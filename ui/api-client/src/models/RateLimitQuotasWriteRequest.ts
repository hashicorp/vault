/* tslint:disable */
/* eslint-disable */
/**
 * HashiCorp Vault API
 * HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.
 *
 * The version of the OpenAPI document: 1.21.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface RateLimitQuotasWriteRequest
 */
export interface RateLimitQuotasWriteRequest {
    /**
     * If set, when a client reaches a rate limit threshold, the client will be prohibited from any further requests until after the 'block_interval' has elapsed.
     * @type {string}
     * @memberof RateLimitQuotasWriteRequest
     */
    blockInterval?: string;
    /**
     * Attribute by which to group requests by. Valid group_by modes are: 1) "ip" that groups requests by their source IP address (group_by defaults to ip if unset); 2) "none" that groups all requests that match the rate limit quota rule together; 3) "entity_then_ip" that groups requests by their entity ID for authenticated requests that carry one, or by their IP for unauthenticated requests (or requests whose authentication is not connected to an entity); and 4) "entity_then_none" which also groups requests by their entity ID when available, but the rest is all grouped together (i.e. unauthenticated or with authentication not connected to an entity).
     * @type {string}
     * @memberof RateLimitQuotasWriteRequest
     */
    groupBy?: string;
    /**
     * Whether all child namespaces can inherit this namespace quota.
     * @type {boolean}
     * @memberof RateLimitQuotasWriteRequest
     */
    inheritable?: boolean;
    /**
     * The duration to enforce rate limiting for (default '1s').
     * @type {string}
     * @memberof RateLimitQuotasWriteRequest
     */
    interval?: string;
    /**
     * Path of the mount or namespace to apply the quota. A blank path configures a global quota. For example namespace1/ adds a quota to a full namespace, namespace1/auth/userpass adds a quota to userpass in namespace1.
     * @type {string}
     * @memberof RateLimitQuotasWriteRequest
     */
    path?: string;
    /**
     * The maximum number of requests in a given interval to be allowed by the quota rule. The 'rate' must be positive.
     * @type {number}
     * @memberof RateLimitQuotasWriteRequest
     */
    rate?: number;
    /**
     * Login role to apply this quota to. Note that when set, path must be configured to a valid auth method with a concept of roles.
     * @type {string}
     * @memberof RateLimitQuotasWriteRequest
     */
    role?: string;
    /**
     * Only available when using the "entity_then_ip" or "entity_then_none" group_by modes. This is the rate limit applied to the requests that fall under the "ip" or "none" groupings, while the authenticated requests that contain an entity ID are subject to the "rate" field instead. Defaults to the same value as "rate".
     * @type {number}
     * @memberof RateLimitQuotasWriteRequest
     */
    secondaryRate?: number;
    /**
     * Type of the quota rule.
     * @type {string}
     * @memberof RateLimitQuotasWriteRequest
     */
    type?: string;
}

/**
 * Check if a given object implements the RateLimitQuotasWriteRequest interface.
 */
export function instanceOfRateLimitQuotasWriteRequest(value: object): value is RateLimitQuotasWriteRequest {
    return true;
}

export function RateLimitQuotasWriteRequestFromJSON(json: any): RateLimitQuotasWriteRequest {
    return RateLimitQuotasWriteRequestFromJSONTyped(json, false);
}

export function RateLimitQuotasWriteRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): RateLimitQuotasWriteRequest {
    if (json == null) {
        return json;
    }
    return {
        
        'blockInterval': json['block_interval'] == null ? undefined : json['block_interval'],
        'groupBy': json['group_by'] == null ? undefined : json['group_by'],
        'inheritable': json['inheritable'] == null ? undefined : json['inheritable'],
        'interval': json['interval'] == null ? undefined : json['interval'],
        'path': json['path'] == null ? undefined : json['path'],
        'rate': json['rate'] == null ? undefined : json['rate'],
        'role': json['role'] == null ? undefined : json['role'],
        'secondaryRate': json['secondary_rate'] == null ? undefined : json['secondary_rate'],
        'type': json['type'] == null ? undefined : json['type'],
    };
}

export function RateLimitQuotasWriteRequestToJSON(json: any): RateLimitQuotasWriteRequest {
    return RateLimitQuotasWriteRequestToJSONTyped(json, false);
}

export function RateLimitQuotasWriteRequestToJSONTyped(value?: RateLimitQuotasWriteRequest | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }

    return {
        
        'block_interval': value['blockInterval'],
        'group_by': value['groupBy'],
        'inheritable': value['inheritable'],
        'interval': value['interval'],
        'path': value['path'],
        'rate': value['rate'],
        'role': value['role'],
        'secondary_rate': value['secondaryRate'],
        'type': value['type'],
    };
}

