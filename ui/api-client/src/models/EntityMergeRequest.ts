/* tslint:disable */
/* eslint-disable */
/**
 * HashiCorp Vault API
 * HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.
 *
 * The version of the OpenAPI document: 1.20.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface EntityMergeRequest
 */
export interface EntityMergeRequest {
    /**
     * Alias IDs to keep in case of conflicting aliases. Ignored if no conflicting aliases found
     * @type {Array<string>}
     * @memberof EntityMergeRequest
     */
    conflictingAliasIdsToKeep?: Array<string>;
    /**
     * Setting this will follow the 'mine' strategy for merging MFA secrets. If there are secrets of the same type both in entities that are merged from and in entity into which all others are getting merged, secrets in the destination will be unaltered. If not set, this API will throw an error containing all the conflicts.
     * @type {boolean}
     * @memberof EntityMergeRequest
     */
    force?: boolean;
    /**
     * Entity IDs which need to get merged
     * @type {Array<string>}
     * @memberof EntityMergeRequest
     */
    fromEntityIds?: Array<string>;
    /**
     * Entity ID into which all the other entities need to get merged
     * @type {string}
     * @memberof EntityMergeRequest
     */
    toEntityId?: string;
}

/**
 * Check if a given object implements the EntityMergeRequest interface.
 */
export function instanceOfEntityMergeRequest(value: object): value is EntityMergeRequest {
    return true;
}

export function EntityMergeRequestFromJSON(json: any): EntityMergeRequest {
    return EntityMergeRequestFromJSONTyped(json, false);
}

export function EntityMergeRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): EntityMergeRequest {
    if (json == null) {
        return json;
    }
    return {
        
        'conflictingAliasIdsToKeep': json['conflicting_alias_ids_to_keep'] == null ? undefined : json['conflicting_alias_ids_to_keep'],
        'force': json['force'] == null ? undefined : json['force'],
        'fromEntityIds': json['from_entity_ids'] == null ? undefined : json['from_entity_ids'],
        'toEntityId': json['to_entity_id'] == null ? undefined : json['to_entity_id'],
    };
}

export function EntityMergeRequestToJSON(json: any): EntityMergeRequest {
    return EntityMergeRequestToJSONTyped(json, false);
}

export function EntityMergeRequestToJSONTyped(value?: EntityMergeRequest | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }

    return {
        
        'conflicting_alias_ids_to_keep': value['conflictingAliasIdsToKeep'],
        'force': value['force'],
        'from_entity_ids': value['fromEntityIds'],
        'to_entity_id': value['toEntityId'],
    };
}

