/* tslint:disable */
/* eslint-disable */
/**
 * HashiCorp Vault API
 * HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.
 *
 * The version of the OpenAPI document: 1.19.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AuditingCalculateHashRequest,
  AuditingCalculateHashResponse,
  AuditingEnableDeviceRequest,
  AuditingEnableRequestHeaderRequest,
  AuditingListRequestHeadersResponse,
  AuthEnableMethodRequest,
  AuthReadConfigurationResponse,
  AuthReadTuningInformationResponse,
  AuthTuneConfigurationParametersRequest,
  CollectHostInformationResponse,
  CorsConfigureRequest,
  CorsReadConfigurationResponse,
  DecodeTokenRequest,
  EncryptionKeyConfigureRotationRequest,
  EncryptionKeyReadRotationConfigurationResponse,
  GenerateHashRequest,
  GenerateHashResponse,
  GenerateHashWithAlgorithmRequest,
  GenerateHashWithAlgorithmResponse,
  GenerateRandomRequest,
  GenerateRandomResponse,
  GenerateRandomWithBytesRequest,
  GenerateRandomWithBytesResponse,
  GenerateRandomWithSourceAndBytesRequest,
  GenerateRandomWithSourceAndBytesResponse,
  GenerateRandomWithSourceRequest,
  GenerateRandomWithSourceResponse,
  HaStatusResponse,
  InitializeRequest,
  InternalClientActivityConfigureRequest,
  InternalCountEntitiesResponse,
  InternalCountTokensResponse,
  InternalGenerateOpenApiDocumentWithParametersRequest,
  InternalUiListEnabledFeatureFlagsResponse,
  InternalUiListEnabledVisibleMountsResponse,
  InternalUiListNamespacesResponse,
  InternalUiReadAuthenticatedActiveCustomMessagesResponse,
  InternalUiReadMountInformationResponse,
  InternalUiReadResultantAclResponse,
  InternalUiReadUnauthenticatedActiveCustomMessagesResponse,
  LeaderStatusResponse,
  LeasesCountResponse,
  LeasesListResponse,
  LeasesLookUpResponse,
  LeasesReadLeaseRequest,
  LeasesReadLeaseResponse,
  LeasesRenewLease2Request,
  LeasesRenewLeaseRequest,
  LeasesRenewLeaseWithId2Request,
  LeasesRenewLeaseWithIdRequest,
  LeasesRevokeLease2Request,
  LeasesRevokeLeaseRequest,
  LeasesRevokeLeaseWithId2Request,
  LeasesRevokeLeaseWithIdRequest,
  LeasesRevokeLeaseWithPrefix2Request,
  LeasesRevokeLeaseWithPrefixRequest,
  LoggersUpdateVerbosityLevelForRequest,
  LoggersUpdateVerbosityLevelRequest,
  MfaValidateRequest,
  MountsEnableSecretsEngineRequest,
  MountsReadConfigurationResponse,
  MountsReadTuningInformationResponse,
  MountsTuneConfigurationParametersRequest,
  PluginsCatalogListPluginsResponse,
  PluginsCatalogListPluginsWithTypeResponse,
  PluginsCatalogPinsCreatePinnedVersionRequest,
  PluginsCatalogPinsListPinnedVersionsResponse,
  PluginsCatalogPinsReadPinnedVersionResponse,
  PluginsCatalogReadPluginConfigurationResponse,
  PluginsCatalogReadPluginConfigurationWithTypeResponse,
  PluginsCatalogRegisterPluginRequest,
  PluginsCatalogRegisterPluginWithTypeRequest,
  PluginsReloadBackendsRequest,
  PluginsReloadBackendsResponse,
  PluginsRuntimesCatalogListPluginsRuntimesResponse,
  PluginsRuntimesCatalogReadPluginRuntimeConfigurationResponse,
  PluginsRuntimesCatalogRegisterPluginRuntimeRequest,
  PoliciesGeneratePasswordFromPasswordPolicyResponse,
  PoliciesListAclPolicies2Response,
  PoliciesListAclPolicies3Response,
  PoliciesListAclPoliciesResponse,
  PoliciesReadAclPolicy2Response,
  PoliciesReadAclPolicyResponse,
  PoliciesReadPasswordPolicyResponse,
  PoliciesWriteAclPolicy2Request,
  PoliciesWriteAclPolicyRequest,
  PoliciesWritePasswordPolicyRequest,
  QueryTokenAccessorCapabilitiesRequest,
  QueryTokenCapabilitiesRequest,
  QueryTokenSelfCapabilitiesRequest,
  RateLimitQuotasConfigureRequest,
  RateLimitQuotasReadConfigurationResponse,
  RateLimitQuotasReadResponse,
  RateLimitQuotasWriteRequest,
  RawReadResponse,
  RawWriteRequest,
  ReadWrappingProperties2Response,
  ReadWrappingPropertiesRequest,
  ReadWrappingPropertiesResponse,
  RekeyAttemptInitializeRequest,
  RekeyAttemptInitializeResponse,
  RekeyAttemptReadProgressResponse,
  RekeyAttemptUpdateRequest,
  RekeyAttemptUpdateResponse,
  RekeyReadBackupKeyResponse,
  RekeyReadBackupRecoveryKeyResponse,
  RekeyVerificationCancelResponse,
  RekeyVerificationReadProgressResponse,
  RekeyVerificationUpdateRequest,
  RekeyVerificationUpdateResponse,
  ReloadPluginsRequest,
  ReloadPluginsResponse,
  RemountRequest,
  RemountResponse,
  RemountStatusResponse,
  RewrapRequest,
  RootTokenGenerationInitialize2Request,
  RootTokenGenerationInitialize2Response,
  RootTokenGenerationInitializeRequest,
  RootTokenGenerationInitializeResponse,
  RootTokenGenerationReadProgress2Response,
  RootTokenGenerationReadProgressResponse,
  RootTokenGenerationUpdateRequest,
  RootTokenGenerationUpdateResponse,
  SealStatusResponse,
  StandardListResponse,
  SystemWriteInternalCountersActivityWriteRequest,
  UiHeadersConfigureRequest,
  UiHeadersListResponse,
  UiHeadersReadConfigurationResponse,
  UnsealRequest,
  UnsealResponse,
  UnwrapRequest,
  VersionHistoryResponse,
  WellKnownListLabels2Response,
  WellKnownListLabelsResponse,
  WellKnownReadLabelResponse,
} from '../models/index';
import {
    AuditingCalculateHashRequestFromJSON,
    AuditingCalculateHashRequestToJSON,
    AuditingCalculateHashResponseFromJSON,
    AuditingCalculateHashResponseToJSON,
    AuditingEnableDeviceRequestFromJSON,
    AuditingEnableDeviceRequestToJSON,
    AuditingEnableRequestHeaderRequestFromJSON,
    AuditingEnableRequestHeaderRequestToJSON,
    AuditingListRequestHeadersResponseFromJSON,
    AuditingListRequestHeadersResponseToJSON,
    AuthEnableMethodRequestFromJSON,
    AuthEnableMethodRequestToJSON,
    AuthReadConfigurationResponseFromJSON,
    AuthReadConfigurationResponseToJSON,
    AuthReadTuningInformationResponseFromJSON,
    AuthReadTuningInformationResponseToJSON,
    AuthTuneConfigurationParametersRequestFromJSON,
    AuthTuneConfigurationParametersRequestToJSON,
    CollectHostInformationResponseFromJSON,
    CollectHostInformationResponseToJSON,
    CorsConfigureRequestFromJSON,
    CorsConfigureRequestToJSON,
    CorsReadConfigurationResponseFromJSON,
    CorsReadConfigurationResponseToJSON,
    DecodeTokenRequestFromJSON,
    DecodeTokenRequestToJSON,
    EncryptionKeyConfigureRotationRequestFromJSON,
    EncryptionKeyConfigureRotationRequestToJSON,
    EncryptionKeyReadRotationConfigurationResponseFromJSON,
    EncryptionKeyReadRotationConfigurationResponseToJSON,
    GenerateHashRequestFromJSON,
    GenerateHashRequestToJSON,
    GenerateHashResponseFromJSON,
    GenerateHashResponseToJSON,
    GenerateHashWithAlgorithmRequestFromJSON,
    GenerateHashWithAlgorithmRequestToJSON,
    GenerateHashWithAlgorithmResponseFromJSON,
    GenerateHashWithAlgorithmResponseToJSON,
    GenerateRandomRequestFromJSON,
    GenerateRandomRequestToJSON,
    GenerateRandomResponseFromJSON,
    GenerateRandomResponseToJSON,
    GenerateRandomWithBytesRequestFromJSON,
    GenerateRandomWithBytesRequestToJSON,
    GenerateRandomWithBytesResponseFromJSON,
    GenerateRandomWithBytesResponseToJSON,
    GenerateRandomWithSourceAndBytesRequestFromJSON,
    GenerateRandomWithSourceAndBytesRequestToJSON,
    GenerateRandomWithSourceAndBytesResponseFromJSON,
    GenerateRandomWithSourceAndBytesResponseToJSON,
    GenerateRandomWithSourceRequestFromJSON,
    GenerateRandomWithSourceRequestToJSON,
    GenerateRandomWithSourceResponseFromJSON,
    GenerateRandomWithSourceResponseToJSON,
    HaStatusResponseFromJSON,
    HaStatusResponseToJSON,
    InitializeRequestFromJSON,
    InitializeRequestToJSON,
    InternalClientActivityConfigureRequestFromJSON,
    InternalClientActivityConfigureRequestToJSON,
    InternalCountEntitiesResponseFromJSON,
    InternalCountEntitiesResponseToJSON,
    InternalCountTokensResponseFromJSON,
    InternalCountTokensResponseToJSON,
    InternalGenerateOpenApiDocumentWithParametersRequestFromJSON,
    InternalGenerateOpenApiDocumentWithParametersRequestToJSON,
    InternalUiListEnabledFeatureFlagsResponseFromJSON,
    InternalUiListEnabledFeatureFlagsResponseToJSON,
    InternalUiListEnabledVisibleMountsResponseFromJSON,
    InternalUiListEnabledVisibleMountsResponseToJSON,
    InternalUiListNamespacesResponseFromJSON,
    InternalUiListNamespacesResponseToJSON,
    InternalUiReadAuthenticatedActiveCustomMessagesResponseFromJSON,
    InternalUiReadAuthenticatedActiveCustomMessagesResponseToJSON,
    InternalUiReadMountInformationResponseFromJSON,
    InternalUiReadMountInformationResponseToJSON,
    InternalUiReadResultantAclResponseFromJSON,
    InternalUiReadResultantAclResponseToJSON,
    InternalUiReadUnauthenticatedActiveCustomMessagesResponseFromJSON,
    InternalUiReadUnauthenticatedActiveCustomMessagesResponseToJSON,
    LeaderStatusResponseFromJSON,
    LeaderStatusResponseToJSON,
    LeasesCountResponseFromJSON,
    LeasesCountResponseToJSON,
    LeasesListResponseFromJSON,
    LeasesListResponseToJSON,
    LeasesLookUpResponseFromJSON,
    LeasesLookUpResponseToJSON,
    LeasesReadLeaseRequestFromJSON,
    LeasesReadLeaseRequestToJSON,
    LeasesReadLeaseResponseFromJSON,
    LeasesReadLeaseResponseToJSON,
    LeasesRenewLease2RequestFromJSON,
    LeasesRenewLease2RequestToJSON,
    LeasesRenewLeaseRequestFromJSON,
    LeasesRenewLeaseRequestToJSON,
    LeasesRenewLeaseWithId2RequestFromJSON,
    LeasesRenewLeaseWithId2RequestToJSON,
    LeasesRenewLeaseWithIdRequestFromJSON,
    LeasesRenewLeaseWithIdRequestToJSON,
    LeasesRevokeLease2RequestFromJSON,
    LeasesRevokeLease2RequestToJSON,
    LeasesRevokeLeaseRequestFromJSON,
    LeasesRevokeLeaseRequestToJSON,
    LeasesRevokeLeaseWithId2RequestFromJSON,
    LeasesRevokeLeaseWithId2RequestToJSON,
    LeasesRevokeLeaseWithIdRequestFromJSON,
    LeasesRevokeLeaseWithIdRequestToJSON,
    LeasesRevokeLeaseWithPrefix2RequestFromJSON,
    LeasesRevokeLeaseWithPrefix2RequestToJSON,
    LeasesRevokeLeaseWithPrefixRequestFromJSON,
    LeasesRevokeLeaseWithPrefixRequestToJSON,
    LoggersUpdateVerbosityLevelForRequestFromJSON,
    LoggersUpdateVerbosityLevelForRequestToJSON,
    LoggersUpdateVerbosityLevelRequestFromJSON,
    LoggersUpdateVerbosityLevelRequestToJSON,
    MfaValidateRequestFromJSON,
    MfaValidateRequestToJSON,
    MountsEnableSecretsEngineRequestFromJSON,
    MountsEnableSecretsEngineRequestToJSON,
    MountsReadConfigurationResponseFromJSON,
    MountsReadConfigurationResponseToJSON,
    MountsReadTuningInformationResponseFromJSON,
    MountsReadTuningInformationResponseToJSON,
    MountsTuneConfigurationParametersRequestFromJSON,
    MountsTuneConfigurationParametersRequestToJSON,
    PluginsCatalogListPluginsResponseFromJSON,
    PluginsCatalogListPluginsResponseToJSON,
    PluginsCatalogListPluginsWithTypeResponseFromJSON,
    PluginsCatalogListPluginsWithTypeResponseToJSON,
    PluginsCatalogPinsCreatePinnedVersionRequestFromJSON,
    PluginsCatalogPinsCreatePinnedVersionRequestToJSON,
    PluginsCatalogPinsListPinnedVersionsResponseFromJSON,
    PluginsCatalogPinsListPinnedVersionsResponseToJSON,
    PluginsCatalogPinsReadPinnedVersionResponseFromJSON,
    PluginsCatalogPinsReadPinnedVersionResponseToJSON,
    PluginsCatalogReadPluginConfigurationResponseFromJSON,
    PluginsCatalogReadPluginConfigurationResponseToJSON,
    PluginsCatalogReadPluginConfigurationWithTypeResponseFromJSON,
    PluginsCatalogReadPluginConfigurationWithTypeResponseToJSON,
    PluginsCatalogRegisterPluginRequestFromJSON,
    PluginsCatalogRegisterPluginRequestToJSON,
    PluginsCatalogRegisterPluginWithTypeRequestFromJSON,
    PluginsCatalogRegisterPluginWithTypeRequestToJSON,
    PluginsReloadBackendsRequestFromJSON,
    PluginsReloadBackendsRequestToJSON,
    PluginsReloadBackendsResponseFromJSON,
    PluginsReloadBackendsResponseToJSON,
    PluginsRuntimesCatalogListPluginsRuntimesResponseFromJSON,
    PluginsRuntimesCatalogListPluginsRuntimesResponseToJSON,
    PluginsRuntimesCatalogReadPluginRuntimeConfigurationResponseFromJSON,
    PluginsRuntimesCatalogReadPluginRuntimeConfigurationResponseToJSON,
    PluginsRuntimesCatalogRegisterPluginRuntimeRequestFromJSON,
    PluginsRuntimesCatalogRegisterPluginRuntimeRequestToJSON,
    PoliciesGeneratePasswordFromPasswordPolicyResponseFromJSON,
    PoliciesGeneratePasswordFromPasswordPolicyResponseToJSON,
    PoliciesListAclPolicies2ResponseFromJSON,
    PoliciesListAclPolicies2ResponseToJSON,
    PoliciesListAclPolicies3ResponseFromJSON,
    PoliciesListAclPolicies3ResponseToJSON,
    PoliciesListAclPoliciesResponseFromJSON,
    PoliciesListAclPoliciesResponseToJSON,
    PoliciesReadAclPolicy2ResponseFromJSON,
    PoliciesReadAclPolicy2ResponseToJSON,
    PoliciesReadAclPolicyResponseFromJSON,
    PoliciesReadAclPolicyResponseToJSON,
    PoliciesReadPasswordPolicyResponseFromJSON,
    PoliciesReadPasswordPolicyResponseToJSON,
    PoliciesWriteAclPolicy2RequestFromJSON,
    PoliciesWriteAclPolicy2RequestToJSON,
    PoliciesWriteAclPolicyRequestFromJSON,
    PoliciesWriteAclPolicyRequestToJSON,
    PoliciesWritePasswordPolicyRequestFromJSON,
    PoliciesWritePasswordPolicyRequestToJSON,
    QueryTokenAccessorCapabilitiesRequestFromJSON,
    QueryTokenAccessorCapabilitiesRequestToJSON,
    QueryTokenCapabilitiesRequestFromJSON,
    QueryTokenCapabilitiesRequestToJSON,
    QueryTokenSelfCapabilitiesRequestFromJSON,
    QueryTokenSelfCapabilitiesRequestToJSON,
    RateLimitQuotasConfigureRequestFromJSON,
    RateLimitQuotasConfigureRequestToJSON,
    RateLimitQuotasReadConfigurationResponseFromJSON,
    RateLimitQuotasReadConfigurationResponseToJSON,
    RateLimitQuotasReadResponseFromJSON,
    RateLimitQuotasReadResponseToJSON,
    RateLimitQuotasWriteRequestFromJSON,
    RateLimitQuotasWriteRequestToJSON,
    RawReadResponseFromJSON,
    RawReadResponseToJSON,
    RawWriteRequestFromJSON,
    RawWriteRequestToJSON,
    ReadWrappingProperties2ResponseFromJSON,
    ReadWrappingProperties2ResponseToJSON,
    ReadWrappingPropertiesRequestFromJSON,
    ReadWrappingPropertiesRequestToJSON,
    ReadWrappingPropertiesResponseFromJSON,
    ReadWrappingPropertiesResponseToJSON,
    RekeyAttemptInitializeRequestFromJSON,
    RekeyAttemptInitializeRequestToJSON,
    RekeyAttemptInitializeResponseFromJSON,
    RekeyAttemptInitializeResponseToJSON,
    RekeyAttemptReadProgressResponseFromJSON,
    RekeyAttemptReadProgressResponseToJSON,
    RekeyAttemptUpdateRequestFromJSON,
    RekeyAttemptUpdateRequestToJSON,
    RekeyAttemptUpdateResponseFromJSON,
    RekeyAttemptUpdateResponseToJSON,
    RekeyReadBackupKeyResponseFromJSON,
    RekeyReadBackupKeyResponseToJSON,
    RekeyReadBackupRecoveryKeyResponseFromJSON,
    RekeyReadBackupRecoveryKeyResponseToJSON,
    RekeyVerificationCancelResponseFromJSON,
    RekeyVerificationCancelResponseToJSON,
    RekeyVerificationReadProgressResponseFromJSON,
    RekeyVerificationReadProgressResponseToJSON,
    RekeyVerificationUpdateRequestFromJSON,
    RekeyVerificationUpdateRequestToJSON,
    RekeyVerificationUpdateResponseFromJSON,
    RekeyVerificationUpdateResponseToJSON,
    ReloadPluginsRequestFromJSON,
    ReloadPluginsRequestToJSON,
    ReloadPluginsResponseFromJSON,
    ReloadPluginsResponseToJSON,
    RemountRequestFromJSON,
    RemountRequestToJSON,
    RemountResponseFromJSON,
    RemountResponseToJSON,
    RemountStatusResponseFromJSON,
    RemountStatusResponseToJSON,
    RewrapRequestFromJSON,
    RewrapRequestToJSON,
    RootTokenGenerationInitialize2RequestFromJSON,
    RootTokenGenerationInitialize2RequestToJSON,
    RootTokenGenerationInitialize2ResponseFromJSON,
    RootTokenGenerationInitialize2ResponseToJSON,
    RootTokenGenerationInitializeRequestFromJSON,
    RootTokenGenerationInitializeRequestToJSON,
    RootTokenGenerationInitializeResponseFromJSON,
    RootTokenGenerationInitializeResponseToJSON,
    RootTokenGenerationReadProgress2ResponseFromJSON,
    RootTokenGenerationReadProgress2ResponseToJSON,
    RootTokenGenerationReadProgressResponseFromJSON,
    RootTokenGenerationReadProgressResponseToJSON,
    RootTokenGenerationUpdateRequestFromJSON,
    RootTokenGenerationUpdateRequestToJSON,
    RootTokenGenerationUpdateResponseFromJSON,
    RootTokenGenerationUpdateResponseToJSON,
    SealStatusResponseFromJSON,
    SealStatusResponseToJSON,
    StandardListResponseFromJSON,
    StandardListResponseToJSON,
    SystemWriteInternalCountersActivityWriteRequestFromJSON,
    SystemWriteInternalCountersActivityWriteRequestToJSON,
    UiHeadersConfigureRequestFromJSON,
    UiHeadersConfigureRequestToJSON,
    UiHeadersListResponseFromJSON,
    UiHeadersListResponseToJSON,
    UiHeadersReadConfigurationResponseFromJSON,
    UiHeadersReadConfigurationResponseToJSON,
    UnsealRequestFromJSON,
    UnsealRequestToJSON,
    UnsealResponseFromJSON,
    UnsealResponseToJSON,
    UnwrapRequestFromJSON,
    UnwrapRequestToJSON,
    VersionHistoryResponseFromJSON,
    VersionHistoryResponseToJSON,
    WellKnownListLabels2ResponseFromJSON,
    WellKnownListLabels2ResponseToJSON,
    WellKnownListLabelsResponseFromJSON,
    WellKnownListLabelsResponseToJSON,
    WellKnownReadLabelResponseFromJSON,
    WellKnownReadLabelResponseToJSON,
} from '../models/index';

export interface AuditingCalculateHashOperationRequest {
    path: string;
    auditingCalculateHashRequest: AuditingCalculateHashRequest;
}

export interface AuditingDisableDeviceRequest {
    path: string;
}

export interface AuditingDisableRequestHeaderRequest {
    header: string;
}

export interface AuditingEnableDeviceOperationRequest {
    path: string;
    auditingEnableDeviceRequest: AuditingEnableDeviceRequest;
}

export interface AuditingEnableRequestHeaderOperationRequest {
    header: string;
    auditingEnableRequestHeaderRequest: AuditingEnableRequestHeaderRequest;
}

export interface AuditingReadRequestHeaderInformationRequest {
    header: string;
}

export interface AuthDisableMethodRequest {
    path: string;
}

export interface AuthEnableMethodOperationRequest {
    path: string;
    authEnableMethodRequest: AuthEnableMethodRequest;
}

export interface AuthReadConfigurationRequest {
    path: string;
}

export interface AuthReadTuningInformationRequest {
    path: string;
}

export interface AuthTuneConfigurationParametersOperationRequest {
    path: string;
    authTuneConfigurationParametersRequest: AuthTuneConfigurationParametersRequest;
}

export interface CorsConfigureOperationRequest {
    corsConfigureRequest: CorsConfigureRequest;
}

export interface DecodeTokenOperationRequest {
    decodeTokenRequest: DecodeTokenRequest;
}

export interface EncryptionKeyConfigureRotationOperationRequest {
    encryptionKeyConfigureRotationRequest: EncryptionKeyConfigureRotationRequest;
}

export interface EnterpriseStubDeleteManagedKeysTypeNameRequest {
    name: string;
    type: string;
}

export interface EnterpriseStubDeleteMfaMethodDuoNameRequest {
    name: string;
}

export interface EnterpriseStubDeleteMfaMethodOktaNameRequest {
    name: string;
}

export interface EnterpriseStubDeleteMfaMethodPingidNameRequest {
    name: string;
}

export interface EnterpriseStubDeleteMfaMethodTotpNameRequest {
    name: string;
}

export interface EnterpriseStubDeleteNamespacesPathRequest {
    path: string;
}

export interface EnterpriseStubDeletePoliciesEgpNameRequest {
    name: string;
}

export interface EnterpriseStubDeletePoliciesRgpNameRequest {
    name: string;
}

export interface EnterpriseStubDeleteQuotasLeaseCountNameRequest {
    name: string;
}

export interface EnterpriseStubDeleteReplicationPerformancePrimaryPathsFilterIdRequest {
    id: string;
}

export interface EnterpriseStubDeleteStorageRaftSnapshotAutoConfigNameRequest {
    name: string;
}

export interface EnterpriseStubListManagedKeysTypeRequest {
    type: string;
    list: EnterpriseStubListManagedKeysTypeListEnum;
}

export interface EnterpriseStubListMfaMethodRequest {
    list: EnterpriseStubListMfaMethodListEnum;
}

export interface EnterpriseStubListNamespacesRequest {
    list: EnterpriseStubListNamespacesListEnum;
}

export interface EnterpriseStubListPoliciesEgpRequest {
    list: EnterpriseStubListPoliciesEgpListEnum;
}

export interface EnterpriseStubListPoliciesRgpRequest {
    list: EnterpriseStubListPoliciesRgpListEnum;
}

export interface EnterpriseStubListQuotasLeaseCountRequest {
    list: EnterpriseStubListQuotasLeaseCountListEnum;
}

export interface EnterpriseStubListStorageRaftSnapshotAutoConfigRequest {
    list: EnterpriseStubListStorageRaftSnapshotAutoConfigListEnum;
}

export interface EnterpriseStubReadManagedKeysTypeNameRequest {
    name: string;
    type: string;
}

export interface EnterpriseStubReadMfaMethodDuoNameRequest {
    name: string;
}

export interface EnterpriseStubReadMfaMethodOktaNameRequest {
    name: string;
}

export interface EnterpriseStubReadMfaMethodPingidNameRequest {
    name: string;
}

export interface EnterpriseStubReadMfaMethodTotpNameRequest {
    name: string;
}

export interface EnterpriseStubReadMfaMethodTotpNameGenerateRequest {
    name: string;
}

export interface EnterpriseStubReadNamespacesPathRequest {
    path: string;
}

export interface EnterpriseStubReadPoliciesEgpNameRequest {
    name: string;
}

export interface EnterpriseStubReadPoliciesRgpNameRequest {
    name: string;
}

export interface EnterpriseStubReadQuotasLeaseCountNameRequest {
    name: string;
}

export interface EnterpriseStubReadReplicationPerformancePrimaryDynamicFilterIdRequest {
    id: string;
}

export interface EnterpriseStubReadReplicationPerformancePrimaryPathsFilterIdRequest {
    id: string;
}

export interface EnterpriseStubReadReplicationPerformanceSecondaryDynamicFilterIdRequest {
    id: string;
}

export interface EnterpriseStubReadStorageRaftSnapshotAutoConfigNameRequest {
    name: string;
}

export interface EnterpriseStubReadStorageRaftSnapshotAutoStatusNameRequest {
    name: string;
}

export interface EnterpriseStubWriteManagedKeysTypeNameRequest {
    name: string;
    type: string;
}

export interface EnterpriseStubWriteManagedKeysTypeNameTestSignRequest {
    name: string;
    type: string;
}

export interface EnterpriseStubWriteMfaMethodDuoNameRequest {
    name: string;
}

export interface EnterpriseStubWriteMfaMethodOktaNameRequest {
    name: string;
}

export interface EnterpriseStubWriteMfaMethodPingidNameRequest {
    name: string;
}

export interface EnterpriseStubWriteMfaMethodTotpNameRequest {
    name: string;
}

export interface EnterpriseStubWriteMfaMethodTotpNameAdminDestroyRequest {
    name: string;
}

export interface EnterpriseStubWriteMfaMethodTotpNameAdminGenerateRequest {
    name: string;
}

export interface EnterpriseStubWriteNamespacesApiLockLockPathRequest {
    path: string;
}

export interface EnterpriseStubWriteNamespacesApiLockUnlockPathRequest {
    path: string;
}

export interface EnterpriseStubWriteNamespacesPathRequest {
    path: string;
}

export interface EnterpriseStubWritePoliciesEgpNameRequest {
    name: string;
}

export interface EnterpriseStubWritePoliciesRgpNameRequest {
    name: string;
}

export interface EnterpriseStubWriteQuotasLeaseCountNameRequest {
    name: string;
}

export interface EnterpriseStubWriteReplicationDrSecondaryConfigReloadSubsystemRequest {
    subsystem: string;
}

export interface EnterpriseStubWriteReplicationPerformancePrimaryPathsFilterIdRequest {
    id: string;
}

export interface EnterpriseStubWriteStorageRaftSnapshotAutoConfigNameRequest {
    name: string;
}

export interface GenerateHashOperationRequest {
    generateHashRequest: GenerateHashRequest;
}

export interface GenerateHashWithAlgorithmOperationRequest {
    urlalgorithm: string;
    generateHashWithAlgorithmRequest: GenerateHashWithAlgorithmRequest;
}

export interface GenerateRandomOperationRequest {
    generateRandomRequest: GenerateRandomRequest;
}

export interface GenerateRandomWithBytesOperationRequest {
    urlbytes: string;
    generateRandomWithBytesRequest: GenerateRandomWithBytesRequest;
}

export interface GenerateRandomWithSourceOperationRequest {
    source: string;
    generateRandomWithSourceRequest: GenerateRandomWithSourceRequest;
}

export interface GenerateRandomWithSourceAndBytesOperationRequest {
    source: string;
    urlbytes: string;
    generateRandomWithSourceAndBytesRequest: GenerateRandomWithSourceAndBytesRequest;
}

export interface InitializeOperationRequest {
    initializeRequest: InitializeRequest;
}

export interface InternalClientActivityConfigureOperationRequest {
    internalClientActivityConfigureRequest: InternalClientActivityConfigureRequest;
}

export interface InternalGenerateOpenApiDocumentRequest {
    context?: string;
    genericMountPaths?: boolean;
}

export interface InternalGenerateOpenApiDocumentWithParametersOperationRequest {
    internalGenerateOpenApiDocumentWithParametersRequest: InternalGenerateOpenApiDocumentWithParametersRequest;
}

export interface InternalInspectRouterRequest {
    tag: string;
}

export interface InternalUiReadMountInformationRequest {
    path: string;
}

export interface LeasesForceRevokeLeaseWithPrefixRequest {
    prefix: string;
}

export interface LeasesForceRevokeLeaseWithPrefix2Request {
    prefix: string;
}

export interface LeasesLookUpRequest {
    prefix: string;
    list: LeasesLookUpListEnum;
}

export interface LeasesReadLeaseOperationRequest {
    leasesReadLeaseRequest: LeasesReadLeaseRequest;
}

export interface LeasesRenewLeaseOperationRequest {
    leasesRenewLeaseRequest: LeasesRenewLeaseRequest;
}

export interface LeasesRenewLease2OperationRequest {
    leasesRenewLease2Request: LeasesRenewLease2Request;
}

export interface LeasesRenewLeaseWithIdOperationRequest {
    urlLeaseId: string;
    leasesRenewLeaseWithIdRequest: LeasesRenewLeaseWithIdRequest;
}

export interface LeasesRenewLeaseWithId2OperationRequest {
    urlLeaseId: string;
    leasesRenewLeaseWithId2Request: LeasesRenewLeaseWithId2Request;
}

export interface LeasesRevokeLeaseOperationRequest {
    leasesRevokeLeaseRequest: LeasesRevokeLeaseRequest;
}

export interface LeasesRevokeLease2OperationRequest {
    leasesRevokeLease2Request: LeasesRevokeLease2Request;
}

export interface LeasesRevokeLeaseWithIdOperationRequest {
    urlLeaseId: string;
    leasesRevokeLeaseWithIdRequest: LeasesRevokeLeaseWithIdRequest;
}

export interface LeasesRevokeLeaseWithId2OperationRequest {
    urlLeaseId: string;
    leasesRevokeLeaseWithId2Request: LeasesRevokeLeaseWithId2Request;
}

export interface LeasesRevokeLeaseWithPrefixOperationRequest {
    prefix: string;
    leasesRevokeLeaseWithPrefixRequest: LeasesRevokeLeaseWithPrefixRequest;
}

export interface LeasesRevokeLeaseWithPrefix2OperationRequest {
    prefix: string;
    leasesRevokeLeaseWithPrefix2Request: LeasesRevokeLeaseWithPrefix2Request;
}

export interface LockedUsersUnlockRequest {
    aliasIdentifier: string;
    mountAccessor: string;
}

export interface LoggersReadVerbosityLevelForRequest {
    name: string;
}

export interface LoggersRevertVerbosityLevelForRequest {
    name: string;
}

export interface LoggersUpdateVerbosityLevelOperationRequest {
    loggersUpdateVerbosityLevelRequest: LoggersUpdateVerbosityLevelRequest;
}

export interface LoggersUpdateVerbosityLevelForOperationRequest {
    name: string;
    loggersUpdateVerbosityLevelForRequest: LoggersUpdateVerbosityLevelForRequest;
}

export interface MetricsRequest {
    format?: string;
}

export interface MfaValidateOperationRequest {
    mfaValidateRequest: MfaValidateRequest;
}

export interface MonitorRequest {
    logFormat?: string;
    logLevel?: string;
}

export interface MountsDisableSecretsEngineRequest {
    path: string;
}

export interface MountsEnableSecretsEngineOperationRequest {
    path: string;
    mountsEnableSecretsEngineRequest: MountsEnableSecretsEngineRequest;
}

export interface MountsReadConfigurationRequest {
    path: string;
}

export interface MountsReadTuningInformationRequest {
    path: string;
}

export interface MountsTuneConfigurationParametersOperationRequest {
    path: string;
    mountsTuneConfigurationParametersRequest: MountsTuneConfigurationParametersRequest;
}

export interface PluginsCatalogListPluginsWithTypeRequest {
    type: string;
    list: PluginsCatalogListPluginsWithTypeListEnum;
}

export interface PluginsCatalogPinsCreatePinnedVersionOperationRequest {
    name: string;
    type: string;
    pluginsCatalogPinsCreatePinnedVersionRequest: PluginsCatalogPinsCreatePinnedVersionRequest;
}

export interface PluginsCatalogPinsReadPinnedVersionRequest {
    name: string;
    type: string;
}

export interface PluginsCatalogPinsRemovePinnedVersionRequest {
    name: string;
    type: string;
}

export interface PluginsCatalogReadPluginConfigurationRequest {
    name: string;
}

export interface PluginsCatalogReadPluginConfigurationWithTypeRequest {
    name: string;
    type: string;
}

export interface PluginsCatalogRegisterPluginOperationRequest {
    name: string;
    pluginsCatalogRegisterPluginRequest: PluginsCatalogRegisterPluginRequest;
}

export interface PluginsCatalogRegisterPluginWithTypeOperationRequest {
    name: string;
    type: string;
    pluginsCatalogRegisterPluginWithTypeRequest: PluginsCatalogRegisterPluginWithTypeRequest;
}

export interface PluginsCatalogRemovePluginRequest {
    name: string;
}

export interface PluginsCatalogRemovePluginWithTypeRequest {
    name: string;
    type: string;
}

export interface PluginsReloadBackendsOperationRequest {
    pluginsReloadBackendsRequest: PluginsReloadBackendsRequest;
}

export interface PluginsRuntimesCatalogListPluginsRuntimes0Request {
    list: PluginsRuntimesCatalogListPluginsRuntimes0ListEnum;
}

export interface PluginsRuntimesCatalogReadPluginRuntimeConfigurationRequest {
    name: string;
    type: string;
}

export interface PluginsRuntimesCatalogRegisterPluginRuntimeOperationRequest {
    name: string;
    type: string;
    pluginsRuntimesCatalogRegisterPluginRuntimeRequest: PluginsRuntimesCatalogRegisterPluginRuntimeRequest;
}

export interface PluginsRuntimesCatalogRemovePluginRuntimeRequest {
    name: string;
    type: string;
}

export interface PoliciesDeleteAclPolicyRequest {
    name: string;
}

export interface PoliciesDeleteAclPolicy2Request {
    name: string;
}

export interface PoliciesDeletePasswordPolicyRequest {
    name: string;
}

export interface PoliciesGeneratePasswordFromPasswordPolicyRequest {
    name: string;
}

export interface PoliciesListAclPoliciesRequest {
    list: PoliciesListAclPoliciesListEnum;
}

export interface PoliciesListAclPolicies3Request {
    list: PoliciesListAclPolicies3ListEnum;
}

export interface PoliciesListPasswordPoliciesRequest {
    list: PoliciesListPasswordPoliciesListEnum;
}

export interface PoliciesReadAclPolicyRequest {
    name: string;
}

export interface PoliciesReadAclPolicy2Request {
    name: string;
}

export interface PoliciesReadPasswordPolicyRequest {
    name: string;
}

export interface PoliciesWriteAclPolicyOperationRequest {
    name: string;
    policiesWriteAclPolicyRequest: PoliciesWriteAclPolicyRequest;
}

export interface PoliciesWriteAclPolicy2OperationRequest {
    name: string;
    policiesWriteAclPolicy2Request: PoliciesWriteAclPolicy2Request;
}

export interface PoliciesWritePasswordPolicyOperationRequest {
    name: string;
    policiesWritePasswordPolicyRequest: PoliciesWritePasswordPolicyRequest;
}

export interface QueryTokenAccessorCapabilitiesOperationRequest {
    queryTokenAccessorCapabilitiesRequest: QueryTokenAccessorCapabilitiesRequest;
}

export interface QueryTokenCapabilitiesOperationRequest {
    queryTokenCapabilitiesRequest: QueryTokenCapabilitiesRequest;
}

export interface QueryTokenSelfCapabilitiesOperationRequest {
    queryTokenSelfCapabilitiesRequest: QueryTokenSelfCapabilitiesRequest;
}

export interface RateLimitQuotasConfigureOperationRequest {
    rateLimitQuotasConfigureRequest: RateLimitQuotasConfigureRequest;
}

export interface RateLimitQuotasDeleteRequest {
    name: string;
}

export interface RateLimitQuotasListRequest {
    list: RateLimitQuotasListListEnum;
}

export interface RateLimitQuotasReadRequest {
    name: string;
}

export interface RateLimitQuotasWriteOperationRequest {
    name: string;
    rateLimitQuotasWriteRequest: RateLimitQuotasWriteRequest;
}

export interface RawDeleteRequest {
    path: string;
}

export interface RawListRequest {
    path: string;
    list: RawListListEnum;
}

export interface RawReadRequest {
    path: string;
}

export interface RawWriteOperationRequest {
    path: string;
    rawWriteRequest: RawWriteRequest;
}

export interface ReadWrappingPropertiesOperationRequest {
    readWrappingPropertiesRequest: ReadWrappingPropertiesRequest;
}

export interface ReadWrappingProperties2Request {
    token?: string;
}

export interface RekeyAttemptInitializeOperationRequest {
    rekeyAttemptInitializeRequest: RekeyAttemptInitializeRequest;
}

export interface RekeyAttemptUpdateOperationRequest {
    rekeyAttemptUpdateRequest: RekeyAttemptUpdateRequest;
}

export interface RekeyVerificationUpdateOperationRequest {
    rekeyVerificationUpdateRequest: RekeyVerificationUpdateRequest;
}

export interface ReloadPluginsOperationRequest {
    name: string;
    type: string;
    reloadPluginsRequest: ReloadPluginsRequest;
}

export interface ReloadSubsystemRequest {
    subsystem: string;
}

export interface RemountOperationRequest {
    remountRequest: RemountRequest;
}

export interface RemountStatusRequest {
    migrationId: string;
}

export interface RewrapOperationRequest {
    rewrapRequest: RewrapRequest;
}

export interface RootTokenGenerationInitializeOperationRequest {
    rootTokenGenerationInitializeRequest: RootTokenGenerationInitializeRequest;
}

export interface RootTokenGenerationInitialize2OperationRequest {
    rootTokenGenerationInitialize2Request: RootTokenGenerationInitialize2Request;
}

export interface RootTokenGenerationUpdateOperationRequest {
    rootTokenGenerationUpdateRequest: RootTokenGenerationUpdateRequest;
}

export interface SystemWriteInternalCountersActivityWriteOperationRequest {
    systemWriteInternalCountersActivityWriteRequest: SystemWriteInternalCountersActivityWriteRequest;
}

export interface UiHeadersConfigureOperationRequest {
    header: string;
    uiHeadersConfigureRequest: UiHeadersConfigureRequest;
}

export interface UiHeadersDeleteConfigurationRequest {
    header: string;
}

export interface UiHeadersListRequest {
    list: UiHeadersListListEnum;
}

export interface UiHeadersReadConfigurationRequest {
    header: string;
}

export interface UnsealOperationRequest {
    unsealRequest: UnsealRequest;
}

export interface UnwrapOperationRequest {
    unwrapRequest: UnwrapRequest;
}

export interface VersionHistoryRequest {
    list: VersionHistoryListEnum;
}

export interface WellKnownListLabelsRequest {
    list: WellKnownListLabelsListEnum;
}

export interface WellKnownReadLabelRequest {
    label: string;
}

export interface WrapRequest {
    requestBody: { [key: string]: any; };
}

/**
 * 
 */
export class SystemApi extends runtime.BaseAPI {

    /**
     * Activate a flagged feature.
     */
    async activationFlagsActivateRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/activation-flags/activation-test/activate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Activate a flagged feature.
     */
    async activationFlagsActivate(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.activationFlagsActivateRaw(initOverrides);
    }

    /**
     * Activate a flagged feature.
     */
    async activationFlagsActivate_1Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/activation-flags/force-identity-deduplication/activate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Activate a flagged feature.
     */
    async activationFlagsActivate_1(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.activationFlagsActivate_1Raw(initOverrides);
    }

    /**
     */
    async auditingCalculateHashRaw(requestParameters: AuditingCalculateHashOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuditingCalculateHashResponse>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling auditingCalculateHash().'
            );
        }

        if (requestParameters['auditingCalculateHashRequest'] == null) {
            throw new runtime.RequiredError(
                'auditingCalculateHashRequest',
                'Required parameter "auditingCalculateHashRequest" was null or undefined when calling auditingCalculateHash().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/audit-hash/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AuditingCalculateHashRequestToJSON(requestParameters['auditingCalculateHashRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuditingCalculateHashResponseFromJSON(jsonValue));
    }

    /**
     */
    async auditingCalculateHash(requestParameters: AuditingCalculateHashOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuditingCalculateHashResponse> {
        const response = await this.auditingCalculateHashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Disable the audit device at the given path.
     */
    async auditingDisableDeviceRaw(requestParameters: AuditingDisableDeviceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling auditingDisableDevice().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/audit/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Disable the audit device at the given path.
     */
    async auditingDisableDevice(requestParameters: AuditingDisableDeviceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.auditingDisableDeviceRaw(requestParameters, initOverrides);
    }

    /**
     * Disable auditing of the given request header.
     */
    async auditingDisableRequestHeaderRaw(requestParameters: AuditingDisableRequestHeaderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['header'] == null) {
            throw new runtime.RequiredError(
                'header',
                'Required parameter "header" was null or undefined when calling auditingDisableRequestHeader().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/auditing/request-headers/{header}`.replace(`{${"header"}}`, encodeURIComponent(String(requestParameters['header']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Disable auditing of the given request header.
     */
    async auditingDisableRequestHeader(requestParameters: AuditingDisableRequestHeaderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.auditingDisableRequestHeaderRaw(requestParameters, initOverrides);
    }

    /**
     * Enable a new audit device at the supplied path.
     */
    async auditingEnableDeviceRaw(requestParameters: AuditingEnableDeviceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling auditingEnableDevice().'
            );
        }

        if (requestParameters['auditingEnableDeviceRequest'] == null) {
            throw new runtime.RequiredError(
                'auditingEnableDeviceRequest',
                'Required parameter "auditingEnableDeviceRequest" was null or undefined when calling auditingEnableDevice().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/audit/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AuditingEnableDeviceRequestToJSON(requestParameters['auditingEnableDeviceRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enable a new audit device at the supplied path.
     */
    async auditingEnableDevice(requestParameters: AuditingEnableDeviceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.auditingEnableDeviceRaw(requestParameters, initOverrides);
    }

    /**
     * Enable auditing of a header.
     */
    async auditingEnableRequestHeaderRaw(requestParameters: AuditingEnableRequestHeaderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['header'] == null) {
            throw new runtime.RequiredError(
                'header',
                'Required parameter "header" was null or undefined when calling auditingEnableRequestHeader().'
            );
        }

        if (requestParameters['auditingEnableRequestHeaderRequest'] == null) {
            throw new runtime.RequiredError(
                'auditingEnableRequestHeaderRequest',
                'Required parameter "auditingEnableRequestHeaderRequest" was null or undefined when calling auditingEnableRequestHeader().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/config/auditing/request-headers/{header}`.replace(`{${"header"}}`, encodeURIComponent(String(requestParameters['header']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AuditingEnableRequestHeaderRequestToJSON(requestParameters['auditingEnableRequestHeaderRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enable auditing of a header.
     */
    async auditingEnableRequestHeader(requestParameters: AuditingEnableRequestHeaderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.auditingEnableRequestHeaderRaw(requestParameters, initOverrides);
    }

    /**
     * List the enabled audit devices.
     */
    async auditingListEnabledDevicesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/audit`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * List the enabled audit devices.
     */
    async auditingListEnabledDevices(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.auditingListEnabledDevicesRaw(initOverrides);
    }

    /**
     * List the request headers that are configured to be audited.
     */
    async auditingListRequestHeadersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuditingListRequestHeadersResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/auditing/request-headers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuditingListRequestHeadersResponseFromJSON(jsonValue));
    }

    /**
     * List the request headers that are configured to be audited.
     */
    async auditingListRequestHeaders(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuditingListRequestHeadersResponse> {
        const response = await this.auditingListRequestHeadersRaw(initOverrides);
        return await response.value();
    }

    /**
     * List the information for the given request header.
     */
    async auditingReadRequestHeaderInformationRaw(requestParameters: AuditingReadRequestHeaderInformationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['header'] == null) {
            throw new runtime.RequiredError(
                'header',
                'Required parameter "header" was null or undefined when calling auditingReadRequestHeaderInformation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/auditing/request-headers/{header}`.replace(`{${"header"}}`, encodeURIComponent(String(requestParameters['header']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * List the information for the given request header.
     */
    async auditingReadRequestHeaderInformation(requestParameters: AuditingReadRequestHeaderInformationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.auditingReadRequestHeaderInformationRaw(requestParameters, initOverrides);
    }

    /**
     * Disable the auth method at the given auth path
     */
    async authDisableMethodRaw(requestParameters: AuthDisableMethodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling authDisableMethod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/auth/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Disable the auth method at the given auth path
     */
    async authDisableMethod(requestParameters: AuthDisableMethodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.authDisableMethodRaw(requestParameters, initOverrides);
    }

    /**
     * After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.  For example, enable the \"foo\" auth method will make it accessible at /auth/foo.
     * Enables a new auth method.
     */
    async authEnableMethodRaw(requestParameters: AuthEnableMethodOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling authEnableMethod().'
            );
        }

        if (requestParameters['authEnableMethodRequest'] == null) {
            throw new runtime.RequiredError(
                'authEnableMethodRequest',
                'Required parameter "authEnableMethodRequest" was null or undefined when calling authEnableMethod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/auth/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AuthEnableMethodRequestToJSON(requestParameters['authEnableMethodRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.  For example, enable the \"foo\" auth method will make it accessible at /auth/foo.
     * Enables a new auth method.
     */
    async authEnableMethod(requestParameters: AuthEnableMethodOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.authEnableMethodRaw(requestParameters, initOverrides);
    }

    /**
     */
    async authListEnabledMethodsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/auth`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async authListEnabledMethods(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.authListEnabledMethodsRaw(initOverrides);
    }

    /**
     * Read the configuration of the auth engine at the given path.
     */
    async authReadConfigurationRaw(requestParameters: AuthReadConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthReadConfigurationResponse>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling authReadConfiguration().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/auth/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthReadConfigurationResponseFromJSON(jsonValue));
    }

    /**
     * Read the configuration of the auth engine at the given path.
     */
    async authReadConfiguration(requestParameters: AuthReadConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthReadConfigurationResponse> {
        const response = await this.authReadConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.
     * Reads the given auth path\'s configuration.
     */
    async authReadTuningInformationRaw(requestParameters: AuthReadTuningInformationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthReadTuningInformationResponse>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling authReadTuningInformation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/auth/{path}/tune`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthReadTuningInformationResponseFromJSON(jsonValue));
    }

    /**
     * This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.
     * Reads the given auth path\'s configuration.
     */
    async authReadTuningInformation(requestParameters: AuthReadTuningInformationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthReadTuningInformationResponse> {
        const response = await this.authReadTuningInformationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.
     * Tune configuration parameters for a given auth path.
     */
    async authTuneConfigurationParametersRaw(requestParameters: AuthTuneConfigurationParametersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling authTuneConfigurationParameters().'
            );
        }

        if (requestParameters['authTuneConfigurationParametersRequest'] == null) {
            throw new runtime.RequiredError(
                'authTuneConfigurationParametersRequest',
                'Required parameter "authTuneConfigurationParametersRequest" was null or undefined when calling authTuneConfigurationParameters().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/auth/{path}/tune`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AuthTuneConfigurationParametersRequestToJSON(requestParameters['authTuneConfigurationParametersRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.
     * Tune configuration parameters for a given auth path.
     */
    async authTuneConfigurationParameters(requestParameters: AuthTuneConfigurationParametersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.authTuneConfigurationParametersRaw(requestParameters, initOverrides);
    }

    /**
     * Information about the host instance that this Vault server is running on.   The information that gets collected includes host hardware information, and CPU,   disk, and memory utilization
     * Information about the host instance that this Vault server is running on.
     */
    async collectHostInformationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectHostInformationResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/host-info`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectHostInformationResponseFromJSON(jsonValue));
    }

    /**
     * Information about the host instance that this Vault server is running on.   The information that gets collected includes host hardware information, and CPU,   disk, and memory utilization
     * Information about the host instance that this Vault server is running on.
     */
    async collectHostInformation(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectHostInformationResponse> {
        const response = await this.collectHostInformationRaw(initOverrides);
        return await response.value();
    }

    /**
     * This path responds to the following HTTP methods.   GET /    Returns a map of in-flight requests.
     * reports in-flight requests
     */
    async collectInFlightRequestInformationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/in-flight-req`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This path responds to the following HTTP methods.   GET /    Returns a map of in-flight requests.
     * reports in-flight requests
     */
    async collectInFlightRequestInformation(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.collectInFlightRequestInformationRaw(initOverrides);
    }

    /**
     * Configure the CORS settings.
     */
    async corsConfigureRaw(requestParameters: CorsConfigureOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['corsConfigureRequest'] == null) {
            throw new runtime.RequiredError(
                'corsConfigureRequest',
                'Required parameter "corsConfigureRequest" was null or undefined when calling corsConfigure().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/config/cors`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CorsConfigureRequestToJSON(requestParameters['corsConfigureRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Configure the CORS settings.
     */
    async corsConfigure(requestParameters: CorsConfigureOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.corsConfigureRaw(requestParameters, initOverrides);
    }

    /**
     * Remove any CORS settings.
     */
    async corsDeleteConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/cors`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove any CORS settings.
     */
    async corsDeleteConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.corsDeleteConfigurationRaw(initOverrides);
    }

    /**
     * Return the current CORS settings.
     */
    async corsReadConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CorsReadConfigurationResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/cors`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CorsReadConfigurationResponseFromJSON(jsonValue));
    }

    /**
     * Return the current CORS settings.
     */
    async corsReadConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CorsReadConfigurationResponse> {
        const response = await this.corsReadConfigurationRaw(initOverrides);
        return await response.value();
    }

    /**
     * Decodes the encoded token with the otp.
     */
    async decodeTokenRaw(requestParameters: DecodeTokenOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['decodeTokenRequest'] == null) {
            throw new runtime.RequiredError(
                'decodeTokenRequest',
                'Required parameter "decodeTokenRequest" was null or undefined when calling decodeToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/decode-token`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DecodeTokenRequestToJSON(requestParameters['decodeTokenRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Decodes the encoded token with the otp.
     */
    async decodeToken(requestParameters: DecodeTokenOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.decodeTokenRaw(requestParameters, initOverrides);
    }

    /**
     */
    async encryptionKeyConfigureRotationRaw(requestParameters: EncryptionKeyConfigureRotationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['encryptionKeyConfigureRotationRequest'] == null) {
            throw new runtime.RequiredError(
                'encryptionKeyConfigureRotationRequest',
                'Required parameter "encryptionKeyConfigureRotationRequest" was null or undefined when calling encryptionKeyConfigureRotation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/rotate/config`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: EncryptionKeyConfigureRotationRequestToJSON(requestParameters['encryptionKeyConfigureRotationRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async encryptionKeyConfigureRotation(requestParameters: EncryptionKeyConfigureRotationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.encryptionKeyConfigureRotationRaw(requestParameters, initOverrides);
    }

    /**
     */
    async encryptionKeyReadRotationConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EncryptionKeyReadRotationConfigurationResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/rotate/config`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EncryptionKeyReadRotationConfigurationResponseFromJSON(jsonValue));
    }

    /**
     */
    async encryptionKeyReadRotationConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EncryptionKeyReadRotationConfigurationResponse> {
        const response = await this.encryptionKeyReadRotationConfigurationRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async encryptionKeyRotateRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/rotate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async encryptionKeyRotate(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.encryptionKeyRotateRaw(initOverrides);
    }

    /**
     * Provides information about the backend encryption key.
     */
    async encryptionKeyStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/key-status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Provides information about the backend encryption key.
     */
    async encryptionKeyStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.encryptionKeyStatusRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubDeleteConfigControlGroupRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/control-group`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubDeleteConfigControlGroup(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubDeleteConfigControlGroupRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubDeleteManagedKeysTypeNameRaw(requestParameters: EnterpriseStubDeleteManagedKeysTypeNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubDeleteManagedKeysTypeName().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling enterpriseStubDeleteManagedKeysTypeName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/managed-keys/{type}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubDeleteManagedKeysTypeName(requestParameters: EnterpriseStubDeleteManagedKeysTypeNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubDeleteManagedKeysTypeNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubDeleteMfaMethodDuoNameRaw(requestParameters: EnterpriseStubDeleteMfaMethodDuoNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubDeleteMfaMethodDuoName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/duo/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubDeleteMfaMethodDuoName(requestParameters: EnterpriseStubDeleteMfaMethodDuoNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubDeleteMfaMethodDuoNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubDeleteMfaMethodOktaNameRaw(requestParameters: EnterpriseStubDeleteMfaMethodOktaNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubDeleteMfaMethodOktaName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/okta/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubDeleteMfaMethodOktaName(requestParameters: EnterpriseStubDeleteMfaMethodOktaNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubDeleteMfaMethodOktaNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubDeleteMfaMethodPingidNameRaw(requestParameters: EnterpriseStubDeleteMfaMethodPingidNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubDeleteMfaMethodPingidName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/pingid/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubDeleteMfaMethodPingidName(requestParameters: EnterpriseStubDeleteMfaMethodPingidNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubDeleteMfaMethodPingidNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubDeleteMfaMethodTotpNameRaw(requestParameters: EnterpriseStubDeleteMfaMethodTotpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubDeleteMfaMethodTotpName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/totp/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubDeleteMfaMethodTotpName(requestParameters: EnterpriseStubDeleteMfaMethodTotpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubDeleteMfaMethodTotpNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubDeleteNamespacesPathRaw(requestParameters: EnterpriseStubDeleteNamespacesPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling enterpriseStubDeleteNamespacesPath().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/namespaces/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubDeleteNamespacesPath(requestParameters: EnterpriseStubDeleteNamespacesPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubDeleteNamespacesPathRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubDeletePoliciesEgpNameRaw(requestParameters: EnterpriseStubDeletePoliciesEgpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubDeletePoliciesEgpName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/egp/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubDeletePoliciesEgpName(requestParameters: EnterpriseStubDeletePoliciesEgpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubDeletePoliciesEgpNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubDeletePoliciesRgpNameRaw(requestParameters: EnterpriseStubDeletePoliciesRgpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubDeletePoliciesRgpName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/rgp/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubDeletePoliciesRgpName(requestParameters: EnterpriseStubDeletePoliciesRgpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubDeletePoliciesRgpNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubDeleteQuotasLeaseCountNameRaw(requestParameters: EnterpriseStubDeleteQuotasLeaseCountNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubDeleteQuotasLeaseCountName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/quotas/lease-count/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubDeleteQuotasLeaseCountName(requestParameters: EnterpriseStubDeleteQuotasLeaseCountNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubDeleteQuotasLeaseCountNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubDeleteReplicationPerformancePrimaryPathsFilterIdRaw(requestParameters: EnterpriseStubDeleteReplicationPerformancePrimaryPathsFilterIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling enterpriseStubDeleteReplicationPerformancePrimaryPathsFilterId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/primary/paths-filter/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubDeleteReplicationPerformancePrimaryPathsFilterId(requestParameters: EnterpriseStubDeleteReplicationPerformancePrimaryPathsFilterIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubDeleteReplicationPerformancePrimaryPathsFilterIdRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubDeleteStorageRaftSnapshotAutoConfigNameRaw(requestParameters: EnterpriseStubDeleteStorageRaftSnapshotAutoConfigNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubDeleteStorageRaftSnapshotAutoConfigName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/storage/raft/snapshot-auto/config/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubDeleteStorageRaftSnapshotAutoConfigName(requestParameters: EnterpriseStubDeleteStorageRaftSnapshotAutoConfigNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubDeleteStorageRaftSnapshotAutoConfigNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubListManagedKeysTypeRaw(requestParameters: EnterpriseStubListManagedKeysTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StandardListResponse>> {
        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling enterpriseStubListManagedKeysType().'
            );
        }

        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling enterpriseStubListManagedKeysType().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/managed-keys/{type}/`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StandardListResponseFromJSON(jsonValue));
    }

    /**
     */
    async enterpriseStubListManagedKeysType(requestParameters: EnterpriseStubListManagedKeysTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StandardListResponse> {
        const response = await this.enterpriseStubListManagedKeysTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async enterpriseStubListMfaMethodRaw(requestParameters: EnterpriseStubListMfaMethodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StandardListResponse>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling enterpriseStubListMfaMethod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StandardListResponseFromJSON(jsonValue));
    }

    /**
     */
    async enterpriseStubListMfaMethod(requestParameters: EnterpriseStubListMfaMethodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StandardListResponse> {
        const response = await this.enterpriseStubListMfaMethodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async enterpriseStubListNamespacesRaw(requestParameters: EnterpriseStubListNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StandardListResponse>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling enterpriseStubListNamespaces().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/namespaces/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StandardListResponseFromJSON(jsonValue));
    }

    /**
     */
    async enterpriseStubListNamespaces(requestParameters: EnterpriseStubListNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StandardListResponse> {
        const response = await this.enterpriseStubListNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async enterpriseStubListPoliciesEgpRaw(requestParameters: EnterpriseStubListPoliciesEgpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StandardListResponse>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling enterpriseStubListPoliciesEgp().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/egp/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StandardListResponseFromJSON(jsonValue));
    }

    /**
     */
    async enterpriseStubListPoliciesEgp(requestParameters: EnterpriseStubListPoliciesEgpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StandardListResponse> {
        const response = await this.enterpriseStubListPoliciesEgpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async enterpriseStubListPoliciesRgpRaw(requestParameters: EnterpriseStubListPoliciesRgpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StandardListResponse>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling enterpriseStubListPoliciesRgp().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/rgp/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StandardListResponseFromJSON(jsonValue));
    }

    /**
     */
    async enterpriseStubListPoliciesRgp(requestParameters: EnterpriseStubListPoliciesRgpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StandardListResponse> {
        const response = await this.enterpriseStubListPoliciesRgpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async enterpriseStubListQuotasLeaseCountRaw(requestParameters: EnterpriseStubListQuotasLeaseCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StandardListResponse>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling enterpriseStubListQuotasLeaseCount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/quotas/lease-count/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StandardListResponseFromJSON(jsonValue));
    }

    /**
     */
    async enterpriseStubListQuotasLeaseCount(requestParameters: EnterpriseStubListQuotasLeaseCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StandardListResponse> {
        const response = await this.enterpriseStubListQuotasLeaseCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async enterpriseStubListStorageRaftSnapshotAutoConfigRaw(requestParameters: EnterpriseStubListStorageRaftSnapshotAutoConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StandardListResponse>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling enterpriseStubListStorageRaftSnapshotAutoConfig().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/storage/raft/snapshot-auto/config/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StandardListResponseFromJSON(jsonValue));
    }

    /**
     */
    async enterpriseStubListStorageRaftSnapshotAutoConfig(requestParameters: EnterpriseStubListStorageRaftSnapshotAutoConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StandardListResponse> {
        const response = await this.enterpriseStubListStorageRaftSnapshotAutoConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async enterpriseStubReadConfigControlGroupRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/control-group`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadConfigControlGroup(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadConfigControlGroupRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubReadConfigGroupPolicyApplicationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/group-policy-application`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadConfigGroupPolicyApplication(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadConfigGroupPolicyApplicationRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubReadLicenseStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/license/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadLicenseStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadLicenseStatusRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubReadManagedKeysTypeNameRaw(requestParameters: EnterpriseStubReadManagedKeysTypeNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubReadManagedKeysTypeName().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling enterpriseStubReadManagedKeysTypeName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/managed-keys/{type}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadManagedKeysTypeName(requestParameters: EnterpriseStubReadManagedKeysTypeNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadManagedKeysTypeNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadMfaMethodDuoNameRaw(requestParameters: EnterpriseStubReadMfaMethodDuoNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubReadMfaMethodDuoName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/duo/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadMfaMethodDuoName(requestParameters: EnterpriseStubReadMfaMethodDuoNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadMfaMethodDuoNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadMfaMethodOktaNameRaw(requestParameters: EnterpriseStubReadMfaMethodOktaNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubReadMfaMethodOktaName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/okta/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadMfaMethodOktaName(requestParameters: EnterpriseStubReadMfaMethodOktaNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadMfaMethodOktaNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadMfaMethodPingidNameRaw(requestParameters: EnterpriseStubReadMfaMethodPingidNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubReadMfaMethodPingidName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/pingid/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadMfaMethodPingidName(requestParameters: EnterpriseStubReadMfaMethodPingidNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadMfaMethodPingidNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadMfaMethodTotpNameRaw(requestParameters: EnterpriseStubReadMfaMethodTotpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubReadMfaMethodTotpName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/totp/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadMfaMethodTotpName(requestParameters: EnterpriseStubReadMfaMethodTotpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadMfaMethodTotpNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadMfaMethodTotpNameGenerateRaw(requestParameters: EnterpriseStubReadMfaMethodTotpNameGenerateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubReadMfaMethodTotpNameGenerate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/totp/{name}/generate`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadMfaMethodTotpNameGenerate(requestParameters: EnterpriseStubReadMfaMethodTotpNameGenerateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadMfaMethodTotpNameGenerateRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadNamespacesPathRaw(requestParameters: EnterpriseStubReadNamespacesPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling enterpriseStubReadNamespacesPath().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/namespaces/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadNamespacesPath(requestParameters: EnterpriseStubReadNamespacesPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadNamespacesPathRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadPluginsReloadBackendStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/reload/backend/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadPluginsReloadBackendStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadPluginsReloadBackendStatusRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubReadPoliciesEgpNameRaw(requestParameters: EnterpriseStubReadPoliciesEgpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubReadPoliciesEgpName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/egp/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadPoliciesEgpName(requestParameters: EnterpriseStubReadPoliciesEgpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadPoliciesEgpNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadPoliciesRgpNameRaw(requestParameters: EnterpriseStubReadPoliciesRgpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubReadPoliciesRgpName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/rgp/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadPoliciesRgpName(requestParameters: EnterpriseStubReadPoliciesRgpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadPoliciesRgpNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadQuotasLeaseCountNameRaw(requestParameters: EnterpriseStubReadQuotasLeaseCountNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubReadQuotasLeaseCountName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/quotas/lease-count/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadQuotasLeaseCountName(requestParameters: EnterpriseStubReadQuotasLeaseCountNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadQuotasLeaseCountNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadReplicationDrSecondaryLicenseStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/secondary/license/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadReplicationDrSecondaryLicenseStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadReplicationDrSecondaryLicenseStatusRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubReadReplicationDrStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadReplicationDrStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadReplicationDrStatusRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubReadReplicationPerformancePrimaryDynamicFilterIdRaw(requestParameters: EnterpriseStubReadReplicationPerformancePrimaryDynamicFilterIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling enterpriseStubReadReplicationPerformancePrimaryDynamicFilterId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/primary/dynamic-filter/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadReplicationPerformancePrimaryDynamicFilterId(requestParameters: EnterpriseStubReadReplicationPerformancePrimaryDynamicFilterIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadReplicationPerformancePrimaryDynamicFilterIdRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadReplicationPerformancePrimaryPathsFilterIdRaw(requestParameters: EnterpriseStubReadReplicationPerformancePrimaryPathsFilterIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling enterpriseStubReadReplicationPerformancePrimaryPathsFilterId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/primary/paths-filter/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadReplicationPerformancePrimaryPathsFilterId(requestParameters: EnterpriseStubReadReplicationPerformancePrimaryPathsFilterIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadReplicationPerformancePrimaryPathsFilterIdRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadReplicationPerformanceSecondaryDynamicFilterIdRaw(requestParameters: EnterpriseStubReadReplicationPerformanceSecondaryDynamicFilterIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling enterpriseStubReadReplicationPerformanceSecondaryDynamicFilterId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/secondary/dynamic-filter/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadReplicationPerformanceSecondaryDynamicFilterId(requestParameters: EnterpriseStubReadReplicationPerformanceSecondaryDynamicFilterIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadReplicationPerformanceSecondaryDynamicFilterIdRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadReplicationPerformanceStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadReplicationPerformanceStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadReplicationPerformanceStatusRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubReadSealwrapRewrapRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/sealwrap/rewrap`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadSealwrapRewrap(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadSealwrapRewrapRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubReadStorageRaftSnapshotAutoConfigNameRaw(requestParameters: EnterpriseStubReadStorageRaftSnapshotAutoConfigNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubReadStorageRaftSnapshotAutoConfigName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/storage/raft/snapshot-auto/config/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadStorageRaftSnapshotAutoConfigName(requestParameters: EnterpriseStubReadStorageRaftSnapshotAutoConfigNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadStorageRaftSnapshotAutoConfigNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubReadStorageRaftSnapshotAutoStatusNameRaw(requestParameters: EnterpriseStubReadStorageRaftSnapshotAutoStatusNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubReadStorageRaftSnapshotAutoStatusName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/storage/raft/snapshot-auto/status/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubReadStorageRaftSnapshotAutoStatusName(requestParameters: EnterpriseStubReadStorageRaftSnapshotAutoStatusNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubReadStorageRaftSnapshotAutoStatusNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteConfigControlGroupRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/control-group`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteConfigControlGroup(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteConfigControlGroupRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteConfigGroupPolicyApplicationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/group-policy-application`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteConfigGroupPolicyApplication(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteConfigGroupPolicyApplicationRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteControlGroupAuthorizeRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/control-group/authorize`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteControlGroupAuthorize(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteControlGroupAuthorizeRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteControlGroupRequestRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/control-group/request`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteControlGroupRequest(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteControlGroupRequestRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteManagedKeysTypeNameRaw(requestParameters: EnterpriseStubWriteManagedKeysTypeNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubWriteManagedKeysTypeName().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling enterpriseStubWriteManagedKeysTypeName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/managed-keys/{type}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteManagedKeysTypeName(requestParameters: EnterpriseStubWriteManagedKeysTypeNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteManagedKeysTypeNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteManagedKeysTypeNameTestSignRaw(requestParameters: EnterpriseStubWriteManagedKeysTypeNameTestSignRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubWriteManagedKeysTypeNameTestSign().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling enterpriseStubWriteManagedKeysTypeNameTestSign().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/managed-keys/{type}/{name}/test/sign`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteManagedKeysTypeNameTestSign(requestParameters: EnterpriseStubWriteManagedKeysTypeNameTestSignRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteManagedKeysTypeNameTestSignRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteMfaMethodDuoNameRaw(requestParameters: EnterpriseStubWriteMfaMethodDuoNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubWriteMfaMethodDuoName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/duo/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteMfaMethodDuoName(requestParameters: EnterpriseStubWriteMfaMethodDuoNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteMfaMethodDuoNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteMfaMethodOktaNameRaw(requestParameters: EnterpriseStubWriteMfaMethodOktaNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubWriteMfaMethodOktaName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/okta/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteMfaMethodOktaName(requestParameters: EnterpriseStubWriteMfaMethodOktaNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteMfaMethodOktaNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteMfaMethodPingidNameRaw(requestParameters: EnterpriseStubWriteMfaMethodPingidNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubWriteMfaMethodPingidName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/pingid/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteMfaMethodPingidName(requestParameters: EnterpriseStubWriteMfaMethodPingidNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteMfaMethodPingidNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteMfaMethodTotpNameRaw(requestParameters: EnterpriseStubWriteMfaMethodTotpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubWriteMfaMethodTotpName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/totp/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteMfaMethodTotpName(requestParameters: EnterpriseStubWriteMfaMethodTotpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteMfaMethodTotpNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteMfaMethodTotpNameAdminDestroyRaw(requestParameters: EnterpriseStubWriteMfaMethodTotpNameAdminDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubWriteMfaMethodTotpNameAdminDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/totp/{name}/admin-destroy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteMfaMethodTotpNameAdminDestroy(requestParameters: EnterpriseStubWriteMfaMethodTotpNameAdminDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteMfaMethodTotpNameAdminDestroyRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteMfaMethodTotpNameAdminGenerateRaw(requestParameters: EnterpriseStubWriteMfaMethodTotpNameAdminGenerateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubWriteMfaMethodTotpNameAdminGenerate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mfa/method/totp/{name}/admin-generate`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteMfaMethodTotpNameAdminGenerate(requestParameters: EnterpriseStubWriteMfaMethodTotpNameAdminGenerateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteMfaMethodTotpNameAdminGenerateRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteNamespacesApiLockLockRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/namespaces/api-lock/lock`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteNamespacesApiLockLock(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteNamespacesApiLockLockRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteNamespacesApiLockLockPathRaw(requestParameters: EnterpriseStubWriteNamespacesApiLockLockPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling enterpriseStubWriteNamespacesApiLockLockPath().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/namespaces/api-lock/lock/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteNamespacesApiLockLockPath(requestParameters: EnterpriseStubWriteNamespacesApiLockLockPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteNamespacesApiLockLockPathRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteNamespacesApiLockUnlockRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/namespaces/api-lock/unlock`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteNamespacesApiLockUnlock(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteNamespacesApiLockUnlockRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteNamespacesApiLockUnlockPathRaw(requestParameters: EnterpriseStubWriteNamespacesApiLockUnlockPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling enterpriseStubWriteNamespacesApiLockUnlockPath().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/namespaces/api-lock/unlock/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteNamespacesApiLockUnlockPath(requestParameters: EnterpriseStubWriteNamespacesApiLockUnlockPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteNamespacesApiLockUnlockPathRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteNamespacesPathRaw(requestParameters: EnterpriseStubWriteNamespacesPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling enterpriseStubWriteNamespacesPath().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/namespaces/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteNamespacesPath(requestParameters: EnterpriseStubWriteNamespacesPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteNamespacesPathRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWritePoliciesEgpNameRaw(requestParameters: EnterpriseStubWritePoliciesEgpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubWritePoliciesEgpName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/egp/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWritePoliciesEgpName(requestParameters: EnterpriseStubWritePoliciesEgpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWritePoliciesEgpNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWritePoliciesRgpNameRaw(requestParameters: EnterpriseStubWritePoliciesRgpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubWritePoliciesRgpName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/rgp/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWritePoliciesRgpName(requestParameters: EnterpriseStubWritePoliciesRgpNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWritePoliciesRgpNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteQuotasLeaseCountNameRaw(requestParameters: EnterpriseStubWriteQuotasLeaseCountNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubWriteQuotasLeaseCountName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/quotas/lease-count/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteQuotasLeaseCountName(requestParameters: EnterpriseStubWriteQuotasLeaseCountNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteQuotasLeaseCountNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrPrimaryDemoteRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/primary/demote`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrPrimaryDemote(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrPrimaryDemoteRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrPrimaryDisableRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/primary/disable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrPrimaryDisable(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrPrimaryDisableRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrPrimaryEnableRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/primary/enable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrPrimaryEnable(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrPrimaryEnableRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrPrimaryRevokeSecondaryRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/primary/revoke-secondary`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrPrimaryRevokeSecondary(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrPrimaryRevokeSecondaryRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrPrimarySecondaryTokenRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/primary/secondary-token`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrPrimarySecondaryToken(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrPrimarySecondaryTokenRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryConfigReloadSubsystemRaw(requestParameters: EnterpriseStubWriteReplicationDrSecondaryConfigReloadSubsystemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['subsystem'] == null) {
            throw new runtime.RequiredError(
                'subsystem',
                'Required parameter "subsystem" was null or undefined when calling enterpriseStubWriteReplicationDrSecondaryConfigReloadSubsystem().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/secondary/config/reload/{subsystem}`.replace(`{${"subsystem"}}`, encodeURIComponent(String(requestParameters['subsystem']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryConfigReloadSubsystem(requestParameters: EnterpriseStubWriteReplicationDrSecondaryConfigReloadSubsystemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrSecondaryConfigReloadSubsystemRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryDisableRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/secondary/disable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryDisable(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrSecondaryDisableRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryEnableRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/secondary/enable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryEnable(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrSecondaryEnableRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryGeneratePublicKeyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/secondary/generate-public-key`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryGeneratePublicKey(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrSecondaryGeneratePublicKeyRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryOperationTokenDeleteRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/secondary/operation-token/delete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryOperationTokenDelete(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrSecondaryOperationTokenDeleteRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryPromoteRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/secondary/promote`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryPromote(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrSecondaryPromoteRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryRecoverRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/secondary/recover`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryRecover(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrSecondaryRecoverRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryReindexRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/secondary/reindex`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryReindex(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrSecondaryReindexRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryUpdatePrimaryRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/dr/secondary/update-primary`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationDrSecondaryUpdatePrimary(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationDrSecondaryUpdatePrimaryRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformancePrimaryDemoteRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/primary/demote`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformancePrimaryDemote(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPerformancePrimaryDemoteRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformancePrimaryDisableRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/primary/disable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformancePrimaryDisable(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPerformancePrimaryDisableRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformancePrimaryEnableRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/primary/enable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformancePrimaryEnable(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPerformancePrimaryEnableRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformancePrimaryPathsFilterIdRaw(requestParameters: EnterpriseStubWriteReplicationPerformancePrimaryPathsFilterIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling enterpriseStubWriteReplicationPerformancePrimaryPathsFilterId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/primary/paths-filter/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformancePrimaryPathsFilterId(requestParameters: EnterpriseStubWriteReplicationPerformancePrimaryPathsFilterIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPerformancePrimaryPathsFilterIdRaw(requestParameters, initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformancePrimaryRevokeSecondaryRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/primary/revoke-secondary`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformancePrimaryRevokeSecondary(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPerformancePrimaryRevokeSecondaryRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformancePrimarySecondaryTokenRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/primary/secondary-token`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformancePrimarySecondaryToken(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPerformancePrimarySecondaryTokenRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformanceSecondaryDisableRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/secondary/disable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformanceSecondaryDisable(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPerformanceSecondaryDisableRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformanceSecondaryEnableRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/secondary/enable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformanceSecondaryEnable(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPerformanceSecondaryEnableRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformanceSecondaryGeneratePublicKeyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/secondary/generate-public-key`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformanceSecondaryGeneratePublicKey(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPerformanceSecondaryGeneratePublicKeyRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformanceSecondaryPromoteRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/secondary/promote`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformanceSecondaryPromote(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPerformanceSecondaryPromoteRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformanceSecondaryUpdatePrimaryRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/performance/secondary/update-primary`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPerformanceSecondaryUpdatePrimary(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPerformanceSecondaryUpdatePrimaryRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPrimaryDemoteRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/primary/demote`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPrimaryDemote(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPrimaryDemoteRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPrimaryDisableRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/primary/disable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPrimaryDisable(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPrimaryDisableRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPrimaryEnableRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/primary/enable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPrimaryEnable(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPrimaryEnableRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPrimaryRevokeSecondaryRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/primary/revoke-secondary`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPrimaryRevokeSecondary(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPrimaryRevokeSecondaryRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationPrimarySecondaryTokenRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/primary/secondary-token`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationPrimarySecondaryToken(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationPrimarySecondaryTokenRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationRecoverRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/recover`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationRecover(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationRecoverRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationReindexRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/reindex`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationReindex(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationReindexRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationSecondaryDisableRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/secondary/disable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationSecondaryDisable(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationSecondaryDisableRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationSecondaryEnableRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/secondary/enable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationSecondaryEnable(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationSecondaryEnableRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationSecondaryPromoteRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/secondary/promote`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationSecondaryPromote(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationSecondaryPromoteRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteReplicationSecondaryUpdatePrimaryRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/secondary/update-primary`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteReplicationSecondaryUpdatePrimary(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteReplicationSecondaryUpdatePrimaryRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteSealwrapRewrapRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/sealwrap/rewrap`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteSealwrapRewrap(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteSealwrapRewrapRaw(initOverrides);
    }

    /**
     */
    async enterpriseStubWriteStorageRaftSnapshotAutoConfigNameRaw(requestParameters: EnterpriseStubWriteStorageRaftSnapshotAutoConfigNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling enterpriseStubWriteStorageRaftSnapshotAutoConfigName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/storage/raft/snapshot-auto/config/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async enterpriseStubWriteStorageRaftSnapshotAutoConfigName(requestParameters: EnterpriseStubWriteStorageRaftSnapshotAutoConfigNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enterpriseStubWriteStorageRaftSnapshotAutoConfigNameRaw(requestParameters, initOverrides);
    }

    /**
     */
    async generateHashRaw(requestParameters: GenerateHashOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateHashResponse>> {
        if (requestParameters['generateHashRequest'] == null) {
            throw new runtime.RequiredError(
                'generateHashRequest',
                'Required parameter "generateHashRequest" was null or undefined when calling generateHash().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/tools/hash`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenerateHashRequestToJSON(requestParameters['generateHashRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateHashResponseFromJSON(jsonValue));
    }

    /**
     */
    async generateHash(requestParameters: GenerateHashOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateHashResponse> {
        const response = await this.generateHashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async generateHashWithAlgorithmRaw(requestParameters: GenerateHashWithAlgorithmOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateHashWithAlgorithmResponse>> {
        if (requestParameters['urlalgorithm'] == null) {
            throw new runtime.RequiredError(
                'urlalgorithm',
                'Required parameter "urlalgorithm" was null or undefined when calling generateHashWithAlgorithm().'
            );
        }

        if (requestParameters['generateHashWithAlgorithmRequest'] == null) {
            throw new runtime.RequiredError(
                'generateHashWithAlgorithmRequest',
                'Required parameter "generateHashWithAlgorithmRequest" was null or undefined when calling generateHashWithAlgorithm().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/tools/hash/{urlalgorithm}`.replace(`{${"urlalgorithm"}}`, encodeURIComponent(String(requestParameters['urlalgorithm']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenerateHashWithAlgorithmRequestToJSON(requestParameters['generateHashWithAlgorithmRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateHashWithAlgorithmResponseFromJSON(jsonValue));
    }

    /**
     */
    async generateHashWithAlgorithm(requestParameters: GenerateHashWithAlgorithmOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateHashWithAlgorithmResponse> {
        const response = await this.generateHashWithAlgorithmRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async generateRandomRaw(requestParameters: GenerateRandomOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateRandomResponse>> {
        if (requestParameters['generateRandomRequest'] == null) {
            throw new runtime.RequiredError(
                'generateRandomRequest',
                'Required parameter "generateRandomRequest" was null or undefined when calling generateRandom().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/tools/random`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenerateRandomRequestToJSON(requestParameters['generateRandomRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateRandomResponseFromJSON(jsonValue));
    }

    /**
     */
    async generateRandom(requestParameters: GenerateRandomOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateRandomResponse> {
        const response = await this.generateRandomRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async generateRandomWithBytesRaw(requestParameters: GenerateRandomWithBytesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateRandomWithBytesResponse>> {
        if (requestParameters['urlbytes'] == null) {
            throw new runtime.RequiredError(
                'urlbytes',
                'Required parameter "urlbytes" was null or undefined when calling generateRandomWithBytes().'
            );
        }

        if (requestParameters['generateRandomWithBytesRequest'] == null) {
            throw new runtime.RequiredError(
                'generateRandomWithBytesRequest',
                'Required parameter "generateRandomWithBytesRequest" was null or undefined when calling generateRandomWithBytes().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/tools/random/{urlbytes}`.replace(`{${"urlbytes"}}`, encodeURIComponent(String(requestParameters['urlbytes']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenerateRandomWithBytesRequestToJSON(requestParameters['generateRandomWithBytesRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateRandomWithBytesResponseFromJSON(jsonValue));
    }

    /**
     */
    async generateRandomWithBytes(requestParameters: GenerateRandomWithBytesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateRandomWithBytesResponse> {
        const response = await this.generateRandomWithBytesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async generateRandomWithSourceRaw(requestParameters: GenerateRandomWithSourceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateRandomWithSourceResponse>> {
        if (requestParameters['source'] == null) {
            throw new runtime.RequiredError(
                'source',
                'Required parameter "source" was null or undefined when calling generateRandomWithSource().'
            );
        }

        if (requestParameters['generateRandomWithSourceRequest'] == null) {
            throw new runtime.RequiredError(
                'generateRandomWithSourceRequest',
                'Required parameter "generateRandomWithSourceRequest" was null or undefined when calling generateRandomWithSource().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/tools/random/{source}`.replace(`{${"source"}}`, encodeURIComponent(String(requestParameters['source']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenerateRandomWithSourceRequestToJSON(requestParameters['generateRandomWithSourceRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateRandomWithSourceResponseFromJSON(jsonValue));
    }

    /**
     */
    async generateRandomWithSource(requestParameters: GenerateRandomWithSourceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateRandomWithSourceResponse> {
        const response = await this.generateRandomWithSourceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async generateRandomWithSourceAndBytesRaw(requestParameters: GenerateRandomWithSourceAndBytesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateRandomWithSourceAndBytesResponse>> {
        if (requestParameters['source'] == null) {
            throw new runtime.RequiredError(
                'source',
                'Required parameter "source" was null or undefined when calling generateRandomWithSourceAndBytes().'
            );
        }

        if (requestParameters['urlbytes'] == null) {
            throw new runtime.RequiredError(
                'urlbytes',
                'Required parameter "urlbytes" was null or undefined when calling generateRandomWithSourceAndBytes().'
            );
        }

        if (requestParameters['generateRandomWithSourceAndBytesRequest'] == null) {
            throw new runtime.RequiredError(
                'generateRandomWithSourceAndBytesRequest',
                'Required parameter "generateRandomWithSourceAndBytesRequest" was null or undefined when calling generateRandomWithSourceAndBytes().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/tools/random/{source}/{urlbytes}`.replace(`{${"source"}}`, encodeURIComponent(String(requestParameters['source']))).replace(`{${"urlbytes"}}`, encodeURIComponent(String(requestParameters['urlbytes']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenerateRandomWithSourceAndBytesRequestToJSON(requestParameters['generateRandomWithSourceAndBytesRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateRandomWithSourceAndBytesResponseFromJSON(jsonValue));
    }

    /**
     */
    async generateRandomWithSourceAndBytes(requestParameters: GenerateRandomWithSourceAndBytesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateRandomWithSourceAndBytesResponse> {
        const response = await this.generateRandomWithSourceAndBytesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check the HA status of a Vault cluster
     */
    async haStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HaStatusResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/ha-status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HaStatusResponseFromJSON(jsonValue));
    }

    /**
     * Check the HA status of a Vault cluster
     */
    async haStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HaStatusResponse> {
        const response = await this.haStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * The Vault must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using Vault HSM.
     * Initialize a new Vault.
     */
    async initializeRaw(requestParameters: InitializeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['initializeRequest'] == null) {
            throw new runtime.RequiredError(
                'initializeRequest',
                'Required parameter "initializeRequest" was null or undefined when calling initialize().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/init`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InitializeRequestToJSON(requestParameters['initializeRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The Vault must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using Vault HSM.
     * Initialize a new Vault.
     */
    async initialize(requestParameters: InitializeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.initializeRaw(requestParameters, initOverrides);
    }

    /**
     * Enable or disable collection of client count, set retention period, or set default reporting period.
     */
    async internalClientActivityConfigureRaw(requestParameters: InternalClientActivityConfigureOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['internalClientActivityConfigureRequest'] == null) {
            throw new runtime.RequiredError(
                'internalClientActivityConfigureRequest',
                'Required parameter "internalClientActivityConfigureRequest" was null or undefined when calling internalClientActivityConfigure().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/internal/counters/config`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InternalClientActivityConfigureRequestToJSON(requestParameters['internalClientActivityConfigureRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enable or disable collection of client count, set retention period, or set default reporting period.
     */
    async internalClientActivityConfigure(requestParameters: InternalClientActivityConfigureOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.internalClientActivityConfigureRaw(requestParameters, initOverrides);
    }

    /**
     * Report the client count metrics, for this namespace and all child namespaces.
     */
    async internalClientActivityExportRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/counters/activity/export`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Report the client count metrics, for this namespace and all child namespaces.
     */
    async internalClientActivityExport(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.internalClientActivityExportRaw(initOverrides);
    }

    /**
     * Read the client count tracking configuration.
     */
    async internalClientActivityReadConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/counters/config`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Read the client count tracking configuration.
     */
    async internalClientActivityReadConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.internalClientActivityReadConfigurationRaw(initOverrides);
    }

    /**
     * Report the client count metrics, for this namespace and all child namespaces.
     */
    async internalClientActivityReportCountsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/counters/activity`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Report the client count metrics, for this namespace and all child namespaces.
     */
    async internalClientActivityReportCounts(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.internalClientActivityReportCountsRaw(initOverrides);
    }

    /**
     * Report the number of clients for this month, for this namespace and all child namespaces.
     */
    async internalClientActivityReportCountsThisMonthRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/counters/activity/monthly`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Report the number of clients for this month, for this namespace and all child namespaces.
     */
    async internalClientActivityReportCountsThisMonth(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.internalClientActivityReportCountsThisMonthRaw(initOverrides);
    }

    /**
     * Backwards compatibility is not guaranteed for this API
     */
    async internalCountEntitiesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InternalCountEntitiesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/counters/entities`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InternalCountEntitiesResponseFromJSON(jsonValue));
    }

    /**
     * Backwards compatibility is not guaranteed for this API
     */
    async internalCountEntities(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InternalCountEntitiesResponse> {
        const response = await this.internalCountEntitiesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Backwards compatibility is not guaranteed for this API
     * @deprecated
     */
    async internalCountRequestsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/counters/requests`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Backwards compatibility is not guaranteed for this API
     * @deprecated
     */
    async internalCountRequests(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.internalCountRequestsRaw(initOverrides);
    }

    /**
     * Backwards compatibility is not guaranteed for this API
     */
    async internalCountTokensRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InternalCountTokensResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/counters/tokens`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InternalCountTokensResponseFromJSON(jsonValue));
    }

    /**
     * Backwards compatibility is not guaranteed for this API
     */
    async internalCountTokens(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InternalCountTokensResponse> {
        const response = await this.internalCountTokensRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async internalGenerateOpenApiDocumentRaw(requestParameters: InternalGenerateOpenApiDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['context'] != null) {
            queryParameters['context'] = requestParameters['context'];
        }

        if (requestParameters['genericMountPaths'] != null) {
            queryParameters['generic_mount_paths'] = requestParameters['genericMountPaths'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/specs/openapi`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async internalGenerateOpenApiDocument(requestParameters: InternalGenerateOpenApiDocumentRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.internalGenerateOpenApiDocumentRaw(requestParameters, initOverrides);
    }

    /**
     */
    async internalGenerateOpenApiDocumentWithParametersRaw(requestParameters: InternalGenerateOpenApiDocumentWithParametersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['internalGenerateOpenApiDocumentWithParametersRequest'] == null) {
            throw new runtime.RequiredError(
                'internalGenerateOpenApiDocumentWithParametersRequest',
                'Required parameter "internalGenerateOpenApiDocumentWithParametersRequest" was null or undefined when calling internalGenerateOpenApiDocumentWithParameters().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/internal/specs/openapi`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InternalGenerateOpenApiDocumentWithParametersRequestToJSON(requestParameters['internalGenerateOpenApiDocumentWithParametersRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async internalGenerateOpenApiDocumentWithParameters(requestParameters: InternalGenerateOpenApiDocumentWithParametersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.internalGenerateOpenApiDocumentWithParametersRaw(requestParameters, initOverrides);
    }

    /**
     * Expose the route entry and mount entry tables present in the router
     */
    async internalInspectRouterRaw(requestParameters: InternalInspectRouterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tag'] == null) {
            throw new runtime.RequiredError(
                'tag',
                'Required parameter "tag" was null or undefined when calling internalInspectRouter().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/inspect/router/{tag}`.replace(`{${"tag"}}`, encodeURIComponent(String(requestParameters['tag']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Expose the route entry and mount entry tables present in the router
     */
    async internalInspectRouter(requestParameters: InternalInspectRouterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.internalInspectRouterRaw(requestParameters, initOverrides);
    }

    /**
     * Lists enabled feature flags.
     */
    async internalUiListEnabledFeatureFlagsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InternalUiListEnabledFeatureFlagsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/ui/feature-flags`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InternalUiListEnabledFeatureFlagsResponseFromJSON(jsonValue));
    }

    /**
     * Lists enabled feature flags.
     */
    async internalUiListEnabledFeatureFlags(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InternalUiListEnabledFeatureFlagsResponse> {
        const response = await this.internalUiListEnabledFeatureFlagsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists all enabled and visible auth and secrets mounts.
     */
    async internalUiListEnabledVisibleMountsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InternalUiListEnabledVisibleMountsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/ui/mounts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InternalUiListEnabledVisibleMountsResponseFromJSON(jsonValue));
    }

    /**
     * Lists all enabled and visible auth and secrets mounts.
     */
    async internalUiListEnabledVisibleMounts(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InternalUiListEnabledVisibleMountsResponse> {
        const response = await this.internalUiListEnabledVisibleMountsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Backwards compatibility is not guaranteed for this API
     */
    async internalUiListNamespacesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InternalUiListNamespacesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/ui/namespaces`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InternalUiListNamespacesResponseFromJSON(jsonValue));
    }

    /**
     * Backwards compatibility is not guaranteed for this API
     */
    async internalUiListNamespaces(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InternalUiListNamespacesResponse> {
        const response = await this.internalUiListNamespacesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves Active post-login Custom Messages
     */
    async internalUiReadAuthenticatedActiveCustomMessagesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InternalUiReadAuthenticatedActiveCustomMessagesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/ui/authenticated-messages`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InternalUiReadAuthenticatedActiveCustomMessagesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves Active post-login Custom Messages
     */
    async internalUiReadAuthenticatedActiveCustomMessages(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InternalUiReadAuthenticatedActiveCustomMessagesResponse> {
        const response = await this.internalUiReadAuthenticatedActiveCustomMessagesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Return information about the given mount.
     */
    async internalUiReadMountInformationRaw(requestParameters: InternalUiReadMountInformationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InternalUiReadMountInformationResponse>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling internalUiReadMountInformation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/ui/mounts/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InternalUiReadMountInformationResponseFromJSON(jsonValue));
    }

    /**
     * Return information about the given mount.
     */
    async internalUiReadMountInformation(requestParameters: InternalUiReadMountInformationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InternalUiReadMountInformationResponse> {
        const response = await this.internalUiReadMountInformationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Backwards compatibility is not guaranteed for this API
     */
    async internalUiReadResultantAclRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InternalUiReadResultantAclResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/ui/resultant-acl`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InternalUiReadResultantAclResponseFromJSON(jsonValue));
    }

    /**
     * Backwards compatibility is not guaranteed for this API
     */
    async internalUiReadResultantAcl(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InternalUiReadResultantAclResponse | null | undefined > {
        const response = await this.internalUiReadResultantAclRaw(initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Retrieves Active pre-login Custom Messages
     */
    async internalUiReadUnauthenticatedActiveCustomMessagesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InternalUiReadUnauthenticatedActiveCustomMessagesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/internal/ui/unauthenticated-messages`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InternalUiReadUnauthenticatedActiveCustomMessagesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves Active pre-login Custom Messages
     */
    async internalUiReadUnauthenticatedActiveCustomMessages(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InternalUiReadUnauthenticatedActiveCustomMessagesResponse> {
        const response = await this.internalUiReadUnauthenticatedActiveCustomMessagesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns the high availability status and current leader instance of Vault.
     */
    async leaderStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LeaderStatusResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/leader`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LeaderStatusResponseFromJSON(jsonValue));
    }

    /**
     * Returns the high availability status and current leader instance of Vault.
     */
    async leaderStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LeaderStatusResponse> {
        const response = await this.leaderStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async leasesCountRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LeasesCountResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/leases/count`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LeasesCountResponseFromJSON(jsonValue));
    }

    /**
     */
    async leasesCount(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LeasesCountResponse> {
        const response = await this.leasesCountRaw(initOverrides);
        return await response.value();
    }

    /**
     * Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
     * Revokes all secrets or tokens generated under a given prefix immediately
     */
    async leasesForceRevokeLeaseWithPrefixRaw(requestParameters: LeasesForceRevokeLeaseWithPrefixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling leasesForceRevokeLeaseWithPrefix().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/leases/revoke-force/{prefix}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
     * Revokes all secrets or tokens generated under a given prefix immediately
     */
    async leasesForceRevokeLeaseWithPrefix(requestParameters: LeasesForceRevokeLeaseWithPrefixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leasesForceRevokeLeaseWithPrefixRaw(requestParameters, initOverrides);
    }

    /**
     * Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
     * Revokes all secrets or tokens generated under a given prefix immediately
     */
    async leasesForceRevokeLeaseWithPrefix2Raw(requestParameters: LeasesForceRevokeLeaseWithPrefix2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling leasesForceRevokeLeaseWithPrefix2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/revoke-force/{prefix}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
     * Revokes all secrets or tokens generated under a given prefix immediately
     */
    async leasesForceRevokeLeaseWithPrefix2(requestParameters: LeasesForceRevokeLeaseWithPrefix2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leasesForceRevokeLeaseWithPrefix2Raw(requestParameters, initOverrides);
    }

    /**
     */
    async leasesListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LeasesListResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/leases`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LeasesListResponseFromJSON(jsonValue));
    }

    /**
     */
    async leasesList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LeasesListResponse> {
        const response = await this.leasesListRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async leasesLookUpRaw(requestParameters: LeasesLookUpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LeasesLookUpResponse>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling leasesLookUp().'
            );
        }

        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling leasesLookUp().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/leases/lookup/{prefix}/`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LeasesLookUpResponseFromJSON(jsonValue));
    }

    /**
     */
    async leasesLookUp(requestParameters: LeasesLookUpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LeasesLookUpResponse> {
        const response = await this.leasesLookUpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async leasesReadLeaseRaw(requestParameters: LeasesReadLeaseOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LeasesReadLeaseResponse>> {
        if (requestParameters['leasesReadLeaseRequest'] == null) {
            throw new runtime.RequiredError(
                'leasesReadLeaseRequest',
                'Required parameter "leasesReadLeaseRequest" was null or undefined when calling leasesReadLease().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/leases/lookup`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LeasesReadLeaseRequestToJSON(requestParameters['leasesReadLeaseRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LeasesReadLeaseResponseFromJSON(jsonValue));
    }

    /**
     */
    async leasesReadLease(requestParameters: LeasesReadLeaseOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LeasesReadLeaseResponse> {
        const response = await this.leasesReadLeaseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Renews a lease, requesting to extend the lease.
     */
    async leasesRenewLeaseRaw(requestParameters: LeasesRenewLeaseOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['leasesRenewLeaseRequest'] == null) {
            throw new runtime.RequiredError(
                'leasesRenewLeaseRequest',
                'Required parameter "leasesRenewLeaseRequest" was null or undefined when calling leasesRenewLease().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/leases/renew`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LeasesRenewLeaseRequestToJSON(requestParameters['leasesRenewLeaseRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Renews a lease, requesting to extend the lease.
     */
    async leasesRenewLease(requestParameters: LeasesRenewLeaseOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leasesRenewLeaseRaw(requestParameters, initOverrides);
    }

    /**
     * Renews a lease, requesting to extend the lease.
     */
    async leasesRenewLease2Raw(requestParameters: LeasesRenewLease2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['leasesRenewLease2Request'] == null) {
            throw new runtime.RequiredError(
                'leasesRenewLease2Request',
                'Required parameter "leasesRenewLease2Request" was null or undefined when calling leasesRenewLease2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/renew`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LeasesRenewLease2RequestToJSON(requestParameters['leasesRenewLease2Request']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Renews a lease, requesting to extend the lease.
     */
    async leasesRenewLease2(requestParameters: LeasesRenewLease2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leasesRenewLease2Raw(requestParameters, initOverrides);
    }

    /**
     * Renews a lease, requesting to extend the lease.
     */
    async leasesRenewLeaseWithIdRaw(requestParameters: LeasesRenewLeaseWithIdOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['urlLeaseId'] == null) {
            throw new runtime.RequiredError(
                'urlLeaseId',
                'Required parameter "urlLeaseId" was null or undefined when calling leasesRenewLeaseWithId().'
            );
        }

        if (requestParameters['leasesRenewLeaseWithIdRequest'] == null) {
            throw new runtime.RequiredError(
                'leasesRenewLeaseWithIdRequest',
                'Required parameter "leasesRenewLeaseWithIdRequest" was null or undefined when calling leasesRenewLeaseWithId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/leases/renew/{url_lease_id}`.replace(`{${"url_lease_id"}}`, encodeURIComponent(String(requestParameters['urlLeaseId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LeasesRenewLeaseWithIdRequestToJSON(requestParameters['leasesRenewLeaseWithIdRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Renews a lease, requesting to extend the lease.
     */
    async leasesRenewLeaseWithId(requestParameters: LeasesRenewLeaseWithIdOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leasesRenewLeaseWithIdRaw(requestParameters, initOverrides);
    }

    /**
     * Renews a lease, requesting to extend the lease.
     */
    async leasesRenewLeaseWithId2Raw(requestParameters: LeasesRenewLeaseWithId2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['urlLeaseId'] == null) {
            throw new runtime.RequiredError(
                'urlLeaseId',
                'Required parameter "urlLeaseId" was null or undefined when calling leasesRenewLeaseWithId2().'
            );
        }

        if (requestParameters['leasesRenewLeaseWithId2Request'] == null) {
            throw new runtime.RequiredError(
                'leasesRenewLeaseWithId2Request',
                'Required parameter "leasesRenewLeaseWithId2Request" was null or undefined when calling leasesRenewLeaseWithId2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/renew/{url_lease_id}`.replace(`{${"url_lease_id"}}`, encodeURIComponent(String(requestParameters['urlLeaseId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LeasesRenewLeaseWithId2RequestToJSON(requestParameters['leasesRenewLeaseWithId2Request']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Renews a lease, requesting to extend the lease.
     */
    async leasesRenewLeaseWithId2(requestParameters: LeasesRenewLeaseWithId2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leasesRenewLeaseWithId2Raw(requestParameters, initOverrides);
    }

    /**
     * Revokes a lease immediately.
     */
    async leasesRevokeLeaseRaw(requestParameters: LeasesRevokeLeaseOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['leasesRevokeLeaseRequest'] == null) {
            throw new runtime.RequiredError(
                'leasesRevokeLeaseRequest',
                'Required parameter "leasesRevokeLeaseRequest" was null or undefined when calling leasesRevokeLease().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/leases/revoke`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LeasesRevokeLeaseRequestToJSON(requestParameters['leasesRevokeLeaseRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revokes a lease immediately.
     */
    async leasesRevokeLease(requestParameters: LeasesRevokeLeaseOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leasesRevokeLeaseRaw(requestParameters, initOverrides);
    }

    /**
     * Revokes a lease immediately.
     */
    async leasesRevokeLease2Raw(requestParameters: LeasesRevokeLease2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['leasesRevokeLease2Request'] == null) {
            throw new runtime.RequiredError(
                'leasesRevokeLease2Request',
                'Required parameter "leasesRevokeLease2Request" was null or undefined when calling leasesRevokeLease2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/revoke`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LeasesRevokeLease2RequestToJSON(requestParameters['leasesRevokeLease2Request']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revokes a lease immediately.
     */
    async leasesRevokeLease2(requestParameters: LeasesRevokeLease2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leasesRevokeLease2Raw(requestParameters, initOverrides);
    }

    /**
     * Revokes a lease immediately.
     */
    async leasesRevokeLeaseWithIdRaw(requestParameters: LeasesRevokeLeaseWithIdOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['urlLeaseId'] == null) {
            throw new runtime.RequiredError(
                'urlLeaseId',
                'Required parameter "urlLeaseId" was null or undefined when calling leasesRevokeLeaseWithId().'
            );
        }

        if (requestParameters['leasesRevokeLeaseWithIdRequest'] == null) {
            throw new runtime.RequiredError(
                'leasesRevokeLeaseWithIdRequest',
                'Required parameter "leasesRevokeLeaseWithIdRequest" was null or undefined when calling leasesRevokeLeaseWithId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/leases/revoke/{url_lease_id}`.replace(`{${"url_lease_id"}}`, encodeURIComponent(String(requestParameters['urlLeaseId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LeasesRevokeLeaseWithIdRequestToJSON(requestParameters['leasesRevokeLeaseWithIdRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revokes a lease immediately.
     */
    async leasesRevokeLeaseWithId(requestParameters: LeasesRevokeLeaseWithIdOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leasesRevokeLeaseWithIdRaw(requestParameters, initOverrides);
    }

    /**
     * Revokes a lease immediately.
     */
    async leasesRevokeLeaseWithId2Raw(requestParameters: LeasesRevokeLeaseWithId2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['urlLeaseId'] == null) {
            throw new runtime.RequiredError(
                'urlLeaseId',
                'Required parameter "urlLeaseId" was null or undefined when calling leasesRevokeLeaseWithId2().'
            );
        }

        if (requestParameters['leasesRevokeLeaseWithId2Request'] == null) {
            throw new runtime.RequiredError(
                'leasesRevokeLeaseWithId2Request',
                'Required parameter "leasesRevokeLeaseWithId2Request" was null or undefined when calling leasesRevokeLeaseWithId2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/revoke/{url_lease_id}`.replace(`{${"url_lease_id"}}`, encodeURIComponent(String(requestParameters['urlLeaseId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LeasesRevokeLeaseWithId2RequestToJSON(requestParameters['leasesRevokeLeaseWithId2Request']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revokes a lease immediately.
     */
    async leasesRevokeLeaseWithId2(requestParameters: LeasesRevokeLeaseWithId2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leasesRevokeLeaseWithId2Raw(requestParameters, initOverrides);
    }

    /**
     * Revokes all secrets (via a lease ID prefix) or tokens (via the tokens\' path property) generated under a given prefix immediately.
     */
    async leasesRevokeLeaseWithPrefixRaw(requestParameters: LeasesRevokeLeaseWithPrefixOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling leasesRevokeLeaseWithPrefix().'
            );
        }

        if (requestParameters['leasesRevokeLeaseWithPrefixRequest'] == null) {
            throw new runtime.RequiredError(
                'leasesRevokeLeaseWithPrefixRequest',
                'Required parameter "leasesRevokeLeaseWithPrefixRequest" was null or undefined when calling leasesRevokeLeaseWithPrefix().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/leases/revoke-prefix/{prefix}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LeasesRevokeLeaseWithPrefixRequestToJSON(requestParameters['leasesRevokeLeaseWithPrefixRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revokes all secrets (via a lease ID prefix) or tokens (via the tokens\' path property) generated under a given prefix immediately.
     */
    async leasesRevokeLeaseWithPrefix(requestParameters: LeasesRevokeLeaseWithPrefixOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leasesRevokeLeaseWithPrefixRaw(requestParameters, initOverrides);
    }

    /**
     * Revokes all secrets (via a lease ID prefix) or tokens (via the tokens\' path property) generated under a given prefix immediately.
     */
    async leasesRevokeLeaseWithPrefix2Raw(requestParameters: LeasesRevokeLeaseWithPrefix2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling leasesRevokeLeaseWithPrefix2().'
            );
        }

        if (requestParameters['leasesRevokeLeaseWithPrefix2Request'] == null) {
            throw new runtime.RequiredError(
                'leasesRevokeLeaseWithPrefix2Request',
                'Required parameter "leasesRevokeLeaseWithPrefix2Request" was null or undefined when calling leasesRevokeLeaseWithPrefix2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/revoke-prefix/{prefix}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LeasesRevokeLeaseWithPrefix2RequestToJSON(requestParameters['leasesRevokeLeaseWithPrefix2Request']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revokes all secrets (via a lease ID prefix) or tokens (via the tokens\' path property) generated under a given prefix immediately.
     */
    async leasesRevokeLeaseWithPrefix2(requestParameters: LeasesRevokeLeaseWithPrefix2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leasesRevokeLeaseWithPrefix2Raw(requestParameters, initOverrides);
    }

    /**
     */
    async leasesTidyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/leases/tidy`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async leasesTidy(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leasesTidyRaw(initOverrides);
    }

    /**
     * Returns the available and enabled experiments
     */
    async listExperimentalFeaturesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/experiments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns the available and enabled experiments
     */
    async listExperimentalFeatures(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.listExperimentalFeaturesRaw(initOverrides);
    }

    /**
     * Report the locked user count metrics, for this namespace and all child namespaces.
     */
    async lockedUsersListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/locked-users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Report the locked user count metrics, for this namespace and all child namespaces.
     */
    async lockedUsersList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.lockedUsersListRaw(initOverrides);
    }

    /**
     * Unlocks the user with given mount_accessor and alias_identifier
     */
    async lockedUsersUnlockRaw(requestParameters: LockedUsersUnlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['aliasIdentifier'] == null) {
            throw new runtime.RequiredError(
                'aliasIdentifier',
                'Required parameter "aliasIdentifier" was null or undefined when calling lockedUsersUnlock().'
            );
        }

        if (requestParameters['mountAccessor'] == null) {
            throw new runtime.RequiredError(
                'mountAccessor',
                'Required parameter "mountAccessor" was null or undefined when calling lockedUsersUnlock().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/locked-users/{mount_accessor}/unlock/{alias_identifier}`.replace(`{${"alias_identifier"}}`, encodeURIComponent(String(requestParameters['aliasIdentifier']))).replace(`{${"mount_accessor"}}`, encodeURIComponent(String(requestParameters['mountAccessor']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unlocks the user with given mount_accessor and alias_identifier
     */
    async lockedUsersUnlock(requestParameters: LockedUsersUnlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.lockedUsersUnlockRaw(requestParameters, initOverrides);
    }

    /**
     * Read the log level for all existing loggers.
     */
    async loggersReadVerbosityLevelRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/loggers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Read the log level for all existing loggers.
     */
    async loggersReadVerbosityLevel(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.loggersReadVerbosityLevelRaw(initOverrides);
    }

    /**
     * Read the log level for a single logger.
     */
    async loggersReadVerbosityLevelForRaw(requestParameters: LoggersReadVerbosityLevelForRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling loggersReadVerbosityLevelFor().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/loggers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Read the log level for a single logger.
     */
    async loggersReadVerbosityLevelFor(requestParameters: LoggersReadVerbosityLevelForRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.loggersReadVerbosityLevelForRaw(requestParameters, initOverrides);
    }

    /**
     * Revert the all loggers to use log level provided in config.
     */
    async loggersRevertVerbosityLevelRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/loggers`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revert the all loggers to use log level provided in config.
     */
    async loggersRevertVerbosityLevel(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.loggersRevertVerbosityLevelRaw(initOverrides);
    }

    /**
     * Revert a single logger to use log level provided in config.
     */
    async loggersRevertVerbosityLevelForRaw(requestParameters: LoggersRevertVerbosityLevelForRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling loggersRevertVerbosityLevelFor().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/loggers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revert a single logger to use log level provided in config.
     */
    async loggersRevertVerbosityLevelFor(requestParameters: LoggersRevertVerbosityLevelForRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.loggersRevertVerbosityLevelForRaw(requestParameters, initOverrides);
    }

    /**
     * Modify the log level for all existing loggers.
     */
    async loggersUpdateVerbosityLevelRaw(requestParameters: LoggersUpdateVerbosityLevelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['loggersUpdateVerbosityLevelRequest'] == null) {
            throw new runtime.RequiredError(
                'loggersUpdateVerbosityLevelRequest',
                'Required parameter "loggersUpdateVerbosityLevelRequest" was null or undefined when calling loggersUpdateVerbosityLevel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/loggers`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoggersUpdateVerbosityLevelRequestToJSON(requestParameters['loggersUpdateVerbosityLevelRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Modify the log level for all existing loggers.
     */
    async loggersUpdateVerbosityLevel(requestParameters: LoggersUpdateVerbosityLevelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.loggersUpdateVerbosityLevelRaw(requestParameters, initOverrides);
    }

    /**
     * Modify the log level of a single logger.
     */
    async loggersUpdateVerbosityLevelForRaw(requestParameters: LoggersUpdateVerbosityLevelForOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling loggersUpdateVerbosityLevelFor().'
            );
        }

        if (requestParameters['loggersUpdateVerbosityLevelForRequest'] == null) {
            throw new runtime.RequiredError(
                'loggersUpdateVerbosityLevelForRequest',
                'Required parameter "loggersUpdateVerbosityLevelForRequest" was null or undefined when calling loggersUpdateVerbosityLevelFor().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/loggers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoggersUpdateVerbosityLevelForRequestToJSON(requestParameters['loggersUpdateVerbosityLevelForRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Modify the log level of a single logger.
     */
    async loggersUpdateVerbosityLevelFor(requestParameters: LoggersUpdateVerbosityLevelForOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.loggersUpdateVerbosityLevelForRaw(requestParameters, initOverrides);
    }

    /**
     */
    async metricsRaw(requestParameters: MetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/metrics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async metrics(requestParameters: MetricsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.metricsRaw(requestParameters, initOverrides);
    }

    /**
     * Validates the login for the given MFA methods. Upon successful validation, it returns an auth response containing the client token
     */
    async mfaValidateRaw(requestParameters: MfaValidateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['mfaValidateRequest'] == null) {
            throw new runtime.RequiredError(
                'mfaValidateRequest',
                'Required parameter "mfaValidateRequest" was null or undefined when calling mfaValidate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/mfa/validate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MfaValidateRequestToJSON(requestParameters['mfaValidateRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Validates the login for the given MFA methods. Upon successful validation, it returns an auth response containing the client token
     */
    async mfaValidate(requestParameters: MfaValidateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.mfaValidateRaw(requestParameters, initOverrides);
    }

    /**
     */
    async monitorRaw(requestParameters: MonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['logFormat'] != null) {
            queryParameters['log_format'] = requestParameters['logFormat'];
        }

        if (requestParameters['logLevel'] != null) {
            queryParameters['log_level'] = requestParameters['logLevel'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/monitor`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async monitor(requestParameters: MonitorRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.monitorRaw(requestParameters, initOverrides);
    }

    /**
     * Disable the mount point specified at the given path.
     */
    async mountsDisableSecretsEngineRaw(requestParameters: MountsDisableSecretsEngineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling mountsDisableSecretsEngine().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mounts/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Disable the mount point specified at the given path.
     */
    async mountsDisableSecretsEngine(requestParameters: MountsDisableSecretsEngineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.mountsDisableSecretsEngineRaw(requestParameters, initOverrides);
    }

    /**
     * Enable a new secrets engine at the given path.
     */
    async mountsEnableSecretsEngineRaw(requestParameters: MountsEnableSecretsEngineOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling mountsEnableSecretsEngine().'
            );
        }

        if (requestParameters['mountsEnableSecretsEngineRequest'] == null) {
            throw new runtime.RequiredError(
                'mountsEnableSecretsEngineRequest',
                'Required parameter "mountsEnableSecretsEngineRequest" was null or undefined when calling mountsEnableSecretsEngine().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/mounts/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MountsEnableSecretsEngineRequestToJSON(requestParameters['mountsEnableSecretsEngineRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enable a new secrets engine at the given path.
     */
    async mountsEnableSecretsEngine(requestParameters: MountsEnableSecretsEngineOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.mountsEnableSecretsEngineRaw(requestParameters, initOverrides);
    }

    /**
     */
    async mountsListSecretsEnginesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mounts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async mountsListSecretsEngines(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.mountsListSecretsEnginesRaw(initOverrides);
    }

    /**
     * Read the configuration of the secret engine at the given path.
     */
    async mountsReadConfigurationRaw(requestParameters: MountsReadConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MountsReadConfigurationResponse>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling mountsReadConfiguration().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mounts/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MountsReadConfigurationResponseFromJSON(jsonValue));
    }

    /**
     * Read the configuration of the secret engine at the given path.
     */
    async mountsReadConfiguration(requestParameters: MountsReadConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MountsReadConfigurationResponse> {
        const response = await this.mountsReadConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async mountsReadTuningInformationRaw(requestParameters: MountsReadTuningInformationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MountsReadTuningInformationResponse>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling mountsReadTuningInformation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/mounts/{path}/tune`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MountsReadTuningInformationResponseFromJSON(jsonValue));
    }

    /**
     */
    async mountsReadTuningInformation(requestParameters: MountsReadTuningInformationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MountsReadTuningInformationResponse> {
        const response = await this.mountsReadTuningInformationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async mountsTuneConfigurationParametersRaw(requestParameters: MountsTuneConfigurationParametersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling mountsTuneConfigurationParameters().'
            );
        }

        if (requestParameters['mountsTuneConfigurationParametersRequest'] == null) {
            throw new runtime.RequiredError(
                'mountsTuneConfigurationParametersRequest',
                'Required parameter "mountsTuneConfigurationParametersRequest" was null or undefined when calling mountsTuneConfigurationParameters().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/mounts/{path}/tune`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MountsTuneConfigurationParametersRequestToJSON(requestParameters['mountsTuneConfigurationParametersRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async mountsTuneConfigurationParameters(requestParameters: MountsTuneConfigurationParametersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.mountsTuneConfigurationParametersRaw(requestParameters, initOverrides);
    }

    /**
     */
    async pluginsCatalogListPluginsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PluginsCatalogListPluginsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/catalog`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginsCatalogListPluginsResponseFromJSON(jsonValue));
    }

    /**
     */
    async pluginsCatalogListPlugins(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PluginsCatalogListPluginsResponse> {
        const response = await this.pluginsCatalogListPluginsRaw(initOverrides);
        return await response.value();
    }

    /**
     * List the plugins in the catalog.
     */
    async pluginsCatalogListPluginsWithTypeRaw(requestParameters: PluginsCatalogListPluginsWithTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PluginsCatalogListPluginsWithTypeResponse>> {
        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling pluginsCatalogListPluginsWithType().'
            );
        }

        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling pluginsCatalogListPluginsWithType().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/catalog/{type}/`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginsCatalogListPluginsWithTypeResponseFromJSON(jsonValue));
    }

    /**
     * List the plugins in the catalog.
     */
    async pluginsCatalogListPluginsWithType(requestParameters: PluginsCatalogListPluginsWithTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PluginsCatalogListPluginsWithTypeResponse> {
        const response = await this.pluginsCatalogListPluginsWithTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create or update the pinned version for a plugin with a given type and name.
     */
    async pluginsCatalogPinsCreatePinnedVersionRaw(requestParameters: PluginsCatalogPinsCreatePinnedVersionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling pluginsCatalogPinsCreatePinnedVersion().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling pluginsCatalogPinsCreatePinnedVersion().'
            );
        }

        if (requestParameters['pluginsCatalogPinsCreatePinnedVersionRequest'] == null) {
            throw new runtime.RequiredError(
                'pluginsCatalogPinsCreatePinnedVersionRequest',
                'Required parameter "pluginsCatalogPinsCreatePinnedVersionRequest" was null or undefined when calling pluginsCatalogPinsCreatePinnedVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/plugins/pins/{type}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PluginsCatalogPinsCreatePinnedVersionRequestToJSON(requestParameters['pluginsCatalogPinsCreatePinnedVersionRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create or update the pinned version for a plugin with a given type and name.
     */
    async pluginsCatalogPinsCreatePinnedVersion(requestParameters: PluginsCatalogPinsCreatePinnedVersionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pluginsCatalogPinsCreatePinnedVersionRaw(requestParameters, initOverrides);
    }

    /**
     */
    async pluginsCatalogPinsListPinnedVersionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PluginsCatalogPinsListPinnedVersionsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/pins`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginsCatalogPinsListPinnedVersionsResponseFromJSON(jsonValue));
    }

    /**
     */
    async pluginsCatalogPinsListPinnedVersions(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PluginsCatalogPinsListPinnedVersionsResponse> {
        const response = await this.pluginsCatalogPinsListPinnedVersionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Return the pinned version for the plugin with the given type and name.
     */
    async pluginsCatalogPinsReadPinnedVersionRaw(requestParameters: PluginsCatalogPinsReadPinnedVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PluginsCatalogPinsReadPinnedVersionResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling pluginsCatalogPinsReadPinnedVersion().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling pluginsCatalogPinsReadPinnedVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/pins/{type}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginsCatalogPinsReadPinnedVersionResponseFromJSON(jsonValue));
    }

    /**
     * Return the pinned version for the plugin with the given type and name.
     */
    async pluginsCatalogPinsReadPinnedVersion(requestParameters: PluginsCatalogPinsReadPinnedVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PluginsCatalogPinsReadPinnedVersionResponse> {
        const response = await this.pluginsCatalogPinsReadPinnedVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove any pinned version for the plugin with the given type and name.
     */
    async pluginsCatalogPinsRemovePinnedVersionRaw(requestParameters: PluginsCatalogPinsRemovePinnedVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling pluginsCatalogPinsRemovePinnedVersion().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling pluginsCatalogPinsRemovePinnedVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/pins/{type}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove any pinned version for the plugin with the given type and name.
     */
    async pluginsCatalogPinsRemovePinnedVersion(requestParameters: PluginsCatalogPinsRemovePinnedVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pluginsCatalogPinsRemovePinnedVersionRaw(requestParameters, initOverrides);
    }

    /**
     * Return the configuration data for the plugin with the given name.
     */
    async pluginsCatalogReadPluginConfigurationRaw(requestParameters: PluginsCatalogReadPluginConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PluginsCatalogReadPluginConfigurationResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling pluginsCatalogReadPluginConfiguration().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/catalog/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginsCatalogReadPluginConfigurationResponseFromJSON(jsonValue));
    }

    /**
     * Return the configuration data for the plugin with the given name.
     */
    async pluginsCatalogReadPluginConfiguration(requestParameters: PluginsCatalogReadPluginConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PluginsCatalogReadPluginConfigurationResponse> {
        const response = await this.pluginsCatalogReadPluginConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the configuration data for the plugin with the given name.
     */
    async pluginsCatalogReadPluginConfigurationWithTypeRaw(requestParameters: PluginsCatalogReadPluginConfigurationWithTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PluginsCatalogReadPluginConfigurationWithTypeResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling pluginsCatalogReadPluginConfigurationWithType().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling pluginsCatalogReadPluginConfigurationWithType().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/catalog/{type}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginsCatalogReadPluginConfigurationWithTypeResponseFromJSON(jsonValue));
    }

    /**
     * Return the configuration data for the plugin with the given name.
     */
    async pluginsCatalogReadPluginConfigurationWithType(requestParameters: PluginsCatalogReadPluginConfigurationWithTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PluginsCatalogReadPluginConfigurationWithTypeResponse> {
        const response = await this.pluginsCatalogReadPluginConfigurationWithTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a new plugin, or updates an existing one with the supplied name.
     */
    async pluginsCatalogRegisterPluginRaw(requestParameters: PluginsCatalogRegisterPluginOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling pluginsCatalogRegisterPlugin().'
            );
        }

        if (requestParameters['pluginsCatalogRegisterPluginRequest'] == null) {
            throw new runtime.RequiredError(
                'pluginsCatalogRegisterPluginRequest',
                'Required parameter "pluginsCatalogRegisterPluginRequest" was null or undefined when calling pluginsCatalogRegisterPlugin().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/plugins/catalog/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PluginsCatalogRegisterPluginRequestToJSON(requestParameters['pluginsCatalogRegisterPluginRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Register a new plugin, or updates an existing one with the supplied name.
     */
    async pluginsCatalogRegisterPlugin(requestParameters: PluginsCatalogRegisterPluginOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pluginsCatalogRegisterPluginRaw(requestParameters, initOverrides);
    }

    /**
     * Register a new plugin, or updates an existing one with the supplied name.
     */
    async pluginsCatalogRegisterPluginWithTypeRaw(requestParameters: PluginsCatalogRegisterPluginWithTypeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling pluginsCatalogRegisterPluginWithType().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling pluginsCatalogRegisterPluginWithType().'
            );
        }

        if (requestParameters['pluginsCatalogRegisterPluginWithTypeRequest'] == null) {
            throw new runtime.RequiredError(
                'pluginsCatalogRegisterPluginWithTypeRequest',
                'Required parameter "pluginsCatalogRegisterPluginWithTypeRequest" was null or undefined when calling pluginsCatalogRegisterPluginWithType().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/plugins/catalog/{type}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PluginsCatalogRegisterPluginWithTypeRequestToJSON(requestParameters['pluginsCatalogRegisterPluginWithTypeRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Register a new plugin, or updates an existing one with the supplied name.
     */
    async pluginsCatalogRegisterPluginWithType(requestParameters: PluginsCatalogRegisterPluginWithTypeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pluginsCatalogRegisterPluginWithTypeRaw(requestParameters, initOverrides);
    }

    /**
     * Remove the plugin with the given name.
     */
    async pluginsCatalogRemovePluginRaw(requestParameters: PluginsCatalogRemovePluginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling pluginsCatalogRemovePlugin().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/catalog/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove the plugin with the given name.
     */
    async pluginsCatalogRemovePlugin(requestParameters: PluginsCatalogRemovePluginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pluginsCatalogRemovePluginRaw(requestParameters, initOverrides);
    }

    /**
     * Remove the plugin with the given name.
     */
    async pluginsCatalogRemovePluginWithTypeRaw(requestParameters: PluginsCatalogRemovePluginWithTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling pluginsCatalogRemovePluginWithType().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling pluginsCatalogRemovePluginWithType().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/catalog/{type}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove the plugin with the given name.
     */
    async pluginsCatalogRemovePluginWithType(requestParameters: PluginsCatalogRemovePluginWithTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pluginsCatalogRemovePluginWithTypeRaw(requestParameters, initOverrides);
    }

    /**
     * Either the plugin name (`plugin`) or the desired plugin backend mounts (`mounts`) must be provided, but not both. In the case that the plugin name is provided, all mounted paths that use that plugin backend will be reloaded.  If (`scope`) is provided and is (`global`), the plugin(s) are reloaded globally.
     * Reload mounted plugin backends.
     */
    async pluginsReloadBackendsRaw(requestParameters: PluginsReloadBackendsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PluginsReloadBackendsResponse>> {
        if (requestParameters['pluginsReloadBackendsRequest'] == null) {
            throw new runtime.RequiredError(
                'pluginsReloadBackendsRequest',
                'Required parameter "pluginsReloadBackendsRequest" was null or undefined when calling pluginsReloadBackends().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/plugins/reload/backend`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PluginsReloadBackendsRequestToJSON(requestParameters['pluginsReloadBackendsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginsReloadBackendsResponseFromJSON(jsonValue));
    }

    /**
     * Either the plugin name (`plugin`) or the desired plugin backend mounts (`mounts`) must be provided, but not both. In the case that the plugin name is provided, all mounted paths that use that plugin backend will be reloaded.  If (`scope`) is provided and is (`global`), the plugin(s) are reloaded globally.
     * Reload mounted plugin backends.
     */
    async pluginsReloadBackends(requestParameters: PluginsReloadBackendsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PluginsReloadBackendsResponse> {
        const response = await this.pluginsReloadBackendsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async pluginsRuntimesCatalogListPluginsRuntimesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PluginsRuntimesCatalogListPluginsRuntimesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/runtimes/catalog`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginsRuntimesCatalogListPluginsRuntimesResponseFromJSON(jsonValue));
    }

    /**
     */
    async pluginsRuntimesCatalogListPluginsRuntimes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PluginsRuntimesCatalogListPluginsRuntimesResponse> {
        const response = await this.pluginsRuntimesCatalogListPluginsRuntimesRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async pluginsRuntimesCatalogListPluginsRuntimes_2Raw(requestParameters: PluginsRuntimesCatalogListPluginsRuntimes0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PluginsRuntimesCatalogListPluginsRuntimesResponse>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling pluginsRuntimesCatalogListPluginsRuntimes_2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/runtimes/catalog/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginsRuntimesCatalogListPluginsRuntimesResponseFromJSON(jsonValue));
    }

    /**
     */
    async pluginsRuntimesCatalogListPluginsRuntimes_2(requestParameters: PluginsRuntimesCatalogListPluginsRuntimes0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PluginsRuntimesCatalogListPluginsRuntimesResponse> {
        const response = await this.pluginsRuntimesCatalogListPluginsRuntimes_2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the configuration data for the plugin runtime with the given name.
     */
    async pluginsRuntimesCatalogReadPluginRuntimeConfigurationRaw(requestParameters: PluginsRuntimesCatalogReadPluginRuntimeConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PluginsRuntimesCatalogReadPluginRuntimeConfigurationResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling pluginsRuntimesCatalogReadPluginRuntimeConfiguration().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling pluginsRuntimesCatalogReadPluginRuntimeConfiguration().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/runtimes/catalog/{type}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginsRuntimesCatalogReadPluginRuntimeConfigurationResponseFromJSON(jsonValue));
    }

    /**
     * Return the configuration data for the plugin runtime with the given name.
     */
    async pluginsRuntimesCatalogReadPluginRuntimeConfiguration(requestParameters: PluginsRuntimesCatalogReadPluginRuntimeConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PluginsRuntimesCatalogReadPluginRuntimeConfigurationResponse> {
        const response = await this.pluginsRuntimesCatalogReadPluginRuntimeConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a new plugin runtime, or updates an existing one with the supplied name.
     */
    async pluginsRuntimesCatalogRegisterPluginRuntimeRaw(requestParameters: PluginsRuntimesCatalogRegisterPluginRuntimeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling pluginsRuntimesCatalogRegisterPluginRuntime().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling pluginsRuntimesCatalogRegisterPluginRuntime().'
            );
        }

        if (requestParameters['pluginsRuntimesCatalogRegisterPluginRuntimeRequest'] == null) {
            throw new runtime.RequiredError(
                'pluginsRuntimesCatalogRegisterPluginRuntimeRequest',
                'Required parameter "pluginsRuntimesCatalogRegisterPluginRuntimeRequest" was null or undefined when calling pluginsRuntimesCatalogRegisterPluginRuntime().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/plugins/runtimes/catalog/{type}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PluginsRuntimesCatalogRegisterPluginRuntimeRequestToJSON(requestParameters['pluginsRuntimesCatalogRegisterPluginRuntimeRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Register a new plugin runtime, or updates an existing one with the supplied name.
     */
    async pluginsRuntimesCatalogRegisterPluginRuntime(requestParameters: PluginsRuntimesCatalogRegisterPluginRuntimeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pluginsRuntimesCatalogRegisterPluginRuntimeRaw(requestParameters, initOverrides);
    }

    /**
     * Remove the plugin runtime with the given name.
     */
    async pluginsRuntimesCatalogRemovePluginRuntimeRaw(requestParameters: PluginsRuntimesCatalogRemovePluginRuntimeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling pluginsRuntimesCatalogRemovePluginRuntime().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling pluginsRuntimesCatalogRemovePluginRuntime().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/plugins/runtimes/catalog/{type}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove the plugin runtime with the given name.
     */
    async pluginsRuntimesCatalogRemovePluginRuntime(requestParameters: PluginsRuntimesCatalogRemovePluginRuntimeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pluginsRuntimesCatalogRemovePluginRuntimeRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the ACL policy with the given name.
     */
    async policiesDeleteAclPolicyRaw(requestParameters: PoliciesDeleteAclPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling policiesDeleteAclPolicy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/acl/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the ACL policy with the given name.
     */
    async policiesDeleteAclPolicy(requestParameters: PoliciesDeleteAclPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.policiesDeleteAclPolicyRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the policy with the given name.
     */
    async policiesDeleteAclPolicy2Raw(requestParameters: PoliciesDeleteAclPolicy2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling policiesDeleteAclPolicy2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policy/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the policy with the given name.
     */
    async policiesDeleteAclPolicy2(requestParameters: PoliciesDeleteAclPolicy2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.policiesDeleteAclPolicy2Raw(requestParameters, initOverrides);
    }

    /**
     * Delete a password policy.
     */
    async policiesDeletePasswordPolicyRaw(requestParameters: PoliciesDeletePasswordPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling policiesDeletePasswordPolicy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/password/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a password policy.
     */
    async policiesDeletePasswordPolicy(requestParameters: PoliciesDeletePasswordPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.policiesDeletePasswordPolicyRaw(requestParameters, initOverrides);
    }

    /**
     * Generate a password from an existing password policy.
     */
    async policiesGeneratePasswordFromPasswordPolicyRaw(requestParameters: PoliciesGeneratePasswordFromPasswordPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PoliciesGeneratePasswordFromPasswordPolicyResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling policiesGeneratePasswordFromPasswordPolicy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/password/{name}/generate`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PoliciesGeneratePasswordFromPasswordPolicyResponseFromJSON(jsonValue));
    }

    /**
     * Generate a password from an existing password policy.
     */
    async policiesGeneratePasswordFromPasswordPolicy(requestParameters: PoliciesGeneratePasswordFromPasswordPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PoliciesGeneratePasswordFromPasswordPolicyResponse> {
        const response = await this.policiesGeneratePasswordFromPasswordPolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async policiesListAclPoliciesRaw(requestParameters: PoliciesListAclPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PoliciesListAclPoliciesResponse>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling policiesListAclPolicies().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/acl/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PoliciesListAclPoliciesResponseFromJSON(jsonValue));
    }

    /**
     */
    async policiesListAclPolicies(requestParameters: PoliciesListAclPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PoliciesListAclPoliciesResponse> {
        const response = await this.policiesListAclPoliciesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async policiesListAclPolicies2Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PoliciesListAclPolicies2Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policy`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PoliciesListAclPolicies2ResponseFromJSON(jsonValue));
    }

    /**
     */
    async policiesListAclPolicies2(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PoliciesListAclPolicies2Response> {
        const response = await this.policiesListAclPolicies2Raw(initOverrides);
        return await response.value();
    }

    /**
     */
    async policiesListAclPolicies3Raw(requestParameters: PoliciesListAclPolicies3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PoliciesListAclPolicies3Response>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling policiesListAclPolicies3().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policy/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PoliciesListAclPolicies3ResponseFromJSON(jsonValue));
    }

    /**
     */
    async policiesListAclPolicies3(requestParameters: PoliciesListAclPolicies3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PoliciesListAclPolicies3Response> {
        const response = await this.policiesListAclPolicies3Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the existing password policies.
     */
    async policiesListPasswordPoliciesRaw(requestParameters: PoliciesListPasswordPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StandardListResponse>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling policiesListPasswordPolicies().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/password/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StandardListResponseFromJSON(jsonValue));
    }

    /**
     * List the existing password policies.
     */
    async policiesListPasswordPolicies(requestParameters: PoliciesListPasswordPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StandardListResponse> {
        const response = await this.policiesListPasswordPoliciesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve information about the named ACL policy.
     */
    async policiesReadAclPolicyRaw(requestParameters: PoliciesReadAclPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PoliciesReadAclPolicyResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling policiesReadAclPolicy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/acl/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PoliciesReadAclPolicyResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve information about the named ACL policy.
     */
    async policiesReadAclPolicy(requestParameters: PoliciesReadAclPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PoliciesReadAclPolicyResponse> {
        const response = await this.policiesReadAclPolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the policy body for the named policy.
     */
    async policiesReadAclPolicy2Raw(requestParameters: PoliciesReadAclPolicy2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PoliciesReadAclPolicy2Response>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling policiesReadAclPolicy2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policy/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PoliciesReadAclPolicy2ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the policy body for the named policy.
     */
    async policiesReadAclPolicy2(requestParameters: PoliciesReadAclPolicy2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PoliciesReadAclPolicy2Response> {
        const response = await this.policiesReadAclPolicy2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve an existing password policy.
     */
    async policiesReadPasswordPolicyRaw(requestParameters: PoliciesReadPasswordPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PoliciesReadPasswordPolicyResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling policiesReadPasswordPolicy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/policies/password/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PoliciesReadPasswordPolicyResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve an existing password policy.
     */
    async policiesReadPasswordPolicy(requestParameters: PoliciesReadPasswordPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PoliciesReadPasswordPolicyResponse> {
        const response = await this.policiesReadPasswordPolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a new or update an existing ACL policy.
     */
    async policiesWriteAclPolicyRaw(requestParameters: PoliciesWriteAclPolicyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling policiesWriteAclPolicy().'
            );
        }

        if (requestParameters['policiesWriteAclPolicyRequest'] == null) {
            throw new runtime.RequiredError(
                'policiesWriteAclPolicyRequest',
                'Required parameter "policiesWriteAclPolicyRequest" was null or undefined when calling policiesWriteAclPolicy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/policies/acl/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PoliciesWriteAclPolicyRequestToJSON(requestParameters['policiesWriteAclPolicyRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add a new or update an existing ACL policy.
     */
    async policiesWriteAclPolicy(requestParameters: PoliciesWriteAclPolicyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.policiesWriteAclPolicyRaw(requestParameters, initOverrides);
    }

    /**
     * Add a new or update an existing policy.
     */
    async policiesWriteAclPolicy2Raw(requestParameters: PoliciesWriteAclPolicy2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling policiesWriteAclPolicy2().'
            );
        }

        if (requestParameters['policiesWriteAclPolicy2Request'] == null) {
            throw new runtime.RequiredError(
                'policiesWriteAclPolicy2Request',
                'Required parameter "policiesWriteAclPolicy2Request" was null or undefined when calling policiesWriteAclPolicy2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/policy/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PoliciesWriteAclPolicy2RequestToJSON(requestParameters['policiesWriteAclPolicy2Request']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add a new or update an existing policy.
     */
    async policiesWriteAclPolicy2(requestParameters: PoliciesWriteAclPolicy2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.policiesWriteAclPolicy2Raw(requestParameters, initOverrides);
    }

    /**
     * Add a new or update an existing password policy.
     */
    async policiesWritePasswordPolicyRaw(requestParameters: PoliciesWritePasswordPolicyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling policiesWritePasswordPolicy().'
            );
        }

        if (requestParameters['policiesWritePasswordPolicyRequest'] == null) {
            throw new runtime.RequiredError(
                'policiesWritePasswordPolicyRequest',
                'Required parameter "policiesWritePasswordPolicyRequest" was null or undefined when calling policiesWritePasswordPolicy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/policies/password/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PoliciesWritePasswordPolicyRequestToJSON(requestParameters['policiesWritePasswordPolicyRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add a new or update an existing password policy.
     */
    async policiesWritePasswordPolicy(requestParameters: PoliciesWritePasswordPolicyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.policiesWritePasswordPolicyRaw(requestParameters, initOverrides);
    }

    /**
     * Returns stack traces that led to blocking on synchronization primitives
     * Returns stack traces that led to blocking on synchronization primitives
     */
    async pprofBlockingRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/pprof/block`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns stack traces that led to blocking on synchronization primitives
     * Returns stack traces that led to blocking on synchronization primitives
     */
    async pprofBlocking(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pprofBlockingRaw(initOverrides);
    }

    /**
     * Returns the running program\'s command line, with arguments separated by NUL bytes.
     * Returns the running program\'s command line.
     */
    async pprofCommandLineRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/pprof/cmdline`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns the running program\'s command line, with arguments separated by NUL bytes.
     * Returns the running program\'s command line.
     */
    async pprofCommandLine(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pprofCommandLineRaw(initOverrides);
    }

    /**
     * Returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.
     * Returns a pprof-formatted cpu profile payload.
     */
    async pprofCpuProfileRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/pprof/profile`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.
     * Returns a pprof-formatted cpu profile payload.
     */
    async pprofCpuProfile(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pprofCpuProfileRaw(initOverrides);
    }

    /**
     * Returns  the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.
     * Returns the execution trace in binary form.
     */
    async pprofExecutionTraceRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/pprof/trace`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns  the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.
     * Returns the execution trace in binary form.
     */
    async pprofExecutionTrace(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pprofExecutionTraceRaw(initOverrides);
    }

    /**
     * Returns stack traces of all current goroutines.
     * Returns stack traces of all current goroutines.
     */
    async pprofGoroutinesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/pprof/goroutine`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns stack traces of all current goroutines.
     * Returns stack traces of all current goroutines.
     */
    async pprofGoroutines(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pprofGoroutinesRaw(initOverrides);
    }

    /**
     * Returns an HTML page listing the available  profiles. This should be mainly accessed via browsers or applications that can  render pages.
     * Returns an HTML page listing the available profiles.
     */
    async pprofIndexRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/pprof`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns an HTML page listing the available  profiles. This should be mainly accessed via browsers or applications that can  render pages.
     * Returns an HTML page listing the available profiles.
     */
    async pprofIndex(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pprofIndexRaw(initOverrides);
    }

    /**
     * Returns a sampling of all past memory allocations.
     * Returns a sampling of all past memory allocations.
     */
    async pprofMemoryAllocationsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/pprof/allocs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns a sampling of all past memory allocations.
     * Returns a sampling of all past memory allocations.
     */
    async pprofMemoryAllocations(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pprofMemoryAllocationsRaw(initOverrides);
    }

    /**
     * Returns a sampling of memory allocations of live object.
     * Returns a sampling of memory allocations of live object.
     */
    async pprofMemoryAllocationsLiveRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/pprof/heap`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns a sampling of memory allocations of live object.
     * Returns a sampling of memory allocations of live object.
     */
    async pprofMemoryAllocationsLive(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pprofMemoryAllocationsLiveRaw(initOverrides);
    }

    /**
     * Returns stack traces of holders of contended mutexes
     * Returns stack traces of holders of contended mutexes
     */
    async pprofMutexesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/pprof/mutex`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns stack traces of holders of contended mutexes
     * Returns stack traces of holders of contended mutexes
     */
    async pprofMutexes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pprofMutexesRaw(initOverrides);
    }

    /**
     * Returns the program counters listed in the request.
     * Returns the program counters listed in the request.
     */
    async pprofSymbolsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/pprof/symbol`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns the program counters listed in the request.
     * Returns the program counters listed in the request.
     */
    async pprofSymbols(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pprofSymbolsRaw(initOverrides);
    }

    /**
     * Returns stack traces that led to the creation of new OS threads
     * Returns stack traces that led to the creation of new OS threads
     */
    async pprofThreadCreationsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/pprof/threadcreate`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns stack traces that led to the creation of new OS threads
     * Returns stack traces that led to the creation of new OS threads
     */
    async pprofThreadCreations(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pprofThreadCreationsRaw(initOverrides);
    }

    /**
     */
    async queryTokenAccessorCapabilitiesRaw(requestParameters: QueryTokenAccessorCapabilitiesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['queryTokenAccessorCapabilitiesRequest'] == null) {
            throw new runtime.RequiredError(
                'queryTokenAccessorCapabilitiesRequest',
                'Required parameter "queryTokenAccessorCapabilitiesRequest" was null or undefined when calling queryTokenAccessorCapabilities().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/capabilities-accessor`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QueryTokenAccessorCapabilitiesRequestToJSON(requestParameters['queryTokenAccessorCapabilitiesRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async queryTokenAccessorCapabilities(requestParameters: QueryTokenAccessorCapabilitiesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.queryTokenAccessorCapabilitiesRaw(requestParameters, initOverrides);
    }

    /**
     */
    async queryTokenCapabilitiesRaw(requestParameters: QueryTokenCapabilitiesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['queryTokenCapabilitiesRequest'] == null) {
            throw new runtime.RequiredError(
                'queryTokenCapabilitiesRequest',
                'Required parameter "queryTokenCapabilitiesRequest" was null or undefined when calling queryTokenCapabilities().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/capabilities`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QueryTokenCapabilitiesRequestToJSON(requestParameters['queryTokenCapabilitiesRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async queryTokenCapabilities(requestParameters: QueryTokenCapabilitiesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.queryTokenCapabilitiesRaw(requestParameters, initOverrides);
    }

    /**
     */
    async queryTokenSelfCapabilitiesRaw(requestParameters: QueryTokenSelfCapabilitiesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['queryTokenSelfCapabilitiesRequest'] == null) {
            throw new runtime.RequiredError(
                'queryTokenSelfCapabilitiesRequest',
                'Required parameter "queryTokenSelfCapabilitiesRequest" was null or undefined when calling queryTokenSelfCapabilities().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/capabilities-self`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QueryTokenSelfCapabilitiesRequestToJSON(requestParameters['queryTokenSelfCapabilitiesRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async queryTokenSelfCapabilities(requestParameters: QueryTokenSelfCapabilitiesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.queryTokenSelfCapabilitiesRaw(requestParameters, initOverrides);
    }

    /**
     */
    async rateLimitQuotasConfigureRaw(requestParameters: RateLimitQuotasConfigureOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['rateLimitQuotasConfigureRequest'] == null) {
            throw new runtime.RequiredError(
                'rateLimitQuotasConfigureRequest',
                'Required parameter "rateLimitQuotasConfigureRequest" was null or undefined when calling rateLimitQuotasConfigure().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/quotas/config`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RateLimitQuotasConfigureRequestToJSON(requestParameters['rateLimitQuotasConfigureRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async rateLimitQuotasConfigure(requestParameters: RateLimitQuotasConfigureOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.rateLimitQuotasConfigureRaw(requestParameters, initOverrides);
    }

    /**
     */
    async rateLimitQuotasDeleteRaw(requestParameters: RateLimitQuotasDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling rateLimitQuotasDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/quotas/rate-limit/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async rateLimitQuotasDelete(requestParameters: RateLimitQuotasDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.rateLimitQuotasDeleteRaw(requestParameters, initOverrides);
    }

    /**
     */
    async rateLimitQuotasListRaw(requestParameters: RateLimitQuotasListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StandardListResponse>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling rateLimitQuotasList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/quotas/rate-limit/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StandardListResponseFromJSON(jsonValue));
    }

    /**
     */
    async rateLimitQuotasList(requestParameters: RateLimitQuotasListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StandardListResponse> {
        const response = await this.rateLimitQuotasListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async rateLimitQuotasReadRaw(requestParameters: RateLimitQuotasReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RateLimitQuotasReadResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling rateLimitQuotasRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/quotas/rate-limit/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RateLimitQuotasReadResponseFromJSON(jsonValue));
    }

    /**
     */
    async rateLimitQuotasRead(requestParameters: RateLimitQuotasReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RateLimitQuotasReadResponse> {
        const response = await this.rateLimitQuotasReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async rateLimitQuotasReadConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RateLimitQuotasReadConfigurationResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/quotas/config`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RateLimitQuotasReadConfigurationResponseFromJSON(jsonValue));
    }

    /**
     */
    async rateLimitQuotasReadConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RateLimitQuotasReadConfigurationResponse> {
        const response = await this.rateLimitQuotasReadConfigurationRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async rateLimitQuotasWriteRaw(requestParameters: RateLimitQuotasWriteOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling rateLimitQuotasWrite().'
            );
        }

        if (requestParameters['rateLimitQuotasWriteRequest'] == null) {
            throw new runtime.RequiredError(
                'rateLimitQuotasWriteRequest',
                'Required parameter "rateLimitQuotasWriteRequest" was null or undefined when calling rateLimitQuotasWrite().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/quotas/rate-limit/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RateLimitQuotasWriteRequestToJSON(requestParameters['rateLimitQuotasWriteRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async rateLimitQuotasWrite(requestParameters: RateLimitQuotasWriteOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.rateLimitQuotasWriteRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the key with given path.
     */
    async rawDeleteRaw(requestParameters: RawDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling rawDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/raw/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the key with given path.
     */
    async rawDelete(requestParameters: RawDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.rawDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Return a list keys for a given path prefix.
     */
    async rawListRaw(requestParameters: RawListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StandardListResponse>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling rawList().'
            );
        }

        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling rawList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/raw/{path}/`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StandardListResponseFromJSON(jsonValue));
    }

    /**
     * Return a list keys for a given path prefix.
     */
    async rawList(requestParameters: RawListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StandardListResponse> {
        const response = await this.rawListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Read the value of the key at the given path.
     */
    async rawReadRaw(requestParameters: RawReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RawReadResponse>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling rawRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/raw/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RawReadResponseFromJSON(jsonValue));
    }

    /**
     * Read the value of the key at the given path.
     */
    async rawRead(requestParameters: RawReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RawReadResponse> {
        const response = await this.rawReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the value of the key at the given path.
     */
    async rawWriteRaw(requestParameters: RawWriteOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling rawWrite().'
            );
        }

        if (requestParameters['rawWriteRequest'] == null) {
            throw new runtime.RequiredError(
                'rawWriteRequest',
                'Required parameter "rawWriteRequest" was null or undefined when calling rawWrite().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/raw/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RawWriteRequestToJSON(requestParameters['rawWriteRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update the value of the key at the given path.
     */
    async rawWrite(requestParameters: RawWriteOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.rawWriteRaw(requestParameters, initOverrides);
    }

    /**
     * Returns the available and activated activation-flagged features.
     */
    async readActivationFlagsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/activation-flags`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns the available and activated activation-flagged features.
     */
    async readActivationFlags(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.readActivationFlagsRaw(initOverrides);
    }

    /**
     * Returns the health status of Vault.
     */
    async readHealthStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/health`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns the health status of Vault.
     */
    async readHealthStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.readHealthStatusRaw(initOverrides);
    }

    /**
     * Returns the initialization status of Vault.
     */
    async readInitializationStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/init`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns the initialization status of Vault.
     */
    async readInitializationStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.readInitializationStatusRaw(initOverrides);
    }

    /**
     */
    async readReplicationStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/replication/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async readReplicationStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.readReplicationStatusRaw(initOverrides);
    }

    /**
     * The sanitized output strips configuration values in the storage, HA storage, and seals stanzas, which may contain sensitive values such as API tokens. It also removes any token or secret fields in other stanzas, such as the circonus_api_token from telemetry.
     * Return a sanitized version of the Vault server configuration.
     */
    async readSanitizedConfigurationStateRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/state/sanitized`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The sanitized output strips configuration values in the storage, HA storage, and seals stanzas, which may contain sensitive values such as API tokens. It also removes any token or secret fields in other stanzas, such as the circonus_api_token from telemetry.
     * Return a sanitized version of the Vault server configuration.
     */
    async readSanitizedConfigurationState(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.readSanitizedConfigurationStateRaw(initOverrides);
    }

    /**
     * Look up wrapping properties for the given token.
     */
    async readWrappingPropertiesRaw(requestParameters: ReadWrappingPropertiesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReadWrappingPropertiesResponse>> {
        if (requestParameters['readWrappingPropertiesRequest'] == null) {
            throw new runtime.RequiredError(
                'readWrappingPropertiesRequest',
                'Required parameter "readWrappingPropertiesRequest" was null or undefined when calling readWrappingProperties().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/wrapping/lookup`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReadWrappingPropertiesRequestToJSON(requestParameters['readWrappingPropertiesRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReadWrappingPropertiesResponseFromJSON(jsonValue));
    }

    /**
     * Look up wrapping properties for the given token.
     */
    async readWrappingProperties(requestParameters: ReadWrappingPropertiesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReadWrappingPropertiesResponse> {
        const response = await this.readWrappingPropertiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Look up wrapping properties for the requester\'s token.
     */
    async readWrappingProperties2Raw(requestParameters: ReadWrappingProperties2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReadWrappingProperties2Response>> {
        const queryParameters: any = {};

        if (requestParameters['token'] != null) {
            queryParameters['token'] = requestParameters['token'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/wrapping/lookup`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReadWrappingProperties2ResponseFromJSON(jsonValue));
    }

    /**
     * Look up wrapping properties for the requester\'s token.
     */
    async readWrappingProperties2(requestParameters: ReadWrappingProperties2Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReadWrappingProperties2Response> {
        const response = await this.readWrappingProperties2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.
     * Cancels any in-progress rekey.
     */
    async rekeyAttemptCancelRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/rekey/init`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.
     * Cancels any in-progress rekey.
     */
    async rekeyAttemptCancel(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.rekeyAttemptCancelRaw(initOverrides);
    }

    /**
     * Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.
     * Initializes a new rekey attempt.
     */
    async rekeyAttemptInitializeRaw(requestParameters: RekeyAttemptInitializeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RekeyAttemptInitializeResponse>> {
        if (requestParameters['rekeyAttemptInitializeRequest'] == null) {
            throw new runtime.RequiredError(
                'rekeyAttemptInitializeRequest',
                'Required parameter "rekeyAttemptInitializeRequest" was null or undefined when calling rekeyAttemptInitialize().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/rekey/init`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RekeyAttemptInitializeRequestToJSON(requestParameters['rekeyAttemptInitializeRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RekeyAttemptInitializeResponseFromJSON(jsonValue));
    }

    /**
     * Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.
     * Initializes a new rekey attempt.
     */
    async rekeyAttemptInitialize(requestParameters: RekeyAttemptInitializeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RekeyAttemptInitializeResponse> {
        const response = await this.rekeyAttemptInitializeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reads the configuration and progress of the current rekey attempt.
     */
    async rekeyAttemptReadProgressRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RekeyAttemptReadProgressResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/rekey/init`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RekeyAttemptReadProgressResponseFromJSON(jsonValue));
    }

    /**
     * Reads the configuration and progress of the current rekey attempt.
     */
    async rekeyAttemptReadProgress(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RekeyAttemptReadProgressResponse> {
        const response = await this.rekeyAttemptReadProgressRaw(initOverrides);
        return await response.value();
    }

    /**
     * Enter a single unseal key share to progress the rekey of the Vault.
     */
    async rekeyAttemptUpdateRaw(requestParameters: RekeyAttemptUpdateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RekeyAttemptUpdateResponse>> {
        if (requestParameters['rekeyAttemptUpdateRequest'] == null) {
            throw new runtime.RequiredError(
                'rekeyAttemptUpdateRequest',
                'Required parameter "rekeyAttemptUpdateRequest" was null or undefined when calling rekeyAttemptUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/rekey/update`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RekeyAttemptUpdateRequestToJSON(requestParameters['rekeyAttemptUpdateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RekeyAttemptUpdateResponseFromJSON(jsonValue));
    }

    /**
     * Enter a single unseal key share to progress the rekey of the Vault.
     */
    async rekeyAttemptUpdate(requestParameters: RekeyAttemptUpdateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RekeyAttemptUpdateResponse> {
        const response = await this.rekeyAttemptUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the backup copy of PGP-encrypted unseal keys.
     */
    async rekeyDeleteBackupKeyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/rekey/backup`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the backup copy of PGP-encrypted unseal keys.
     */
    async rekeyDeleteBackupKey(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.rekeyDeleteBackupKeyRaw(initOverrides);
    }

    /**
     */
    async rekeyDeleteBackupRecoveryKeyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/rekey/recovery-key-backup`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async rekeyDeleteBackupRecoveryKey(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.rekeyDeleteBackupRecoveryKeyRaw(initOverrides);
    }

    /**
     * Return the backup copy of PGP-encrypted unseal keys.
     */
    async rekeyReadBackupKeyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RekeyReadBackupKeyResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/rekey/backup`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RekeyReadBackupKeyResponseFromJSON(jsonValue));
    }

    /**
     * Return the backup copy of PGP-encrypted unseal keys.
     */
    async rekeyReadBackupKey(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RekeyReadBackupKeyResponse> {
        const response = await this.rekeyReadBackupKeyRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async rekeyReadBackupRecoveryKeyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RekeyReadBackupRecoveryKeyResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/rekey/recovery-key-backup`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RekeyReadBackupRecoveryKeyResponseFromJSON(jsonValue));
    }

    /**
     */
    async rekeyReadBackupRecoveryKey(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RekeyReadBackupRecoveryKeyResponse> {
        const response = await this.rekeyReadBackupRecoveryKeyRaw(initOverrides);
        return await response.value();
    }

    /**
     * This clears any progress made and resets the nonce. Unlike a `DELETE` against `sys/rekey/init`, this only resets the current verification operation, not the entire rekey atttempt.
     * Cancel any in-progress rekey verification operation.
     */
    async rekeyVerificationCancelRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RekeyVerificationCancelResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/rekey/verify`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RekeyVerificationCancelResponseFromJSON(jsonValue));
    }

    /**
     * This clears any progress made and resets the nonce. Unlike a `DELETE` against `sys/rekey/init`, this only resets the current verification operation, not the entire rekey atttempt.
     * Cancel any in-progress rekey verification operation.
     */
    async rekeyVerificationCancel(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RekeyVerificationCancelResponse> {
        const response = await this.rekeyVerificationCancelRaw(initOverrides);
        return await response.value();
    }

    /**
     * Read the configuration and progress of the current rekey verification attempt.
     */
    async rekeyVerificationReadProgressRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RekeyVerificationReadProgressResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/rekey/verify`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RekeyVerificationReadProgressResponseFromJSON(jsonValue));
    }

    /**
     * Read the configuration and progress of the current rekey verification attempt.
     */
    async rekeyVerificationReadProgress(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RekeyVerificationReadProgressResponse> {
        const response = await this.rekeyVerificationReadProgressRaw(initOverrides);
        return await response.value();
    }

    /**
     * Enter a single new key share to progress the rekey verification operation.
     */
    async rekeyVerificationUpdateRaw(requestParameters: RekeyVerificationUpdateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RekeyVerificationUpdateResponse>> {
        if (requestParameters['rekeyVerificationUpdateRequest'] == null) {
            throw new runtime.RequiredError(
                'rekeyVerificationUpdateRequest',
                'Required parameter "rekeyVerificationUpdateRequest" was null or undefined when calling rekeyVerificationUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/rekey/verify`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RekeyVerificationUpdateRequestToJSON(requestParameters['rekeyVerificationUpdateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RekeyVerificationUpdateResponseFromJSON(jsonValue));
    }

    /**
     * Enter a single new key share to progress the rekey verification operation.
     */
    async rekeyVerificationUpdate(requestParameters: RekeyVerificationUpdateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RekeyVerificationUpdateResponse> {
        const response = await this.rekeyVerificationUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reload all plugins of a specific name and type across all namespaces. If \"scope\" is provided and is \"global\", the plugin is reloaded across all nodes and clusters. If a new plugin version has been pinned, this will ensure all instances start using the new version.
     * Reload all instances of a specific plugin.
     */
    async reloadPluginsRaw(requestParameters: ReloadPluginsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReloadPluginsResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling reloadPlugins().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling reloadPlugins().'
            );
        }

        if (requestParameters['reloadPluginsRequest'] == null) {
            throw new runtime.RequiredError(
                'reloadPluginsRequest',
                'Required parameter "reloadPluginsRequest" was null or undefined when calling reloadPlugins().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/plugins/reload/{type}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReloadPluginsRequestToJSON(requestParameters['reloadPluginsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReloadPluginsResponseFromJSON(jsonValue));
    }

    /**
     * Reload all plugins of a specific name and type across all namespaces. If \"scope\" is provided and is \"global\", the plugin is reloaded across all nodes and clusters. If a new plugin version has been pinned, this will ensure all instances start using the new version.
     * Reload all instances of a specific plugin.
     */
    async reloadPlugins(requestParameters: ReloadPluginsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReloadPluginsResponse> {
        const response = await this.reloadPluginsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reload the given subsystem
     */
    async reloadSubsystemRaw(requestParameters: ReloadSubsystemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['subsystem'] == null) {
            throw new runtime.RequiredError(
                'subsystem',
                'Required parameter "subsystem" was null or undefined when calling reloadSubsystem().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/reload/{subsystem}`.replace(`{${"subsystem"}}`, encodeURIComponent(String(requestParameters['subsystem']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Reload the given subsystem
     */
    async reloadSubsystem(requestParameters: ReloadSubsystemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.reloadSubsystemRaw(requestParameters, initOverrides);
    }

    /**
     * Initiate a mount migration
     */
    async remountRaw(requestParameters: RemountOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RemountResponse>> {
        if (requestParameters['remountRequest'] == null) {
            throw new runtime.RequiredError(
                'remountRequest',
                'Required parameter "remountRequest" was null or undefined when calling remount().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/remount`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RemountRequestToJSON(requestParameters['remountRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RemountResponseFromJSON(jsonValue));
    }

    /**
     * Initiate a mount migration
     */
    async remount(requestParameters: RemountOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RemountResponse> {
        const response = await this.remountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check status of a mount migration
     */
    async remountStatusRaw(requestParameters: RemountStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RemountStatusResponse>> {
        if (requestParameters['migrationId'] == null) {
            throw new runtime.RequiredError(
                'migrationId',
                'Required parameter "migrationId" was null or undefined when calling remountStatus().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/remount/status/{migration_id}`.replace(`{${"migration_id"}}`, encodeURIComponent(String(requestParameters['migrationId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RemountStatusResponseFromJSON(jsonValue));
    }

    /**
     * Check status of a mount migration
     */
    async remountStatus(requestParameters: RemountStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RemountStatusResponse> {
        const response = await this.remountStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async rewrapRaw(requestParameters: RewrapOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['rewrapRequest'] == null) {
            throw new runtime.RequiredError(
                'rewrapRequest',
                'Required parameter "rewrapRequest" was null or undefined when calling rewrap().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/wrapping/rewrap`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RewrapRequestToJSON(requestParameters['rewrapRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async rewrap(requestParameters: RewrapOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.rewrapRaw(requestParameters, initOverrides);
    }

    /**
     * Cancels any in-progress root generation attempt.
     */
    async rootTokenGenerationCancelRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/generate-root/attempt`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Cancels any in-progress root generation attempt.
     */
    async rootTokenGenerationCancel(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.rootTokenGenerationCancelRaw(initOverrides);
    }

    /**
     * Cancels any in-progress root generation attempt.
     */
    async rootTokenGenerationCancel2Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/generate-root`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Cancels any in-progress root generation attempt.
     */
    async rootTokenGenerationCancel2(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.rootTokenGenerationCancel2Raw(initOverrides);
    }

    /**
     * Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
     * Initializes a new root generation attempt.
     */
    async rootTokenGenerationInitializeRaw(requestParameters: RootTokenGenerationInitializeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RootTokenGenerationInitializeResponse>> {
        if (requestParameters['rootTokenGenerationInitializeRequest'] == null) {
            throw new runtime.RequiredError(
                'rootTokenGenerationInitializeRequest',
                'Required parameter "rootTokenGenerationInitializeRequest" was null or undefined when calling rootTokenGenerationInitialize().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/generate-root/attempt`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RootTokenGenerationInitializeRequestToJSON(requestParameters['rootTokenGenerationInitializeRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RootTokenGenerationInitializeResponseFromJSON(jsonValue));
    }

    /**
     * Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
     * Initializes a new root generation attempt.
     */
    async rootTokenGenerationInitialize(requestParameters: RootTokenGenerationInitializeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RootTokenGenerationInitializeResponse> {
        const response = await this.rootTokenGenerationInitializeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
     * Initializes a new root generation attempt.
     */
    async rootTokenGenerationInitialize2Raw(requestParameters: RootTokenGenerationInitialize2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RootTokenGenerationInitialize2Response>> {
        if (requestParameters['rootTokenGenerationInitialize2Request'] == null) {
            throw new runtime.RequiredError(
                'rootTokenGenerationInitialize2Request',
                'Required parameter "rootTokenGenerationInitialize2Request" was null or undefined when calling rootTokenGenerationInitialize2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/generate-root`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RootTokenGenerationInitialize2RequestToJSON(requestParameters['rootTokenGenerationInitialize2Request']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RootTokenGenerationInitialize2ResponseFromJSON(jsonValue));
    }

    /**
     * Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
     * Initializes a new root generation attempt.
     */
    async rootTokenGenerationInitialize2(requestParameters: RootTokenGenerationInitialize2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RootTokenGenerationInitialize2Response> {
        const response = await this.rootTokenGenerationInitialize2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Read the configuration and progress of the current root generation attempt.
     */
    async rootTokenGenerationReadProgressRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RootTokenGenerationReadProgressResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/generate-root/attempt`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RootTokenGenerationReadProgressResponseFromJSON(jsonValue));
    }

    /**
     * Read the configuration and progress of the current root generation attempt.
     */
    async rootTokenGenerationReadProgress(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RootTokenGenerationReadProgressResponse> {
        const response = await this.rootTokenGenerationReadProgressRaw(initOverrides);
        return await response.value();
    }

    /**
     * Read the configuration and progress of the current root generation attempt.
     */
    async rootTokenGenerationReadProgress2Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RootTokenGenerationReadProgress2Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/generate-root`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RootTokenGenerationReadProgress2ResponseFromJSON(jsonValue));
    }

    /**
     * Read the configuration and progress of the current root generation attempt.
     */
    async rootTokenGenerationReadProgress2(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RootTokenGenerationReadProgress2Response> {
        const response = await this.rootTokenGenerationReadProgress2Raw(initOverrides);
        return await response.value();
    }

    /**
     * If the threshold number of unseal key shares is reached, Vault will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.
     * Enter a single unseal key share to progress the root generation attempt.
     */
    async rootTokenGenerationUpdateRaw(requestParameters: RootTokenGenerationUpdateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RootTokenGenerationUpdateResponse>> {
        if (requestParameters['rootTokenGenerationUpdateRequest'] == null) {
            throw new runtime.RequiredError(
                'rootTokenGenerationUpdateRequest',
                'Required parameter "rootTokenGenerationUpdateRequest" was null or undefined when calling rootTokenGenerationUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/generate-root/update`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RootTokenGenerationUpdateRequestToJSON(requestParameters['rootTokenGenerationUpdateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RootTokenGenerationUpdateResponseFromJSON(jsonValue));
    }

    /**
     * If the threshold number of unseal key shares is reached, Vault will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.
     * Enter a single unseal key share to progress the root generation attempt.
     */
    async rootTokenGenerationUpdate(requestParameters: RootTokenGenerationUpdateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RootTokenGenerationUpdateResponse> {
        const response = await this.rootTokenGenerationUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Seal the Vault.
     */
    async sealRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/seal`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Seal the Vault.
     */
    async seal(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.sealRaw(initOverrides);
    }

    /**
     * Check the seal status of a Vault.
     */
    async sealStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SealStatusResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/seal-status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SealStatusResponseFromJSON(jsonValue));
    }

    /**
     * Check the seal status of a Vault.
     */
    async sealStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SealStatusResponse> {
        const response = await this.sealStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again.
     * Cause the node to give up active status.
     */
    async stepDownLeaderRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/step-down`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again.
     * Cause the node to give up active status.
     */
    async stepDownLeader(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.stepDownLeaderRaw(initOverrides);
    }

    /**
     * Write activity log data
     */
    async systemWriteInternalCountersActivityWriteRaw(requestParameters: SystemWriteInternalCountersActivityWriteOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['systemWriteInternalCountersActivityWriteRequest'] == null) {
            throw new runtime.RequiredError(
                'systemWriteInternalCountersActivityWriteRequest',
                'Required parameter "systemWriteInternalCountersActivityWriteRequest" was null or undefined when calling systemWriteInternalCountersActivityWrite().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/internal/counters/activity/write`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SystemWriteInternalCountersActivityWriteRequestToJSON(requestParameters['systemWriteInternalCountersActivityWriteRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Write activity log data
     */
    async systemWriteInternalCountersActivityWrite(requestParameters: SystemWriteInternalCountersActivityWriteOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.systemWriteInternalCountersActivityWriteRaw(requestParameters, initOverrides);
    }

    /**
     * Configure the values to be returned for the UI header.
     */
    async uiHeadersConfigureRaw(requestParameters: UiHeadersConfigureOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['header'] == null) {
            throw new runtime.RequiredError(
                'header',
                'Required parameter "header" was null or undefined when calling uiHeadersConfigure().'
            );
        }

        if (requestParameters['uiHeadersConfigureRequest'] == null) {
            throw new runtime.RequiredError(
                'uiHeadersConfigureRequest',
                'Required parameter "uiHeadersConfigureRequest" was null or undefined when calling uiHeadersConfigure().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/config/ui/headers/{header}`.replace(`{${"header"}}`, encodeURIComponent(String(requestParameters['header']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UiHeadersConfigureRequestToJSON(requestParameters['uiHeadersConfigureRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Configure the values to be returned for the UI header.
     */
    async uiHeadersConfigure(requestParameters: UiHeadersConfigureOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.uiHeadersConfigureRaw(requestParameters, initOverrides);
    }

    /**
     * Remove a UI header.
     */
    async uiHeadersDeleteConfigurationRaw(requestParameters: UiHeadersDeleteConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['header'] == null) {
            throw new runtime.RequiredError(
                'header',
                'Required parameter "header" was null or undefined when calling uiHeadersDeleteConfiguration().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/ui/headers/{header}`.replace(`{${"header"}}`, encodeURIComponent(String(requestParameters['header']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a UI header.
     */
    async uiHeadersDeleteConfiguration(requestParameters: UiHeadersDeleteConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.uiHeadersDeleteConfigurationRaw(requestParameters, initOverrides);
    }

    /**
     * Return a list of configured UI headers.
     */
    async uiHeadersListRaw(requestParameters: UiHeadersListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UiHeadersListResponse>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling uiHeadersList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/ui/headers/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UiHeadersListResponseFromJSON(jsonValue));
    }

    /**
     * Return a list of configured UI headers.
     */
    async uiHeadersList(requestParameters: UiHeadersListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UiHeadersListResponse> {
        const response = await this.uiHeadersListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the given UI header\'s configuration
     */
    async uiHeadersReadConfigurationRaw(requestParameters: UiHeadersReadConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UiHeadersReadConfigurationResponse>> {
        if (requestParameters['header'] == null) {
            throw new runtime.RequiredError(
                'header',
                'Required parameter "header" was null or undefined when calling uiHeadersReadConfiguration().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/config/ui/headers/{header}`.replace(`{${"header"}}`, encodeURIComponent(String(requestParameters['header']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UiHeadersReadConfigurationResponseFromJSON(jsonValue));
    }

    /**
     * Return the given UI header\'s configuration
     */
    async uiHeadersReadConfiguration(requestParameters: UiHeadersReadConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UiHeadersReadConfigurationResponse> {
        const response = await this.uiHeadersReadConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unseal the Vault.
     */
    async unsealRaw(requestParameters: UnsealOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnsealResponse>> {
        if (requestParameters['unsealRequest'] == null) {
            throw new runtime.RequiredError(
                'unsealRequest',
                'Required parameter "unsealRequest" was null or undefined when calling unseal().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/unseal`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UnsealRequestToJSON(requestParameters['unsealRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UnsealResponseFromJSON(jsonValue));
    }

    /**
     * Unseal the Vault.
     */
    async unseal(requestParameters: UnsealOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnsealResponse> {
        const response = await this.unsealRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async unwrapRaw(requestParameters: UnwrapOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['unwrapRequest'] == null) {
            throw new runtime.RequiredError(
                'unwrapRequest',
                'Required parameter "unwrapRequest" was null or undefined when calling unwrap().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/wrapping/unwrap`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UnwrapRequestToJSON(requestParameters['unwrapRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async unwrap(requestParameters: UnwrapOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unwrapRaw(requestParameters, initOverrides);
    }

    /**
     * Returns map of historical version change entries
     */
    async versionHistoryRaw(requestParameters: VersionHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionHistoryResponse>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling versionHistory().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/version-history/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionHistoryResponseFromJSON(jsonValue));
    }

    /**
     * Returns map of historical version change entries
     */
    async versionHistory(requestParameters: VersionHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionHistoryResponse> {
        const response = await this.versionHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async wellKnownListLabelsRaw(requestParameters: WellKnownListLabelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WellKnownListLabelsResponse>> {
        if (requestParameters['list'] == null) {
            throw new runtime.RequiredError(
                'list',
                'Required parameter "list" was null or undefined when calling wellKnownListLabels().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['list'] != null) {
            queryParameters['list'] = requestParameters['list'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/well-known/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WellKnownListLabelsResponseFromJSON(jsonValue));
    }

    /**
     */
    async wellKnownListLabels(requestParameters: WellKnownListLabelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WellKnownListLabelsResponse> {
        const response = await this.wellKnownListLabelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async wellKnownListLabels2Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WellKnownListLabels2Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/well-known`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WellKnownListLabels2ResponseFromJSON(jsonValue));
    }

    /**
     */
    async wellKnownListLabels2(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WellKnownListLabels2Response> {
        const response = await this.wellKnownListLabels2Raw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the associated mount information for a registered well-known label.
     */
    async wellKnownReadLabelRaw(requestParameters: WellKnownReadLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WellKnownReadLabelResponse>> {
        if (requestParameters['label'] == null) {
            throw new runtime.RequiredError(
                'label',
                'Required parameter "label" was null or undefined when calling wellKnownReadLabel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sys/well-known/{label}`.replace(`{${"label"}}`, encodeURIComponent(String(requestParameters['label']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WellKnownReadLabelResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the associated mount information for a registered well-known label.
     */
    async wellKnownReadLabel(requestParameters: WellKnownReadLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WellKnownReadLabelResponse> {
        const response = await this.wellKnownReadLabelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async wrapRaw(requestParameters: WrapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling wrap().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sys/wrapping/wrap`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async wrap(requestParameters: WrapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.wrapRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const EnterpriseStubListManagedKeysTypeListEnum = {
    True: 'true'
} as const;
export type EnterpriseStubListManagedKeysTypeListEnum = typeof EnterpriseStubListManagedKeysTypeListEnum[keyof typeof EnterpriseStubListManagedKeysTypeListEnum];
/**
 * @export
 */
export const EnterpriseStubListMfaMethodListEnum = {
    True: 'true'
} as const;
export type EnterpriseStubListMfaMethodListEnum = typeof EnterpriseStubListMfaMethodListEnum[keyof typeof EnterpriseStubListMfaMethodListEnum];
/**
 * @export
 */
export const EnterpriseStubListNamespacesListEnum = {
    True: 'true'
} as const;
export type EnterpriseStubListNamespacesListEnum = typeof EnterpriseStubListNamespacesListEnum[keyof typeof EnterpriseStubListNamespacesListEnum];
/**
 * @export
 */
export const EnterpriseStubListPoliciesEgpListEnum = {
    True: 'true'
} as const;
export type EnterpriseStubListPoliciesEgpListEnum = typeof EnterpriseStubListPoliciesEgpListEnum[keyof typeof EnterpriseStubListPoliciesEgpListEnum];
/**
 * @export
 */
export const EnterpriseStubListPoliciesRgpListEnum = {
    True: 'true'
} as const;
export type EnterpriseStubListPoliciesRgpListEnum = typeof EnterpriseStubListPoliciesRgpListEnum[keyof typeof EnterpriseStubListPoliciesRgpListEnum];
/**
 * @export
 */
export const EnterpriseStubListQuotasLeaseCountListEnum = {
    True: 'true'
} as const;
export type EnterpriseStubListQuotasLeaseCountListEnum = typeof EnterpriseStubListQuotasLeaseCountListEnum[keyof typeof EnterpriseStubListQuotasLeaseCountListEnum];
/**
 * @export
 */
export const EnterpriseStubListStorageRaftSnapshotAutoConfigListEnum = {
    True: 'true'
} as const;
export type EnterpriseStubListStorageRaftSnapshotAutoConfigListEnum = typeof EnterpriseStubListStorageRaftSnapshotAutoConfigListEnum[keyof typeof EnterpriseStubListStorageRaftSnapshotAutoConfigListEnum];
/**
 * @export
 */
export const LeasesLookUpListEnum = {
    True: 'true'
} as const;
export type LeasesLookUpListEnum = typeof LeasesLookUpListEnum[keyof typeof LeasesLookUpListEnum];
/**
 * @export
 */
export const PluginsCatalogListPluginsWithTypeListEnum = {
    True: 'true'
} as const;
export type PluginsCatalogListPluginsWithTypeListEnum = typeof PluginsCatalogListPluginsWithTypeListEnum[keyof typeof PluginsCatalogListPluginsWithTypeListEnum];
/**
 * @export
 */
export const PluginsRuntimesCatalogListPluginsRuntimes0ListEnum = {
    True: 'true'
} as const;
export type PluginsRuntimesCatalogListPluginsRuntimes0ListEnum = typeof PluginsRuntimesCatalogListPluginsRuntimes0ListEnum[keyof typeof PluginsRuntimesCatalogListPluginsRuntimes0ListEnum];
/**
 * @export
 */
export const PoliciesListAclPoliciesListEnum = {
    True: 'true'
} as const;
export type PoliciesListAclPoliciesListEnum = typeof PoliciesListAclPoliciesListEnum[keyof typeof PoliciesListAclPoliciesListEnum];
/**
 * @export
 */
export const PoliciesListAclPolicies3ListEnum = {
    True: 'true'
} as const;
export type PoliciesListAclPolicies3ListEnum = typeof PoliciesListAclPolicies3ListEnum[keyof typeof PoliciesListAclPolicies3ListEnum];
/**
 * @export
 */
export const PoliciesListPasswordPoliciesListEnum = {
    True: 'true'
} as const;
export type PoliciesListPasswordPoliciesListEnum = typeof PoliciesListPasswordPoliciesListEnum[keyof typeof PoliciesListPasswordPoliciesListEnum];
/**
 * @export
 */
export const RateLimitQuotasListListEnum = {
    True: 'true'
} as const;
export type RateLimitQuotasListListEnum = typeof RateLimitQuotasListListEnum[keyof typeof RateLimitQuotasListListEnum];
/**
 * @export
 */
export const RawListListEnum = {
    True: 'true'
} as const;
export type RawListListEnum = typeof RawListListEnum[keyof typeof RawListListEnum];
/**
 * @export
 */
export const UiHeadersListListEnum = {
    True: 'true'
} as const;
export type UiHeadersListListEnum = typeof UiHeadersListListEnum[keyof typeof UiHeadersListListEnum];
/**
 * @export
 */
export const VersionHistoryListEnum = {
    True: 'true'
} as const;
export type VersionHistoryListEnum = typeof VersionHistoryListEnum[keyof typeof VersionHistoryListEnum];
/**
 * @export
 */
export const WellKnownListLabelsListEnum = {
    True: 'true'
} as const;
export type WellKnownListLabelsListEnum = typeof WellKnownListLabelsListEnum[keyof typeof WellKnownListLabelsListEnum];
