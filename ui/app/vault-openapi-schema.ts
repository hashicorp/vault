/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/auth/token/accessors/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List token accessors, which can then be
     *     be used to iterate and discover their properties
     *     or revoke them. Because this can be used to
     *     cause a denial of service, this endpoint
     *     requires 'sudo' capability in addition to
     *     'list'. */
    get: operations['token-list-accessors'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** The token create path is used to create new tokens. */
    post: operations['token-create'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/create-orphan': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** The token create path is used to create new orphan tokens. */
    post: operations['token-create-orphan'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/create/{role_name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        role_name: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** This token create path is used to create new tokens adhering to the given role. */
    post: operations['token-create-against-role'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/lookup': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['token-look-up-2'];
    put?: never;
    post: operations['token-look-up'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/lookup-accessor': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID. */
    post: operations['token-look-up-accessor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/lookup-self': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['token-look-up-self'];
    put?: never;
    post: operations['token-look-up-self2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/renew': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** This endpoint will renew the given token and prevent expiration. */
    post: operations['token-renew'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/renew-accessor': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID. */
    post: operations['token-renew-accessor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/renew-self': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** This endpoint will renew the token used to call it and prevent expiration. */
    post: operations['token-renew-self'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/revoke': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** This endpoint will delete the given token and all of its child tokens. */
    post: operations['token-revoke'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/revoke-accessor': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** This endpoint will delete the token associated with the accessor and all of its child tokens. */
    post: operations['token-revoke-accessor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/revoke-orphan': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** This endpoint will delete the token and orphan its child tokens. */
    post: operations['token-revoke-orphan'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/revoke-self': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** This endpoint will delete the token used to call it and all of its child tokens. */
    post: operations['token-revoke-self'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** This endpoint lists configured roles. */
    get: operations['token-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/roles/{role_name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        role_name: string;
      };
      cookie?: never;
    };
    get: operations['token-read-role'];
    put?: never;
    post: operations['token-write-role'];
    delete: operations['token-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/token/tidy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** This endpoint performs cleanup tasks that can be run if certain error
     *     conditions have occurred. */
    post: operations['token-tidy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{alicloud_mount_path}/login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Authenticates an RAM entity with Vault. */
    post: operations['ali-cloud-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{alicloud_mount_path}/role/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    /** Lists all the roles that are registered with Vault. */
    get: operations['ali-cloud-list-auth-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{alicloud_mount_path}/role/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role as it should appear in Vault. */
        role: string;
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    /** Create a role and associate policies to it. */
    get: operations['ali-cloud-read-auth-role'];
    put?: never;
    /** Create a role and associate policies to it. */
    post: operations['ali-cloud-write-auth-role'];
    /** Create a role and associate policies to it. */
    delete: operations['ali-cloud-delete-auth-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{alicloud_mount_path}/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    /** Lists all the roles that are registered with Vault. */
    get: operations['ali-cloud-list-auth-roles2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['app-role-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-role'];
    put?: never;
    post: operations['app-role-write-role'];
    delete: operations['app-role-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/bind-secret-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-bind-secret-id'];
    put?: never;
    post: operations['app-role-write-bind-secret-id'];
    delete: operations['app-role-delete-bind-secret-id'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-bound-cidr-list'];
    put?: never;
    post: operations['app-role-write-bound-cidr-list'];
    delete: operations['app-role-delete-bound-cidr-list'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/custom-secret-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['app-role-write-custom-secret-id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/local-secret-ids': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-local-secret-ids'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/period': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-period'];
    put?: never;
    post: operations['app-role-write-period'];
    delete: operations['app-role-delete-period'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/policies': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-policies'];
    put?: never;
    post: operations['app-role-write-policies'];
    delete: operations['app-role-delete-policies'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/role-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-role-id'];
    put?: never;
    post: operations['app-role-write-role-id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/secret-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['app-role-write-secret-id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['app-role-destroy-secret-id-by-accessor'];
    delete: operations['app-role-destroy-secret-id-by-accessor2'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/lookup': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['app-role-look-up-secret-id-by-accessor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-secret-id-bound-cidrs'];
    put?: never;
    post: operations['app-role-write-secret-id-bound-cidrs'];
    delete: operations['app-role-delete-secret-id-bound-cidrs'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-secret-id-num-uses'];
    put?: never;
    post: operations['app-role-write-secret-id-num-uses'];
    delete: operations['app-role-delete-secret-id-num-uses'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-secret-id-ttl'];
    put?: never;
    post: operations['app-role-write-secret-id-ttl'];
    delete: operations['app-role-delete-secret-id-ttl'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/secret-id/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-list-secret-ids'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/secret-id/destroy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['app-role-destroy-secret-id'];
    delete: operations['app-role-destroy-secret-id2'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/secret-id/lookup': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['app-role-look-up-secret-id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-token-bound-cidrs'];
    put?: never;
    post: operations['app-role-write-token-bound-cidrs'];
    delete: operations['app-role-delete-token-bound-cidrs'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/token-max-ttl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-token-max-ttl'];
    put?: never;
    post: operations['app-role-write-token-max-ttl'];
    delete: operations['app-role-delete-token-max-ttl'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/token-num-uses': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-token-num-uses'];
    put?: never;
    post: operations['app-role-write-token-num-uses'];
    delete: operations['app-role-delete-token-num-uses'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/role/{role_name}/token-ttl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['app-role-read-token-ttl'];
    put?: never;
    post: operations['app-role-write-token-ttl'];
    delete: operations['app-role-delete-token-ttl'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{approle_mount_path}/tidy/secret-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['app-role-tidy-secret-id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/config/certificate/{cert_name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the certificate. */
        cert_name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-certificate-configuration'];
    put?: never;
    post: operations['aws-configure-certificate'];
    delete: operations['aws-delete-certificate-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/config/certificates/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-list-certificate-configurations'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/config/client': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-client-configuration'];
    put?: never;
    post: operations['aws-configure-client'];
    delete: operations['aws-delete-client-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/config/identity': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-identity-integration-configuration'];
    put?: never;
    post: operations['aws-configure-identity-integration'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/config/rotate-root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['aws-rotate-root-credentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/config/sts/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-list-sts-role-relationships'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/config/sts/{account_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account. */
        account_id: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-sts-role'];
    put?: never;
    post: operations['aws-write-sts-role'];
    delete: operations['aws-delete-sts-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/config/tidy/identity-accesslist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-identity-access-list-tidy-settings'];
    put?: never;
    post: operations['aws-configure-identity-access-list-tidy-operation'];
    delete: operations['aws-delete-identity-access-list-tidy-settings'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/config/tidy/identity-whitelist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-identity-whitelist-tidy-settings'];
    put?: never;
    post: operations['aws-configure-identity-whitelist-tidy-operation'];
    delete: operations['aws-delete-identity-whitelist-tidy-settings'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/config/tidy/roletag-blacklist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-role-tag-blacklist-tidy-settings'];
    put?: never;
    post: operations['aws-configure-role-tag-blacklist-tidy-operation'];
    delete: operations['aws-delete-role-tag-blacklist-tidy-settings'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/config/tidy/roletag-denylist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-role-tag-deny-list-tidy-settings'];
    put?: never;
    post: operations['aws-configure-role-tag-deny-list-tidy-operation'];
    delete: operations['aws-delete-role-tag-deny-list-tidy-settings'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/identity-accesslist/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-list-identity-access-list'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/identity-accesslist/{instance_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID. */
        instance_id: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-identity-access-list'];
    put?: never;
    post?: never;
    delete: operations['aws-delete-identity-access-list'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/identity-whitelist/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-list-identity-whitelist'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/identity-whitelist/{instance_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID. */
        instance_id: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-identity-whitelist'];
    put?: never;
    post?: never;
    delete: operations['aws-delete-identity-whitelist'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['aws-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/role/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-list-auth-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/role/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-auth-role'];
    put?: never;
    post: operations['aws-write-auth-role'];
    delete: operations['aws-delete-auth-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/role/{role}/tag': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['aws-write-role-tag'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-list-auth-roles2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/roletag-blacklist/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-list-role-tag-blacklists'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/roletag-blacklist/{role_tag}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded. */
        role_tag: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-role-tag-blacklist'];
    put?: never;
    post: operations['aws-write-role-tag-blacklist'];
    delete: operations['aws-delete-role-tag-blacklist'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/roletag-denylist/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-list-role-tag-deny-lists'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/roletag-denylist/{role_tag}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded. */
        role_tag: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-role-tag-deny-list'];
    put?: never;
    post: operations['aws-write-role-tag-deny-list'];
    delete: operations['aws-delete-role-tag-deny-list'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/tidy/identity-accesslist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['aws-tidy-identity-access-list'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/tidy/identity-whitelist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['aws-tidy-identity-whitelist'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/tidy/roletag-blacklist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['aws-tidy-role-tag-blacklist'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{aws_mount_path}/tidy/roletag-denylist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['aws-tidy-role-tag-deny-list'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{azure_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['azure-read-auth-configuration'];
    put?: never;
    post: operations['azure-configure-auth'];
    delete: operations['azure-delete-auth-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{azure_mount_path}/login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['azure-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{azure_mount_path}/role/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['azure-list-auth-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{azure_mount_path}/role/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['azure-read-auth-role'];
    put?: never;
    post: operations['azure-write-auth-role'];
    delete: operations['azure-delete-auth-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{azure_mount_path}/rotate-root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['azure-rotate-root-credentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{cert_mount_path}/certs/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage trusted certificates used for authentication. */
    get: operations['cert-list-certificates'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{cert_mount_path}/certs/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the certificate */
        name: string;
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage trusted certificates used for authentication. */
    get: operations['cert-read-certificate'];
    put?: never;
    /** Manage trusted certificates used for authentication. */
    post: operations['cert-write-certificate'];
    /** Manage trusted certificates used for authentication. */
    delete: operations['cert-delete-certificate'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{cert_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['cert-read-configuration'];
    put?: never;
    post: operations['cert-configure'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{cert_mount_path}/crls/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['cert-list-crls'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{cert_mount_path}/crls/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the certificate */
        name: string;
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage Certificate Revocation Lists checked during authentication. */
    get: operations['cert-read-crl'];
    put?: never;
    /** Manage Certificate Revocation Lists checked during authentication. */
    post: operations['cert-write-crl'];
    /** Manage Certificate Revocation Lists checked during authentication. */
    delete: operations['cert-delete-crl'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{cert_mount_path}/login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['cert-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{cf_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cf_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['cloud-foundry-read-configuration'];
    put?: never;
    post: operations['cloud-foundry-configure'];
    delete: operations['cloud-foundry-delete-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{cf_mount_path}/login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cf_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['cloud-foundry-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{cf_mount_path}/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cf_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['cloud-foundry-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{cf_mount_path}/roles/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        cf_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['cloud-foundry-read-role'];
    put?: never;
    post: operations['cloud-foundry-write-role'];
    delete: operations['cloud-foundry-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{gcp_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-read-auth-configuration'];
    put?: never;
    post: operations['google-cloud-configure-auth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{gcp_mount_path}/login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['google-cloud-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{gcp_mount_path}/role/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    /** Lists all the roles that are registered with Vault. */
    get: operations['google-cloud-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{gcp_mount_path}/role/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    /** Create a GCP role with associated policies and required attributes. */
    get: operations['google-cloud-read-role'];
    put?: never;
    /** Create a GCP role with associated policies and required attributes. */
    post: operations['google-cloud-write-role'];
    /** Create a GCP role with associated policies and required attributes. */
    delete: operations['google-cloud-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{gcp_mount_path}/role/{name}/labels': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Add or remove labels for an existing 'gce' role */
    post: operations['google-cloud-edit-labels-for-role'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{gcp_mount_path}/role/{name}/service-accounts': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Add or remove service accounts for an existing `iam` role */
    post: operations['google-cloud-edit-service-accounts-for-role'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{gcp_mount_path}/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    /** Lists all the roles that are registered with Vault. */
    get: operations['google-cloud-list-roles2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{github_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['github-read-configuration'];
    put?: never;
    post: operations['github-configure'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{github_mount_path}/login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['github-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{github_mount_path}/map/teams': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    /** Read mappings for teams */
    get: operations['github-list-teams2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{github_mount_path}/map/teams/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    /** Read mappings for teams */
    get: operations['github-list-teams'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{github_mount_path}/map/teams/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Key for the teams mapping */
        key: string;
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    /** Read/write/delete a single teams mapping */
    get: operations['github-read-team-mapping'];
    put?: never;
    /** Read/write/delete a single teams mapping */
    post: operations['github-write-team-mapping'];
    /** Read/write/delete a single teams mapping */
    delete: operations['github-delete-team-mapping'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{github_mount_path}/map/users': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    /** Read mappings for users */
    get: operations['github-list-users2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{github_mount_path}/map/users/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    /** Read mappings for users */
    get: operations['github-list-users'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{github_mount_path}/map/users/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Key for the users mapping */
        key: string;
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    /** Read/write/delete a single users mapping */
    get: operations['github-read-user-mapping'];
    put?: never;
    /** Read/write/delete a single users mapping */
    post: operations['github-write-user-mapping'];
    /** Read/write/delete a single users mapping */
    delete: operations['github-delete-user-mapping'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{jwt_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    /** Read the current JWT authentication backend configuration. */
    get: operations['jwt-read-configuration'];
    put?: never;
    /**
     * Configure the JWT authentication backend.
     * @description The JWT authentication backend validates JWTs (or OIDC) using the configured
     *     credentials. If using OIDC Discovery, the URL must be provided, along
     *     with (optionally) the CA cert to use for the connection. If performing JWT
     *     validation locally, a set of public keys must be provided.
     */
    post: operations['jwt-configure'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{jwt_mount_path}/login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Authenticates to Vault using a JWT (or OIDC) token. */
    post: operations['jwt-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{jwt_mount_path}/oidc/auth_url': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Request an authorization URL to start an OIDC login flow. */
    post: operations['jwt-oidc-request-authorization-url'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{jwt_mount_path}/oidc/callback': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    /** Callback endpoint to complete an OIDC login. */
    get: operations['jwt-oidc-callback'];
    put?: never;
    /** Callback endpoint to handle form_posts. */
    post: operations['jwt-oidc-callback-form-post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{jwt_mount_path}/role/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    /**
     * Lists all the roles registered with the backend.
     * @description The list will contain the names of the roles.
     */
    get: operations['jwt-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{jwt_mount_path}/role/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    /** Read an existing role. */
    get: operations['jwt-read-role'];
    put?: never;
    /**
     * Register an role with the backend.
     * @description A role is required to authenticate with this backend. The role binds
     *     		JWT token information with token policies and settings.
     *     		The bindings, token polices and token settings can all be configured
     *     		using this endpoint
     */
    post: operations['jwt-write-role'];
    /** Delete an existing role. */
    delete: operations['jwt-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{kerberos_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kerberos-read-configuration'];
    put?: never;
    post: operations['kerberos-configure'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{kerberos_mount_path}/config/ldap': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kerberos-read-ldap-configuration'];
    put?: never;
    post: operations['kerberos-configure-ldap'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{kerberos_mount_path}/groups/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kerberos-list-groups'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{kerberos_mount_path}/groups/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the LDAP group. */
        name: string;
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kerberos-read-group'];
    put?: never;
    post: operations['kerberos-write-group'];
    delete: operations['kerberos-delete-group'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{kerberos_mount_path}/login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kerberos-login2'];
    put?: never;
    post: operations['kerberos-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{kubernetes_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kubernetes-read-auth-configuration'];
    put?: never;
    post: operations['kubernetes-configure-auth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{kubernetes_mount_path}/login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Authenticates Kubernetes service accounts with Vault. */
    post: operations['kubernetes-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{kubernetes_mount_path}/role/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    /** Lists all the roles registered with the backend. */
    get: operations['kubernetes-list-auth-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{kubernetes_mount_path}/role/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    /** Register an role with the backend. */
    get: operations['kubernetes-read-auth-role'];
    put?: never;
    /** Register an role with the backend. */
    post: operations['kubernetes-write-auth-role'];
    /** Register an role with the backend. */
    delete: operations['kubernetes-delete-auth-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{ldap_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['ldap-read-auth-configuration'];
    put?: never;
    post: operations['ldap-configure-auth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{ldap_mount_path}/config/rotate-root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['ldap-rotate-root-credentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{ldap_mount_path}/groups/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage additional groups for users allowed to authenticate. */
    get: operations['ldap-list-groups'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{ldap_mount_path}/groups/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the LDAP group. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage additional groups for users allowed to authenticate. */
    get: operations['ldap-read-group'];
    put?: never;
    /** Manage additional groups for users allowed to authenticate. */
    post: operations['ldap-write-group'];
    /** Manage additional groups for users allowed to authenticate. */
    delete: operations['ldap-delete-group'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{ldap_mount_path}/login/{username}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description DN (distinguished name) to be used for login. */
        username: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Log in with a username and password. */
    post: operations['ldap-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{ldap_mount_path}/users/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage users allowed to authenticate. */
    get: operations['ldap-list-users'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{ldap_mount_path}/users/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the LDAP user. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage users allowed to authenticate. */
    get: operations['ldap-read-user'];
    put?: never;
    /** Manage users allowed to authenticate. */
    post: operations['ldap-write-user'];
    /** Manage users allowed to authenticate. */
    delete: operations['ldap-delete-user'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{oci_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        oci_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['oci-read-configuration'];
    put?: never;
    post: operations['oci-configure'];
    delete: operations['oci-delete-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{oci_mount_path}/login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        oci_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{oci_mount_path}/login/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        oci_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Authenticates to Vault using OCI credentials */
    post: operations['oci-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{oci_mount_path}/role/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        oci_mount_path: string;
      };
      cookie?: never;
    };
    /** Lists all the roles that are registered with Vault. */
    get: operations['oci-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{oci_mount_path}/role/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        oci_mount_path: string;
      };
      cookie?: never;
    };
    /** Create a role and associate policies to it. */
    get: operations['oci-read-role'];
    put?: never;
    /** Create a role and associate policies to it. */
    post: operations['oci-write-role'];
    /** Create a role and associate policies to it. */
    delete: operations['oci-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{okta_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['okta-read-configuration'];
    put?: never;
    post: operations['okta-configure'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{okta_mount_path}/groups/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage users allowed to authenticate. */
    get: operations['okta-list-groups'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{okta_mount_path}/groups/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the Okta group. */
        name: string;
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage users allowed to authenticate. */
    get: operations['okta-read-group'];
    put?: never;
    /** Manage users allowed to authenticate. */
    post: operations['okta-write-group'];
    /** Manage users allowed to authenticate. */
    delete: operations['okta-delete-group'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{okta_mount_path}/login/{username}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username to be used for login. */
        username: string;
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Log in with a username and password. */
    post: operations['okta-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{okta_mount_path}/users/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage additional groups for users allowed to authenticate. */
    get: operations['okta-list-users'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{okta_mount_path}/users/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the user. */
        name: string;
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage additional groups for users allowed to authenticate. */
    get: operations['okta-read-user'];
    put?: never;
    /** Manage additional groups for users allowed to authenticate. */
    post: operations['okta-write-user'];
    /** Manage additional groups for users allowed to authenticate. */
    delete: operations['okta-delete-user'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{okta_mount_path}/verify/{nonce}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Nonce provided during a login request to retrieve the number verification challenge for the matching request. */
        nonce: string;
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['okta-verify'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{radius_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        radius_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['radius-read-configuration'];
    put?: never;
    post: operations['radius-configure'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{radius_mount_path}/login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        radius_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Log in with a username and password. */
    post: operations['radius-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{radius_mount_path}/login/{urlusername}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username to be used for login. (URL parameter) */
        urlusername: string;
        /** @description Path that the backend was mounted at */
        radius_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Log in with a username and password. */
    post: operations['radius-login-with-username'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{radius_mount_path}/users/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        radius_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage users allowed to authenticate. */
    get: operations['radius-list-users'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{radius_mount_path}/users/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the RADIUS user. */
        name: string;
        /** @description Path that the backend was mounted at */
        radius_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage users allowed to authenticate. */
    get: operations['radius-read-user'];
    put?: never;
    /** Manage users allowed to authenticate. */
    post: operations['radius-write-user'];
    /** Manage users allowed to authenticate. */
    delete: operations['radius-delete-user'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{userpass_mount_path}/login/{username}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username of the user. */
        username: string;
        /** @description Path that the backend was mounted at */
        userpass_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Log in with a username and password. */
    post: operations['userpass-login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{userpass_mount_path}/users/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        userpass_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage users allowed to authenticate. */
    get: operations['userpass-list-users'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{userpass_mount_path}/users/{username}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username for this user. */
        username: string;
        /** @description Path that the backend was mounted at */
        userpass_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage users allowed to authenticate. */
    get: operations['userpass-read-user'];
    put?: never;
    /** Manage users allowed to authenticate. */
    post: operations['userpass-write-user'];
    /** Manage users allowed to authenticate. */
    delete: operations['userpass-delete-user'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{userpass_mount_path}/users/{username}/password': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username for this user. */
        username: string;
        /** @description Path that the backend was mounted at */
        userpass_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Reset user's password. */
    post: operations['userpass-reset-password'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/{userpass_mount_path}/users/{username}/policies': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username for this user. */
        username: string;
        /** @description Path that the backend was mounted at */
        userpass_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update the policies associated with the username. */
    post: operations['userpass-update-policies'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cubbyhole/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Specifies the path of the secret. */
        path: string;
      };
      cookie?: never;
    };
    /** Retrieve the secret at the specified location. */
    get: operations['cubbyhole-read'];
    put?: never;
    /** Store a secret at the specified location. */
    post: operations['cubbyhole-write'];
    /** Deletes the secret at the specified location. */
    delete: operations['cubbyhole-delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cubbyhole/{path}/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Specifies the path of the secret. */
        path: string;
      };
      cookie?: never;
    };
    /**
     * List secret entries at the specified location.
     * @description Folders are suffixed with /. The input must be a folder; list on a file will not return a value. The values themselves are not accessible via this command.
     */
    get: operations['cubbyhole-list'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/alias': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create a new alias. */
    post: operations['alias-create'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/alias/id/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all the alias IDs. */
    get: operations['alias-list-by-id'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/alias/id/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the alias */
        id: string;
      };
      cookie?: never;
    };
    get: operations['alias-read-by-id'];
    put?: never;
    post: operations['alias-update-by-id'];
    delete: operations['alias-delete-by-id'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/entity': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['entity-create'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/entity-alias': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create a new alias. */
    post: operations['entity-create-alias'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/entity-alias/id/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all the alias IDs. */
    get: operations['entity-list-aliases-by-id'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/entity-alias/id/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the alias */
        id: string;
      };
      cookie?: never;
    };
    get: operations['entity-read-alias-by-id'];
    put?: never;
    post: operations['entity-update-alias-by-id'];
    delete: operations['entity-delete-alias-by-id'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/entity/batch-delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['entity-batch-delete'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/entity/id/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['entity-list-by-id'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/entity/id/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the entity. If set, updates the corresponding existing entity. */
        id: string;
      };
      cookie?: never;
    };
    get: operations['entity-read-by-id'];
    put?: never;
    post: operations['entity-update-by-id'];
    delete: operations['entity-delete-by-id'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/entity/merge': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['entity-merge'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/entity/name/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['entity-list-by-name'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/entity/name/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the entity */
        name: string;
      };
      cookie?: never;
    };
    get: operations['entity-read-by-name'];
    put?: never;
    post: operations['entity-update-by-name'];
    delete: operations['entity-delete-by-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/group': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['group-create'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/group-alias': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Creates a new group alias, or updates an existing one. */
    post: operations['group-create-alias'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/group-alias/id/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all the group alias IDs. */
    get: operations['group-list-aliases-by-id'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/group-alias/id/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the group alias. */
        id: string;
      };
      cookie?: never;
    };
    get: operations['group-read-alias-by-id'];
    put?: never;
    post: operations['group-update-alias-by-id'];
    delete: operations['group-delete-alias-by-id'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/group/id/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all the group IDs. */
    get: operations['group-list-by-id'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/group/id/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the group. If set, updates the corresponding existing group. */
        id: string;
      };
      cookie?: never;
    };
    get: operations['group-read-by-id'];
    put?: never;
    post: operations['group-update-by-id'];
    delete: operations['group-delete-by-id'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/group/name/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['group-list-by-name'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/group/name/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the group. */
        name: string;
      };
      cookie?: never;
    };
    get: operations['group-read-by-name'];
    put?: never;
    post: operations['group-update-by-name'];
    delete: operations['group-delete-by-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/lookup/entity': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Query entities based on various properties. */
    post: operations['entity-look-up'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/lookup/group': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Query groups based on various properties. */
    post: operations['group-look-up'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/login-enforcement/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List login enforcements */
    get: operations['mfa-list-login-enforcements'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/login-enforcement/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name for this login enforcement configuration */
        name: string;
      };
      cookie?: never;
    };
    /** Read the current login enforcement */
    get: operations['mfa-read-login-enforcement'];
    put?: never;
    /** Create or update a login enforcement */
    post: operations['mfa-write-login-enforcement'];
    /** Delete a login enforcement */
    delete: operations['mfa-delete-login-enforcement'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List MFA method configurations for all MFA methods */
    get: operations['mfa-list-methods'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/duo': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create the given MFA method */
    post: operations['mfa-create-duo-method'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/duo/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List MFA method configurations for the given MFA method */
    get: operations['mfa-list-duo-methods'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/duo/{method_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    /** Read the current configuration for the given MFA method */
    get: operations['mfa-read-duo-method'];
    put?: never;
    /** Update the configuration for the given MFA method */
    post: operations['mfa-update-duo-method'];
    /** Delete the given MFA method */
    delete: operations['mfa-delete-duo-method'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/okta': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create the given MFA method */
    post: operations['mfa-create-okta-method'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/okta/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List MFA method configurations for the given MFA method */
    get: operations['mfa-list-okta-methods'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/okta/{method_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    /** Read the current configuration for the given MFA method */
    get: operations['mfa-read-okta-method'];
    put?: never;
    /** Update the configuration for the given MFA method */
    post: operations['mfa-update-okta-method'];
    /** Delete the given MFA method */
    delete: operations['mfa-delete-okta-method'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/pingid': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create the given MFA method */
    post: operations['mfa-create-ping-id-method'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/pingid/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List MFA method configurations for the given MFA method */
    get: operations['mfa-list-ping-id-methods'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/pingid/{method_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    /** Read the current configuration for the given MFA method */
    get: operations['mfa-read-ping-id-method'];
    put?: never;
    /** Update the configuration for the given MFA method */
    post: operations['mfa-update-ping-id-method'];
    /** Delete the given MFA method */
    delete: operations['mfa-delete-ping-id-method'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/totp': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create the given MFA method */
    post: operations['mfa-create-totp-method'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/totp/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List MFA method configurations for the given MFA method */
    get: operations['mfa-list-totp-methods'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/totp/admin-destroy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Destroys a TOTP secret for the given MFA method ID on the given entity */
    post: operations['mfa-admin-destroy-totp-secret'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/totp/admin-generate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update or create TOTP secret for the given method ID on the given entity. */
    post: operations['mfa-admin-generate-totp-secret'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/totp/generate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update or create TOTP secret for the given method ID on the given entity. */
    post: operations['mfa-generate-totp-secret'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/totp/{method_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    /** Read the current configuration for the given MFA method */
    get: operations['mfa-read-totp-method'];
    put?: never;
    /** Update the configuration for the given MFA method */
    post: operations['mfa-update-totp-method'];
    /** Delete the given MFA method */
    delete: operations['mfa-delete-totp-method'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/mfa/method/{method_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    /** Read the current configuration for the given ID regardless of the MFA method type */
    get: operations['mfa-read-method'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/.well-known/keys': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve public keys */
    get: operations['oidc-read-public-keys'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/.well-known/openid-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Query OIDC configurations */
    get: operations['oidc-read-open-id-configuration'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/assignment/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['oidc-list-assignments'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/assignment/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the assignment */
        name: string;
      };
      cookie?: never;
    };
    get: operations['oidc-read-assignment'];
    put?: never;
    post: operations['oidc-write-assignment'];
    delete: operations['oidc-delete-assignment'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/client/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['oidc-list-clients'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/client/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the client. */
        name: string;
      };
      cookie?: never;
    };
    get: operations['oidc-read-client'];
    put?: never;
    post: operations['oidc-write-client'];
    delete: operations['oidc-delete-client'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['oidc-read-configuration'];
    put?: never;
    post: operations['oidc-configure'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/introspect': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Verify the authenticity of an OIDC token */
    post: operations['oidc-introspect'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/key/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List OIDC keys */
    get: operations['oidc-list-keys'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/key/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
      };
      cookie?: never;
    };
    /** CRUD operations for OIDC keys. */
    get: operations['oidc-read-key'];
    put?: never;
    /** CRUD operations for OIDC keys. */
    post: operations['oidc-write-key'];
    /** CRUD operations for OIDC keys. */
    delete: operations['oidc-delete-key'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/key/{name}/rotate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Rotate a named OIDC key. */
    post: operations['oidc-rotate-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/provider/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['oidc-list-providers'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/provider/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    get: operations['oidc-read-provider'];
    put?: never;
    post: operations['oidc-write-provider'];
    delete: operations['oidc-delete-provider'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/provider/{name}/.well-known/keys': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    get: operations['oidc-read-provider-public-keys'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/provider/{name}/.well-known/openid-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    get: operations['oidc-read-provider-open-id-configuration'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/provider/{name}/authorize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    get: operations['oidc-provider-authorize'];
    put?: never;
    post: operations['oidc-provider-authorize-with-parameters'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/provider/{name}/token': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['oidc-provider-token'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/provider/{name}/userinfo': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    get: operations['oidc-provider-user-info'];
    put?: never;
    post: operations['oidc-provider-user-info2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/role/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List configured OIDC roles */
    get: operations['oidc-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/role/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
      };
      cookie?: never;
    };
    /** CRUD operations on OIDC Roles */
    get: operations['oidc-read-role'];
    put?: never;
    /** CRUD operations on OIDC Roles */
    post: operations['oidc-write-role'];
    /** CRUD operations on OIDC Roles */
    delete: operations['oidc-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/scope/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['oidc-list-scopes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/scope/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the scope */
        name: string;
      };
      cookie?: never;
    };
    get: operations['oidc-read-scope'];
    put?: never;
    post: operations['oidc-write-scope'];
    delete: operations['oidc-delete-scope'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/token/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
      };
      cookie?: never;
    };
    /** Generate an OIDC token */
    get: operations['oidc-generate-token'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/{child}/.well-known/keys': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the child issuer */
        child: string;
      };
      cookie?: never;
    };
    /** Retrieve public keys */
    get: operations['oidc-read-oidc-child-well-known-keys'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/oidc/{child}/.well-known/openid-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the child issuer */
        child: string;
      };
      cookie?: never;
    };
    /** Query OIDC configurations */
    get: operations['oidc-read-oidc-child-well-known-openid-configuration'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/persona': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create a new alias. */
    post: operations['persona-create'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/persona/id/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all the alias IDs. */
    get: operations['persona-list-by-id'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/identity/persona/id/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the persona */
        id: string;
      };
      cookie?: never;
    };
    get: operations['persona-read-by-id'];
    put?: never;
    post: operations['persona-update-by-id'];
    delete: operations['persona-delete-by-id'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/audit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List the enabled audit devices. */
    get: operations['auditing-list-enabled-devices'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/audit-hash/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the backend. Cannot be delimited. Example: "mysql" */
        path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['auditing-calculate-hash'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/audit/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the backend. Cannot be delimited. Example: "mysql" */
        path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Enable a new audit device at the supplied path. */
    post: operations['auditing-enable-device'];
    /** Disable the audit device at the given path. */
    delete: operations['auditing-disable-device'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/auth': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['auth-list-enabled-methods'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/auth/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to mount to. Cannot be delimited. Example: "user" */
        path: string;
      };
      cookie?: never;
    };
    /** Read the configuration of the auth engine at the given path. */
    get: operations['auth-read-configuration'];
    put?: never;
    /**
     * Enables a new auth method.
     * @description After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.
     *
     *     For example, enable the "foo" auth method will make it accessible at /auth/foo.
     */
    post: operations['auth-enable-method'];
    /** Disable the auth method at the given auth path */
    delete: operations['auth-disable-method'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/auth/{path}/tune': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Tune the configuration parameters for an auth path. */
        path: string;
      };
      cookie?: never;
    };
    /**
     * Reads the given auth path's configuration.
     * @description This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.
     */
    get: operations['auth-read-tuning-information'];
    put?: never;
    /**
     * Tune configuration parameters for a given auth path.
     * @description This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.
     */
    post: operations['auth-tune-configuration-parameters'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/capabilities': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['query-token-capabilities'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/capabilities-accessor': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['query-token-accessor-capabilities'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/capabilities-self': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['query-token-self-capabilities'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/config/auditing/request-headers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List the request headers that are configured to be audited. */
    get: operations['auditing-list-request-headers'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/config/auditing/request-headers/{header}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        header: string;
      };
      cookie?: never;
    };
    /** List the information for the given request header. */
    get: operations['auditing-read-request-header-information'];
    put?: never;
    /** Enable auditing of a header. */
    post: operations['auditing-enable-request-header'];
    /** Disable auditing of the given request header. */
    delete: operations['auditing-disable-request-header'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/config/control-group': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Configure control group global settings. */
    get: operations['system-read-config-control-group'];
    put?: never;
    /** Configure control group global settings. */
    post: operations['system-write-config-control-group'];
    /** Configure control group global settings. */
    delete: operations['system-delete-config-control-group'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/config/cors': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Return the current CORS settings. */
    get: operations['cors-read-configuration'];
    put?: never;
    /** Configure the CORS settings. */
    post: operations['cors-configure'];
    /** Remove any CORS settings. */
    delete: operations['cors-delete-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/config/group-policy-application': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Gets the current status of the policy application mode for Vault.
     * @description Gets the current status of the policy application mode for Vault.
     */
    get: operations['system-read-config-group-policy-application'];
    put?: never;
    /**
     * Updates the policy application mode for Vault.
     * @description The group_policy_application_mode must be provided, as within_namespace_hierarchy or any.
     */
    post: operations['system-write-config-group-policy-application'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/config/reload/{subsystem}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        subsystem: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Reload the given subsystem */
    post: operations['reload-subsystem'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/config/state/sanitized': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Return a sanitized version of the Vault server configuration.
     * @description The sanitized output strips configuration values in the storage, HA storage, and seals stanzas, which may contain sensitive values such as API tokens. It also removes any token or secret fields in other stanzas, such as the circonus_api_token from telemetry.
     */
    get: operations['read-sanitized-configuration-state'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/config/ui/custom-messages': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create custom message */
    post: operations['create-custom-message'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/config/ui/custom-messages/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Lists custom messages */
    get: operations['ui-config-list-custom-messages'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/config/ui/custom-messages/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the custom message */
        id: string;
      };
      cookie?: never;
    };
    /** Read custom message */
    get: operations['ui-config-read-custom-message'];
    put?: never;
    /** Update custom message */
    post: operations['ui-config-update-custom-message'];
    /** Delete custom message */
    delete: operations['ui-config-delete-custom-message'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/config/ui/headers/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Return a list of configured UI headers. */
    get: operations['ui-headers-list'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/config/ui/headers/{header}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the header. */
        header: string;
      };
      cookie?: never;
    };
    /** Return the given UI header's configuration */
    get: operations['ui-headers-read-configuration'];
    put?: never;
    /** Configure the values to be returned for the UI header. */
    post: operations['ui-headers-configure'];
    /** Remove a UI header. */
    delete: operations['ui-headers-delete-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/control-group/authorize': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Authorize a control group request */
    post: operations['system-write-control-group-authorize'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/control-group/request': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Check the status of a control group request */
    post: operations['system-write-control-group-request'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/decode-token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Decodes the encoded token with the otp. */
    post: operations['decode-token'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/experiments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns the available and enabled experiments */
    get: operations['list-experimental-features'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/generate-root': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Read the configuration and progress of the current root generation attempt. */
    get: operations['root-token-generation-read-progress2'];
    put?: never;
    /**
     * Initializes a new root generation attempt.
     * @description Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
     */
    post: operations['root-token-generation-initialize-2'];
    /** Cancels any in-progress root generation attempt. */
    delete: operations['root-token-generation-cancel-2'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/generate-root/attempt': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Read the configuration and progress of the current root generation attempt. */
    get: operations['root-token-generation-read-progress'];
    put?: never;
    /**
     * Initializes a new root generation attempt.
     * @description Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
     */
    post: operations['root-token-generation-initialize'];
    /** Cancels any in-progress root generation attempt. */
    delete: operations['root-token-generation-cancel'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/generate-root/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Enter a single unseal key share to progress the root generation attempt.
     * @description If the threshold number of unseal key shares is reached, Vault will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.
     */
    post: operations['root-token-generation-update'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/ha-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Check the HA status of a Vault cluster */
    get: operations['ha-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/health': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns the health status of Vault. */
    get: operations['read-health-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/host-info': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Information about the host instance that this Vault server is running on.
     * @description Information about the host instance that this Vault server is running on.
     *     		The information that gets collected includes host hardware information, and CPU,
     *     		disk, and memory utilization
     */
    get: operations['collect-host-information'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/in-flight-req': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * reports in-flight requests
     * @description This path responds to the following HTTP methods.
     *     		GET /
     *     			Returns a map of in-flight requests.
     */
    get: operations['collect-in-flight-request-information'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/init': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns the initialization status of Vault. */
    get: operations['read-initialization-status'];
    put?: never;
    /**
     * Initialize a new Vault.
     * @description The Vault must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using Vault HSM.
     */
    post: operations['initialize'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/counters/activity': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Report the client count metrics, for this namespace and all child namespaces. */
    get: operations['internal-client-activity-report-counts'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/counters/activity/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Report the client count metrics, for this namespace and all child namespaces. */
    get: operations['internal-client-activity-export'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/counters/activity/monthly': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Report the number of clients for this month, for this namespace and all child namespaces. */
    get: operations['internal-client-activity-report-counts-this-month'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/counters/activity/write': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Write activity log data */
    post: operations['system-write-internal-counters-activity-write'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/counters/config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Read the client count tracking configuration. */
    get: operations['internal-client-activity-read-configuration'];
    put?: never;
    /** Enable or disable collection of client count, set retention period, or set default reporting period. */
    post: operations['internal-client-activity-configure'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/counters/entities': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Backwards compatibility is not guaranteed for this API */
    get: operations['internal-count-entities'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/counters/requests': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Backwards compatibility is not guaranteed for this API
     * @deprecated
     */
    get: operations['internal-count-requests'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/counters/tokens': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Backwards compatibility is not guaranteed for this API */
    get: operations['internal-count-tokens'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/inspect/router/{tag}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of subtree being observed */
        tag: string;
      };
      cookie?: never;
    };
    /** Expose the route entry and mount entry tables present in the router */
    get: operations['internal-inspect-router'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/request-limiter/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Read the current status of the request limiter. */
    get: operations['read-verbosity-level-for'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/specs/openapi': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['internal-generate-open-api-document'];
    put?: never;
    post: operations['internal-generate-open-api-document-with-parameters'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/ui/authenticated-messages': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieves Active post-login Custom Messages */
    get: operations['internal-ui-read-authenticated-active-custom-messages'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/ui/feature-flags': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Lists enabled feature flags. */
    get: operations['internal-ui-list-enabled-feature-flags'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/ui/mounts': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Lists all enabled and visible auth and secrets mounts. */
    get: operations['internal-ui-list-enabled-visible-mounts'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/ui/mounts/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path of the mount. */
        path: string;
      };
      cookie?: never;
    };
    /** Return information about the given mount. */
    get: operations['internal-ui-read-mount-information'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/ui/namespaces': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Backwards compatibility is not guaranteed for this API */
    get: operations['internal-ui-list-namespaces'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/ui/resultant-acl': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Backwards compatibility is not guaranteed for this API */
    get: operations['internal-ui-read-resultant-acl'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/ui/unauthenticated-messages': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieves Active pre-login Custom Messages */
    get: operations['internal-ui-read-unauthenticated-active-custom-messages'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/internal/ui/version': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Backwards compatibility is not guaranteed for this API */
    get: operations['internal-ui-read-version'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/key-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Provides information about the backend encryption key. */
    get: operations['encryption-key-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/leader': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns the high availability status and current leader instance of Vault. */
    get: operations['leader-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/leases': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['leases-list'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/leases/count': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['leases-count'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/leases/lookup': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['leases-read-lease'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/leases/lookup/{prefix}/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to list leases under. Example: "aws/creds/deploy" */
        prefix: string;
      };
      cookie?: never;
    };
    get: operations['leases-look-up'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/leases/renew': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Renews a lease, requesting to extend the lease. */
    post: operations['leases-renew-lease'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/leases/renew/{url_lease_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The lease identifier to renew. This is included with a lease. */
        url_lease_id: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Renews a lease, requesting to extend the lease. */
    post: operations['leases-renew-lease-with-id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/leases/revoke': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Revokes a lease immediately. */
    post: operations['leases-revoke-lease'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/leases/revoke-force/{prefix}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to revoke keys under. Example: "prod/aws/ops" */
        prefix: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Revokes all secrets or tokens generated under a given prefix immediately
     * @description Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.
     *
     *     By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
     */
    post: operations['leases-force-revoke-lease-with-prefix'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/leases/revoke-prefix/{prefix}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to revoke keys under. Example: "prod/aws/ops" */
        prefix: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Revokes all secrets (via a lease ID prefix) or tokens (via the tokens' path property) generated under a given prefix immediately. */
    post: operations['leases-revoke-lease-with-prefix'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/leases/revoke/{url_lease_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The lease identifier to renew. This is included with a lease. */
        url_lease_id: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Revokes a lease immediately. */
    post: operations['leases-revoke-lease-with-id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/leases/tidy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['leases-tidy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/license/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** The path responds to the following HTTP methods.
     *
     *         GET /
     *             Returns information on the installed license
     *
     *         POST
     *             Sets the license for the server */
    get: operations['system-read-license-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/locked-users': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Report the locked user count metrics, for this namespace and all child namespaces. */
    get: operations['locked-users-list'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/locked-users/{mount_accessor}/unlock/{alias_identifier}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description It is the name of the alias (user). For example, if the alias belongs to userpass backend, the name should be a valid username within userpass auth method. If the alias belongs to an approle auth method, the name should be a valid RoleID */
        alias_identifier: string;
        /** @description MountAccessor is the identifier of the mount entry to which the user belongs */
        mount_accessor: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Unlocks the user with given mount_accessor and alias_identifier */
    post: operations['locked-users-unlock'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/loggers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Read the log level for all existing loggers. */
    get: operations['loggers-read-verbosity-level'];
    put?: never;
    /** Modify the log level for all existing loggers. */
    post: operations['loggers-update-verbosity-level'];
    /** Revert the all loggers to use log level provided in config. */
    delete: operations['loggers-revert-verbosity-level'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/loggers/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the logger to be modified. */
        name: string;
      };
      cookie?: never;
    };
    /** Read the log level for a single logger. */
    get: operations['loggers-read-verbosity-level-for'];
    put?: never;
    /** Modify the log level of a single logger. */
    post: operations['loggers-update-verbosity-level-for'];
    /** Revert a single logger to use log level provided in config. */
    delete: operations['loggers-revert-verbosity-level-for'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/managed-keys/{type}/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The type of the managed key. */
        type: string;
      };
      cookie?: never;
    };
    get: operations['system-list-managed-keys-type'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/managed-keys/{type}/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the managed key. */
        name: string;
        /** @description The type of the managed key. */
        type: string;
      };
      cookie?: never;
    };
    get: operations['system-read-managed-keys-type-name'];
    put?: never;
    post: operations['system-write-managed-keys-type-name'];
    delete: operations['system-delete-managed-keys-type-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/managed-keys/{type}/{name}/test/sign': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the managed key. */
        name: string;
        /** @description The type of the managed key. */
        type: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-managed-keys-type-name-test-sign'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['metrics'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/mfa/method/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Lists all the available MFA methods by their name. */
    get: operations['system-list-mfa-method'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/mfa/method/duo/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    /** Defines or updates a Duo MFA method. */
    get: operations['system-read-mfa-method-duo-name'];
    put?: never;
    /** Defines or updates a Duo MFA method. */
    post: operations['system-write-mfa-method-duo-name'];
    /** Defines or updates a Duo MFA method. */
    delete: operations['system-delete-mfa-method-duo-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/mfa/method/okta/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    /** Defines or updates an Okta MFA method. */
    get: operations['system-read-mfa-method-okta-name'];
    put?: never;
    /** Defines or updates an Okta MFA method. */
    post: operations['system-write-mfa-method-okta-name'];
    /** Defines or updates an Okta MFA method. */
    delete: operations['system-delete-mfa-method-okta-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/mfa/method/pingid/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    /** Defines or updates a PingID MFA method. */
    get: operations['system-read-mfa-method-pingid-name'];
    put?: never;
    /** Defines or updates a PingID MFA method. */
    post: operations['system-write-mfa-method-pingid-name'];
    /** Defines or updates a PingID MFA method. */
    delete: operations['system-delete-mfa-method-pingid-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/mfa/method/totp/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    /** Defines or updates a TOTP MFA method. */
    get: operations['system-read-mfa-method-totp-name'];
    put?: never;
    /** Defines or updates a TOTP MFA method. */
    post: operations['system-write-mfa-method-totp-name'];
    /** Defines or updates a TOTP MFA method. */
    delete: operations['system-delete-mfa-method-totp-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/mfa/method/totp/{name}/admin-destroy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Deletes the TOTP secret for the given method name on the given entity. */
    post: operations['system-write-mfa-method-totp-name-admin-destroy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/mfa/method/totp/{name}/admin-generate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generates a TOTP secret for the given method name on the given entity. */
    post: operations['system-write-mfa-method-totp-name-admin-generate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/mfa/method/totp/{name}/generate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    /** Generates a TOTP secret for the given method name on the entity of the
     *     		calling token. */
    get: operations['system-read-mfa-method-totp-name-generate'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/mfa/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Validates the login for the given MFA methods. Upon successful validation, it returns an auth response containing the client token */
    post: operations['mfa-validate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/monitor': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['monitor'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/mounts': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['mounts-list-secrets-engines'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/mounts/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to mount to. Example: "aws/east" */
        path: string;
      };
      cookie?: never;
    };
    /** Read the configuration of the secret engine at the given path. */
    get: operations['mounts-read-configuration'];
    put?: never;
    /** Enable a new secrets engine at the given path. */
    post: operations['mounts-enable-secrets-engine'];
    /** Disable the mount point specified at the given path. */
    delete: operations['mounts-disable-secrets-engine'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/mounts/{path}/tune': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to mount to. Example: "aws/east" */
        path: string;
      };
      cookie?: never;
    };
    get: operations['mounts-read-tuning-information'];
    put?: never;
    post: operations['mounts-tune-configuration-parameters'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/namespaces/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['system-list-namespaces'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/namespaces/api-lock/lock': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Lock the API for a namespace and its descendants */
    post: operations['system-write-namespaces-api-lock-lock'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/namespaces/api-lock/lock/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Optional relative path for locking descendants of the current namespace. */
        path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Lock the API for a namespace and its descendants */
    post: operations['system-write-namespaces-api-lock-lock-path'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/namespaces/api-lock/unlock': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Unlock the API for a namespace and its descendants */
    post: operations['system-write-namespaces-api-lock-unlock'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/namespaces/api-lock/unlock/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Optional relative path for unlocking descendants of the current namespace. */
        path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Unlock the API for a namespace and its descendants */
    post: operations['system-write-namespaces-api-lock-unlock-path'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/namespaces/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path of the namespace. */
        path: string;
      };
      cookie?: never;
    };
    get: operations['system-read-namespaces-path'];
    put?: never;
    post: operations['system-write-namespaces-path'];
    delete: operations['system-delete-namespaces-path'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/plugins/catalog': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['plugins-catalog-list-plugins'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/plugins/catalog/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin */
        name: string;
      };
      cookie?: never;
    };
    /** Return the configuration data for the plugin with the given name. */
    get: operations['plugins-catalog-read-plugin-configuration'];
    put?: never;
    /** Register a new plugin, or updates an existing one with the supplied name. */
    post: operations['plugins-catalog-register-plugin'];
    /** Remove the plugin with the given name. */
    delete: operations['plugins-catalog-remove-plugin'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/plugins/catalog/{type}/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The type of the plugin, may be auth, secret, or database */
        type: string;
      };
      cookie?: never;
    };
    /** List the plugins in the catalog. */
    get: operations['plugins-catalog-list-plugins-with-type'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/plugins/catalog/{type}/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin */
        name: string;
        /** @description The type of the plugin, may be auth, secret, or database */
        type: string;
      };
      cookie?: never;
    };
    /** Return the configuration data for the plugin with the given name. */
    get: operations['plugins-catalog-read-plugin-configuration-with-type'];
    put?: never;
    /** Register a new plugin, or updates an existing one with the supplied name. */
    post: operations['plugins-catalog-register-plugin-with-type'];
    /** Remove the plugin with the given name. */
    delete: operations['plugins-catalog-remove-plugin-with-type'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/plugins/pins': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['plugins-catalog-pins-list-pinned-versions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/plugins/pins/{type}/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin */
        name: string;
        /** @description The type of the plugin, may be auth, secret, or database */
        type: string;
      };
      cookie?: never;
    };
    /** Return the pinned version for the plugin with the given type and name. */
    get: operations['plugins-catalog-pins-read-pinned-version'];
    put?: never;
    /** Create or update the pinned version for a plugin with a given type and name. */
    post: operations['plugins-catalog-pins-create-pinned-version'];
    /** Remove any pinned version for the plugin with the given type and name. */
    delete: operations['plugins-catalog-pins-remove-pinned-version'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/plugins/reload/backend': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Reload mounted plugin backends.
     * @description Either the plugin name (`plugin`) or the desired plugin backend mounts (`mounts`) must be provided, but not both. In the case that the plugin name is provided, all mounted paths that use that plugin backend will be reloaded.  If (`scope`) is provided and is (`global`), the plugin(s) are reloaded globally.
     */
    post: operations['plugins-reload-backends'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/plugins/reload/backend/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get the status of a cluster-scoped reload.
     * @description The reload_id returned by a cluster scoped reload must be provided.
     */
    get: operations['system-read-plugins-reload-backend-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/plugins/reload/{type}/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin to reload, as registered in the plugin catalog. */
        name: string;
        /** @description The type of the plugin to reload, as registered in the plugin catalog. */
        type: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Reload all instances of a specific plugin.
     * @description Reload all plugins of a specific name and type across all namespaces. If "scope" is provided and is "global", the plugin is reloaded across all nodes and clusters. If a new plugin version has been pinned, this will ensure all instances start using the new version.
     */
    post: operations['reload-plugins'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/plugins/runtimes/catalog': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['plugins-runtimes-catalog-list-plugins-runtimes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/plugins/runtimes/catalog/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['plugins-runtimes-catalog-list-plugins-runtimes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/plugins/runtimes/catalog/{type}/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin runtime */
        name: string;
        /** @description The type of the plugin runtime */
        type: string;
      };
      cookie?: never;
    };
    /** Return the configuration data for the plugin runtime with the given name. */
    get: operations['plugins-runtimes-catalog-read-plugin-runtime-configuration'];
    put?: never;
    /** Register a new plugin runtime, or updates an existing one with the supplied name. */
    post: operations['plugins-runtimes-catalog-register-plugin-runtime'];
    /** Remove the plugin runtime with the given name. */
    delete: operations['plugins-runtimes-catalog-remove-plugin-runtime'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/policies/acl/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['policies-list-acl-policies'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/policies/acl/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    /** Retrieve information about the named ACL policy. */
    get: operations['policies-read-acl-policy'];
    put?: never;
    /** Add a new or update an existing ACL policy. */
    post: operations['policies-write-acl-policy'];
    /** Delete the ACL policy with the given name. */
    delete: operations['policies-delete-acl-policy'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/policies/egp/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List the configured access control policies. */
    get: operations['system-list-policies-egp'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/policies/egp/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    /** Read, Modify, or Delete an access control policy. */
    get: operations['system-read-policies-egp-name'];
    put?: never;
    /** Read, Modify, or Delete an access control policy. */
    post: operations['system-write-policies-egp-name'];
    /** Read, Modify, or Delete an access control policy. */
    delete: operations['system-delete-policies-egp-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/policies/password/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List the existing password policies. */
    get: operations['policies-list-password-policies'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/policies/password/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the password policy. */
        name: string;
      };
      cookie?: never;
    };
    /** Retrieve an existing password policy. */
    get: operations['policies-read-password-policy'];
    put?: never;
    /** Add a new or update an existing password policy. */
    post: operations['policies-write-password-policy'];
    /** Delete a password policy. */
    delete: operations['policies-delete-password-policy'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/policies/password/{name}/generate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the password policy. */
        name: string;
      };
      cookie?: never;
    };
    /** Generate a password from an existing password policy. */
    get: operations['policies-generate-password-from-password-policy'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/policies/rgp/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List the configured access control policies. */
    get: operations['system-list-policies-rgp'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/policies/rgp/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    /** Read, Modify, or Delete an access control policy. */
    get: operations['system-read-policies-rgp-name'];
    put?: never;
    /** Read, Modify, or Delete an access control policy. */
    post: operations['system-write-policies-rgp-name'];
    /** Read, Modify, or Delete an access control policy. */
    delete: operations['system-delete-policies-rgp-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/policy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['policies-list-acl-policies2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/policy/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['policies-list-acl-policies3'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/policy/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    /** Retrieve the policy body for the named policy. */
    get: operations['policies-read-acl-policy2'];
    put?: never;
    /** Add a new or update an existing policy. */
    post: operations['policies-write-acl-policy2'];
    /** Delete the policy with the given name. */
    delete: operations['policies-delete-acl-policy2'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/pprof': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns an HTML page listing the available profiles.
     * @description Returns an HTML page listing the available
     *     profiles. This should be mainly accessed via browsers or applications that can
     *     render pages.
     */
    get: operations['pprof-index'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/pprof/allocs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns a sampling of all past memory allocations.
     * @description Returns a sampling of all past memory allocations.
     */
    get: operations['pprof-memory-allocations'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/pprof/block': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns stack traces that led to blocking on synchronization primitives
     * @description Returns stack traces that led to blocking on synchronization primitives
     */
    get: operations['pprof-blocking'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/pprof/cmdline': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns the running program's command line.
     * @description Returns the running program's command line, with arguments separated by NUL bytes.
     */
    get: operations['pprof-command-line'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/pprof/goroutine': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns stack traces of all current goroutines.
     * @description Returns stack traces of all current goroutines.
     */
    get: operations['pprof-goroutines'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/pprof/heap': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns a sampling of memory allocations of live object.
     * @description Returns a sampling of memory allocations of live object.
     */
    get: operations['pprof-memory-allocations-live'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/pprof/mutex': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns stack traces of holders of contended mutexes
     * @description Returns stack traces of holders of contended mutexes
     */
    get: operations['pprof-mutexes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/pprof/profile': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns a pprof-formatted cpu profile payload.
     * @description Returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.
     */
    get: operations['pprof-cpu-profile'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/pprof/symbol': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns the program counters listed in the request.
     * @description Returns the program counters listed in the request.
     */
    get: operations['pprof-symbols'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/pprof/threadcreate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns stack traces that led to the creation of new OS threads
     * @description Returns stack traces that led to the creation of new OS threads
     */
    get: operations['pprof-thread-creations'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/pprof/trace': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns the execution trace in binary form.
     * @description Returns  the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.
     */
    get: operations['pprof-execution-trace'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/quotas/config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['rate-limit-quotas-read-configuration'];
    put?: never;
    post: operations['rate-limit-quotas-configure'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/quotas/lease-count/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['system-list-quotas-lease-count'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/quotas/lease-count/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the quota rule. */
        name: string;
      };
      cookie?: never;
    };
    get: operations['system-read-quotas-lease-count-name'];
    put?: never;
    post: operations['system-write-quotas-lease-count-name'];
    delete: operations['system-delete-quotas-lease-count-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/quotas/rate-limit/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['rate-limit-quotas-list'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/quotas/rate-limit/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the quota rule. */
        name: string;
      };
      cookie?: never;
    };
    get: operations['rate-limit-quotas-read'];
    put?: never;
    post: operations['rate-limit-quotas-write'];
    delete: operations['rate-limit-quotas-delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/raw/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        path: string;
      };
      cookie?: never;
    };
    /** Read the value of the key at the given path. */
    get: operations['raw-read'];
    put?: never;
    /** Update the value of the key at the given path. */
    post: operations['raw-write'];
    /** Delete the key with given path. */
    delete: operations['raw-delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/raw/{path}/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        path: string;
      };
      cookie?: never;
    };
    /** Return a list keys for a given path prefix. */
    get: operations['raw-list'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/rekey/backup': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Return the backup copy of PGP-encrypted unseal keys. */
    get: operations['rekey-read-backup-key'];
    put?: never;
    post?: never;
    /** Delete the backup copy of PGP-encrypted unseal keys. */
    delete: operations['rekey-delete-backup-key'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/rekey/init': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Reads the configuration and progress of the current rekey attempt. */
    get: operations['rekey-attempt-read-progress'];
    put?: never;
    /**
     * Initializes a new rekey attempt.
     * @description Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.
     */
    post: operations['rekey-attempt-initialize'];
    /**
     * Cancels any in-progress rekey.
     * @description This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.
     */
    delete: operations['rekey-attempt-cancel'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/rekey/recovery-key-backup': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['rekey-read-backup-recovery-key'];
    put?: never;
    post?: never;
    delete: operations['rekey-delete-backup-recovery-key'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/rekey/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Enter a single unseal key share to progress the rekey of the Vault. */
    post: operations['rekey-attempt-update'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/rekey/verify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Read the configuration and progress of the current rekey verification attempt. */
    get: operations['rekey-verification-read-progress'];
    put?: never;
    /** Enter a single new key share to progress the rekey verification operation. */
    post: operations['rekey-verification-update'];
    /**
     * Cancel any in-progress rekey verification operation.
     * @description This clears any progress made and resets the nonce. Unlike a `DELETE` against `sys/rekey/init`, this only resets the current verification operation, not the entire rekey atttempt.
     */
    delete: operations['rekey-verification-cancel'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/remount': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Initiate a mount migration */
    post: operations['remount'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/remount/status/{migration_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the migration operation */
        migration_id: string;
      };
      cookie?: never;
    };
    /** Check status of a mount migration */
    get: operations['remount-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/renew': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Renews a lease, requesting to extend the lease. */
    post: operations['leases-renew-lease2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/renew/{url_lease_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The lease identifier to renew. This is included with a lease. */
        url_lease_id: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Renews a lease, requesting to extend the lease. */
    post: operations['leases-renew-lease-with-id2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/primary/demote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-primary-demote'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/primary/disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-primary-disable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/primary/enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-primary-enable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/primary/revoke-secondary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-primary-revoke-secondary'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/primary/secondary-token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-primary-secondary-token'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/secondary/config/reload/{subsystem}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        subsystem: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Reload the given subsystem */
    post: operations['system-write-replication-dr-secondary-config-reload-subsystem'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/secondary/disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-secondary-disable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/secondary/enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-secondary-enable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/secondary/generate-public-key': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-secondary-generate-public-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/secondary/license/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['system-read-replication-dr-secondary-license-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/secondary/merkle-check': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-secondary-merkle-check'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/secondary/operation-token/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-secondary-operation-token-delete'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/secondary/promote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-secondary-promote'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/secondary/recover': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-secondary-recover'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/secondary/reindex': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-secondary-reindex'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/secondary/update-primary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-dr-secondary-update-primary'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/dr/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['system-read-replication-dr-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/force-corruption': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** force corrupting stuff */
    post: operations['system-write-replication-force-corruption'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/merkle-check': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-merkle-check'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/primary/demote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-performance-primary-demote'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/primary/disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-performance-primary-disable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/primary/dynamic-filter/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The opaque identifier used to identify the secondary. */
        id: string;
      };
      cookie?: never;
    };
    get: operations['system-read-replication-performance-primary-dynamic-filter-id'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/primary/enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-performance-primary-enable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/primary/paths-filter/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The opaque identifier used to identify the secondary. */
        id: string;
      };
      cookie?: never;
    };
    get: operations['system-read-replication-performance-primary-paths-filter-id'];
    put?: never;
    post: operations['system-write-replication-performance-primary-paths-filter-id'];
    delete: operations['system-delete-replication-performance-primary-paths-filter-id'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/primary/revoke-secondary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-performance-primary-revoke-secondary'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/primary/secondary-token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-performance-primary-secondary-token'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/secondary/disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-performance-secondary-disable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/secondary/dynamic-filter/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The opaque identifier used to identify the secondary. */
        id: string;
      };
      cookie?: never;
    };
    get: operations['system-read-replication-performance-secondary-dynamic-filter-id'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/secondary/enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-performance-secondary-enable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/secondary/generate-public-key': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-performance-secondary-generate-public-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/secondary/promote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-performance-secondary-promote'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/secondary/update-primary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-performance-secondary-update-primary'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/performance/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['system-read-replication-performance-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/primary/demote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-primary-demote'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/primary/disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-primary-disable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/primary/enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-primary-enable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/primary/revoke-secondary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-primary-revoke-secondary'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/primary/secondary-token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-primary-secondary-token'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/recover': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-recover'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/reindex': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-reindex'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/secondary/disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-secondary-disable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/secondary/enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-secondary-enable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/secondary/promote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-secondary-promote'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/secondary/update-primary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-replication-secondary-update-primary'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/replication/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['system-read-replication-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/revoke': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Revokes a lease immediately. */
    post: operations['leases-revoke-lease2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/revoke-force/{prefix}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to revoke keys under. Example: "prod/aws/ops" */
        prefix: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Revokes all secrets or tokens generated under a given prefix immediately
     * @description Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.
     *
     *     By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
     */
    post: operations['leases-force-revoke-lease-with-prefix2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/revoke-prefix/{prefix}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to revoke keys under. Example: "prod/aws/ops" */
        prefix: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Revokes all secrets (via a lease ID prefix) or tokens (via the tokens' path property) generated under a given prefix immediately. */
    post: operations['leases-revoke-lease-with-prefix2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/revoke/{url_lease_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The lease identifier to renew. This is included with a lease. */
        url_lease_id: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Revokes a lease immediately. */
    post: operations['leases-revoke-lease-with-id2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/rotate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['encryption-key-rotate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/rotate/config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['encryption-key-read-rotation-configuration'];
    put?: never;
    post: operations['encryption-key-configure-rotation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/seal': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Seal the Vault. */
    post: operations['seal'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/seal-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Check the seal status of a Vault. */
    get: operations['seal-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sealwrap/rewrap': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve the state of any ongoing seal rewrap process */
    get: operations['system-read-sealwrap-rewrap'];
    put?: never;
    /** Start a seal rewrap process */
    post: operations['system-write-sealwrap-rewrap'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/step-down': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cause the node to give up active status.
     * @description This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again.
     */
    post: operations['step-down-leader'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/storage/raft/snapshot-auto/config/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List automated raft snapshot configurations */
    get: operations['system-list-storage-raft-snapshot-auto-config'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/storage/raft/snapshot-auto/config/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description name of configuration to update */
        name: string;
      };
      cookie?: never;
    };
    /** Read automated raft snapshot configuration */
    get: operations['system-read-storage-raft-snapshot-auto-config-name'];
    put?: never;
    /** Update automated raft snapshot configuration */
    post: operations['system-write-storage-raft-snapshot-auto-config-name'];
    /** Delete automated raft snapshot configuration */
    delete: operations['system-delete-storage-raft-snapshot-auto-config-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/storage/raft/snapshot-auto/status/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description name of configuration to update */
        name: string;
      };
      cookie?: never;
    };
    /** Read status of automated raft snapshots */
    get: operations['system-read-storage-raft-snapshot-auto-status-name'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/associations/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['system-list-sync-associations'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/associations/destinations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['system-read-sync-associations-destinations'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/associations/{mount}/{secret_name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Mount of the secret to configure or read. */
        mount: string;
        /** @description Name of the secret to configure or read. */
        secret_name: string;
      };
      cookie?: never;
    };
    get: operations['system-read-sync-associations-mount-secret_name'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['system-read-sync-config'];
    put?: never;
    post?: never;
    delete: operations['system-delete-sync-config'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/destinations/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['system-list-sync-destinations'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/destinations/aws-sm/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    get: operations['system-read-sync-destinations-aws-sm-name'];
    put?: never;
    post: operations['system-write-sync-destinations-aws-sm-name'];
    delete: operations['system-delete-sync-destinations-aws-sm-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/destinations/azure-kv/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    get: operations['system-read-sync-destinations-azure-kv-name'];
    put?: never;
    post: operations['system-write-sync-destinations-azure-kv-name'];
    delete: operations['system-delete-sync-destinations-azure-kv-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/destinations/gcp-sm/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    get: operations['system-read-sync-destinations-gcp-sm-name'];
    put?: never;
    post: operations['system-write-sync-destinations-gcp-sm-name'];
    delete: operations['system-delete-sync-destinations-gcp-sm-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/destinations/gh/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    get: operations['system-read-sync-destinations-gh-name'];
    put?: never;
    post: operations['system-write-sync-destinations-gh-name'];
    delete: operations['system-delete-sync-destinations-gh-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/destinations/in-mem/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    get: operations['system-read-sync-destinations-in-mem-name'];
    put?: never;
    post: operations['system-write-sync-destinations-in-mem-name'];
    delete: operations['system-delete-sync-destinations-in-mem-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/destinations/vercel-project/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    get: operations['system-read-sync-destinations-vercel-project-name'];
    put?: never;
    post: operations['system-write-sync-destinations-vercel-project-name'];
    delete: operations['system-delete-sync-destinations-vercel-project-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/destinations/{type}/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Type of this secrets store. */
        type: string;
      };
      cookie?: never;
    };
    get: operations['system-list-sync-destinations-type'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/destinations/{type}/{name}/associations': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
        /** @description Type of this secrets store. */
        type: string;
      };
      cookie?: never;
    };
    get: operations['system-read-sync-destinations-type-name-associations'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/destinations/{type}/{name}/associations/remove': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
        /** @description Type of this secrets store. */
        type: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-sync-destinations-type-name-associations-remove'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/destinations/{type}/{name}/associations/set': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
        /** @description Type of this secrets store. */
        type: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['system-write-sync-destinations-type-name-associations-set'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/github-apps/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['system-list-sync-github-apps'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/sync/github-apps/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The user defined name of the GitHub App configuration. */
        name: string;
      };
      cookie?: never;
    };
    get: operations['system-read-sync-github-apps-name'];
    put?: never;
    post: operations['system-write-sync-github-apps-name'];
    delete: operations['system-delete-sync-github-apps-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/tools/hash': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['generate-hash'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/tools/hash/{urlalgorithm}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Algorithm to use (POST URL parameter) */
        urlalgorithm: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['generate-hash-with-algorithm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/tools/random': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['generate-random'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/tools/random/{source}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Which system to source random data from, ether "platform", "seal", or "all". */
        source: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['generate-random-with-source'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/tools/random/{source}/{urlbytes}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Which system to source random data from, ether "platform", "seal", or "all". */
        source: string;
        /** @description The number of bytes to generate (POST URL parameter) */
        urlbytes: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['generate-random-with-source-and-bytes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/tools/random/{urlbytes}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The number of bytes to generate (POST URL parameter) */
        urlbytes: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['generate-random-with-bytes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/unseal': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Unseal the Vault. */
    post: operations['unseal'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/utilization': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * returns manual license reporting report data
     * @description Gets manual license reporting data
     */
    post: operations['system-write-utilization'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/version-history/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns map of historical version change entries */
    get: operations['version-history'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/wrapping/lookup': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Look up wrapping properties for the requester's token. */
    get: operations['read-wrapping-properties2'];
    put?: never;
    /** Look up wrapping properties for the given token. */
    post: operations['read-wrapping-properties'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/wrapping/rewrap': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['rewrap'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/wrapping/unwrap': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['unwrap'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sys/wrapping/wrap': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['wrap'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{alicloud_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['ali-cloud-read-configuration'];
    put?: never;
    post: operations['ali-cloud-configure'];
    delete: operations['ali-cloud-delete-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{alicloud_mount_path}/creds/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    /** Generate an API key or STS credential using the given role's configuration.' */
    get: operations['ali-cloud-generate-credentials'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{alicloud_mount_path}/role/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    /** List the existing roles in this backend. */
    get: operations['ali-cloud-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{alicloud_mount_path}/role/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    /** Read, write and reference policies and roles that API keys or STS credentials can be made for. */
    get: operations['ali-cloud-read-role'];
    put?: never;
    /** Read, write and reference policies and roles that API keys or STS credentials can be made for. */
    post: operations['ali-cloud-write-role'];
    /** Read, write and reference policies and roles that API keys or STS credentials can be made for. */
    delete: operations['ali-cloud-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{aws_mount_path}/config/lease': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-lease-configuration'];
    put?: never;
    post: operations['aws-configure-lease'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{aws_mount_path}/config/root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-root-iam-credentials-configuration'];
    put?: never;
    post: operations['aws-configure-root-iam-credentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{aws_mount_path}/config/rotate-root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['aws-rotate-root-iam-credentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{aws_mount_path}/creds/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-generate-credentials'];
    put?: never;
    post: operations['aws-generate-credentials-with-parameters'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{aws_mount_path}/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    /** List the existing roles in this backend */
    get: operations['aws-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{aws_mount_path}/roles/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    /** Read, write and reference IAM policies that access keys can be made for. */
    get: operations['aws-read-role'];
    put?: never;
    /** Read, write and reference IAM policies that access keys can be made for. */
    post: operations['aws-write-role'];
    /** Read, write and reference IAM policies that access keys can be made for. */
    delete: operations['aws-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{aws_mount_path}/static-creds/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of this role. */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-static-creds-name'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{aws_mount_path}/static-roles/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of this role. */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-read-static-roles-name'];
    put?: never;
    post: operations['aws-write-static-roles-name'];
    delete: operations['aws-delete-static-roles-name'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{aws_mount_path}/sts/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['aws-generate-sts-credentials'];
    put?: never;
    post: operations['aws-generate-sts-credentials-with-parameters'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{azure_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['azure-read-configuration'];
    put?: never;
    post: operations['azure-configure'];
    delete: operations['azure-delete-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{azure_mount_path}/creds/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the Vault role */
        role: string;
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['azure-request-service-principal-credentials'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{azure_mount_path}/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    /** List existing roles. */
    get: operations['azure-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{azure_mount_path}/roles/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage the Vault roles used to generate Azure credentials. */
    get: operations['azure-read-role'];
    put?: never;
    /** Manage the Vault roles used to generate Azure credentials. */
    post: operations['azure-write-role'];
    /** Manage the Vault roles used to generate Azure credentials. */
    delete: operations['azure-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{azure_mount_path}/rotate-root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['azure-rotate-root'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{consul_mount_path}/config/access': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        consul_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['consul-read-access-configuration'];
    put?: never;
    post: operations['consul-configure-access'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{consul_mount_path}/creds/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        consul_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['consul-generate-credentials'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{consul_mount_path}/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        consul_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['consul-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{consul_mount_path}/roles/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        consul_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['consul-read-role'];
    put?: never;
    post: operations['consul-write-role'];
    delete: operations['consul-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{database_mount_path}/config/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    /** Configure connection details to a database plugin. */
    get: operations['database-list-connections'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{database_mount_path}/config/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this database connection */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['database-read-connection-configuration'];
    put?: never;
    post: operations['database-configure-connection'];
    delete: operations['database-delete-connection-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{database_mount_path}/creds/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    /** Request database credentials for a certain role. */
    get: operations['database-generate-credentials'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{database_mount_path}/reload/{plugin_name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the database plugin */
        plugin_name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Reloads all connections using a named database plugin. */
    post: operations['database-reload-plugin'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{database_mount_path}/reset/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this database connection */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Resets a database plugin. */
    post: operations['database-reset-connection'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{database_mount_path}/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage the roles that can be created with this backend. */
    get: operations['database-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{database_mount_path}/roles/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage the roles that can be created with this backend. */
    get: operations['database-read-role'];
    put?: never;
    /** Manage the roles that can be created with this backend. */
    post: operations['database-write-role'];
    /** Manage the roles that can be created with this backend. */
    delete: operations['database-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{database_mount_path}/rotate-role/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the static role */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['database-rotate-static-role-credentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{database_mount_path}/rotate-root/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this database connection */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['database-rotate-root-credentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{database_mount_path}/static-creds/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the static role. */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    /** Request database credentials for a certain static role. These credentials are
     *     rotated periodically. */
    get: operations['database-read-static-role-credentials'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{database_mount_path}/static-roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage the static roles that can be created with this backend. */
    get: operations['database-list-static-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{database_mount_path}/static-roles/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage the static roles that can be created with this backend. */
    get: operations['database-read-static-role'];
    put?: never;
    /** Manage the static roles that can be created with this backend. */
    post: operations['database-write-static-role'];
    /** Manage the static roles that can be created with this backend. */
    delete: operations['database-delete-static-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-read-configuration'];
    put?: never;
    post: operations['google-cloud-configure'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/config/rotate-root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['google-cloud-rotate-root-credentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/impersonated-account/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-list-impersonated-accounts'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/impersonated-account/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name to refer to this impersonated account in Vault. Cannot be updated. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-read-impersonated-account'];
    put?: never;
    post: operations['google-cloud-write-impersonated-account'];
    delete: operations['google-cloud-delete-impersonated-account'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/impersonated-account/{name}/token': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the impersonated account. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-generate-impersonated-account-access-token'];
    put?: never;
    post: operations['google-cloud-generate-impersonated-account-access-token2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/impersonated-accounts/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-list-impersonated-accounts2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/key/{roleset}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role set. */
        roleset: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-generate-roleset-key4'];
    put?: never;
    post: operations['google-cloud-generate-roleset-key3'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/roleset/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-list-rolesets'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/roleset/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-read-roleset'];
    put?: never;
    post: operations['google-cloud-write-roleset'];
    delete: operations['google-cloud-delete-roleset'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/roleset/{name}/rotate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['google-cloud-rotate-roleset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/roleset/{name}/rotate-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['google-cloud-rotate-roleset-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/roleset/{roleset}/key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role set. */
        roleset: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-generate-roleset-key2'];
    put?: never;
    post: operations['google-cloud-generate-roleset-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/roleset/{roleset}/token': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role set. */
        roleset: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-generate-roleset-access-token2'];
    put?: never;
    post: operations['google-cloud-generate-roleset-access-token'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/rolesets/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-list-rolesets2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/static-account/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-list-static-accounts'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/static-account/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name to refer to this static account in Vault. Cannot be updated. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-read-static-account'];
    put?: never;
    post: operations['google-cloud-write-static-account'];
    delete: operations['google-cloud-delete-static-account'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/static-account/{name}/key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the static account. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-generate-static-account-key2'];
    put?: never;
    post: operations['google-cloud-generate-static-account-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/static-account/{name}/rotate-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the account. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['google-cloud-rotate-static-account-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/static-account/{name}/token': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the static account. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-generate-static-account-access-token2'];
    put?: never;
    post: operations['google-cloud-generate-static-account-access-token'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/static-accounts/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-list-static-accounts2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcp_mount_path}/token/{roleset}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role set. */
        roleset: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-generate-roleset-access-token4'];
    put?: never;
    post: operations['google-cloud-generate-roleset-access-token3'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-kms-read-configuration'];
    put?: never;
    post: operations['google-cloud-kms-configure'];
    delete: operations['google-cloud-kms-delete-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/decrypt/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Decrypt a ciphertext value using a named key */
    post: operations['google-cloud-kms-decrypt'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/encrypt/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Encrypt a plaintext value using a named key */
    post: operations['google-cloud-kms-encrypt'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/keys/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    /** List named keys */
    get: operations['google-cloud-kms-list-keys'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/keys/config/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['google-cloud-kms-read-key-configuration'];
    put?: never;
    post: operations['google-cloud-kms-configure-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/keys/deregister/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['google-cloud-kms-deregister-key'];
    delete: operations['google-cloud-kms-deregister-key2'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/keys/register/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Register an existing crypto key in Google Cloud KMS */
    post: operations['google-cloud-kms-register-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/keys/rotate/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Rotate a crypto key to a new primary version */
    post: operations['google-cloud-kms-rotate-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/keys/trim/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['google-cloud-kms-trim-key-versions'];
    delete: operations['google-cloud-kms-trim-key-versions2'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/keys/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    /** Interact with crypto keys in Vault and Google Cloud KMS */
    get: operations['google-cloud-kms-read-key'];
    put?: never;
    /** Interact with crypto keys in Vault and Google Cloud KMS */
    post: operations['google-cloud-kms-write-key'];
    /** Interact with crypto keys in Vault and Google Cloud KMS */
    delete: operations['google-cloud-kms-delete-key'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/pubkey/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    /** Retrieve the public key associated with the named key */
    get: operations['google-cloud-kms-retrieve-public-key'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/reencrypt/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Re-encrypt existing ciphertext data to a new version */
    post: operations['google-cloud-kms-reencrypt'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/sign/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Signs a message or digest using a named key */
    post: operations['google-cloud-kms-sign'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{gcpkms_mount_path}/verify/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Verify a signature using a named key */
    post: operations['google-cloud-kms-verify'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kubernetes_mount_path}/check': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kubernetes-check-configuration'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kubernetes_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kubernetes-read-configuration'];
    put?: never;
    post: operations['kubernetes-configure'];
    delete: operations['kubernetes-delete-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kubernetes_mount_path}/creds/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the Vault role */
        name: string;
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['kubernetes-generate-credentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kubernetes_mount_path}/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kubernetes-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kubernetes_mount_path}/roles/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kubernetes-read-role'];
    put?: never;
    post: operations['kubernetes-write-role'];
    delete: operations['kubernetes-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kv_v1_mount_path}/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v1_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kv-v1-read'];
    put?: never;
    post: operations['kv-v1-write'];
    delete: operations['kv-v1-delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kv_v1_mount_path}/{path}/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v1_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kv-v1-list'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kv_v2_mount_path}/^.*$': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kv_v2_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    /** Read the backend level settings. */
    get: operations['kv-v2-read-configuration'];
    put?: never;
    /** Configure backend level settings that are applied to every key in the key-value store. */
    post: operations['kv-v2-configure'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kv_v2_mount_path}/data/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kv-v2-read'];
    put?: never;
    post: operations['kv-v2-write'];
    delete: operations['kv-v2-delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kv_v2_mount_path}/delete/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['kv-v2-delete-versions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kv_v2_mount_path}/destroy/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['kv-v2-destroy-versions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kv_v2_mount_path}/metadata/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kv-v2-read-metadata'];
    put?: never;
    post: operations['kv-v2-write-metadata'];
    delete: operations['kv-v2-delete-metadata-and-all-versions'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kv_v2_mount_path}/metadata/{path}/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kv-v2-list'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kv_v2_mount_path}/subkeys/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['kv-v2-read-subkeys'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{kv_v2_mount_path}/undelete/{path}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['kv-v2-undelete-versions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['ldap-read-configuration'];
    put?: never;
    post: operations['ldap-configure'];
    delete: operations['ldap-delete-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/creds/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the dynamic role. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['ldap-request-dynamic-role-credentials'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/library/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['ldap-library-list'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/library/manage/{name}/check-in': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the set. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Check service accounts in to the library. */
    post: operations['ldap-library-force-check-in'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/library/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the set. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    /** Read a library set. */
    get: operations['ldap-library-read'];
    put?: never;
    /** Update a library set. */
    post: operations['ldap-library-configure'];
    /** Delete a library set. */
    delete: operations['ldap-library-delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/library/{name}/check-in': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the set. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Check service accounts in to the library. */
    post: operations['ldap-library-check-in'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/library/{name}/check-out': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the set */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Check a service account out from the library. */
    post: operations['ldap-library-check-out'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/library/{name}/status': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the set. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    /** Check the status of the service accounts in a library set. */
    get: operations['ldap-library-check-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/role/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['ldap-list-dynamic-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/role/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role (lowercase) */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['ldap-read-dynamic-role'];
    put?: never;
    post: operations['ldap-write-dynamic-role'];
    delete: operations['ldap-delete-dynamic-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/rotate-role/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the static role */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['ldap-rotate-static-role'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/rotate-root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['ldap-rotate-root-credentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/static-cred/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the static role. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['ldap-request-static-role-credentials'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/static-role/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['ldap-list-static-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ldap_mount_path}/static-role/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['ldap-read-static-role'];
    put?: never;
    post: operations['ldap-write-static-role'];
    delete: operations['ldap-delete-static-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{mongodbatlas_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        mongodbatlas_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['mongo-db-atlas-read-configuration'];
    put?: never;
    post: operations['mongo-db-atlas-configure'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{mongodbatlas_mount_path}/creds/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        mongodbatlas_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['mongo-db-atlas-generate-credentials'];
    put?: never;
    post: operations['mongo-db-atlas-generate-credentials2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{mongodbatlas_mount_path}/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        mongodbatlas_mount_path: string;
      };
      cookie?: never;
    };
    /** List the existing roles in this backend */
    get: operations['mongo-db-atlas-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{mongodbatlas_mount_path}/roles/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the Roles */
        name: string;
        /** @description Path that the backend was mounted at */
        mongodbatlas_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage the roles used to generate MongoDB Atlas Programmatic API Keys. */
    get: operations['mongo-db-atlas-read-role'];
    put?: never;
    /** Manage the roles used to generate MongoDB Atlas Programmatic API Keys. */
    post: operations['mongo-db-atlas-write-role'];
    /** Manage the roles used to generate MongoDB Atlas Programmatic API Keys. */
    delete: operations['mongo-db-atlas-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{nomad_mount_path}/config/access': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['nomad-read-access-configuration'];
    put?: never;
    post: operations['nomad-configure-access'];
    delete: operations['nomad-delete-access-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{nomad_mount_path}/config/lease': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['nomad-read-lease-configuration'];
    put?: never;
    post: operations['nomad-configure-lease'];
    delete: operations['nomad-delete-lease-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{nomad_mount_path}/creds/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['nomad-generate-credentials'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{nomad_mount_path}/role/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['nomad-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{nomad_mount_path}/role/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['nomad-read-role'];
    put?: never;
    post: operations['nomad-write-role'];
    delete: operations['nomad-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/acme/account/{kid}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-acme-account-kid'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/acme/authorization/{auth_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-acme-authorization-auth_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/acme/challenge/{auth_id}/{challenge_type}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-acme-challenge-auth_id-challenge_type'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/acme/directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-acme-directory'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/acme/new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-acme-new-account'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/acme/new-eab': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-generate-eab-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/acme/new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-acme-new-nonce'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/acme/new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-acme-new-order'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/acme/order/{order_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-acme-order-order_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/acme/order/{order_id}/cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-acme-order-order_id-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/acme/order/{order_id}/finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-acme-order-order_id-finalize'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/acme/orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-acme-orders'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/acme/revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-acme-revoke-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/ca': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-ca-der'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/ca/pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-ca-pem'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/ca_chain': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-ca-chain-pem'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/cert/ca_chain': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-cert-ca-chain'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/cert/crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-cert-crl'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/cert/delta-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-cert-delta-crl'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/cert/unified-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-cert-unified-crl'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/cert/unified-delta-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-cert-unified-delta-crl'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/cert/{serial}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Certificate serial number, in colon- or hyphen-separated octal */
        serial: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-cert'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/cert/{serial}/raw': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Certificate serial number, in colon- or hyphen-separated octal */
        serial: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-cert-raw-der'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/cert/{serial}/raw/pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Certificate serial number, in colon- or hyphen-separated octal */
        serial: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-cert-raw-pem'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/certs/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-list-certs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/certs/revocation-queue/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-list-certs-revocation-queue'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/certs/revoked/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-list-revoked-certs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/certs/unified-revoked/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-list-unified-revoked-certs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/config/acme': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-acme-configuration'];
    put?: never;
    post: operations['pki-configure-acme'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/config/auto-tidy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-auto-tidy-configuration'];
    put?: never;
    post: operations['pki-configure-auto-tidy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/config/ca': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-configure-ca'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/config/cluster': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-cluster-configuration'];
    put?: never;
    post: operations['pki-configure-cluster'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/config/crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-crl-configuration'];
    put?: never;
    post: operations['pki-configure-crl'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/config/est': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-est-configuration'];
    put?: never;
    post: operations['pki-configure-est'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/config/external-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-configure-external-policy'];
    put?: never;
    post: operations['pki-configure-external-policy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/config/issuers': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-issuers-configuration'];
    put?: never;
    post: operations['pki-configure-issuers'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/config/keys': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-keys-configuration'];
    put?: never;
    post: operations['pki-configure-keys'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/config/urls': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-urls-configuration'];
    put?: never;
    post: operations['pki-configure-urls'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-crl-der'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/crl/delta': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-crl-delta'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/crl/delta/pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-crl-delta-pem'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/crl/pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-crl-pem'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/crl/rotate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-rotate-crl'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/crl/rotate-delta': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-rotate-delta-crl'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/eab/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-list-eab-keys'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/eab/{key_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description EAB key identifier */
        key_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete: operations['pki-delete-eab-key'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/est/cacerts': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-est-cacerts'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/est/simpleenroll': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-est-simpleenroll'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/est/simplereenroll': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-est-simplereenroll'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/acme/account/{kid}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-acme-account-kid'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/acme/authorization/{auth_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-acme-authorization-auth_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/acme/challenge/{auth_id}/{challenge_type}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-acme-challenge-auth_id-challenge_type'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/acme/directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-external-policy-acme-directory'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/acme/new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-acme-new-account'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/acme/new-eab': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-generate-eab-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/acme/new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-external-policy-acme-new-nonce'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/acme/new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-acme-new-order'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/acme/order/{order_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-acme-order-order_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/acme/order/{order_id}/cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-acme-order-order_id-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/acme/order/{order_id}/finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-acme-order-order_id-finalize'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/acme/orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-acme-orders'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/acme/revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-acme-revoke-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/issue': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-issue'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/issue/{policy}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the external service. */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-issue-policy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/sign': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-sign'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/sign-intermediate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-sign-intermediate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/sign-intermediate/{policy}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the external service. */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-sign-intermediate-policy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/sign/{policy}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the external service. */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-sign-policy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/{policy}/acme/account/{kid}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-policy-acme-account-kid'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/{policy}/acme/authorization/{auth_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-policy-acme-authorization-auth_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/{policy}/acme/challenge/{auth_id}/{challenge_type}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-policy-acme-challenge-auth_id-challenge_type'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/{policy}/acme/directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-external-policy-policy-acme-directory'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/{policy}/acme/new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-policy-acme-new-account'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/{policy}/acme/new-eab': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-generate-eab-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/{policy}/acme/new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-external-policy-policy-acme-new-nonce'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/{policy}/acme/new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-policy-acme-new-order'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/{policy}/acme/order/{order_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-policy-acme-order-order_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/{policy}/acme/order/{order_id}/cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-policy-acme-order-order_id-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/{policy}/acme/order/{order_id}/finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-policy-acme-order-order_id-finalize'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/{policy}/acme/orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-policy-acme-orders'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/external-policy/{policy}/acme/revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-external-policy-policy-acme-revoke-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/intermediate/cross-sign': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-cross-sign-intermediate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/intermediate/generate/{exported}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Must be "internal", "exported" or "kms". If set to "exported", the generated private key will be returned. This is your *only* chance to retrieve the private key! */
        exported: 'internal' | 'external' | 'kms';
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-generate-intermediate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/intermediate/set-signed': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-set-signed-intermediate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issue/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role with configuration for this request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-issue-with-role'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-issuer'];
    put?: never;
    post: operations['pki-write-issuer'];
    delete: operations['pki-delete-issuer'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/acme/account/{kid}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-acme-account-kid'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/acme/authorization/{auth_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-acme-authorization-auth_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/acme/challenge/{auth_id}/{challenge_type}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-acme-challenge-auth_id-challenge_type'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/acme/directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-issuer-issuer_ref-acme-directory'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/acme/new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-acme-new-account'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/acme/new-eab': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-generate-eab-key-for-issuer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/acme/new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-issuer-issuer_ref-acme-new-nonce'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/acme/new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-acme-new-order'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/acme/order/{order_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-acme-order-order_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/acme/order/{order_id}/cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-acme-order-order_id-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/acme/order/{order_id}/finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-acme-order-order_id-finalize'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/acme/orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-acme-orders'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/acme/revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-acme-revoke-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-issuer-read-crl'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/crl/delta': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-issuer-read-crl-delta'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/crl/delta/der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-issuer-read-crl-delta-der'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/crl/delta/pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-issuer-read-crl-delta-pem'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/crl/der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-issuer-read-crl-der'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/crl/pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-issuer-read-crl-pem'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-issuer-der'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/acme/account/{kid}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-acme-account-kid'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/acme/authorization/{auth_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-acme-authorization-auth_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/acme/challenge/{auth_id}/{challenge_type}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-acme-challenge-auth_id-challenge_type'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/acme/directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-issuer-issuer_ref-external-policy-acme-directory'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/acme/new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-acme-new-account'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/acme/new-eab': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-generate-eab-key-for-issuer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/acme/new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-issuer-issuer_ref-external-policy-acme-new-nonce'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/acme/new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-acme-new-order'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/acme/order/{order_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-acme-order-order_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/acme/order/{order_id}/cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-acme-order-order_id-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/acme/order/{order_id}/finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-acme-order-order_id-finalize'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/acme/orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-acme-orders'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/acme/revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-acme-revoke-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/issue': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-issue'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/issue/{policy}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the external service. */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-issue-policy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/sign': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-sign'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/sign-intermediate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-sign-intermediate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/sign-intermediate/{policy}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the external service. */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-sign-intermediate-policy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/sign/{policy}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the external service. */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-sign-policy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/{policy}/acme/account/{kid}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-policy-acme-account-kid'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/{policy}/acme/authorization/{auth_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-policy-acme-authorization-auth_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/{policy}/acme/challenge/{auth_id}/{challenge_type}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-policy-acme-challenge-auth_id-challenge_type'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/{policy}/acme/directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-issuer-issuer_ref-external-policy-policy-acme-directory'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/{policy}/acme/new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-policy-acme-new-account'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/{policy}/acme/new-eab': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-generate-eab-key-for-issuer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/{policy}/acme/new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-issuer-issuer_ref-external-policy-policy-acme-new-nonce'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/{policy}/acme/new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-policy-acme-new-order'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/{policy}/acme/order/{order_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-policy-acme-order-order_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/{policy}/acme/order/{order_id}/cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-policy-acme-order-order_id-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/{policy}/acme/order/{order_id}/finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-policy-acme-order-order_id-finalize'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/{policy}/acme/orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-policy-acme-orders'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/external-policy/{policy}/acme/revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-external-policy-policy-acme-revoke-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/issue/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description The desired role with configuration for this request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-issuer-issue-with-role'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/json': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-issuer-json'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-issuer-pem'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/resign-crls': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-issuer-resign-crls'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/revoke': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-revoke-issuer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/account/{kid}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-roles-role-acme-account-kid'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/authorization/{auth_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-roles-role-acme-authorization-auth_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/challenge/{auth_id}/{challenge_type}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-roles-role-acme-challenge-auth_id-challenge_type'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-issuer-issuer_ref-roles-role-acme-directory'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-roles-role-acme-new-account'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/new-eab': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-generate-eab-key-for-issuer-and-role'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-issuer-issuer_ref-roles-role-acme-new-nonce'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-roles-role-acme-new-order'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/order/{order_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-roles-role-acme-order-order_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/order/{order_id}/cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-roles-role-acme-order-order_id-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/order/{order_id}/finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-roles-role-acme-order-order_id-finalize'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-roles-role-acme-orders'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-issuer-issuer_ref-roles-role-acme-revoke-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/sign-intermediate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-issuer-sign-intermediate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/sign-revocation-list': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-issuer-sign-revocation-list'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/sign-self-issued': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-issuer-sign-self-issued'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/sign-verbatim': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-issuer-sign-verbatim'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/sign-verbatim/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description The desired role with configuration for this request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-issuer-sign-verbatim-with-role'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/sign/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description The desired role with configuration for this request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-issuer-sign-with-role'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/unified-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-issuer-read-unified-crl'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/unified-crl/delta': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-issuer-read-unified-crl-delta'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/unified-crl/delta/der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-issuer-read-unified-crl-delta-der'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/unified-crl/delta/pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-issuer-read-unified-crl-delta-pem'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/unified-crl/der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-issuer-read-unified-crl-der'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuer/{issuer_ref}/unified-crl/pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-issuer-read-unified-crl-pem'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuers/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-list-issuers'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuers/generate/intermediate/{exported}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Must be "internal", "exported" or "kms". If set to "exported", the generated private key will be returned. This is your *only* chance to retrieve the private key! */
        exported: 'internal' | 'external' | 'kms';
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-issuers-generate-intermediate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuers/generate/root/{exported}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Must be "internal", "exported" or "kms". If set to "exported", the generated private key will be returned. This is your *only* chance to retrieve the private key! */
        exported: 'internal' | 'external' | 'kms';
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-issuers-generate-root'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuers/import/bundle': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-issuers-import-bundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/issuers/import/cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-issuers-import-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/key/{key_ref}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to key; either "default" for the configured default key, an identifier of a key, or the name assigned to the key. */
        key_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-key'];
    put?: never;
    post: operations['pki-write-key'];
    delete: operations['pki-delete-key'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/keys/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-list-keys'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/keys/generate/exported': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-generate-exported-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/keys/generate/internal': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-generate-internal-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/keys/generate/kms': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-generate-kms-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/keys/import': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-import-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/ocsp': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-query-ocsp'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/ocsp/{req}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description base-64 encoded ocsp request */
        req: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-query-ocsp-with-get-req'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/revoke': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-revoke'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/revoke-with-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-revoke-with-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-role'];
    put?: never;
    post: operations['pki-write-role'];
    delete: operations['pki-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/acme/account/{kid}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-roles-role-acme-account-kid'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/acme/authorization/{auth_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-roles-role-acme-authorization-auth_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/acme/challenge/{auth_id}/{challenge_type}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-roles-role-acme-challenge-auth_id-challenge_type'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/acme/directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-roles-role-acme-directory'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/acme/new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-roles-role-acme-new-account'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/acme/new-eab': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-generate-eab-key-for-role'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/acme/new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-roles-role-acme-new-nonce'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/acme/new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-roles-role-acme-new-order'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/acme/order/{order_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-roles-role-acme-order-order_id'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/acme/order/{order_id}/cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-roles-role-acme-order-order_id-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/acme/order/{order_id}/finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-roles-role-acme-order-order_id-finalize'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/acme/orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-roles-role-acme-orders'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/acme/revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-roles-role-acme-revoke-cert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/est/cacerts': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the EST request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-roles-role-est-cacerts'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/est/simpleenroll': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the EST request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-roles-role-est-simpleenroll'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/roles/{role}/est/simplereenroll': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the EST request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-write-roles-role-est-simplereenroll'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete: operations['pki-delete-root'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/root/generate/{exported}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Must be "internal", "exported" or "kms". If set to "exported", the generated private key will be returned. This is your *only* chance to retrieve the private key! */
        exported: 'internal' | 'external' | 'kms';
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-generate-root'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/root/replace': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-replace-root'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/root/rotate/{exported}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Must be "internal", "exported" or "kms". If set to "exported", the generated private key will be returned. This is your *only* chance to retrieve the private key! */
        exported: 'internal' | 'external' | 'kms';
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-rotate-root'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/root/sign-intermediate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-root-sign-intermediate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/root/sign-self-issued': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-root-sign-self-issued'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/sign-verbatim': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-sign-verbatim'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/sign-verbatim/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role with configuration for this request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-sign-verbatim-with-role'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/sign/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role with configuration for this request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-sign-with-role'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/tidy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-tidy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/tidy-cancel': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-tidy-cancel'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/tidy-status': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-tidy-status'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/unified-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-unified-crl-der'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/unified-crl/delta': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-unified-crl-delta'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/unified-crl/delta/pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-unified-crl-delta-pem'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/unified-crl/pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-read-unified-crl-pem'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/unified-ocsp': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['pki-query-unified-ocsp'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{pki_mount_path}/unified-ocsp/{req}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description base-64 encoded ocsp request */
        req: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['pki-query-unified-ocsp-with-get-req'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{rabbitmq_mount_path}/config/connection': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        rabbitmq_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API. */
    post: operations['rabbit-mq-configure-connection'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{rabbitmq_mount_path}/config/lease': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        rabbitmq_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['rabbit-mq-read-lease-configuration'];
    put?: never;
    post: operations['rabbit-mq-configure-lease'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{rabbitmq_mount_path}/creds/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        rabbitmq_mount_path: string;
      };
      cookie?: never;
    };
    /** Request RabbitMQ credentials for a certain role. */
    get: operations['rabbit-mq-request-credentials'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{rabbitmq_mount_path}/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        rabbitmq_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage the roles that can be created with this backend. */
    get: operations['rabbit-mq-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{rabbitmq_mount_path}/roles/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        rabbitmq_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage the roles that can be created with this backend. */
    get: operations['rabbit-mq-read-role'];
    put?: never;
    /** Manage the roles that can be created with this backend. */
    post: operations['rabbit-mq-write-role'];
    /** Manage the roles that can be created with this backend. */
    delete: operations['rabbit-mq-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ssh_mount_path}/config/ca': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['ssh-read-ca-configuration'];
    put?: never;
    post: operations['ssh-configure-ca'];
    delete: operations['ssh-delete-ca-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ssh_mount_path}/config/zeroaddress': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['ssh-read-zero-address-configuration'];
    put?: never;
    post: operations['ssh-configure-zero-address'];
    delete: operations['ssh-delete-zero-address-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ssh_mount_path}/creds/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description [Required] Name of the role */
        role: string;
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Creates a credential for establishing SSH connection with the remote host. */
    post: operations['ssh-generate-credentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ssh_mount_path}/issue/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role with configuration for this request. */
        role: string;
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['ssh-issue-certificate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ssh_mount_path}/lookup': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** List all the roles associated with the given IP address. */
    post: operations['ssh-list-roles-by-ip'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ssh_mount_path}/public_key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    /** Retrieve the public key. */
    get: operations['ssh-read-public-key'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ssh_mount_path}/roles/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage the 'roles' that can be created with this backend. */
    get: operations['ssh-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ssh_mount_path}/roles/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description [Required for all types] Name of the role being created. */
        role: string;
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage the 'roles' that can be created with this backend. */
    get: operations['ssh-read-role'];
    put?: never;
    /** Manage the 'roles' that can be created with this backend. */
    post: operations['ssh-write-role'];
    /** Manage the 'roles' that can be created with this backend. */
    delete: operations['ssh-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ssh_mount_path}/sign/{role}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role with configuration for this request. */
        role: string;
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Request signing an SSH key using a certain role with the provided details. */
    post: operations['ssh-sign-certificate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ssh_mount_path}/tidy/dynamic-keys': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /** This endpoint removes the stored host keys used for the removed Dynamic Key feature, if present. */
    delete: operations['ssh-tidy-dynamic-host-keys'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{ssh_mount_path}/verify': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Validate the OTP provided by Vault SSH Agent. */
    post: operations['ssh-verify-otp'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{terraform_mount_path}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['terraform-cloud-read-configuration'];
    put?: never;
    post: operations['terraform-cloud-configure'];
    delete: operations['terraform-cloud-delete-configuration'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{terraform_mount_path}/creds/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['terraform-cloud-generate-credentials'];
    put?: never;
    post: operations['terraform-cloud-generate-credentials2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{terraform_mount_path}/role/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['terraform-cloud-list-roles'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{terraform_mount_path}/role/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['terraform-cloud-read-role'];
    put?: never;
    post: operations['terraform-cloud-write-role'];
    delete: operations['terraform-cloud-delete-role'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{terraform_mount_path}/rotate-role/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the team or organization role */
        name: string;
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['terraform-cloud-rotate-role'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{totp_mount_path}/code/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key. */
        name: string;
        /** @description Path that the backend was mounted at */
        totp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['totp-generate-code'];
    put?: never;
    post: operations['totp-validate-code'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{totp_mount_path}/keys/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        totp_mount_path: string;
      };
      cookie?: never;
    };
    /** Manage the keys that can be created with this backend. */
    get: operations['totp-list-keys'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{totp_mount_path}/keys/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key. */
        name: string;
        /** @description Path that the backend was mounted at */
        totp_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['totp-read-key'];
    put?: never;
    post: operations['totp-create-key'];
    delete: operations['totp-delete-key'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/backup/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    /** Backup the named key */
    get: operations['transit-back-up-key'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/byok-export/{destination}/{source}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Destination key to export to; usually the public wrapping key of another Transit instance. */
        destination: string;
        /** @description Source key to export; could be any present key within Transit. */
        source: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    /** Securely export named encryption or signing key */
    get: operations['transit-byok-key'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/byok-export/{destination}/{source}/{version}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Destination key to export to; usually the public wrapping key of another Transit instance. */
        destination: string;
        /** @description Source key to export; could be any present key within Transit. */
        source: string;
        /** @description Optional version of the key to export, else all key versions are exported. */
        version: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    /** Securely export named encryption or signing key */
    get: operations['transit-byok-key-version'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/cache-config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    /** Returns the size of the active cache */
    get: operations['transit-read-cache-configuration'];
    put?: never;
    /** Configures a new cache of the specified size */
    post: operations['transit-configure-cache'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/config/keys': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['transit-read-keys-configuration'];
    put?: never;
    post: operations['transit-configure-keys'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/datakey/{plaintext}/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The backend key used for encrypting the data key */
        name: string;
        /** @description "plaintext" will return the key in both plaintext and ciphertext; "wrapped" will return the ciphertext only. */
        plaintext: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate a data key */
    post: operations['transit-generate-data-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/decrypt/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Decrypt a ciphertext value using a named key */
    post: operations['transit-decrypt'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/encrypt/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Encrypt a plaintext value or a batch of plaintext
     *     blocks using a named key */
    post: operations['transit-encrypt'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/export/{type}/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Type of key to export (encryption-key, signing-key, hmac-key, public-key) */
        type: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    /** Export named encryption or signing key */
    get: operations['transit-export-key'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/export/{type}/{name}/{version}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Type of key to export (encryption-key, signing-key, hmac-key, public-key) */
        type: string;
        /** @description Version of the key */
        version: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    /** Export named encryption or signing key */
    get: operations['transit-export-key-version'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/hash': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate a hash sum for input data */
    post: operations['transit-hash'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/hash/{urlalgorithm}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Algorithm to use (POST URL parameter) */
        urlalgorithm: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate a hash sum for input data */
    post: operations['transit-hash-with-algorithm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/hmac/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key to use for the HMAC function */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate an HMAC for input data using the named key */
    post: operations['transit-generate-hmac'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/hmac/{name}/{urlalgorithm}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key to use for the HMAC function */
        name: string;
        /** @description Algorithm to use (POST URL parameter) */
        urlalgorithm: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate an HMAC for input data using the named key */
    post: operations['transit-generate-hmac-with-algorithm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/keys/': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    /** Managed named encryption keys */
    get: operations['transit-list-keys'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/keys/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get: operations['transit-read-key'];
    put?: never;
    post: operations['transit-create-key'];
    delete: operations['transit-delete-key'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/keys/{name}/config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Configure a named encryption key */
    post: operations['transit-configure-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/keys/{name}/csr': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['transit-generate-csr-for-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/keys/{name}/import': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Imports an externally-generated key into a new transit key */
    post: operations['transit-import-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/keys/{name}/import_version': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Imports an externally-generated key into an existing imported key */
    post: operations['transit-import-key-version'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/keys/{name}/rotate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Rotate named encryption key */
    post: operations['transit-rotate-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/keys/{name}/set-certificate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['transit-set-certificate-for-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/keys/{name}/trim': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Trim key versions of a named key */
    post: operations['transit-trim-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/random': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate random bytes */
    post: operations['transit-generate-random'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/random/{source}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Which system to source random data from, ether "platform", "seal", or "all". */
        source: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate random bytes */
    post: operations['transit-generate-random-with-source'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/random/{source}/{urlbytes}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Which system to source random data from, ether "platform", "seal", or "all". */
        source: string;
        /** @description The number of bytes to generate (POST URL parameter) */
        urlbytes: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate random bytes */
    post: operations['transit-generate-random-with-source-and-bytes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/random/{urlbytes}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The number of bytes to generate (POST URL parameter) */
        urlbytes: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate random bytes */
    post: operations['transit-generate-random-with-bytes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/restore': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Restore the named key */
    post: operations['transit-restore-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/restore/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description If set, this will be the name of the restored key. */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Restore the named key */
    post: operations['transit-restore-and-rename-key'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/rewrap/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Rewrap ciphertext */
    post: operations['transit-rewrap'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/sign/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key to use */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate a signature for input data using the named key */
    post: operations['transit-sign'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/sign/{name}/{urlalgorithm}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key to use */
        name: string;
        /** @description Hash algorithm to use (POST URL parameter) */
        urlalgorithm: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate a signature for input data using the named key */
    post: operations['transit-sign-with-algorithm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/verify/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key to use */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Verify a signature or HMAC for input data created using the named key */
    post: operations['transit-verify'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/verify/{name}/{urlalgorithm}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key to use */
        name: string;
        /** @description Hash algorithm to use (POST URL parameter) */
        urlalgorithm: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Verify a signature or HMAC for input data created using the named key */
    post: operations['transit-verify-with-algorithm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{transit_mount_path}/wrapping_key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    /** Returns the public key to use for wrapping imported keys */
    get: operations['transit-read-wrapping-key'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    AliCloudConfigureRequest: {
      /** @description Access key with appropriate permissions. */
      access_key?: string;
      /** @description Secret key with appropriate permissions. */
      secret_key?: string;
    };
    AliCloudLoginRequest: {
      /** @description The request headers. This must include the headers over which AliCloud has included a signature. */
      identity_request_headers?: string;
      /** @description Base64-encoded full URL against which to make the AliCloud request. */
      identity_request_url?: string;
      /** @description Name of the role against which the login is being attempted. If 'role' is not specified, then the login endpoint looks for a role name in the ARN returned by the GetCallerIdentity request. If a matching role is not found, login fails. */
      role: string;
    };
    AliCloudWriteAuthRoleRequest: {
      /** @description ARN of the RAM to bind to this role. */
      arn?: string;
      /**
       * @deprecated
       * @description Use "token_bound_cidrs" instead. If this and "token_bound_cidrs" are both specified, only "token_bound_cidrs" will be used.
       */
      bound_cidrs?: string[];
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_max_ttl" instead. If this and "token_max_ttl" are both specified, only "token_max_ttl" will be used.
       */
      max_ttl?: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_period" instead. If this and "token_period" are both specified, only "token_period" will be used.
       */
      period?: string;
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_ttl" instead. If this and "token_ttl" are both specified, only "token_ttl" will be used.
       */
      ttl?: string;
    };
    AliCloudWriteRoleRequest: {
      /** @description JSON of policies to be dynamically applied to users of this role. */
      inline_policies?: string;
      /**
       * Format: duration
       * @description The maximum allowed lifetime of tokens issued using this role.
       */
      max_ttl?: string;
      /** @description The name and type of each remote policy to be applied. Example: "name:AliyunRDSReadOnlyAccess,type:System". */
      remote_policies?: string[];
      /** @description ARN of the role to be assumed. If provided, inline_policies and remote_policies should be blank. At creation time, this role must have configured trusted actors, and the access key and secret that will be used to assume the role (in /config) must qualify as a trusted actor. */
      role_arn?: string;
      /**
       * Format: duration
       * @description Duration in seconds after which the issued token should expire. Defaults to 0, in which case the value will fallback to the system/mount defaults.
       */
      ttl?: string;
    };
    AliasCreateRequest: {
      /** @description Entity ID to which this alias belongs to */
      canonical_id?: string;
      /** @description Entity ID to which this alias belongs to. This field is deprecated in favor of 'canonical_id'. */
      entity_id?: string;
      /** @description ID of the alias */
      id?: string;
      /** @description Mount accessor to which this alias belongs to */
      mount_accessor?: string;
      /** @description Name of the alias */
      name?: string;
    };
    AliasUpdateByIdRequest: {
      /** @description Entity ID to which this alias should be tied to */
      canonical_id?: string;
      /** @description Entity ID to which this alias should be tied to. This field is deprecated in favor of 'canonical_id'. */
      entity_id?: string;
      /** @description Mount accessor to which this alias belongs to */
      mount_accessor?: string;
      /** @description Name of the alias */
      name?: string;
    };
    AppRoleDestroySecretIdByAccessorRequest: {
      /** @description Accessor of the SecretID */
      secret_id_accessor?: string;
    };
    AppRoleDestroySecretIdRequest: {
      /** @description SecretID attached to the role. */
      secret_id?: string;
    };
    AppRoleLoginRequest: {
      /** @description Unique identifier of the Role. Required to be supplied when the 'bind_secret_id' constraint is set. */
      role_id?: string;
      /**
       * @description SecretID belong to the App role
       * @default
       */
      secret_id: string;
    };
    AppRoleLoginResponse: {
      role?: string;
    };
    AppRoleLookUpSecretIdByAccessorRequest: {
      /** @description Accessor of the SecretID */
      secret_id_accessor?: string;
    };
    AppRoleLookUpSecretIdByAccessorResponse: {
      /** @description List of CIDR blocks enforcing secret IDs to be used from specific set of IP addresses. If 'bound_cidr_list' is set on the role, then the list of CIDR blocks listed here should be a subset of the CIDR blocks listed on the role. */
      cidr_list?: string[];
      /** Format: date-time */
      creation_time?: string;
      /** Format: date-time */
      expiration_time?: string;
      /** Format: date-time */
      last_updated_time?: string;
      /** Format: kvpairs */
      metadata?: Record<string, never>;
      /** @description Accessor of the secret ID */
      secret_id_accessor?: string;
      /** @description Number of times a secret ID can access the role, after which the secret ID will expire. */
      secret_id_num_uses?: number;
      /**
       * Format: int64
       * @description Duration in seconds after which the issued secret ID expires.
       */
      secret_id_ttl?: number;
      /** @description List of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. Should be a subset of the token CIDR blocks listed on the role, if any. */
      token_bound_cidrs?: string[];
    };
    AppRoleLookUpSecretIdRequest: {
      /** @description SecretID attached to the role. */
      secret_id?: string;
    };
    AppRoleLookUpSecretIdResponse: {
      /** @description List of CIDR blocks enforcing secret IDs to be used from specific set of IP addresses. If 'bound_cidr_list' is set on the role, then the list of CIDR blocks listed here should be a subset of the CIDR blocks listed on the role. */
      cidr_list?: string[];
      /** Format: date-time */
      creation_time?: string;
      /** Format: date-time */
      expiration_time?: string;
      /** Format: date-time */
      last_updated_time?: string;
      /** Format: kvpairs */
      metadata?: Record<string, never>;
      /** @description Accessor of the secret ID */
      secret_id_accessor?: string;
      /** @description Number of times a secret ID can access the role, after which the secret ID will expire. */
      secret_id_num_uses?: number;
      /**
       * Format: int64
       * @description Duration in seconds after which the issued secret ID expires.
       */
      secret_id_ttl?: number;
      /** @description List of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. Should be a subset of the token CIDR blocks listed on the role, if any. */
      token_bound_cidrs?: string[];
    };
    AppRoleReadBindSecretIdResponse: {
      /** @description Impose secret_id to be presented when logging in using this role. Defaults to 'true'. */
      bind_secret_id?: boolean;
    };
    AppRoleReadBoundCidrListResponse: {
      /**
       * @deprecated
       * @description Deprecated: Please use "secret_id_bound_cidrs" instead. Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation.
       */
      bound_cidr_list?: string[];
    };
    AppRoleReadLocalSecretIdsResponse: {
      /** @description If true, the secret identifiers generated using this role will be cluster local. This can only be set during role creation and once set, it can't be reset later */
      local_secret_ids?: boolean;
    };
    AppRoleReadPeriodResponse: {
      /**
       * Format: int64
       * @deprecated
       * @description Use "token_period" instead. If this and "token_period" are both specified, only "token_period" will be used.
       */
      period?: number;
      /**
       * Format: int64
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: number;
    };
    AppRoleReadPoliciesResponse: {
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /** @description Comma-separated list of policies */
      token_policies?: string[];
    };
    AppRoleReadRoleIdResponse: {
      /** @description Identifier of the role. Defaults to a UUID. */
      role_id?: string;
    };
    AppRoleReadRoleResponse: {
      /** @description Impose secret ID to be presented when logging in using this role. */
      bind_secret_id?: boolean;
      /** @description If true, the secret identifiers generated using this role will be cluster local. This can only be set during role creation and once set, it can't be reset later */
      local_secret_ids?: boolean;
      /**
       * Format: int64
       * @deprecated
       * @description Use "token_period" instead. If this and "token_period" are both specified, only "token_period" will be used.
       */
      period?: number;
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /** @description Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation. */
      secret_id_bound_cidrs?: string[];
      /** @description Number of times a secret ID can access the role, after which the secret ID will expire. */
      secret_id_num_uses?: number;
      /**
       * Format: int64
       * @description Duration in seconds after which the issued secret ID expires.
       */
      secret_id_ttl?: number;
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: int64
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: number;
      /**
       * Format: int64
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: number;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: int64
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value.
       */
      token_period?: number;
      /** @description Comma-separated list of policies */
      token_policies?: string[];
      /**
       * Format: int64
       * @description The initial ttl of the token to generate
       */
      token_ttl?: number;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
    };
    AppRoleReadSecretIdBoundCidrsResponse: {
      /** @description Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation. */
      secret_id_bound_cidrs?: string[];
    };
    AppRoleReadSecretIdNumUsesResponse: {
      /** @description Number of times a secret ID can access the role, after which the SecretID will expire. Defaults to 0 meaning that the secret ID is of unlimited use. */
      secret_id_num_uses?: number;
    };
    AppRoleReadSecretIdTtlResponse: {
      /**
       * Format: int64
       * @description Duration in seconds after which the issued secret ID should expire. Defaults to 0, meaning no expiration.
       */
      secret_id_ttl?: number;
    };
    AppRoleReadTokenBoundCidrsResponse: {
      /** @description Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. Should be a subset of the token CIDR blocks listed on the role, if any. */
      token_bound_cidrs?: string[];
    };
    AppRoleReadTokenMaxTtlResponse: {
      /**
       * Format: int64
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: number;
    };
    AppRoleReadTokenNumUsesResponse: {
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
    };
    AppRoleReadTokenTtlResponse: {
      /**
       * Format: int64
       * @description The initial ttl of the token to generate
       */
      token_ttl?: number;
    };
    AppRoleWriteBindSecretIdRequest: {
      /**
       * @description Impose secret_id to be presented when logging in using this role.
       * @default true
       */
      bind_secret_id: boolean;
    };
    AppRoleWriteBoundCidrListRequest: {
      /** @description Deprecated: Please use "secret_id_bound_cidrs" instead. Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation. */
      bound_cidr_list?: string[];
    };
    AppRoleWriteCustomSecretIdRequest: {
      /** @description Comma separated string or list of CIDR blocks enforcing secret IDs to be used from specific set of IP addresses. If 'bound_cidr_list' is set on the role, then the list of CIDR blocks listed here should be a subset of the CIDR blocks listed on the role. */
      cidr_list?: string[];
      /** @description Metadata to be tied to the SecretID. This should be a JSON formatted string containing metadata in key value pairs. */
      metadata?: string;
      /** @description Number of times this SecretID can be used, after which the SecretID expires. Overrides secret_id_num_uses role option when supplied. May not be higher than role's secret_id_num_uses. */
      num_uses?: number;
      /** @description SecretID to be attached to the role. */
      secret_id?: string;
      /** @description Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. Should be a subset of the token CIDR blocks listed on the role, if any. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description Duration in seconds after which this SecretID expires. Overrides secret_id_ttl role option when supplied. May not be longer than role's secret_id_ttl.
       */
      ttl?: string;
    };
    AppRoleWriteCustomSecretIdResponse: {
      /** @description Secret ID attached to the role. */
      secret_id?: string;
      /** @description Accessor of the secret ID */
      secret_id_accessor?: string;
      /** @description Number of times a secret ID can access the role, after which the secret ID will expire. */
      secret_id_num_uses?: number;
      /**
       * Format: int64
       * @description Duration in seconds after which the issued secret ID expires.
       */
      secret_id_ttl?: number;
    };
    AppRoleWritePeriodRequest: {
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_period" instead. If this and "token_period" are both specified, only "token_period" will be used.
       */
      period?: string;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
    };
    AppRoleWritePoliciesRequest: {
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /** @description Comma-separated list of policies */
      token_policies?: string[];
    };
    AppRoleWriteRoleIdRequest: {
      /** @description Identifier of the role. Defaults to a UUID. */
      role_id?: string;
    };
    AppRoleWriteRoleRequest: {
      /**
       * @description Impose secret_id to be presented when logging in using this role. Defaults to 'true'.
       * @default true
       */
      bind_secret_id: boolean;
      /**
       * @deprecated
       * @description Use "secret_id_bound_cidrs" instead.
       */
      bound_cidr_list?: string[];
      /** @description If set, the secret IDs generated using this role will be cluster local. This can only be set during role creation and once set, it can't be reset later. */
      local_secret_ids?: boolean;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_period" instead. If this and "token_period" are both specified, only "token_period" will be used.
       */
      period?: string;
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /** @description Identifier of the role. Defaults to a UUID. */
      role_id?: string;
      /** @description Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation. */
      secret_id_bound_cidrs?: string[];
      /** @description Number of times a SecretID can access the role, after which the SecretID will expire. Defaults to 0 meaning that the the secret_id is of unlimited use. */
      secret_id_num_uses?: number;
      /**
       * Format: duration
       * @description Duration in seconds after which the issued SecretID should expire. Defaults to 0, meaning no expiration.
       */
      secret_id_ttl?: string;
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
    };
    AppRoleWriteSecretIdBoundCidrsRequest: {
      /** @description Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation. */
      secret_id_bound_cidrs?: string[];
    };
    AppRoleWriteSecretIdNumUsesRequest: {
      /** @description Number of times a SecretID can access the role, after which the SecretID will expire. */
      secret_id_num_uses?: number;
    };
    AppRoleWriteSecretIdRequest: {
      /** @description Comma separated string or list of CIDR blocks enforcing secret IDs to be used from specific set of IP addresses. If 'bound_cidr_list' is set on the role, then the list of CIDR blocks listed here should be a subset of the CIDR blocks listed on the role. */
      cidr_list?: string[];
      /** @description Metadata to be tied to the SecretID. This should be a JSON formatted string containing the metadata in key value pairs. */
      metadata?: string;
      /** @description Number of times this SecretID can be used, after which the SecretID expires. Overrides secret_id_num_uses role option when supplied. May not be higher than role's secret_id_num_uses. */
      num_uses?: number;
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description Duration in seconds after which this SecretID expires. Overrides secret_id_ttl role option when supplied. May not be longer than role's secret_id_ttl.
       */
      ttl?: string;
    };
    AppRoleWriteSecretIdResponse: {
      /** @description Secret ID attached to the role. */
      secret_id?: string;
      /** @description Accessor of the secret ID */
      secret_id_accessor?: string;
      /** @description Number of times a secret ID can access the role, after which the secret ID will expire. */
      secret_id_num_uses?: number;
      /**
       * Format: int64
       * @description Duration in seconds after which the issued secret ID expires.
       */
      secret_id_ttl?: number;
    };
    AppRoleWriteSecretIdTtlRequest: {
      /**
       * Format: duration
       * @description Duration in seconds after which the issued SecretID should expire. Defaults to 0, meaning no expiration.
       */
      secret_id_ttl?: string;
    };
    AppRoleWriteTokenBoundCidrsRequest: {
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
    };
    AppRoleWriteTokenMaxTtlRequest: {
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
    };
    AppRoleWriteTokenNumUsesRequest: {
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
    };
    AppRoleWriteTokenTtlRequest: {
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
    };
    AuditingCalculateHashRequest: {
      input?: string;
    };
    AuditingCalculateHashResponse: {
      hash?: string;
    };
    AuditingEnableDeviceRequest: {
      /** @description User-friendly description for this audit backend. */
      description?: string;
      /**
       * @description Mark the mount as a local mount, which is not replicated and is unaffected by replication.
       * @default false
       */
      local: boolean;
      /**
       * Format: kvpairs
       * @description Configuration options for the audit backend.
       */
      options?: Record<string, never>;
      /** @description The type of the backend. Example: "mysql" */
      type?: string;
    };
    AuditingEnableRequestHeaderRequest: {
      hmac?: boolean;
    };
    AuditingListRequestHeadersResponse: {
      /** Format: map */
      headers?: Record<string, never>;
    };
    AuthEnableMethodRequest: {
      /**
       * Format: map
       * @description Configuration for this mount, such as plugin_name.
       */
      config?: Record<string, never>;
      /** @description User-friendly description for this credential backend. */
      description?: string;
      /**
       * @description Whether to give the mount access to Vault's external entropy.
       * @default false
       */
      external_entropy_access: boolean;
      /**
       * @description Mark the mount as a local mount, which is not replicated and is unaffected by replication.
       * @default false
       */
      local: boolean;
      /**
       * Format: kvpairs
       * @description The options to pass into the backend. Should be a json object with string keys and values.
       */
      options?: Record<string, never>;
      /** @description Name of the auth plugin to use based from the name in the plugin catalog. */
      plugin_name?: string;
      /** @description The semantic version of the plugin to use, or image tag if oci_image is provided. */
      plugin_version?: string;
      /**
       * @description Whether to turn on seal wrapping for the mount.
       * @default false
       */
      seal_wrap: boolean;
      /** @description The type of the backend. Example: "userpass" */
      type?: string;
    };
    AuthReadConfigurationResponse: {
      accessor?: string;
      /** Format: map */
      config?: Record<string, never>;
      deprecation_status?: string;
      description?: string;
      external_entropy_access?: boolean;
      local?: boolean;
      /** Format: map */
      options?: Record<string, never>;
      plugin_version?: string;
      running_plugin_version?: string;
      running_sha256?: string;
      seal_wrap?: boolean;
      type?: string;
      uuid?: string;
    };
    AuthReadTuningInformationResponse: {
      allowed_managed_keys?: string[];
      allowed_response_headers?: string[];
      audit_non_hmac_request_keys?: string[];
      audit_non_hmac_response_keys?: string[];
      default_lease_ttl?: number;
      description?: string;
      external_entropy_access?: boolean;
      force_no_cache?: boolean;
      identity_token_key?: string;
      listing_visibility?: string;
      max_lease_ttl?: number;
      /** Format: map */
      options?: Record<string, never>;
      passthrough_request_headers?: string[];
      plugin_version?: string;
      token_type?: string;
      /** Format: int64 */
      user_lockout_counter_reset_duration?: number;
      user_lockout_disable?: boolean;
      /** Format: int64 */
      user_lockout_duration?: number;
      /** Format: int64 */
      user_lockout_threshold?: number;
    };
    AuthTuneConfigurationParametersRequest: {
      /** @description A list of headers to whitelist and allow a plugin to set on responses. */
      allowed_response_headers?: string[];
      /** @description The list of keys in the request data object that will not be HMAC'ed by audit devices. */
      audit_non_hmac_request_keys?: string[];
      /** @description The list of keys in the response data object that will not be HMAC'ed by audit devices. */
      audit_non_hmac_response_keys?: string[];
      /** @description The default lease TTL for this mount. */
      default_lease_ttl?: string;
      /** @description User-friendly description for this credential backend. */
      description?: string;
      /** @description The name of the key used to sign plugin identity tokens. Defaults to the default key. */
      identity_token_key?: string;
      /** @description Determines the visibility of the mount in the UI-specific listing endpoint. Accepted value are 'unauth' and 'hidden', with the empty default ('') behaving like 'hidden'. */
      listing_visibility?: string;
      /** @description The max lease TTL for this mount. */
      max_lease_ttl?: string;
      /**
       * Format: kvpairs
       * @description The options to pass into the backend. Should be a json object with string keys and values.
       */
      options?: Record<string, never>;
      /** @description A list of headers to whitelist and pass from the request to the plugin. */
      passthrough_request_headers?: string[];
      /** @description The semantic version of the plugin to use, or image tag if oci_image is provided. */
      plugin_version?: string;
      /** @description The type of token to issue (service or batch). */
      token_type?: string;
      /**
       * Format: map
       * @description The user lockout configuration to pass into the backend. Should be a json object with string keys and values.
       */
      user_lockout_config?: Record<string, never>;
    };
    AwsConfigureCertificateRequest: {
      /** @description Base64 encoded AWS Public cert required to verify PKCS7 signature of the EC2 instance metadata. */
      aws_public_cert?: string;
      /**
       * @description Takes the value of either "pkcs7" or "identity", indicating the type of document which can be verified using the given certificate. The reason is that the PKCS#7 document will have a DSA digest and the identity signature will have an RSA signature, and accordingly the public certificates to verify those also vary. Defaults to "pkcs7".
       * @default pkcs7
       */
      type: string;
    };
    AwsConfigureClientRequest: {
      /**
       * @description AWS Access Key ID for the account used to make AWS API requests.
       * @default
       */
      access_key: string;
      /** @description List of additional headers that are allowed to be in AWS STS request headers */
      allowed_sts_header_values?: string[];
      /**
       * @description URL to override the default generated endpoint for making AWS EC2 API calls.
       * @default
       */
      endpoint: string;
      /**
       * @description URL to override the default generated endpoint for making AWS IAM API calls.
       * @default
       */
      iam_endpoint: string;
      /**
       * @description Value to require in the X-Vault-AWS-IAM-Server-ID request header
       * @default
       */
      iam_server_id_header_value: string;
      /**
       * @description Maximum number of retries for recoverable exceptions of AWS APIs
       * @default -1
       */
      max_retries: number;
      /**
       * @description AWS Secret Access Key for the account used to make AWS API requests.
       * @default
       */
      secret_key: string;
      /**
       * @description URL to override the default generated endpoint for making AWS STS API calls.
       * @default
       */
      sts_endpoint: string;
      /**
       * @description The region ID for the sts_endpoint, if set.
       * @default
       */
      sts_region: string;
      /**
       * @description Uses the STS region from client requests for making AWS STS API calls.
       * @default false
       */
      use_sts_region_from_client: boolean;
    };
    AwsConfigureIdentityAccessListTidyOperationRequest: {
      /**
       * @description If set to 'true', disables the periodic tidying of the 'identity-accesslist/<instance_id>' entries.
       * @default false
       */
      disable_periodic_tidy: boolean;
      /**
       * Format: duration
       * @description The amount of extra time that must have passed beyond the identity's expiration, before it is removed from the backend storage.
       * @default 259200
       */
      safety_buffer: string;
    };
    AwsConfigureIdentityIntegrationRequest: {
      /**
       * @description Configure how the AWS auth method generates entity alias when using EC2 auth. Valid values are "role_id", "instance_id", and "image_id". Defaults to "role_id".
       * @default instance_id
       */
      ec2_alias: string;
      /**
       * @description The metadata to include on the aliases and audit logs generated by this plugin. When set to 'default', includes: account_id, auth_type. These fields are available to add: ami_id, instance_id, region. Not editing this field means the 'default' fields are included. Explicitly setting this field to empty overrides the 'default' and means no metadata will be included. If not using 'default', explicit fields must be sent like: 'field1,field2'.
       * @default [
       *       "default"
       *     ]
       */
      ec2_metadata: string[];
      /**
       * @description Configure how the AWS auth method generates entity aliases when using IAM auth. Valid values are "role_id", "unique_id", and "full_arn". Defaults to "role_id".
       * @default unique_id
       */
      iam_alias: string;
      /**
       * @description The metadata to include on the aliases and audit logs generated by this plugin. When set to 'default', includes: account_id, auth_type. These fields are available to add: canonical_arn, client_arn, client_user_id, inferred_aws_region, inferred_entity_id, inferred_entity_type. Not editing this field means the 'default' fields are included. Explicitly setting this field to empty overrides the 'default' and means no metadata will be included. If not using 'default', explicit fields must be sent like: 'field1,field2'.
       * @default [
       *       "default"
       *     ]
       */
      iam_metadata: string[];
    };
    AwsConfigureIdentityWhitelistTidyOperationRequest: {
      /**
       * @description If set to 'true', disables the periodic tidying of the 'identity-accesslist/<instance_id>' entries.
       * @default false
       */
      disable_periodic_tidy: boolean;
      /**
       * Format: duration
       * @description The amount of extra time that must have passed beyond the identity's expiration, before it is removed from the backend storage.
       * @default 259200
       */
      safety_buffer: string;
    };
    AwsConfigureLeaseRequest: {
      /** @description Default lease for roles. */
      lease?: string;
      /** @description Maximum time a credential is valid for. */
      lease_max?: string;
    };
    AwsConfigureRoleTagBlacklistTidyOperationRequest: {
      /**
       * @description If set to 'true', disables the periodic tidying of deny listed entries.
       * @default false
       */
      disable_periodic_tidy: boolean;
      /**
       * Format: duration
       * @description The amount of extra time that must have passed beyond the roletag expiration, before it is removed from the backend storage. Defaults to 4320h (180 days).
       * @default 15552000
       */
      safety_buffer: string;
    };
    AwsConfigureRoleTagDenyListTidyOperationRequest: {
      /**
       * @description If set to 'true', disables the periodic tidying of deny listed entries.
       * @default false
       */
      disable_periodic_tidy: boolean;
      /**
       * Format: duration
       * @description The amount of extra time that must have passed beyond the roletag expiration, before it is removed from the backend storage. Defaults to 4320h (180 days).
       * @default 15552000
       */
      safety_buffer: string;
    };
    AwsConfigureRootIamCredentialsRequest: {
      /** @description Access key with permission to create new keys. */
      access_key?: string;
      /** @description Endpoint to custom IAM server URL */
      iam_endpoint?: string;
      /**
       * @description Audience of plugin identity tokens
       * @default
       */
      identity_token_audience: string;
      /**
       * Format: duration
       * @description Time-to-live of plugin identity tokens
       * @default 3600
       */
      identity_token_ttl: string;
      /**
       * @description Maximum number of retries for recoverable exceptions of AWS APIs
       * @default -1
       */
      max_retries: number;
      /** @description Region for API calls. */
      region?: string;
      /** @description Role ARN to assume for plugin identity token federation */
      role_arn?: string;
      /** @description Secret key with permission to create new keys. */
      secret_key?: string;
      /** @description Endpoint to custom STS server URL */
      sts_endpoint?: string;
      /** @description Template to generate custom IAM usernames */
      username_template?: string;
    };
    AwsGenerateCredentialsWithParametersRequest: {
      /** @description MFA code to provide for session tokens */
      mfa_code?: string;
      /** @description ARN of role to assume when credential_type is assumed_role */
      role_arn?: string;
      /** @description Session name to use when assuming role. Max chars: 64 */
      role_session_name?: string;
      /**
       * Format: duration
       * @description Lifetime of the returned credentials in seconds
       * @default 3600
       */
      ttl: string;
    };
    AwsGenerateStsCredentialsWithParametersRequest: {
      /** @description MFA code to provide for session tokens */
      mfa_code?: string;
      /** @description ARN of role to assume when credential_type is assumed_role */
      role_arn?: string;
      /** @description Session name to use when assuming role. Max chars: 64 */
      role_session_name?: string;
      /**
       * Format: duration
       * @description Lifetime of the returned credentials in seconds
       * @default 3600
       */
      ttl: string;
    };
    AwsLoginRequest: {
      /** @description HTTP method to use for the AWS request when auth_type is iam. This must match what has been signed in the presigned request. */
      iam_http_request_method?: string;
      /** @description Base64-encoded request body when auth_type is iam. This must match the request body included in the signature. */
      iam_request_body?: string;
      /** @description Key/value pairs of headers for use in the sts:GetCallerIdentity HTTP requests headers when auth_type is iam. Can be either a Base64-encoded, JSON-serialized string, or a JSON object of key/value pairs. This must at a minimum include the headers over which AWS has included a signature. */
      iam_request_headers?: string;
      /** @description Base64-encoded full URL against which to make the AWS request when using iam auth_type. */
      iam_request_url?: string;
      /** @description Base64 encoded EC2 instance identity document. This needs to be supplied along with the 'signature' parameter. If using 'curl' for fetching the identity document, consider using the option '-w 0' while piping the output to 'base64' binary. */
      identity?: string;
      /** @description The nonce to be used for subsequent login requests when auth_type is ec2. If this parameter is not specified at all and if reauthentication is allowed, then the backend will generate a random nonce, attaches it to the instance's identity access list entry and returns the nonce back as part of auth metadata. This value should be used with further login requests, to establish client authenticity. Clients can choose to set a custom nonce if preferred, in which case, it is recommended that clients provide a strong nonce. If a nonce is provided but with an empty value, it indicates intent to disable reauthentication. Note that, when 'disallow_reauthentication' option is enabled on either the role or the role tag, the 'nonce' holds no significance. */
      nonce?: string;
      /** @description PKCS7 signature of the identity document when using an auth_type of ec2. */
      pkcs7?: string;
      /** @description Name of the role against which the login is being attempted. If 'role' is not specified, then the login endpoint looks for a role bearing the name of the AMI ID of the EC2 instance that is trying to login. If a matching role is not found, login fails. */
      role?: string;
      /** @description Base64 encoded SHA256 RSA signature of the instance identity document. This needs to be supplied along with 'identity' parameter. */
      signature?: string;
    };
    AwsReadStaticCredsNameResponse: {
      /** @description The access key of the AWS Credential */
      access_key?: string;
      /** @description The secret key of the AWS Credential */
      secret_key?: string;
    };
    AwsReadStaticRolesNameResponse: {
      /** @description The name of this role. */
      name?: string;
      /**
       * Format: duration
       * @description Period by which to rotate the backing credential of the adopted user. This can be a Go duration (e.g, '1m', 24h'), or an integer number of seconds.
       */
      rotation_period?: string;
      /** @description The IAM user to adopt as a static role. */
      username?: string;
    };
    AwsTidyIdentityAccessListRequest: {
      /**
       * Format: duration
       * @description The amount of extra time that must have passed beyond the identity's expiration, before it is removed from the backend storage.
       * @default 259200
       */
      safety_buffer: string;
    };
    AwsTidyIdentityWhitelistRequest: {
      /**
       * Format: duration
       * @description The amount of extra time that must have passed beyond the identity's expiration, before it is removed from the backend storage.
       * @default 259200
       */
      safety_buffer: string;
    };
    AwsTidyRoleTagBlacklistRequest: {
      /**
       * Format: duration
       * @description The amount of extra time that must have passed beyond the roletag expiration, before it is removed from the backend storage.
       * @default 259200
       */
      safety_buffer: string;
    };
    AwsTidyRoleTagDenyListRequest: {
      /**
       * Format: duration
       * @description The amount of extra time that must have passed beyond the roletag expiration, before it is removed from the backend storage.
       * @default 259200
       */
      safety_buffer: string;
    };
    AwsWriteAuthRoleRequest: {
      /**
       * @description If set, allows migration of the underlying instance where the client resides. This keys off of pendingTime in the metadata document, so essentially, this disables the client nonce check whenever the instance is migrated to a new host and pendingTime is newer than the previously-remembered time. Use with caution. This is only checked when auth_type is ec2.
       * @default false
       */
      allow_instance_migration: boolean;
      /** @description The auth_type permitted to authenticate to this role. Must be one of iam or ec2 and cannot be changed after role creation. */
      auth_type?: string;
      /** @description If set, defines a constraint on the EC2 instances that the account ID in its identity document to match one of the IDs specified by this parameter. This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance. */
      bound_account_id?: string[];
      /** @description If set, defines a constraint on the EC2 instances that they should be using one of the AMI IDs specified by this parameter. This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance. */
      bound_ami_id?: string[];
      /** @description If set, defines a constraint on the EC2 instances to have one of the given instance IDs. Can be a list or comma-separated string of EC2 instance IDs. This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance. */
      bound_ec2_instance_id?: string[];
      /** @description If set, defines a constraint on the EC2 instances to be associated with an IAM instance profile ARN which has a prefix that matches one of the values specified by this parameter. The value is prefix-matched (as though it were a glob ending in '*'). This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance. */
      bound_iam_instance_profile_arn?: string[];
      /** @description ARN of the IAM principals to bind to this role. Only applicable when auth_type is iam. */
      bound_iam_principal_arn?: string[];
      /** @description If set, defines a constraint on the authenticating EC2 instance that it must match one of the IAM role ARNs specified by this parameter. The value is prefix-matched (as though it were a glob ending in '*'). The configured IAM user or EC2 instance role must be allowed to execute the 'iam:GetInstanceProfile' action if this is specified. This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance. */
      bound_iam_role_arn?: string[];
      /** @description If set, defines a constraint on the EC2 instances that the region in its identity document match one of the regions specified by this parameter. This is only applicable when auth_type is ec2. */
      bound_region?: string[];
      /** @description If set, defines a constraint on the EC2 instance to be associated with the subnet ID that matches one of the values specified by this parameter. This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance. */
      bound_subnet_id?: string[];
      /** @description If set, defines a constraint on the EC2 instance to be associated with a VPC ID that matches one of the value specified by this parameter. This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance. */
      bound_vpc_id?: string[];
      /**
       * @description If set, only allows a single token to be granted per instance ID. In order to perform a fresh login, the entry in the access list for the instance ID needs to be cleared using 'auth/aws-ec2/identity-accesslist/<instance_id>' endpoint. This is only applicable when auth_type is ec2.
       * @default false
       */
      disallow_reauthentication: boolean;
      /** @description When auth_type is iam and inferred_entity_type is set, the region to assume the inferred entity exists in. */
      inferred_aws_region?: string;
      /** @description When auth_type is iam, the AWS entity type to infer from the authenticated principal. The only supported value is ec2_instance, which will extract the EC2 instance ID from the authenticated role and apply the following restrictions specific to EC2 instances: bound_ami_id, bound_account_id, bound_iam_role_arn, bound_iam_instance_profile_arn, bound_vpc_id, bound_subnet_id. The configured EC2 client must be able to find the inferred instance ID in the results, and the instance must be running. If unable to determine the EC2 instance ID or unable to find the EC2 instance ID among running instances, then authentication will fail. */
      inferred_entity_type?: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_max_ttl" instead. If this and "token_max_ttl" are both specified, only "token_max_ttl" will be used.
       */
      max_ttl?: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_period" instead. If this and "token_period" are both specified, only "token_period" will be used.
       */
      period?: string;
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /**
       * @description If set, resolve all AWS IAM ARNs into AWS's internal unique IDs. When an IAM entity (e.g., user, role, or instance profile) is deleted, then all references to it within the role will be invalidated, which prevents a new IAM entity from being created with the same name and matching the role's IAM binds. Once set, this cannot be unset.
       * @default true
       */
      resolve_aws_unique_ids: boolean;
      /**
       * @description If set, enables the role tags for this role. The value set for this field should be the 'key' of the tag on the EC2 instance. The 'value' of the tag should be generated using 'role/<role>/tag' endpoint. Defaults to an empty string, meaning that role tags are disabled. This is only allowed if auth_type is ec2.
       * @default
       */
      role_tag: string;
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_ttl" instead. If this and "token_ttl" are both specified, only "token_ttl" will be used.
       */
      ttl?: string;
    };
    AwsWriteRoleRequest: {
      /**
       * @deprecated
       * @description Use role_arns or policy_arns instead.
       */
      arn?: string;
      /** @description Type of credential to retrieve. Must be one of assumed_role, iam_user, federation_token, or session_token */
      credential_type?: string;
      /**
       * Format: duration
       * @description Default TTL for assumed_role, federation_token, and session_token credential types when no TTL is explicitly requested with the credentials
       */
      default_sts_ttl?: string;
      /** @description Names of IAM groups that generated IAM users will be added to. For a credential type of assumed_role or federation_token, the policies sent to the corresponding AWS call (sts:AssumeRole or sts:GetFederation) will be the policies from each group in iam_groups combined with the policy_document and policy_arns parameters. */
      iam_groups?: string[];
      /**
       * Format: kvpairs
       * @description IAM tags to be set for any users created by this role. These must be presented as Key-Value pairs. This can be represented as a map or a list of equal sign delimited key pairs.
       */
      iam_tags?: Record<string, never>;
      /**
       * Format: duration
       * @description Max allowed TTL for assumed_role, federation_token, and session_token credential types
       */
      max_sts_ttl?: string;
      /** @description Identification number or ARN of the MFA device associated with the root config user. Only valid when credential_type is session_token. This is only required when the IAM user has an MFA device configured. */
      mfa_serial_number?: string;
      /** @description ARN of an IAM policy to attach as a permissions boundary on IAM user credentials; only valid when credential_type isiam_user */
      permissions_boundary_arn?: string;
      /**
       * @deprecated
       * @description Use policy_document instead.
       */
      policy?: string;
      /** @description ARNs of AWS policies. Behavior varies by credential_type. When credential_type is iam_user, then it will attach the specified policies to the generated IAM user. When credential_type is assumed_role or federation_token, the policies will be passed as the PolicyArns parameter, acting as a filter on permissions available. */
      policy_arns?: string[];
      /** @description JSON-encoded IAM policy document. Behavior varies by credential_type. When credential_type is iam_user, then it will attach the contents of the policy_document to the IAM user generated. When credential_type is assumed_role or federation_token, this will be passed in as the Policy parameter to the AssumeRole or GetFederationToken API call, acting as a filter on permissions available. */
      policy_document?: string;
      /** @description ARNs of AWS roles allowed to be assumed. Only valid when credential_type is assumed_role */
      role_arns?: string[];
      /**
       * @description Path for IAM User. Only valid when credential_type is iam_user
       * @default /
       */
      user_path: string;
    };
    AwsWriteRoleTagRequest: {
      /**
       * @description If set, allows migration of the underlying instance where the client resides. This keys off of pendingTime in the metadata document, so essentially, this disables the client nonce check whenever the instance is migrated to a new host and pendingTime is newer than the previously-remembered time. Use with caution.
       * @default false
       */
      allow_instance_migration: boolean;
      /**
       * @description If set, only allows a single token to be granted per instance ID. In order to perform a fresh login, the entry in access list for the instance ID needs to be cleared using the 'auth/aws-ec2/identity-accesslist/<instance_id>' endpoint.
       * @default false
       */
      disallow_reauthentication: boolean;
      /** @description Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID. */
      instance_id?: string;
      /**
       * Format: duration
       * @description If set, specifies the maximum allowed token lifetime.
       * @default 0
       */
      max_ttl: string;
      /** @description Policies to be associated with the tag. If set, must be a subset of the role's policies. If set, but set to an empty value, only the 'default' policy will be given to issued tokens. */
      policies?: string[];
    };
    AwsWriteStaticRolesNameRequest: {
      /**
       * Format: duration
       * @description Period by which to rotate the backing credential of the adopted user. This can be a Go duration (e.g, '1m', 24h'), or an integer number of seconds.
       */
      rotation_period?: string;
      /** @description The IAM user to adopt as a static role. */
      username?: string;
    };
    AwsWriteStaticRolesNameResponse: {
      /** @description The name of this role. */
      name?: string;
      /**
       * Format: duration
       * @description Period by which to rotate the backing credential of the adopted user. This can be a Go duration (e.g, '1m', 24h'), or an integer number of seconds.
       */
      rotation_period?: string;
      /** @description The IAM user to adopt as a static role. */
      username?: string;
    };
    AwsWriteStsRoleRequest: {
      /** @description AWS ARN for STS role to be assumed when interacting with the account specified. The Vault server must have permissions to assume this role. */
      sts_role?: string;
    };
    AzureConfigureAuthRequest: {
      /** @description The OAuth2 client id to connection to Azure. This value can also be provided with the AZURE_CLIENT_ID environment variable. */
      client_id?: string;
      /** @description The OAuth2 client secret to connection to Azure. This value can also be provided with the AZURE_CLIENT_SECRET environment variable. */
      client_secret?: string;
      /** @description The Azure environment name. If not provided, AzurePublicCloud is used. This value can also be provided with the AZURE_ENVIRONMENT environment variable. */
      environment?: string;
      /**
       * @description The maximum number of attempts a failed operation will be retried before producing an error.
       * @default 3
       */
      max_retries: number;
      /**
       * Format: duration
       * @description The maximum delay allowed before retrying an operation.
       * @default 60000000000
       */
      max_retry_delay: string;
      /** @description The resource URL for the vault application in Azure Active Directory. This value can also be provided with the AZURE_AD_RESOURCE environment variable. */
      resource?: string;
      /**
       * Format: duration
       * @description The initial amount of delay to use before retrying an operation, increasing exponentially.
       * @default 4000000000
       */
      retry_delay: string;
      /**
       * Format: duration
       * @description The TTL of the root password in Azure. This can be either a number of seconds or a time formatted duration (ex: 24h, 48ds)
       * @default 15768000000000000
       */
      root_password_ttl: string;
      /** @description The tenant id for the Azure Active Directory. This is sometimes referred to as Directory ID in AD. This value can also be provided with the AZURE_TENANT_ID environment variable. */
      tenant_id?: string;
    };
    AzureConfigureRequest: {
      /** @description The OAuth2 client id to connect to Azure. This value can also be provided with the AZURE_CLIENT_ID environment variable. */
      client_id?: string;
      /** @description The OAuth2 client secret to connect to Azure. This value can also be provided with the AZURE_CLIENT_SECRET environment variable. */
      client_secret?: string;
      /** @description The Azure environment name. If not provided, AzurePublicCloud is used. This value can also be provided with the AZURE_ENVIRONMENT environment variable. */
      environment?: string;
      /** @description Name of the password policy to use to generate passwords for dynamic credentials. */
      password_policy?: string;
      /**
       * Format: duration
       * @description The TTL of the root password in Azure. This can be either a number of seconds or a time formatted duration (ex: 24h, 48ds)
       * @default 15768000000000000
       */
      root_password_ttl: string;
      /** @description The subscription id for the Azure Active Directory. This value can also be provided with the AZURE_SUBSCRIPTION_ID environment variable. */
      subscription_id?: string;
      /** @description The tenant id for the Azure Active Directory. This value can also be provided with the AZURE_TENANT_ID environment variable. */
      tenant_id?: string;
    };
    AzureLoginRequest: {
      /** @description A signed JWT */
      jwt?: string;
      /** @description The resource group from the instance. */
      resource_group_name?: string;
      /** @description The fully qualified ID of the resource, includingthe resource name and resource type. Use the format, /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}. This value is ignored if vm_name or vmss_name is specified. */
      resource_id?: string;
      /** @description The token role. */
      role?: string;
      /** @description The subscription id for the instance. */
      subscription_id?: string;
      /** @description The name of the virtual machine. This value is ignored if vmss_name is specified. */
      vm_name?: string;
      /** @description The name of the virtual machine scale set the instance is in. */
      vmss_name?: string;
    };
    AzureWriteAuthRoleRequest: {
      /** @description Comma-separated list of group ids that login is restricted to. */
      bound_group_ids?: string[];
      /** @description Comma-separated list of locations that login is restricted to. */
      bound_locations?: string[];
      /** @description Comma-separated list of resource groups that login is restricted to. */
      bound_resource_groups?: string[];
      /** @description Comma-separated list of scale sets that login is restricted to. */
      bound_scale_sets?: string[];
      /** @description Comma-separated list of service principal ids that login is restricted to. */
      bound_service_principal_ids?: string[];
      /** @description Comma-separated list of subscription ids that login is restricted to. */
      bound_subscription_ids?: string[];
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_max_ttl" instead. If this and "token_max_ttl" are both specified, only "token_max_ttl" will be used.
       */
      max_ttl?: string;
      /**
       * @deprecated
       * @description Use "token_num_uses" instead. If this and "token_num_uses" are both specified, only "token_num_uses" will be used.
       */
      num_uses?: number;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_period" instead. If this and "token_period" are both specified, only "token_period" will be used.
       */
      period?: string;
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_ttl" instead. If this and "token_ttl" are both specified, only "token_ttl" will be used.
       */
      ttl?: string;
    };
    AzureWriteRoleRequest: {
      /** @description Application Object ID to use for static service principal credentials. */
      application_object_id?: string;
      /** @description JSON list of Azure groups to add the service principal to. */
      azure_groups?: string;
      /** @description JSON list of Azure roles to assign. */
      azure_roles?: string;
      /**
       * Format: duration
       * @description Maximum time a service principal. If not set or set to 0, will use system default.
       */
      max_ttl?: string;
      /**
       * @description Indicates whether new application objects should be permanently deleted. If not set, objects will not be permanently deleted.
       * @default false
       */
      permanently_delete: boolean;
      /**
       * @description Persist the app between generated credentials. Useful if the app needs to maintain owner ship of resources it creates
       * @default false
       */
      persist_app: boolean;
      /** @description Specifies the security principal types that are allowed to sign in to the application. Valid values are: AzureADMyOrg, AzureADMultipleOrgs, AzureADandPersonalMicrosoftAccount, PersonalMicrosoftAccount */
      sign_in_audience?: string;
      /** @description Azure tags to attach to an application. */
      tags?: string[];
      /**
       * Format: duration
       * @description Default lease for generated credentials. If not set or set to 0, will use system default.
       */
      ttl?: string;
    };
    CertConfigureRequest: {
      /**
       * @description If set, during renewal, skips the matching of presented client identity with the client identity used during login. Defaults to false.
       * @default false
       */
      disable_binding: boolean;
      /**
       * @description If set, metadata of the certificate including the metadata corresponding to allowed_metadata_extensions will be stored in the alias. Defaults to false.
       * @default false
       */
      enable_identity_alias_metadata: boolean;
      /**
       * @description The size of the in memory OCSP response cache, shared by all configured certs
       * @default 100
       */
      ocsp_cache_size: number;
      /**
       * @description The size of the in memory role cache
       * @default 200
       */
      role_cache_size: number;
    };
    CertLoginRequest: {
      /** @description The name of the certificate role to authenticate against. */
      name?: string;
    };
    CertWriteCertificateRequest: {
      /** @description A comma-separated list of names. At least one must exist in the Common Name. Supports globbing. */
      allowed_common_names?: string[];
      /** @description A comma-separated list of DNS names. At least one must exist in the SANs. Supports globbing. */
      allowed_dns_sans?: string[];
      /** @description A comma-separated list of Email Addresses. At least one must exist in the SANs. Supports globbing. */
      allowed_email_sans?: string[];
      /** @description A comma-separated string or array of oid extensions. Upon successful authentication, these extensions will be added as metadata if they are present in the certificate. The metadata key will be the string consisting of the oid numbers separated by a dash (-) instead of a dot (.) to allow usage in ACL templates. */
      allowed_metadata_extensions?: string[];
      /** @description A comma-separated list of names. At least one must exist in either the Common Name or SANs. Supports globbing. This parameter is deprecated, please use allowed_common_names, allowed_dns_sans, allowed_email_sans, allowed_uri_sans. */
      allowed_names?: string[];
      /** @description A comma-separated list of Organizational Units names. At least one must exist in the OU field. */
      allowed_organizational_units?: string[];
      /** @description A comma-separated list of URIs. At least one must exist in the SANs. Supports globbing. */
      allowed_uri_sans?: string[];
      /**
       * @deprecated
       * @description Use "token_bound_cidrs" instead. If this and "token_bound_cidrs" are both specified, only "token_bound_cidrs" will be used.
       */
      bound_cidrs?: string[];
      /** @description The public certificate that should be trusted. Must be x509 PEM encoded. */
      certificate?: string;
      /** @description The display name to use for clients using this certificate. */
      display_name?: string;
      /**
       * @deprecated
       * @description Use "token_ttl" instead. If this and "token_ttl" are both specified, only "token_ttl" will be used.
       */
      lease?: number;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_max_ttl" instead. If this and "token_max_ttl" are both specified, only "token_max_ttl" will be used.
       */
      max_ttl?: string;
      /** @description Any additional CA certificates needed to communicate with OCSP servers */
      ocsp_ca_certificates?: string;
      /** @description Whether to attempt OCSP verification of certificates at login */
      ocsp_enabled?: boolean;
      /**
       * @description If set to true, if an OCSP revocation cannot be made successfully, login will proceed rather than failing. If false, failing to get an OCSP status fails the request.
       * @default false
       */
      ocsp_fail_open: boolean;
      /**
       * @description If set to true, rather than accepting the first successful OCSP response, query all servers and consider the certificate valid only if all servers agree.
       * @default false
       */
      ocsp_query_all_servers: boolean;
      /** @description A comma-separated list of OCSP server addresses. If unset, the OCSP server is determined from the AuthorityInformationAccess extension on the certificate being inspected. */
      ocsp_servers_override?: string[];
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_period" instead. If this and "token_period" are both specified, only "token_period" will be used.
       */
      period?: string;
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /** @description A comma-separated string or array of extensions formatted as "oid:value". Expects the extension value to be some type of ASN1 encoded string. All values much match. Supports globbing on "value". */
      required_extensions?: string[];
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_ttl" instead. If this and "token_ttl" are both specified, only "token_ttl" will be used.
       */
      ttl?: string;
    };
    CertWriteCrlRequest: {
      /** @description The public CRL that should be trusted to attest to certificates' validity statuses. May be DER or PEM encoded. Note: the expiration time is ignored; if the CRL is no longer valid, delete it using the same name as specified here. */
      crl?: string;
      /** @description The URL of a CRL distribution point. Only one of 'crl' or 'url' parameters should be specified. */
      url?: string;
    };
    CloudFoundryConfigureRequest: {
      /** @description CF’s API address. */
      cf_api_addr?: string;
      /** @description The PEM-format certificates that are presented for mutual TLS with the CloudFoundry API. If not set, mutual TLS is not used */
      cf_api_mutual_tls_certificate?: string;
      /** @description The PEM-format private key that are used for mutual TLS with the CloudFoundry API. If not set, mutual TLS is not used */
      cf_api_mutual_tls_key?: string;
      /** @description The PEM-format CA certificates that are acceptable for the CF API to present. */
      cf_api_trusted_certificates?: string[];
      /** @description The client id for CF’s API. */
      cf_client_id?: string;
      /** @description The client secret for CF’s API. */
      cf_client_secret?: string;
      /** @description The password for CF’s API. */
      cf_password?: string;
      /** @description The username for CF’s API. */
      cf_username?: string;
      /** @description The PEM-format CA certificates that are required to have issued the instance certificates presented for logging in. */
      identity_ca_certificates?: string[];
      /**
       * @description Duration in seconds for the maximum acceptable length in the future a "signing_time" can be. Useful for clock drift. Set low to reduce the opportunity for replay attacks.
       * @default 60
       */
      login_max_seconds_not_after: number;
      /**
       * Format: duration
       * @description Duration in seconds for the maximum acceptable age of a "signing_time". Useful for clock drift. Set low to reduce the opportunity for replay attacks.
       * @default 300
       */
      login_max_seconds_not_before: string;
      /**
       * @deprecated
       * @description Deprecated. Please use "cf_api_addr".
       */
      pcf_api_addr?: string;
      /**
       * @deprecated
       * @description Deprecated. Please use "cf_api_trusted_certificates".
       */
      pcf_api_trusted_certificates?: string[];
      /**
       * @deprecated
       * @description Deprecated. Please use "cf_password".
       */
      pcf_password?: string;
      /**
       * @deprecated
       * @description Deprecated. Please use "cf_username".
       */
      pcf_username?: string;
    };
    CloudFoundryLoginRequest: {
      /** @description The full body of the file available at the CF_INSTANCE_CERT path on the CF instance. */
      cf_instance_cert: string;
      /** @description The name of the role to authenticate against. */
      role: string;
      /** @description The signature generated by the client certificate's private key. */
      signature: string;
      /** @description The date and time used to construct the signature. */
      signing_time: string;
    };
    CloudFoundryWriteRoleRequest: {
      /** @description Require that the client certificate presented has at least one of these app IDs. */
      bound_application_ids?: string[];
      /**
       * @deprecated
       * @description Use "token_bound_cidrs" instead. If this and "token_bound_cidrs" are both specified, only "token_bound_cidrs" will be used.
       */
      bound_cidrs?: string[];
      /** @description Require that the client certificate presented has at least one of these instance IDs. */
      bound_instance_ids?: string[];
      /** @description Require that the client certificate presented has at least one of these org IDs. */
      bound_organization_ids?: string[];
      /** @description Require that the client certificate presented has at least one of these space IDs. */
      bound_space_ids?: string[];
      /**
       * @description If set to true, disables the default behavior that logging in must be performed from an acceptable IP address described by the certificate presented.
       * @default false
       */
      disable_ip_matching: boolean;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_max_ttl" instead. If this and "token_max_ttl" are both specified, only "token_max_ttl" will be used.
       */
      max_ttl?: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_period" instead. If this and "token_period" are both specified, only "token_period" will be used.
       */
      period?: string;
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_ttl" instead. If this and "token_ttl" are both specified, only "token_ttl" will be used.
       */
      ttl?: string;
    };
    CollectHostInformationResponse: {
      cpu?: Record<string, never>[];
      cpu_times?: Record<string, never>[];
      disk?: Record<string, never>[];
      /** Format: map */
      host?: Record<string, never>;
      /** Format: map */
      memory?: Record<string, never>;
      /** Format: date-time */
      timestamp?: string;
    };
    ConsulConfigureAccessRequest: {
      /** @description Consul server address */
      address?: string;
      /** @description CA certificate to use when verifying Consul server certificate, must be x509 PEM encoded. */
      ca_cert?: string;
      /** @description Client certificate used for Consul's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_key. */
      client_cert?: string;
      /** @description Client key used for Consul's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_cert. */
      client_key?: string;
      /**
       * @description URI scheme for the Consul address
       * @default http
       */
      scheme: string;
      /** @description Token for API calls */
      token?: string;
    };
    ConsulWriteRoleRequest: {
      /** @description Indicates which namespace that the token will be created within. Defaults to 'default'. Available in Consul 1.7 and above. */
      consul_namespace?: string;
      /** @description List of policies to attach to the token. Either "consul_policies" or "consul_roles" are required for Consul 1.5 and above, or just "consul_policies" if using Consul 1.4. */
      consul_policies?: string[];
      /** @description List of Consul roles to attach to the token. Either "policies" or "consul_roles" are required for Consul 1.5 and above. */
      consul_roles?: string[];
      /**
       * Format: duration
       * @deprecated
       * @description Use "ttl" instead.
       */
      lease?: string;
      /** @description Indicates that the token should not be replicated globally and instead be local to the current datacenter. Available in Consul 1.4 and above. */
      local?: boolean;
      /**
       * Format: duration
       * @description Max TTL for the Consul token created from the role.
       */
      max_ttl?: string;
      /** @description List of Node Identities to attach to the token. Available in Consul 1.8.1 or above. */
      node_identities?: string[];
      /** @description Indicates which admin partition that the token will be created within. Defaults to 'default'. Available in Consul 1.11 and above. */
      partition?: string;
      /**
       * @deprecated
       * @description Use "consul_policies" instead.
       */
      policies?: string[];
      /**
       * @deprecated
       * @description Policy document, base64 encoded. Required for 'client' tokens. Required for Consul pre-1.4.
       */
      policy?: string;
      /** @description List of Service Identities to attach to the token, separated by semicolons. Available in Consul 1.5 or above. */
      service_identities?: string[];
      /**
       * @deprecated
       * @description Which type of token to create: 'client' or 'management'. If a 'management' token, the "policy", "policies", and "consul_roles" parameters are not required. Defaults to 'client'.
       * @default client
       */
      token_type: string;
      /**
       * Format: duration
       * @description TTL for the Consul token created from the role.
       */
      ttl?: string;
    };
    CorsConfigureRequest: {
      /** @description A comma-separated string or array of strings indicating headers that are allowed on cross-origin requests. */
      allowed_headers?: string[];
      /** @description A comma-separated string or array of strings indicating origins that may make cross-origin requests. */
      allowed_origins?: string[];
      /** @description Enables or disables CORS headers on requests. */
      enable?: boolean;
    };
    CorsReadConfigurationResponse: {
      allowed_headers?: string[];
      allowed_origins?: string[];
      enabled?: boolean;
    };
    CreateCustomMessageRequest: {
      /** @default true */
      authenticated: boolean;
      /** Format: date-time */
      end_time?: string;
      /** Format: map */
      link?: Record<string, never>;
      message: string;
      /** Format: map */
      options?: Record<string, never>;
      /** Format: date-time */
      start_time: string;
      title: string;
      /** @default banner */
      type: string;
    };
    DatabaseConfigureConnectionRequest: {
      /** @description Comma separated string or array of the role names allowed to get creds from this database connection. If empty no roles are allowed. If "*" all roles are allowed. */
      allowed_roles?: string[];
      /** @description Password policy to use when generating passwords. */
      password_policy?: string;
      /** @description The name of a builtin or previously registered plugin known to vault. This endpoint will create an instance of that plugin type. */
      plugin_name?: string;
      /** @description The version of the plugin to use. */
      plugin_version?: string;
      /** @description Specifies the database statements to be executed to rotate the root user's credentials. See the plugin's API page for more information on support and formatting for this parameter. */
      root_rotation_statements?: string[];
      /**
       * @description If true, the connection details are verified by actually connecting to the database. Defaults to true.
       * @default true
       */
      verify_connection: boolean;
    };
    DatabaseWriteRoleRequest: {
      /** @description Specifies the database statements executed to create and configure a user. See the plugin's API page for more information on support and formatting for this parameter. */
      creation_statements?: string[];
      /**
       * Format: kvpairs
       * @description The configuration for the given credential_type.
       */
      credential_config?: Record<string, never>;
      /**
       * @description The type of credential to manage. Options include: 'password', 'rsa_private_key'. Defaults to 'password'.
       * @default password
       */
      credential_type: string;
      /** @description Name of the database this role acts on. */
      db_name?: string;
      /**
       * Format: duration
       * @description Default ttl for role.
       */
      default_ttl?: string;
      /**
       * Format: duration
       * @description Maximum time a credential is valid for
       */
      max_ttl?: string;
      /** @description Specifies the database statements to be executed to renew a user. Not every plugin type will support this functionality. See the plugin's API page for more information on support and formatting for this parameter. */
      renew_statements?: string[];
      /** @description Specifies the database statements to be executed to revoke a user. See the plugin's API page for more information on support and formatting for this parameter. */
      revocation_statements?: string[];
      /** @description Specifies the database statements to be executed rollback a create operation in the event of an error. Not every plugin type will support this functionality. See the plugin's API page for more information on support and formatting for this parameter. */
      rollback_statements?: string[];
    };
    DatabaseWriteStaticRoleRequest: {
      /**
       * Format: kvpairs
       * @description The configuration for the given credential_type.
       */
      credential_config?: Record<string, never>;
      /**
       * @description The type of credential to manage. Options include: 'password', 'rsa_private_key'. Defaults to 'password'.
       * @default password
       */
      credential_type: string;
      /** @description Name of the database this role acts on. */
      db_name?: string;
      /**
       * Format: duration
       * @description Period for automatic credential rotation of the given username. Not valid unless used with "username". Mutually exclusive with "rotation_schedule."
       */
      rotation_period?: string;
      /** @description Schedule for automatic credential rotation of the given username. Mutually exclusive with "rotation_period." */
      rotation_schedule?: string;
      /** @description Specifies the database statements to be executed to rotate the accounts credentials. Not every plugin type will support this functionality. See the plugin's API page for more information on support and formatting for this parameter. */
      rotation_statements?: string[];
      /**
       * Format: duration
       * @description The window of time in which rotations are allowed to occur starting from a given "rotation_schedule". Requires "rotation_schedule" to be specified
       */
      rotation_window?: string;
      /** @description Name of the static user account for Vault to manage. Requires "rotation_period" to be specified */
      username?: string;
    };
    DecodeTokenRequest: {
      /** @description Specifies the encoded token (result from generate-root). */
      encoded_token?: string;
      /** @description Specifies the otp code for decode. */
      otp?: string;
    };
    EncryptionKeyConfigureRotationRequest: {
      /** @description Whether automatic rotation is enabled. */
      enabled?: boolean;
      /**
       * Format: duration
       * @description How long after installation of an active key term that the key will be automatically rotated.
       */
      interval?: string;
      /**
       * Format: int64
       * @description The number of encryption operations performed before the barrier key is automatically rotated.
       */
      max_operations?: number;
    };
    EncryptionKeyReadRotationConfigurationResponse: {
      enabled?: boolean;
      /** Format: duration */
      interval?: string;
      /** Format: int64 */
      max_operations?: number;
    };
    EntityBatchDeleteRequest: {
      /** @description Entity IDs to delete */
      entity_ids?: string[];
    };
    EntityCreateAliasRequest: {
      /** @description Entity ID to which this alias belongs */
      canonical_id?: string;
      /**
       * Format: kvpairs
       * @description User provided key-value pairs
       */
      custom_metadata?: Record<string, never>;
      /** @description Entity ID to which this alias belongs. This field is deprecated, use canonical_id. */
      entity_id?: string;
      /** @description ID of the entity alias. If set, updates the corresponding entity alias. */
      id?: string;
      /** @description Mount accessor to which this alias belongs to; unused for a modify */
      mount_accessor?: string;
      /** @description Name of the alias; unused for a modify */
      name?: string;
    };
    EntityCreateRequest: {
      /** @description If set true, tokens tied to this identity will not be able to be used (but will not be revoked). */
      disabled?: boolean;
      /** @description ID of the entity. If set, updates the corresponding existing entity. */
      id?: string;
      /**
       * Format: kvpairs
       * @description Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2
       */
      metadata?: Record<string, never>;
      /** @description Name of the entity */
      name?: string;
      /** @description Policies to be tied to the entity. */
      policies?: string[];
    };
    EntityLookUpRequest: {
      /** @description ID of the alias. */
      alias_id?: string;
      /** @description Accessor of the mount to which the alias belongs to. This should be supplied in conjunction with 'alias_name'. */
      alias_mount_accessor?: string;
      /** @description Name of the alias. This should be supplied in conjunction with 'alias_mount_accessor'. */
      alias_name?: string;
      /** @description ID of the entity. */
      id?: string;
      /** @description Name of the entity. */
      name?: string;
    };
    EntityMergeRequest: {
      /** @description Alias IDs to keep in case of conflicting aliases. Ignored if no conflicting aliases found */
      conflicting_alias_ids_to_keep?: string[];
      /** @description Setting this will follow the 'mine' strategy for merging MFA secrets. If there are secrets of the same type both in entities that are merged from and in entity into which all others are getting merged, secrets in the destination will be unaltered. If not set, this API will throw an error containing all the conflicts. */
      force?: boolean;
      /** @description Entity IDs which need to get merged */
      from_entity_ids?: string[];
      /** @description Entity ID into which all the other entities need to get merged */
      to_entity_id?: string;
    };
    EntityUpdateAliasByIdRequest: {
      /** @description Entity ID to which this alias should be tied to */
      canonical_id?: string;
      /**
       * Format: kvpairs
       * @description User provided key-value pairs
       */
      custom_metadata?: Record<string, never>;
      /** @description Entity ID to which this alias belongs to. This field is deprecated, use canonical_id. */
      entity_id?: string;
      /** @description (Unused) */
      mount_accessor?: string;
      /** @description (Unused) */
      name?: string;
    };
    EntityUpdateByIdRequest: {
      /** @description If set true, tokens tied to this identity will not be able to be used (but will not be revoked). */
      disabled?: boolean;
      /**
       * Format: kvpairs
       * @description Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2
       */
      metadata?: Record<string, never>;
      /** @description Name of the entity */
      name?: string;
      /** @description Policies to be tied to the entity. */
      policies?: string[];
    };
    EntityUpdateByNameRequest: {
      /** @description If set true, tokens tied to this identity will not be able to be used (but will not be revoked). */
      disabled?: boolean;
      /** @description ID of the entity. If set, updates the corresponding existing entity. */
      id?: string;
      /**
       * Format: kvpairs
       * @description Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2
       */
      metadata?: Record<string, never>;
      /** @description Policies to be tied to the entity. */
      policies?: string[];
    };
    GenerateHashRequest: {
      /**
       * @description Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 Defaults to "sha2-256".
       * @default sha2-256
       */
      algorithm: string;
      /**
       * @description Encoding format to use. Can be "hex" or "base64". Defaults to "hex".
       * @default hex
       */
      format: string;
      /** @description The base64-encoded input data */
      input?: string;
    };
    GenerateHashResponse: {
      sum?: string;
    };
    GenerateHashWithAlgorithmRequest: {
      /**
       * @description Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 Defaults to "sha2-256".
       * @default sha2-256
       */
      algorithm: string;
      /**
       * @description Encoding format to use. Can be "hex" or "base64". Defaults to "hex".
       * @default hex
       */
      format: string;
      /** @description The base64-encoded input data */
      input?: string;
    };
    GenerateHashWithAlgorithmResponse: {
      sum?: string;
    };
    GenerateRandomRequest: {
      /**
       * @description The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
       * @default 32
       */
      bytes: number;
      /**
       * @description Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
       * @default base64
       */
      format: string;
    };
    GenerateRandomResponse: {
      random_bytes?: string;
    };
    GenerateRandomWithBytesRequest: {
      /**
       * @description The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
       * @default 32
       */
      bytes: number;
      /**
       * @description Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
       * @default base64
       */
      format: string;
    };
    GenerateRandomWithBytesResponse: {
      random_bytes?: string;
    };
    GenerateRandomWithSourceAndBytesRequest: {
      /**
       * @description The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
       * @default 32
       */
      bytes: number;
      /**
       * @description Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
       * @default base64
       */
      format: string;
    };
    GenerateRandomWithSourceAndBytesResponse: {
      random_bytes?: string;
    };
    GenerateRandomWithSourceRequest: {
      /**
       * @description The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
       * @default 32
       */
      bytes: number;
      /**
       * @description Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
       * @default base64
       */
      format: string;
    };
    GenerateRandomWithSourceResponse: {
      random_bytes?: string;
    };
    GithubConfigureRequest: {
      /** @description The API endpoint to use. Useful if you are running GitHub Enterprise or an API-compatible authentication server. */
      base_url?: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_max_ttl" instead. If this and "token_max_ttl" are both specified, only "token_max_ttl" will be used.
       */
      max_ttl?: string;
      /** @description The organization users must be part of */
      organization: string;
      /**
       * Format: int64
       * @description The ID of the organization users must be part of
       */
      organization_id?: number;
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies. This will apply to all tokens generated by this auth method, in addition to any policies configured for specific users/groups. */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_ttl" instead. If this and "token_ttl" are both specified, only "token_ttl" will be used.
       */
      ttl?: string;
    };
    GithubLoginRequest: {
      /** @description GitHub personal API token */
      token?: string;
    };
    GithubWriteTeamMappingRequest: {
      /** @description Value for teams mapping */
      value?: string;
    };
    GithubWriteUserMappingRequest: {
      /** @description Value for users mapping */
      value?: string;
    };
    GoogleCloudConfigureAuthRequest: {
      /** @description Google credentials JSON that Vault will use to verify users against GCP APIs. If not specified, will use application default credentials */
      credentials?: string;
      /**
       * Format: kvpairs
       * @description Specifies overrides for various Google API Service Endpoints used in requests.
       */
      custom_endpoint?: Record<string, never>;
      /**
       * @description Indicates what value to use when generating an alias for GCE authentications.
       * @default role_id
       */
      gce_alias: string;
      /**
       * @description The metadata to include on the aliases and audit logs generated by this plugin. When set to 'default', includes: instance_creation_timestamp, instance_id, instance_name, project_id, project_number, role, service_account_id, service_account_email, zone. Not editing this field means the 'default' fields are included. Explicitly setting this field to empty overrides the 'default' and means no metadata will be included. If not using 'default', explicit fields must be sent like: 'field1,field2'.
       * @default [
       *       "default"
       *     ]
       */
      gce_metadata: string[];
      /**
       * @deprecated
       * @description Deprecated. This field does nothing and be removed in a future release
       */
      google_certs_endpoint?: string;
      /**
       * @description Indicates what value to use when generating an alias for IAM authentications.
       * @default role_id
       */
      iam_alias: string;
      /**
       * @description The metadata to include on the aliases and audit logs generated by this plugin. When set to 'default', includes: project_id, role, service_account_id, service_account_email. Not editing this field means the 'default' fields are included. Explicitly setting this field to empty overrides the 'default' and means no metadata will be included. If not using 'default', explicit fields must be sent like: 'field1,field2'.
       * @default [
       *       "default"
       *     ]
       */
      iam_metadata: string[];
    };
    GoogleCloudConfigureRequest: {
      /** @description GCP IAM service account credentials JSON with permissions to create new service accounts and set IAM policies */
      credentials?: string;
      /**
       * Format: duration
       * @description Maximum time a service account key is valid for. If <= 0, will use system default.
       */
      max_ttl?: string;
      /**
       * Format: duration
       * @description Default lease for generated keys. If <= 0, will use system default.
       */
      ttl?: string;
    };
    GoogleCloudEditLabelsForRoleRequest: {
      /** @description BoundLabels to add (in $key:$value) */
      add?: string[];
      /** @description Label key values to remove */
      remove?: string[];
    };
    GoogleCloudEditServiceAccountsForRoleRequest: {
      /** @description Service-account emails or IDs to add. */
      add?: string[];
      /** @description Service-account emails or IDs to remove. */
      remove?: string[];
    };
    GoogleCloudGenerateRolesetKey3Request: {
      /**
       * @description Private key algorithm for service account key - defaults to KEY_ALG_RSA_2048"
       * @default KEY_ALG_RSA_2048
       */
      key_algorithm: string;
      /**
       * @description Private key type for service account key - defaults to TYPE_GOOGLE_CREDENTIALS_FILE"
       * @default TYPE_GOOGLE_CREDENTIALS_FILE
       */
      key_type: string;
      /**
       * Format: duration
       * @description Lifetime of the service account key
       */
      ttl?: string;
    };
    GoogleCloudGenerateRolesetKeyRequest: {
      /**
       * @description Private key algorithm for service account key - defaults to KEY_ALG_RSA_2048"
       * @default KEY_ALG_RSA_2048
       */
      key_algorithm: string;
      /**
       * @description Private key type for service account key - defaults to TYPE_GOOGLE_CREDENTIALS_FILE"
       * @default TYPE_GOOGLE_CREDENTIALS_FILE
       */
      key_type: string;
      /**
       * Format: duration
       * @description Lifetime of the service account key
       */
      ttl?: string;
    };
    GoogleCloudGenerateStaticAccountKeyRequest: {
      /**
       * @description Private key algorithm for service account key. Defaults to KEY_ALG_RSA_2048."
       * @default KEY_ALG_RSA_2048
       */
      key_algorithm: string;
      /**
       * @description Private key type for service account key. Defaults to TYPE_GOOGLE_CREDENTIALS_FILE."
       * @default TYPE_GOOGLE_CREDENTIALS_FILE
       */
      key_type: string;
      /**
       * Format: duration
       * @description Lifetime of the service account key
       */
      ttl?: string;
    };
    GoogleCloudKmsConfigureKeyRequest: {
      /** @description Maximum allowed crypto key version. If set to a positive value, key versions greater than the given value are not permitted to be used. If set to 0 or a negative value, there is no maximum key version. */
      max_version?: number;
      /** @description Minimum allowed crypto key version. If set to a positive value, key versions less than the given value are not permitted to be used. If set to 0 or a negative value, there is no minimum key version. This value only affects encryption/re-encryption, not decryption. To restrict old values from being decrypted, increase this value and then perform a trim operation. */
      min_version?: number;
    };
    GoogleCloudKmsConfigureRequest: {
      /** @description The credentials to use for authenticating to Google Cloud. Leave this blank to use the Default Application Credentials or instance metadata authentication. */
      credentials?: string;
      /** @description The list of full-URL scopes to request when authenticating. By default, this requests https://www.googleapis.com/auth/cloudkms. */
      scopes?: string[];
    };
    GoogleCloudKmsDecryptRequest: {
      /** @description Optional data that was specified during encryption of this payload. */
      additional_authenticated_data?: string;
      /** @description Ciphertext to decrypt as previously returned from an encrypt operation. This must be base64-encoded ciphertext as previously returned from an encrypt operation. */
      ciphertext?: string;
      /** @description Integer version of the crypto key version to use for decryption. This is required for asymmetric keys. For symmetric keys, Cloud KMS will choose the correct version automatically. */
      key_version?: number;
    };
    GoogleCloudKmsEncryptRequest: {
      /** @description Optional base64-encoded data that, if specified, must also be provided to decrypt this payload. */
      additional_authenticated_data?: string;
      /** @description Integer version of the crypto key version to use for encryption. If unspecified, this defaults to the latest active crypto key version. */
      key_version?: number;
      /** @description Plaintext value to be encrypted. This can be a string or binary, but the size is limited. See the Google Cloud KMS documentation for information on size limitations by key types. */
      plaintext?: string;
    };
    GoogleCloudKmsReencryptRequest: {
      /** @description Optional data that, if specified, must also be provided during decryption. */
      additional_authenticated_data?: string;
      /** @description Ciphertext to be re-encrypted to the latest key version. This must be ciphertext that Vault previously generated for this named key. */
      ciphertext?: string;
      /** @description Integer version of the crypto key version to use for the new encryption. If unspecified, this defaults to the latest active crypto key version. */
      key_version?: number;
    };
    GoogleCloudKmsRegisterKeyRequest: {
      /** @description Full resource ID of the crypto key including the project, location, key ring, and crypto key like "projects/%s/locations/%s/keyRings/%s/cryptoKeys/%s". This crypto key must already exist in Google Cloud KMS unless verify is set to "false". */
      crypto_key?: string;
      /**
       * @description Verify that the given Google Cloud KMS crypto key exists and is accessible before creating the storage entry in Vault. Set this to "false" if the key will not exist at creation time.
       * @default true
       */
      verify: boolean;
    };
    GoogleCloudKmsSignRequest: {
      /** @description Digest to sign. This digest must use the same SHA algorithm as the underlying Cloud KMS key. The digest must be the base64-encoded binary value. This field is required. */
      digest?: string;
      /** @description Integer version of the crypto key version to use for signing. This field is required. */
      key_version?: number;
    };
    GoogleCloudKmsVerifyRequest: {
      /** @description Digest to verify. This digest must use the same SHA algorithm as the underlying Cloud KMS key. The digest must be the base64-encoded binary value. This field is required. */
      digest?: string;
      /** @description Integer version of the crypto key version to use for verification. This field is required. */
      key_version?: number;
      /** @description Base64-encoded signature to use for verification. This field is required. */
      signature?: string;
    };
    GoogleCloudKmsWriteKeyRequest: {
      /** @description Algorithm to use for encryption, decryption, or signing. The value depends on the key purpose. The value cannot be changed after creation. For a key purpose of "encrypt_decrypt", the valid values are: - symmetric_encryption (default) For a key purpose of "asymmetric_sign", valid values are: - rsa_sign_pss_2048_sha256 - rsa_sign_pss_3072_sha256 - rsa_sign_pss_4096_sha256 - rsa_sign_pkcs1_2048_sha256 - rsa_sign_pkcs1_3072_sha256 - rsa_sign_pkcs1_4096_sha256 - ec_sign_p256_sha256 - ec_sign_p384_sha384 For a key purpose of "asymmetric_decrypt", valid values are: - rsa_decrypt_oaep_2048_sha256 - rsa_decrypt_oaep_3072_sha256 - rsa_decrypt_oaep_4096_sha256 */
      algorithm?: string;
      /** @description Name of the crypto key to use. If the given crypto key does not exist, Vault will try to create it. This defaults to the name of the key given to Vault as the parameter if unspecified. */
      crypto_key?: string;
      /** @description Full Google Cloud resource ID of the key ring with the project and location (e.g. projects/my-project/locations/global/keyRings/my-keyring). If the given key ring does not exist, Vault will try to create it during a create operation. */
      key_ring?: string;
      /**
       * Format: kvpairs
       * @description Arbitrary key=value label to apply to the crypto key. To specify multiple labels, specify this argument multiple times (e.g. labels="a=b" labels="c=d").
       */
      labels?: Record<string, never>;
      /** @description Level of protection to use for the key management. Valid values are "software" and "hsm". The default value is "software". The value cannot be changed after creation. */
      protection_level?: string;
      /** @description Purpose of the key. Valid options are "asymmetric_decrypt", "asymmetric_sign", and "encrypt_decrypt". The default value is "encrypt_decrypt". The value cannot be changed after creation. */
      purpose?: string;
      /**
       * Format: duration
       * @description Amount of time between crypto key version rotations. This is specified as a time duration value like 72h (72 hours). The smallest possible value is 24h. This value only applies to keys with a purpose of "encrypt_decrypt".
       */
      rotation_period?: string;
    };
    GoogleCloudLoginRequest: {
      /** @description A signed JWT. This is either a self-signed service account JWT ('iam' roles only) or a GCE identity metadata token ('iam', 'gce' roles). */
      jwt?: string;
      /** @description Name of the role against which the login is being attempted. Required. */
      role?: string;
    };
    GoogleCloudWriteImpersonatedAccountRequest: {
      /** @description Required. Email of the GCP service account to manage. Cannot be updated. */
      service_account_email?: string;
      /** @description List of OAuth scopes to assign to access tokens generated under this account. */
      token_scopes?: string[];
      /**
       * Format: duration
       * @description Lifetime of the token for the impersonated account.
       */
      ttl?: string;
    };
    GoogleCloudWriteRoleRequest: {
      /**
       * @description If true, will add group aliases to auth tokens generated under this role. This will add the full list of ancestors (projects, folders, organizations) for the given entity's project. Requires IAM permission `resourcemanager.projects.get` on this project.
       * @default false
       */
      add_group_aliases: boolean;
      /**
       * @description 'iam' roles only. If false, Vault will not not allow GCE instances to login in against this role
       * @default true
       */
      allow_gce_inference: boolean;
      /** @description Deprecated: use "bound_instance_groups" instead. */
      bound_instance_group?: string;
      /** @description Comma-separated list of permitted instance groups to which the GCE instance must belong. This option only applies to "gce" roles. */
      bound_instance_groups?: string[];
      /** @description Comma-separated list of GCP labels formatted as"key:value" strings that must be present on the GCE instance in order to authenticate. This option only applies to "gce" roles. */
      bound_labels?: string[];
      /** @description GCP Projects that authenticating entities must belong to. */
      bound_projects?: string[];
      /** @description Deprecated: use "bound_regions" instead. */
      bound_region?: string;
      /** @description Comma-separated list of permitted regions to which the GCE instance must belong. If a group is provided, it is assumed to be a regional group. If "zone" is provided, this option is ignored. This can be a self-link or region name. This option only applies to "gce" roles. */
      bound_regions?: string[];
      /** @description Can be set for both 'iam' and 'gce' roles (required for 'iam'). A comma-seperated list of authorized service accounts. If the single value "*" is given, this is assumed to be all service accounts under the role's project. If this is set on a GCE role, the inferred service account from the instance metadata token will be used. */
      bound_service_accounts?: string[];
      /** @description Deprecated: use "bound_zones" instead. */
      bound_zone?: string;
      /** @description Comma-separated list of permitted zones to which the GCE instance must belong. If a group is provided, it is assumed to be a zonal group. This can be a self-link or zone name. This option only applies to "gce" roles. */
      bound_zones?: string[];
      /**
       * Format: duration
       * @description Currently enabled for 'iam' only. Duration in seconds from time of validation that a JWT must expire within.
       * @default 900
       */
      max_jwt_exp: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_max_ttl" instead. If this and "token_max_ttl" are both specified, only "token_max_ttl" will be used.
       */
      max_ttl?: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_period" instead. If this and "token_period" are both specified, only "token_period" will be used.
       */
      period?: string;
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /** @description Deprecated: use "bound_projects" instead */
      project_id?: string;
      /** @description Deprecated: use "bound_service_accounts" instead. */
      service_accounts?: string[];
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_ttl" instead. If this and "token_ttl" are both specified, only "token_ttl" will be used.
       */
      ttl?: string;
      /** @description Type of the role. Currently supported: iam, gce */
      type?: string;
    };
    GoogleCloudWriteRolesetRequest: {
      /** @description Bindings configuration string. */
      bindings?: string;
      /** @description Name of the GCP project that this roleset's service account will belong to. */
      project?: string;
      /**
       * @description Type of secret generated for this role set. Defaults to 'access_token'
       * @default access_token
       */
      secret_type: string;
      /** @description List of OAuth scopes to assign to credentials generated under this role set */
      token_scopes?: string[];
    };
    GoogleCloudWriteStaticAccountRequest: {
      /** @description Bindings configuration string. */
      bindings?: string;
      /**
       * @description Type of secret generated for this account. Cannot be updated. Defaults to "access_token"
       * @default access_token
       */
      secret_type: string;
      /** @description Required. Email of the GCP service account to manage. Cannot be updated. */
      service_account_email?: string;
      /** @description List of OAuth scopes to assign to access tokens generated under this account. Ignored if "secret_type" is not ""access_token"" */
      token_scopes?: string[];
    };
    GroupCreateAliasRequest: {
      /** @description ID of the group to which this is an alias. */
      canonical_id?: string;
      /** @description ID of the group alias. */
      id?: string;
      /** @description Mount accessor to which this alias belongs to. */
      mount_accessor?: string;
      /** @description Alias of the group. */
      name?: string;
    };
    GroupCreateRequest: {
      /** @description ID of the group. If set, updates the corresponding existing group. */
      id?: string;
      /** @description Entity IDs to be assigned as group members. */
      member_entity_ids?: string[];
      /** @description Group IDs to be assigned as group members. */
      member_group_ids?: string[];
      /**
       * Format: kvpairs
       * @description Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2
       */
      metadata?: Record<string, never>;
      /** @description Name of the group. */
      name?: string;
      /** @description Policies to be tied to the group. */
      policies?: string[];
      /** @description Type of the group, 'internal' or 'external'. Defaults to 'internal' */
      type?: string;
    };
    GroupLookUpRequest: {
      /** @description ID of the alias. */
      alias_id?: string;
      /** @description Accessor of the mount to which the alias belongs to. This should be supplied in conjunction with 'alias_name'. */
      alias_mount_accessor?: string;
      /** @description Name of the alias. This should be supplied in conjunction with 'alias_mount_accessor'. */
      alias_name?: string;
      /** @description ID of the group. */
      id?: string;
      /** @description Name of the group. */
      name?: string;
    };
    GroupUpdateAliasByIdRequest: {
      /** @description ID of the group to which this is an alias. */
      canonical_id?: string;
      /** @description Mount accessor to which this alias belongs to. */
      mount_accessor?: string;
      /** @description Alias of the group. */
      name?: string;
    };
    GroupUpdateByIdRequest: {
      /** @description Entity IDs to be assigned as group members. */
      member_entity_ids?: string[];
      /** @description Group IDs to be assigned as group members. */
      member_group_ids?: string[];
      /**
       * Format: kvpairs
       * @description Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2
       */
      metadata?: Record<string, never>;
      /** @description Name of the group. */
      name?: string;
      /** @description Policies to be tied to the group. */
      policies?: string[];
      /** @description Type of the group, 'internal' or 'external'. Defaults to 'internal' */
      type?: string;
    };
    GroupUpdateByNameRequest: {
      /** @description ID of the group. If set, updates the corresponding existing group. */
      id?: string;
      /** @description Entity IDs to be assigned as group members. */
      member_entity_ids?: string[];
      /** @description Group IDs to be assigned as group members. */
      member_group_ids?: string[];
      /**
       * Format: kvpairs
       * @description Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2
       */
      metadata?: Record<string, never>;
      /** @description Policies to be tied to the group. */
      policies?: string[];
      /** @description Type of the group, 'internal' or 'external'. Defaults to 'internal' */
      type?: string;
    };
    HaStatusResponse: {
      nodes?: Record<string, never>[];
    };
    InitializeRequest: {
      /** @description Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as `secret_shares`. */
      pgp_keys?: string[];
      /** @description Specifies an array of PGP public keys used to encrypt the output recovery keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as `recovery_shares`. */
      recovery_pgp_keys?: string[];
      /** @description Specifies the number of shares to split the recovery key into. */
      recovery_shares?: number;
      /** @description Specifies the number of shares required to reconstruct the recovery key. This must be less than or equal to `recovery_shares`. */
      recovery_threshold?: number;
      /** @description Specifies a PGP public key used to encrypt the initial root token. The key must be base64-encoded from its original binary representation. */
      root_token_pgp_key?: string;
      /** @description Specifies the number of shares to split the unseal key into. */
      secret_shares?: number;
      /** @description Specifies the number of shares required to reconstruct the unseal key. This must be less than or equal secret_shares. If using Vault HSM with auto-unsealing, this value must be the same as `secret_shares`. */
      secret_threshold?: number;
      /** @description Specifies the number of shares that should be encrypted by the HSM and stored for auto-unsealing. Currently must be the same as `secret_shares`. */
      stored_shares?: number;
    };
    InternalClientActivityConfigureRequest: {
      /**
       * @description Number of months to report if no start date specified.
       * @default 12
       */
      default_report_months: number;
      /**
       * @description Enable or disable collection of client count: enable, disable, or default.
       * @default default
       */
      enabled: string;
      /**
       * @description Number of months of client data to retain. Setting to 0 will clear all existing data.
       * @default 24
       */
      retention_months: number;
    };
    InternalCountEntitiesResponse: {
      /** Format: map */
      counters?: Record<string, never>;
    };
    InternalCountTokensResponse: {
      /** Format: map */
      counters?: Record<string, never>;
    };
    InternalGenerateOpenApiDocumentWithParametersRequest: {
      /** @description Context string appended to every operationId */
      context?: string;
      /**
       * @description Use generic mount paths
       * @default false
       */
      generic_mount_paths: boolean;
    };
    InternalUiListEnabledFeatureFlagsResponse: {
      feature_flags?: string[];
    };
    InternalUiListEnabledVisibleMountsResponse: {
      /**
       * Format: map
       * @description auth mounts
       */
      auth?: Record<string, never>;
      /**
       * Format: map
       * @description secret mounts
       */
      secret?: Record<string, never>;
    };
    InternalUiListNamespacesResponse: {
      /** @description field is only returned if there are one or more namespaces */
      keys?: string[];
    };
    InternalUiReadAuthenticatedActiveCustomMessagesResponse: {
      /** Format: map */
      key_info?: Record<string, never>;
      keys?: string[];
    };
    InternalUiReadMountInformationResponse: {
      accessor?: string;
      /** Format: map */
      config?: Record<string, never>;
      description?: string;
      external_entropy_access?: boolean;
      local?: boolean;
      /** Format: map */
      options?: Record<string, never>;
      path?: string;
      plugin_version?: string;
      running_plugin_version?: string;
      running_sha256?: string;
      seal_wrap?: boolean;
      type?: string;
      uuid?: string;
    };
    InternalUiReadResultantAclResponse: {
      chroot_namespace?: string;
      /** Format: map */
      exact_paths?: Record<string, never>;
      /** Format: map */
      glob_paths?: Record<string, never>;
      root?: boolean;
    };
    InternalUiReadUnauthenticatedActiveCustomMessagesResponse: {
      /** Format: map */
      key_info?: Record<string, never>;
      keys?: string[];
    };
    InternalUiReadVersionResponse: {
      version?: string;
    };
    JwtConfigureRequest: {
      /** @description The value against which to match the 'iss' claim in a JWT. Optional. */
      bound_issuer?: string;
      /**
       * Format: lowercase
       * @description The default role to use if none is provided during login. If not set, a role is required during login.
       */
      default_role?: string;
      /** @description The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used. */
      jwks_ca_pem?: string;
      /** @description Set of JWKS Url and CA certificate (or chain of certificates) pairs. CA certificates must be in PEM format. Cannot be used with "jwks_url" or "jwks_ca_pem". */
      jwks_pairs?: Record<string, never>[];
      /** @description JWKS URL to use to authenticate signatures. Cannot be used with "oidc_discovery_url" or "jwt_validation_pubkeys". */
      jwks_url?: string;
      /** @description A list of supported signing algorithms. Defaults to RS256. */
      jwt_supported_algs?: string[];
      /** @description A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used with "jwks_url" or "oidc_discovery_url". */
      jwt_validation_pubkeys?: string[];
      /** @description Pass namespace in the OIDC state parameter instead of as a separate query parameter. With this setting, the allowed redirect URL(s) in Vault and on the provider side should not contain a namespace query parameter. This means only one redirect URL entry needs to be maintained on the provider side for all vault namespaces that will be authenticating against it. Defaults to true for new configs. */
      namespace_in_state?: boolean;
      /** @description The OAuth Client ID configured with your OIDC provider. */
      oidc_client_id?: string;
      /** @description The OAuth Client Secret configured with your OIDC provider. */
      oidc_client_secret?: string;
      /** @description The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used. */
      oidc_discovery_ca_pem?: string;
      /** @description OIDC Discovery URL, without any .well-known component (base path). Cannot be used with "jwks_url" or "jwt_validation_pubkeys". */
      oidc_discovery_url?: string;
      /** @description The response mode to be used in the OAuth2 request. Allowed values are 'query' and 'form_post'. */
      oidc_response_mode?: string;
      /** @description The response types to request. Allowed values are 'code' and 'id_token'. Defaults to 'code'. */
      oidc_response_types?: string[];
      /**
       * Format: map
       * @description Provider-specific configuration. Optional.
       */
      provider_config?: Record<string, never>;
    };
    JwtLoginRequest: {
      /** @description The signed JWT to validate. */
      jwt?: string;
      /**
       * Format: lowercase
       * @description The role to log in against.
       */
      role?: string;
    };
    JwtOidcCallbackFormPostRequest: {
      client_nonce?: string;
      code?: string;
      id_token?: string;
      state?: string;
    };
    JwtOidcRequestAuthorizationUrlRequest: {
      /** @description Optional client-provided nonce that must match during callback, if present. */
      client_nonce?: string;
      /** @description The OAuth redirect_uri to use in the authorization URL. */
      redirect_uri?: string;
      /**
       * Format: lowercase
       * @description The role to issue an OIDC authorization URL against.
       */
      role?: string;
    };
    JwtWriteRoleRequest: {
      /** @description Comma-separated list of allowed values for redirect_uri */
      allowed_redirect_uris?: string[];
      /** @description Comma-separated list of 'aud' claims that are valid for login; any match is sufficient */
      bound_audiences?: string[];
      /**
       * @deprecated
       * @description Use "token_bound_cidrs" instead. If this and "token_bound_cidrs" are both specified, only "token_bound_cidrs" will be used.
       */
      bound_cidrs?: string[];
      /**
       * Format: map
       * @description Map of claims/values which must match for login
       */
      bound_claims?: Record<string, never>;
      /**
       * @description How to interpret values in the map of claims/values (which must match for login): allowed values are 'string' or 'glob'
       * @default string
       */
      bound_claims_type: string;
      /** @description The 'sub' claim that is valid for login. Optional. */
      bound_subject?: string;
      /**
       * Format: kvpairs
       * @description Mappings of claims (key) that will be copied to a metadata field (value)
       */
      claim_mappings?: Record<string, never>;
      /**
       * Format: duration
       * @description Duration in seconds of leeway when validating all claims to account for clock skew. Defaults to 60 (1 minute) if set to 0 and can be disabled if set to -1.
       * @default 60000000000
       */
      clock_skew_leeway: string;
      /**
       * Format: duration
       * @description Duration in seconds of leeway when validating expiration of a token to account for clock skew. Defaults to 150 (2.5 minutes) if set to 0 and can be disabled if set to -1.
       * @default 150
       */
      expiration_leeway: string;
      /** @description The claim to use for the Identity group alias names */
      groups_claim?: string;
      /**
       * Format: duration
       * @description Specifies the allowable elapsed time in seconds since the last time the user was actively authenticated.
       */
      max_age?: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_max_ttl" instead. If this and "token_max_ttl" are both specified, only "token_max_ttl" will be used.
       */
      max_ttl?: string;
      /**
       * Format: duration
       * @description Duration in seconds of leeway when validating not before values of a token to account for clock skew. Defaults to 150 (2.5 minutes) if set to 0 and can be disabled if set to -1.
       * @default 150
       */
      not_before_leeway: string;
      /**
       * @deprecated
       * @description Use "token_num_uses" instead. If this and "token_num_uses" are both specified, only "token_num_uses" will be used.
       */
      num_uses?: number;
      /** @description Comma-separated list of OIDC scopes */
      oidc_scopes?: string[];
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_period" instead. If this and "token_period" are both specified, only "token_period" will be used.
       */
      period?: string;
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /** @description Type of the role, either 'jwt' or 'oidc'. */
      role_type?: string;
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_ttl" instead. If this and "token_ttl" are both specified, only "token_ttl" will be used.
       */
      ttl?: string;
      /** @description The claim to use for the Identity entity alias name */
      user_claim?: string;
      /** @description If true, the user_claim value will use JSON pointer syntax for referencing claims. */
      user_claim_json_pointer?: boolean;
      /** @description Log received OIDC tokens and claims when debug-level logging is active. Not recommended in production since sensitive information may be present in OIDC responses. */
      verbose_oidc_logging?: boolean;
    };
    KerberosConfigureLdapRequest: {
      /**
       * @description Use anonymous binds when performing LDAP group searches (if true the initial credentials will still be used for the initial connection test).
       * @default false
       */
      anonymous_group_search: boolean;
      /** @description LDAP DN for searching for the user DN (optional) */
      binddn?: string;
      /** @description LDAP password for searching for the user DN (optional) */
      bindpass?: string;
      /** @description If true, case sensitivity will be used when comparing usernames and groups for matching policies. */
      case_sensitive_names?: boolean;
      /** @description CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded (optional) */
      certificate?: string;
      /** @description Client certificate to provide to the LDAP server, must be x509 PEM encoded (optional) */
      client_tls_cert?: string;
      /** @description Client certificate key to provide to the LDAP server, must be x509 PEM encoded (optional) */
      client_tls_key?: string;
      /**
       * Format: duration
       * @description Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL in the configuration.
       * @default 30s
       */
      connection_timeout: string;
      /**
       * @description Denies an unauthenticated LDAP bind request if the user's password is empty; defaults to true
       * @default true
       */
      deny_null_bind: boolean;
      /**
       * @description When aliases should be dereferenced on search operations. Accepted values are 'never', 'finding', 'searching', 'always'. Defaults to 'never'.
       * @default never
       * @enum {string}
       */
      dereference_aliases: 'never' | 'finding' | 'searching' | 'always';
      /** @description Use anonymous bind to discover the bind DN of a user (optional) */
      discoverdn?: boolean;
      /**
       * @description LDAP attribute to follow on objects returned by <groupfilter> in order to enumerate user group membership. Examples: "cn" or "memberOf", etc. Default: cn
       * @default cn
       */
      groupattr: string;
      /** @description LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org) */
      groupdn?: string;
      /**
       * @description Go template for querying group membership of user (optional) The template can access the following context variables: UserDN, Username Example: (&(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})) Default: (|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))
       * @default (|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))
       */
      groupfilter: string;
      /** @description Skip LDAP server SSL Certificate verification - VERY insecure (optional) */
      insecure_tls?: boolean;
      /**
       * @description If set to a value greater than 0, the LDAP backend will use the LDAP server's paged search control to request pages of up to the given size. This can be used to avoid hitting the LDAP server's maximum result size limit. Otherwise, the LDAP backend will not use the paged search control.
       * @default 0
       */
      max_page_size: number;
      /**
       * Format: duration
       * @description Timeout, in seconds, for the connection when making requests against the server before returning back an error.
       * @default 90s
       */
      request_timeout: string;
      /** @description Issue a StartTLS command after establishing unencrypted connection (optional) */
      starttls?: boolean;
      /**
       * @description Maximum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'
       * @default tls12
       * @enum {string}
       */
      tls_max_version: 'tls10' | 'tls11' | 'tls12' | 'tls13';
      /**
       * @description Minimum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'
       * @default tls12
       * @enum {string}
       */
      tls_min_version: 'tls10' | 'tls11' | 'tls12' | 'tls13';
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies. This will apply to all tokens generated by this auth method, in addition to any configured for specific users/groups. */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /** @description Enables userPrincipalDomain login with [username]@UPNDomain (optional) */
      upndomain?: string;
      /**
       * @description LDAP URL to connect to (default: ldap://127.0.0.1). Multiple URLs can be specified by concatenating them with commas; they will be tried in-order.
       * @default ldap://127.0.0.1
       */
      url: string;
      /** @description In Vault 1.1.1 a fix for handling group CN values of different cases unfortunately introduced a regression that could cause previously defined groups to not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for matching group CNs will be used. This is only needed in some upgrade scenarios for backwards compatibility. It is enabled by default if the config is upgraded but disabled by default on new configurations. */
      use_pre111_group_cn_behavior?: boolean;
      /**
       * @description If true, use the Active Directory tokenGroups constructed attribute of the user to find the group memberships. This will find all security groups including nested ones.
       * @default false
       */
      use_token_groups: boolean;
      /**
       * @description Attribute used for users (default: cn)
       * @default cn
       */
      userattr: string;
      /** @description LDAP domain to use for users (eg: ou=People,dc=example,dc=org) */
      userdn?: string;
      /**
       * @description Go template for LDAP user search filer (optional) The template can access the following context variables: UserAttr, Username Default: ({{.UserAttr}}={{.Username}})
       * @default ({{.UserAttr}}={{.Username}})
       */
      userfilter: string;
      /**
       * @description If true, sets the alias name to the username
       * @default false
       */
      username_as_alias: boolean;
    };
    KerberosConfigureRequest: {
      /** @description If set to true, returns any groups found in LDAP as a group alias. */
      add_group_aliases?: boolean;
      /** @description Base64 encoded keytab */
      keytab?: string;
      /** @description Remove instance/FQDN from keytab principal names. */
      remove_instance_name?: boolean;
      /** @description Service Account */
      service_account?: string;
    };
    KerberosLoginRequest: {
      /** @description SPNEGO Authorization header. Required. */
      authorization?: string;
    };
    KerberosWriteGroupRequest: {
      /** @description Comma-separated list of policies associated to the group. */
      policies?: string[];
    };
    KubernetesConfigureAuthRequest: {
      /**
       * @deprecated
       * @description Disable JWT issuer validation (Deprecated, will be removed in a future release)
       * @default true
       */
      disable_iss_validation: boolean;
      /**
       * @description Disable defaulting to the local CA cert and service account JWT when running in a Kubernetes pod
       * @default false
       */
      disable_local_ca_jwt: boolean;
      /**
       * @deprecated
       * @description Optional JWT issuer. If no issuer is specified, then this plugin will use kubernetes.io/serviceaccount as the default issuer. (Deprecated, will be removed in a future release)
       */
      issuer?: string;
      /** @description PEM encoded CA cert for use by the TLS client used to talk with the API. */
      kubernetes_ca_cert?: string;
      /** @description Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server. */
      kubernetes_host?: string;
      /** @description Optional list of PEM-formated public keys or certificates used to verify the signatures of kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys. */
      pem_keys?: string[];
      /** @description A service account JWT (or other token) used as a bearer token to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API. */
      token_reviewer_jwt?: string;
      /**
       * @description Use annotations from the client token's associated service account as alias metadata for the Vault entity. Only annotations with the prefix "vault.hashicorp.com/alias-metadata-" will be used. Note that Vault will need permission to read service accounts from the Kubernetes API.
       * @default false
       */
      use_annotations_as_alias_metadata: boolean;
    };
    KubernetesConfigureRequest: {
      /**
       * @description Disable defaulting to the local CA certificate and service account JWT when running in a Kubernetes pod.
       * @default false
       */
      disable_local_ca_jwt: boolean;
      /** @description PEM encoded CA certificate to use to verify the Kubernetes API server certificate. Defaults to the local pod's CA if found. */
      kubernetes_ca_cert?: string;
      /** @description Kubernetes API URL to connect to. Defaults to https://$KUBERNETES_SERVICE_HOST:KUBERNETES_SERVICE_PORT if those environment variables are set. */
      kubernetes_host?: string;
      /** @description The JSON web token of the service account used by the secret engine to manage Kubernetes credentials. Defaults to the local pod's JWT if found. */
      service_account_jwt?: string;
    };
    KubernetesGenerateCredentialsRequest: {
      /** @description The intended audiences of the generated credentials */
      audiences?: string[];
      /** @description If true, generate a ClusterRoleBinding to grant permissions across the whole cluster instead of within a namespace. Requires the Vault role to have kubernetes_role_type set to ClusterRole. */
      cluster_role_binding?: boolean;
      /** @description The name of the Kubernetes namespace in which to generate the credentials */
      kubernetes_namespace: string;
      /**
       * Format: duration
       * @description The TTL of the generated credentials
       */
      ttl?: string;
    };
    KubernetesLoginRequest: {
      /** @description A signed JWT for authenticating a service account. This field is required. */
      jwt?: string;
      /** @description Name of the role against which the login is being attempted. This field is required */
      role?: string;
    };
    KubernetesWriteAuthRoleRequest: {
      /**
       * @description Source to use when deriving the Alias name. valid choices: "serviceaccount_uid" : <token.uid> e.g. 474b11b5-0f20-4f9d-8ca5-65715ab325e0 (most secure choice) "serviceaccount_name" : <namespace>/<serviceaccount> e.g. vault/vault-agent default: "serviceaccount_uid"
       * @default serviceaccount_uid
       */
      alias_name_source: string;
      /** @description Optional Audience claim to verify in the jwt. */
      audience?: string;
      /**
       * @deprecated
       * @description Use "token_bound_cidrs" instead. If this and "token_bound_cidrs" are both specified, only "token_bound_cidrs" will be used.
       */
      bound_cidrs?: string[];
      /** @description List of service account names able to access this role. If set to "*" all names are allowed. */
      bound_service_account_names?: string[];
      /** @description A label selector for Kubernetes namespaces which are allowed to access this role. Accepts either a JSON or YAML object. If set with bound_service_account_namespaces, the conditions are ORed. */
      bound_service_account_namespace_selector?: string;
      /** @description List of namespaces allowed to access this role. If set to "*" all namespaces are allowed. */
      bound_service_account_namespaces?: string[];
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_max_ttl" instead. If this and "token_max_ttl" are both specified, only "token_max_ttl" will be used.
       */
      max_ttl?: string;
      /**
       * @deprecated
       * @description Use "token_num_uses" instead. If this and "token_num_uses" are both specified, only "token_num_uses" will be used.
       */
      num_uses?: number;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_period" instead. If this and "token_period" are both specified, only "token_period" will be used.
       */
      period?: string;
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_ttl" instead. If this and "token_ttl" are both specified, only "token_ttl" will be used.
       */
      ttl?: string;
    };
    KubernetesWriteRoleRequest: {
      /** @description A label selector for Kubernetes namespaces in which credentials can be generated. Accepts either a JSON or YAML object. If set with allowed_kubernetes_namespaces, the conditions are conjuncted. */
      allowed_kubernetes_namespace_selector?: string;
      /** @description A list of the Kubernetes namespaces in which credentials can be generated. If set to "*" all namespaces are allowed. */
      allowed_kubernetes_namespaces?: string[];
      /**
       * Format: kvpairs
       * @description Additional annotations to apply to all generated Kubernetes objects.
       */
      extra_annotations?: Record<string, never>;
      /**
       * Format: kvpairs
       * @description Additional labels to apply to all generated Kubernetes objects.
       */
      extra_labels?: Record<string, never>;
      /** @description The Role or ClusterRole rules to use when generating a role. Accepts either a JSON or YAML object. If set, the entire chain of Kubernetes objects will be generated. */
      generated_role_rules?: string;
      /** @description The pre-existing Role or ClusterRole to bind a generated service account to. If set, Kubernetes token, service account, and role binding objects will be created. */
      kubernetes_role_name?: string;
      /**
       * @description Specifies whether the Kubernetes role is a Role or ClusterRole.
       * @default Role
       */
      kubernetes_role_type: string;
      /** @description The name template to use when generating service accounts, roles and role bindings. If unset, a default template is used. */
      name_template?: string;
      /** @description The pre-existing service account to generate tokens for. Mutually exclusive with all role parameters. If set, only a Kubernetes service account token will be created. */
      service_account_name?: string;
      /** @description The default audiences for generated Kubernetes service account tokens. If not set or set to "", will use k8s cluster default. */
      token_default_audiences?: string[];
      /**
       * Format: duration
       * @description The default ttl for generated Kubernetes service account tokens. If not set or set to 0, will use system default.
       */
      token_default_ttl?: string;
      /**
       * Format: duration
       * @description The maximum ttl for generated Kubernetes service account tokens. If not set or set to 0, will use system default.
       */
      token_max_ttl?: string;
    };
    KvV2ConfigureRequest: {
      /** @description If true, the backend will require the cas parameter to be set for each write */
      cas_required?: boolean;
      /**
       * Format: duration
       * @description If set, the length of time before a version is deleted. A negative duration disables the use of delete_version_after on all keys. A zero duration clears the current setting. Accepts a Go duration format string.
       */
      delete_version_after?: string;
      /** @description The number of versions to keep for each key. Defaults to 10 */
      max_versions?: number;
    };
    KvV2DeleteVersionsRequest: {
      /** @description The versions to be archived. The versioned data will not be deleted, but it will no longer be returned in normal get requests. */
      versions?: number[];
    };
    KvV2DestroyVersionsRequest: {
      /** @description The versions to destroy. Their data will be permanently deleted. */
      versions?: number[];
    };
    KvV2PatchResponse: {
      /** Format: date-time */
      created_time?: string;
      /** Format: map */
      custom_metadata?: Record<string, never>;
      deletion_time?: string;
      destroyed?: boolean;
      /** Format: int64 */
      version?: number;
    };
    KvV2ReadConfigurationResponse: {
      /** @description If true, the backend will require the cas parameter to be set for each write */
      cas_required?: boolean;
      /**
       * Format: duration
       * @description The length of time before a version is deleted.
       */
      delete_version_after?: string;
      /** @description The number of versions to keep for each key. */
      max_versions?: number;
    };
    KvV2ReadMetadataResponse: {
      cas_required?: boolean;
      /** Format: date-time */
      created_time?: string;
      /** Format: int64 */
      current_version?: number;
      /**
       * Format: map
       * @description User-provided key-value pairs that are used to describe arbitrary and version-agnostic information about a secret.
       */
      custom_metadata?: Record<string, never>;
      /**
       * Format: duration
       * @description The length of time before a version is deleted.
       */
      delete_version_after?: string;
      /**
       * Format: int64
       * @description The number of versions to keep
       */
      max_versions?: number;
      /** Format: int64 */
      oldest_version?: number;
      /** Format: date-time */
      updated_time?: string;
      /** Format: map */
      versions?: Record<string, never>;
    };
    KvV2ReadResponse: {
      /** Format: map */
      data?: Record<string, never>;
      /** Format: map */
      metadata?: Record<string, never>;
    };
    KvV2ReadSubkeysResponse: {
      /** Format: map */
      metadata?: Record<string, never>;
      /** Format: map */
      subkeys?: Record<string, never>;
    };
    KvV2UndeleteVersionsRequest: {
      /** @description The versions to unarchive. The versions will be restored and their data will be returned on normal get requests. */
      versions?: number[];
    };
    KvV2WriteMetadataRequest: {
      /** @description If true the key will require the cas parameter to be set on all write requests. If false, the backend’s configuration will be used. */
      cas_required?: boolean;
      /**
       * Format: map
       * @description User-provided key-value pairs that are used to describe arbitrary and version-agnostic information about a secret.
       */
      custom_metadata?: Record<string, never>;
      /**
       * Format: duration
       * @description The length of time before a version is deleted. If not set, the backend's configured delete_version_after is used. Cannot be greater than the backend's delete_version_after. A zero duration clears the current setting. A negative duration will cause an error.
       */
      delete_version_after?: string;
      /** @description The number of versions to keep. If not set, the backend’s configured max version is used. */
      max_versions?: number;
    };
    KvV2WriteRequest: {
      /**
       * Format: map
       * @description The contents of the data map will be stored and returned on read.
       */
      data?: Record<string, never>;
      /**
       * Format: map
       * @description Options for writing a KV entry. Set the "cas" value to use a Check-And-Set operation. If not set the write will be allowed. If set to 0 a write will only be allowed if the key doesn’t exist. If the index is non-zero the write will only be allowed if the key’s current version matches the version specified in the cas parameter.
       */
      options?: Record<string, never>;
      /** @description If provided during a read, the value at the version number will be returned */
      version?: number;
    };
    KvV2WriteResponse: {
      /** Format: date-time */
      created_time?: string;
      /** Format: map */
      custom_metadata?: Record<string, never>;
      deletion_time?: string;
      destroyed?: boolean;
      /** Format: int64 */
      version?: number;
    };
    LdapConfigureAuthRequest: {
      /**
       * @description Use anonymous binds when performing LDAP group searches (if true the initial credentials will still be used for the initial connection test).
       * @default false
       */
      anonymous_group_search: boolean;
      /** @description LDAP DN for searching for the user DN (optional) */
      binddn?: string;
      /** @description LDAP password for searching for the user DN (optional) */
      bindpass?: string;
      /** @description If true, case sensitivity will be used when comparing usernames and groups for matching policies. */
      case_sensitive_names?: boolean;
      /** @description CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded (optional) */
      certificate?: string;
      /** @description Client certificate to provide to the LDAP server, must be x509 PEM encoded (optional) */
      client_tls_cert?: string;
      /** @description Client certificate key to provide to the LDAP server, must be x509 PEM encoded (optional) */
      client_tls_key?: string;
      /**
       * Format: duration
       * @description Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL in the configuration.
       * @default 30s
       */
      connection_timeout: string;
      /**
       * @description Denies an unauthenticated LDAP bind request if the user's password is empty; defaults to true
       * @default true
       */
      deny_null_bind: boolean;
      /**
       * @description When aliases should be dereferenced on search operations. Accepted values are 'never', 'finding', 'searching', 'always'. Defaults to 'never'.
       * @default never
       * @enum {string}
       */
      dereference_aliases: 'never' | 'finding' | 'searching' | 'always';
      /** @description Use anonymous bind to discover the bind DN of a user (optional) */
      discoverdn?: boolean;
      /**
       * @description LDAP attribute to follow on objects returned by <groupfilter> in order to enumerate user group membership. Examples: "cn" or "memberOf", etc. Default: cn
       * @default cn
       */
      groupattr: string;
      /** @description LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org) */
      groupdn?: string;
      /**
       * @description Go template for querying group membership of user (optional) The template can access the following context variables: UserDN, Username Example: (&(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})) Default: (|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))
       * @default (|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))
       */
      groupfilter: string;
      /** @description Skip LDAP server SSL Certificate verification - VERY insecure (optional) */
      insecure_tls?: boolean;
      /**
       * @description If set to a value greater than 0, the LDAP backend will use the LDAP server's paged search control to request pages of up to the given size. This can be used to avoid hitting the LDAP server's maximum result size limit. Otherwise, the LDAP backend will not use the paged search control.
       * @default 0
       */
      max_page_size: number;
      /** @description Password policy to use to rotate the root password */
      password_policy?: string;
      /**
       * Format: duration
       * @description Timeout, in seconds, for the connection when making requests against the server before returning back an error.
       * @default 90s
       */
      request_timeout: string;
      /** @description Issue a StartTLS command after establishing unencrypted connection (optional) */
      starttls?: boolean;
      /**
       * @description Maximum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'
       * @default tls12
       * @enum {string}
       */
      tls_max_version: 'tls10' | 'tls11' | 'tls12' | 'tls13';
      /**
       * @description Minimum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'
       * @default tls12
       * @enum {string}
       */
      tls_min_version: 'tls10' | 'tls11' | 'tls12' | 'tls13';
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies. This will apply to all tokens generated by this auth method, in addition to any configured for specific users/groups. */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /** @description Enables userPrincipalDomain login with [username]@UPNDomain (optional) */
      upndomain?: string;
      /**
       * @description LDAP URL to connect to (default: ldap://127.0.0.1). Multiple URLs can be specified by concatenating them with commas; they will be tried in-order.
       * @default ldap://127.0.0.1
       */
      url: string;
      /** @description In Vault 1.1.1 a fix for handling group CN values of different cases unfortunately introduced a regression that could cause previously defined groups to not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for matching group CNs will be used. This is only needed in some upgrade scenarios for backwards compatibility. It is enabled by default if the config is upgraded but disabled by default on new configurations. */
      use_pre111_group_cn_behavior?: boolean;
      /**
       * @description If true, use the Active Directory tokenGroups constructed attribute of the user to find the group memberships. This will find all security groups including nested ones.
       * @default false
       */
      use_token_groups: boolean;
      /**
       * @description Attribute used for users (default: cn)
       * @default cn
       */
      userattr: string;
      /** @description LDAP domain to use for users (eg: ou=People,dc=example,dc=org) */
      userdn?: string;
      /**
       * @description Go template for LDAP user search filer (optional) The template can access the following context variables: UserAttr, Username Default: ({{.UserAttr}}={{.Username}})
       * @default ({{.UserAttr}}={{.Username}})
       */
      userfilter: string;
      /**
       * @description If true, sets the alias name to the username
       * @default false
       */
      username_as_alias: boolean;
    };
    LdapConfigureRequest: {
      /**
       * @description Use anonymous binds when performing LDAP group searches (if true the initial credentials will still be used for the initial connection test).
       * @default false
       */
      anonymous_group_search: boolean;
      /** @description LDAP DN for searching for the user DN (optional) */
      binddn?: string;
      /** @description LDAP password for searching for the user DN (optional) */
      bindpass?: string;
      /** @description If true, case sensitivity will be used when comparing usernames and groups for matching policies. */
      case_sensitive_names?: boolean;
      /** @description CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded (optional) */
      certificate?: string;
      /** @description Client certificate to provide to the LDAP server, must be x509 PEM encoded (optional) */
      client_tls_cert?: string;
      /** @description Client certificate key to provide to the LDAP server, must be x509 PEM encoded (optional) */
      client_tls_key?: string;
      /**
       * Format: duration
       * @description Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL in the configuration.
       * @default 30s
       */
      connection_timeout: string;
      /**
       * @description Denies an unauthenticated LDAP bind request if the user's password is empty; defaults to true
       * @default true
       */
      deny_null_bind: boolean;
      /**
       * @description When aliases should be dereferenced on search operations. Accepted values are 'never', 'finding', 'searching', 'always'. Defaults to 'never'.
       * @default never
       * @enum {string}
       */
      dereference_aliases: 'never' | 'finding' | 'searching' | 'always';
      /** @description Use anonymous bind to discover the bind DN of a user (optional) */
      discoverdn?: boolean;
      /**
       * @description LDAP attribute to follow on objects returned by <groupfilter> in order to enumerate user group membership. Examples: "cn" or "memberOf", etc. Default: cn
       * @default cn
       */
      groupattr: string;
      /** @description LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org) */
      groupdn?: string;
      /**
       * @description Go template for querying group membership of user (optional) The template can access the following context variables: UserDN, Username Example: (&(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})) Default: (|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))
       * @default (|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))
       */
      groupfilter: string;
      /** @description Skip LDAP server SSL Certificate verification - VERY insecure (optional) */
      insecure_tls?: boolean;
      /**
       * @deprecated
       * @description The desired length of passwords that Vault generates.
       */
      length?: number;
      /**
       * @description If set to a value greater than 0, the LDAP backend will use the LDAP server's paged search control to request pages of up to the given size. This can be used to avoid hitting the LDAP server's maximum result size limit. Otherwise, the LDAP backend will not use the paged search control.
       * @default 0
       */
      max_page_size: number;
      /**
       * Format: duration
       * @description The maximum password time-to-live.
       */
      max_ttl?: string;
      /** @description Password policy to use to generate passwords */
      password_policy?: string;
      /**
       * Format: duration
       * @description Timeout, in seconds, for the connection when making requests against the server before returning back an error.
       * @default 90s
       */
      request_timeout: string;
      /**
       * @description The desired LDAP schema used when modifying user account passwords.
       * @default openldap
       */
      schema: string;
      /** @description Whether to skip the 'import' rotation. */
      skip_static_role_import_rotation?: boolean;
      /** @description Issue a StartTLS command after establishing unencrypted connection (optional) */
      starttls?: boolean;
      /**
       * @description Maximum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'
       * @default tls12
       * @enum {string}
       */
      tls_max_version: 'tls10' | 'tls11' | 'tls12' | 'tls13';
      /**
       * @description Minimum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'
       * @default tls12
       * @enum {string}
       */
      tls_min_version: 'tls10' | 'tls11' | 'tls12' | 'tls13';
      /**
       * Format: duration
       * @description The default password time-to-live.
       */
      ttl?: string;
      /** @description Enables userPrincipalDomain login with [username]@UPNDomain (optional) */
      upndomain?: string;
      /**
       * @description LDAP URL to connect to (default: ldap://127.0.0.1). Multiple URLs can be specified by concatenating them with commas; they will be tried in-order.
       * @default ldap://127.0.0.1
       */
      url: string;
      /** @description In Vault 1.1.1 a fix for handling group CN values of different cases unfortunately introduced a regression that could cause previously defined groups to not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for matching group CNs will be used. This is only needed in some upgrade scenarios for backwards compatibility. It is enabled by default if the config is upgraded but disabled by default on new configurations. */
      use_pre111_group_cn_behavior?: boolean;
      /**
       * @description If true, use the Active Directory tokenGroups constructed attribute of the user to find the group memberships. This will find all security groups including nested ones.
       * @default false
       */
      use_token_groups: boolean;
      /**
       * @description Attribute used for users (default: cn)
       * @default cn
       */
      userattr: string;
      /** @description LDAP domain to use for users (eg: ou=People,dc=example,dc=org) */
      userdn?: string;
      /**
       * @description Go template for LDAP user search filer (optional) The template can access the following context variables: UserAttr, Username Default: ({{.UserAttr}}={{.Username}})
       * @default ({{.UserAttr}}={{.Username}})
       */
      userfilter: string;
      /**
       * @description If true, sets the alias name to the username
       * @default false
       */
      username_as_alias: boolean;
    };
    LdapLibraryCheckInRequest: {
      /** @description The username/logon name for the service accounts to check in. */
      service_account_names?: string[];
    };
    LdapLibraryCheckOutRequest: {
      /**
       * Format: duration
       * @description The length of time before the check-out will expire, in seconds.
       */
      ttl?: string;
    };
    LdapLibraryConfigureRequest: {
      /**
       * @description Disable the default behavior of requiring that check-ins are performed by the entity that checked them out.
       * @default false
       */
      disable_check_in_enforcement: boolean;
      /**
       * Format: duration
       * @description In seconds, the max amount of time a check-out's renewals should last. Defaults to 24 hours.
       * @default 86400
       */
      max_ttl: string;
      /** @description The username/logon name for the service accounts with which this set will be associated. */
      service_account_names?: string[];
      /**
       * Format: duration
       * @description In seconds, the amount of time a check-out should last. Defaults to 24 hours.
       * @default 86400
       */
      ttl: string;
    };
    LdapLibraryForceCheckInRequest: {
      /** @description The username/logon name for the service accounts to check in. */
      service_account_names?: string[];
    };
    LdapLoginRequest: {
      /** @description Password for this user. */
      password?: string;
    };
    LdapWriteDynamicRoleRequest: {
      /** @description LDIF string used to create new entities within the LDAP system. This LDIF can be templated. */
      creation_ldif: string;
      /**
       * Format: duration
       * @description Default TTL for dynamic credentials
       */
      default_ttl?: string;
      /** @description LDIF string used to delete entities created within the LDAP system. This LDIF can be templated. */
      deletion_ldif: string;
      /**
       * Format: duration
       * @description Max TTL a dynamic credential can be extended to
       */
      max_ttl?: string;
      /** @description LDIF string used to rollback changes in the event of a failure to create credentials. This LDIF can be templated. */
      rollback_ldif?: string;
      /** @description The template used to create a username */
      username_template?: string;
    };
    LdapWriteGroupRequest: {
      /** @description Comma-separated list of policies associated to the group. */
      policies?: string[];
    };
    LdapWriteStaticRoleRequest: {
      /** @description The distinguished name of the entry to manage. */
      dn?: string;
      /**
       * Format: duration
       * @description Period for automatic credential rotation of the given entry.
       */
      rotation_period?: string;
      /** @description Skip the initial pasword rotation on import (has no effect on updates) */
      skip_import_rotation?: boolean;
      /** @description The username/logon name for the entry with which this role will be associated. */
      username?: string;
    };
    LdapWriteUserRequest: {
      /** @description Comma-separated list of additional groups associated with the user. */
      groups?: string[];
      /** @description Comma-separated list of policies associated with the user. */
      policies?: string[];
    };
    LeaderStatusResponse: {
      /** Format: date-time */
      active_time?: string;
      ha_enabled?: boolean;
      is_self?: boolean;
      /** Format: int64 */
      last_wal?: number;
      leader_address?: string;
      leader_cluster_address?: string;
      performance_standby?: boolean;
      /** Format: int64 */
      performance_standby_last_remote_wal?: number;
      /** Format: int64 */
      raft_applied_index?: number;
      /** Format: int64 */
      raft_committed_index?: number;
    };
    LeasesCountResponse: {
      /** @description Number of matching leases per mount */
      counts?: number;
      /** @description Number of matching leases */
      lease_count?: number;
    };
    LeasesListResponse: {
      /** @description Number of matching leases per mount */
      counts?: number;
      /** @description Number of matching leases */
      lease_count?: number;
    };
    LeasesLookUpResponse: {
      /** @description A list of lease ids */
      keys?: string[];
    };
    LeasesReadLeaseRequest: {
      /** @description The lease identifier to renew. This is included with a lease. */
      lease_id?: string;
    };
    LeasesReadLeaseResponse: {
      /**
       * Format: date-time
       * @description Optional lease expiry time
       */
      expire_time?: string;
      /** @description Lease id */
      id?: string;
      /**
       * Format: date-time
       * @description Timestamp for the lease's issue time
       */
      issue_time?: string;
      /**
       * Format: date-time
       * @description Optional Timestamp of the last time the lease was renewed
       */
      last_renewal?: string;
      /** @description True if the lease is able to be renewed */
      renewable?: boolean;
      /** @description Time to Live set for the lease, returns 0 if unset */
      ttl?: number;
    };
    LeasesRenewLease2Request: {
      /**
       * Format: duration
       * @description The desired increment in seconds to the lease
       */
      increment?: string;
      /** @description The lease identifier to renew. This is included with a lease. */
      lease_id?: string;
    };
    LeasesRenewLeaseRequest: {
      /**
       * Format: duration
       * @description The desired increment in seconds to the lease
       */
      increment?: string;
      /** @description The lease identifier to renew. This is included with a lease. */
      lease_id?: string;
    };
    LeasesRenewLeaseWithId2Request: {
      /**
       * Format: duration
       * @description The desired increment in seconds to the lease
       */
      increment?: string;
      /** @description The lease identifier to renew. This is included with a lease. */
      lease_id?: string;
    };
    LeasesRenewLeaseWithIdRequest: {
      /**
       * Format: duration
       * @description The desired increment in seconds to the lease
       */
      increment?: string;
      /** @description The lease identifier to renew. This is included with a lease. */
      lease_id?: string;
    };
    LeasesRevokeLease2Request: {
      /** @description The lease identifier to renew. This is included with a lease. */
      lease_id?: string;
      /**
       * @description Whether or not to perform the revocation synchronously
       * @default true
       */
      sync: boolean;
    };
    LeasesRevokeLeaseRequest: {
      /** @description The lease identifier to renew. This is included with a lease. */
      lease_id?: string;
      /**
       * @description Whether or not to perform the revocation synchronously
       * @default true
       */
      sync: boolean;
    };
    LeasesRevokeLeaseWithId2Request: {
      /** @description The lease identifier to renew. This is included with a lease. */
      lease_id?: string;
      /**
       * @description Whether or not to perform the revocation synchronously
       * @default true
       */
      sync: boolean;
    };
    LeasesRevokeLeaseWithIdRequest: {
      /** @description The lease identifier to renew. This is included with a lease. */
      lease_id?: string;
      /**
       * @description Whether or not to perform the revocation synchronously
       * @default true
       */
      sync: boolean;
    };
    LeasesRevokeLeaseWithPrefix2Request: {
      /**
       * @description Whether or not to perform the revocation synchronously
       * @default true
       */
      sync: boolean;
    };
    LeasesRevokeLeaseWithPrefixRequest: {
      /**
       * @description Whether or not to perform the revocation synchronously
       * @default true
       */
      sync: boolean;
    };
    LoggersUpdateVerbosityLevelForRequest: {
      /** @description Log verbosity level. Supported values (in order of detail) are "trace", "debug", "info", "warn", and "error". */
      level?: string;
    };
    LoggersUpdateVerbosityLevelRequest: {
      /** @description Log verbosity level. Supported values (in order of detail) are "trace", "debug", "info", "warn", and "error". */
      level?: string;
    };
    MfaAdminDestroyTotpSecretRequest: {
      /** @description Identifier of the entity from which the MFA method secret needs to be removed. */
      entity_id: string;
      /** @description The unique identifier for this MFA method. */
      method_id: string;
    };
    MfaAdminGenerateTotpSecretRequest: {
      /** @description Entity ID on which the generated secret needs to get stored. */
      entity_id: string;
      /** @description The unique identifier for this MFA method. */
      method_id: string;
    };
    MfaCreateDuoMethodRequest: {
      /** @description API host name for Duo. */
      api_hostname?: string;
      /** @description Integration key for Duo. */
      integration_key?: string;
      /** @description The unique name identifier for this MFA method. */
      method_name?: string;
      /** @description Push information for Duo. */
      push_info?: string;
      /** @description Secret key for Duo. */
      secret_key?: string;
      /** @description If true, the user is reminded to use the passcode upon MFA validation. This option does not enforce using the passcode. Defaults to false. */
      use_passcode?: boolean;
      /** @description A template string for mapping Identity names to MFA method names. Values to subtitute should be placed in {{}}. For example, "{{alias.name}}@example.com". Currently-supported mappings: alias.name: The name returned by the mount configured via the mount_accessor parameter If blank, the Alias's name field will be used as-is. */
      username_format?: string;
    };
    MfaCreateOktaMethodRequest: {
      /** @description Okta API key. */
      api_token?: string;
      /** @description The base domain to use for the Okta API. When not specified in the configuration, "okta.com" is used. */
      base_url?: string;
      /** @description The unique name identifier for this MFA method. */
      method_name?: string;
      /** @description Name of the organization to be used in the Okta API. */
      org_name?: string;
      /** @description If true, the username will only match the primary email for the account. Defaults to false. */
      primary_email?: boolean;
      /** @description (DEPRECATED) Use base_url instead. */
      production?: boolean;
      /** @description A template string for mapping Identity names to MFA method names. Values to substitute should be placed in {{}}. For example, "{{entity.name}}@example.com". If blank, the Entity's name field will be used as-is. */
      username_format?: string;
    };
    MfaCreatePingIdMethodRequest: {
      /** @description The unique name identifier for this MFA method. */
      method_name?: string;
      /** @description The settings file provided by Ping, Base64-encoded. This must be a settings file suitable for third-party clients, not the PingID SDK or PingFederate. */
      settings_file_base64?: string;
      /** @description A template string for mapping Identity names to MFA method names. Values to subtitute should be placed in {{}}. For example, "{{alias.name}}@example.com". Currently-supported mappings: alias.name: The name returned by the mount configured via the mount_accessor parameter If blank, the Alias's name field will be used as-is. */
      username_format?: string;
    };
    MfaCreateTotpMethodRequest: {
      /**
       * @description The hashing algorithm used to generate the TOTP token. Options include SHA1, SHA256 and SHA512.
       * @default SHA1
       */
      algorithm: string;
      /**
       * @description The number of digits in the generated TOTP token. This value can either be 6 or 8.
       * @default 6
       */
      digits: number;
      /** @description The name of the key's issuing organization. */
      issuer?: string;
      /**
       * @description Determines the size in bytes of the generated key.
       * @default 20
       */
      key_size: number;
      /** @description Max number of allowed validation attempts. */
      max_validation_attempts?: number;
      /** @description The unique name identifier for this MFA method. */
      method_name?: string;
      /**
       * Format: duration
       * @description The length of time used to generate a counter for the TOTP token calculation.
       * @default 30
       */
      period: string;
      /**
       * @description The pixel size of the generated square QR code.
       * @default 200
       */
      qr_size: number;
      /**
       * @description The number of delay periods that are allowed when validating a TOTP token. This value can either be 0 or 1.
       * @default 1
       */
      skew: number;
    };
    MfaGenerateTotpSecretRequest: {
      /** @description The unique identifier for this MFA method. */
      method_id: string;
    };
    MfaUpdateDuoMethodRequest: {
      /** @description API host name for Duo. */
      api_hostname?: string;
      /** @description Integration key for Duo. */
      integration_key?: string;
      /** @description The unique name identifier for this MFA method. */
      method_name?: string;
      /** @description Push information for Duo. */
      push_info?: string;
      /** @description Secret key for Duo. */
      secret_key?: string;
      /** @description If true, the user is reminded to use the passcode upon MFA validation. This option does not enforce using the passcode. Defaults to false. */
      use_passcode?: boolean;
      /** @description A template string for mapping Identity names to MFA method names. Values to subtitute should be placed in {{}}. For example, "{{alias.name}}@example.com". Currently-supported mappings: alias.name: The name returned by the mount configured via the mount_accessor parameter If blank, the Alias's name field will be used as-is. */
      username_format?: string;
    };
    MfaUpdateOktaMethodRequest: {
      /** @description Okta API key. */
      api_token?: string;
      /** @description The base domain to use for the Okta API. When not specified in the configuration, "okta.com" is used. */
      base_url?: string;
      /** @description The unique name identifier for this MFA method. */
      method_name?: string;
      /** @description Name of the organization to be used in the Okta API. */
      org_name?: string;
      /** @description If true, the username will only match the primary email for the account. Defaults to false. */
      primary_email?: boolean;
      /** @description (DEPRECATED) Use base_url instead. */
      production?: boolean;
      /** @description A template string for mapping Identity names to MFA method names. Values to substitute should be placed in {{}}. For example, "{{entity.name}}@example.com". If blank, the Entity's name field will be used as-is. */
      username_format?: string;
    };
    MfaUpdatePingIdMethodRequest: {
      /** @description The unique name identifier for this MFA method. */
      method_name?: string;
      /** @description The settings file provided by Ping, Base64-encoded. This must be a settings file suitable for third-party clients, not the PingID SDK or PingFederate. */
      settings_file_base64?: string;
      /** @description A template string for mapping Identity names to MFA method names. Values to subtitute should be placed in {{}}. For example, "{{alias.name}}@example.com". Currently-supported mappings: alias.name: The name returned by the mount configured via the mount_accessor parameter If blank, the Alias's name field will be used as-is. */
      username_format?: string;
    };
    MfaUpdateTotpMethodRequest: {
      /**
       * @description The hashing algorithm used to generate the TOTP token. Options include SHA1, SHA256 and SHA512.
       * @default SHA1
       */
      algorithm: string;
      /**
       * @description The number of digits in the generated TOTP token. This value can either be 6 or 8.
       * @default 6
       */
      digits: number;
      /** @description The name of the key's issuing organization. */
      issuer?: string;
      /**
       * @description Determines the size in bytes of the generated key.
       * @default 20
       */
      key_size: number;
      /** @description Max number of allowed validation attempts. */
      max_validation_attempts?: number;
      /** @description The unique name identifier for this MFA method. */
      method_name?: string;
      /**
       * Format: duration
       * @description The length of time used to generate a counter for the TOTP token calculation.
       * @default 30
       */
      period: string;
      /**
       * @description The pixel size of the generated square QR code.
       * @default 200
       */
      qr_size: number;
      /**
       * @description The number of delay periods that are allowed when validating a TOTP token. This value can either be 0 or 1.
       * @default 1
       */
      skew: number;
    };
    MfaValidateRequest: {
      /**
       * Format: map
       * @description A map from MFA method ID to a slice of passcodes or an empty slice if the method does not use passcodes
       */
      mfa_payload: Record<string, never>;
      /** @description ID for this MFA request */
      mfa_request_id: string;
    };
    MfaWriteLoginEnforcementRequest: {
      /** @description Array of auth mount accessor IDs */
      auth_method_accessors?: string[];
      /** @description Array of auth mount types */
      auth_method_types?: string[];
      /** @description Array of identity entity IDs */
      identity_entity_ids?: string[];
      /** @description Array of identity group IDs */
      identity_group_ids?: string[];
      /** @description Array of Method IDs that determine what methods will be enforced */
      mfa_method_ids: string[];
    };
    MongoDbAtlasConfigureRequest: {
      /** @description MongoDB Atlas Programmatic Private Key */
      private_key: string;
      /** @description MongoDB Atlas Programmatic Public Key */
      public_key: string;
    };
    MongoDbAtlasWriteRoleRequest: {
      /** @description Access list entry in CIDR notation to be added for the API key. Optional for organization and project keys. */
      cidr_blocks?: string[];
      /** @description IP address to be added to the access list for the API key. Optional for organization and project keys. */
      ip_addresses?: string[];
      /**
       * Format: duration
       * @description The maximum allowed lifetime of credentials issued using this role.
       */
      max_ttl?: string;
      /** @description Organization ID required for an organization API key */
      organization_id?: string;
      /** @description Project ID the project API key belongs to. */
      project_id?: string;
      /** @description Roles assigned when an organization API Key is assigned to a project API key */
      project_roles?: string[];
      /** @description List of roles that the API Key should be granted. A minimum of one role must be provided. Any roles provided must be valid for the assigned Project, required for organization and project keys. */
      roles: string[];
      /**
       * Format: duration
       * @description Duration in seconds after which the issued credential should expire. Defaults to 0, in which case the value will fallback to the system/mount defaults.
       */
      ttl?: string;
    };
    MountsEnableSecretsEngineRequest: {
      /**
       * Format: map
       * @description Configuration for this mount, such as default_lease_ttl and max_lease_ttl.
       */
      config?: Record<string, never>;
      /** @description User-friendly description for this mount. */
      description?: string;
      /**
       * @description Whether to give the mount access to Vault's external entropy.
       * @default false
       */
      external_entropy_access: boolean;
      /**
       * @description Mark the mount as a local mount, which is not replicated and is unaffected by replication.
       * @default false
       */
      local: boolean;
      /**
       * Format: kvpairs
       * @description The options to pass into the backend. Should be a json object with string keys and values.
       */
      options?: Record<string, never>;
      /** @description Name of the plugin to mount based from the name registered in the plugin catalog. */
      plugin_name?: string;
      /** @description The semantic version of the plugin to use, or image tag if oci_image is provided. */
      plugin_version?: string;
      /**
       * @description Whether to turn on seal wrapping for the mount.
       * @default false
       */
      seal_wrap: boolean;
      /** @description The type of the backend. Example: "passthrough" */
      type?: string;
    };
    MountsReadConfigurationResponse: {
      accessor?: string;
      /**
       * Format: map
       * @description Configuration for this mount, such as default_lease_ttl and max_lease_ttl.
       */
      config?: Record<string, never>;
      deprecation_status?: string;
      /** @description User-friendly description for this mount. */
      description?: string;
      external_entropy_access?: boolean;
      /**
       * @description Mark the mount as a local mount, which is not replicated and is unaffected by replication.
       * @default false
       */
      local: boolean;
      /**
       * Format: kvpairs
       * @description The options to pass into the backend. Should be a json object with string keys and values.
       */
      options?: Record<string, never>;
      /** @description The semantic version of the plugin to use, or image tag if oci_image is provided. */
      plugin_version?: string;
      running_plugin_version?: string;
      running_sha256?: string;
      /**
       * @description Whether to turn on seal wrapping for the mount.
       * @default false
       */
      seal_wrap: boolean;
      /** @description The type of the backend. Example: "passthrough" */
      type?: string;
      uuid?: string;
    };
    MountsReadTuningInformationResponse: {
      allowed_managed_keys?: string[];
      /** @description A list of headers to whitelist and allow a plugin to set on responses. */
      allowed_response_headers?: string[];
      audit_non_hmac_request_keys?: string[];
      audit_non_hmac_response_keys?: string[];
      /** @description The default lease TTL for this mount. */
      default_lease_ttl?: number;
      /** @description A list of auth accessors that the mount is allowed to delegate authentication too */
      delegated_auth_accessors?: string[];
      /** @description User-friendly description for this credential backend. */
      description?: string;
      external_entropy_access?: boolean;
      force_no_cache?: boolean;
      identity_token_key?: string;
      listing_visibility?: string;
      /** @description The max lease TTL for this mount. */
      max_lease_ttl?: number;
      /**
       * Format: kvpairs
       * @description The options to pass into the backend. Should be a json object with string keys and values.
       */
      options?: Record<string, never>;
      passthrough_request_headers?: string[];
      /** @description The semantic version of the plugin to use, or image tag if oci_image is provided. */
      plugin_version?: string;
      /** @description The type of token to issue (service or batch). */
      token_type?: string;
      /** Format: int64 */
      user_lockout_counter_reset_duration?: number;
      user_lockout_disable?: boolean;
      /** Format: int64 */
      user_lockout_duration?: number;
      /** Format: int64 */
      user_lockout_threshold?: number;
    };
    MountsTuneConfigurationParametersRequest: {
      allowed_managed_keys?: string[];
      /** @description A list of headers to whitelist and allow a plugin to set on responses. */
      allowed_response_headers?: string[];
      /** @description The list of keys in the request data object that will not be HMAC'ed by audit devices. */
      audit_non_hmac_request_keys?: string[];
      /** @description The list of keys in the response data object that will not be HMAC'ed by audit devices. */
      audit_non_hmac_response_keys?: string[];
      /** @description The default lease TTL for this mount. */
      default_lease_ttl?: string;
      delegated_auth_accessors?: string[];
      /** @description User-friendly description for this credential backend. */
      description?: string;
      /** @description The name of the key used to sign plugin identity tokens. Defaults to the default key. */
      identity_token_key?: string;
      /** @description Determines the visibility of the mount in the UI-specific listing endpoint. Accepted value are 'unauth' and 'hidden', with the empty default ('') behaving like 'hidden'. */
      listing_visibility?: string;
      /** @description The max lease TTL for this mount. */
      max_lease_ttl?: string;
      /**
       * Format: kvpairs
       * @description The options to pass into the backend. Should be a json object with string keys and values.
       */
      options?: Record<string, never>;
      /** @description A list of headers to whitelist and pass from the request to the plugin. */
      passthrough_request_headers?: string[];
      /** @description The semantic version of the plugin to use, or image tag if oci_image is provided. */
      plugin_version?: string;
      /** @description The type of token to issue (service or batch). */
      token_type?: string;
      /**
       * Format: map
       * @description The user lockout configuration to pass into the backend. Should be a json object with string keys and values.
       */
      user_lockout_config?: Record<string, never>;
    };
    NomadConfigureAccessRequest: {
      /** @description Nomad server address */
      address?: string;
      /** @description CA certificate to use when verifying Nomad server certificate, must be x509 PEM encoded. */
      ca_cert?: string;
      /** @description Client certificate used for Nomad's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_key. */
      client_cert?: string;
      /** @description Client key used for Nomad's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_cert. */
      client_key?: string;
      /** @description Max length for name of generated Nomad tokens */
      max_token_name_length?: number;
      /** @description Token for API calls */
      token?: string;
    };
    NomadConfigureLeaseRequest: {
      /**
       * Format: duration
       * @description Duration after which the issued token should not be allowed to be renewed
       */
      max_ttl?: string;
      /**
       * Format: duration
       * @description Duration before which the issued token needs renewal
       */
      ttl?: string;
    };
    NomadWriteRoleRequest: {
      /** @description Boolean value describing if the token should be global or not. Defaults to false. */
      global?: boolean;
      /** @description Comma-separated string or list of policies as previously created in Nomad. Required for 'client' token. */
      policies?: string[];
      /**
       * @description Which type of token to create: 'client' or 'management'. If a 'management' token, the "policies" parameter is not required. Defaults to 'client'.
       * @default client
       */
      type: string;
    };
    OciConfigureRequest: {
      /** @description The tenancy id of the account. */
      home_tenancy_id?: string;
    };
    OciLoginRequest: {
      /** @description The signed headers of the client */
      request_headers?: string;
    };
    OciWriteRoleRequest: {
      /** @description A comma separated list of Group or Dynamic Group OCIDs that are allowed to take this role. */
      ocid_list?: string[];
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
    };
    OidcConfigureRequest: {
      /** @description Issuer URL to be used in the iss claim of the token. If not set, Vault's app_addr will be used. */
      issuer?: string;
    };
    OidcIntrospectRequest: {
      /** @description Optional client_id to verify */
      client_id?: string;
      /** @description Token to verify */
      token?: string;
    };
    OidcProviderAuthorizeWithParametersRequest: {
      /** @description The ID of the requesting client. */
      client_id: string;
      /** @description The code challenge derived from the code verifier. */
      code_challenge?: string;
      /**
       * @description The method that was used to derive the code challenge. The following methods are supported: 'S256', 'plain'. Defaults to 'plain'.
       * @default plain
       */
      code_challenge_method: string;
      /** @description The allowable elapsed time in seconds since the last time the end-user was actively authenticated. */
      max_age?: number;
      /** @description The value that will be returned in the ID token nonce claim after a token exchange. */
      nonce?: string;
      /** @description The redirection URI to which the response will be sent. */
      redirect_uri: string;
      /** @description The OIDC authentication flow to be used. The following response types are supported: 'code' */
      response_type: string;
      /** @description A space-delimited, case-sensitive list of scopes to be requested. The 'openid' scope is required. */
      scope: string;
      /** @description The value used to maintain state between the authentication request and client. */
      state?: string;
    };
    OidcProviderTokenRequest: {
      /** @description The ID of the requesting client. */
      client_id?: string;
      /** @description The secret of the requesting client. */
      client_secret?: string;
      /** @description The authorization code received from the provider's authorization endpoint. */
      code: string;
      /** @description The code verifier associated with the authorization code. */
      code_verifier?: string;
      /** @description The authorization grant type. The following grant types are supported: 'authorization_code'. */
      grant_type: string;
      /** @description The callback location where the authentication response was sent. */
      redirect_uri: string;
    };
    OidcRotateKeyRequest: {
      /**
       * Format: duration
       * @description Controls how long the public portion of a key will be available for verification after being rotated. Setting verification_ttl here will override the verification_ttl set on the key.
       */
      verification_ttl?: string;
    };
    OidcWriteAssignmentRequest: {
      /** @description Comma separated string or array of identity entity IDs */
      entity_ids?: string[];
      /** @description Comma separated string or array of identity group IDs */
      group_ids?: string[];
    };
    OidcWriteClientRequest: {
      /**
       * Format: duration
       * @description The time-to-live for access tokens obtained by the client.
       * @default 24h
       */
      access_token_ttl: string;
      /** @description Comma separated string or array of assignment resources. */
      assignments?: string[];
      /**
       * @description The client type based on its ability to maintain confidentiality of credentials. The following client types are supported: 'confidential', 'public'. Defaults to 'confidential'.
       * @default confidential
       */
      client_type: string;
      /**
       * Format: duration
       * @description The time-to-live for ID tokens obtained by the client.
       * @default 24h
       */
      id_token_ttl: string;
      /**
       * @description A reference to a named key resource. Cannot be modified after creation. Defaults to the 'default' key.
       * @default default
       */
      key: string;
      /** @description Comma separated string or array of redirect URIs used by the client. One of these values must exactly match the redirect_uri parameter value used in each authentication request. */
      redirect_uris?: string[];
    };
    OidcWriteKeyRequest: {
      /**
       * @description Signing algorithm to use. This will default to RS256.
       * @default RS256
       */
      algorithm: string;
      /** @description Comma separated string or array of role client ids allowed to use this key for signing. If empty no roles are allowed. If "*" all roles are allowed. */
      allowed_client_ids?: string[];
      /**
       * Format: duration
       * @description How often to generate a new keypair.
       * @default 24h
       */
      rotation_period: string;
      /**
       * Format: duration
       * @description Controls how long the public portion of a key will be available for verification after being rotated.
       * @default 24h
       */
      verification_ttl: string;
    };
    OidcWriteProviderRequest: {
      /** @description The client IDs that are permitted to use the provider */
      allowed_client_ids?: string[];
      /** @description Specifies what will be used for the iss claim of ID tokens. */
      issuer?: string;
      /** @description The scopes supported for requesting on the provider */
      scopes_supported?: string[];
    };
    OidcWriteRoleRequest: {
      /** @description Optional client_id */
      client_id?: string;
      /** @description The OIDC key to use for generating tokens. The specified key must already exist. */
      key: string;
      /** @description The template string to use for generating tokens. This may be in string-ified JSON or base64 format. */
      template?: string;
      /**
       * Format: duration
       * @description TTL of the tokens generated against the role.
       * @default 24h
       */
      ttl: string;
    };
    OidcWriteScopeRequest: {
      /** @description The description of the scope */
      description?: string;
      /** @description The template string to use for the scope. This may be in string-ified JSON or base64 format. */
      template?: string;
    };
    OktaConfigureRequest: {
      /** @description Okta API key. */
      api_token?: string;
      /** @description The base domain to use for the Okta API. When not specified in the configuration, "okta.com" is used. */
      base_url?: string;
      /** @description When set true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired. */
      bypass_okta_mfa?: boolean;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_max_ttl" instead. If this and "token_max_ttl" are both specified, only "token_max_ttl" will be used.
       */
      max_ttl?: string;
      /** @description Name of the organization to be used in the Okta API. */
      org_name?: string;
      /**
       * @deprecated
       * @description Use org_name instead.
       */
      organization?: string;
      /**
       * @deprecated
       * @description Use base_url instead.
       */
      production?: boolean;
      /**
       * @deprecated
       * @description Use api_token instead.
       */
      token?: string;
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies. This will apply to all tokens generated by this auth method, in addition to any configured for specific users/groups. */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_ttl" instead. If this and "token_ttl" are both specified, only "token_ttl" will be used.
       */
      ttl?: string;
    };
    OktaLoginRequest: {
      /** @description Nonce provided if performing login that requires number verification challenge. Logins through the vault login CLI command will automatically generate a nonce. */
      nonce?: string;
      /** @description Password for this user. */
      password?: string;
      /** @description Preferred factor provider. */
      provider?: string;
      /** @description TOTP passcode. */
      totp?: string;
    };
    OktaWriteGroupRequest: {
      /** @description Comma-separated list of policies associated to the group. */
      policies?: string[];
    };
    OktaWriteUserRequest: {
      /** @description List of groups associated with the user. */
      groups?: string[];
      /** @description List of policies associated with the user. */
      policies?: string[];
    };
    PersonaCreateRequest: {
      /** @description Entity ID to which this persona belongs to */
      entity_id?: string;
      /** @description ID of the persona */
      id?: string;
      /**
       * Format: kvpairs
       * @description Metadata to be associated with the persona. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2
       */
      metadata?: Record<string, never>;
      /** @description Mount accessor to which this persona belongs to */
      mount_accessor?: string;
      /** @description Name of the persona */
      name?: string;
    };
    PersonaUpdateByIdRequest: {
      /** @description Entity ID to which this persona should be tied to */
      entity_id?: string;
      /**
       * Format: kvpairs
       * @description Metadata to be associated with the persona. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2
       */
      metadata?: Record<string, never>;
      /** @description Mount accessor to which this persona belongs to */
      mount_accessor?: string;
      /** @description Name of the persona */
      name?: string;
    };
    PkiConfigureAcmeRequest: {
      /**
       * @description whether the ExtKeyUsage field from a role is used, defaults to false meaning that certificate will be signed with ServerAuth.
       * @default false
       */
      allow_role_ext_key_usage: boolean;
      /**
       * @description which issuers are allowed for use with ACME; by default, this will only be the primary (default) issuer
       * @default [
       *       "*"
       *     ]
       */
      allowed_issuers: string[];
      /**
       * @description which roles are allowed for use with ACME; by default via '*', these will be all roles including sign-verbatim; when concrete role names are specified, any default_directory_policy role must be included to allow usage of the default acme directories under /pki/acme/directory and /pki/issuer/:issuer_id/acme/directory.
       * @default [
       *       "*"
       *     ]
       */
      allowed_roles: string[];
      /**
       * @description the policy to be used for non-role-qualified ACME requests; by default ACME issuance will be otherwise unrestricted, equivalent to the sign-verbatim endpoint; one may also specify a role to use as this policy, as "role:<role_name>", the specified role must be allowed by allowed_roles
       * @default sign-verbatim
       */
      default_directory_policy: string;
      /**
       * @description DNS resolver to use for domain resolution on this mount. Defaults to using the default system resolver. Must be in the format <host>:<port>, with both parts mandatory.
       * @default
       */
      dns_resolver: string;
      /**
       * @description Specify the policy to use for external account binding behaviour, 'not-required', 'new-account-required' or 'always-required'
       * @default always-required
       */
      eab_policy: string;
      /**
       * @description whether ACME is enabled, defaults to false meaning that clusters will by default not get ACME support
       * @default false
       */
      enabled: boolean;
    };
    PkiConfigureAutoTidyRequest: {
      /**
       * Format: duration
       * @description The amount of time that must pass after creation that an account with no orders is marked revoked, and the amount of time after being marked revoked or deactivated.
       * @default 2592000
       */
      acme_account_safety_buffer: string;
      /** @description Set to true to enable automatic tidy operations. */
      enabled?: boolean;
      /**
       * Format: duration
       * @description Interval at which to run an auto-tidy operation. This is the time between tidy invocations (after one finishes to the start of the next). Running a manual tidy will reset this duration.
       * @default 43200
       */
      interval_duration: string;
      /**
       * Format: duration
       * @description The amount of extra time that must have passed beyond issuer's expiration before it is removed from the backend storage. Defaults to 8760 hours (1 year).
       * @default 31536000
       */
      issuer_safety_buffer: string;
      /**
       * @description This configures whether stored certificates are counted upon initialization of the backend, and whether during normal operation, a running count of certificates stored is maintained.
       * @default false
       */
      maintain_stored_certificate_counts: boolean;
      /**
       * @description The amount of time to wait between processing certificates. This allows operators to change the execution profile of tidy to take consume less resources by slowing down how long it takes to run. Note that the entire list of certificates will be stored in memory during the entire tidy operation, but resources to read/process/update existing entries will be spread out over a greater period of time. By default this is zero seconds.
       * @default 0s
       */
      pause_duration: string;
      /**
       * @description This configures whether the stored certificate count is published to the metrics consumer. It does not affect if the stored certificate count is maintained, and if maintained, it will be available on the tidy-status endpoint.
       * @default false
       */
      publish_stored_certificate_count_metrics: boolean;
      /**
       * Format: duration
       * @description The amount of time that must pass from the cross-cluster revocation request being initiated to when it will be slated for removal. Setting this too low may remove valid revocation requests before the owning cluster has a chance to process them, especially if the cluster is offline.
       * @default 172800
       */
      revocation_queue_safety_buffer: string;
      /**
       * Format: duration
       * @description The amount of extra time that must have passed beyond certificate expiration before it is removed from the backend storage and/or revocation list. Defaults to 72 hours.
       * @default 259200
       */
      safety_buffer: string;
      /**
       * @description Set to true to enable tidying ACME accounts, orders and authorizations. ACME orders are tidied (deleted) safety_buffer after the certificate associated with them expires, or after the order and relevant authorizations have expired if no certificate was produced. Authorizations are tidied with the corresponding order. When a valid ACME Account is at least acme_account_safety_buffer old, and has no remaining orders associated with it, the account is marked as revoked. After another acme_account_safety_buffer has passed from the revocation or deactivation date, a revoked or deactivated ACME account is deleted.
       * @default false
       */
      tidy_acme: boolean;
      /** @description Set to true to enable tidying up the certificate store */
      tidy_cert_store?: boolean;
      /** @description Set to true to enable tidying up the cross-cluster revoked certificate store. Only runs on the active primary node. */
      tidy_cross_cluster_revoked_certs?: boolean;
      /** @description Set to true to automatically remove expired issuers past the issuer_safety_buffer. No keys will be removed as part of this operation. */
      tidy_expired_issuers?: boolean;
      /** @description Set to true to move the legacy ca_bundle from /config/ca_bundle to /config/ca_bundle.bak. This prevents downgrades to pre-Vault 1.11 versions (as older PKI engines do not know about the new multi-issuer storage layout), but improves the performance on seal wrapped PKI mounts. This will only occur if at least issuer_safety_buffer time has occurred after the initial storage migration. This backup is saved in case of an issue in future migrations. Operators may consider removing it via sys/raw if they desire. The backup will be removed via a DELETE /root call, but note that this removes ALL issuers within the mount (and is thus not desirable in most operational scenarios). */
      tidy_move_legacy_ca_bundle?: boolean;
      /** @description Deprecated; synonym for 'tidy_revoked_certs */
      tidy_revocation_list?: boolean;
      /**
       * @description Set to true to remove stale revocation queue entries that haven't been confirmed by any active cluster. Only runs on the active primary node
       * @default false
       */
      tidy_revocation_queue: boolean;
      /** @description Set to true to validate issuer associations on revocation entries. This helps increase the performance of CRL building and OCSP responses. */
      tidy_revoked_cert_issuer_associations?: boolean;
      /** @description Set to true to expire all revoked and expired certificates, removing them both from the CRL and from storage. The CRL will be rotated if this causes any values to be removed. */
      tidy_revoked_certs?: boolean;
    };
    PkiConfigureAutoTidyResponse: {
      /** @description Safety buffer after creation after which accounts lacking orders are revoked */
      acme_account_safety_buffer?: number;
      /** @description Specifies whether automatic tidy is enabled or not */
      enabled?: boolean;
      /** @description Specifies the duration between automatic tidy operation */
      interval_duration?: number;
      /** @description Issuer safety buffer */
      issuer_safety_buffer?: number;
      maintain_stored_certificate_counts?: boolean;
      /** @description Duration to pause between tidying certificates */
      pause_duration?: string;
      publish_stored_certificate_count_metrics?: boolean;
      revocation_queue_safety_buffer?: number;
      /** @description Safety buffer time duration */
      safety_buffer?: number;
      /** @description Tidy Unused Acme Accounts, and Orders */
      tidy_acme?: boolean;
      /** @description Specifies whether to tidy up the certificate store */
      tidy_cert_store?: boolean;
      /** @description Tidy the cross-cluster revoked certificate store */
      tidy_cross_cluster_revoked_certs?: boolean;
      /** @description Specifies whether tidy expired issuers */
      tidy_expired_issuers?: boolean;
      tidy_move_legacy_ca_bundle?: boolean;
      tidy_revocation_queue?: boolean;
      /** @description Specifies whether to associate revoked certificates with their corresponding issuers */
      tidy_revoked_cert_issuer_associations?: boolean;
      /** @description Specifies whether to remove all invalid and expired certificates from storage */
      tidy_revoked_certs?: boolean;
    };
    PkiConfigureCaRequest: {
      /** @description PEM-format, concatenated unencrypted secret key and certificate. */
      pem_bundle?: string;
    };
    PkiConfigureCaResponse: {
      /** @description Existing issuers specified as part of the import bundle of this request */
      existing_issuers?: string[];
      /** @description Existing keys specified as part of the import bundle of this request */
      existing_keys?: string[];
      /** @description Net-new issuers imported as a part of this request */
      imported_issuers?: string[];
      /** @description Net-new keys imported as a part of this request */
      imported_keys?: string[];
      /**
       * Format: map
       * @description A mapping of issuer_id to key_id for all issuers included in this request
       */
      mapping?: Record<string, never>;
    };
    PkiConfigureClusterRequest: {
      /** @description Optional URI to this mount's AIA distribution point; may refer to an external non-Vault responder. This is for resolving AIA URLs and providing the {{cluster_aia_path}} template parameter and will not be used for other purposes. As such, unlike path above, this could safely be an insecure transit mechanism (like HTTP without TLS). For example: http://cdn.example.com/pr1/pki */
      aia_path?: string;
      /** @description Canonical URI to this mount on this performance replication cluster's external address. This is for resolving AIA URLs and providing the {{cluster_path}} template parameter but might be used for other purposes in the future. This should only point back to this particular PR replica and should not ever point to another PR cluster. It may point to any node in the PR replica, including standby nodes, and need not always point to the active node. For example: https://pr1.vault.example.com:8200/v1/pki */
      path?: string;
    };
    PkiConfigureClusterResponse: {
      /** @description Optional URI to this mount's AIA distribution point; may refer to an external non-Vault responder. This is for resolving AIA URLs and providing the {{cluster_aia_path}} template parameter and will not be used for other purposes. As such, unlike path above, this could safely be an insecure transit mechanism (like HTTP without TLS). For example: http://cdn.example.com/pr1/pki */
      aia_path?: string;
      /** @description Canonical URI to this mount on this performance replication cluster's external address. This is for resolving AIA URLs and providing the {{cluster_path}} template parameter but might be used for other purposes in the future. This should only point back to this particular PR replica and should not ever point to another PR cluster. It may point to any node in the PR replica, including standby nodes, and need not always point to the active node. For example: https://pr1.vault.example.com:8200/v1/pki */
      path?: string;
    };
    PkiConfigureCrlRequest: {
      /** @description If set to true, enables automatic rebuilding of the CRL */
      auto_rebuild?: boolean;
      /**
       * @description The time before the CRL expires to automatically rebuild it, when enabled. Must be shorter than the CRL expiry. Defaults to 12h.
       * @default 12h
       */
      auto_rebuild_grace_period: string;
      /** @description Whether to enable a global, cross-cluster revocation queue. Must be used with auto_rebuild=true. */
      cross_cluster_revocation?: boolean;
      /**
       * @description The time between delta CRL rebuilds if a new revocation has occurred. Must be shorter than the CRL expiry. Defaults to 15m.
       * @default 15m
       */
      delta_rebuild_interval: string;
      /** @description If set to true, disables generating the CRL entirely. */
      disable?: boolean;
      /** @description Whether to enable delta CRLs between authoritative CRL rebuilds */
      enable_delta?: boolean;
      /**
       * @description The amount of time the generated CRL should be valid; defaults to 72 hours
       * @default 72h
       */
      expiry: string;
      /** @description If set to true, ocsp unauthorized responses will be returned. */
      ocsp_disable?: boolean;
      /**
       * @description The amount of time an OCSP response will be valid (controls the NextUpdate field); defaults to 12 hours
       * @default 1h
       */
      ocsp_expiry: string;
      /**
       * @description If set to true enables global replication of revocation entries, also enabling unified versions of OCSP and CRLs if their respective features are enabled. disable for CRLs and ocsp_disable for OCSP.
       * @default false
       */
      unified_crl: boolean;
      /**
       * @description If set to true, existing CRL and OCSP paths will return the unified CRL instead of a response based on cluster-local data
       * @default false
       */
      unified_crl_on_existing_paths: boolean;
    };
    PkiConfigureCrlResponse: {
      /** @description If set to true, enables automatic rebuilding of the CRL */
      auto_rebuild?: boolean;
      /**
       * @description The time before the CRL expires to automatically rebuild it, when enabled. Must be shorter than the CRL expiry. Defaults to 12h.
       * @default 12h
       */
      auto_rebuild_grace_period: string;
      /** @description Whether to enable a global, cross-cluster revocation queue. Must be used with auto_rebuild=true. */
      cross_cluster_revocation?: boolean;
      /**
       * @description The time between delta CRL rebuilds if a new revocation has occurred. Must be shorter than the CRL expiry. Defaults to 15m.
       * @default 15m
       */
      delta_rebuild_interval: string;
      /** @description If set to true, disables generating the CRL entirely. */
      disable?: boolean;
      /** @description Whether to enable delta CRLs between authoritative CRL rebuilds */
      enable_delta?: boolean;
      /**
       * @description The amount of time the generated CRL should be valid; defaults to 72 hours
       * @default 72h
       */
      expiry: string;
      /** @description If set to true, ocsp unauthorized responses will be returned. */
      ocsp_disable?: boolean;
      /**
       * @description The amount of time an OCSP response will be valid (controls the NextUpdate field); defaults to 12 hours
       * @default 1h
       */
      ocsp_expiry: string;
      /** @description If set to true enables global replication of revocation entries, also enabling unified versions of OCSP and CRLs if their respective features are enabled. disable for CRLs and ocsp_disable for OCSP. */
      unified_crl?: boolean;
      /** @description If set to true, existing CRL and OCSP paths will return the unified CRL instead of a response based on cluster-local data */
      unified_crl_on_existing_paths?: boolean;
    };
    PkiConfigureEstRequest: {
      /**
       * Format: map
       * @description A map of authentication type to authentication parameters
       */
      authenticators?: Record<string, never>;
      /**
       * @description Indicates if this mount owns the .well-known/est mount path
       * @default false
       */
      default_mount: boolean;
      /** @description the policy of the default EST responder path, required if default_mount is true */
      default_path_policy?: string;
      /**
       * @description Parse CSR to that its fields can be used by sentinel policies.
       * @default false
       */
      enable_sentinel_parsing: boolean;
      /**
       * @description whether EST is enabled, defaults to false
       * @default false
       */
      enabled: boolean;
      /**
       * Format: map
       * @description The EST label to register and its associated role path
       */
      label_to_path_policy?: Record<string, never>;
    };
    PkiConfigureExternalPolicyRequest: {
      /**
       * @description Whether the external validation engine is enabled at all for this mount
       * @default false
       */
      enabled: boolean;
      /**
       * @description A JMESPath search string that will extract the entity meta data to be sent to the CIEPS service. If blank, none of the entity metadata will be sent to the service.
       * @default
       */
      entity_jmespath: string;
      /**
       * @description The URL where the external policy service is accessible to vault
       * @default
       */
      external_service_url: string;
      /**
       * @description A JMESPath search string that will extract the entity group information to be sent to the CIEPS service. If blank, none of the group entity metadata will be sent to the service.
       * @default
       */
      group_jmespath: string;
      /**
       * Format: duration
       * @description This is how long any particular request should wait for a timeout
       * @default 15
       */
      timeout: string;
      /**
       * @description If this is set, vault will trust any leaf-certificate issued by this certificate to be the external policy service
       * @default
       */
      trusted_ca: string;
      /**
       * @description This is the PEM of the leaf certificate(s) that vault will expect to do certificate pinning
       * @default
       */
      trusted_leaf_certificate_bundle: string;
      /**
       * @description The vault client certificate used to authenticate vault to the external policy engine, and theprivate key to use it.
       * @default
       */
      vault_client_cert_bundle: string;
    };
    PkiConfigureExternalPolicyResponse: {
      /**
       * @description Whether the external validation engine is enabled at all for this mount
       * @default false
       */
      enabled: boolean;
      /**
       * @description A JMESPath search string that will extract the entity meta data to be sent to the CIEPS service. If blank, none of the entity metadata will be sent to the service.
       * @default
       */
      entity_jmespath: string;
      /** @description Timestamp of the last update of the external policy engine configuration, (empty if never configured) */
      external_service_last_updated?: string;
      /**
       * @description The URL where the external policy service is accessible to vault
       * @default
       */
      external_service_url: string;
      /** @description Has the current user configuration been successfully used since the last update */
      external_service_validated?: boolean;
      /**
       * @description A JMESPath search string that will extract the entity group information to be sent to the CIEPS service. If blank, none of the group entity metadata will be sent to the service.
       * @default
       */
      group_jmespath: string;
      /** @description Timestamp of the last successful request with the policy engine (empty if no request has succeeded on this mount) */
      last_successful_request?: string;
      /**
       * Format: duration
       * @description This is how long any particular request should wait for a timeout
       * @default 15
       */
      timeout: string;
      /**
       * @description If this is set, vault will trust any leaf-certificate issued by this certificate to be the external policy service
       * @default
       */
      trusted_ca: string;
      /**
       * @description This is the PEM of the leaf certificate(s) that vault will expect to do certificate pinning
       * @default
       */
      trusted_leaf_certificate_bundle: string;
      /**
       * @description The vault client certificate used to authenticate vault to the external policy engine
       * @default
       */
      vault_client_cert_bundle_no_keys: string;
    };
    PkiConfigureIssuersRequest: {
      /** @description Reference (name or identifier) to the default issuer. */
      default?: string;
      /**
       * @description Whether the default issuer should automatically follow the latest generated or imported issuer. Defaults to false.
       * @default false
       */
      default_follows_latest_issuer: boolean;
    };
    PkiConfigureIssuersResponse: {
      /** @description Reference (name or identifier) to the default issuer. */
      default?: string;
      /** @description Whether the default issuer should automatically follow the latest generated or imported issuer. Defaults to false. */
      default_follows_latest_issuer?: boolean;
    };
    PkiConfigureKeysRequest: {
      /** @description Reference (name or identifier) of the default key. */
      default?: string;
    };
    PkiConfigureKeysResponse: {
      /** @description Reference (name or identifier) to the default issuer. */
      default?: string;
    };
    PkiConfigureUrlsRequest: {
      /** @description Comma-separated list of URLs to be used for the CRL distribution points attribute. See also RFC 5280 Section 4.2.1.13. */
      crl_distribution_points?: string[];
      /**
       * @description Whether or not to enabling templating of the above AIA fields. When templating is enabled the special values '{{issuer_id}}', '{{cluster_path}}', and '{{cluster_aia_path}}' are available, but the addresses are not checked for URI validity until issuance time. Using '{{cluster_path}}' requires /config/cluster's 'path' member to be set on all PR Secondary clusters and using '{{cluster_aia_path}}' requires /config/cluster's 'aia_path' member to be set on all PR secondary clusters.
       * @default false
       */
      enable_templating: boolean;
      /** @description Comma-separated list of URLs to be used for the issuing certificate attribute. See also RFC 5280 Section 4.2.2.1. */
      issuing_certificates?: string[];
      /** @description Comma-separated list of URLs to be used for the OCSP servers attribute. See also RFC 5280 Section 4.2.2.1. */
      ocsp_servers?: string[];
    };
    PkiConfigureUrlsResponse: {
      /** @description Comma-separated list of URLs to be used for the CRL distribution points attribute. See also RFC 5280 Section 4.2.1.13. */
      crl_distribution_points?: string[];
      /**
       * @description Whether or not to enabling templating of the above AIA fields. When templating is enabled the special values '{{issuer_id}}' and '{{cluster_path}}' are available, but the addresses are not checked for URI validity until issuance time. This requires /config/cluster's path to be set on all PR Secondary clusters.
       * @default false
       */
      enable_templating: boolean;
      /** @description Comma-separated list of URLs to be used for the issuing certificate attribute. See also RFC 5280 Section 4.2.2.1. */
      issuing_certificates?: string[];
      /** @description Comma-separated list of URLs to be used for the OCSP servers attribute. See also RFC 5280 Section 4.2.2.1. */
      ocsp_servers?: string[];
    };
    PkiCrossSignIntermediateRequest: {
      /** @description Whether to add a Basic Constraints extension with CA: true. Only needed as a workaround in some compatibility scenarios with Active Directory Certificate Services. */
      add_basic_constraints?: boolean;
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans. */
      common_name?: string;
      /** @description If set, Country will be set to this value. */
      country?: string[];
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description Must be "internal", "exported" or "kms". If set to "exported", the generated private key will be returned. This is your *only* chance to retrieve the private key!
       * @enum {string}
       */
      exported?: 'internal' | 'external' | 'kms';
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, 4096 or 8192; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /** @description Provide a name to the generated or existing key, the name must be unique across all keys and not be the reserved value 'default' */
      key_name?: string;
      /**
       * @description Reference to a existing key; either "default" for the configured default key, an identifier or the name assigned to the key.
       * @default default
       */
      key_ref: string;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519';
      /** @description If set, Locality will be set to this value. */
      locality?: string[];
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types. */
      managed_key_id?: string;
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types. */
      managed_key_name?: string;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /**
       * Format: duration
       * @description The duration before now which the certificate needs to be backdated by.
       * @default 30
       */
      not_before_duration: string;
      /** @description If set, O (Organization) will be set to this value. */
      organization?: string[];
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /** @description If set, OU (OrganizationalUnit) will be set to this value. */
      ou?: string[];
      /** @description If set, Postal Code will be set to this value. */
      postal_code?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /** @description If set, Province will be set to this value. */
      province?: string[];
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).
       * @default 0
       */
      signature_bits: number;
      /** @description If set, Street Address will be set to this value. */
      street_address?: string[];
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
    };
    PkiCrossSignIntermediateResponse: {
      /** @description Certificate signing request. */
      csr?: string;
      /** @description Id of the key. */
      key_id?: string;
      /** @description Generated private key. */
      private_key?: string;
      /** @description Specifies the format used for marshaling the private key. */
      private_key_type?: string;
    };
    PkiGenerateEabKeyForIssuerAndRoleResponse: {
      /** @description The ACME directory to which the key belongs */
      acme_directory?: string;
      /**
       * Format: date-time
       * @description An RFC3339 formatted date time when the EAB token was created
       */
      created_on?: string;
      /** @description The EAB key identifier */
      id?: string;
      /** @description The EAB hmac key */
      key?: string;
      /** @description The EAB key type */
      key_type?: string;
    };
    PkiGenerateEabKeyForIssuerResponse: {
      /** @description The ACME directory to which the key belongs */
      acme_directory?: string;
      /**
       * Format: date-time
       * @description An RFC3339 formatted date time when the EAB token was created
       */
      created_on?: string;
      /** @description The EAB key identifier */
      id?: string;
      /** @description The EAB hmac key */
      key?: string;
      /** @description The EAB key type */
      key_type?: string;
    };
    PkiGenerateEabKeyForRoleResponse: {
      /** @description The ACME directory to which the key belongs */
      acme_directory?: string;
      /**
       * Format: date-time
       * @description An RFC3339 formatted date time when the EAB token was created
       */
      created_on?: string;
      /** @description The EAB key identifier */
      id?: string;
      /** @description The EAB hmac key */
      key?: string;
      /** @description The EAB key type */
      key_type?: string;
    };
    PkiGenerateEabKeyResponse: {
      /** @description The ACME directory to which the key belongs */
      acme_directory?: string;
      /**
       * Format: date-time
       * @description An RFC3339 formatted date time when the EAB token was created
       */
      created_on?: string;
      /** @description The EAB key identifier */
      id?: string;
      /** @description The EAB hmac key */
      key?: string;
      /** @description The EAB key type */
      key_type?: string;
    };
    PkiGenerateExportedKeyRequest: {
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, 4096 or 8192; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /** @description Optional name to be used for this key */
      key_name?: string;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519';
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types. */
      managed_key_id?: string;
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types. */
      managed_key_name?: string;
    };
    PkiGenerateExportedKeyResponse: {
      /** @description ID assigned to this key. */
      key_id?: string;
      /** @description Name assigned to this key. */
      key_name?: string;
      /** @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values. */
      key_type?: string;
      /** @description The private key string */
      private_key?: string;
    };
    PkiGenerateIntermediateRequest: {
      /** @description Whether to add a Basic Constraints extension with CA: true. Only needed as a workaround in some compatibility scenarios with Active Directory Certificate Services. */
      add_basic_constraints?: boolean;
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans. */
      common_name?: string;
      /** @description If set, Country will be set to this value. */
      country?: string[];
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, 4096 or 8192; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /** @description Provide a name to the generated or existing key, the name must be unique across all keys and not be the reserved value 'default' */
      key_name?: string;
      /**
       * @description Reference to a existing key; either "default" for the configured default key, an identifier or the name assigned to the key.
       * @default default
       */
      key_ref: string;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519';
      /** @description If set, Locality will be set to this value. */
      locality?: string[];
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types. */
      managed_key_id?: string;
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types. */
      managed_key_name?: string;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /**
       * Format: duration
       * @description The duration before now which the certificate needs to be backdated by.
       * @default 30
       */
      not_before_duration: string;
      /** @description If set, O (Organization) will be set to this value. */
      organization?: string[];
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /** @description If set, OU (OrganizationalUnit) will be set to this value. */
      ou?: string[];
      /** @description If set, Postal Code will be set to this value. */
      postal_code?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /** @description If set, Province will be set to this value. */
      province?: string[];
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).
       * @default 0
       */
      signature_bits: number;
      /** @description If set, Street Address will be set to this value. */
      street_address?: string[];
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
    };
    PkiGenerateIntermediateResponse: {
      /** @description Certificate signing request. */
      csr?: string;
      /** @description Id of the key. */
      key_id?: string;
      /** @description Generated private key. */
      private_key?: string;
      /** @description Specifies the format used for marshaling the private key. */
      private_key_type?: string;
    };
    PkiGenerateInternalKeyRequest: {
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, 4096 or 8192; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /** @description Optional name to be used for this key */
      key_name?: string;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519';
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types. */
      managed_key_id?: string;
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types. */
      managed_key_name?: string;
    };
    PkiGenerateInternalKeyResponse: {
      /** @description ID assigned to this key. */
      key_id?: string;
      /** @description Name assigned to this key. */
      key_name?: string;
      /** @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values. */
      key_type?: string;
      /** @description The private key string */
      private_key?: string;
    };
    PkiGenerateKmsKeyRequest: {
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, 4096 or 8192; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /** @description Optional name to be used for this key */
      key_name?: string;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519';
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types. */
      managed_key_id?: string;
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types. */
      managed_key_name?: string;
    };
    PkiGenerateKmsKeyResponse: {
      /** @description ID assigned to this key. */
      key_id?: string;
      /** @description Name assigned to this key. */
      key_name?: string;
      /** @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values. */
      key_type?: string;
      /** @description The private key string */
      private_key?: string;
    };
    PkiGenerateRootRequest: {
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans. */
      common_name?: string;
      /** @description If set, Country will be set to this value. */
      country?: string[];
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /** @description Provide a name to the generated or existing issuer, the name must be unique across all issuers and not be the reserved value 'default' */
      issuer_name?: string;
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, 4096 or 8192; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /** @description Provide a name to the generated or existing key, the name must be unique across all keys and not be the reserved value 'default' */
      key_name?: string;
      /**
       * @description Reference to a existing key; either "default" for the configured default key, an identifier or the name assigned to the key.
       * @default default
       */
      key_ref: string;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519';
      /** @description If set, Locality will be set to this value. */
      locality?: string[];
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types. */
      managed_key_id?: string;
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types. */
      managed_key_name?: string;
      /**
       * @description The maximum allowable path length
       * @default -1
       */
      max_path_length: number;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /**
       * Format: duration
       * @description The duration before now which the certificate needs to be backdated by.
       * @default 30
       */
      not_before_duration: string;
      /** @description If set, O (Organization) will be set to this value. */
      organization?: string[];
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /** @description If set, OU (OrganizationalUnit) will be set to this value. */
      ou?: string[];
      /** @description Domains for which this certificate is allowed to sign or issue child certificates. If set, all DNS names (subject and alt) on child certs must be exact matches or subsets of the given domains (see https://tools.ietf.org/html/rfc5280#section-4.2.1.10). */
      permitted_dns_domains?: string[];
      /** @description If set, Postal Code will be set to this value. */
      postal_code?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /** @description If set, Province will be set to this value. */
      province?: string[];
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).
       * @default 0
       */
      signature_bits: number;
      /** @description If set, Street Address will be set to this value. */
      street_address?: string[];
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
      /**
       * @description Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.
       * @default false
       */
      use_pss: boolean;
    };
    PkiGenerateRootResponse: {
      /** @description The generated self-signed CA certificate. */
      certificate?: string;
      /**
       * Format: int64
       * @description The expiration of the given issuer.
       */
      expiration?: number;
      /** @description The ID of the issuer */
      issuer_id?: string;
      /** @description The name of the issuer. */
      issuer_name?: string;
      /** @description The issuing certificate authority. */
      issuing_ca?: string;
      /** @description The ID of the key. */
      key_id?: string;
      /** @description The key name if given. */
      key_name?: string;
      /** @description The private key if exported was specified. */
      private_key?: string;
      /** @description The requested Subject's named serial number. */
      serial_number?: string;
    };
    PkiImportKeyRequest: {
      /** @description Optional name to be used for this key */
      key_name?: string;
      /** @description PEM-format, unencrypted secret key */
      pem_bundle?: string;
    };
    PkiImportKeyResponse: {
      /** @description ID assigned to this key. */
      key_id?: string;
      /** @description Name assigned to this key. */
      key_name?: string;
      /** @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values. */
      key_type?: string;
    };
    PkiIssueWithRoleRequest: {
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address. */
      common_name?: string;
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /**
       * @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer.
       * @default default
       */
      issuer_ref: string;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
      /** @description The requested user_ids value to place in the subject, if any, in a comma-delimited list. Restricted by allowed_user_ids. Any values are added with OID 0.9.2342.19200300.100.1.1. */
      user_ids?: string[];
    };
    PkiIssueWithRoleResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Private key */
      private_key?: string;
      /** @description Private key type */
      private_key_type?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiIssuerIssueWithRoleRequest: {
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address. */
      common_name?: string;
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
      /** @description The requested user_ids value to place in the subject, if any, in a comma-delimited list. Restricted by allowed_user_ids. Any values are added with OID 0.9.2342.19200300.100.1.1. */
      user_ids?: string[];
    };
    PkiIssuerIssueWithRoleResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Private key */
      private_key?: string;
      /** @description Private key type */
      private_key_type?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiIssuerReadCrlDeltaDerResponse: {
      crl?: string;
    };
    PkiIssuerReadCrlDeltaPemResponse: {
      crl?: string;
    };
    PkiIssuerReadCrlDeltaResponse: {
      crl?: string;
    };
    PkiIssuerReadCrlDerResponse: {
      crl?: string;
    };
    PkiIssuerReadCrlPemResponse: {
      crl?: string;
    };
    PkiIssuerReadCrlResponse: {
      crl?: string;
    };
    PkiIssuerReadUnifiedCrlDeltaDerResponse: {
      crl?: string;
    };
    PkiIssuerReadUnifiedCrlDeltaPemResponse: {
      crl?: string;
    };
    PkiIssuerReadUnifiedCrlDeltaResponse: {
      crl?: string;
    };
    PkiIssuerReadUnifiedCrlDerResponse: {
      crl?: string;
    };
    PkiIssuerReadUnifiedCrlPemResponse: {
      crl?: string;
    };
    PkiIssuerReadUnifiedCrlResponse: {
      crl?: string;
    };
    PkiIssuerResignCrlsRequest: {
      /** @description The sequence number to be written within the CRL Number extension. */
      crl_number?: number;
      /** @description A list of PEM encoded CRLs to combine, originally signed by the requested issuer. */
      crls?: string[];
      /**
       * @description Using a zero or greater value specifies the base CRL revision number to encode within a Delta CRL indicator extension, otherwise the extension will not be added.
       * @default -1
       */
      delta_crl_base_number: number;
      /**
       * @description The format of the combined CRL, can be "pem" or "der". If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       */
      format: string;
      /**
       * @description The amount of time the generated CRL should be valid; defaults to 72 hours.
       * @default 72h
       */
      next_update: string;
    };
    PkiIssuerResignCrlsResponse: {
      /** @description CRL */
      crl?: string;
    };
    PkiIssuerSignIntermediateRequest: {
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans. */
      common_name?: string;
      /** @description If set, Country will be set to this value. */
      country?: string[];
      /**
       * @description PEM-format CSR to be signed.
       * @default
       */
      csr: string;
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /** @description Provide a name to the generated or existing issuer, the name must be unique across all issuers and not be the reserved value 'default' */
      issuer_name?: string;
      /** @description If set, Locality will be set to this value. */
      locality?: string[];
      /**
       * @description The maximum allowable path length
       * @default -1
       */
      max_path_length: number;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /**
       * Format: duration
       * @description The duration before now which the certificate needs to be backdated by.
       * @default 30
       */
      not_before_duration: string;
      /** @description If set, O (Organization) will be set to this value. */
      organization?: string[];
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /** @description If set, OU (OrganizationalUnit) will be set to this value. */
      ou?: string[];
      /** @description Domains for which this certificate is allowed to sign or issue child certificates. If set, all DNS names (subject and alt) on child certs must be exact matches or subsets of the given domains (see https://tools.ietf.org/html/rfc5280#section-4.2.1.10). */
      permitted_dns_domains?: string[];
      /** @description If set, Postal Code will be set to this value. */
      postal_code?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /** @description If set, Province will be set to this value. */
      province?: string[];
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).
       * @default 0
       */
      signature_bits: number;
      /**
       * @description Value for the Subject Key Identifier field (RFC 5280 Section 4.2.1.2). This value should ONLY be used when cross-signing to mimic the existing certificate's SKID value; this is necessary to allow certain TLS implementations (such as OpenSSL) which use SKID/AKID matches in chain building to restrict possible valid chains. Specified as a string in hex format. Default is empty, allowing Vault to automatically calculate the SKID according to method one in the above RFC section.
       * @default
       */
      skid: string;
      /** @description If set, Street Address will be set to this value. */
      street_address?: string[];
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
      /**
       * @description If true, then: 1) Subject information, including names and alternate names, will be preserved from the CSR rather than using values provided in the other parameters to this path; 2) Any key usages requested in the CSR will be added to the basic set of key usages used for CA certs signed by this path; for instance, the non-repudiation flag; 3) Extensions requested in the CSR will be copied into the issued certificate.
       * @default false
       */
      use_csr_values: boolean;
      /**
       * @description Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.
       * @default false
       */
      use_pss: boolean;
    };
    PkiIssuerSignIntermediateResponse: {
      /** @description CA Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Expiration Time
       */
      expiration?: number;
      /** @description Issuing CA */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiIssuerSignRevocationListRequest: {
      /** @description The sequence number to be written within the CRL Number extension. */
      crl_number?: number;
      /**
       * @description Using a zero or greater value specifies the base CRL revision number to encode within a Delta CRL indicator extension, otherwise the extension will not be added.
       * @default -1
       */
      delta_crl_base_number: number;
      /** @description A list of maps containing extensions with keys id (string), critical (bool), value (string) */
      extensions?: Record<string, never>[];
      /**
       * @description The format of the combined CRL, can be "pem" or "der". If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       */
      format: string;
      /**
       * @description The amount of time the generated CRL should be valid; defaults to 72 hours.
       * @default 72h
       */
      next_update: string;
      /** @description A list of maps containing the keys serial_number (string), revocation_time (string), and extensions (map with keys id (string), critical (bool), value (string)) */
      revoked_certs?: Record<string, never>[];
    };
    PkiIssuerSignRevocationListResponse: {
      /** @description CRL */
      crl?: string;
    };
    PkiIssuerSignSelfIssuedRequest: {
      /** @description PEM-format self-issued certificate to be signed. */
      certificate?: string;
      /**
       * @description If true, require the public key algorithm of the signer to match that of the self issued certificate.
       * @default false
       */
      require_matching_certificate_algorithms: boolean;
    };
    PkiIssuerSignSelfIssuedResponse: {
      /** @description Certificate */
      certificate?: string;
      /** @description Issuing CA */
      issuing_ca?: string;
    };
    PkiIssuerSignVerbatimRequest: {
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address. */
      common_name?: string;
      /**
       * @description PEM-format CSR to be signed. Values will be taken verbatim from the CSR, except for basic constraints.
       * @default
       */
      csr: string;
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the "ExtKeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list.
       * @default []
       */
      ext_key_usage: string[];
      /**
       * @description A comma-separated string or list of extended key usage oids.
       * @default []
       */
      ext_key_usage_oids: string[];
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /**
       * @description A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the "KeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list.
       * @default [
       *       "DigitalSignature",
       *       "KeyAgreement",
       *       "KeyEncipherment"
       *     ]
       */
      key_usage: string[];
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).
       * @default 0
       */
      signature_bits: number;
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
      /**
       * @description Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.
       * @default false
       */
      use_pss: boolean;
      /** @description The requested user_ids value to place in the subject, if any, in a comma-delimited list. Restricted by allowed_user_ids. Any values are added with OID 0.9.2342.19200300.100.1.1. */
      user_ids?: string[];
    };
    PkiIssuerSignVerbatimResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiIssuerSignVerbatimWithRoleRequest: {
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address. */
      common_name?: string;
      /**
       * @description PEM-format CSR to be signed. Values will be taken verbatim from the CSR, except for basic constraints.
       * @default
       */
      csr: string;
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the "ExtKeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list.
       * @default []
       */
      ext_key_usage: string[];
      /**
       * @description A comma-separated string or list of extended key usage oids.
       * @default []
       */
      ext_key_usage_oids: string[];
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /**
       * @description A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the "KeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list.
       * @default [
       *       "DigitalSignature",
       *       "KeyAgreement",
       *       "KeyEncipherment"
       *     ]
       */
      key_usage: string[];
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).
       * @default 0
       */
      signature_bits: number;
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
      /**
       * @description Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.
       * @default false
       */
      use_pss: boolean;
      /** @description The requested user_ids value to place in the subject, if any, in a comma-delimited list. Restricted by allowed_user_ids. Any values are added with OID 0.9.2342.19200300.100.1.1. */
      user_ids?: string[];
    };
    PkiIssuerSignVerbatimWithRoleResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiIssuerSignWithRoleRequest: {
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address. */
      common_name?: string;
      /**
       * @description PEM-format CSR to be signed.
       * @default
       */
      csr: string;
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
      /** @description The requested user_ids value to place in the subject, if any, in a comma-delimited list. Restricted by allowed_user_ids. Any values are added with OID 0.9.2342.19200300.100.1.1. */
      user_ids?: string[];
    };
    PkiIssuerSignWithRoleResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiIssuersGenerateIntermediateRequest: {
      /** @description Whether to add a Basic Constraints extension with CA: true. Only needed as a workaround in some compatibility scenarios with Active Directory Certificate Services. */
      add_basic_constraints?: boolean;
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans. */
      common_name?: string;
      /** @description If set, Country will be set to this value. */
      country?: string[];
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, 4096 or 8192; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /** @description Provide a name to the generated or existing key, the name must be unique across all keys and not be the reserved value 'default' */
      key_name?: string;
      /**
       * @description Reference to a existing key; either "default" for the configured default key, an identifier or the name assigned to the key.
       * @default default
       */
      key_ref: string;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519';
      /** @description If set, Locality will be set to this value. */
      locality?: string[];
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types. */
      managed_key_id?: string;
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types. */
      managed_key_name?: string;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /**
       * Format: duration
       * @description The duration before now which the certificate needs to be backdated by.
       * @default 30
       */
      not_before_duration: string;
      /** @description If set, O (Organization) will be set to this value. */
      organization?: string[];
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /** @description If set, OU (OrganizationalUnit) will be set to this value. */
      ou?: string[];
      /** @description If set, Postal Code will be set to this value. */
      postal_code?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /** @description If set, Province will be set to this value. */
      province?: string[];
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).
       * @default 0
       */
      signature_bits: number;
      /** @description If set, Street Address will be set to this value. */
      street_address?: string[];
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
    };
    PkiIssuersGenerateIntermediateResponse: {
      /** @description Certificate signing request. */
      csr?: string;
      /** @description Id of the key. */
      key_id?: string;
      /** @description Generated private key. */
      private_key?: string;
      /** @description Specifies the format used for marshaling the private key. */
      private_key_type?: string;
    };
    PkiIssuersGenerateRootRequest: {
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans. */
      common_name?: string;
      /** @description If set, Country will be set to this value. */
      country?: string[];
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /** @description Provide a name to the generated or existing issuer, the name must be unique across all issuers and not be the reserved value 'default' */
      issuer_name?: string;
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, 4096 or 8192; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /** @description Provide a name to the generated or existing key, the name must be unique across all keys and not be the reserved value 'default' */
      key_name?: string;
      /**
       * @description Reference to a existing key; either "default" for the configured default key, an identifier or the name assigned to the key.
       * @default default
       */
      key_ref: string;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519';
      /** @description If set, Locality will be set to this value. */
      locality?: string[];
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types. */
      managed_key_id?: string;
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types. */
      managed_key_name?: string;
      /**
       * @description The maximum allowable path length
       * @default -1
       */
      max_path_length: number;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /**
       * Format: duration
       * @description The duration before now which the certificate needs to be backdated by.
       * @default 30
       */
      not_before_duration: string;
      /** @description If set, O (Organization) will be set to this value. */
      organization?: string[];
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /** @description If set, OU (OrganizationalUnit) will be set to this value. */
      ou?: string[];
      /** @description Domains for which this certificate is allowed to sign or issue child certificates. If set, all DNS names (subject and alt) on child certs must be exact matches or subsets of the given domains (see https://tools.ietf.org/html/rfc5280#section-4.2.1.10). */
      permitted_dns_domains?: string[];
      /** @description If set, Postal Code will be set to this value. */
      postal_code?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /** @description If set, Province will be set to this value. */
      province?: string[];
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).
       * @default 0
       */
      signature_bits: number;
      /** @description If set, Street Address will be set to this value. */
      street_address?: string[];
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
      /**
       * @description Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.
       * @default false
       */
      use_pss: boolean;
    };
    PkiIssuersGenerateRootResponse: {
      /** @description The generated self-signed CA certificate. */
      certificate?: string;
      /**
       * Format: int64
       * @description The expiration of the given issuer.
       */
      expiration?: number;
      /** @description The ID of the issuer */
      issuer_id?: string;
      /** @description The name of the issuer. */
      issuer_name?: string;
      /** @description The issuing certificate authority. */
      issuing_ca?: string;
      /** @description The ID of the key. */
      key_id?: string;
      /** @description The key name if given. */
      key_name?: string;
      /** @description The private key if exported was specified. */
      private_key?: string;
      /** @description The requested Subject's named serial number. */
      serial_number?: string;
    };
    PkiIssuersImportBundleRequest: {
      /** @description PEM-format, concatenated unencrypted secret-key (optional) and certificates. */
      pem_bundle?: string;
    };
    PkiIssuersImportBundleResponse: {
      /** @description Existing issuers specified as part of the import bundle of this request */
      existing_issuers?: string[];
      /** @description Existing keys specified as part of the import bundle of this request */
      existing_keys?: string[];
      /** @description Net-new issuers imported as a part of this request */
      imported_issuers?: string[];
      /** @description Net-new keys imported as a part of this request */
      imported_keys?: string[];
      /**
       * Format: map
       * @description A mapping of issuer_id to key_id for all issuers included in this request
       */
      mapping?: Record<string, never>;
    };
    PkiIssuersImportCertRequest: {
      /** @description PEM-format, concatenated unencrypted secret-key (optional) and certificates. */
      pem_bundle?: string;
    };
    PkiIssuersImportCertResponse: {
      /** @description Existing issuers specified as part of the import bundle of this request */
      existing_issuers?: string[];
      /** @description Existing keys specified as part of the import bundle of this request */
      existing_keys?: string[];
      /** @description Net-new issuers imported as a part of this request */
      imported_issuers?: string[];
      /** @description Net-new keys imported as a part of this request */
      imported_keys?: string[];
      /**
       * Format: map
       * @description A mapping of issuer_id to key_id for all issuers included in this request
       */
      mapping?: Record<string, never>;
    };
    PkiListEabKeysResponse: {
      /**
       * Format: map
       * @description EAB details keyed by the eab key id
       */
      key_info?: Record<string, never>;
      /** @description A list of unused eab keys */
      keys?: string[];
    };
    PkiListIssuersResponse: {
      /**
       * Format: map
       * @description Key info with issuer name
       */
      key_info?: Record<string, never>;
      /** @description A list of keys */
      keys?: string[];
    };
    PkiListKeysResponse: {
      /**
       * Format: map
       * @description Key info with issuer name
       */
      key_info?: Record<string, never>;
      /** @description A list of keys */
      keys?: string[];
    };
    PkiListUnifiedRevokedCertsResponse: {
      /** @description Key information */
      key_info?: string;
      /** @description List of Keys */
      keys?: string[];
    };
    PkiPatchIssuerResponse: {
      /** @description CA Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /** @description CRL Distribution Points */
      crl_distribution_points?: string[];
      /** @description Whether or not templating is enabled for AIA fields */
      enable_aia_url_templating?: boolean;
      /** @description Issuer Id */
      issuer_id?: string;
      /** @description Issuer Name */
      issuer_name?: string;
      /** @description Issuing Certificates */
      issuing_certificates?: string[];
      /** @description Key Id */
      key_id?: string;
      /** @description Leaf Not After Behavior */
      leaf_not_after_behavior?: string;
      /** @description Manual Chain */
      manual_chain?: string[];
      /** @description OCSP Servers */
      ocsp_servers?: string[];
      /** @description Revocation Signature Alogrithm */
      revocation_signature_algorithm?: string;
      revocation_time?: number;
      revocation_time_rfc3339?: string;
      /** @description Revoked */
      revoked?: boolean;
      /** @description Usage */
      usage?: string;
    };
    PkiPatchRoleResponse: {
      /** @description If set, clients can request certificates for any domain, regardless of allowed_domains restrictions. See the documentation for more information. */
      allow_any_name?: boolean;
      /** @description If set, clients can request certificates for the base domains themselves, e.g. "example.com" of domains listed in allowed_domains. This is a separate option as in some cases this can be considered a security threat. See the documentation for more information. */
      allow_bare_domains?: boolean;
      /** @description If set, domains specified in allowed_domains can include shell-style glob patterns, e.g. "ftp*.example.com". See the documentation for more information. */
      allow_glob_domains?: boolean;
      /** @description If set, IP Subject Alternative Names are allowed. Any valid IP is accepted and No authorization checking is performed. */
      allow_ip_sans?: boolean;
      /** @description Whether to allow "localhost" and "localdomain" as a valid common name in a request, independent of allowed_domains value. */
      allow_localhost?: boolean;
      /** @description If set, clients can request certificates for subdomains of domains listed in allowed_domains, including wildcard subdomains. See the documentation for more information. */
      allow_subdomains?: boolean;
      /** @description Whether to allow "localhost" and "localdomain" as a valid common name in a request, independent of allowed_domains value. */
      allow_token_displayname?: boolean;
      /** @description If set, allows certificates with wildcards in the common name to be issued, conforming to RFC 6125's Section 6.4.3; e.g., "*.example.net" or "b*z.example.net". See the documentation for more information. */
      allow_wildcard_certificates?: boolean;
      /** @description Specifies the domains this role is allowed to issue certificates for. This is used with the allow_bare_domains, allow_subdomains, and allow_glob_domains to determine matches for the common name, DNS-typed SAN entries, and Email-typed SAN entries of certificates. See the documentation for more information. This parameter accepts a comma-separated string or list of domains. */
      allowed_domains?: string[];
      /** @description If set, Allowed domains can be specified using identity template policies. Non-templated domains are also permitted. */
      allowed_domains_template?: boolean;
      /** @description If set, an array of allowed other names to put in SANs. These values support globbing and must be in the format <oid>;<type>:<value>. Currently only "utf8" is a valid type. All values, including globbing values, must use this syntax, with the exception being a single "*" which allows any OID and any value (but type must still be utf8). */
      allowed_other_sans?: string[];
      /** @description If set, an array of allowed serial numbers to put in Subject. These values support globbing. */
      allowed_serial_numbers?: string[];
      /** @description If set, an array of allowed URIs for URI Subject Alternative Names. Any valid URI is accepted, these values support globbing. */
      allowed_uri_sans?: string[];
      /** @description If set, Allowed URI SANs can be specified using identity template policies. Non-templated URI SANs are also permitted. */
      allowed_uri_sans_template?: boolean;
      /** @description If set, an array of allowed user-ids to put in user system login name specified here: https://www.rfc-editor.org/rfc/rfc1274#section-9.3.1 */
      allowed_user_ids?: string[];
      /** @description Mark Basic Constraints valid when issuing non-CA certificates. */
      basic_constraints_valid_for_non_ca?: boolean;
      /** @description If set, certificates are flagged for client auth use. Defaults to true. See also RFC 5280 Section 4.2.1.12. */
      client_flag?: boolean;
      /** @description List of allowed validations to run against the Common Name field. Values can include 'email' to validate the CN is a email address, 'hostname' to validate the CN is a valid hostname (potentially including wildcards). When multiple validations are specified, these take OR semantics (either email OR hostname are allowed). The special value 'disabled' allows disabling all CN name validations, allowing for arbitrary non-Hostname, non-Email address CNs. */
      cn_validations?: string[];
      /** @description If set, certificates are flagged for code signing use. Defaults to false. See also RFC 5280 Section 4.2.1.12. */
      code_signing_flag?: boolean;
      /** @description If set, Country will be set to this value in certificates issued by this role. */
      country?: string[];
      /** @description If set, certificates are flagged for email protection use. Defaults to false. See also RFC 5280 Section 4.2.1.12. */
      email_protection_flag?: boolean;
      /** @description If set, only valid host names are allowed for CN and DNS SANs, and the host part of email addresses. Defaults to true. */
      enforce_hostnames?: boolean;
      /** @description A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the "ExtKeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list. See also RFC 5280 Section 4.2.1.12. */
      ext_key_usage?: string[];
      /** @description A comma-separated string or list of extended key usage oids. */
      ext_key_usage_oids?: string[];
      /** @description If set, certificates issued/signed against this role will have Vault leases attached to them. Defaults to "false". Certificates can be added to the CRL by "vault revoke <lease_id>" when certificates are associated with leases. It can also be done using the "pki/revoke" endpoint. However, when lease generation is disabled, invoking "pki/revoke" would be the only way to add the certificates to the CRL. When large number of certificates are generated with long lifetimes, it is recommended that lease generation be disabled, as large amount of leases adversely affect the startup time of Vault. */
      generate_lease?: boolean;
      /** @description Reference to the issuer used to sign requests serviced by this role. */
      issuer_ref?: string;
      /** @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519. */
      key_bits?: number;
      /** @description The type of key to use; defaults to RSA. "rsa" "ec", "ed25519" and "any" are the only valid values. */
      key_type?: string;
      /** @description A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the "KeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list. See also RFC 5280 Section 4.2.1.3. */
      key_usage?: string[];
      /** @description If set, Locality will be set to this value in certificates issued by this role. */
      locality?: string[];
      /**
       * Format: int64
       * @description The maximum allowed lease duration. If not set, defaults to the system maximum lease TTL.
       */
      max_ttl?: number;
      /** @description If set, certificates issued/signed against this role will not be stored in the storage backend. This can improve performance when issuing large numbers of certificates. However, certificates issued in this way cannot be enumerated or revoked, so this option is recommended only for certificates that are non-sensitive, or extremely short-lived. This option implies a value of "false" for "generate_lease". */
      no_store?: boolean;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ. */
      not_after?: string;
      /**
       * Format: int64
       * @description The duration in seconds before now which the certificate needs to be backdated by.
       */
      not_before_duration?: number;
      /** @description If set, O (Organization) will be set to this value in certificates issued by this role. */
      organization?: string[];
      /** @description If set, OU (OrganizationalUnit) will be set to this value in certificates issued by this role. */
      ou?: string[];
      /** @description A comma-separated string or list of policy OIDs, or a JSON list of qualified policy information, which must include an oid, and may include a notice and/or cps url, using the form [{"oid"="1.3.6.1.4.1.7.8","notice"="I am a user Notice"}, {"oid"="1.3.6.1.4.1.44947.1.2.4 ","cps"="https://example.com"}]. */
      policy_identifiers?: string[];
      /** @description If set, Postal Code will be set to this value in certificates issued by this role. */
      postal_code?: string[];
      /** @description If set, Province will be set to this value in certificates issued by this role. */
      province?: string[];
      /** @description If set to false, makes the 'common_name' field optional while generating a certificate. */
      require_cn?: boolean;
      /**
       * @description If set, certificates are flagged for server auth use. Defaults to true. See also RFC 5280 Section 4.2.1.12.
       * @default true
       */
      server_flag: boolean;
      /** @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves). */
      signature_bits?: number;
      /** @description If set, Street Address will be set to this value in certificates issued by this role. */
      street_address?: string[];
      /**
       * Format: int64
       * @description The lease duration (validity period of the certificate) if no specific lease duration is requested. The lease duration controls the expiration of certificates issued by this backend. Defaults to the system default value or the value of max_ttl, whichever is shorter.
       */
      ttl?: number;
      /** @description If set, when used with a signing profile, the common name in the CSR will be used. This does *not* include any requested Subject Alternative Names; use use_csr_sans for that. Defaults to true. */
      use_csr_common_name?: boolean;
      /** @description If set, when used with a signing profile, the SANs in the CSR will be used. This does *not* include the Common Name (cn); use use_csr_common_name for that. Defaults to true. */
      use_csr_sans?: boolean;
      /** @description Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false. */
      use_pss?: boolean;
    };
    PkiReadAutoTidyConfigurationResponse: {
      /** @description Safety buffer after creation after which accounts lacking orders are revoked */
      acme_account_safety_buffer?: number;
      /** @description Specifies whether automatic tidy is enabled or not */
      enabled?: boolean;
      /** @description Specifies the duration between automatic tidy operation */
      interval_duration?: number;
      /** @description Issuer safety buffer */
      issuer_safety_buffer?: number;
      maintain_stored_certificate_counts?: boolean;
      /** @description Duration to pause between tidying certificates */
      pause_duration?: string;
      publish_stored_certificate_count_metrics?: boolean;
      revocation_queue_safety_buffer?: number;
      /** @description Safety buffer time duration */
      safety_buffer?: number;
      /** @description Tidy Unused Acme Accounts, and Orders */
      tidy_acme?: boolean;
      /** @description Specifies whether to tidy up the certificate store */
      tidy_cert_store?: boolean;
      tidy_cross_cluster_revoked_certs?: boolean;
      /** @description Specifies whether tidy expired issuers */
      tidy_expired_issuers?: boolean;
      tidy_move_legacy_ca_bundle?: boolean;
      tidy_revocation_queue?: boolean;
      /** @description Specifies whether to associate revoked certificates with their corresponding issuers */
      tidy_revoked_cert_issuer_associations?: boolean;
      /** @description Specifies whether to remove all invalid and expired certificates from storage */
      tidy_revoked_certs?: boolean;
    };
    PkiReadCaChainPemResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadCaDerResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadCaPemResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadCertCaChainResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadCertCrlResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadCertDeltaCrlResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadCertRawDerResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadCertRawPemResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadCertResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadCertUnifiedCrlResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadCertUnifiedDeltaCrlResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadClusterConfigurationResponse: {
      /** @description Optional URI to this mount's AIA distribution point; may refer to an external non-Vault responder. This is for resolving AIA URLs and providing the {{cluster_aia_path}} template parameter and will not be used for other purposes. As such, unlike path above, this could safely be an insecure transit mechanism (like HTTP without TLS). For example: http://cdn.example.com/pr1/pki */
      aia_path?: string;
      /** @description Canonical URI to this mount on this performance replication cluster's external address. This is for resolving AIA URLs and providing the {{cluster_path}} template parameter but might be used for other purposes in the future. This should only point back to this particular PR replica and should not ever point to another PR cluster. It may point to any node in the PR replica, including standby nodes, and need not always point to the active node. For example: https://pr1.vault.example.com:8200/v1/pki */
      path?: string;
    };
    PkiReadCrlConfigurationResponse: {
      /** @description If set to true, enables automatic rebuilding of the CRL */
      auto_rebuild?: boolean;
      /** @description The time before the CRL expires to automatically rebuild it, when enabled. Must be shorter than the CRL expiry. Defaults to 12h. */
      auto_rebuild_grace_period?: string;
      /** @description Whether to enable a global, cross-cluster revocation queue. Must be used with auto_rebuild=true. */
      cross_cluster_revocation?: boolean;
      /** @description The time between delta CRL rebuilds if a new revocation has occurred. Must be shorter than the CRL expiry. Defaults to 15m. */
      delta_rebuild_interval?: string;
      /** @description If set to true, disables generating the CRL entirely. */
      disable?: boolean;
      /** @description Whether to enable delta CRLs between authoritative CRL rebuilds */
      enable_delta?: boolean;
      /** @description The amount of time the generated CRL should be valid; defaults to 72 hours */
      expiry?: string;
      /** @description If set to true, ocsp unauthorized responses will be returned. */
      ocsp_disable?: boolean;
      /** @description The amount of time an OCSP response will be valid (controls the NextUpdate field); defaults to 12 hours */
      ocsp_expiry?: string;
      /** @description If set to true enables global replication of revocation entries, also enabling unified versions of OCSP and CRLs if their respective features are enabled. disable for CRLs and ocsp_disable for OCSP. */
      unified_crl?: boolean;
      /** @description If set to true, existing CRL and OCSP paths will return the unified CRL instead of a response based on cluster-local data */
      unified_crl_on_existing_paths?: boolean;
    };
    PkiReadCrlDeltaPemResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadCrlDeltaResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadCrlDerResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadCrlPemResponse: {
      /** @description Issuing CA Chain */
      ca_chain?: string;
      /** @description Certificate */
      certificate?: string;
      /** @description ID of the issuer */
      issuer_id?: string;
      /**
       * Format: int64
       * @description Revocation time
       */
      revocation_time?: number;
      /** @description Revocation time RFC 3339 formatted */
      revocation_time_rfc3339?: string;
    };
    PkiReadIssuerDerResponse: {
      /** @description CA Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /** @description Issuer Id */
      issuer_id?: string;
      /** @description Issuer Name */
      issuer_name?: string;
    };
    PkiReadIssuerJsonResponse: {
      /** @description CA Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /** @description Issuer Id */
      issuer_id?: string;
      /** @description Issuer Name */
      issuer_name?: string;
    };
    PkiReadIssuerPemResponse: {
      /** @description CA Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /** @description Issuer Id */
      issuer_id?: string;
      /** @description Issuer Name */
      issuer_name?: string;
    };
    PkiReadIssuerResponse: {
      /** @description CA Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /** @description CRL Distribution Points */
      crl_distribution_points?: string[];
      /** @description Whether or not templating is enabled for AIA fields */
      enable_aia_url_templating?: boolean;
      /** @description Issuer Id */
      issuer_id?: string;
      /** @description Issuer Name */
      issuer_name?: string;
      /** @description Issuing Certificates */
      issuing_certificates?: string[];
      /** @description Key Id */
      key_id?: string;
      /** @description Leaf Not After Behavior */
      leaf_not_after_behavior?: string;
      /** @description Manual Chain */
      manual_chain?: string[];
      /** @description OCSP Servers */
      ocsp_servers?: string[];
      /** @description Revocation Signature Alogrithm */
      revocation_signature_algorithm?: string;
      revocation_time?: number;
      revocation_time_rfc3339?: string;
      /** @description Revoked */
      revoked?: boolean;
      /** @description Usage */
      usage?: string;
    };
    PkiReadIssuersConfigurationResponse: {
      /** @description Reference (name or identifier) to the default issuer. */
      default?: string;
      /** @description Whether the default issuer should automatically follow the latest generated or imported issuer. Defaults to false. */
      default_follows_latest_issuer?: boolean;
    };
    PkiReadKeyResponse: {
      /** @description Key Id */
      key_id?: string;
      /** @description Key Name */
      key_name?: string;
      /** @description Key Type */
      key_type?: string;
      /** @description Managed Key Id */
      managed_key_id?: string;
      /** @description Managed Key Name */
      managed_key_name?: string;
      /** @description RFC 5280 Subject Key Identifier of the public counterpart */
      subject_key_id?: string;
    };
    PkiReadKeysConfigurationResponse: {
      /** @description Reference (name or identifier) to the default issuer. */
      default?: string;
    };
    PkiReadRoleResponse: {
      /** @description If set, clients can request certificates for any domain, regardless of allowed_domains restrictions. See the documentation for more information. */
      allow_any_name?: boolean;
      /** @description If set, clients can request certificates for the base domains themselves, e.g. "example.com" of domains listed in allowed_domains. This is a separate option as in some cases this can be considered a security threat. See the documentation for more information. */
      allow_bare_domains?: boolean;
      /** @description If set, domains specified in allowed_domains can include shell-style glob patterns, e.g. "ftp*.example.com". See the documentation for more information. */
      allow_glob_domains?: boolean;
      /** @description If set, IP Subject Alternative Names are allowed. Any valid IP is accepted and No authorization checking is performed. */
      allow_ip_sans?: boolean;
      /** @description Whether to allow "localhost" and "localdomain" as a valid common name in a request, independent of allowed_domains value. */
      allow_localhost?: boolean;
      /** @description If set, clients can request certificates for subdomains of domains listed in allowed_domains, including wildcard subdomains. See the documentation for more information. */
      allow_subdomains?: boolean;
      /** @description Whether to allow "localhost" and "localdomain" as a valid common name in a request, independent of allowed_domains value. */
      allow_token_displayname?: boolean;
      /** @description If set, allows certificates with wildcards in the common name to be issued, conforming to RFC 6125's Section 6.4.3; e.g., "*.example.net" or "b*z.example.net". See the documentation for more information. */
      allow_wildcard_certificates?: boolean;
      /** @description Specifies the domains this role is allowed to issue certificates for. This is used with the allow_bare_domains, allow_subdomains, and allow_glob_domains to determine matches for the common name, DNS-typed SAN entries, and Email-typed SAN entries of certificates. See the documentation for more information. This parameter accepts a comma-separated string or list of domains. */
      allowed_domains?: string[];
      /** @description If set, Allowed domains can be specified using identity template policies. Non-templated domains are also permitted. */
      allowed_domains_template?: boolean;
      /** @description If set, an array of allowed other names to put in SANs. These values support globbing and must be in the format <oid>;<type>:<value>. Currently only "utf8" is a valid type. All values, including globbing values, must use this syntax, with the exception being a single "*" which allows any OID and any value (but type must still be utf8). */
      allowed_other_sans?: string[];
      /** @description If set, an array of allowed serial numbers to put in Subject. These values support globbing. */
      allowed_serial_numbers?: string[];
      /** @description If set, an array of allowed URIs for URI Subject Alternative Names. Any valid URI is accepted, these values support globbing. */
      allowed_uri_sans?: string[];
      /** @description If set, Allowed URI SANs can be specified using identity template policies. Non-templated URI SANs are also permitted. */
      allowed_uri_sans_template?: boolean;
      /** @description If set, an array of allowed user-ids to put in user system login name specified here: https://www.rfc-editor.org/rfc/rfc1274#section-9.3.1 */
      allowed_user_ids?: string[];
      /** @description Mark Basic Constraints valid when issuing non-CA certificates. */
      basic_constraints_valid_for_non_ca?: boolean;
      /** @description If set, certificates are flagged for client auth use. Defaults to true. See also RFC 5280 Section 4.2.1.12. */
      client_flag?: boolean;
      /** @description List of allowed validations to run against the Common Name field. Values can include 'email' to validate the CN is a email address, 'hostname' to validate the CN is a valid hostname (potentially including wildcards). When multiple validations are specified, these take OR semantics (either email OR hostname are allowed). The special value 'disabled' allows disabling all CN name validations, allowing for arbitrary non-Hostname, non-Email address CNs. */
      cn_validations?: string[];
      /** @description If set, certificates are flagged for code signing use. Defaults to false. See also RFC 5280 Section 4.2.1.12. */
      code_signing_flag?: boolean;
      /** @description If set, Country will be set to this value in certificates issued by this role. */
      country?: string[];
      /** @description If set, certificates are flagged for email protection use. Defaults to false. See also RFC 5280 Section 4.2.1.12. */
      email_protection_flag?: boolean;
      /** @description If set, only valid host names are allowed for CN and DNS SANs, and the host part of email addresses. Defaults to true. */
      enforce_hostnames?: boolean;
      /** @description A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the "ExtKeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list. See also RFC 5280 Section 4.2.1.12. */
      ext_key_usage?: string[];
      /** @description A comma-separated string or list of extended key usage oids. */
      ext_key_usage_oids?: string[];
      /** @description If set, certificates issued/signed against this role will have Vault leases attached to them. Defaults to "false". Certificates can be added to the CRL by "vault revoke <lease_id>" when certificates are associated with leases. It can also be done using the "pki/revoke" endpoint. However, when lease generation is disabled, invoking "pki/revoke" would be the only way to add the certificates to the CRL. When large number of certificates are generated with long lifetimes, it is recommended that lease generation be disabled, as large amount of leases adversely affect the startup time of Vault. */
      generate_lease?: boolean;
      /** @description Reference to the issuer used to sign requests serviced by this role. */
      issuer_ref?: string;
      /** @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519. */
      key_bits?: number;
      /** @description The type of key to use; defaults to RSA. "rsa" "ec", "ed25519" and "any" are the only valid values. */
      key_type?: string;
      /** @description A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the "KeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list. See also RFC 5280 Section 4.2.1.3. */
      key_usage?: string[];
      /** @description If set, Locality will be set to this value in certificates issued by this role. */
      locality?: string[];
      /**
       * Format: int64
       * @description The maximum allowed lease duration. If not set, defaults to the system maximum lease TTL.
       */
      max_ttl?: number;
      /** @description If set, certificates issued/signed against this role will not be stored in the storage backend. This can improve performance when issuing large numbers of certificates. However, certificates issued in this way cannot be enumerated or revoked, so this option is recommended only for certificates that are non-sensitive, or extremely short-lived. This option implies a value of "false" for "generate_lease". */
      no_store?: boolean;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ. */
      not_after?: string;
      /**
       * Format: int64
       * @description The duration in seconds before now which the certificate needs to be backdated by.
       */
      not_before_duration?: number;
      /** @description If set, O (Organization) will be set to this value in certificates issued by this role. */
      organization?: string[];
      /** @description If set, OU (OrganizationalUnit) will be set to this value in certificates issued by this role. */
      ou?: string[];
      /** @description A comma-separated string or list of policy OIDs, or a JSON list of qualified policy information, which must include an oid, and may include a notice and/or cps url, using the form [{"oid"="1.3.6.1.4.1.7.8","notice"="I am a user Notice"}, {"oid"="1.3.6.1.4.1.44947.1.2.4 ","cps"="https://example.com"}]. */
      policy_identifiers?: string[];
      /** @description If set, Postal Code will be set to this value in certificates issued by this role. */
      postal_code?: string[];
      /** @description If set, Province will be set to this value in certificates issued by this role. */
      province?: string[];
      /** @description If set to false, makes the 'common_name' field optional while generating a certificate. */
      require_cn?: boolean;
      /**
       * @description If set, certificates are flagged for server auth use. Defaults to true. See also RFC 5280 Section 4.2.1.12.
       * @default true
       */
      server_flag: boolean;
      /** @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves). */
      signature_bits?: number;
      /** @description If set, Street Address will be set to this value in certificates issued by this role. */
      street_address?: string[];
      /**
       * Format: int64
       * @description The lease duration (validity period of the certificate) if no specific lease duration is requested. The lease duration controls the expiration of certificates issued by this backend. Defaults to the system default value or the value of max_ttl, whichever is shorter.
       */
      ttl?: number;
      /** @description If set, when used with a signing profile, the common name in the CSR will be used. This does *not* include any requested Subject Alternative Names; use use_csr_sans for that. Defaults to true. */
      use_csr_common_name?: boolean;
      /** @description If set, when used with a signing profile, the SANs in the CSR will be used. This does *not* include the Common Name (cn); use use_csr_common_name for that. Defaults to true. */
      use_csr_sans?: boolean;
      /** @description Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false. */
      use_pss?: boolean;
    };
    PkiReadUrlsConfigurationResponse: {
      /** @description Comma-separated list of URLs to be used for the CRL distribution points attribute. See also RFC 5280 Section 4.2.1.13. */
      crl_distribution_points?: string[];
      /** @description Whether or not to enable templating of the above AIA fields. When templating is enabled the special values '{{issuer_id}}' and '{{cluster_path}}' are available, but the addresses are not checked for URI validity until issuance time. This requires /config/cluster's path to be set on all PR Secondary clusters. */
      enable_templating?: boolean;
      /** @description Comma-separated list of URLs to be used for the issuing certificate attribute. See also RFC 5280 Section 4.2.2.1. */
      issuing_certificates?: string[];
      /** @description Comma-separated list of URLs to be used for the OCSP servers attribute. See also RFC 5280 Section 4.2.2.1. */
      ocsp_servers?: string[];
    };
    PkiReplaceRootRequest: {
      /**
       * @description Reference (name or identifier) to the default issuer.
       * @default next
       */
      default: string;
    };
    PkiReplaceRootResponse: {
      /** @description Reference (name or identifier) to the default issuer. */
      default?: string;
      /** @description Whether the default issuer should automatically follow the latest generated or imported issuer. Defaults to false. */
      default_follows_latest_issuer?: boolean;
    };
    PkiRevokeIssuerResponse: {
      /** @description Certificate Authority Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /** @description Specifies the URL values for the CRL Distribution Points field */
      crl_distribution_points?: string[];
      /** @description ID of the issuer */
      issuer_id?: string;
      /** @description Name of the issuer */
      issuer_name?: string;
      /** @description Specifies the URL values for the Issuing Certificate field */
      issuing_certificates?: string[];
      /** @description ID of the Key */
      key_id?: string;
      leaf_not_after_behavior?: string;
      /** @description Manual Chain */
      manual_chain?: string[];
      /** @description Specifies the URL values for the OCSP Servers field */
      ocsp_servers?: string[];
      /** @description Which signature algorithm to use when building CRLs */
      revocation_signature_algorithm?: string;
      /**
       * Format: int64
       * @description Time of revocation
       */
      revocation_time?: number;
      /**
       * Format: date-time
       * @description RFC formatted time of revocation
       */
      revocation_time_rfc3339?: string;
      /** @description Whether the issuer was revoked */
      revoked?: boolean;
      /** @description Allowed usage */
      usage?: string;
    };
    PkiRevokeRequest: {
      /** @description Certificate to revoke in PEM format; must be signed by an issuer in this mount. */
      certificate?: string;
      /** @description Certificate serial number, in colon- or hyphen-separated octal */
      serial_number?: string;
    };
    PkiRevokeResponse: {
      /**
       * Format: int64
       * @description Revocation Time
       */
      revocation_time?: number;
      /**
       * Format: date-time
       * @description Revocation Time
       */
      revocation_time_rfc3339?: string;
      /** @description Revocation State */
      state?: string;
    };
    PkiRevokeWithKeyRequest: {
      /** @description Certificate to revoke in PEM format; must be signed by an issuer in this mount. */
      certificate?: string;
      /** @description Key to use to verify revocation permission; must be in PEM format. */
      private_key?: string;
      /** @description Certificate serial number, in colon- or hyphen-separated octal */
      serial_number?: string;
    };
    PkiRevokeWithKeyResponse: {
      /**
       * Format: int64
       * @description Revocation Time
       */
      revocation_time?: number;
      /**
       * Format: date-time
       * @description Revocation Time
       */
      revocation_time_rfc3339?: string;
      /** @description Revocation State */
      state?: string;
    };
    PkiRootSignIntermediateRequest: {
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans. */
      common_name?: string;
      /** @description If set, Country will be set to this value. */
      country?: string[];
      /**
       * @description PEM-format CSR to be signed.
       * @default
       */
      csr: string;
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /** @description Provide a name to the generated or existing issuer, the name must be unique across all issuers and not be the reserved value 'default' */
      issuer_name?: string;
      /**
       * @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer.
       * @default default
       */
      issuer_ref: string;
      /** @description If set, Locality will be set to this value. */
      locality?: string[];
      /**
       * @description The maximum allowable path length
       * @default -1
       */
      max_path_length: number;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /**
       * Format: duration
       * @description The duration before now which the certificate needs to be backdated by.
       * @default 30
       */
      not_before_duration: string;
      /** @description If set, O (Organization) will be set to this value. */
      organization?: string[];
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /** @description If set, OU (OrganizationalUnit) will be set to this value. */
      ou?: string[];
      /** @description Domains for which this certificate is allowed to sign or issue child certificates. If set, all DNS names (subject and alt) on child certs must be exact matches or subsets of the given domains (see https://tools.ietf.org/html/rfc5280#section-4.2.1.10). */
      permitted_dns_domains?: string[];
      /** @description If set, Postal Code will be set to this value. */
      postal_code?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /** @description If set, Province will be set to this value. */
      province?: string[];
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).
       * @default 0
       */
      signature_bits: number;
      /**
       * @description Value for the Subject Key Identifier field (RFC 5280 Section 4.2.1.2). This value should ONLY be used when cross-signing to mimic the existing certificate's SKID value; this is necessary to allow certain TLS implementations (such as OpenSSL) which use SKID/AKID matches in chain building to restrict possible valid chains. Specified as a string in hex format. Default is empty, allowing Vault to automatically calculate the SKID according to method one in the above RFC section.
       * @default
       */
      skid: string;
      /** @description If set, Street Address will be set to this value. */
      street_address?: string[];
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
      /**
       * @description If true, then: 1) Subject information, including names and alternate names, will be preserved from the CSR rather than using values provided in the other parameters to this path; 2) Any key usages requested in the CSR will be added to the basic set of key usages used for CA certs signed by this path; for instance, the non-repudiation flag; 3) Extensions requested in the CSR will be copied into the issued certificate.
       * @default false
       */
      use_csr_values: boolean;
      /**
       * @description Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.
       * @default false
       */
      use_pss: boolean;
    };
    PkiRootSignIntermediateResponse: {
      /** @description CA Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Expiration Time
       */
      expiration?: number;
      /** @description Issuing CA */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiRootSignSelfIssuedRequest: {
      /** @description PEM-format self-issued certificate to be signed. */
      certificate?: string;
      /**
       * @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer.
       * @default default
       */
      issuer_ref: string;
      /**
       * @description If true, require the public key algorithm of the signer to match that of the self issued certificate.
       * @default false
       */
      require_matching_certificate_algorithms: boolean;
    };
    PkiRootSignSelfIssuedResponse: {
      /** @description Certificate */
      certificate?: string;
      /** @description Issuing CA */
      issuing_ca?: string;
    };
    PkiRotateCrlResponse: {
      /** @description Whether rotation was successful */
      success?: boolean;
    };
    PkiRotateDeltaCrlResponse: {
      /** @description Whether rotation was successful */
      success?: boolean;
    };
    PkiRotateRootRequest: {
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans. */
      common_name?: string;
      /** @description If set, Country will be set to this value. */
      country?: string[];
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /** @description Provide a name to the generated or existing issuer, the name must be unique across all issuers and not be the reserved value 'default' */
      issuer_name?: string;
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, 4096 or 8192; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /** @description Provide a name to the generated or existing key, the name must be unique across all keys and not be the reserved value 'default' */
      key_name?: string;
      /**
       * @description Reference to a existing key; either "default" for the configured default key, an identifier or the name assigned to the key.
       * @default default
       */
      key_ref: string;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519';
      /** @description If set, Locality will be set to this value. */
      locality?: string[];
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types. */
      managed_key_id?: string;
      /** @description The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types. */
      managed_key_name?: string;
      /**
       * @description The maximum allowable path length
       * @default -1
       */
      max_path_length: number;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /**
       * Format: duration
       * @description The duration before now which the certificate needs to be backdated by.
       * @default 30
       */
      not_before_duration: string;
      /** @description If set, O (Organization) will be set to this value. */
      organization?: string[];
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /** @description If set, OU (OrganizationalUnit) will be set to this value. */
      ou?: string[];
      /** @description Domains for which this certificate is allowed to sign or issue child certificates. If set, all DNS names (subject and alt) on child certs must be exact matches or subsets of the given domains (see https://tools.ietf.org/html/rfc5280#section-4.2.1.10). */
      permitted_dns_domains?: string[];
      /** @description If set, Postal Code will be set to this value. */
      postal_code?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /** @description If set, Province will be set to this value. */
      province?: string[];
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).
       * @default 0
       */
      signature_bits: number;
      /** @description If set, Street Address will be set to this value. */
      street_address?: string[];
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
      /**
       * @description Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.
       * @default false
       */
      use_pss: boolean;
    };
    PkiRotateRootResponse: {
      /** @description The generated self-signed CA certificate. */
      certificate?: string;
      /**
       * Format: int64
       * @description The expiration of the given issuer.
       */
      expiration?: number;
      /** @description The ID of the issuer */
      issuer_id?: string;
      /** @description The name of the issuer. */
      issuer_name?: string;
      /** @description The issuing certificate authority. */
      issuing_ca?: string;
      /** @description The ID of the key. */
      key_id?: string;
      /** @description The key name if given. */
      key_name?: string;
      /** @description The private key if exported was specified. */
      private_key?: string;
      /** @description The requested Subject's named serial number. */
      serial_number?: string;
    };
    PkiSetSignedIntermediateRequest: {
      /** @description PEM-format certificate. This must be a CA certificate with a public key matching the previously-generated key from the generation endpoint. Additional parent CAs may be optionally appended to the bundle. */
      certificate?: string;
    };
    PkiSetSignedIntermediateResponse: {
      /** @description Existing issuers specified as part of the import bundle of this request */
      existing_issuers?: string[];
      /** @description Existing keys specified as part of the import bundle of this request */
      existing_keys?: string[];
      /** @description Net-new issuers imported as a part of this request */
      imported_issuers?: string[];
      /** @description Net-new keys imported as a part of this request */
      imported_keys?: string[];
      /**
       * Format: map
       * @description A mapping of issuer_id to key_id for all issuers included in this request
       */
      mapping?: Record<string, never>;
    };
    PkiSignVerbatimRequest: {
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address. */
      common_name?: string;
      /**
       * @description PEM-format CSR to be signed. Values will be taken verbatim from the CSR, except for basic constraints.
       * @default
       */
      csr: string;
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the "ExtKeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list.
       * @default []
       */
      ext_key_usage: string[];
      /**
       * @description A comma-separated string or list of extended key usage oids.
       * @default []
       */
      ext_key_usage_oids: string[];
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /**
       * @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer.
       * @default default
       */
      issuer_ref: string;
      /**
       * @description A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the "KeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list.
       * @default [
       *       "DigitalSignature",
       *       "KeyAgreement",
       *       "KeyEncipherment"
       *     ]
       */
      key_usage: string[];
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).
       * @default 0
       */
      signature_bits: number;
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
      /**
       * @description Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.
       * @default false
       */
      use_pss: boolean;
      /** @description The requested user_ids value to place in the subject, if any, in a comma-delimited list. Restricted by allowed_user_ids. Any values are added with OID 0.9.2342.19200300.100.1.1. */
      user_ids?: string[];
    };
    PkiSignVerbatimResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiSignVerbatimWithRoleRequest: {
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address. */
      common_name?: string;
      /**
       * @description PEM-format CSR to be signed. Values will be taken verbatim from the CSR, except for basic constraints.
       * @default
       */
      csr: string;
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the "ExtKeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list.
       * @default []
       */
      ext_key_usage: string[];
      /**
       * @description A comma-separated string or list of extended key usage oids.
       * @default []
       */
      ext_key_usage_oids: string[];
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /**
       * @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer.
       * @default default
       */
      issuer_ref: string;
      /**
       * @description A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the "KeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list.
       * @default [
       *       "DigitalSignature",
       *       "KeyAgreement",
       *       "KeyEncipherment"
       *     ]
       */
      key_usage: string[];
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).
       * @default 0
       */
      signature_bits: number;
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
      /**
       * @description Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.
       * @default false
       */
      use_pss: boolean;
      /** @description The requested user_ids value to place in the subject, if any, in a comma-delimited list. Restricted by allowed_user_ids. Any values are added with OID 0.9.2342.19200300.100.1.1. */
      user_ids?: string[];
    };
    PkiSignVerbatimWithRoleResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiSignWithRoleRequest: {
      /** @description The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses. */
      alt_names?: string;
      /** @description The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address. */
      common_name?: string;
      /**
       * @description PEM-format CSR to be signed.
       * @default
       */
      csr: string;
      /**
       * @description If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).
       * @default false
       */
      exclude_cn_from_sans: boolean;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /** @description The requested IP SANs, if any, in a comma-delimited list */
      ip_sans?: string[];
      /**
       * @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer.
       * @default default
       */
      issuer_ref: string;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ */
      not_after?: string;
      /** @description Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry. */
      other_sans?: string[];
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: '' | 'der' | 'pem' | 'pkcs8';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
      /** @description The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field. */
      serial_number?: string;
      /**
       * Format: duration
       * @description The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.
       */
      ttl?: string;
      /** @description The requested URI SANs, if any, in a comma-delimited list. */
      uri_sans?: string[];
      /** @description The requested user_ids value to place in the subject, if any, in a comma-delimited list. Restricted by allowed_user_ids. Any values are added with OID 0.9.2342.19200300.100.1.1. */
      user_ids?: string[];
    };
    PkiSignWithRoleResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiTidyCancelResponse: {
      /** @description The number of revoked acme accounts removed */
      acme_account_deleted_count?: number;
      /** @description The number of unused acme accounts revoked */
      acme_account_revoked_count?: number;
      /** @description Safety buffer after creation after which accounts lacking orders are revoked */
      acme_account_safety_buffer?: number;
      /** @description The number of expired, unused acme orders removed */
      acme_orders_deleted_count?: number;
      /** @description The number of certificate storage entries deleted */
      cert_store_deleted_count?: number;
      cross_revoked_cert_deleted_count?: number;
      /** @description The number of revoked certificate entries deleted */
      current_cert_store_count?: number;
      /** @description The number of revoked certificate entries deleted */
      current_revoked_cert_count?: number;
      /** @description The error message */
      error?: string;
      internal_backend_uuid?: string;
      /** @description Issuer safety buffer */
      issuer_safety_buffer?: number;
      /** @description Time the last auto-tidy operation finished */
      last_auto_tidy_finished?: string;
      /** @description Message of the operation */
      message?: string;
      missing_issuer_cert_count?: number;
      /** @description Duration to pause between tidying certificates */
      pause_duration?: string;
      revocation_queue_deleted_count?: number;
      /** @description Revocation queue safety buffer */
      revocation_queue_safety_buffer?: number;
      /** @description The number of revoked certificate entries deleted */
      revoked_cert_deleted_count?: number;
      /** @description Safety buffer time duration */
      safety_buffer?: number;
      /** @description One of Inactive, Running, Finished, or Error */
      state?: string;
      /** @description Tidy Unused Acme Accounts, and Orders */
      tidy_acme?: boolean;
      /** @description Tidy certificate store */
      tidy_cert_store?: boolean;
      /** @description Tidy the cross-cluster revoked certificate store */
      tidy_cross_cluster_revoked_certs?: boolean;
      /** @description Tidy expired issuers */
      tidy_expired_issuers?: boolean;
      tidy_move_legacy_ca_bundle?: boolean;
      tidy_revocation_queue?: boolean;
      /** @description Tidy revoked certificate issuer associations */
      tidy_revoked_cert_issuer_associations?: boolean;
      /** @description Tidy revoked certificates */
      tidy_revoked_certs?: boolean;
      /** @description Time the operation finished */
      time_finished?: string;
      /** @description Time the operation started */
      time_started?: string;
      /** @description Total number of acme accounts iterated over */
      total_acme_account_count?: number;
    };
    PkiTidyRequest: {
      /**
       * Format: duration
       * @description The amount of time that must pass after creation that an account with no orders is marked revoked, and the amount of time after being marked revoked or deactivated.
       * @default 2592000
       */
      acme_account_safety_buffer: string;
      /**
       * Format: duration
       * @description The amount of extra time that must have passed beyond issuer's expiration before it is removed from the backend storage. Defaults to 8760 hours (1 year).
       * @default 31536000
       */
      issuer_safety_buffer: string;
      /**
       * @description The amount of time to wait between processing certificates. This allows operators to change the execution profile of tidy to take consume less resources by slowing down how long it takes to run. Note that the entire list of certificates will be stored in memory during the entire tidy operation, but resources to read/process/update existing entries will be spread out over a greater period of time. By default this is zero seconds.
       * @default 0s
       */
      pause_duration: string;
      /**
       * Format: duration
       * @description The amount of time that must pass from the cross-cluster revocation request being initiated to when it will be slated for removal. Setting this too low may remove valid revocation requests before the owning cluster has a chance to process them, especially if the cluster is offline.
       * @default 172800
       */
      revocation_queue_safety_buffer: string;
      /**
       * Format: duration
       * @description The amount of extra time that must have passed beyond certificate expiration before it is removed from the backend storage and/or revocation list. Defaults to 72 hours.
       * @default 259200
       */
      safety_buffer: string;
      /**
       * @description Set to true to enable tidying ACME accounts, orders and authorizations. ACME orders are tidied (deleted) safety_buffer after the certificate associated with them expires, or after the order and relevant authorizations have expired if no certificate was produced. Authorizations are tidied with the corresponding order. When a valid ACME Account is at least acme_account_safety_buffer old, and has no remaining orders associated with it, the account is marked as revoked. After another acme_account_safety_buffer has passed from the revocation or deactivation date, a revoked or deactivated ACME account is deleted.
       * @default false
       */
      tidy_acme: boolean;
      /** @description Set to true to enable tidying up the certificate store */
      tidy_cert_store?: boolean;
      /** @description Set to true to enable tidying up the cross-cluster revoked certificate store. Only runs on the active primary node. */
      tidy_cross_cluster_revoked_certs?: boolean;
      /** @description Set to true to automatically remove expired issuers past the issuer_safety_buffer. No keys will be removed as part of this operation. */
      tidy_expired_issuers?: boolean;
      /** @description Set to true to move the legacy ca_bundle from /config/ca_bundle to /config/ca_bundle.bak. This prevents downgrades to pre-Vault 1.11 versions (as older PKI engines do not know about the new multi-issuer storage layout), but improves the performance on seal wrapped PKI mounts. This will only occur if at least issuer_safety_buffer time has occurred after the initial storage migration. This backup is saved in case of an issue in future migrations. Operators may consider removing it via sys/raw if they desire. The backup will be removed via a DELETE /root call, but note that this removes ALL issuers within the mount (and is thus not desirable in most operational scenarios). */
      tidy_move_legacy_ca_bundle?: boolean;
      /** @description Deprecated; synonym for 'tidy_revoked_certs */
      tidy_revocation_list?: boolean;
      /**
       * @description Set to true to remove stale revocation queue entries that haven't been confirmed by any active cluster. Only runs on the active primary node
       * @default false
       */
      tidy_revocation_queue: boolean;
      /** @description Set to true to validate issuer associations on revocation entries. This helps increase the performance of CRL building and OCSP responses. */
      tidy_revoked_cert_issuer_associations?: boolean;
      /** @description Set to true to expire all revoked and expired certificates, removing them both from the CRL and from storage. The CRL will be rotated if this causes any values to be removed. */
      tidy_revoked_certs?: boolean;
    };
    PkiTidyStatusResponse: {
      /** @description The number of revoked acme accounts removed */
      acme_account_deleted_count?: number;
      /** @description The number of unused acme accounts revoked */
      acme_account_revoked_count?: number;
      /** @description Safety buffer after creation after which accounts lacking orders are revoked */
      acme_account_safety_buffer?: number;
      /** @description The number of expired, unused acme orders removed */
      acme_orders_deleted_count?: number;
      /** @description The number of certificate storage entries deleted */
      cert_store_deleted_count?: number;
      cross_revoked_cert_deleted_count?: number;
      /** @description The number of revoked certificate entries deleted */
      current_cert_store_count?: number;
      /** @description The number of revoked certificate entries deleted */
      current_revoked_cert_count?: number;
      /** @description The error message */
      error?: string;
      internal_backend_uuid?: string;
      /** @description Issuer safety buffer */
      issuer_safety_buffer?: number;
      /** @description Time the last auto-tidy operation finished */
      last_auto_tidy_finished?: string;
      /** @description Message of the operation */
      message?: string;
      missing_issuer_cert_count?: number;
      /** @description Duration to pause between tidying certificates */
      pause_duration?: string;
      revocation_queue_deleted_count?: number;
      /** @description Revocation queue safety buffer */
      revocation_queue_safety_buffer?: number;
      /** @description The number of revoked certificate entries deleted */
      revoked_cert_deleted_count?: number;
      /** @description Safety buffer time duration */
      safety_buffer?: number;
      /** @description One of Inactive, Running, Finished, or Error */
      state?: string;
      /** @description Tidy Unused Acme Accounts, and Orders */
      tidy_acme?: boolean;
      /** @description Tidy certificate store */
      tidy_cert_store?: boolean;
      /** @description Tidy the cross-cluster revoked certificate store */
      tidy_cross_cluster_revoked_certs?: boolean;
      /** @description Tidy expired issuers */
      tidy_expired_issuers?: boolean;
      tidy_move_legacy_ca_bundle?: boolean;
      tidy_revocation_queue?: boolean;
      /** @description Tidy revoked certificate issuer associations */
      tidy_revoked_cert_issuer_associations?: boolean;
      /** @description Tidy revoked certificates */
      tidy_revoked_certs?: boolean;
      /** @description Time the operation finished */
      time_finished?: string;
      /** @description Time the operation started */
      time_started?: string;
      /** @description Total number of acme accounts iterated over */
      total_acme_account_count?: number;
    };
    PkiWriteAcmeAccountKidRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteAcmeAuthorizationAuth_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteAcmeChallengeAuth_idChallenge_typeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteAcmeNewAccountRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteAcmeNewOrderRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteAcmeOrderOrder_idCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteAcmeOrderOrder_idFinalizeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteAcmeOrderOrder_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteAcmeOrdersRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteAcmeRevokeCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyAcmeAccountKidRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyAcmeAuthorizationAuth_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyAcmeChallengeAuth_idChallenge_typeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyAcmeNewAccountRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyAcmeNewOrderRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyAcmeOrderOrder_idCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyAcmeOrderOrder_idFinalizeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyAcmeOrderOrder_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyAcmeOrdersRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyAcmeRevokeCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyIssuePolicyRequest: {
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519';
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: 'der' | 'pem' | 'pkcs8';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
    };
    PkiWriteExternalPolicyIssuePolicyResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Private key */
      private_key?: string;
      /** @description Private key type */
      private_key_type?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiWriteExternalPolicyIssueRequest: {
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519';
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: 'der' | 'pem' | 'pkcs8';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
    };
    PkiWriteExternalPolicyIssueResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Private key */
      private_key?: string;
      /** @description Private key type */
      private_key_type?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiWriteExternalPolicyPolicyAcmeAccountKidRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyPolicyAcmeAuthorizationAuth_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyPolicyAcmeChallengeAuth_idChallenge_typeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyPolicyAcmeNewAccountRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyPolicyAcmeNewOrderRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyPolicyAcmeOrderOrder_idCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyPolicyAcmeOrderOrder_idFinalizeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyPolicyAcmeOrderOrder_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyPolicyAcmeOrdersRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicyPolicyAcmeRevokeCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteExternalPolicySignIntermediatePolicyRequest: {
      /** @description PEM-format CSR is expected but the contents of this field will not be validated */
      csr: string;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
    };
    PkiWriteExternalPolicySignIntermediatePolicyResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiWriteExternalPolicySignIntermediateRequest: {
      /** @description PEM-format CSR is expected but the contents of this field will not be validated */
      csr: string;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
    };
    PkiWriteExternalPolicySignIntermediateResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiWriteExternalPolicySignPolicyRequest: {
      /** @description PEM-format CSR is expected but the contents of this field will not be validated */
      csr: string;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
    };
    PkiWriteExternalPolicySignPolicyResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiWriteExternalPolicySignRequest: {
      /** @description PEM-format CSR is expected but the contents of this field will not be validated */
      csr: string;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
    };
    PkiWriteExternalPolicySignResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiWriteIssuerIssuer_refAcmeAccountKidRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refAcmeAuthorizationAuth_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refAcmeChallengeAuth_idChallenge_typeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refAcmeNewAccountRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refAcmeNewOrderRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refAcmeOrderOrder_idCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refAcmeOrderOrder_idFinalizeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refAcmeOrderOrder_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refAcmeOrdersRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refAcmeRevokeCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyAcmeAccountKidRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyAcmeAuthorizationAuth_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyAcmeChallengeAuth_idChallenge_typeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyAcmeNewAccountRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyAcmeNewOrderRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyAcmeOrderOrder_idCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyAcmeOrderOrder_idFinalizeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyAcmeOrderOrder_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyAcmeOrdersRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyAcmeRevokeCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyIssuePolicyRequest: {
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519';
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: 'der' | 'pem' | 'pkcs8';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
    };
    PkiWriteIssuerIssuer_refExternalPolicyIssuePolicyResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Private key */
      private_key?: string;
      /** @description Private key type */
      private_key_type?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyIssueRequest: {
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec" and "ed25519" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519';
      /**
       * @description Format for the returned private key. Generally the default will be controlled by the "format" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to "der".
       * @default der
       * @enum {string}
       */
      private_key_format: 'der' | 'pem' | 'pkcs8';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
    };
    PkiWriteIssuerIssuer_refExternalPolicyIssueResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Private key */
      private_key?: string;
      /** @description Private key type */
      private_key_type?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeAccountKidRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeAuthorizationAuth_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeChallengeAuth_idChallenge_typeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeNewAccountRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeNewOrderRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeOrderOrder_idCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeOrderOrder_idFinalizeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeOrderOrder_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeOrdersRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeRevokeCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicySignIntermediatePolicyRequest: {
      /** @description PEM-format CSR is expected but the contents of this field will not be validated */
      csr: string;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
    };
    PkiWriteIssuerIssuer_refExternalPolicySignIntermediatePolicyResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicySignIntermediateRequest: {
      /** @description PEM-format CSR is expected but the contents of this field will not be validated */
      csr: string;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
    };
    PkiWriteIssuerIssuer_refExternalPolicySignIntermediateResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicySignPolicyRequest: {
      /** @description PEM-format CSR is expected but the contents of this field will not be validated */
      csr: string;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
    };
    PkiWriteIssuerIssuer_refExternalPolicySignPolicyResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiWriteIssuerIssuer_refExternalPolicySignRequest: {
      /** @description PEM-format CSR is expected but the contents of this field will not be validated */
      csr: string;
      /**
       * @description Format for returned data. Can be "pem", "der", or "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Defaults to "pem".
       * @default pem
       * @enum {string}
       */
      format: 'pem' | 'der' | 'pem_bundle';
      /**
       * @description Whether or not to remove self-signed CA certificates in the output of the ca_chain field.
       * @default false
       */
      remove_roots_from_chain: boolean;
    };
    PkiWriteIssuerIssuer_refExternalPolicySignResponse: {
      /** @description Certificate Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /**
       * Format: int64
       * @description Time of expiration
       */
      expiration?: number;
      /** @description Issuing Certificate Authority */
      issuing_ca?: string;
      /** @description Serial Number */
      serial_number?: string;
    };
    PkiWriteIssuerIssuer_refRolesRoleAcmeAccountKidRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refRolesRoleAcmeAuthorizationAuth_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refRolesRoleAcmeChallengeAuth_idChallenge_typeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refRolesRoleAcmeNewAccountRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refRolesRoleAcmeNewOrderRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refRolesRoleAcmeOrderOrder_idCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refRolesRoleAcmeOrderOrder_idFinalizeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refRolesRoleAcmeOrderOrder_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refRolesRoleAcmeOrdersRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerIssuer_refRolesRoleAcmeRevokeCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteIssuerRequest: {
      /** @description Comma-separated list of URLs to be used for the CRL distribution points attribute. See also RFC 5280 Section 4.2.1.13. */
      crl_distribution_points?: string[];
      /**
       * @description Whether or not to enabling templating of the above AIA fields. When templating is enabled the special values '{{issuer_id}}', '{{cluster_path}}', '{{cluster_aia_path}}' are available, but the addresses are not checked for URL validity until issuance time. Using '{{cluster_path}}' requires /config/cluster's 'path' member to be set on all PR Secondary clusters and using '{{cluster_aia_path}}' requires /config/cluster's 'aia_path' member to be set on all PR secondary clusters.
       * @default false
       */
      enable_aia_url_templating: boolean;
      /** @description Provide a name to the generated or existing issuer, the name must be unique across all issuers and not be the reserved value 'default' */
      issuer_name?: string;
      /** @description Comma-separated list of URLs to be used for the issuing certificate attribute. See also RFC 5280 Section 4.2.2.1. */
      issuing_certificates?: string[];
      /**
       * @description Behavior of leaf's NotAfter fields: "err" to error if the computed NotAfter date exceeds that of this issuer; "truncate" to silently truncate to that of this issuer; or "permit" to allow this issuance to succeed (with NotAfter exceeding that of an issuer). Note that not all values will results in certificates that can be validated through the entire validity period. It is suggested to use "truncate" for intermediate CAs and "permit" only for root CAs.
       * @default err
       */
      leaf_not_after_behavior: string;
      /** @description Chain of issuer references to use to build this issuer's computed CAChain field, when non-empty. */
      manual_chain?: string[];
      /** @description Comma-separated list of URLs to be used for the OCSP servers attribute. See also RFC 5280 Section 4.2.2.1. */
      ocsp_servers?: string[];
      /**
       * @description Which x509.SignatureAlgorithm name to use for signing CRLs. This parameter allows differentiation between PKCS#1v1.5 and PSS keys and choice of signature hash algorithm. The default (empty string) value is for Go to select the signature algorithm. This can fail if the underlying key does not support the requested signature algorithm, which may not be known at modification time (such as with PKCS#11 managed RSA keys).
       * @default
       */
      revocation_signature_algorithm: string;
      /**
       * @description Comma-separated list (or string slice) of usages for this issuer; valid values are "read-only", "issuing-certificates", "crl-signing", and "ocsp-signing". Multiple values may be specified. Read-only is implicit and always set.
       * @default [
       *       "read-only",
       *       "issuing-certificates",
       *       "crl-signing",
       *       "ocsp-signing"
       *     ]
       */
      usage: string[];
    };
    PkiWriteIssuerResponse: {
      /** @description CA Chain */
      ca_chain?: string[];
      /** @description Certificate */
      certificate?: string;
      /** @description CRL Distribution Points */
      crl_distribution_points?: string[];
      /** @description Whether or not templating is enabled for AIA fields */
      enable_aia_url_templating?: boolean;
      /** @description Issuer Id */
      issuer_id?: string;
      /** @description Issuer Name */
      issuer_name?: string;
      /** @description Issuing Certificates */
      issuing_certificates?: string[];
      /** @description Key Id */
      key_id?: string;
      /** @description Leaf Not After Behavior */
      leaf_not_after_behavior?: string;
      /** @description Manual Chain */
      manual_chain?: string[];
      /** @description OCSP Servers */
      ocsp_servers?: string[];
      /** @description Revocation Signature Alogrithm */
      revocation_signature_algorithm?: string;
      revocation_time?: number;
      revocation_time_rfc3339?: string;
      /** @description Revoked */
      revoked?: boolean;
      /** @description Usage */
      usage?: string;
    };
    PkiWriteKeyRequest: {
      /** @description Human-readable name for this key. */
      key_name?: string;
    };
    PkiWriteKeyResponse: {
      /** @description Key Id */
      key_id?: string;
      /** @description Key Name */
      key_name?: string;
      /** @description Key Type */
      key_type?: string;
    };
    PkiWriteRoleRequest: {
      /** @description If set, clients can request certificates for any domain, regardless of allowed_domains restrictions. See the documentation for more information. */
      allow_any_name?: boolean;
      /** @description If set, clients can request certificates for the base domains themselves, e.g. "example.com" of domains listed in allowed_domains. This is a separate option as in some cases this can be considered a security threat. See the documentation for more information. */
      allow_bare_domains?: boolean;
      /** @description If set, domains specified in allowed_domains can include shell-style glob patterns, e.g. "ftp*.example.com". See the documentation for more information. */
      allow_glob_domains?: boolean;
      /**
       * @description If set, IP Subject Alternative Names are allowed. Any valid IP is accepted and No authorization checking is performed.
       * @default true
       */
      allow_ip_sans: boolean;
      /**
       * @description Whether to allow "localhost" and "localdomain" as a valid common name in a request, independent of allowed_domains value.
       * @default true
       */
      allow_localhost: boolean;
      /** @description If set, clients can request certificates for subdomains of domains listed in allowed_domains, including wildcard subdomains. See the documentation for more information. */
      allow_subdomains?: boolean;
      /**
       * @description If set, allows certificates with wildcards in the common name to be issued, conforming to RFC 6125's Section 6.4.3; e.g., "*.example.net" or "b*z.example.net". See the documentation for more information.
       * @default true
       */
      allow_wildcard_certificates: boolean;
      /** @description Specifies the domains this role is allowed to issue certificates for. This is used with the allow_bare_domains, allow_subdomains, and allow_glob_domains to determine matches for the common name, DNS-typed SAN entries, and Email-typed SAN entries of certificates. See the documentation for more information. This parameter accepts a comma-separated string or list of domains. */
      allowed_domains?: string[];
      /**
       * @description If set, Allowed domains can be specified using identity template policies. Non-templated domains are also permitted.
       * @default false
       */
      allowed_domains_template: boolean;
      /** @description If set, an array of allowed other names to put in SANs. These values support globbing and must be in the format <oid>;<type>:<value>. Currently only "utf8" is a valid type. All values, including globbing values, must use this syntax, with the exception being a single "*" which allows any OID and any value (but type must still be utf8). */
      allowed_other_sans?: string[];
      /** @description If set, an array of allowed serial numbers to put in Subject. These values support globbing. */
      allowed_serial_numbers?: string[];
      /** @description If set, an array of allowed URIs for URI Subject Alternative Names. Any valid URI is accepted, these values support globbing. */
      allowed_uri_sans?: string[];
      /**
       * @description If set, Allowed URI SANs can be specified using identity template policies. Non-templated URI SANs are also permitted.
       * @default false
       */
      allowed_uri_sans_template: boolean;
      /** @description If set, an array of allowed user-ids to put in user system login name specified here: https://www.rfc-editor.org/rfc/rfc1274#section-9.3.1 */
      allowed_user_ids?: string[];
      /** @description Backend Type */
      backend?: string;
      /** @description Mark Basic Constraints valid when issuing non-CA certificates. */
      basic_constraints_valid_for_non_ca?: boolean;
      /**
       * @description If set, certificates are flagged for client auth use. Defaults to true. See also RFC 5280 Section 4.2.1.12.
       * @default true
       */
      client_flag: boolean;
      /**
       * @description List of allowed validations to run against the Common Name field. Values can include 'email' to validate the CN is a email address, 'hostname' to validate the CN is a valid hostname (potentially including wildcards). When multiple validations are specified, these take OR semantics (either email OR hostname are allowed). The special value 'disabled' allows disabling all CN name validations, allowing for arbitrary non-Hostname, non-Email address CNs.
       * @default [
       *       "email",
       *       "hostname"
       *     ]
       */
      cn_validations: string[];
      /** @description If set, certificates are flagged for code signing use. Defaults to false. See also RFC 5280 Section 4.2.1.12. */
      code_signing_flag?: boolean;
      /** @description If set, Country will be set to this value in certificates issued by this role. */
      country?: string[];
      /** @description If set, certificates are flagged for email protection use. Defaults to false. See also RFC 5280 Section 4.2.1.12. */
      email_protection_flag?: boolean;
      /**
       * @description If set, only valid host names are allowed for CN and DNS SANs, and the host part of email addresses. Defaults to true.
       * @default true
       */
      enforce_hostnames: boolean;
      /**
       * @description A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the "ExtKeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list. See also RFC 5280 Section 4.2.1.12.
       * @default []
       */
      ext_key_usage: string[];
      /** @description A comma-separated string or list of extended key usage oids. */
      ext_key_usage_oids?: string[];
      /** @description If set, certificates issued/signed against this role will have Vault leases attached to them. Defaults to "false". Certificates can be added to the CRL by "vault revoke <lease_id>" when certificates are associated with leases. It can also be done using the "pki/revoke" endpoint. However, when lease generation is disabled, invoking "pki/revoke" would be the only way to add the certificates to the CRL. When large number of certificates are generated with long lifetimes, it is recommended that lease generation be disabled, as large amount of leases adversely affect the startup time of Vault. */
      generate_lease?: boolean;
      /**
       * @description Reference to the issuer used to sign requests serviced by this role.
       * @default default
       */
      issuer_ref: string;
      /**
       * @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.
       * @default 0
       */
      key_bits: number;
      /**
       * @description The type of key to use; defaults to RSA. "rsa" "ec", "ed25519" and "any" are the only valid values.
       * @default rsa
       * @enum {string}
       */
      key_type: 'rsa' | 'ec' | 'ed25519' | 'any';
      /**
       * @description A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the "KeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list. See also RFC 5280 Section 4.2.1.3.
       * @default [
       *       "DigitalSignature",
       *       "KeyAgreement",
       *       "KeyEncipherment"
       *     ]
       */
      key_usage: string[];
      /** @description If set, Locality will be set to this value in certificates issued by this role. */
      locality?: string[];
      /**
       * Format: duration
       * @description The maximum allowed lease duration. If not set, defaults to the system maximum lease TTL.
       */
      max_ttl?: string;
      /** @description If set, certificates issued/signed against this role will not be stored in the storage backend. This can improve performance when issuing large numbers of certificates. However, certificates issued in this way cannot be enumerated or revoked, so this option is recommended only for certificates that are non-sensitive, or extremely short-lived. This option implies a value of "false" for "generate_lease". */
      no_store?: boolean;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ. */
      not_after?: string;
      /**
       * Format: duration
       * @description The duration before now which the certificate needs to be backdated by.
       * @default 30
       */
      not_before_duration: string;
      /** @description If set, O (Organization) will be set to this value in certificates issued by this role. */
      organization?: string[];
      /** @description If set, OU (OrganizationalUnit) will be set to this value in certificates issued by this role. */
      ou?: string[];
      /** @description A comma-separated string or list of policy OIDs, or a JSON list of qualified policy information, which must include an oid, and may include a notice and/or cps url, using the form [{"oid"="1.3.6.1.4.1.7.8","notice"="I am a user Notice"}, {"oid"="1.3.6.1.4.1.44947.1.2.4 ","cps"="https://example.com"}]. */
      policy_identifiers?: string[];
      /** @description If set, Postal Code will be set to this value in certificates issued by this role. */
      postal_code?: string[];
      /** @description If set, Province will be set to this value in certificates issued by this role. */
      province?: string[];
      /**
       * @description If set to false, makes the 'common_name' field optional while generating a certificate.
       * @default true
       */
      require_cn: boolean;
      /**
       * @description If set, certificates are flagged for server auth use. Defaults to true. See also RFC 5280 Section 4.2.1.12.
       * @default true
       */
      server_flag: boolean;
      /**
       * @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).
       * @default 0
       */
      signature_bits: number;
      /** @description If set, Street Address will be set to this value in certificates issued by this role. */
      street_address?: string[];
      /**
       * Format: duration
       * @description The lease duration (validity period of the certificate) if no specific lease duration is requested. The lease duration controls the expiration of certificates issued by this backend. Defaults to the system default value or the value of max_ttl, whichever is shorter.
       */
      ttl?: string;
      /**
       * @description If set, when used with a signing profile, the common name in the CSR will be used. This does *not* include any requested Subject Alternative Names; use use_csr_sans for that. Defaults to true.
       * @default true
       */
      use_csr_common_name: boolean;
      /**
       * @description If set, when used with a signing profile, the SANs in the CSR will be used. This does *not* include the Common Name (cn); use use_csr_common_name for that. Defaults to true.
       * @default true
       */
      use_csr_sans: boolean;
      /**
       * @description Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.
       * @default false
       */
      use_pss: boolean;
    };
    PkiWriteRoleResponse: {
      /** @description If set, clients can request certificates for any domain, regardless of allowed_domains restrictions. See the documentation for more information. */
      allow_any_name?: boolean;
      /** @description If set, clients can request certificates for the base domains themselves, e.g. "example.com" of domains listed in allowed_domains. This is a separate option as in some cases this can be considered a security threat. See the documentation for more information. */
      allow_bare_domains?: boolean;
      /** @description If set, domains specified in allowed_domains can include shell-style glob patterns, e.g. "ftp*.example.com". See the documentation for more information. */
      allow_glob_domains?: boolean;
      /** @description If set, IP Subject Alternative Names are allowed. Any valid IP is accepted and No authorization checking is performed. */
      allow_ip_sans?: boolean;
      /** @description Whether to allow "localhost" and "localdomain" as a valid common name in a request, independent of allowed_domains value. */
      allow_localhost?: boolean;
      /** @description If set, clients can request certificates for subdomains of domains listed in allowed_domains, including wildcard subdomains. See the documentation for more information. */
      allow_subdomains?: boolean;
      /** @description Whether to allow "localhost" and "localdomain" as a valid common name in a request, independent of allowed_domains value. */
      allow_token_displayname?: boolean;
      /** @description If set, allows certificates with wildcards in the common name to be issued, conforming to RFC 6125's Section 6.4.3; e.g., "*.example.net" or "b*z.example.net". See the documentation for more information. */
      allow_wildcard_certificates?: boolean;
      /** @description Specifies the domains this role is allowed to issue certificates for. This is used with the allow_bare_domains, allow_subdomains, and allow_glob_domains to determine matches for the common name, DNS-typed SAN entries, and Email-typed SAN entries of certificates. See the documentation for more information. This parameter accepts a comma-separated string or list of domains. */
      allowed_domains?: string[];
      /** @description If set, Allowed domains can be specified using identity template policies. Non-templated domains are also permitted. */
      allowed_domains_template?: boolean;
      /** @description If set, an array of allowed other names to put in SANs. These values support globbing and must be in the format <oid>;<type>:<value>. Currently only "utf8" is a valid type. All values, including globbing values, must use this syntax, with the exception being a single "*" which allows any OID and any value (but type must still be utf8). */
      allowed_other_sans?: string[];
      /** @description If set, an array of allowed serial numbers to put in Subject. These values support globbing. */
      allowed_serial_numbers?: string[];
      /** @description If set, an array of allowed URIs for URI Subject Alternative Names. Any valid URI is accepted, these values support globbing. */
      allowed_uri_sans?: string[];
      /** @description If set, Allowed URI SANs can be specified using identity template policies. Non-templated URI SANs are also permitted. */
      allowed_uri_sans_template?: boolean;
      /** @description If set, an array of allowed user-ids to put in user system login name specified here: https://www.rfc-editor.org/rfc/rfc1274#section-9.3.1 */
      allowed_user_ids?: string[];
      /** @description Mark Basic Constraints valid when issuing non-CA certificates. */
      basic_constraints_valid_for_non_ca?: boolean;
      /** @description If set, certificates are flagged for client auth use. Defaults to true. See also RFC 5280 Section 4.2.1.12. */
      client_flag?: boolean;
      /** @description List of allowed validations to run against the Common Name field. Values can include 'email' to validate the CN is a email address, 'hostname' to validate the CN is a valid hostname (potentially including wildcards). When multiple validations are specified, these take OR semantics (either email OR hostname are allowed). The special value 'disabled' allows disabling all CN name validations, allowing for arbitrary non-Hostname, non-Email address CNs. */
      cn_validations?: string[];
      /** @description If set, certificates are flagged for code signing use. Defaults to false. See also RFC 5280 Section 4.2.1.12. */
      code_signing_flag?: boolean;
      /** @description If set, Country will be set to this value in certificates issued by this role. */
      country?: string[];
      /** @description If set, certificates are flagged for email protection use. Defaults to false. See also RFC 5280 Section 4.2.1.12. */
      email_protection_flag?: boolean;
      /** @description If set, only valid host names are allowed for CN and DNS SANs, and the host part of email addresses. Defaults to true. */
      enforce_hostnames?: boolean;
      /** @description A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the "ExtKeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list. See also RFC 5280 Section 4.2.1.12. */
      ext_key_usage?: string[];
      /** @description A comma-separated string or list of extended key usage oids. */
      ext_key_usage_oids?: string[];
      /** @description If set, certificates issued/signed against this role will have Vault leases attached to them. Defaults to "false". Certificates can be added to the CRL by "vault revoke <lease_id>" when certificates are associated with leases. It can also be done using the "pki/revoke" endpoint. However, when lease generation is disabled, invoking "pki/revoke" would be the only way to add the certificates to the CRL. When large number of certificates are generated with long lifetimes, it is recommended that lease generation be disabled, as large amount of leases adversely affect the startup time of Vault. */
      generate_lease?: boolean;
      /** @description Reference to the issuer used to sign requests serviced by this role. */
      issuer_ref?: string;
      /** @description The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519. */
      key_bits?: number;
      /** @description The type of key to use; defaults to RSA. "rsa" "ec", "ed25519" and "any" are the only valid values. */
      key_type?: string;
      /** @description A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the "KeyUsage" part of the name. To remove all key usages from being set, set this value to an empty list. See also RFC 5280 Section 4.2.1.3. */
      key_usage?: string[];
      /** @description If set, Locality will be set to this value in certificates issued by this role. */
      locality?: string[];
      /**
       * Format: int64
       * @description The maximum allowed lease duration. If not set, defaults to the system maximum lease TTL.
       */
      max_ttl?: number;
      /** @description If set, certificates issued/signed against this role will not be stored in the storage backend. This can improve performance when issuing large numbers of certificates. However, certificates issued in this way cannot be enumerated or revoked, so this option is recommended only for certificates that are non-sensitive, or extremely short-lived. This option implies a value of "false" for "generate_lease". */
      no_store?: boolean;
      /** @description Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ. */
      not_after?: string;
      /**
       * Format: int64
       * @description The duration in seconds before now which the certificate needs to be backdated by.
       */
      not_before_duration?: number;
      /** @description If set, O (Organization) will be set to this value in certificates issued by this role. */
      organization?: string[];
      /** @description If set, OU (OrganizationalUnit) will be set to this value in certificates issued by this role. */
      ou?: string[];
      /** @description A comma-separated string or list of policy OIDs, or a JSON list of qualified policy information, which must include an oid, and may include a notice and/or cps url, using the form [{"oid"="1.3.6.1.4.1.7.8","notice"="I am a user Notice"}, {"oid"="1.3.6.1.4.1.44947.1.2.4 ","cps"="https://example.com"}]. */
      policy_identifiers?: string[];
      /** @description If set, Postal Code will be set to this value in certificates issued by this role. */
      postal_code?: string[];
      /** @description If set, Province will be set to this value in certificates issued by this role. */
      province?: string[];
      /** @description If set to false, makes the 'common_name' field optional while generating a certificate. */
      require_cn?: boolean;
      /**
       * @description If set, certificates are flagged for server auth use. Defaults to true. See also RFC 5280 Section 4.2.1.12.
       * @default true
       */
      server_flag: boolean;
      /** @description The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves). */
      signature_bits?: number;
      /** @description If set, Street Address will be set to this value in certificates issued by this role. */
      street_address?: string[];
      /**
       * Format: int64
       * @description The lease duration (validity period of the certificate) if no specific lease duration is requested. The lease duration controls the expiration of certificates issued by this backend. Defaults to the system default value or the value of max_ttl, whichever is shorter.
       */
      ttl?: number;
      /** @description If set, when used with a signing profile, the common name in the CSR will be used. This does *not* include any requested Subject Alternative Names; use use_csr_sans for that. Defaults to true. */
      use_csr_common_name?: boolean;
      /** @description If set, when used with a signing profile, the SANs in the CSR will be used. This does *not* include the Common Name (cn); use use_csr_common_name for that. Defaults to true. */
      use_csr_sans?: boolean;
      /** @description Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false. */
      use_pss?: boolean;
    };
    PkiWriteRolesRoleAcmeAccountKidRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteRolesRoleAcmeAuthorizationAuth_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteRolesRoleAcmeChallengeAuth_idChallenge_typeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteRolesRoleAcmeNewAccountRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteRolesRoleAcmeNewOrderRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteRolesRoleAcmeOrderOrder_idCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteRolesRoleAcmeOrderOrder_idFinalizeRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteRolesRoleAcmeOrderOrder_idRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteRolesRoleAcmeOrdersRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PkiWriteRolesRoleAcmeRevokeCertRequest: {
      /** @description ACME request 'payload' value */
      payload?: string;
      /** @description ACME request 'protected' value */
      protected?: string;
      /** @description ACME request 'signature' value */
      signature?: string;
    };
    PluginsCatalogListPluginsResponse: {
      /** Format: map */
      detailed?: Record<string, never>;
    };
    PluginsCatalogListPluginsWithTypeResponse: {
      /** @description List of plugin names in the catalog */
      keys?: string[];
    };
    PluginsCatalogPinsCreatePinnedVersionRequest: {
      /** @description The semantic version of the plugin to use, or image tag if oci_image is provided. */
      version?: string;
    };
    PluginsCatalogPinsListPinnedVersionsResponse: {
      /** Format: map */
      pinned_versions?: Record<string, never>;
    };
    PluginsCatalogPinsReadPinnedVersionResponse: {
      /** @description The name of the plugin */
      name?: string;
      /** @description The type of the plugin, may be auth, secret, or database */
      type?: string;
      /** @description The semantic version of the plugin to use, or image tag if oci_image is provided. */
      version?: string;
    };
    PluginsCatalogReadPluginConfigurationResponse: {
      /** @description The args passed to plugin command. */
      args?: string[];
      builtin?: boolean;
      /** @description The command used to start the plugin. The executable defined in this command must exist in vault's plugin directory. */
      command?: string;
      deprecation_status?: string;
      /** @description The name of the plugin */
      name?: string;
      oci_image?: string;
      /** @description The Vault plugin runtime to use when running the plugin. */
      runtime?: string;
      /** @description The SHA256 sum of the executable or container to be run. This should be HEX encoded. */
      sha256?: string;
      /** @description The semantic version of the plugin to use, or image tag if oci_image is provided. */
      version?: string;
    };
    PluginsCatalogReadPluginConfigurationWithTypeResponse: {
      /** @description The args passed to plugin command. */
      args?: string[];
      builtin?: boolean;
      /** @description The command used to start the plugin. The executable defined in this command must exist in vault's plugin directory. */
      command?: string;
      deprecation_status?: string;
      /** @description The name of the plugin */
      name?: string;
      oci_image?: string;
      /** @description The Vault plugin runtime to use when running the plugin. */
      runtime?: string;
      /** @description The SHA256 sum of the executable or container to be run. This should be HEX encoded. */
      sha256?: string;
      /** @description The semantic version of the plugin to use, or image tag if oci_image is provided. */
      version?: string;
    };
    PluginsCatalogRegisterPluginRequest: {
      /** @description The args passed to plugin command. */
      args?: string[];
      /** @description The command used to start the plugin. The executable defined in this command must exist in vault's plugin directory. */
      command?: string;
      /** @description The environment variables passed to plugin command. Each entry is of the form "key=value". */
      env?: string[];
      oci_image?: string;
      /** @description The Vault plugin runtime to use when running the plugin. */
      runtime?: string;
      /** @description The SHA256 sum of the executable or container to be run. This should be HEX encoded. */
      sha256?: string;
      /** @description The semantic version of the plugin to use, or image tag if oci_image is provided. */
      version?: string;
    };
    PluginsCatalogRegisterPluginWithTypeRequest: {
      /** @description The args passed to plugin command. */
      args?: string[];
      /** @description The command used to start the plugin. The executable defined in this command must exist in vault's plugin directory. */
      command?: string;
      /** @description The environment variables passed to plugin command. Each entry is of the form "key=value". */
      env?: string[];
      oci_image?: string;
      /** @description The Vault plugin runtime to use when running the plugin. */
      runtime?: string;
      /** @description The SHA256 sum of the executable or container to be run. This should be HEX encoded. */
      sha256?: string;
      /** @description The semantic version of the plugin to use, or image tag if oci_image is provided. */
      version?: string;
    };
    PluginsReloadBackendsRequest: {
      /** @description The mount paths of the plugin backends to reload. */
      mounts?: string[];
      /** @description The name of the plugin to reload, as registered in the plugin catalog. */
      plugin?: string;
      /** @description The scope for the reload operation. May be empty or "global". */
      scope?: string;
    };
    PluginsReloadBackendsResponse: {
      reload_id?: string;
    };
    PluginsRuntimesCatalogListPluginsRuntimesResponse: {
      /** @description List of all plugin runtimes in the catalog */
      runtimes?: Record<string, never>[];
    };
    PluginsRuntimesCatalogReadPluginRuntimeConfigurationResponse: {
      /** @description Parent cgroup to set for each container. This can be used to control the total resource usage for a group of plugins. */
      cgroup_parent?: string;
      /**
       * Format: int64
       * @description CPU limit to set per container in nanos. Defaults to no limit.
       */
      cpu_nanos?: number;
      /**
       * Format: int64
       * @description Memory limit to set per container in bytes. Defaults to no limit.
       */
      memory_bytes?: number;
      /** @description The name of the plugin runtime */
      name?: string;
      /** @description The OCI-compatible runtime (default "runsc") */
      oci_runtime?: string;
      /** @description Whether the container runtime is run as a non-privileged (non-root) user. */
      rootless?: boolean;
      /** @description The type of the plugin runtime */
      type?: string;
    };
    PluginsRuntimesCatalogRegisterPluginRuntimeRequest: {
      /** @description Parent cgroup to set for each container. This can be used to control the total resource usage for a group of plugins. */
      cgroup_parent?: string;
      /**
       * Format: int64
       * @description CPU limit to set per container in nanos. Defaults to no limit.
       */
      cpu_nanos?: number;
      /**
       * Format: int64
       * @description Memory limit to set per container in bytes. Defaults to no limit.
       */
      memory_bytes?: number;
      /** @description The OCI-compatible runtime (default "runsc") */
      oci_runtime?: string;
      /** @description Whether the container runtime is run as a non-privileged (non-root) user. */
      rootless?: boolean;
    };
    PoliciesGeneratePasswordFromPasswordPolicyResponse: {
      password?: string;
    };
    PoliciesListAclPolicies2Response: {
      keys?: string[];
      policies?: string[];
    };
    PoliciesListAclPolicies3Response: {
      keys?: string[];
      policies?: string[];
    };
    PoliciesListAclPoliciesResponse: {
      keys?: string[];
      policies?: string[];
    };
    PoliciesReadAclPolicy2Response: {
      name?: string;
      policy?: string;
      rules?: string;
    };
    PoliciesReadAclPolicyResponse: {
      name?: string;
      policy?: string;
      rules?: string;
    };
    PoliciesReadPasswordPolicyResponse: {
      policy?: string;
    };
    PoliciesWriteAclPolicy2Request: {
      /** @description The rules of the policy. */
      policy?: string;
      /**
       * @deprecated
       * @description The rules of the policy.
       */
      rules?: string;
    };
    PoliciesWriteAclPolicyRequest: {
      /** @description The rules of the policy. */
      policy?: string;
    };
    PoliciesWritePasswordPolicyRequest: {
      /** @description The password policy */
      policy?: string;
    };
    QueryTokenAccessorCapabilitiesRequest: {
      /** @description Accessor of the token for which capabilities are being queried. */
      accessor?: string;
      /**
       * @deprecated
       * @description Use 'paths' instead.
       */
      path?: string[];
      /** @description Paths on which capabilities are being queried. */
      paths?: string[];
    };
    QueryTokenCapabilitiesRequest: {
      /**
       * @deprecated
       * @description Use 'paths' instead.
       */
      path?: string[];
      /** @description Paths on which capabilities are being queried. */
      paths?: string[];
      /** @description Token for which capabilities are being queried. */
      token?: string;
    };
    QueryTokenSelfCapabilitiesRequest: {
      /**
       * @deprecated
       * @description Use 'paths' instead.
       */
      path?: string[];
      /** @description Paths on which capabilities are being queried. */
      paths?: string[];
      /** @description Token for which capabilities are being queried. */
      token?: string;
    };
    RabbitMqConfigureConnectionRequest: {
      /** @description RabbitMQ Management URI */
      connection_uri?: string;
      /** @description Password of the provided RabbitMQ management user */
      password?: string;
      /** @description Name of the password policy to use to generate passwords for dynamic credentials. */
      password_policy?: string;
      /** @description Username of a RabbitMQ management administrator */
      username?: string;
      /** @description Template describing how dynamic usernames are generated. */
      username_template?: string;
      /**
       * @description If set, connection_uri is verified by actually connecting to the RabbitMQ management API
       * @default true
       */
      verify_connection: boolean;
    };
    RabbitMqConfigureLeaseRequest: {
      /**
       * Format: duration
       * @description Duration after which the issued credentials should not be allowed to be renewed
       * @default 0
       */
      max_ttl: string;
      /**
       * Format: duration
       * @description Duration before which the issued credentials needs renewal
       * @default 0
       */
      ttl: string;
    };
    RabbitMqWriteRoleRequest: {
      /** @description Comma-separated list of tags for this role. */
      tags?: string;
      /** @description A nested map of virtual hosts and exchanges to topic permissions. */
      vhost_topics?: string;
      /** @description A map of virtual hosts to permissions. */
      vhosts?: string;
    };
    RadiusConfigureRequest: {
      /**
       * Format: duration
       * @description Number of seconds before connect times out (default: 10)
       * @default 10
       */
      dial_timeout: string;
      /** @description RADIUS server host */
      host?: string;
      /**
       * @description RADIUS NAS Identifier field (optional)
       * @default
       */
      nas_identifier: string;
      /**
       * @description RADIUS NAS port field (default: 10)
       * @default 10
       */
      nas_port: number;
      /**
       * @description RADIUS server port (default: 1812)
       * @default 1812
       */
      port: number;
      /**
       * Format: duration
       * @description Number of seconds before response times out (default: 10)
       * @default 10
       */
      read_timeout: string;
      /** @description Secret shared with the RADIUS server */
      secret?: string;
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies. This will apply to all tokens generated by this auth method, in addition to any configured for specific users. */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /**
       * @description Comma-separated list of policies to grant upon successful RADIUS authentication of an unregistered user (default: empty)
       * @default
       */
      unregistered_user_policies: string;
    };
    RadiusLoginRequest: {
      /** @description Password for this user. */
      password?: string;
      /** @description Username to be used for login. (POST request body) */
      username?: string;
    };
    RadiusLoginWithUsernameRequest: {
      /** @description Password for this user. */
      password?: string;
      /** @description Username to be used for login. (POST request body) */
      username?: string;
    };
    RadiusWriteUserRequest: {
      /** @description Comma-separated list of policies associated to the user. */
      policies?: string[];
    };
    RateLimitQuotasConfigureRequest: {
      /** @description Specifies the list of exempt global paths from all rate limit quotas. If empty no global paths will be exempt. */
      absolute_rate_limit_exempt_paths?: string[];
      /** @description If set, starts audit logging of requests that get rejected due to rate limit quota rule violations. */
      enable_rate_limit_audit_logging?: boolean;
      /** @description If set, additional rate limit quota HTTP headers will be added to responses. */
      enable_rate_limit_response_headers?: boolean;
      /** @description Specifies the list of exempt paths from all rate limit quotas. If empty no paths will be exempt. */
      rate_limit_exempt_paths?: string[];
    };
    RateLimitQuotasReadConfigurationResponse: {
      absolute_rate_limit_exempt_paths?: string[];
      enable_rate_limit_audit_logging?: boolean;
      enable_rate_limit_response_headers?: boolean;
      rate_limit_exempt_paths?: string[];
    };
    RateLimitQuotasReadResponse: {
      block_interval?: number;
      inheritable?: boolean;
      interval?: number;
      name?: string;
      path?: string;
      /** Format: float */
      rate?: number;
      role?: string;
      type?: string;
    };
    RateLimitQuotasWriteRequest: {
      /**
       * Format: duration
       * @description If set, when a client reaches a rate limit threshold, the client will be prohibited from any further requests until after the 'block_interval' has elapsed.
       */
      block_interval?: string;
      /** @description Whether all child namespaces can inherit this namespace quota. */
      inheritable?: boolean;
      /**
       * Format: duration
       * @description The duration to enforce rate limiting for (default '1s').
       */
      interval?: string;
      /** @description Path of the mount or namespace to apply the quota. A blank path configures a global quota. For example namespace1/ adds a quota to a full namespace, namespace1/auth/userpass adds a quota to userpass in namespace1. */
      path?: string;
      /**
       * Format: float
       * @description The maximum number of requests in a given interval to be allowed by the quota rule. The 'rate' must be positive.
       */
      rate?: number;
      /** @description Login role to apply this quota to. Note that when set, path must be configured to a valid auth method with a concept of roles. */
      role?: string;
      /** @description Type of the quota rule. */
      type?: string;
    };
    RawReadResponse: {
      value?: string;
    };
    RawWriteRequest: {
      compressed?: boolean;
      compression_type?: string;
      encoding?: string;
      value?: string;
    };
    ReadWrappingProperties2Response: {
      creation_path?: string;
      /** Format: date-time */
      creation_time?: string;
      /** Format: duration */
      creation_ttl?: string;
    };
    ReadWrappingPropertiesRequest: {
      token?: string;
    };
    ReadWrappingPropertiesResponse: {
      creation_path?: string;
      /** Format: date-time */
      creation_time?: string;
      /** Format: duration */
      creation_ttl?: string;
    };
    RekeyAttemptInitializeRequest: {
      /** @description Specifies if using PGP-encrypted keys, whether Vault should also store a plaintext backup of the PGP-encrypted keys. */
      backup?: boolean;
      /** @description Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as secret_shares. */
      pgp_keys?: string[];
      /** @description Turns on verification functionality */
      require_verification?: boolean;
      /** @description Specifies the number of shares to split the unseal key into. */
      secret_shares?: number;
      /** @description Specifies the number of shares required to reconstruct the unseal key. This must be less than or equal secret_shares. If using Vault HSM with auto-unsealing, this value must be the same as secret_shares. */
      secret_threshold?: number;
    };
    RekeyAttemptInitializeResponse: {
      backup?: boolean;
      n?: number;
      nonce?: string;
      pgp_fingerprints?: string[];
      progress?: number;
      required?: number;
      started?: boolean;
      t?: number;
      verification_nonce?: string;
      verification_required?: boolean;
    };
    RekeyAttemptReadProgressResponse: {
      backup?: boolean;
      n?: number;
      nonce?: string;
      pgp_fingerprints?: string[];
      progress?: number;
      required?: number;
      started?: boolean;
      t?: number;
      verification_nonce?: string;
      verification_required?: boolean;
    };
    RekeyAttemptUpdateRequest: {
      /** @description Specifies a single unseal key share. */
      key?: string;
      /** @description Specifies the nonce of the rekey attempt. */
      nonce?: string;
    };
    RekeyAttemptUpdateResponse: {
      backup?: boolean;
      complete?: boolean;
      keys?: string[];
      keys_base64?: string[];
      n?: number;
      nonce?: string;
      pgp_fingerprints?: string[];
      progress?: number;
      required?: number;
      started?: boolean;
      t?: number;
      verification_nonce?: string;
      verification_required?: boolean;
    };
    RekeyReadBackupKeyResponse: {
      /** Format: map */
      keys?: Record<string, never>;
      /** Format: map */
      keys_base64?: Record<string, never>;
      nonce?: string;
    };
    RekeyReadBackupRecoveryKeyResponse: {
      /** Format: map */
      keys?: Record<string, never>;
      /** Format: map */
      keys_base64?: Record<string, never>;
      nonce?: string;
    };
    RekeyVerificationCancelResponse: {
      n?: number;
      nonce?: string;
      progress?: number;
      started?: boolean;
      t?: number;
    };
    RekeyVerificationReadProgressResponse: {
      n?: number;
      nonce?: string;
      progress?: number;
      started?: boolean;
      t?: number;
    };
    RekeyVerificationUpdateRequest: {
      /** @description Specifies a single unseal share key from the new set of shares. */
      key?: string;
      /** @description Specifies the nonce of the rekey verification operation. */
      nonce?: string;
    };
    RekeyVerificationUpdateResponse: {
      complete?: boolean;
      nonce?: string;
    };
    ReloadPluginsRequest: {
      /** @description The scope for the reload operation. May be empty or "global". */
      scope?: string;
    };
    ReloadPluginsResponse: {
      reload_id?: string;
    };
    RemountRequest: {
      /** @description The previous mount point. */
      from?: string;
      /** @description The new mount point. */
      to?: string;
    };
    RemountResponse: {
      migration_id?: string;
    };
    RemountStatusResponse: {
      migration_id?: string;
      /** Format: map */
      migration_info?: Record<string, never>;
    };
    RewrapRequest: {
      token?: string;
    };
    RootTokenGenerationInitialize2Request: {
      /** @description Specifies a base64-encoded PGP public key. */
      pgp_key?: string;
    };
    RootTokenGenerationInitialize2Response: {
      complete?: boolean;
      encoded_root_token?: string;
      encoded_token?: string;
      nonce?: string;
      otp?: string;
      otp_length?: number;
      pgp_fingerprint?: string;
      progress?: number;
      required?: number;
      started?: boolean;
    };
    RootTokenGenerationInitializeRequest: {
      /** @description Specifies a base64-encoded PGP public key. */
      pgp_key?: string;
    };
    RootTokenGenerationInitializeResponse: {
      complete?: boolean;
      encoded_root_token?: string;
      encoded_token?: string;
      nonce?: string;
      otp?: string;
      otp_length?: number;
      pgp_fingerprint?: string;
      progress?: number;
      required?: number;
      started?: boolean;
    };
    RootTokenGenerationReadProgress2Response: {
      complete?: boolean;
      encoded_root_token?: string;
      encoded_token?: string;
      nonce?: string;
      otp?: string;
      otp_length?: number;
      pgp_fingerprint?: string;
      progress?: number;
      required?: number;
      started?: boolean;
    };
    RootTokenGenerationReadProgressResponse: {
      complete?: boolean;
      encoded_root_token?: string;
      encoded_token?: string;
      nonce?: string;
      otp?: string;
      otp_length?: number;
      pgp_fingerprint?: string;
      progress?: number;
      required?: number;
      started?: boolean;
    };
    RootTokenGenerationUpdateRequest: {
      /** @description Specifies a single unseal key share. */
      key?: string;
      /** @description Specifies the nonce of the attempt. */
      nonce?: string;
    };
    RootTokenGenerationUpdateResponse: {
      complete?: boolean;
      encoded_root_token?: string;
      encoded_token?: string;
      nonce?: string;
      otp?: string;
      otp_length?: number;
      pgp_fingerprint?: string;
      progress?: number;
      required?: number;
      started?: boolean;
    };
    SealStatusResponse: {
      build_date?: string;
      cluster_id?: string;
      cluster_name?: string;
      hcp_link_resource_ID?: string;
      hcp_link_status?: string;
      initialized?: boolean;
      migration?: boolean;
      n?: number;
      nonce?: string;
      progress?: number;
      recovery_seal?: boolean;
      sealed?: boolean;
      storage_type?: string;
      t?: number;
      type?: string;
      version?: string;
    };
    SshConfigureCaRequest: {
      /**
       * @description Generate SSH key pair internally rather than use the private_key and public_key fields.
       * @default true
       */
      generate_signing_key: boolean;
      /**
       * @description Specifies the desired key bits when generating variable-length keys (such as when key_type="ssh-rsa") or which NIST P-curve to use when key_type="ec" (256, 384, or 521).
       * @default 0
       */
      key_bits: number;
      /**
       * @description Specifies the desired key type when generating; could be a OpenSSH key type identifier (ssh-rsa, ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, ecdsa-sha2-nistp521, or ssh-ed25519) or an algorithm (rsa, ec, ed25519).
       * @default ssh-rsa
       */
      key_type: string;
      /** @description Private half of the SSH key that will be used to sign certificates. */
      private_key?: string;
      /** @description Public half of the SSH key that will be used to sign certificates. */
      public_key?: string;
    };
    SshConfigureZeroAddressRequest: {
      /** @description [Required] Comma separated list of role names which allows credentials to be requested for any IP address. CIDR blocks previously registered under these roles will be ignored. */
      roles?: string[];
    };
    SshGenerateCredentialsRequest: {
      /** @description [Required] IP of the remote host */
      ip?: string;
      /** @description [Optional] Username in remote host */
      username?: string;
    };
    SshIssueCertificateRequest: {
      /**
       * @description Type of certificate to be created; either "user" or "host".
       * @default user
       */
      cert_type: string;
      /**
       * Format: map
       * @description Critical options that the certificate should be signed for.
       */
      critical_options?: Record<string, never>;
      /**
       * Format: map
       * @description Extensions that the certificate should be signed for.
       */
      extensions?: Record<string, never>;
      /**
       * @description Specifies the number of bits to use for the generated keys.
       * @default 0
       */
      key_bits: number;
      /** @description Key id that the created certificate should have. If not specified, the display name of the token will be used. */
      key_id?: string;
      /**
       * @description Specifies the desired key type; must be `rsa`, `ed25519` or `ec`
       * @default rsa
       */
      key_type: string;
      /**
       * Format: duration
       * @description The requested Time To Live for the SSH certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be later than the role max TTL.
       */
      ttl?: string;
      /** @description Valid principals, either usernames or hostnames, that the certificate should be signed for. */
      valid_principals?: string;
    };
    SshListRolesByIpRequest: {
      /** @description [Required] IP address of remote host */
      ip?: string;
    };
    SshSignCertificateRequest: {
      /**
       * @description Type of certificate to be created; either "user" or "host".
       * @default user
       */
      cert_type: string;
      /**
       * Format: map
       * @description Critical options that the certificate should be signed for.
       */
      critical_options?: Record<string, never>;
      /**
       * Format: map
       * @description Extensions that the certificate should be signed for.
       */
      extensions?: Record<string, never>;
      /** @description Key id that the created certificate should have. If not specified, the display name of the token will be used. */
      key_id?: string;
      /** @description SSH public key that should be signed. */
      public_key?: string;
      /**
       * Format: duration
       * @description The requested Time To Live for the SSH certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be later than the role max TTL.
       */
      ttl?: string;
      /** @description Valid principals, either usernames or hostnames, that the certificate should be signed for. */
      valid_principals?: string;
    };
    SshVerifyOtpRequest: {
      /** @description [Required] One-Time-Key that needs to be validated */
      otp?: string;
    };
    SshWriteRoleRequest: {
      /**
       * @description [Not applicable for OTP type] [Optional for CA type] When supplied, this value specifies a signing algorithm for the key. Possible values: ssh-rsa, rsa-sha2-256, rsa-sha2-512, default, or the empty string.
       * @enum {string}
       */
      algorithm_signer?: '' | 'default' | 'ssh-rsa' | 'rsa-sha2-256' | 'rsa-sha2-512';
      /** @description [Not applicable for OTP type] [Optional for CA type] If set, host certificates that are requested are allowed to use the base domains listed in "allowed_domains", e.g. "example.com". This is a separate option as in some cases this can be considered a security threat. */
      allow_bare_domains?: boolean;
      /**
       * @description [Not applicable for OTP type] [Optional for CA type] If set, certificates are allowed to be signed for use as a 'host'.
       * @default false
       */
      allow_host_certificates: boolean;
      /** @description [Not applicable for OTP type] [Optional for CA type] If set, host certificates that are requested are allowed to use subdomains of those listed in "allowed_domains". */
      allow_subdomains?: boolean;
      /**
       * @description [Not applicable for OTP type] [Optional for CA type] If set, certificates are allowed to be signed for use as a 'user'.
       * @default false
       */
      allow_user_certificates: boolean;
      /** @description [Not applicable for OTP type] [Optional for CA type] If true, users can override the key ID for a signed certificate with the "key_id" field. When false, the key ID will always be the token display name. The key ID is logged by the SSH server and can be useful for auditing. */
      allow_user_key_ids?: boolean;
      /** @description [Not applicable for OTP type] [Optional for CA type] A comma-separated list of critical options that certificates can have when signed. To allow any critical options, set this to an empty string. */
      allowed_critical_options?: string;
      /** @description [Not applicable for OTP type] [Optional for CA type] If this option is not specified, client can request for a signed certificate for any valid host. If only certain domains are allowed, then this list enforces it. */
      allowed_domains?: string;
      /**
       * @description [Not applicable for OTP type] [Optional for CA type] If set, Allowed domains can be specified using identity template policies. Non-templated domains are also permitted.
       * @default false
       */
      allowed_domains_template: boolean;
      /** @description [Not applicable for OTP type] [Optional for CA type] A comma-separated list of extensions that certificates can have when signed. An empty list means that no extension overrides are allowed by an end-user; explicitly specify '*' to allow any extensions to be set. */
      allowed_extensions?: string;
      /**
       * Format: map
       * @description [Not applicable for OTP type] [Optional for CA type] If set, allows the enforcement of key types and minimum key sizes to be signed.
       */
      allowed_user_key_lengths?: Record<string, never>;
      /** @description [Optional for all types] [Works differently for CA type] If this option is not specified, or is '*', client can request a credential for any valid user at the remote host, including the admin user. If only certain usernames are to be allowed, then this list enforces it. If this field is set, then credentials can only be created for default_user and usernames present in this list. Setting this option will enable all the users with access to this role to fetch credentials for all other usernames in this list. Use with caution. N.B.: with the CA type, an empty list means that no users are allowed; explicitly specify '*' to allow any user. */
      allowed_users?: string;
      /**
       * @description [Not applicable for OTP type] [Optional for CA type] If set, Allowed users can be specified using identity template policies. Non-templated users are also permitted.
       * @default false
       */
      allowed_users_template: boolean;
      /** @description [Optional for OTP type] [Not applicable for CA type] Comma separated list of CIDR blocks for which the role is applicable for. CIDR blocks can belong to more than one role. */
      cidr_list?: string;
      /**
       * Format: map
       * @description [Not applicable for OTP type] [Optional for CA type] Critical options certificates should have if none are provided when signing. This field takes in key value pairs in JSON format. Note that these are not restricted by "allowed_critical_options". Defaults to none.
       */
      default_critical_options?: Record<string, never>;
      /**
       * Format: map
       * @description [Not applicable for OTP type] [Optional for CA type] Extensions certificates should have if none are provided when signing. This field takes in key value pairs in JSON format. Note that these are not restricted by "allowed_extensions". Defaults to none.
       */
      default_extensions?: Record<string, never>;
      /**
       * @description [Not applicable for OTP type] [Optional for CA type] If set, Default extension values can be specified using identity template policies. Non-templated extension values are also permitted.
       * @default false
       */
      default_extensions_template: boolean;
      /** @description [Required for OTP type] [Optional for CA type] Default username for which a credential will be generated. When the endpoint 'creds/' is used without a username, this value will be used as default username. */
      default_user?: string;
      /**
       * @description [Not applicable for OTP type] [Optional for CA type] If set, Default user can be specified using identity template policies. Non-templated users are also permitted.
       * @default false
       */
      default_user_template: boolean;
      /** @description [Optional for OTP type] [Not applicable for CA type] Comma separated list of CIDR blocks. IP addresses belonging to these blocks are not accepted by the role. This is particularly useful when big CIDR blocks are being used by the role and certain parts of it needs to be kept out. */
      exclude_cidr_list?: string;
      /** @description [Not applicable for OTP type] [Optional for CA type] When supplied, this value specifies a custom format for the key id of a signed certificate. The following variables are available for use: '{{token_display_name}}' - The display name of the token used to make the request. '{{role_name}}' - The name of the role signing the request. '{{public_key_hash}}' - A SHA256 checksum of the public key that is being signed. */
      key_id_format?: string;
      /**
       * @description [Required for all types] Type of key used to login to hosts. It can be either 'otp' or 'ca'. 'otp' type requires agent to be installed in remote hosts.
       * @enum {string}
       */
      key_type?: 'otp' | 'ca';
      /**
       * Format: duration
       * @description [Not applicable for OTP type] [Optional for CA type] The maximum allowed lease duration
       */
      max_ttl?: string;
      /**
       * Format: duration
       * @description [Not applicable for OTP type] [Optional for CA type] The duration that the SSH certificate should be backdated by at issuance.
       * @default 30
       */
      not_before_duration: string;
      /** @description [Optional for OTP type] [Not applicable for CA type] Port number for SSH connection. Default is '22'. Port number does not play any role in creation of OTP. For 'otp' type, this is just a way to inform client about the port number to use. Port number will be returned to client by Vault server along with OTP. */
      port?: number;
      /**
       * Format: duration
       * @description [Not applicable for OTP type] [Optional for CA type] The lease duration if no specific lease duration is requested. The lease duration controls the expiration of certificates issued by this backend. Defaults to the value of max_ttl.
       */
      ttl?: string;
    };
    StandardListResponse: {
      keys?: string[];
    };
    SystemDeleteSyncConfigResponse: {
      /**
       * @description Disables the syncing process between Vault and external destinations.
       * @default false
       */
      disabled: boolean;
      /**
       * @description Maximum number of pending sync operations allowed on the queue.
       * @default 1000000
       */
      queue_capacity: number;
    };
    SystemDeleteSyncGithubAppsNameResponse: {
      /**
       * Format: int64
       * @description Application ID of the GitHub App.
       */
      app_id?: number;
      /** @description The name of the GitHub app. Used to identify the application when configuring the GitHub destination */
      name?: string;
    };
    SystemListSyncAssociationsResponse: {
      /**
       * Format: map
       * @description Map of associations listing all synced secret names regrouped by their mount.
       */
      key_info?: Record<string, never>;
      /** @description List of mounts with at least one association. */
      keys?: Record<string, never>[];
    };
    SystemListSyncDestinationsResponse: {
      /**
       * Format: map
       * @description Map of destinations listing all existing destination names regrouped per type.
       */
      key_info?: Record<string, never>;
      /** @description List of destination types with at least one destination. */
      keys?: Record<string, never>[];
    };
    SystemListSyncDestinationsTypeResponse: {
      /** @description List of destination types with at least one destination. */
      keys?: Record<string, never>[];
    };
    SystemListSyncGithubAppsResponse: {
      /** @description List of configured GitHub apps. */
      keys?: Record<string, never>[];
    };
    SystemPatchSyncConfigResponse: {
      /**
       * @description Disables the syncing process between Vault and external destinations.
       * @default false
       */
      disabled: boolean;
      /**
       * @description Maximum number of pending sync operations allowed on the queue.
       * @default 1000000
       */
      queue_capacity: number;
    };
    SystemPatchSyncDestinationsAwsSmNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemPatchSyncDestinationsAzureKvNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemPatchSyncDestinationsGcpSmNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemPatchSyncDestinationsGhNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemPatchSyncDestinationsInMemNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemPatchSyncDestinationsVercelProjectNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemReadConfigGroupPolicyApplicationResponse: {
      /** @description The current-set group_policy_application_mode. Will be either within_namespace_hierarchy or any. */
      group_policy_application_mode?: string;
    };
    SystemReadSyncAssociationsDestinationsResponse: {
      /**
       * Format: map
       * @description Map of external destinations associated with a given Vault secret.
       */
      associated_destinations?: Record<string, never>;
    };
    SystemReadSyncAssociationsMountSecret_nameResponse: {
      /**
       * Format: map
       * @description Map of external destinations associated with a given Vault secret.
       */
      associated_destinations?: Record<string, never>;
    };
    SystemReadSyncConfigResponse: {
      /**
       * @description Disables the syncing process between Vault and external destinations.
       * @default false
       */
      disabled: boolean;
      /**
       * @description Maximum number of pending sync operations allowed on the queue.
       * @default 1000000
       */
      queue_capacity: number;
    };
    SystemReadSyncDestinationsAwsSmNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemReadSyncDestinationsAzureKvNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemReadSyncDestinationsGcpSmNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemReadSyncDestinationsGhNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemReadSyncDestinationsInMemNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemReadSyncDestinationsTypeNameAssociationsResponse: {
      /**
       * Format: map
       * @description Map of Vault secrets associated with a given external destination.
       */
      associated_secrets?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemReadSyncDestinationsVercelProjectNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemReadSyncGithubAppsNameResponse: {
      /**
       * Format: int64
       * @description Application ID of the GitHub App.
       */
      app_id?: number;
      /** @description The name of the GitHub app. Used to identify the application when configuring the GitHub destination */
      name?: string;
    };
    SystemWriteConfigControlGroupRequest: {
      /**
       * Format: duration
       * @description The max TTL for a control group token.
       */
      max_ttl?: string;
    };
    SystemWriteConfigGroupPolicyApplicationRequest: {
      /** @description Configures how policies in groups should be applied, accepting 'within_namespace_hierarchy' (default) and 'any',which will allow policies to grant permissions in groups outside of those sharing a namespace hierarchy. */
      group_policy_application_mode?: string;
    };
    SystemWriteControlGroupAuthorizeRequest: {
      /** @description The accessor of the request to authorize. */
      accessor?: string;
    };
    SystemWriteControlGroupRequestRequest: {
      /** @description The accessor of the request. */
      accessor?: string;
    };
    SystemWriteInternalCountersActivityWriteRequest: {
      /** @description JSON input for generating mock data */
      input?: string;
    };
    SystemWriteManagedKeysTypeNameRequest: {
      /** @description Access key for authenticating to AWS */
      access_key?: string;
      /** @description The signature algorithm to use with this key */
      algorithm?: string;
      /** @description If true, allows users of the key to trigger key generation. If false and generation is needed, it will fail. */
      allow_generate_key?: boolean;
      /** @description If true, allows users of the key to provide key material which may replace keys that were previously present. allow_store_key being false overrides this behavior. */
      allow_replace_key?: boolean;
      /** @description If true, allows users of the key to provide key material where none was present. */
      allow_store_key?: boolean;
      /** @description If true, this key may be accessed by any mount without the mount's allowed_manage_keys field being set. */
      any_mount?: boolean;
      /** @description The client ID for credentials to invoke the Azure APIs. */
      client_id?: string;
      /** @description The client secret for credentials to invoke the Azure APIs. */
      client_secret?: string;
      /** @description The path for the GCP credential file */
      credentials?: string;
      /** @description The name of the key in GCP Cloud KMS */
      crypto_key?: string;
      /** @description The key version of an existing key in GCP Cloud KMS */
      crypto_key_version?: number;
      /** @description For ECDSA keys, the desired elliptic curve if the key is to be generated, either P256, P384, or P521. */
      curve?: string;
      /** @description The AWS endpoint to use */
      endpoint?: string;
      /** @description The Azure Cloud environment API endpoints to use. */
      environment?: string;
      /**
       * @description If true, forces read/write sessions on the HSM, to work around some buggy HSMs.
       * @default false
       */
      force_rw_session: boolean;
      /** @description The desired key length in bits if the RSA key is to be generated, either 2048, 3072, or 4096. */
      'key-bits'?: number;
      /** @description For RSA keys, the desired key length in bits if the key is to be generated, either 2048, 3072, or 4096. */
      key_bits?: number;
      /** @description The id of a PKCS#11 key to use. As key ids are created by the HSM, it is an error if the key does not yet exist. This value or key_label must be specified. */
      key_id?: string;
      /** @description The label of a PKCS#11 key to use. If the key does not exist and generation is enabled, this is the label that will be given to the generated key. This value or key_id must be specified. */
      key_label?: string;
      /** @description The name of the Azure Key Vault Key. */
      key_name?: string;
      /** @description The name of the key ring in GCP Cloud KMS */
      key_ring?: string;
      /** @description The type of the Azure Key Vault Key. Currently only `RSA-HSM` is supported. */
      key_type?: string;
      /** @description An identifier for the AWS KMS key. If the key already exists, this can be either the AWS-generated key ID or an alias. If the key is to be generated and the field is non-empty, the provided value will be used to create an alias for the key. */
      kms_key?: string;
      /** @description The name of a managed key access library, as defined in the Vault server configuration. */
      library?: string;
      /** @description The maximum number of concurrent operations that may be submitted to the HSM at a time. */
      max_parallel?: number;
      /** @description The mechanism for the given key, specified as a decimal or hexadecimal (prefixed by 0x) string. */
      mechanism?: string;
      /** @description The access PIN for the slot. */
      pin?: string;
      /** @description The name of the GCP project */
      project?: string;
      /** @description The GCP region used for the key ring */
      region?: string;
      /** @description The Azure Key Vault resource's DNS Suffix to connect to. Needs to be changed to connect to Azure's Managed HSM KeyVault instance type. */
      resource?: string;
      /** @description Secret key ID for authenticating to AWS */
      secret_key?: string;
      /** @description The slot number to use, specified as a string (e.g. "0"). */
      slot?: string;
      /** @description The tenant ID for the Azure Active Directory organization. */
      tenant_id?: string;
      /** @description The slot token label to use. */
      token_label?: string;
      /** @description A comma-delimited list of the allowed usages of this key. Valid values are encrypt, decrypt, sign, verify, wrap, unwrap, mac, and random. */
      usages?: string;
      /** @description The name of an existing Azure Key Vault instance. */
      vault_name?: string;
    };
    SystemWriteManagedKeysTypeNameTestSignRequest: {
      /**
       * @description The hashing algorithm to use when signing/verifying the random data.
       * @default sha2-256
       */
      hash_algorithm: string;
      /**
       * @description For RSA backed managed keys attempt to sign with PSS
       * @default false
       */
      use_pss: boolean;
    };
    SystemWriteMfaMethodDuoNameRequest: {
      /** @description API host name for Duo. */
      api_hostname?: string;
      /** @description Integration key for Duo. */
      integration_key?: string;
      /** @description The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated with this mount as the username in the mapping. */
      mount_accessor?: string;
      /** @description Push information for Duo. */
      push_info?: string;
      /** @description Secret key for Duo. */
      secret_key?: string;
      /** @description If true, the user is reminded to use the passcode upon MFA validation. This option does not enforce using the passcode. Defaults to false. */
      use_passcode?: boolean;
      /** @description A format string for mapping Identity names to MFA method names. Values to subtitute should be placed in {{}}. For example, "{{alias.name}}@example.com". Currently-supported mappings: alias.name: The name returned by the mount configured via the mount_accessor parameter If blank, the Alias's name field will be used as-is. */
      username_format?: string;
    };
    SystemWriteMfaMethodOktaNameRequest: {
      /** @description Okta API key. */
      api_token?: string;
      /** @description The base domain to use for the Okta API. When not specified in the configuration, "okta.com" is used. */
      base_url?: string;
      /** @description The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated with this mount as the username in the mapping. */
      mount_accessor?: string;
      /** @description Name of the organization to be used in the Okta API. */
      org_name?: string;
      /** @description If true, the username will only match the primary email for the account. Defaults to false. */
      primary_email?: boolean;
      /** @description (DEPRECATED) Use base_url instead. */
      production?: boolean;
      /** @description A format string for mapping Identity names to MFA method names. Values to subtitute should be placed in {{}}. For example, "{{alias.name}}@example.com". Currently-supported mappings: alias.name: The name returned by the mount configured via the mount_accessor parameter If blank, the Alias's name field will be used as-is. */
      username_format?: string;
    };
    SystemWriteMfaMethodPingidNameRequest: {
      /** @description The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated with this mount as the username in the mapping. */
      mount_accessor?: string;
      /** @description The settings file provided by Ping, Base64-encoded. This must be a settings file suitable for third-party clients, not the PingID SDK or PingFederate. */
      settings_file_base64?: string;
      /** @description A format string for mapping Identity names to MFA method names. Values to subtitute should be placed in {{}}. For example, "{{alias.name}}@example.com". Currently-supported mappings: alias.name: The name returned by the mount configured via the mount_accessor parameter If blank, the Alias's name field will be used as-is. */
      username_format?: string;
    };
    SystemWriteMfaMethodTotpNameAdminDestroyRequest: {
      /** @description Identifier of the entity from which the MFA method secret needs to be removed. */
      entity_id?: string;
    };
    SystemWriteMfaMethodTotpNameAdminGenerateRequest: {
      /** @description Entity ID on which the generated secret needs to get stored. */
      entity_id?: string;
    };
    SystemWriteMfaMethodTotpNameRequest: {
      /**
       * @description The hashing algorithm used to generate the TOTP token. Options include SHA1, SHA256 and SHA512.
       * @default SHA1
       */
      algorithm: string;
      /**
       * @description The number of digits in the generated TOTP token. This value can either be 6 or 8.
       * @default 6
       */
      digits: number;
      /** @description The name of the key's issuing organization. */
      issuer?: string;
      /**
       * @description Determines the size in bytes of the generated key.
       * @default 20
       */
      key_size: number;
      /** @description Max number of allowed validation attempts. */
      max_validation_attempts?: number;
      /**
       * Format: duration
       * @description The length of time used to generate a counter for the TOTP token calculation.
       * @default 30
       */
      period: string;
      /**
       * @description The pixel size of the generated square QR code.
       * @default 200
       */
      qr_size: number;
      /**
       * @description The number of delay periods that are allowed when validating a TOTP token. This value can either be 0 or 1.
       * @default 1
       */
      skew: number;
    };
    SystemWriteNamespacesApiLockUnlockPathRequest: {
      /** @description Key to unlock the namespace. */
      unlock_key?: string;
    };
    SystemWriteNamespacesApiLockUnlockRequest: {
      /** @description Key to unlock the namespace. */
      unlock_key?: string;
    };
    SystemWriteNamespacesPathRequest: {
      /**
       * Format: map
       * @description User-provided key-value pairs that are used to describe arbitrary information about a namespace.
       */
      custom_metadata?: Record<string, never>;
    };
    SystemWritePoliciesEgpNameRequest: {
      /** @description The enforcement level to apply to the policy. */
      enforcement_level?: string;
      /** @description The paths on which the policy should be applied. */
      paths?: string[];
      /** @description The rules of the policy. */
      policy?: string;
    };
    SystemWritePoliciesRgpNameRequest: {
      /** @description The enforcement level to apply to the policy. */
      enforcement_level?: string;
      /** @description The rules of the policy. */
      policy?: string;
    };
    SystemWriteQuotasLeaseCountNameRequest: {
      /** @description Whether all child namespaces can inherit this namespace quota. */
      inheritable?: boolean;
      /** @description Maximum number of leases allowed by the quota rule. */
      max_leases?: number;
      /** @description Path including the applicable namespace prefix. */
      path?: string;
      /** @description Login role to apply this quota to. Note that when set, path must be configured to a valid auth method with a concept of roles. */
      role?: string;
      /** @description Type of the quota rule. */
      type?: string;
    };
    SystemWriteReplicationDrPrimaryEnableRequest: {
      /** @description The address the secondary cluster should connect to. Defaults to the primary's cluster address. */
      primary_cluster_addr?: string;
    };
    SystemWriteReplicationDrPrimaryRevokeSecondaryRequest: {
      /** @description The secondary cluster ID to revoke */
      id?: string;
    };
    SystemWriteReplicationDrPrimarySecondaryTokenRequest: {
      /** @description An opaque identifier that can be used to identify and revoke a secondary cluster's access later. */
      id?: string;
      /** @description A base64-encoded public key generated by the secondary cluster. */
      secondary_public_key?: string;
      /**
       * Format: duration
       * @description The TTL to use for the secondary activation token. Defaults to 30 minutes.
       * @default 30m
       */
      ttl: string;
    };
    SystemWriteReplicationDrSecondaryDisableRequest: {
      /** @description DR operation token used to authorize this request. */
      dr_operation_token?: string;
    };
    SystemWriteReplicationDrSecondaryEnableRequest: {
      /** @description A path to a file containing a PEM-encoded CA certificate to verify the call against the primary's API address */
      ca_file?: string;
      /** @description A path to a directory containing PEM-encoded CA certificates to verify the call against the primary's API address */
      ca_path?: string;
      /** @description The client certificate to use for authentication, in PEM format. Note: client authentication for this operation will always use TLS 1.2 or higher. */
      client_cert_pem?: string;
      /** @description The client key to use for authentication, in PEM format. */
      client_key_pem?: string;
      /** @description The API address of the primary. If not set, the value the primary supplies in the token will be used, which is the primary's redirect address. */
      primary_api_addr?: string;
      /** @description The token given by the primary to activate secondary status for this cluster. */
      token?: string;
    };
    SystemWriteReplicationDrSecondaryMerkleCheckRequest: {
      /** @description DR operation token used to authorize this request. */
      dr_operation_token?: string;
    };
    SystemWriteReplicationDrSecondaryOperationTokenDeleteRequest: {
      /** @description DR operation token used to authorize this request. */
      dr_operation_token?: string;
    };
    SystemWriteReplicationDrSecondaryPromoteRequest: {
      /** @description DR operation token used to authorize this request. */
      dr_operation_token?: string;
      /** @description Set to true if the cluster should be promoted despite replication being in an error state. This could mean some data was not replicated to the secondary */
      force?: boolean;
      /** @description The address the secondary cluster should connect to. Defaults to the primary's cluster address. */
      primary_cluster_addr?: string;
    };
    SystemWriteReplicationDrSecondaryRecoverRequest: {
      /** @description DR operation token used to authorize this request. */
      dr_operation_token?: string;
    };
    SystemWriteReplicationDrSecondaryReindexRequest: {
      /** @description Enables a slower re-indexing which will perform a key level check to diagnose issues. Defaults false. */
      diff?: boolean;
      /** @description DR operation token used to authorize this request. */
      dr_operation_token?: string;
      /** @description Forces a complete re-indexing which only scans data available in the storage. Defaults false. */
      force?: boolean;
      /** @description Skips the tree flushing stage of the reindex process. This setting can be used to reduce the amount of time the tree is locked during a reindex process. If this node is killed before the full tree has been asynchronously flushed the reindex may not have applied fully and a new reindex may need to be done. Shutting down this node cleanly will cause the tree to be flushed prior to shutdown. Defaults false. */
      skip_flush?: boolean;
    };
    SystemWriteReplicationDrSecondaryUpdatePrimaryRequest: {
      /** @description A path to a file containing a PEM-encoded CA certificate to verify the call against the primary's API address */
      ca_file?: string;
      /** @description A path to a directory containing PEM-encoded CA certificates to verify the call against the primary's API address */
      ca_path?: string;
      /** @description The client certificate to use for authentication, in PEM format. Note: client authentication for this operation will always use TLS 1.2 or higher. */
      client_cert_pem?: string;
      /** @description The client key to use for authentication, in PEM format. */
      client_key_pem?: string;
      /** @description DR operation token used to authorize this request. */
      dr_operation_token?: string;
      /** @description The API address of the primary. If not set, the value the primary supplies in the token will be used, which is the primary's redirect address. */
      primary_api_addr?: string;
      /** @description The token given by the primary to activate secondary status for this cluster. */
      token?: string;
      /** @description A comma separated list of host:port strings to serve as new addresses for the primary cluster */
      update_primary_addrs?: string[];
    };
    SystemWriteReplicationForceCorruptionRequest: {
      /** @description force corrupting composite rootHashes */
      composite_root_hash?: boolean;
      /** @description force corrupting pages */
      page?: number;
      /** @description force corrupting subpages */
      subpage?: number;
      /** @description force corrupting a subtree */
      subtree?: string;
      /** @description force corrupting subtree rootHashes */
      subtree_root_hash?: boolean;
    };
    SystemWriteReplicationPerformancePrimaryEnableRequest: {
      /** @description The address the secondary cluster should connect to. Defaults to the primary's cluster address. */
      primary_cluster_addr?: string;
    };
    SystemWriteReplicationPerformancePrimaryPathsFilterIdRequest: {
      /**
       * @description The filter mode for the paths filter (allow or deny). Defaults to allow.
       * @default allow
       */
      mode: string;
      /** @description The paths to filter in replication. Must be a mount or a namespace. */
      paths?: string[];
    };
    SystemWriteReplicationPerformancePrimaryRevokeSecondaryRequest: {
      /** @description The secondary cluster ID to revoke */
      id?: string;
    };
    SystemWriteReplicationPerformancePrimarySecondaryTokenRequest: {
      /** @description An opaque identifier that can be used to identify and revoke a secondary cluster's access later. */
      id?: string;
      /** @description A base64-encoded public key generated by the secondary cluster. */
      secondary_public_key?: string;
      /**
       * Format: duration
       * @description The TTL to use for the secondary activation token. Defaults to 30 minutes.
       * @default 30m
       */
      ttl: string;
    };
    SystemWriteReplicationPerformanceSecondaryEnableRequest: {
      /** @description A path to a file containing a PEM-encoded CA certificate to verify the call against the primary's API address */
      ca_file?: string;
      /** @description A path to a directory containing PEM-encoded CA certificates to verify the call against the primary's API address */
      ca_path?: string;
      /** @description The client certificate to use for authentication, in PEM format. Note: client authentication for this operation will always use TLS 1.2 or higher. */
      client_cert_pem?: string;
      /** @description The client key to use for authentication, in PEM format. */
      client_key_pem?: string;
      /** @description The API address of the primary. If not set, the value the primary supplies in the token will be used, which is the primary's redirect address. */
      primary_api_addr?: string;
      /** @description The token given by the primary to activate secondary status for this cluster. */
      token?: string;
    };
    SystemWriteReplicationPerformanceSecondaryPromoteRequest: {
      /** @description Set to true if the cluster should be promoted despite replication being in an error state. This could mean some data was not replicated to the secondary */
      force?: boolean;
      /** @description The address the secondary cluster should connect to. Defaults to the primary's cluster address. */
      primary_cluster_addr?: string;
    };
    SystemWriteReplicationPerformanceSecondaryUpdatePrimaryRequest: {
      /** @description A path to a file containing a PEM-encoded CA certificate to verify the call against the primary's API address */
      ca_file?: string;
      /** @description A path to a directory containing PEM-encoded CA certificates to verify the call against the primary's API address */
      ca_path?: string;
      /** @description The client certificate to use for authentication, in PEM format. Note: client authentication for this operation will always use TLS 1.2 or higher. */
      client_cert_pem?: string;
      /** @description The client key to use for authentication, in PEM format. */
      client_key_pem?: string;
      /** @description The API address of the primary. If not set, the value the primary supplies in the token will be used, which is the primary's redirect address. */
      primary_api_addr?: string;
      /** @description The token given by the primary to activate secondary status for this cluster. */
      token?: string;
      /** @description A comma separated list of host:port strings to serve as new addresses for the primary cluster */
      update_primary_addrs?: string[];
    };
    SystemWriteReplicationPrimaryEnableRequest: {
      /** @description The address the secondary cluster should connect to. Defaults to the primary's cluster address. */
      primary_cluster_addr?: string;
    };
    SystemWriteReplicationPrimaryRevokeSecondaryRequest: {
      /** @description The secondary cluster ID to revoke */
      id?: string;
    };
    SystemWriteReplicationPrimarySecondaryTokenRequest: {
      /** @description An opaque identifier that can be used to identify and revoke a secondary cluster's access later. */
      id?: string;
      /** @description A base64-encoded public key generated by the secondary cluster. */
      secondary_public_key?: string;
      /**
       * Format: duration
       * @description The TTL to use for the secondary activation token. Defaults to 30 minutes.
       * @default 30m
       */
      ttl: string;
    };
    SystemWriteReplicationReindexRequest: {
      /** @description Enables a slower re-indexing which will perform a key level check to diagnose issues. Defaults false. */
      diff?: boolean;
      /** @description Forces a complete re-indexing which only scans data available in the storage. Defaults false. */
      force?: boolean;
      /** @description Skips the tree flushing stage of the reindex process. This setting can be used to reduce the amount of time the tree is locked during a reindex process. If this node is killed before the full tree has been asynchronously flushed the reindex may not have applied fully and a new reindex may need to be done. Shutting down this node cleanly will cause the tree to be flushed prior to shutdown. Defaults false. */
      skip_flush?: boolean;
    };
    SystemWriteReplicationSecondaryEnableRequest: {
      /** @description A path to a file containing a PEM-encoded CA certificate to verify the call against the primary's API address */
      ca_file?: string;
      /** @description A path to a directory containing PEM-encoded CA certificates to verify the call against the primary's API address */
      ca_path?: string;
      /** @description The client certificate to use for authentication, in PEM format. Note: client authentication for this operation will always use TLS 1.2 or higher. */
      client_cert_pem?: string;
      /** @description The client key to use for authentication, in PEM format. */
      client_key_pem?: string;
      /** @description The API address of the primary. If not set, the value the primary supplies in the token will be used, which is the primary's redirect address. */
      primary_api_addr?: string;
      /** @description The token given by the primary to activate secondary status for this cluster. */
      token?: string;
    };
    SystemWriteReplicationSecondaryPromoteRequest: {
      /** @description Set to true if the cluster should be promoted despite replication being in an error state. This could mean some data was not replicated to the secondary */
      force?: boolean;
      /** @description The address the secondary cluster should connect to. Defaults to the primary's cluster address. */
      primary_cluster_addr?: string;
    };
    SystemWriteReplicationSecondaryUpdatePrimaryRequest: {
      /** @description A path to a file containing a PEM-encoded CA certificate to verify the call against the primary's API address */
      ca_file?: string;
      /** @description A path to a directory containing PEM-encoded CA certificates to verify the call against the primary's API address */
      ca_path?: string;
      /** @description The client certificate to use for authentication, in PEM format. Note: client authentication for this operation will always use TLS 1.2 or higher. */
      client_cert_pem?: string;
      /** @description The client key to use for authentication, in PEM format. */
      client_key_pem?: string;
      /** @description The API address of the primary. If not set, the value the primary supplies in the token will be used, which is the primary's redirect address. */
      primary_api_addr?: string;
      /** @description The token given by the primary to activate secondary status for this cluster. */
      token?: string;
    };
    SystemWriteStorageRaftSnapshotAutoConfigNameRequest: {
      /** @description AWS access key ID */
      aws_access_key_id?: string;
      /** @description AWS bucket */
      aws_s3_bucket?: string;
      /** @description Disable TLS for the AWS endpoint, intended only for testing */
      aws_s3_disable_tls?: boolean;
      /** @description Use KMS to encrypt bucket contents */
      aws_s3_enable_kms?: boolean;
      /** @description AWS endpoint, typically only set when using a non-AWS S3 instance like Minio */
      aws_s3_endpoint?: string;
      /** @description Use the endpoint/bucket URL style instead of bucket.endpoint */
      aws_s3_force_path_style?: boolean;
      /** @description Use named KMS key */
      aws_s3_kms_key?: string;
      /** @description AWS region */
      aws_s3_region?: string;
      /** @description Use AES256 to encrypt bucket contents */
      aws_s3_server_side_encryption?: boolean;
      /** @description AWS secret access key */
      aws_secret_access_key?: string;
      /** @description AWS session token */
      aws_session_token?: string;
      /** @description Azure account key */
      azure_account_key?: string;
      /** @description Azure account name */
      azure_account_name?: string;
      /**
       * @description Azure blob environment
       * @default AZUREPUBLICCLOUD
       */
      azure_blob_environment: string;
      /** @description Azure container name */
      azure_container_name?: string;
      /** @description Azure blob storage endpoint */
      azure_endpoint?: string;
      /**
       * @description file/object prefix prepended to snapshot ID
       * @default vault-snapshot
       */
      file_prefix: string;
      /** @description Disable TLS, normally only for testing */
      google_disable_tls?: boolean;
      /** @description GCS endpoint */
      google_endpoint?: string;
      /** @description GCS bucket */
      google_gcs_bucket?: string;
      /** @description Service account key in JSON format */
      google_service_account_key?: string;
      /**
       * Format: duration
       * @description snapshot schedule
       * @default 3600000000000
       */
      interval: string;
      /** @description max space on disk to use for snapshots */
      local_max_space?: number;
      /** @description directory (local) or bucket prefix (cloud) for snapshot */
      path_prefix?: string;
      /**
       * @description how many snapshots to keep
       * @default 1
       */
      retain: number;
      /**
       * @description type of storage to use for the snapshots
       * @enum {string}
       */
      storage_type?: 'local' | 'azure-blob' | 'aws-s3' | 'google-gcs';
    };
    SystemWriteSyncDestinationsAwsSmNameRequest: {
      /** @description AWS access key ID to access the secrets manager. */
      access_key_id?: string;
      /**
       * Format: kvpairs
       * @description Custom tags to set on the secret managed at the destination. Custom tags are merged with system tags.
       */
      custom_tags?: Record<string, never>;
      /** @description Unique string used as a condition for extra security when assuming the AWS IAM role. Optional. Ignored if the role ARN is not set. */
      external_id?: string;
      /** @description Determines what level of information is synced as a distinct resource at the destination. Supports `secret-path` and `secret-key`. */
      granularity?: string;
      /** @description Asynchronously unsyncs all associated secrets with the destination then deletes the destination config. */
      purge?: boolean;
      /** @description AWS region where to manage secrets. */
      region?: string;
      /** @description AWS IAM role identifier Vault will assume when connecting to the Secrets Manager. Optional. Supports cross-account access. */
      role_arn?: string;
      /** @description AWS secret access key to access the secrets manager. */
      secret_access_key?: string;
      /**
       * @description Template describing how to generate external secret names. Supports a subset of the Go Template syntax.
       * @default
       */
      secret_name_template: string;
      /** @description List of custom tags to remove for patch requests. This field is ignored on create and update requests. */
      tags_to_remove?: string[];
    };
    SystemWriteSyncDestinationsAwsSmNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemWriteSyncDestinationsAzureKvNameRequest: {
      /** @description OAuth2 client id of an Azure app registration with access to the key vault. */
      client_id?: string;
      /** @description OAuth2 client secret of an Azure app registration with access to the key vault. */
      client_secret?: string;
      /** @description Azure environment name. If not provided, AzurePublicCloud is used. */
      cloud?: string;
      /**
       * Format: kvpairs
       * @description Custom tags to set on the secret managed at the destination. Custom tags are merged with system tags.
       */
      custom_tags?: Record<string, never>;
      /** @description Determines what level of information is synced as a distinct resource at the destination. Supports `secret-path` and `secret-key`. */
      granularity?: string;
      /** @description URI of the Azure Key Vault to access. */
      key_vault_uri?: string;
      /** @description Asynchronously unsyncs all associated secrets with the destination then deletes the destination config. */
      purge?: boolean;
      /**
       * @description Template describing how to generate external secret names. Supports a subset of the Go Template syntax.
       * @default
       */
      secret_name_template: string;
      /** @description List of custom tags to remove for patch requests. This field is ignored on create and update requests. */
      tags_to_remove?: string[];
      /** @description Tenant id for the Azure Active Directory. */
      tenant_id?: string;
    };
    SystemWriteSyncDestinationsAzureKvNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemWriteSyncDestinationsGcpSmNameRequest: {
      /** @description GCP IAM service account credentials JSON string to access the secret manager */
      credentials?: string;
      /**
       * Format: kvpairs
       * @description Custom tags to set on the secret managed at the destination. Custom tags are merged with system tags.
       */
      custom_tags?: Record<string, never>;
      /** @description Determines what level of information is synced as a distinct resource at the destination. Supports `secret-path` and `secret-key`. */
      granularity?: string;
      /** @description The target project to manage secrets in. If set, overrides the project derived from the service account JSON credentials or application default credentials. The credentials must be authorized to perform actions in the target project. */
      project_id?: string;
      /** @description Asynchronously unsyncs all associated secrets with the destination then deletes the destination config. */
      purge?: boolean;
      /**
       * @description Template describing how to generate external secret names. Supports a subset of the Go Template syntax.
       * @default
       */
      secret_name_template: string;
      /** @description List of custom tags to remove for patch requests. This field is ignored on create and update requests. */
      tags_to_remove?: string[];
    };
    SystemWriteSyncDestinationsGcpSmNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemWriteSyncDestinationsGhNameRequest: {
      /** @description Classic or fine-grained access token to access your GitHub organization. */
      access_token?: string;
      /** @description The user defined name of the GitHub App configuration. */
      app_name?: string;
      /** @description Determines what level of information is synced as a distinct resource at the destination. Supports `secret-path` and `secret-key`. */
      granularity?: string;
      /**
       * Format: int64
       * @description The ID of the GitHub App installation, returned by GitHub after installing the app on your repository
       */
      installation_id?: number;
      /** @description Asynchronously unsyncs all associated secrets with the destination then deletes the destination config. */
      purge?: boolean;
      /** @description Name of the repository where to manage secrets. For example for 'git clone github.com/acme/my-repo' the name is my-repo. */
      repository_name?: string;
      /** @description Organization name or username the repository belongs to. For example for 'git clone github.com/acme/my-repo' the owner is acme. */
      repository_owner?: string;
      /**
       * @description Template describing how to generate external secret names. Supports a subset of the Go Template syntax.
       * @default
       */
      secret_name_template: string;
    };
    SystemWriteSyncDestinationsGhNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemWriteSyncDestinationsInMemNameRequest: {
      /** @description Determines what level of information is synced as a distinct resource at the destination. Supports `secret-path` and `secret-key`. */
      granularity?: string;
      /** @description Asynchronously unsyncs all associated secrets with the destination then deletes the destination config. */
      purge?: boolean;
      /**
       * @description Template describing how to generate external secret names. Supports a subset of the Go Template syntax.
       * @default
       */
      secret_name_template: string;
    };
    SystemWriteSyncDestinationsInMemNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemWriteSyncDestinationsTypeNameAssociationsRemoveRequest: {
      /** @description Mount of the secret to configure or read. */
      mount?: string;
      /** @description Name of the secret to configure or read. */
      secret_name?: string;
    };
    SystemWriteSyncDestinationsTypeNameAssociationsRemoveResponse: {
      /**
       * Format: map
       * @description Map of Vault secrets associated with a given external destination.
       */
      associated_secrets?: Record<string, never>;
    };
    SystemWriteSyncDestinationsTypeNameAssociationsSetRequest: {
      /** @description Mount of the secret to configure or read. */
      mount?: string;
      /** @description Name of the secret to configure or read. */
      secret_name?: string;
    };
    SystemWriteSyncDestinationsTypeNameAssociationsSetResponse: {
      /**
       * Format: map
       * @description Map of Vault secrets associated with a given external destination.
       */
      associated_secrets?: Record<string, never>;
    };
    SystemWriteSyncDestinationsVercelProjectNameRequest: {
      /** @description Vercel API access token with the permissions to manage environment variables. */
      access_token?: string;
      /** @description Deployment environments where the environment variables are available. Accepts 'development', 'preview' & 'production'. */
      deployment_environments?: string[];
      /** @description Determines what level of information is synced as a distinct resource at the destination. Supports `secret-path` and `secret-key`. */
      granularity?: string;
      /** @description Project ID where to manage environment variables. */
      project_id?: string;
      /** @description Asynchronously unsyncs all associated secrets with the destination then deletes the destination config. */
      purge?: boolean;
      /**
       * @description Template describing how to generate external secret names. Supports a subset of the Go Template syntax.
       * @default
       */
      secret_name_template: string;
      /** @description Team ID the project belongs to. Optional. */
      team_id?: string;
    };
    SystemWriteSyncDestinationsVercelProjectNameResponse: {
      /**
       * Format: kvpairs
       * @description List of key value pairs of information necessary to connect with the external system.
       */
      connection_details?: Record<string, never>;
      /** @description Name of this secrets store. */
      name?: string;
      /** @description Type of this secrets store. */
      type?: string;
    };
    SystemWriteSyncGithubAppsNameRequest: {
      /**
       * Format: int64
       * @description Application ID of the GitHub App.
       */
      app_id?: number;
      /** @description Private key of the GitHub App. */
      private_key?: string;
    };
    SystemWriteSyncGithubAppsNameResponse: {
      /**
       * Format: int64
       * @description Application ID of the GitHub App.
       */
      app_id?: number;
      /** @description The name of the GitHub app. Used to identify the application when configuring the GitHub destination */
      name?: string;
    };
    SystemWriteUtilizationRequest: {
      /** @description Provides context about the conditions under which the report was generated and submitted. This message is not included in the license utilization bundle but will be included in the vault server logs. */
      message?: string;
      /** @description If set to true, includes only today’s snapshot data in response, no historical snapshot data. If not set, response includes all persisted snapshot data. */
      today_only?: boolean;
    };
    SystemWriteUtilizationResponse: {
      /** @description JSON serialized manual license reporting encoded in base64 */
      utilization_bundle?: string;
    };
    TerraformCloudConfigureRequest: {
      /**
       * @description The address to access Terraform Cloud or Enterprise. Default is "https://app.terraform.io".
       * @default https://app.terraform.io
       */
      address: string;
      /**
       * @description The base path for the Terraform Cloud or Enterprise API. Default is "/api/v2/".
       * @default /api/v2/
       */
      base_path: string;
      /** @description The token to access Terraform Cloud */
      token: string;
    };
    TerraformCloudWriteRoleRequest: {
      /**
       * Format: duration
       * @description Maximum time for role. If not set or set to 0, will use system default.
       */
      max_ttl?: string;
      /** @description Name of the Terraform Cloud or Enterprise organization */
      organization?: string;
      /** @description ID of the Terraform Cloud or Enterprise team under organization (e.g., settings/teams/team-xxxxxxxxxxxxx) */
      team_id?: string;
      /**
       * Format: duration
       * @description Default lease for generated credentials. If not set or set to 0, will use system default.
       */
      ttl?: string;
      /** @description ID of the Terraform Cloud or Enterprise user (e.g., user-xxxxxxxxxxxxxxxx) */
      user_id?: string;
    };
    TokenCreateAgainstRoleRequest: {
      /** @description Name to associate with this token */
      display_name?: string;
      /** @description Name of the entity alias to associate with this token */
      entity_alias?: string;
      /** @description Explicit Max TTL of this token */
      explicit_max_ttl?: string;
      /** @description Value for the token */
      id?: string;
      /**
       * @deprecated
       * @description Use 'ttl' instead
       */
      lease?: string;
      /**
       * Format: kvpairs
       * @description Arbitrary key=value metadata to associate with the token
       */
      meta?: Record<string, never>;
      /** @description Do not include default policy for this token */
      no_default_policy?: boolean;
      /** @description Create the token with no parent */
      no_parent?: boolean;
      /** @description Max number of uses for this token */
      num_uses?: number;
      /** @description Renew period */
      period?: string;
      /** @description List of policies for the token */
      policies?: string[];
      /**
       * @description Allow token to be renewed past its initial TTL up to system/mount maximum TTL
       * @default true
       */
      renewable: boolean;
      /** @description Time to live for this token */
      ttl?: string;
      /** @description Token type */
      type?: string;
    };
    TokenCreateOrphanRequest: {
      /** @description Name to associate with this token */
      display_name?: string;
      /** @description Name of the entity alias to associate with this token */
      entity_alias?: string;
      /** @description Explicit Max TTL of this token */
      explicit_max_ttl?: string;
      /** @description Value for the token */
      id?: string;
      /**
       * @deprecated
       * @description Use 'ttl' instead
       */
      lease?: string;
      /**
       * Format: kvpairs
       * @description Arbitrary key=value metadata to associate with the token
       */
      meta?: Record<string, never>;
      /** @description Do not include default policy for this token */
      no_default_policy?: boolean;
      /** @description Create the token with no parent */
      no_parent?: boolean;
      /** @description Max number of uses for this token */
      num_uses?: number;
      /** @description Renew period */
      period?: string;
      /** @description List of policies for the token */
      policies?: string[];
      /**
       * @description Allow token to be renewed past its initial TTL up to system/mount maximum TTL
       * @default true
       */
      renewable: boolean;
      /** @description Time to live for this token */
      ttl?: string;
      /** @description Token type */
      type?: string;
    };
    TokenCreateRequest: {
      /** @description Name to associate with this token */
      display_name?: string;
      /** @description Name of the entity alias to associate with this token */
      entity_alias?: string;
      /** @description Explicit Max TTL of this token */
      explicit_max_ttl?: string;
      /** @description Value for the token */
      id?: string;
      /**
       * @deprecated
       * @description Use 'ttl' instead
       */
      lease?: string;
      /**
       * Format: kvpairs
       * @description Arbitrary key=value metadata to associate with the token
       */
      meta?: Record<string, never>;
      /** @description Do not include default policy for this token */
      no_default_policy?: boolean;
      /** @description Create the token with no parent */
      no_parent?: boolean;
      /** @description Max number of uses for this token */
      num_uses?: number;
      /** @description Renew period */
      period?: string;
      /** @description List of policies for the token */
      policies?: string[];
      /**
       * @description Allow token to be renewed past its initial TTL up to system/mount maximum TTL
       * @default true
       */
      renewable: boolean;
      /** @description Time to live for this token */
      ttl?: string;
      /** @description Token type */
      type?: string;
    };
    TokenLookUpAccessorRequest: {
      /** @description Accessor of the token to look up (request body) */
      accessor?: string;
    };
    TokenLookUpRequest: {
      /** @description Token to lookup */
      token?: string;
    };
    TokenLookUpSelf2Request: {
      /** @description Token to look up (unused, does not need to be set) */
      token?: string;
    };
    TokenRenewAccessorRequest: {
      /** @description Accessor of the token to renew (request body) */
      accessor?: string;
      /**
       * Format: duration
       * @description The desired increment in seconds to the token expiration
       * @default 0
       */
      increment: string;
    };
    TokenRenewRequest: {
      /**
       * Format: duration
       * @description The desired increment in seconds to the token expiration
       * @default 0
       */
      increment: string;
      /** @description Token to renew (request body) */
      token?: string;
    };
    TokenRenewSelfRequest: {
      /**
       * Format: duration
       * @description The desired increment in seconds to the token expiration
       * @default 0
       */
      increment: string;
      /** @description Token to renew (unused, does not need to be set) */
      token?: string;
    };
    TokenRevokeAccessorRequest: {
      /** @description Accessor of the token (request body) */
      accessor?: string;
    };
    TokenRevokeOrphanRequest: {
      /** @description Token to revoke (request body) */
      token?: string;
    };
    TokenRevokeRequest: {
      /** @description Token to revoke (request body) */
      token?: string;
    };
    TokenWriteRoleRequest: {
      /** @description String or JSON list of allowed entity aliases. If set, specifies the entity aliases which are allowed to be used during token generation. This field supports globbing. */
      allowed_entity_aliases?: string[];
      /** @description If set, tokens can be created with any subset of the policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy names. */
      allowed_policies?: string[];
      /** @description If set, tokens can be created with any subset of glob matched policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy name globs. */
      allowed_policies_glob?: string[];
      /**
       * @deprecated
       * @description Use 'token_bound_cidrs' instead.
       */
      bound_cidrs?: string[];
      /** @description If set, successful token creation via this role will require that no policies in the given list are requested. The parameter is a comma-delimited string of policy names. */
      disallowed_policies?: string[];
      /** @description If set, successful token creation via this role will require that no requested policies glob match any of policies in this list. The parameter is a comma-delimited string of policy name globs. */
      disallowed_policies_glob?: string[];
      /**
       * Format: duration
       * @deprecated
       * @description Use 'token_explicit_max_ttl' instead.
       */
      explicit_max_ttl?: string;
      /** @description If true, tokens created via this role will be orphan tokens (have no parent) */
      orphan?: boolean;
      /** @description If set, tokens created via this role will contain the given suffix as a part of their path. This can be used to assist use of the 'revoke-prefix' endpoint later on. The given suffix must match the regular expression.\w[\w-.]+\w */
      path_suffix?: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use 'token_period' instead.
       */
      period?: string;
      /**
       * @description Tokens created via this role will be renewable or not according to this value. Defaults to "true".
       * @default true
       */
      renewable: boolean;
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
    };
    TotpCreateKeyRequest: {
      /** @description The name of the account associated with the key. Required if generate is true. */
      account_name?: string;
      /**
       * @description The hashing algorithm used to generate the TOTP token. Options include SHA1, SHA256 and SHA512.
       * @default SHA1
       */
      algorithm: string;
      /**
       * @description The number of digits in the generated TOTP token. This value can either be 6 or 8.
       * @default 6
       */
      digits: number;
      /**
       * @description Determines if a QR code and url are returned upon generating a key. Only used if generate is true.
       * @default true
       */
      exported: boolean;
      /**
       * @description Determines if a key should be generated by Vault or if a key is being passed from another service.
       * @default false
       */
      generate: boolean;
      /** @description The name of the key's issuing organization. Required if generate is true. */
      issuer?: string;
      /** @description The shared master key used to generate a TOTP token. Only used if generate is false. */
      key?: string;
      /**
       * @description Determines the size in bytes of the generated key. Only used if generate is true.
       * @default 20
       */
      key_size: number;
      /**
       * Format: duration
       * @description The length of time used to generate a counter for the TOTP token calculation.
       * @default 30
       */
      period: string;
      /**
       * @description The pixel size of the generated square QR code. Only used if generate is true and exported is true. If this value is 0, a QR code will not be returned.
       * @default 200
       */
      qr_size: number;
      /**
       * @description The number of delay periods that are allowed when validating a TOTP token. This value can either be 0 or 1. Only used if generate is true.
       * @default 1
       */
      skew: number;
      /** @description A TOTP url string containing all of the parameters for key setup. Only used if generate is false. */
      url?: string;
    };
    TotpValidateCodeRequest: {
      /** @description TOTP code to be validated. */
      code?: string;
    };
    TransitConfigureCacheRequest: {
      /**
       * @description Size of cache, use 0 for an unlimited cache size, defaults to 0
       * @default 0
       */
      size: number;
    };
    TransitConfigureKeyRequest: {
      /** @description Enables taking a backup of the named key in plaintext format. Once set, this cannot be disabled. */
      allow_plaintext_backup?: boolean;
      /**
       * Format: duration
       * @description Amount of time the key should live before being automatically rotated. A value of 0 disables automatic rotation for the key.
       */
      auto_rotate_period?: string;
      /** @description Whether to allow deletion of the key */
      deletion_allowed?: boolean;
      /** @description Enables export of the key. Once set, this cannot be disabled. */
      exportable?: boolean;
      /** @description If set, the minimum version of the key allowed to be decrypted. For signing keys, the minimum version allowed to be used for verification. */
      min_decryption_version?: number;
      /** @description If set, the minimum version of the key allowed to be used for encryption; or for signing keys, to be used for signing. If set to zero, only the latest version of the key is allowed. */
      min_encryption_version?: number;
    };
    TransitConfigureKeysRequest: {
      /** @description Whether to allow automatic upserting (creation) of keys on the encrypt endpoint. */
      disable_upsert?: boolean;
    };
    TransitCreateKeyRequest: {
      /** @description Enables taking a backup of the named key in plaintext format. Once set, this cannot be disabled. */
      allow_plaintext_backup?: boolean;
      /**
       * Format: duration
       * @description Amount of time the key should live before being automatically rotated. A value of 0 (default) disables automatic rotation for the key.
       * @default 0
       */
      auto_rotate_period: string;
      /** @description Base64 encoded context for key derivation. When reading a key with key derivation enabled, if the key type supports public keys, this will return the public key for the given context. */
      context?: string;
      /** @description Whether to support convergent encryption. This is only supported when using a key with key derivation enabled and will require all requests to carry both a context and 96-bit (12-byte) nonce. The given nonce will be used in place of a randomly generated nonce. As a result, when the same context and nonce are supplied, the same ciphertext is generated. It is *very important* when using this mode that you ensure that all nonces are unique for a given context. Failing to do so will severely impact the ciphertext's security. */
      convergent_encryption?: boolean;
      /** @description Enables key derivation mode. This allows for per-transaction unique keys for encryption operations. */
      derived?: boolean;
      /** @description Enables keys to be exportable. This allows for all the valid keys in the key ring to be exported. */
      exportable?: boolean;
      /**
       * @description The key size in bytes for the algorithm. Only applies to HMAC and must be no fewer than 32 bytes and no more than 512
       * @default 0
       */
      key_size: number;
      /** @description The UUID of the managed key to use for this transit key */
      managed_key_id?: string;
      /** @description The name of the managed key to use for this transit key */
      managed_key_name?: string;
      /**
       * @description The type of key to create. Currently, "aes128-gcm96" (symmetric), "aes256-gcm96" (symmetric), "ecdsa-p256" (asymmetric), "ecdsa-p384" (asymmetric), "ecdsa-p521" (asymmetric), "ed25519" (asymmetric), "rsa-2048" (asymmetric), "rsa-3072" (asymmetric), "rsa-4096" (asymmetric) are supported. Defaults to "aes256-gcm96".
       * @default aes256-gcm96
       */
      type: string;
    };
    TransitDecryptRequest: {
      /** @description When using an AEAD cipher mode, such as AES-GCM, this parameter allows passing associated data (AD/AAD) into the encryption function; this data must be passed on subsequent decryption requests but can be transited in plaintext. On successful decryption, both the ciphertext and the associated data are attested not to have been tampered with. */
      associated_data?: string;
      /** @description Specifies a list of items to be decrypted in a single batch. When this parameter is set, if the parameters 'ciphertext', 'context' and 'nonce' are also set, they will be ignored. Any batch output will preserve the order of the batch input. */
      batch_input?: Record<string, never>[];
      /** @description The ciphertext to decrypt, provided as returned by encrypt. */
      ciphertext?: string;
      /** @description Base64 encoded context for key derivation. Required if key derivation is enabled. */
      context?: string;
      /** @description Base64 encoded nonce value used during encryption. Must be provided if convergent encryption is enabled for this key and the key was generated with Vault 0.6.1. Not required for keys created in 0.6.2+. */
      nonce?: string;
      /** @description Ordinarily, if a batch item fails to decrypt due to a bad input, but other batch items succeed, the HTTP response code is 400 (Bad Request). Some applications may want to treat partial failures differently. Providing the parameter returns the given response code integer instead of a 400 in this case. If all values fail HTTP 400 is still returned. */
      partial_failure_response_code?: number;
    };
    TransitEncryptRequest: {
      /** @description When using an AEAD cipher mode, such as AES-GCM, this parameter allows passing associated data (AD/AAD) into the encryption function; this data must be passed on subsequent decryption requests but can be transited in plaintext. On successful decryption, both the ciphertext and the associated data are attested not to have been tampered with. */
      associated_data?: string;
      /** @description Specifies a list of items to be encrypted in a single batch. When this parameter is set, if the parameters 'plaintext', 'context' and 'nonce' are also set, they will be ignored. Any batch output will preserve the order of the batch input. */
      batch_input?: Record<string, never>[];
      /** @description Base64 encoded context for key derivation. Required if key derivation is enabled */
      context?: string;
      /** @description This parameter will only be used when a key is expected to be created. Whether to support convergent encryption. This is only supported when using a key with key derivation enabled and will require all requests to carry both a context and 96-bit (12-byte) nonce. The given nonce will be used in place of a randomly generated nonce. As a result, when the same context and nonce are supplied, the same ciphertext is generated. It is *very important* when using this mode that you ensure that all nonces are unique for a given context. Failing to do so will severely impact the ciphertext's security. */
      convergent_encryption?: boolean;
      /** @description The version of the key to use for encryption. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key. */
      key_version?: number;
      /** @description Base64 encoded nonce value. Must be provided if convergent encryption is enabled for this key and the key was generated with Vault 0.6.1. Not required for keys created in 0.6.2+. The value must be exactly 96 bits (12 bytes) long and the user must ensure that for any given context (and thus, any given encryption key) this nonce value is **never reused**. */
      nonce?: string;
      /** @description Ordinarily, if a batch item fails to encrypt due to a bad input, but other batch items succeed, the HTTP response code is 400 (Bad Request). Some applications may want to treat partial failures differently. Providing the parameter returns the given response code integer instead of a 400 in this case. If all values fail HTTP 400 is still returned. */
      partial_failure_response_code?: number;
      /** @description Base64 encoded plaintext value to be encrypted */
      plaintext?: string;
      /**
       * @description This parameter is required when encryption key is expected to be created. When performing an upsert operation, the type of key to create. Currently, "aes128-gcm96" (symmetric) and "aes256-gcm96" (symmetric) are the only types supported. Defaults to "aes256-gcm96".
       * @default aes256-gcm96
       */
      type: string;
    };
    TransitGenerateCsrForKeyRequest: {
      /** @description PEM encoded CSR template. The information attributes will be used as a basis for the CSR with the key in transit. If not set, an empty CSR is returned. */
      csr?: string;
      /** @description Optional version of key, 'latest' if not set */
      version?: number;
    };
    TransitGenerateDataKeyRequest: {
      /**
       * @description Number of bits for the key; currently 128, 256, and 512 bits are supported. Defaults to 256.
       * @default 256
       */
      bits: number;
      /** @description Context for key derivation. Required for derived keys. */
      context?: string;
      /** @description The version of the Vault key to use for encryption of the data key. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key. */
      key_version?: number;
      /** @description Nonce for when convergent encryption v1 is used (only in Vault 0.6.1) */
      nonce?: string;
    };
    TransitGenerateHmacRequest: {
      /**
       * @description Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 Defaults to "sha2-256".
       * @default sha2-256
       */
      algorithm: string;
      /** @description Specifies a list of items to be processed in a single batch. When this parameter is set, if the parameter 'input' is also set, it will be ignored. Any batch output will preserve the order of the batch input. */
      batch_input?: Record<string, never>[];
      /** @description The base64-encoded input data */
      input?: string;
      /** @description The version of the key to use for generating the HMAC. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key. */
      key_version?: number;
    };
    TransitGenerateHmacWithAlgorithmRequest: {
      /**
       * @description Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 Defaults to "sha2-256".
       * @default sha2-256
       */
      algorithm: string;
      /** @description Specifies a list of items to be processed in a single batch. When this parameter is set, if the parameter 'input' is also set, it will be ignored. Any batch output will preserve the order of the batch input. */
      batch_input?: Record<string, never>[];
      /** @description The base64-encoded input data */
      input?: string;
      /** @description The version of the key to use for generating the HMAC. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key. */
      key_version?: number;
    };
    TransitGenerateRandomRequest: {
      /**
       * @description The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
       * @default 32
       */
      bytes: number;
      /**
       * @description Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
       * @default base64
       */
      format: string;
    };
    TransitGenerateRandomWithBytesRequest: {
      /**
       * @description The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
       * @default 32
       */
      bytes: number;
      /**
       * @description Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
       * @default base64
       */
      format: string;
    };
    TransitGenerateRandomWithSourceAndBytesRequest: {
      /**
       * @description The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
       * @default 32
       */
      bytes: number;
      /**
       * @description Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
       * @default base64
       */
      format: string;
    };
    TransitGenerateRandomWithSourceRequest: {
      /**
       * @description The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
       * @default 32
       */
      bytes: number;
      /**
       * @description Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
       * @default base64
       */
      format: string;
    };
    TransitHashRequest: {
      /**
       * @description Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 Defaults to "sha2-256".
       * @default sha2-256
       */
      algorithm: string;
      /**
       * @description Encoding format to use. Can be "hex" or "base64". Defaults to "hex".
       * @default hex
       */
      format: string;
      /** @description The base64-encoded input data */
      input?: string;
    };
    TransitHashWithAlgorithmRequest: {
      /**
       * @description Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 Defaults to "sha2-256".
       * @default sha2-256
       */
      algorithm: string;
      /**
       * @description Encoding format to use. Can be "hex" or "base64". Defaults to "hex".
       * @default hex
       */
      format: string;
      /** @description The base64-encoded input data */
      input?: string;
    };
    TransitImportKeyRequest: {
      /** @description Enables taking a backup of the named key in plaintext format. Once set, this cannot be disabled. */
      allow_plaintext_backup?: boolean;
      /** @description True if the imported key may be rotated within Vault; false otherwise. */
      allow_rotation?: boolean;
      /**
       * Format: duration
       * @description Amount of time the key should live before being automatically rotated. A value of 0 (default) disables automatic rotation for the key.
       * @default 0
       */
      auto_rotate_period: string;
      /** @description The base64-encoded ciphertext of the keys. The AES key should be encrypted using OAEP with the wrapping key and then concatenated with the import key, wrapped by the AES key. */
      ciphertext?: string;
      /** @description Base64 encoded context for key derivation. When reading a key with key derivation enabled, if the key type supports public keys, this will return the public key for the given context. */
      context?: string;
      /** @description Enables key derivation mode. This allows for per-transaction unique keys for encryption operations. */
      derived?: boolean;
      /** @description Enables keys to be exportable. This allows for all the valid keys in the key ring to be exported. */
      exportable?: boolean;
      /**
       * @description The hash function used as a random oracle in the OAEP wrapping of the user-generated, ephemeral AES key. Can be one of "SHA1", "SHA224", "SHA256" (default), "SHA384", or "SHA512"
       * @default SHA256
       */
      hash_function: string;
      /** @description The plaintext PEM public key to be imported. If "ciphertext" is set, this field is ignored. */
      public_key?: string;
      /**
       * @description The type of key being imported. Currently, "aes128-gcm96" (symmetric), "aes256-gcm96" (symmetric), "ecdsa-p256" (asymmetric), "ecdsa-p384" (asymmetric), "ecdsa-p521" (asymmetric), "ed25519" (asymmetric), "rsa-2048" (asymmetric), "rsa-3072" (asymmetric), "rsa-4096" (asymmetric) are supported. Defaults to "aes256-gcm96".
       * @default aes256-gcm96
       */
      type: string;
    };
    TransitImportKeyVersionRequest: {
      /** @description The base64-encoded ciphertext of the keys. The AES key should be encrypted using OAEP with the wrapping key and then concatenated with the import key, wrapped by the AES key. */
      ciphertext?: string;
      /**
       * @description The hash function used as a random oracle in the OAEP wrapping of the user-generated, ephemeral AES key. Can be one of "SHA1", "SHA224", "SHA256" (default), "SHA384", or "SHA512"
       * @default SHA256
       */
      hash_function: string;
      /** @description The plaintext public key to be imported. If "ciphertext" is set, this field is ignored. */
      public_key?: string;
      /** @description Key version to be updated, if left empty, a new version will be created unless a private key is specified and the 'Latest' key is missing a private key. */
      version?: number;
    };
    TransitRestoreAndRenameKeyRequest: {
      /** @description Backed up key data to be restored. This should be the output from the 'backup/' endpoint. */
      backup?: string;
      /**
       * @description If set and a key by the given name exists, force the restore operation and override the key.
       * @default false
       */
      force: boolean;
    };
    TransitRestoreKeyRequest: {
      /** @description Backed up key data to be restored. This should be the output from the 'backup/' endpoint. */
      backup?: string;
      /**
       * @description If set and a key by the given name exists, force the restore operation and override the key.
       * @default false
       */
      force: boolean;
    };
    TransitRewrapRequest: {
      /** @description Specifies a list of items to be re-encrypted in a single batch. When this parameter is set, if the parameters 'ciphertext', 'context' and 'nonce' are also set, they will be ignored. Any batch output will preserve the order of the batch input. */
      batch_input?: Record<string, never>[];
      /** @description Ciphertext value to rewrap */
      ciphertext?: string;
      /** @description Base64 encoded context for key derivation. Required for derived keys. */
      context?: string;
      /** @description The version of the key to use for encryption. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key. */
      key_version?: number;
      /** @description Nonce for when convergent encryption is used */
      nonce?: string;
    };
    TransitRotateKeyRequest: {
      /** @description The UUID of the managed key to use for the new version of this transit key */
      managed_key_id?: string;
      /** @description The name of the managed key to use for the new version of this transit key */
      managed_key_name?: string;
    };
    TransitSetCertificateForKeyRequest: {
      /** @description PEM encoded certificate chain. It should be composed by one or more concatenated PEM blocks and ordered starting from the end-entity certificate. */
      certificate_chain: string;
      /** @description Optional version of key, 'latest' if not set */
      version?: number;
    };
    TransitSignRequest: {
      /**
       * @description Deprecated: use "hash_algorithm" instead.
       * @default sha2-256
       */
      algorithm: string;
      /** @description Specifies a list of items for processing. When this parameter is set, any supplied 'input' or 'context' parameters will be ignored. Responses are returned in the 'batch_results' array component of the 'data' element of the response. Any batch output will preserve the order of the batch input */
      batch_input?: Record<string, never>[];
      /** @description Base64 encoded context for key derivation. Required if key derivation is enabled; currently only available with ed25519 keys. */
      context?: string;
      /**
       * @description Hash algorithm to use (POST body parameter). Valid values are: * sha1 * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 * none Defaults to "sha2-256". Not valid for all key types, including ed25519. Using none requires setting prehashed=true and signature_algorithm=pkcs1v15, yielding a PKCSv1_5_NoOID instead of the usual PKCSv1_5_DERnull signature.
       * @default sha2-256
       */
      hash_algorithm: string;
      /** @description The base64-encoded input data */
      input?: string;
      /** @description The version of the key to use for signing. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key. */
      key_version?: number;
      /**
       * @description The method by which to marshal the signature. The default is 'asn1' which is used by openssl and X.509. It can also be set to 'jws' which is used for JWT signatures; setting it to this will also cause the encoding of the signature to be url-safe base64 instead of using standard base64 encoding. Currently only valid for ECDSA P-256 key types".
       * @default asn1
       */
      marshaling_algorithm: string;
      /** @description Set to 'true' when the input is already hashed. If the key type is 'rsa-2048', 'rsa-3072' or 'rsa-4096', then the algorithm used to hash the input should be indicated by the 'algorithm' parameter. */
      prehashed?: boolean;
      /**
       * @description The salt length used to sign. Currently only applies to the RSA PSS signature scheme. Options are 'auto' (the default used by Golang, causing the salt to be as large as possible when signing), 'hash' (causes the salt length to equal the length of the hash used in the signature), or an integer between the minimum and the maximum permissible salt lengths for the given RSA key size. Defaults to 'auto'.
       * @default auto
       */
      salt_length: string;
      /** @description The signature algorithm to use for signing. Currently only applies to RSA key types. Options are 'pss' or 'pkcs1v15'. Defaults to 'pss' */
      signature_algorithm?: string;
    };
    TransitSignWithAlgorithmRequest: {
      /**
       * @description Deprecated: use "hash_algorithm" instead.
       * @default sha2-256
       */
      algorithm: string;
      /** @description Specifies a list of items for processing. When this parameter is set, any supplied 'input' or 'context' parameters will be ignored. Responses are returned in the 'batch_results' array component of the 'data' element of the response. Any batch output will preserve the order of the batch input */
      batch_input?: Record<string, never>[];
      /** @description Base64 encoded context for key derivation. Required if key derivation is enabled; currently only available with ed25519 keys. */
      context?: string;
      /**
       * @description Hash algorithm to use (POST body parameter). Valid values are: * sha1 * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 * none Defaults to "sha2-256". Not valid for all key types, including ed25519. Using none requires setting prehashed=true and signature_algorithm=pkcs1v15, yielding a PKCSv1_5_NoOID instead of the usual PKCSv1_5_DERnull signature.
       * @default sha2-256
       */
      hash_algorithm: string;
      /** @description The base64-encoded input data */
      input?: string;
      /** @description The version of the key to use for signing. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key. */
      key_version?: number;
      /**
       * @description The method by which to marshal the signature. The default is 'asn1' which is used by openssl and X.509. It can also be set to 'jws' which is used for JWT signatures; setting it to this will also cause the encoding of the signature to be url-safe base64 instead of using standard base64 encoding. Currently only valid for ECDSA P-256 key types".
       * @default asn1
       */
      marshaling_algorithm: string;
      /** @description Set to 'true' when the input is already hashed. If the key type is 'rsa-2048', 'rsa-3072' or 'rsa-4096', then the algorithm used to hash the input should be indicated by the 'algorithm' parameter. */
      prehashed?: boolean;
      /**
       * @description The salt length used to sign. Currently only applies to the RSA PSS signature scheme. Options are 'auto' (the default used by Golang, causing the salt to be as large as possible when signing), 'hash' (causes the salt length to equal the length of the hash used in the signature), or an integer between the minimum and the maximum permissible salt lengths for the given RSA key size. Defaults to 'auto'.
       * @default auto
       */
      salt_length: string;
      /** @description The signature algorithm to use for signing. Currently only applies to RSA key types. Options are 'pss' or 'pkcs1v15'. Defaults to 'pss' */
      signature_algorithm?: string;
    };
    TransitTrimKeyRequest: {
      /** @description The minimum available version for the key ring. All versions before this version will be permanently deleted. This value can at most be equal to the lesser of 'min_decryption_version' and 'min_encryption_version'. This is not allowed to be set when either 'min_encryption_version' or 'min_decryption_version' is set to zero. */
      min_available_version?: number;
    };
    TransitVerifyRequest: {
      /**
       * @description Deprecated: use "hash_algorithm" instead.
       * @default sha2-256
       */
      algorithm: string;
      /** @description Specifies a list of items for processing. When this parameter is set, any supplied 'input', 'hmac' or 'signature' parameters will be ignored. Responses are returned in the 'batch_results' array component of the 'data' element of the response. Any batch output will preserve the order of the batch input */
      batch_input?: Record<string, never>[];
      /** @description Base64 encoded context for key derivation. Required if key derivation is enabled; currently only available with ed25519 keys. */
      context?: string;
      /**
       * @description Hash algorithm to use (POST body parameter). Valid values are: * sha1 * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 * none Defaults to "sha2-256". Not valid for all key types. See note about none on signing path.
       * @default sha2-256
       */
      hash_algorithm: string;
      /** @description The HMAC, including vault header/key version */
      hmac?: string;
      /** @description The base64-encoded input data to verify */
      input?: string;
      /**
       * @description The method by which to unmarshal the signature when verifying. The default is 'asn1' which is used by openssl and X.509; can also be set to 'jws' which is used for JWT signatures in which case the signature is also expected to be url-safe base64 encoding instead of standard base64 encoding. Currently only valid for ECDSA P-256 key types".
       * @default asn1
       */
      marshaling_algorithm: string;
      /** @description Set to 'true' when the input is already hashed. If the key type is 'rsa-2048', 'rsa-3072' or 'rsa-4096', then the algorithm used to hash the input should be indicated by the 'algorithm' parameter. */
      prehashed?: boolean;
      /**
       * @description The salt length used to sign. Currently only applies to the RSA PSS signature scheme. Options are 'auto' (the default used by Golang, causing the salt to be as large as possible when signing), 'hash' (causes the salt length to equal the length of the hash used in the signature), or an integer between the minimum and the maximum permissible salt lengths for the given RSA key size. Defaults to 'auto'.
       * @default auto
       */
      salt_length: string;
      /** @description The signature, including vault header/key version */
      signature?: string;
      /** @description The signature algorithm to use for signature verification. Currently only applies to RSA key types. Options are 'pss' or 'pkcs1v15'. Defaults to 'pss' */
      signature_algorithm?: string;
    };
    TransitVerifyWithAlgorithmRequest: {
      /**
       * @description Deprecated: use "hash_algorithm" instead.
       * @default sha2-256
       */
      algorithm: string;
      /** @description Specifies a list of items for processing. When this parameter is set, any supplied 'input', 'hmac' or 'signature' parameters will be ignored. Responses are returned in the 'batch_results' array component of the 'data' element of the response. Any batch output will preserve the order of the batch input */
      batch_input?: Record<string, never>[];
      /** @description Base64 encoded context for key derivation. Required if key derivation is enabled; currently only available with ed25519 keys. */
      context?: string;
      /**
       * @description Hash algorithm to use (POST body parameter). Valid values are: * sha1 * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 * none Defaults to "sha2-256". Not valid for all key types. See note about none on signing path.
       * @default sha2-256
       */
      hash_algorithm: string;
      /** @description The HMAC, including vault header/key version */
      hmac?: string;
      /** @description The base64-encoded input data to verify */
      input?: string;
      /**
       * @description The method by which to unmarshal the signature when verifying. The default is 'asn1' which is used by openssl and X.509; can also be set to 'jws' which is used for JWT signatures in which case the signature is also expected to be url-safe base64 encoding instead of standard base64 encoding. Currently only valid for ECDSA P-256 key types".
       * @default asn1
       */
      marshaling_algorithm: string;
      /** @description Set to 'true' when the input is already hashed. If the key type is 'rsa-2048', 'rsa-3072' or 'rsa-4096', then the algorithm used to hash the input should be indicated by the 'algorithm' parameter. */
      prehashed?: boolean;
      /**
       * @description The salt length used to sign. Currently only applies to the RSA PSS signature scheme. Options are 'auto' (the default used by Golang, causing the salt to be as large as possible when signing), 'hash' (causes the salt length to equal the length of the hash used in the signature), or an integer between the minimum and the maximum permissible salt lengths for the given RSA key size. Defaults to 'auto'.
       * @default auto
       */
      salt_length: string;
      /** @description The signature, including vault header/key version */
      signature?: string;
      /** @description The signature algorithm to use for signature verification. Currently only applies to RSA key types. Options are 'pss' or 'pkcs1v15'. Defaults to 'pss' */
      signature_algorithm?: string;
    };
    UiConfigDeleteCustomMessageResponse: {
      id?: string;
    };
    UiConfigReadCustomMessageResponse: {
      id?: string;
    };
    UiConfigUpdateCustomMessageRequest: {
      /** @default true */
      authenticated: boolean;
      /** Format: date-time */
      end_time?: string;
      /** Format: map */
      link?: Record<string, never>;
      message: string;
      /** Format: map */
      options?: Record<string, never>;
      /** Format: date-time */
      start_time: string;
      title: string;
      /** @default banner */
      type: string;
    };
    UiConfigUpdateCustomMessageResponse: {
      authenticated?: boolean;
      /** Format: date-time */
      end_time?: string;
      id?: string;
      /** Format: map */
      link?: Record<string, never>;
      message?: string;
      /** Format: map */
      options?: Record<string, never>;
      /** Format: date-time */
      start_time?: string;
      title?: string;
      type?: boolean;
    };
    UiHeadersConfigureRequest: {
      /** @description Returns multiple values if true */
      multivalue?: boolean;
      /** @description The values to set the header. */
      values?: string[];
    };
    UiHeadersListResponse: {
      /** @description Lists of configured UI headers. Omitted if list is empty */
      keys?: string[];
    };
    UiHeadersReadConfigurationResponse: {
      /** @description returns the first header value when `multivalue` request parameter is false */
      value?: string;
      /** @description returns all header values when `multivalue` request parameter is true */
      values?: string[];
    };
    UnsealRequest: {
      /** @description Specifies a single unseal key share. This is required unless reset is true. */
      key?: string;
      /** @description Specifies if previously-provided unseal keys are discarded and the unseal process is reset. */
      reset?: boolean;
    };
    UnsealResponse: {
      build_date?: string;
      cluster_id?: string;
      cluster_name?: string;
      hcp_link_resource_ID?: string;
      hcp_link_status?: string;
      initialized?: boolean;
      migration?: boolean;
      n?: number;
      nonce?: string;
      progress?: number;
      recovery_seal?: boolean;
      sealed?: boolean;
      storage_type?: string;
      t?: number;
      type?: string;
      version?: string;
    };
    UnwrapRequest: {
      token?: string;
    };
    UserpassLoginRequest: {
      /** @description Password for this user. */
      password?: string;
    };
    UserpassResetPasswordRequest: {
      /** @description Password for this user. */
      password?: string;
    };
    UserpassUpdatePoliciesRequest: {
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /** @description Comma-separated list of policies */
      token_policies?: string[];
    };
    UserpassWriteUserRequest: {
      /**
       * @deprecated
       * @description Use "token_bound_cidrs" instead. If this and "token_bound_cidrs" are both specified, only "token_bound_cidrs" will be used.
       */
      bound_cidrs?: string[];
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_max_ttl" instead. If this and "token_max_ttl" are both specified, only "token_max_ttl" will be used.
       */
      max_ttl?: string;
      /** @description Password for this user. */
      password?: string;
      /**
       * @deprecated
       * @description Use "token_policies" instead. If this and "token_policies" are both specified, only "token_policies" will be used.
       */
      policies?: string[];
      /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
      token_bound_cidrs?: string[];
      /**
       * Format: duration
       * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
       */
      token_explicit_max_ttl?: string;
      /**
       * Format: duration
       * @description The maximum lifetime of the generated token
       */
      token_max_ttl?: string;
      /** @description If true, the 'default' policy will not automatically be added to generated tokens */
      token_no_default_policy?: boolean;
      /** @description The maximum number of times a token may be used, a value of zero means unlimited */
      token_num_uses?: number;
      /**
       * Format: duration
       * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
       */
      token_period?: string;
      /** @description Comma-separated list of policies */
      token_policies?: string[];
      /**
       * Format: duration
       * @description The initial ttl of the token to generate
       */
      token_ttl?: string;
      /**
       * @description The type of token to generate, service or batch
       * @default default-service
       */
      token_type: string;
      /**
       * Format: duration
       * @deprecated
       * @description Use "token_ttl" instead. If this and "token_ttl" are both specified, only "token_ttl" will be used.
       */
      ttl?: string;
    };
    VersionHistoryResponse: {
      /** Format: kvpairs */
      key_info?: Record<string, never>;
      keys?: string[];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  'token-list-accessors': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'token-create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TokenCreateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-create-orphan': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TokenCreateOrphanRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-create-against-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        role_name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TokenCreateAgainstRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-look-up-2': {
    parameters: {
      query?: {
        /** @description Token to lookup */
        token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-look-up': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TokenLookUpRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-look-up-accessor': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TokenLookUpAccessorRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-look-up-self': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-look-up-self2': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TokenLookUpSelf2Request'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-renew': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TokenRenewRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-renew-accessor': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TokenRenewAccessorRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-renew-self': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TokenRenewSelfRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-revoke': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TokenRevokeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-revoke-accessor': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TokenRevokeAccessorRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-revoke-orphan': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TokenRevokeOrphanRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-revoke-self': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'token-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        role_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        role_name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TokenWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        role_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'token-tidy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ali-cloud-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AliCloudLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ali-cloud-list-auth-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'ali-cloud-read-auth-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role as it should appear in Vault. */
        role: string;
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ali-cloud-write-auth-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role as it should appear in Vault. */
        role: string;
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AliCloudWriteAuthRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ali-cloud-delete-auth-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role as it should appear in Vault. */
        role: string;
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ali-cloud-list-auth-roles2': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'app-role-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'app-role-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadRoleResponse'];
        };
      };
    };
  };
  'app-role-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-read-bind-secret-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadBindSecretIdResponse'];
        };
      };
    };
  };
  'app-role-write-bind-secret-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWriteBindSecretIdRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-delete-bind-secret-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-read-bound-cidr-list': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadBoundCidrListResponse'];
        };
      };
    };
  };
  'app-role-write-bound-cidr-list': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWriteBoundCidrListRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-delete-bound-cidr-list': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-write-custom-secret-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWriteCustomSecretIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleWriteCustomSecretIdResponse'];
        };
      };
    };
  };
  'app-role-read-local-secret-ids': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadLocalSecretIdsResponse'];
        };
      };
    };
  };
  'app-role-read-period': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadPeriodResponse'];
        };
      };
    };
  };
  'app-role-write-period': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWritePeriodRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-delete-period': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-read-policies': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadPoliciesResponse'];
        };
      };
    };
  };
  'app-role-write-policies': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWritePoliciesRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-delete-policies': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-read-role-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadRoleIdResponse'];
        };
      };
    };
  };
  'app-role-write-role-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWriteRoleIdRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-write-secret-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWriteSecretIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleWriteSecretIdResponse'];
        };
      };
    };
  };
  'app-role-destroy-secret-id-by-accessor': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleDestroySecretIdByAccessorRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-destroy-secret-id-by-accessor2': {
    parameters: {
      query?: {
        /** @description Accessor of the SecretID */
        secret_id_accessor?: string;
      };
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-look-up-secret-id-by-accessor': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleLookUpSecretIdByAccessorRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleLookUpSecretIdByAccessorResponse'];
        };
      };
    };
  };
  'app-role-read-secret-id-bound-cidrs': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadSecretIdBoundCidrsResponse'];
        };
      };
    };
  };
  'app-role-write-secret-id-bound-cidrs': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWriteSecretIdBoundCidrsRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-delete-secret-id-bound-cidrs': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-read-secret-id-num-uses': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadSecretIdNumUsesResponse'];
        };
      };
    };
  };
  'app-role-write-secret-id-num-uses': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWriteSecretIdNumUsesRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-delete-secret-id-num-uses': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-read-secret-id-ttl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadSecretIdTtlResponse'];
        };
      };
    };
  };
  'app-role-write-secret-id-ttl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWriteSecretIdTtlRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-delete-secret-id-ttl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-list-secret-ids': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'app-role-destroy-secret-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleDestroySecretIdRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-destroy-secret-id2': {
    parameters: {
      query?: {
        /** @description SecretID attached to the role. */
        secret_id?: string;
      };
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-look-up-secret-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleLookUpSecretIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleLookUpSecretIdResponse'];
        };
      };
    };
  };
  'app-role-read-token-bound-cidrs': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadTokenBoundCidrsResponse'];
        };
      };
    };
  };
  'app-role-write-token-bound-cidrs': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWriteTokenBoundCidrsRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-delete-token-bound-cidrs': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-read-token-max-ttl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadTokenMaxTtlResponse'];
        };
      };
    };
  };
  'app-role-write-token-max-ttl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWriteTokenMaxTtlRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-delete-token-max-ttl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-read-token-num-uses': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadTokenNumUsesResponse'];
        };
      };
    };
  };
  'app-role-write-token-num-uses': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWriteTokenNumUsesRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-delete-token-num-uses': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-read-token-ttl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AppRoleReadTokenTtlResponse'];
        };
      };
    };
  };
  'app-role-write-token-ttl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AppRoleWriteTokenTtlRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-delete-token-ttl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. Must be less than 4096 bytes. */
        role_name: string;
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'app-role-tidy-secret-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        approle_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-read-certificate-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the certificate. */
        cert_name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-configure-certificate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the certificate. */
        cert_name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsConfigureCertificateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-delete-certificate-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the certificate. */
        cert_name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-list-certificate-configurations': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'aws-read-client-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-configure-client': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsConfigureClientRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-delete-client-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-read-identity-integration-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-configure-identity-integration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsConfigureIdentityIntegrationRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-rotate-root-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-list-sts-role-relationships': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'aws-read-sts-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account. */
        account_id: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-write-sts-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account. */
        account_id: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsWriteStsRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-delete-sts-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account. */
        account_id: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-read-identity-access-list-tidy-settings': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-configure-identity-access-list-tidy-operation': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsConfigureIdentityAccessListTidyOperationRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-delete-identity-access-list-tidy-settings': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-read-identity-whitelist-tidy-settings': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-configure-identity-whitelist-tidy-operation': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsConfigureIdentityWhitelistTidyOperationRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-delete-identity-whitelist-tidy-settings': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-read-role-tag-blacklist-tidy-settings': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-configure-role-tag-blacklist-tidy-operation': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsConfigureRoleTagBlacklistTidyOperationRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-delete-role-tag-blacklist-tidy-settings': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-read-role-tag-deny-list-tidy-settings': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-configure-role-tag-deny-list-tidy-operation': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsConfigureRoleTagDenyListTidyOperationRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-delete-role-tag-deny-list-tidy-settings': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-list-identity-access-list': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'aws-read-identity-access-list': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID. */
        instance_id: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-delete-identity-access-list': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID. */
        instance_id: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-list-identity-whitelist': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'aws-read-identity-whitelist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID. */
        instance_id: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-delete-identity-whitelist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID. */
        instance_id: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-list-auth-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'aws-read-auth-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-write-auth-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsWriteAuthRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-delete-auth-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-write-role-tag': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsWriteRoleTagRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-list-auth-roles2': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'aws-list-role-tag-blacklists': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'aws-read-role-tag-blacklist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded. */
        role_tag: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-write-role-tag-blacklist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded. */
        role_tag: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-delete-role-tag-blacklist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded. */
        role_tag: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-list-role-tag-deny-lists': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'aws-read-role-tag-deny-list': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded. */
        role_tag: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-write-role-tag-deny-list': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded. */
        role_tag: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-delete-role-tag-deny-list': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded. */
        role_tag: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-tidy-identity-access-list': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsTidyIdentityAccessListRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-tidy-identity-whitelist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsTidyIdentityWhitelistRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-tidy-role-tag-blacklist': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsTidyRoleTagBlacklistRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-tidy-role-tag-deny-list': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsTidyRoleTagDenyListRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-read-auth-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-configure-auth': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AzureConfigureAuthRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-delete-auth-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AzureLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-list-auth-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'azure-read-auth-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-write-auth-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AzureWriteAuthRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-delete-auth-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-rotate-root-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cert-list-certificates': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'cert-read-certificate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the certificate */
        name: string;
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cert-write-certificate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the certificate */
        name: string;
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CertWriteCertificateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cert-delete-certificate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the certificate */
        name: string;
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cert-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cert-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CertConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cert-list-crls': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'cert-read-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the certificate */
        name: string;
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cert-write-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the certificate */
        name: string;
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CertWriteCrlRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cert-delete-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the certificate */
        name: string;
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cert-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cert_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CertLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cloud-foundry-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cf_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cloud-foundry-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cf_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CloudFoundryConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cloud-foundry-delete-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cf_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cloud-foundry-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cf_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CloudFoundryLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cloud-foundry-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        cf_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'cloud-foundry-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        cf_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cloud-foundry-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        cf_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CloudFoundryWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cloud-foundry-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        cf_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-read-auth-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-configure-auth': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudConfigureAuthRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'google-cloud-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-edit-labels-for-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudEditLabelsForRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-edit-service-accounts-for-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudEditServiceAccountsForRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-list-roles2': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'github-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'github-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GithubConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'github-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GithubLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'github-list-teams2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'github-list-teams': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'github-read-team-mapping': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Key for the teams mapping */
        key: string;
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'github-write-team-mapping': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Key for the teams mapping */
        key: string;
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GithubWriteTeamMappingRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'github-delete-team-mapping': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Key for the teams mapping */
        key: string;
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'github-list-users2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'github-list-users': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'github-read-user-mapping': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Key for the users mapping */
        key: string;
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'github-write-user-mapping': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Key for the users mapping */
        key: string;
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GithubWriteUserMappingRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'github-delete-user-mapping': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Key for the users mapping */
        key: string;
        /** @description Path that the backend was mounted at */
        github_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'jwt-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'jwt-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['JwtConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'jwt-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['JwtLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'jwt-oidc-request-authorization-url': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['JwtOidcRequestAuthorizationUrlRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'jwt-oidc-callback': {
    parameters: {
      query?: {
        client_nonce?: string;
        code?: string;
        state?: string;
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'jwt-oidc-callback-form-post': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['JwtOidcCallbackFormPostRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'jwt-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'jwt-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'jwt-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['JwtWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'jwt-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        jwt_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kerberos-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kerberos-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KerberosConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kerberos-read-ldap-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kerberos-configure-ldap': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KerberosConfigureLdapRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kerberos-list-groups': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'kerberos-read-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the LDAP group. */
        name: string;
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kerberos-write-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the LDAP group. */
        name: string;
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KerberosWriteGroupRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kerberos-delete-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the LDAP group. */
        name: string;
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kerberos-login2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kerberos-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kerberos_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KerberosLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-read-auth-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-configure-auth': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KubernetesConfigureAuthRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KubernetesLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-list-auth-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'kubernetes-read-auth-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-write-auth-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KubernetesWriteAuthRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-delete-auth-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-read-auth-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-configure-auth': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LdapConfigureAuthRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-rotate-root-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-list-groups': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'ldap-read-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the LDAP group. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-write-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the LDAP group. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LdapWriteGroupRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-delete-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the LDAP group. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description DN (distinguished name) to be used for login. */
        username: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LdapLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-list-users': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'ldap-read-user': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the LDAP user. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-write-user': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the LDAP user. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LdapWriteUserRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-delete-user': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the LDAP user. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oci-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        oci_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oci-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        oci_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OciConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oci-delete-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        oci_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oci-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        oci_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OciLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oci-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        oci_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'oci-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        oci_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oci-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        oci_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OciWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oci-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        oci_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'okta-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'okta-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OktaConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'okta-list-groups': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'okta-read-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the Okta group. */
        name: string;
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'okta-write-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the Okta group. */
        name: string;
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OktaWriteGroupRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'okta-delete-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the Okta group. */
        name: string;
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'okta-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username to be used for login. */
        username: string;
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OktaLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'okta-list-users': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'okta-read-user': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the user. */
        name: string;
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'okta-write-user': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the user. */
        name: string;
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OktaWriteUserRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'okta-delete-user': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the user. */
        name: string;
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'okta-verify': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Nonce provided during a login request to retrieve the number verification challenge for the matching request. */
        nonce: string;
        /** @description Path that the backend was mounted at */
        okta_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'radius-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        radius_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'radius-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        radius_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RadiusConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'radius-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        radius_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RadiusLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'radius-login-with-username': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username to be used for login. (URL parameter) */
        urlusername: string;
        /** @description Path that the backend was mounted at */
        radius_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RadiusLoginWithUsernameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'radius-list-users': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        radius_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'radius-read-user': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the RADIUS user. */
        name: string;
        /** @description Path that the backend was mounted at */
        radius_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'radius-write-user': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the RADIUS user. */
        name: string;
        /** @description Path that the backend was mounted at */
        radius_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RadiusWriteUserRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'radius-delete-user': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the RADIUS user. */
        name: string;
        /** @description Path that the backend was mounted at */
        radius_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'userpass-login': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username of the user. */
        username: string;
        /** @description Path that the backend was mounted at */
        userpass_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UserpassLoginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'userpass-list-users': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        userpass_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'userpass-read-user': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username for this user. */
        username: string;
        /** @description Path that the backend was mounted at */
        userpass_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'userpass-write-user': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username for this user. */
        username: string;
        /** @description Path that the backend was mounted at */
        userpass_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UserpassWriteUserRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'userpass-delete-user': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username for this user. */
        username: string;
        /** @description Path that the backend was mounted at */
        userpass_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'userpass-reset-password': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username for this user. */
        username: string;
        /** @description Path that the backend was mounted at */
        userpass_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UserpassResetPasswordRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'userpass-update-policies': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Username for this user. */
        username: string;
        /** @description Path that the backend was mounted at */
        userpass_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UserpassUpdatePoliciesRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cubbyhole-read': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Specifies the path of the secret. */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cubbyhole-write': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Specifies the path of the secret. */
        path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cubbyhole-delete': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Specifies the path of the secret. */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cubbyhole-list': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Specifies the path of the secret. */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'alias-create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AliasCreateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'alias-list-by-id': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'alias-read-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the alias */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'alias-update-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the alias */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AliasUpdateByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'alias-delete-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the alias */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EntityCreateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-create-alias': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EntityCreateAliasRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-list-aliases-by-id': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'entity-read-alias-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the alias */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-update-alias-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the alias */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EntityUpdateAliasByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-delete-alias-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the alias */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-batch-delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EntityBatchDeleteRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-list-by-id': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'entity-read-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the entity. If set, updates the corresponding existing entity. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-update-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the entity. If set, updates the corresponding existing entity. */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EntityUpdateByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-delete-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the entity. If set, updates the corresponding existing entity. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-merge': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EntityMergeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-list-by-name': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'entity-read-by-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the entity */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-update-by-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the entity */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EntityUpdateByNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-delete-by-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the entity */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'group-create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GroupCreateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'group-create-alias': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GroupCreateAliasRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'group-list-aliases-by-id': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'group-read-alias-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the group alias. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'group-update-alias-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the group alias. */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GroupUpdateAliasByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'group-delete-alias-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the group alias. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'group-list-by-id': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'group-read-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the group. If set, updates the corresponding existing group. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'group-update-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the group. If set, updates the corresponding existing group. */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GroupUpdateByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'group-delete-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the group. If set, updates the corresponding existing group. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'group-list-by-name': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'group-read-by-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the group. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'group-update-by-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the group. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GroupUpdateByNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'group-delete-by-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the group. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'entity-look-up': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EntityLookUpRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'group-look-up': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GroupLookUpRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-list-login-enforcements': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'mfa-read-login-enforcement': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name for this login enforcement configuration */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-write-login-enforcement': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name for this login enforcement configuration */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaWriteLoginEnforcementRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-delete-login-enforcement': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name for this login enforcement configuration */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-list-methods': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'mfa-create-duo-method': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaCreateDuoMethodRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-list-duo-methods': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'mfa-read-duo-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-update-duo-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaUpdateDuoMethodRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-delete-duo-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-create-okta-method': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaCreateOktaMethodRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-list-okta-methods': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'mfa-read-okta-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-update-okta-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaUpdateOktaMethodRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-delete-okta-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-create-ping-id-method': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaCreatePingIdMethodRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-list-ping-id-methods': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'mfa-read-ping-id-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-update-ping-id-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaUpdatePingIdMethodRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-delete-ping-id-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-create-totp-method': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaCreateTotpMethodRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-list-totp-methods': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'mfa-admin-destroy-totp-secret': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaAdminDestroyTotpSecretRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-admin-generate-totp-secret': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaAdminGenerateTotpSecretRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-generate-totp-secret': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaGenerateTotpSecretRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-read-totp-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-update-totp-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaUpdateTotpMethodRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-delete-totp-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-read-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for this MFA method. */
        method_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-read-public-keys': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-read-open-id-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-list-assignments': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'oidc-read-assignment': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the assignment */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-write-assignment': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the assignment */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OidcWriteAssignmentRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-delete-assignment': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the assignment */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-list-clients': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'oidc-read-client': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the client. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-write-client': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the client. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OidcWriteClientRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-delete-client': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the client. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-configure': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OidcConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-introspect': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OidcIntrospectRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-list-keys': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'oidc-read-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-write-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OidcWriteKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-delete-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-rotate-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OidcRotateKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-list-providers': {
    parameters: {
      query: {
        /** @description Filters the list of OIDC providers to those that allow the given client ID in their set of allowed_client_ids. */
        allowed_client_id?: string;
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'oidc-read-provider': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-write-provider': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OidcWriteProviderRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-delete-provider': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-read-provider-public-keys': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-read-provider-open-id-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-provider-authorize': {
    parameters: {
      query?: {
        /** @description The ID of the requesting client. */
        client_id?: string;
        /** @description The code challenge derived from the code verifier. */
        code_challenge?: string;
        /** @description The method that was used to derive the code challenge. The following methods are supported: 'S256', 'plain'. Defaults to 'plain'. */
        code_challenge_method?: string;
        /** @description The allowable elapsed time in seconds since the last time the end-user was actively authenticated. */
        max_age?: number;
        /** @description The value that will be returned in the ID token nonce claim after a token exchange. */
        nonce?: string;
        /** @description The redirection URI to which the response will be sent. */
        redirect_uri?: string;
        /** @description The OIDC authentication flow to be used. The following response types are supported: 'code' */
        response_type?: string;
        /** @description A space-delimited, case-sensitive list of scopes to be requested. The 'openid' scope is required. */
        scope?: string;
        /** @description The value used to maintain state between the authentication request and client. */
        state?: string;
      };
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-provider-authorize-with-parameters': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OidcProviderAuthorizeWithParametersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-provider-token': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OidcProviderTokenRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-provider-user-info': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-provider-user-info2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the provider */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'oidc-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OidcWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-list-scopes': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'oidc-read-scope': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the scope */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-write-scope': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the scope */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OidcWriteScopeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-delete-scope': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the scope */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-generate-token': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-read-oidc-child-well-known-keys': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the child issuer */
        child: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'oidc-read-oidc-child-well-known-openid-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the child issuer */
        child: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'persona-create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PersonaCreateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'persona-list-by-id': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'persona-read-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the persona */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'persona-update-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the persona */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PersonaUpdateByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'persona-delete-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the persona */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'auditing-list-enabled-devices': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'auditing-calculate-hash': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the backend. Cannot be delimited. Example: "mysql" */
        path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuditingCalculateHashRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuditingCalculateHashResponse'];
        };
      };
    };
  };
  'auditing-enable-device': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the backend. Cannot be delimited. Example: "mysql" */
        path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuditingEnableDeviceRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'auditing-disable-device': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the backend. Cannot be delimited. Example: "mysql" */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'auth-list-enabled-methods': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'auth-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to mount to. Cannot be delimited. Example: "user" */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthReadConfigurationResponse'];
        };
      };
    };
  };
  'auth-enable-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to mount to. Cannot be delimited. Example: "user" */
        path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthEnableMethodRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'auth-disable-method': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to mount to. Cannot be delimited. Example: "user" */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'auth-read-tuning-information': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Tune the configuration parameters for an auth path. */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthReadTuningInformationResponse'];
        };
      };
    };
  };
  'auth-tune-configuration-parameters': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Tune the configuration parameters for an auth path. */
        path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthTuneConfigurationParametersRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'query-token-capabilities': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryTokenCapabilitiesRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'query-token-accessor-capabilities': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryTokenAccessorCapabilitiesRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'query-token-self-capabilities': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryTokenSelfCapabilitiesRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'auditing-list-request-headers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuditingListRequestHeadersResponse'];
        };
      };
    };
  };
  'auditing-read-request-header-information': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        header: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'auditing-enable-request-header': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        header: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuditingEnableRequestHeaderRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'auditing-disable-request-header': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        header: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-config-control-group': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-config-control-group': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteConfigControlGroupRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-delete-config-control-group': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cors-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CorsReadConfigurationResponse'];
        };
      };
    };
  };
  'cors-configure': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CorsConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'cors-delete-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-config-group-policy-application': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemReadConfigGroupPolicyApplicationResponse'];
        };
      };
    };
  };
  'system-write-config-group-policy-application': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteConfigGroupPolicyApplicationRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'reload-subsystem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        subsystem: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'read-sanitized-configuration-state': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'create-custom-message': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateCustomMessageRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ui-config-list-custom-messages': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ui-config-read-custom-message': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the custom message */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UiConfigReadCustomMessageResponse'];
        };
      };
    };
  };
  'ui-config-update-custom-message': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the custom message */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UiConfigUpdateCustomMessageRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UiConfigUpdateCustomMessageResponse'];
        };
      };
    };
  };
  'ui-config-delete-custom-message': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the custom message */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UiConfigDeleteCustomMessageResponse'];
        };
      };
    };
  };
  'ui-headers-list': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UiHeadersListResponse'];
        };
      };
    };
  };
  'ui-headers-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the header. */
        header: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UiHeadersReadConfigurationResponse'];
        };
      };
    };
  };
  'ui-headers-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the header. */
        header: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UiHeadersConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ui-headers-delete-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the header. */
        header: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-control-group-authorize': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteControlGroupAuthorizeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-control-group-request': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteControlGroupRequestRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'decode-token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DecodeTokenRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'list-experimental-features': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'root-token-generation-read-progress2': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RootTokenGenerationReadProgress2Response'];
        };
      };
    };
  };
  'root-token-generation-initialize-2': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RootTokenGenerationInitialize2Request'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RootTokenGenerationInitialize2Response'];
        };
      };
    };
  };
  'root-token-generation-cancel-2': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'root-token-generation-read-progress': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RootTokenGenerationReadProgressResponse'];
        };
      };
    };
  };
  'root-token-generation-initialize': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RootTokenGenerationInitializeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RootTokenGenerationInitializeResponse'];
        };
      };
    };
  };
  'root-token-generation-cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'root-token-generation-update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RootTokenGenerationUpdateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RootTokenGenerationUpdateResponse'];
        };
      };
    };
  };
  'ha-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HaStatusResponse'];
        };
      };
    };
  };
  'read-health-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description initialized, unsealed, and active */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description unsealed and standby */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description data recovery mode replication secondary and active */
      472: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description not initialized */
      501: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description sealed */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'collect-host-information': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CollectHostInformationResponse'];
        };
      };
    };
  };
  'collect-in-flight-request-information': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'read-initialization-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  initialize: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InitializeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'internal-client-activity-report-counts': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'internal-client-activity-export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'internal-client-activity-report-counts-this-month': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-internal-counters-activity-write': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteInternalCountersActivityWriteRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'internal-client-activity-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'internal-client-activity-configure': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InternalClientActivityConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'internal-count-entities': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InternalCountEntitiesResponse'];
        };
      };
    };
  };
  'internal-count-requests': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'internal-count-tokens': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InternalCountTokensResponse'];
        };
      };
    };
  };
  'internal-inspect-router': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of subtree being observed */
        tag: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'read-verbosity-level-for': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'internal-generate-open-api-document': {
    parameters: {
      query?: {
        /** @description Context string appended to every operationId */
        context?: string;
        /** @description Use generic mount paths */
        generic_mount_paths?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'internal-generate-open-api-document-with-parameters': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InternalGenerateOpenApiDocumentWithParametersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'internal-ui-read-authenticated-active-custom-messages': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InternalUiReadAuthenticatedActiveCustomMessagesResponse'];
        };
      };
    };
  };
  'internal-ui-list-enabled-feature-flags': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InternalUiListEnabledFeatureFlagsResponse'];
        };
      };
    };
  };
  'internal-ui-list-enabled-visible-mounts': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InternalUiListEnabledVisibleMountsResponse'];
        };
      };
    };
  };
  'internal-ui-read-mount-information': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path of the mount. */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InternalUiReadMountInformationResponse'];
        };
      };
    };
  };
  'internal-ui-list-namespaces': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InternalUiListNamespacesResponse'];
        };
      };
    };
  };
  'internal-ui-read-resultant-acl': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InternalUiReadResultantAclResponse'];
        };
      };
      /** @description empty response returned if no client token */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'internal-ui-read-unauthenticated-active-custom-messages': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InternalUiReadUnauthenticatedActiveCustomMessagesResponse'];
        };
      };
    };
  };
  'internal-ui-read-version': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InternalUiReadVersionResponse'];
        };
      };
    };
  };
  'encryption-key-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'leader-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaderStatusResponse'];
        };
      };
    };
  };
  'leases-list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeasesListResponse'];
        };
      };
    };
  };
  'leases-count': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeasesCountResponse'];
        };
      };
    };
  };
  'leases-read-lease': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeasesReadLeaseRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeasesReadLeaseResponse'];
        };
      };
    };
  };
  'leases-look-up': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description The path to list leases under. Example: "aws/creds/deploy" */
        prefix: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeasesLookUpResponse'];
        };
      };
    };
  };
  'leases-renew-lease': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeasesRenewLeaseRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'leases-renew-lease-with-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The lease identifier to renew. This is included with a lease. */
        url_lease_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeasesRenewLeaseWithIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'leases-revoke-lease': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeasesRevokeLeaseRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'leases-force-revoke-lease-with-prefix': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to revoke keys under. Example: "prod/aws/ops" */
        prefix: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'leases-revoke-lease-with-prefix': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to revoke keys under. Example: "prod/aws/ops" */
        prefix: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeasesRevokeLeaseWithPrefixRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'leases-revoke-lease-with-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The lease identifier to renew. This is included with a lease. */
        url_lease_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeasesRevokeLeaseWithIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'leases-tidy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-license-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'locked-users-list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'locked-users-unlock': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description It is the name of the alias (user). For example, if the alias belongs to userpass backend, the name should be a valid username within userpass auth method. If the alias belongs to an approle auth method, the name should be a valid RoleID */
        alias_identifier: string;
        /** @description MountAccessor is the identifier of the mount entry to which the user belongs */
        mount_accessor: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'loggers-read-verbosity-level': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'loggers-update-verbosity-level': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LoggersUpdateVerbosityLevelRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'loggers-revert-verbosity-level': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'loggers-read-verbosity-level-for': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the logger to be modified. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'loggers-update-verbosity-level-for': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the logger to be modified. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LoggersUpdateVerbosityLevelForRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'loggers-revert-verbosity-level-for': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the logger to be modified. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-list-managed-keys-type': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description The type of the managed key. */
        type: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'system-read-managed-keys-type-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the managed key. */
        name: string;
        /** @description The type of the managed key. */
        type: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-managed-keys-type-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the managed key. */
        name: string;
        /** @description The type of the managed key. */
        type: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteManagedKeysTypeNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-delete-managed-keys-type-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the managed key. */
        name: string;
        /** @description The type of the managed key. */
        type: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-managed-keys-type-name-test-sign': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the managed key. */
        name: string;
        /** @description The type of the managed key. */
        type: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteManagedKeysTypeNameTestSignRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  metrics: {
    parameters: {
      query?: {
        /** @description Format to export metrics into. Currently accepts only "prometheus". */
        format?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-list-mfa-method': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'system-read-mfa-method-duo-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-mfa-method-duo-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteMfaMethodDuoNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-delete-mfa-method-duo-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-mfa-method-okta-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-mfa-method-okta-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteMfaMethodOktaNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-delete-mfa-method-okta-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-mfa-method-pingid-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-mfa-method-pingid-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteMfaMethodPingidNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-delete-mfa-method-pingid-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-mfa-method-totp-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-mfa-method-totp-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteMfaMethodTotpNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-delete-mfa-method-totp-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-mfa-method-totp-name-admin-destroy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteMfaMethodTotpNameAdminDestroyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-mfa-method-totp-name-admin-generate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteMfaMethodTotpNameAdminGenerateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-mfa-method-totp-name-generate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the MFA method. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mfa-validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaValidateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  monitor: {
    parameters: {
      query?: {
        /** @description Output format of logs. Supported values are "standard" and "json". The default is "standard". */
        log_format?: string;
        /** @description Log level to view system logs at. Currently supported values are "trace", "debug", "info", "warn", "error". */
        log_level?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mounts-list-secrets-engines': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mounts-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to mount to. Example: "aws/east" */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MountsReadConfigurationResponse'];
        };
      };
    };
  };
  'mounts-enable-secrets-engine': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to mount to. Example: "aws/east" */
        path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MountsEnableSecretsEngineRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mounts-disable-secrets-engine': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to mount to. Example: "aws/east" */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mounts-read-tuning-information': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to mount to. Example: "aws/east" */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MountsReadTuningInformationResponse'];
        };
      };
    };
  };
  'mounts-tune-configuration-parameters': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to mount to. Example: "aws/east" */
        path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MountsTuneConfigurationParametersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-list-namespaces': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'system-write-namespaces-api-lock-lock': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-namespaces-api-lock-lock-path': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Optional relative path for locking descendants of the current namespace. */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-namespaces-api-lock-unlock': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteNamespacesApiLockUnlockRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-namespaces-api-lock-unlock-path': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Optional relative path for unlocking descendants of the current namespace. */
        path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteNamespacesApiLockUnlockPathRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-namespaces-path': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path of the namespace. */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-namespaces-path': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path of the namespace. */
        path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteNamespacesPathRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-delete-namespaces-path': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path of the namespace. */
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'plugins-catalog-list-plugins': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PluginsCatalogListPluginsResponse'];
        };
      };
    };
  };
  'plugins-catalog-read-plugin-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PluginsCatalogReadPluginConfigurationResponse'];
        };
      };
    };
  };
  'plugins-catalog-register-plugin': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PluginsCatalogRegisterPluginRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'plugins-catalog-remove-plugin': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'plugins-catalog-list-plugins-with-type': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description The type of the plugin, may be auth, secret, or database */
        type: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PluginsCatalogListPluginsWithTypeResponse'];
        };
      };
    };
  };
  'plugins-catalog-read-plugin-configuration-with-type': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin */
        name: string;
        /** @description The type of the plugin, may be auth, secret, or database */
        type: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PluginsCatalogReadPluginConfigurationWithTypeResponse'];
        };
      };
    };
  };
  'plugins-catalog-register-plugin-with-type': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin */
        name: string;
        /** @description The type of the plugin, may be auth, secret, or database */
        type: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PluginsCatalogRegisterPluginWithTypeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'plugins-catalog-remove-plugin-with-type': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin */
        name: string;
        /** @description The type of the plugin, may be auth, secret, or database */
        type: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'plugins-catalog-pins-list-pinned-versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PluginsCatalogPinsListPinnedVersionsResponse'];
        };
      };
    };
  };
  'plugins-catalog-pins-read-pinned-version': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin */
        name: string;
        /** @description The type of the plugin, may be auth, secret, or database */
        type: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PluginsCatalogPinsReadPinnedVersionResponse'];
        };
      };
    };
  };
  'plugins-catalog-pins-create-pinned-version': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin */
        name: string;
        /** @description The type of the plugin, may be auth, secret, or database */
        type: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PluginsCatalogPinsCreatePinnedVersionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'plugins-catalog-pins-remove-pinned-version': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin */
        name: string;
        /** @description The type of the plugin, may be auth, secret, or database */
        type: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'plugins-reload-backends': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PluginsReloadBackendsRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PluginsReloadBackendsResponse'];
        };
      };
      /** @description OK */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PluginsReloadBackendsResponse'];
        };
      };
    };
  };
  'system-read-plugins-reload-backend-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'reload-plugins': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin to reload, as registered in the plugin catalog. */
        name: string;
        /** @description The type of the plugin to reload, as registered in the plugin catalog. */
        type: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReloadPluginsRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReloadPluginsResponse'];
        };
      };
      /** @description OK */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReloadPluginsResponse'];
        };
      };
    };
  };
  'plugins-runtimes-catalog-list-plugins-runtimes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PluginsRuntimesCatalogListPluginsRuntimesResponse'];
        };
      };
    };
  };
  'plugins-runtimes-catalog-list-plugins-runtimes': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PluginsRuntimesCatalogListPluginsRuntimesResponse'];
        };
      };
    };
  };
  'plugins-runtimes-catalog-read-plugin-runtime-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin runtime */
        name: string;
        /** @description The type of the plugin runtime */
        type: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PluginsRuntimesCatalogReadPluginRuntimeConfigurationResponse'];
        };
      };
    };
  };
  'plugins-runtimes-catalog-register-plugin-runtime': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin runtime */
        name: string;
        /** @description The type of the plugin runtime */
        type: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PluginsRuntimesCatalogRegisterPluginRuntimeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'plugins-runtimes-catalog-remove-plugin-runtime': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the plugin runtime */
        name: string;
        /** @description The type of the plugin runtime */
        type: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'policies-list-acl-policies': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PoliciesListAclPoliciesResponse'];
        };
      };
    };
  };
  'policies-read-acl-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PoliciesReadAclPolicyResponse'];
        };
      };
    };
  };
  'policies-write-acl-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PoliciesWriteAclPolicyRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'policies-delete-acl-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-list-policies-egp': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'system-read-policies-egp-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-policies-egp-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWritePoliciesEgpNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-delete-policies-egp-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'policies-list-password-policies': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'policies-read-password-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the password policy. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PoliciesReadPasswordPolicyResponse'];
        };
      };
    };
  };
  'policies-write-password-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the password policy. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PoliciesWritePasswordPolicyRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'policies-delete-password-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the password policy. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'policies-generate-password-from-password-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the password policy. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PoliciesGeneratePasswordFromPasswordPolicyResponse'];
        };
      };
    };
  };
  'system-list-policies-rgp': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'system-read-policies-rgp-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-policies-rgp-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWritePoliciesRgpNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-delete-policies-rgp-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'policies-list-acl-policies2': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PoliciesListAclPolicies2Response'];
        };
      };
    };
  };
  'policies-list-acl-policies3': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PoliciesListAclPolicies3Response'];
        };
      };
    };
  };
  'policies-read-acl-policy2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PoliciesReadAclPolicy2Response'];
        };
      };
    };
  };
  'policies-write-acl-policy2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PoliciesWriteAclPolicy2Request'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'policies-delete-acl-policy2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the policy. Example: "ops" */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pprof-index': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pprof-memory-allocations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pprof-blocking': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pprof-command-line': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pprof-goroutines': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pprof-memory-allocations-live': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pprof-mutexes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pprof-cpu-profile': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pprof-symbols': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pprof-thread-creations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pprof-execution-trace': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'rate-limit-quotas-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RateLimitQuotasReadConfigurationResponse'];
        };
      };
    };
  };
  'rate-limit-quotas-configure': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RateLimitQuotasConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-list-quotas-lease-count': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'system-read-quotas-lease-count-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the quota rule. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-quotas-lease-count-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the quota rule. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteQuotasLeaseCountNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-delete-quotas-lease-count-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the quota rule. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'rate-limit-quotas-list': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'rate-limit-quotas-read': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the quota rule. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RateLimitQuotasReadResponse'];
        };
      };
    };
  };
  'rate-limit-quotas-write': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the quota rule. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RateLimitQuotasWriteRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'rate-limit-quotas-delete': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the quota rule. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'raw-read': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RawReadResponse'];
        };
      };
    };
  };
  'raw-write': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RawWriteRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'raw-delete': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'raw-list': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'rekey-read-backup-key': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RekeyReadBackupKeyResponse'];
        };
      };
    };
  };
  'rekey-delete-backup-key': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'rekey-attempt-read-progress': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RekeyAttemptReadProgressResponse'];
        };
      };
    };
  };
  'rekey-attempt-initialize': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RekeyAttemptInitializeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RekeyAttemptInitializeResponse'];
        };
      };
    };
  };
  'rekey-attempt-cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'rekey-read-backup-recovery-key': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RekeyReadBackupRecoveryKeyResponse'];
        };
      };
    };
  };
  'rekey-delete-backup-recovery-key': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'rekey-attempt-update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RekeyAttemptUpdateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RekeyAttemptUpdateResponse'];
        };
      };
    };
  };
  'rekey-verification-read-progress': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RekeyVerificationReadProgressResponse'];
        };
      };
    };
  };
  'rekey-verification-update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RekeyVerificationUpdateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RekeyVerificationUpdateResponse'];
        };
      };
    };
  };
  'rekey-verification-cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RekeyVerificationCancelResponse'];
        };
      };
    };
  };
  remount: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RemountRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RemountResponse'];
        };
      };
    };
  };
  'remount-status': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the migration operation */
        migration_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RemountStatusResponse'];
        };
      };
    };
  };
  'leases-renew-lease2': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeasesRenewLease2Request'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'leases-renew-lease-with-id2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The lease identifier to renew. This is included with a lease. */
        url_lease_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeasesRenewLeaseWithId2Request'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-primary-demote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-primary-disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-primary-enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationDrPrimaryEnableRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-primary-revoke-secondary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationDrPrimaryRevokeSecondaryRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-primary-secondary-token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationDrPrimarySecondaryTokenRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-secondary-config-reload-subsystem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        subsystem: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-secondary-disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationDrSecondaryDisableRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-secondary-enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationDrSecondaryEnableRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-secondary-generate-public-key': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-replication-dr-secondary-license-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-secondary-merkle-check': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationDrSecondaryMerkleCheckRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-secondary-operation-token-delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationDrSecondaryOperationTokenDeleteRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-secondary-promote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationDrSecondaryPromoteRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-secondary-recover': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationDrSecondaryRecoverRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-secondary-reindex': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationDrSecondaryReindexRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-dr-secondary-update-primary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationDrSecondaryUpdatePrimaryRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-replication-dr-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-force-corruption': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationForceCorruptionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-merkle-check': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-performance-primary-demote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-performance-primary-disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-replication-performance-primary-dynamic-filter-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The opaque identifier used to identify the secondary. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-performance-primary-enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationPerformancePrimaryEnableRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-replication-performance-primary-paths-filter-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The opaque identifier used to identify the secondary. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-performance-primary-paths-filter-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The opaque identifier used to identify the secondary. */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationPerformancePrimaryPathsFilterIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-delete-replication-performance-primary-paths-filter-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The opaque identifier used to identify the secondary. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-performance-primary-revoke-secondary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationPerformancePrimaryRevokeSecondaryRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-performance-primary-secondary-token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationPerformancePrimarySecondaryTokenRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-performance-secondary-disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-replication-performance-secondary-dynamic-filter-id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The opaque identifier used to identify the secondary. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-performance-secondary-enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationPerformanceSecondaryEnableRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-performance-secondary-generate-public-key': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-performance-secondary-promote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationPerformanceSecondaryPromoteRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-performance-secondary-update-primary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationPerformanceSecondaryUpdatePrimaryRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-replication-performance-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-primary-demote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-primary-disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-primary-enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationPrimaryEnableRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-primary-revoke-secondary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationPrimaryRevokeSecondaryRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-primary-secondary-token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationPrimarySecondaryTokenRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-recover': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-reindex': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationReindexRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-secondary-disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-secondary-enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationSecondaryEnableRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-secondary-promote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationSecondaryPromoteRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-replication-secondary-update-primary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteReplicationSecondaryUpdatePrimaryRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-replication-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'leases-revoke-lease2': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeasesRevokeLease2Request'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'leases-force-revoke-lease-with-prefix2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to revoke keys under. Example: "prod/aws/ops" */
        prefix: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'leases-revoke-lease-with-prefix2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The path to revoke keys under. Example: "prod/aws/ops" */
        prefix: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeasesRevokeLeaseWithPrefix2Request'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'leases-revoke-lease-with-id2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The lease identifier to renew. This is included with a lease. */
        url_lease_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeasesRevokeLeaseWithId2Request'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'encryption-key-rotate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'encryption-key-read-rotation-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncryptionKeyReadRotationConfigurationResponse'];
        };
      };
    };
  };
  'encryption-key-configure-rotation': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EncryptionKeyConfigureRotationRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  seal: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'seal-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SealStatusResponse'];
        };
      };
    };
  };
  'system-read-sealwrap-rewrap': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-sealwrap-rewrap': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'step-down-leader': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-list-storage-raft-snapshot-auto-config': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'system-read-storage-raft-snapshot-auto-config-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description name of configuration to update */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-write-storage-raft-snapshot-auto-config-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description name of configuration to update */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteStorageRaftSnapshotAutoConfigNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-delete-storage-raft-snapshot-auto-config-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description name of configuration to update */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-storage-raft-snapshot-auto-status-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description name of configuration to update */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-list-sync-associations': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemListSyncAssociationsResponse'];
        };
      };
    };
  };
  'system-read-sync-associations-destinations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemReadSyncAssociationsDestinationsResponse'];
        };
      };
    };
  };
  'system-read-sync-associations-mount-secret_name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Mount of the secret to configure or read. */
        mount: string;
        /** @description Name of the secret to configure or read. */
        secret_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemReadSyncAssociationsMountSecret_nameResponse'];
        };
      };
    };
  };
  'system-read-sync-config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemReadSyncConfigResponse'];
        };
      };
    };
  };
  'system-delete-sync-config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemDeleteSyncConfigResponse'];
        };
      };
    };
  };
  'system-list-sync-destinations': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemListSyncDestinationsResponse'];
        };
      };
    };
  };
  'system-read-sync-destinations-aws-sm-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemReadSyncDestinationsAwsSmNameResponse'];
        };
      };
    };
  };
  'system-write-sync-destinations-aws-sm-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteSyncDestinationsAwsSmNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemWriteSyncDestinationsAwsSmNameResponse'];
        };
      };
    };
  };
  'system-delete-sync-destinations-aws-sm-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-sync-destinations-azure-kv-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemReadSyncDestinationsAzureKvNameResponse'];
        };
      };
    };
  };
  'system-write-sync-destinations-azure-kv-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteSyncDestinationsAzureKvNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemWriteSyncDestinationsAzureKvNameResponse'];
        };
      };
    };
  };
  'system-delete-sync-destinations-azure-kv-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-sync-destinations-gcp-sm-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemReadSyncDestinationsGcpSmNameResponse'];
        };
      };
    };
  };
  'system-write-sync-destinations-gcp-sm-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteSyncDestinationsGcpSmNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemWriteSyncDestinationsGcpSmNameResponse'];
        };
      };
    };
  };
  'system-delete-sync-destinations-gcp-sm-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-sync-destinations-gh-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemReadSyncDestinationsGhNameResponse'];
        };
      };
    };
  };
  'system-write-sync-destinations-gh-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteSyncDestinationsGhNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemWriteSyncDestinationsGhNameResponse'];
        };
      };
    };
  };
  'system-delete-sync-destinations-gh-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-sync-destinations-in-mem-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemReadSyncDestinationsInMemNameResponse'];
        };
      };
    };
  };
  'system-write-sync-destinations-in-mem-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteSyncDestinationsInMemNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemWriteSyncDestinationsInMemNameResponse'];
        };
      };
    };
  };
  'system-delete-sync-destinations-in-mem-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-read-sync-destinations-vercel-project-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemReadSyncDestinationsVercelProjectNameResponse'];
        };
      };
    };
  };
  'system-write-sync-destinations-vercel-project-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteSyncDestinationsVercelProjectNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemWriteSyncDestinationsVercelProjectNameResponse'];
        };
      };
    };
  };
  'system-delete-sync-destinations-vercel-project-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'system-list-sync-destinations-type': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Type of this secrets store. */
        type: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemListSyncDestinationsTypeResponse'];
        };
      };
    };
  };
  'system-read-sync-destinations-type-name-associations': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
        /** @description Type of this secrets store. */
        type: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemReadSyncDestinationsTypeNameAssociationsResponse'];
        };
      };
    };
  };
  'system-write-sync-destinations-type-name-associations-remove': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
        /** @description Type of this secrets store. */
        type: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteSyncDestinationsTypeNameAssociationsRemoveRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemWriteSyncDestinationsTypeNameAssociationsRemoveResponse'];
        };
      };
    };
  };
  'system-write-sync-destinations-type-name-associations-set': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this secrets store. */
        name: string;
        /** @description Type of this secrets store. */
        type: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteSyncDestinationsTypeNameAssociationsSetRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemWriteSyncDestinationsTypeNameAssociationsSetResponse'];
        };
      };
    };
  };
  'system-list-sync-github-apps': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemListSyncGithubAppsResponse'];
        };
      };
    };
  };
  'system-read-sync-github-apps-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The user defined name of the GitHub App configuration. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemReadSyncGithubAppsNameResponse'];
        };
      };
    };
  };
  'system-write-sync-github-apps-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The user defined name of the GitHub App configuration. */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteSyncGithubAppsNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemWriteSyncGithubAppsNameResponse'];
        };
      };
    };
  };
  'system-delete-sync-github-apps-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The user defined name of the GitHub App configuration. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemDeleteSyncGithubAppsNameResponse'];
        };
      };
    };
  };
  'generate-hash': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateHashRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateHashResponse'];
        };
      };
    };
  };
  'generate-hash-with-algorithm': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Algorithm to use (POST URL parameter) */
        urlalgorithm: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateHashWithAlgorithmRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateHashWithAlgorithmResponse'];
        };
      };
    };
  };
  'generate-random': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateRandomRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateRandomResponse'];
        };
      };
    };
  };
  'generate-random-with-source': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Which system to source random data from, ether "platform", "seal", or "all". */
        source: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateRandomWithSourceRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateRandomWithSourceResponse'];
        };
      };
    };
  };
  'generate-random-with-source-and-bytes': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Which system to source random data from, ether "platform", "seal", or "all". */
        source: string;
        /** @description The number of bytes to generate (POST URL parameter) */
        urlbytes: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateRandomWithSourceAndBytesRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateRandomWithSourceAndBytesResponse'];
        };
      };
    };
  };
  'generate-random-with-bytes': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The number of bytes to generate (POST URL parameter) */
        urlbytes: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateRandomWithBytesRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateRandomWithBytesResponse'];
        };
      };
    };
  };
  unseal: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnsealRequest'];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UnsealResponse'];
        };
      };
    };
  };
  'system-write-utilization': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SystemWriteUtilizationRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SystemWriteUtilizationResponse'];
        };
      };
    };
  };
  'version-history': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VersionHistoryResponse'];
        };
      };
    };
  };
  'read-wrapping-properties2': {
    parameters: {
      query?: {
        token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReadWrappingProperties2Response'];
        };
      };
    };
  };
  'read-wrapping-properties': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReadWrappingPropertiesRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReadWrappingPropertiesResponse'];
        };
      };
    };
  };
  rewrap: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RewrapRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  unwrap: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnwrapRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description No content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  wrap: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ali-cloud-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ali-cloud-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AliCloudConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ali-cloud-delete-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ali-cloud-generate-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ali-cloud-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'ali-cloud-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ali-cloud-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AliCloudWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ali-cloud-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        alicloud_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-read-lease-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-configure-lease': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsConfigureLeaseRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-read-root-iam-credentials-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-configure-root-iam-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsConfigureRootIamCredentialsRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-rotate-root-iam-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-generate-credentials': {
    parameters: {
      query?: {
        /** @description ARN of role to assume when credential_type is assumed_role */
        role_arn?: string;
        /** @description Session name to use when assuming role. Max chars: 64 */
        role_session_name?: string;
        /** @description Lifetime of the returned credentials in seconds */
        ttl?: string;
      };
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-generate-credentials-with-parameters': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsGenerateCredentialsWithParametersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'aws-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-read-static-creds-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of this role. */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AwsReadStaticCredsNameResponse'];
        };
      };
    };
  };
  'aws-read-static-roles-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of this role. */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AwsReadStaticRolesNameResponse'];
        };
      };
    };
  };
  'aws-write-static-roles-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of this role. */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsWriteStaticRolesNameRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AwsWriteStaticRolesNameResponse'];
        };
      };
    };
  };
  'aws-delete-static-roles-name': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of this role. */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-generate-sts-credentials': {
    parameters: {
      query?: {
        /** @description ARN of role to assume when credential_type is assumed_role */
        role_arn?: string;
        /** @description Session name to use when assuming role. Max chars: 64 */
        role_session_name?: string;
        /** @description Lifetime of the returned credentials in seconds */
        ttl?: string;
      };
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'aws-generate-sts-credentials-with-parameters': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        aws_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsGenerateStsCredentialsWithParametersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AzureConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-delete-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-request-service-principal-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the Vault role */
        role: string;
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'azure-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AzureWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'azure-rotate-root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        azure_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'consul-read-access-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        consul_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'consul-configure-access': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        consul_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConsulConfigureAccessRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'consul-generate-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        role: string;
        /** @description Path that the backend was mounted at */
        consul_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'consul-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        consul_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'consul-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        consul_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'consul-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        consul_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConsulWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'consul-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        consul_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-list-connections': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'database-read-connection-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this database connection */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-configure-connection': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this database connection */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DatabaseConfigureConnectionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-delete-connection-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this database connection */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-generate-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-reload-plugin': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the database plugin */
        plugin_name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-reset-connection': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this database connection */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'database-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DatabaseWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-rotate-static-role-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the static role */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-rotate-root-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of this database connection */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-read-static-role-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the static role. */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-list-static-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'database-read-static-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-write-static-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DatabaseWriteStaticRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'database-delete-static-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        database_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-rotate-root-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-list-impersonated-accounts': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'google-cloud-read-impersonated-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name to refer to this impersonated account in Vault. Cannot be updated. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-write-impersonated-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name to refer to this impersonated account in Vault. Cannot be updated. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudWriteImpersonatedAccountRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-delete-impersonated-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name to refer to this impersonated account in Vault. Cannot be updated. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-generate-impersonated-account-access-token': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the impersonated account. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-generate-impersonated-account-access-token2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the impersonated account. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-list-impersonated-accounts2': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'google-cloud-generate-roleset-key4': {
    parameters: {
      query?: {
        /** @description Private key algorithm for service account key - defaults to KEY_ALG_RSA_2048" */
        key_algorithm?: string;
        /** @description Private key type for service account key - defaults to TYPE_GOOGLE_CREDENTIALS_FILE" */
        key_type?: string;
        /** @description Lifetime of the service account key */
        ttl?: string;
      };
      header?: never;
      path: {
        /** @description Required. Name of the role set. */
        roleset: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-generate-roleset-key3': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role set. */
        roleset: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudGenerateRolesetKey3Request'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-list-rolesets': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'google-cloud-read-roleset': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-write-roleset': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudWriteRolesetRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-delete-roleset': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-rotate-roleset': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-rotate-roleset-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-generate-roleset-key2': {
    parameters: {
      query?: {
        /** @description Private key algorithm for service account key - defaults to KEY_ALG_RSA_2048" */
        key_algorithm?: string;
        /** @description Private key type for service account key - defaults to TYPE_GOOGLE_CREDENTIALS_FILE" */
        key_type?: string;
        /** @description Lifetime of the service account key */
        ttl?: string;
      };
      header?: never;
      path: {
        /** @description Required. Name of the role set. */
        roleset: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-generate-roleset-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role set. */
        roleset: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudGenerateRolesetKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-generate-roleset-access-token2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role set. */
        roleset: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-generate-roleset-access-token': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role set. */
        roleset: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-list-rolesets2': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'google-cloud-list-static-accounts': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'google-cloud-read-static-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name to refer to this static account in Vault. Cannot be updated. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-write-static-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name to refer to this static account in Vault. Cannot be updated. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudWriteStaticAccountRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-delete-static-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name to refer to this static account in Vault. Cannot be updated. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-generate-static-account-key2': {
    parameters: {
      query?: {
        /** @description Private key algorithm for service account key. Defaults to KEY_ALG_RSA_2048." */
        key_algorithm?: string;
        /** @description Private key type for service account key. Defaults to TYPE_GOOGLE_CREDENTIALS_FILE." */
        key_type?: string;
        /** @description Lifetime of the service account key */
        ttl?: string;
      };
      header?: never;
      path: {
        /** @description Required. Name of the static account. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-generate-static-account-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the static account. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudGenerateStaticAccountKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-rotate-static-account-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the account. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-generate-static-account-access-token2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the static account. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-generate-static-account-access-token': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the static account. */
        name: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-list-static-accounts2': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'google-cloud-generate-roleset-access-token4': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role set. */
        roleset: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-generate-roleset-access-token3': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Required. Name of the role set. */
        roleset: string;
        /** @description Path that the backend was mounted at */
        gcp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudKmsConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-delete-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-decrypt': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudKmsDecryptRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-encrypt': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudKmsEncryptRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-list-keys': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'google-cloud-kms-read-key-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-configure-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudKmsConfigureKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-deregister-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-deregister-key2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-register-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudKmsRegisterKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-rotate-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-trim-key-versions': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-trim-key-versions2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-read-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-write-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudKmsWriteKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-delete-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-retrieve-public-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-reencrypt': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudKmsReencryptRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-sign': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudKmsSignRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'google-cloud-kms-verify': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key. */
        key: string;
        /** @description Path that the backend was mounted at */
        gcpkms_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoogleCloudKmsVerifyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-check-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KubernetesConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-delete-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-generate-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the Vault role */
        name: string;
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KubernetesGenerateCredentialsRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'kubernetes-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KubernetesWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kubernetes-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        kubernetes_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kv-v1-read': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v1_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kv-v1-write': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v1_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kv-v1-delete': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v1_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kv-v1-list': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v1_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'kv-v2-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['KvV2ReadConfigurationResponse'];
        };
      };
    };
  };
  'kv-v2-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KvV2ConfigureRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kv-v2-read': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['KvV2ReadResponse'];
        };
      };
    };
  };
  'kv-v2-write': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KvV2WriteRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['KvV2WriteResponse'];
        };
      };
    };
  };
  'kv-v2-delete': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kv-v2-delete-versions': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KvV2DeleteVersionsRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kv-v2-destroy-versions': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KvV2DestroyVersionsRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kv-v2-read-metadata': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['KvV2ReadMetadataResponse'];
        };
      };
    };
  };
  'kv-v2-write-metadata': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KvV2WriteMetadataRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kv-v2-delete-metadata-and-all-versions': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'kv-v2-list': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'kv-v2-read-subkeys': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['KvV2ReadSubkeysResponse'];
        };
      };
    };
  };
  'kv-v2-undelete-versions': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Location of the secret. */
        path: string;
        /** @description Path that the backend was mounted at */
        kv_v2_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KvV2UndeleteVersionsRequest'];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LdapConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-delete-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-request-dynamic-role-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the dynamic role. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-library-list': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'ldap-library-force-check-in': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the set. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LdapLibraryForceCheckInRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-library-read': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the set. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-library-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the set. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LdapLibraryConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-library-delete': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the set. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-library-check-in': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the set. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LdapLibraryCheckInRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-library-check-out': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the set */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LdapLibraryCheckOutRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-library-check-status': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the set. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-list-dynamic-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'ldap-read-dynamic-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role (lowercase) */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-write-dynamic-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role (lowercase) */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LdapWriteDynamicRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-delete-dynamic-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role (lowercase) */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-rotate-static-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the static role */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-rotate-root-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-request-static-role-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the static role. */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-list-static-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'ldap-read-static-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-write-static-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LdapWriteStaticRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ldap-delete-static-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        ldap_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mongo-db-atlas-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        mongodbatlas_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mongo-db-atlas-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        mongodbatlas_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MongoDbAtlasConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mongo-db-atlas-generate-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        mongodbatlas_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mongo-db-atlas-generate-credentials2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        mongodbatlas_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mongo-db-atlas-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        mongodbatlas_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'mongo-db-atlas-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the Roles */
        name: string;
        /** @description Path that the backend was mounted at */
        mongodbatlas_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mongo-db-atlas-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the Roles */
        name: string;
        /** @description Path that the backend was mounted at */
        mongodbatlas_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MongoDbAtlasWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'mongo-db-atlas-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the Roles */
        name: string;
        /** @description Path that the backend was mounted at */
        mongodbatlas_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'nomad-read-access-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'nomad-configure-access': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['NomadConfigureAccessRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'nomad-delete-access-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'nomad-read-lease-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'nomad-configure-lease': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['NomadConfigureLeaseRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'nomad-delete-lease-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'nomad-generate-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'nomad-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'nomad-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'nomad-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['NomadWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'nomad-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        nomad_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-acme-account-kid': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteAcmeAccountKidRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-acme-authorization-auth_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteAcmeAuthorizationAuth_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-acme-challenge-auth_id-challenge_type': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteAcmeChallengeAuth_idChallenge_typeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-acme-directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-acme-new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteAcmeNewAccountRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-generate-eab-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiGenerateEabKeyResponse'];
        };
      };
    };
  };
  'pki-read-acme-new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-acme-new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteAcmeNewOrderRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-acme-order-order_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteAcmeOrderOrder_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-acme-order-order_id-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteAcmeOrderOrder_idCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-acme-order-order_id-finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteAcmeOrderOrder_idFinalizeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-acme-orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteAcmeOrdersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-acme-revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteAcmeRevokeCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-ca-der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCaDerResponse'];
        };
      };
    };
  };
  'pki-read-ca-pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCaPemResponse'];
        };
      };
    };
  };
  'pki-read-ca-chain-pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCaChainPemResponse'];
        };
      };
    };
  };
  'pki-read-cert-ca-chain': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCertCaChainResponse'];
        };
      };
    };
  };
  'pki-read-cert-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCertCrlResponse'];
        };
      };
    };
  };
  'pki-read-cert-delta-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCertDeltaCrlResponse'];
        };
      };
    };
  };
  'pki-read-cert-unified-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCertUnifiedCrlResponse'];
        };
      };
    };
  };
  'pki-read-cert-unified-delta-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCertUnifiedDeltaCrlResponse'];
        };
      };
    };
  };
  'pki-read-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Certificate serial number, in colon- or hyphen-separated octal */
        serial: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCertResponse'];
        };
      };
    };
  };
  'pki-read-cert-raw-der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Certificate serial number, in colon- or hyphen-separated octal */
        serial: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCertRawDerResponse'];
        };
      };
    };
  };
  'pki-read-cert-raw-pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Certificate serial number, in colon- or hyphen-separated octal */
        serial: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCertRawPemResponse'];
        };
      };
    };
  };
  'pki-list-certs': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'pki-list-certs-revocation-queue': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'pki-list-revoked-certs': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'pki-list-unified-revoked-certs': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiListUnifiedRevokedCertsResponse'];
        };
      };
    };
  };
  'pki-read-acme-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-configure-acme': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiConfigureAcmeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-auto-tidy-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadAutoTidyConfigurationResponse'];
        };
      };
    };
  };
  'pki-configure-auto-tidy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiConfigureAutoTidyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiConfigureAutoTidyResponse'];
        };
      };
    };
  };
  'pki-configure-ca': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiConfigureCaRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiConfigureCaResponse'];
        };
      };
    };
  };
  'pki-read-cluster-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadClusterConfigurationResponse'];
        };
      };
    };
  };
  'pki-configure-cluster': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiConfigureClusterRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiConfigureClusterResponse'];
        };
      };
    };
  };
  'pki-read-crl-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCrlConfigurationResponse'];
        };
      };
    };
  };
  'pki-configure-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiConfigureCrlRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiConfigureCrlResponse'];
        };
      };
    };
  };
  'pki-read-est-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-configure-est': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiConfigureEstRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-configure-external-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiConfigureExternalPolicyResponse'];
        };
      };
    };
  };
  'pki-configure-external-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiConfigureExternalPolicyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-issuers-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadIssuersConfigurationResponse'];
        };
      };
    };
  };
  'pki-configure-issuers': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiConfigureIssuersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiConfigureIssuersResponse'];
        };
      };
    };
  };
  'pki-read-keys-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadKeysConfigurationResponse'];
        };
      };
    };
  };
  'pki-configure-keys': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiConfigureKeysRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiConfigureKeysResponse'];
        };
      };
    };
  };
  'pki-read-urls-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadUrlsConfigurationResponse'];
        };
      };
    };
  };
  'pki-configure-urls': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiConfigureUrlsRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiConfigureUrlsResponse'];
        };
      };
    };
  };
  'pki-read-crl-der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCrlDerResponse'];
        };
      };
    };
  };
  'pki-read-crl-delta': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCrlDeltaResponse'];
        };
      };
    };
  };
  'pki-read-crl-delta-pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCrlDeltaPemResponse'];
        };
      };
    };
  };
  'pki-read-crl-pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadCrlPemResponse'];
        };
      };
    };
  };
  'pki-rotate-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiRotateCrlResponse'];
        };
      };
    };
  };
  'pki-rotate-delta-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiRotateDeltaCrlResponse'];
        };
      };
    };
  };
  'pki-list-eab-keys': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiListEabKeysResponse'];
        };
      };
    };
  };
  'pki-delete-eab-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description EAB key identifier */
        key_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-est-cacerts': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-est-simpleenroll': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-est-simplereenroll': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-acme-account-kid': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyAcmeAccountKidRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-acme-authorization-auth_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyAcmeAuthorizationAuth_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-acme-challenge-auth_id-challenge_type': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyAcmeChallengeAuth_idChallenge_typeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-external-policy-acme-directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-acme-new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyAcmeNewAccountRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-generate-eab-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiGenerateEabKeyResponse'];
        };
      };
    };
  };
  'pki-read-external-policy-acme-new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-acme-new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyAcmeNewOrderRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-acme-order-order_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyAcmeOrderOrder_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-acme-order-order_id-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyAcmeOrderOrder_idCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-acme-order-order_id-finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyAcmeOrderOrder_idFinalizeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-acme-orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyAcmeOrdersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-acme-revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyAcmeRevokeCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-issue': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyIssueRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteExternalPolicyIssueResponse'];
        };
      };
    };
  };
  'pki-write-external-policy-issue-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the external service. */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyIssuePolicyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteExternalPolicyIssuePolicyResponse'];
        };
      };
    };
  };
  'pki-write-external-policy-sign': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicySignRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteExternalPolicySignResponse'];
        };
      };
    };
  };
  'pki-write-external-policy-sign-intermediate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicySignIntermediateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteExternalPolicySignIntermediateResponse'];
        };
      };
    };
  };
  'pki-write-external-policy-sign-intermediate-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the external service. */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicySignIntermediatePolicyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteExternalPolicySignIntermediatePolicyResponse'];
        };
      };
    };
  };
  'pki-write-external-policy-sign-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the external service. */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicySignPolicyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteExternalPolicySignPolicyResponse'];
        };
      };
    };
  };
  'pki-write-external-policy-policy-acme-account-kid': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyPolicyAcmeAccountKidRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-policy-acme-authorization-auth_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyPolicyAcmeAuthorizationAuth_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-policy-acme-challenge-auth_id-challenge_type': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyPolicyAcmeChallengeAuth_idChallenge_typeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-external-policy-policy-acme-directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-policy-acme-new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyPolicyAcmeNewAccountRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-generate-eab-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiGenerateEabKeyResponse'];
        };
      };
    };
  };
  'pki-read-external-policy-policy-acme-new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-policy-acme-new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyPolicyAcmeNewOrderRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-policy-acme-order-order_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyPolicyAcmeOrderOrder_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-policy-acme-order-order_id-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyPolicyAcmeOrderOrder_idCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-policy-acme-order-order_id-finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyPolicyAcmeOrderOrder_idFinalizeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-policy-acme-orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyPolicyAcmeOrdersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-external-policy-policy-acme-revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteExternalPolicyPolicyAcmeRevokeCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-cross-sign-intermediate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiCrossSignIntermediateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiCrossSignIntermediateResponse'];
        };
      };
    };
  };
  'pki-generate-intermediate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Must be "internal", "exported" or "kms". If set to "exported", the generated private key will be returned. This is your *only* chance to retrieve the private key! */
        exported: 'internal' | 'external' | 'kms';
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiGenerateIntermediateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiGenerateIntermediateResponse'];
        };
      };
    };
  };
  'pki-set-signed-intermediate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiSetSignedIntermediateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiSetSignedIntermediateResponse'];
        };
      };
    };
  };
  'pki-issue-with-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role with configuration for this request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiIssueWithRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssueWithRoleResponse'];
        };
      };
    };
  };
  'pki-read-issuer': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadIssuerResponse'];
        };
      };
    };
  };
  'pki-write-issuer': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteIssuerResponse'];
        };
      };
    };
  };
  'pki-delete-issuer': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-acme-account-kid': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refAcmeAccountKidRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-acme-authorization-auth_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refAcmeAuthorizationAuth_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-acme-challenge-auth_id-challenge_type': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refAcmeChallengeAuth_idChallenge_typeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-issuer-issuer_ref-acme-directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-acme-new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refAcmeNewAccountRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-generate-eab-key-for-issuer': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiGenerateEabKeyForIssuerResponse'];
        };
      };
    };
  };
  'pki-read-issuer-issuer_ref-acme-new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-acme-new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refAcmeNewOrderRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-acme-order-order_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refAcmeOrderOrder_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-acme-order-order_id-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refAcmeOrderOrder_idCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-acme-order-order_id-finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refAcmeOrderOrder_idFinalizeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-acme-orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refAcmeOrdersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-acme-revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refAcmeRevokeCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-issuer-read-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerReadCrlResponse'];
        };
      };
    };
  };
  'pki-issuer-read-crl-delta': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerReadCrlDeltaResponse'];
        };
      };
    };
  };
  'pki-issuer-read-crl-delta-der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerReadCrlDeltaDerResponse'];
        };
      };
    };
  };
  'pki-issuer-read-crl-delta-pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerReadCrlDeltaPemResponse'];
        };
      };
    };
  };
  'pki-issuer-read-crl-der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerReadCrlDerResponse'];
        };
      };
    };
  };
  'pki-issuer-read-crl-pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerReadCrlPemResponse'];
        };
      };
    };
  };
  'pki-read-issuer-der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadIssuerDerResponse'];
        };
      };
      /** @description Not Modified */
      304: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-acme-account-kid': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyAcmeAccountKidRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-acme-authorization-auth_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyAcmeAuthorizationAuth_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-acme-challenge-auth_id-challenge_type': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyAcmeChallengeAuth_idChallenge_typeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-issuer-issuer_ref-external-policy-acme-directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-acme-new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyAcmeNewAccountRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-generate-eab-key-for-issuer': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiGenerateEabKeyForIssuerResponse'];
        };
      };
    };
  };
  'pki-read-issuer-issuer_ref-external-policy-acme-new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-acme-new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyAcmeNewOrderRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-acme-order-order_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyAcmeOrderOrder_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-acme-order-order_id-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyAcmeOrderOrder_idCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-acme-order-order_id-finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyAcmeOrderOrder_idFinalizeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-acme-orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyAcmeOrdersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-acme-revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyAcmeRevokeCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-issue': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyIssueRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyIssueResponse'];
        };
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-issue-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the external service. */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyIssuePolicyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyIssuePolicyResponse'];
        };
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-sign': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicySignRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicySignResponse'];
        };
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-sign-intermediate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicySignIntermediateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicySignIntermediateResponse'];
        };
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-sign-intermediate-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the external service. */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicySignIntermediatePolicyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicySignIntermediatePolicyResponse'];
        };
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-sign-policy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the external service. */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicySignPolicyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicySignPolicyResponse'];
        };
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-policy-acme-account-kid': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeAccountKidRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-policy-acme-authorization-auth_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeAuthorizationAuth_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-policy-acme-challenge-auth_id-challenge_type': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeChallengeAuth_idChallenge_typeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-issuer-issuer_ref-external-policy-policy-acme-directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-policy-acme-new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeNewAccountRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-generate-eab-key-for-issuer': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiGenerateEabKeyForIssuerResponse'];
        };
      };
    };
  };
  'pki-read-issuer-issuer_ref-external-policy-policy-acme-new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-policy-acme-new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeNewOrderRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-policy-acme-order-order_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeOrderOrder_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-policy-acme-order-order_id-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeOrderOrder_idCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-policy-acme-order-order_id-finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeOrderOrder_idFinalizeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-policy-acme-orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeOrdersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-external-policy-policy-acme-revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The policy name to pass through to the CIEPS service */
        policy: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refExternalPolicyPolicyAcmeRevokeCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-issuer-issue-with-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description The desired role with configuration for this request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiIssuerIssueWithRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerIssueWithRoleResponse'];
        };
      };
    };
  };
  'pki-read-issuer-json': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadIssuerJsonResponse'];
        };
      };
      /** @description Not Modified */
      304: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-issuer-pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadIssuerPemResponse'];
        };
      };
      /** @description Not Modified */
      304: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-issuer-resign-crls': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiIssuerResignCrlsRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerResignCrlsResponse'];
        };
      };
    };
  };
  'pki-revoke-issuer': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiRevokeIssuerResponse'];
        };
      };
    };
  };
  'pki-write-issuer-issuer_ref-roles-role-acme-account-kid': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refRolesRoleAcmeAccountKidRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-roles-role-acme-authorization-auth_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refRolesRoleAcmeAuthorizationAuth_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-roles-role-acme-challenge-auth_id-challenge_type': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refRolesRoleAcmeChallengeAuth_idChallenge_typeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-issuer-issuer_ref-roles-role-acme-directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-roles-role-acme-new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refRolesRoleAcmeNewAccountRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-generate-eab-key-for-issuer-and-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiGenerateEabKeyForIssuerAndRoleResponse'];
        };
      };
    };
  };
  'pki-read-issuer-issuer_ref-roles-role-acme-new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-roles-role-acme-new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refRolesRoleAcmeNewOrderRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-roles-role-acme-order-order_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refRolesRoleAcmeOrderOrder_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-roles-role-acme-order-order_id-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refRolesRoleAcmeOrderOrder_idCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-roles-role-acme-order-order_id-finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refRolesRoleAcmeOrderOrder_idFinalizeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-roles-role-acme-orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refRolesRoleAcmeOrdersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-issuer-issuer_ref-roles-role-acme-revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to an existing issuer name or issuer id */
        issuer_ref: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteIssuerIssuer_refRolesRoleAcmeRevokeCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-issuer-sign-intermediate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiIssuerSignIntermediateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerSignIntermediateResponse'];
        };
      };
    };
  };
  'pki-issuer-sign-revocation-list': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiIssuerSignRevocationListRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerSignRevocationListResponse'];
        };
      };
    };
  };
  'pki-issuer-sign-self-issued': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiIssuerSignSelfIssuedRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerSignSelfIssuedResponse'];
        };
      };
    };
  };
  'pki-issuer-sign-verbatim': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiIssuerSignVerbatimRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerSignVerbatimResponse'];
        };
      };
    };
  };
  'pki-issuer-sign-verbatim-with-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description The desired role with configuration for this request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiIssuerSignVerbatimWithRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerSignVerbatimWithRoleResponse'];
        };
      };
    };
  };
  'pki-issuer-sign-with-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description The desired role with configuration for this request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiIssuerSignWithRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerSignWithRoleResponse'];
        };
      };
    };
  };
  'pki-issuer-read-unified-crl': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerReadUnifiedCrlResponse'];
        };
      };
    };
  };
  'pki-issuer-read-unified-crl-delta': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerReadUnifiedCrlDeltaResponse'];
        };
      };
    };
  };
  'pki-issuer-read-unified-crl-delta-der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerReadUnifiedCrlDeltaDerResponse'];
        };
      };
    };
  };
  'pki-issuer-read-unified-crl-delta-pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerReadUnifiedCrlDeltaPemResponse'];
        };
      };
    };
  };
  'pki-issuer-read-unified-crl-der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerReadUnifiedCrlDerResponse'];
        };
      };
    };
  };
  'pki-issuer-read-unified-crl-pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to a existing issuer; either "default" for the configured default issuer, an identifier or the name assigned to the issuer. */
        issuer_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuerReadUnifiedCrlPemResponse'];
        };
      };
    };
  };
  'pki-list-issuers': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiListIssuersResponse'];
        };
      };
    };
  };
  'pki-issuers-generate-intermediate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Must be "internal", "exported" or "kms". If set to "exported", the generated private key will be returned. This is your *only* chance to retrieve the private key! */
        exported: 'internal' | 'external' | 'kms';
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiIssuersGenerateIntermediateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuersGenerateIntermediateResponse'];
        };
      };
    };
  };
  'pki-issuers-generate-root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Must be "internal", "exported" or "kms". If set to "exported", the generated private key will be returned. This is your *only* chance to retrieve the private key! */
        exported: 'internal' | 'external' | 'kms';
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiIssuersGenerateRootRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuersGenerateRootResponse'];
        };
      };
    };
  };
  'pki-issuers-import-bundle': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiIssuersImportBundleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuersImportBundleResponse'];
        };
      };
    };
  };
  'pki-issuers-import-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiIssuersImportCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiIssuersImportCertResponse'];
        };
      };
    };
  };
  'pki-read-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to key; either "default" for the configured default key, an identifier of a key, or the name assigned to the key. */
        key_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadKeyResponse'];
        };
      };
    };
  };
  'pki-write-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to key; either "default" for the configured default key, an identifier of a key, or the name assigned to the key. */
        key_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteKeyResponse'];
        };
      };
    };
  };
  'pki-delete-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Reference to key; either "default" for the configured default key, an identifier of a key, or the name assigned to the key. */
        key_ref: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-list-keys': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiListKeysResponse'];
        };
      };
    };
  };
  'pki-generate-exported-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiGenerateExportedKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiGenerateExportedKeyResponse'];
        };
      };
    };
  };
  'pki-generate-internal-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiGenerateInternalKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiGenerateInternalKeyResponse'];
        };
      };
    };
  };
  'pki-generate-kms-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiGenerateKmsKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiGenerateKmsKeyResponse'];
        };
      };
    };
  };
  'pki-import-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiImportKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiImportKeyResponse'];
        };
      };
    };
  };
  'pki-query-ocsp': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-query-ocsp-with-get-req': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description base-64 encoded ocsp request */
        req: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-revoke': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiRevokeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiRevokeResponse'];
        };
      };
    };
  };
  'pki-revoke-with-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiRevokeWithKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiRevokeWithKeyResponse'];
        };
      };
    };
  };
  'pki-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'pki-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReadRoleResponse'];
        };
      };
    };
  };
  'pki-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiWriteRoleResponse'];
        };
      };
    };
  };
  'pki-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-roles-role-acme-account-kid': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key identifier provided by the CA */
        kid: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteRolesRoleAcmeAccountKidRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-roles-role-acme-authorization-auth_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteRolesRoleAcmeAuthorizationAuth_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-roles-role-acme-challenge-auth_id-challenge_type': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ACME authorization identifier value */
        auth_id: string;
        /** @description ACME challenge type */
        challenge_type: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteRolesRoleAcmeChallengeAuth_idChallenge_typeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-roles-role-acme-directory': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-roles-role-acme-new-account': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteRolesRoleAcmeNewAccountRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-generate-eab-key-for-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiGenerateEabKeyForRoleResponse'];
        };
      };
    };
  };
  'pki-read-roles-role-acme-new-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-roles-role-acme-new-order': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteRolesRoleAcmeNewOrderRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-roles-role-acme-order-order_id': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteRolesRoleAcmeOrderOrder_idRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-roles-role-acme-order-order_id-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteRolesRoleAcmeOrderOrder_idCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-roles-role-acme-order-order_id-finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ACME order identifier to fetch */
        order_id: string;
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteRolesRoleAcmeOrderOrder_idFinalizeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-roles-role-acme-orders': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteRolesRoleAcmeOrdersRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-roles-role-acme-revoke-cert': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the acme request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiWriteRolesRoleAcmeRevokeCertRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-roles-role-est-cacerts': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the EST request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-roles-role-est-simpleenroll': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the EST request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-write-roles-role-est-simplereenroll': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role for the EST request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-delete-root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-generate-root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Must be "internal", "exported" or "kms". If set to "exported", the generated private key will be returned. This is your *only* chance to retrieve the private key! */
        exported: 'internal' | 'external' | 'kms';
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiGenerateRootRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiGenerateRootResponse'];
        };
      };
    };
  };
  'pki-replace-root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiReplaceRootRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiReplaceRootResponse'];
        };
      };
    };
  };
  'pki-rotate-root': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Must be "internal", "exported" or "kms". If set to "exported", the generated private key will be returned. This is your *only* chance to retrieve the private key! */
        exported: 'internal' | 'external' | 'kms';
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiRotateRootRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiRotateRootResponse'];
        };
      };
    };
  };
  'pki-root-sign-intermediate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiRootSignIntermediateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiRootSignIntermediateResponse'];
        };
      };
    };
  };
  'pki-root-sign-self-issued': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiRootSignSelfIssuedRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiRootSignSelfIssuedResponse'];
        };
      };
    };
  };
  'pki-sign-verbatim': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiSignVerbatimRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiSignVerbatimResponse'];
        };
      };
    };
  };
  'pki-sign-verbatim-with-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role with configuration for this request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiSignVerbatimWithRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiSignVerbatimWithRoleResponse'];
        };
      };
    };
  };
  'pki-sign-with-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role with configuration for this request */
        role: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiSignWithRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiSignWithRoleResponse'];
        };
      };
    };
  };
  'pki-tidy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PkiTidyRequest'];
      };
    };
    responses: {
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-tidy-cancel': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiTidyCancelResponse'];
        };
      };
    };
  };
  'pki-tidy-status': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PkiTidyStatusResponse'];
        };
      };
    };
  };
  'pki-read-unified-crl-der': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-unified-crl-delta': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-unified-crl-delta-pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-read-unified-crl-pem': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-query-unified-ocsp': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'pki-query-unified-ocsp-with-get-req': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description base-64 encoded ocsp request */
        req: string;
        /** @description Path that the backend was mounted at */
        pki_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'rabbit-mq-configure-connection': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        rabbitmq_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RabbitMqConfigureConnectionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'rabbit-mq-read-lease-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        rabbitmq_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'rabbit-mq-configure-lease': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        rabbitmq_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RabbitMqConfigureLeaseRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'rabbit-mq-request-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        rabbitmq_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'rabbit-mq-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        rabbitmq_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'rabbit-mq-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        rabbitmq_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'rabbit-mq-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        rabbitmq_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RabbitMqWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'rabbit-mq-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role. */
        name: string;
        /** @description Path that the backend was mounted at */
        rabbitmq_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-read-ca-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-configure-ca': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SshConfigureCaRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-delete-ca-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-read-zero-address-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-configure-zero-address': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SshConfigureZeroAddressRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-delete-zero-address-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-generate-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description [Required] Name of the role */
        role: string;
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SshGenerateCredentialsRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-issue-certificate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role with configuration for this request. */
        role: string;
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SshIssueCertificateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-list-roles-by-ip': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SshListRolesByIpRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-read-public-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'ssh-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description [Required for all types] Name of the role being created. */
        role: string;
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description [Required for all types] Name of the role being created. */
        role: string;
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SshWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description [Required for all types] Name of the role being created. */
        role: string;
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-sign-certificate': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The desired role with configuration for this request. */
        role: string;
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SshSignCertificateRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-tidy-dynamic-host-keys': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'ssh-verify-otp': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        ssh_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SshVerifyOtpRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'terraform-cloud-read-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'terraform-cloud-configure': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TerraformCloudConfigureRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'terraform-cloud-delete-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'terraform-cloud-generate-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'terraform-cloud-generate-credentials2': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'terraform-cloud-list-roles': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'terraform-cloud-read-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'terraform-cloud-write-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TerraformCloudWriteRoleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'terraform-cloud-delete-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the role */
        name: string;
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'terraform-cloud-rotate-role': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the team or organization role */
        name: string;
        /** @description Path that the backend was mounted at */
        terraform_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'totp-generate-code': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key. */
        name: string;
        /** @description Path that the backend was mounted at */
        totp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'totp-validate-code': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key. */
        name: string;
        /** @description Path that the backend was mounted at */
        totp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TotpValidateCodeRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'totp-list-keys': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        totp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'totp-read-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key. */
        name: string;
        /** @description Path that the backend was mounted at */
        totp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'totp-create-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key. */
        name: string;
        /** @description Path that the backend was mounted at */
        totp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TotpCreateKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'totp-delete-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key. */
        name: string;
        /** @description Path that the backend was mounted at */
        totp_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-back-up-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-byok-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Destination key to export to; usually the public wrapping key of another Transit instance. */
        destination: string;
        /** @description Source key to export; could be any present key within Transit. */
        source: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-byok-key-version': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Destination key to export to; usually the public wrapping key of another Transit instance. */
        destination: string;
        /** @description Source key to export; could be any present key within Transit. */
        source: string;
        /** @description Optional version of the key to export, else all key versions are exported. */
        version: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-read-cache-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-configure-cache': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitConfigureCacheRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-read-keys-configuration': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-configure-keys': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitConfigureKeysRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-generate-data-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The backend key used for encrypting the data key */
        name: string;
        /** @description "plaintext" will return the key in both plaintext and ciphertext; "wrapped" will return the ciphertext only. */
        plaintext: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitGenerateDataKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-decrypt': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitDecryptRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-encrypt': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitEncryptRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-export-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Type of key to export (encryption-key, signing-key, hmac-key, public-key) */
        type: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-export-key-version': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Type of key to export (encryption-key, signing-key, hmac-key, public-key) */
        type: string;
        /** @description Version of the key */
        version: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-hash': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitHashRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-hash-with-algorithm': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Algorithm to use (POST URL parameter) */
        urlalgorithm: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitHashWithAlgorithmRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-generate-hmac': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key to use for the HMAC function */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitGenerateHmacRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-generate-hmac-with-algorithm': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key to use for the HMAC function */
        name: string;
        /** @description Algorithm to use (POST URL parameter) */
        urlalgorithm: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitGenerateHmacWithAlgorithmRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-list-keys': {
    parameters: {
      query: {
        /** @description Must be set to `true` */
        list: 'true';
      };
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StandardListResponse'];
        };
      };
    };
  };
  'transit-read-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-create-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitCreateKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-delete-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description empty body */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-configure-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitConfigureKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-generate-csr-for-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitGenerateCsrForKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-import-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitImportKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-import-key-version': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitImportKeyVersionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-rotate-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitRotateKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-set-certificate-for-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitSetCertificateForKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-trim-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitTrimKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-generate-random': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitGenerateRandomRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-generate-random-with-source': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Which system to source random data from, ether "platform", "seal", or "all". */
        source: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitGenerateRandomWithSourceRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-generate-random-with-source-and-bytes': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Which system to source random data from, ether "platform", "seal", or "all". */
        source: string;
        /** @description The number of bytes to generate (POST URL parameter) */
        urlbytes: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitGenerateRandomWithSourceAndBytesRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-generate-random-with-bytes': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The number of bytes to generate (POST URL parameter) */
        urlbytes: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitGenerateRandomWithBytesRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-restore-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitRestoreKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-restore-and-rename-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description If set, this will be the name of the restored key. */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitRestoreAndRenameKeyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-rewrap': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the key */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitRewrapRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-sign': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key to use */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitSignRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-sign-with-algorithm': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key to use */
        name: string;
        /** @description Hash algorithm to use (POST URL parameter) */
        urlalgorithm: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitSignWithAlgorithmRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-verify': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key to use */
        name: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitVerifyRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-verify-with-algorithm': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The key to use */
        name: string;
        /** @description Hash algorithm to use (POST URL parameter) */
        urlalgorithm: string;
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransitVerifyWithAlgorithmRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'transit-read-wrapping-key': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Path that the backend was mounted at */
        transit_mount_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
