/*
Copyright (c) 2014-2024 VMware, Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package types

import (
	"reflect"
	"time"
)

type AbandonHciWorkflow AbandonHciWorkflowRequestType

func init() {
	t["AbandonHciWorkflow"] = reflect.TypeOf((*AbandonHciWorkflow)(nil)).Elem()
}

type AbandonHciWorkflowRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["AbandonHciWorkflowRequestType"] = reflect.TypeOf((*AbandonHciWorkflowRequestType)(nil)).Elem()
}

type AbandonHciWorkflowResponse struct {
}

type AbdicateDomOwnership AbdicateDomOwnershipRequestType

func init() {
	t["AbdicateDomOwnership"] = reflect.TypeOf((*AbdicateDomOwnership)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.AbdicateDomOwnership`.
type AbdicateDomOwnershipRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of VSAN/DOM object UUIDs.
	Uuids []string `xml:"uuids" json:"uuids"`
}

func init() {
	t["AbdicateDomOwnershipRequestType"] = reflect.TypeOf((*AbdicateDomOwnershipRequestType)(nil)).Elem()
}

type AbdicateDomOwnershipResponse struct {
	Returnval []string `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The parameters of `VirtualMachineGuestCustomizationManager.AbortCustomization_Task`.
type AbortCustomizationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The Virtual Machine managed object reference.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
}

func init() {
	t["AbortCustomizationRequestType"] = reflect.TypeOf((*AbortCustomizationRequestType)(nil)).Elem()
}

type AbortCustomization_Task AbortCustomizationRequestType

func init() {
	t["AbortCustomization_Task"] = reflect.TypeOf((*AbortCustomization_Task)(nil)).Elem()
}

type AbortCustomization_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This data object type describes system information
// including the name, type, version, and build number.
type AboutInfo struct {
	DynamicData

	// Short form of the product name.
	Name string `xml:"name" json:"name"`
	// The complete product name, including the version information.
	FullName string `xml:"fullName" json:"fullName"`
	// Name of the vendor of this product.
	Vendor string `xml:"vendor" json:"vendor"`
	// Dot-separated version string.
	//
	// For example, "1.2".
	Version string `xml:"version" json:"version"`
	// Patch level for the server.
	PatchLevel string `xml:"patchLevel,omitempty" json:"patchLevel,omitempty" vim:"7.0.2.0"`
	// Build string for the server on which this call is made.
	//
	// For example, x.y.z-num.
	// This string does not apply to the API.
	Build string `xml:"build" json:"build"`
	// Version of the message catalog for the current session's locale.
	LocaleVersion string `xml:"localeVersion,omitempty" json:"localeVersion,omitempty"`
	// Build number for the current session's locale.
	//
	// Typically, this is a small number reflecting a
	// localization change from the normal product build.
	LocaleBuild string `xml:"localeBuild,omitempty" json:"localeBuild,omitempty"`
	// Operating system type and architecture.
	//
	// Examples of values are:
	//   - "win32-x86" - For x86-based Windows systems.
	//   - "linux-x86" - For x86-based Linux systems.
	//   - "vmnix-x86" - For the x86 ESX Server microkernel.
	//   - "vmnix-arm64" - For the arm64 ESX Server microkernel.
	OsType string `xml:"osType" json:"osType"`
	// The product ID is a unique identifier for a product line.
	//
	// Examples of values are:
	//   - "gsx" - For the VMware Server product.
	//   - "esx" - For the ESX product.
	//   - "embeddedEsx" - For the ESXi product.
	//   - "esxio" - For the ESXio product.
	//   - "vpx" - For the VirtualCenter product.
	ProductLineId string `xml:"productLineId" json:"productLineId"`
	// Indicates whether or not the service instance represents a
	// standalone host.
	//
	// If the service instance represents a standalone host, then the physical
	// inventory for that service instance is fixed to that single host.
	// VirtualCenter server provides additional features over single hosts.
	// For example, VirtualCenter offers multi-host management.
	//
	// Examples of values are:
	//   - "VirtualCenter" - For a VirtualCenter instance.
	//   - "HostAgent" - For host agent on an ESX Server or VMware Server host.
	ApiType string `xml:"apiType" json:"apiType"`
	// The version of the API as a dot-separated string.
	//
	// For example, "1.0.0".
	ApiVersion string `xml:"apiVersion" json:"apiVersion"`
	// A globally unique identifier associated with this service instance.
	InstanceUuid string `xml:"instanceUuid,omitempty" json:"instanceUuid,omitempty"`
	// The license product name
	LicenseProductName string `xml:"licenseProductName,omitempty" json:"licenseProductName,omitempty"`
	// The license product version
	LicenseProductVersion string `xml:"licenseProductVersion,omitempty" json:"licenseProductVersion,omitempty"`
}

func init() {
	t["AboutInfo"] = reflect.TypeOf((*AboutInfo)(nil)).Elem()
}

// This event records that an account was created on a host.
type AccountCreatedEvent struct {
	HostEvent

	Spec  BaseHostAccountSpec `xml:"spec,typeattr" json:"spec"`
	Group bool                `xml:"group" json:"group"`
}

func init() {
	t["AccountCreatedEvent"] = reflect.TypeOf((*AccountCreatedEvent)(nil)).Elem()
}

// This event records that an account was removed from a host.
type AccountRemovedEvent struct {
	HostEvent

	Account string `xml:"account" json:"account"`
	Group   bool   `xml:"group" json:"group"`
}

func init() {
	t["AccountRemovedEvent"] = reflect.TypeOf((*AccountRemovedEvent)(nil)).Elem()
}

// This event records that an account was updated on a host.
type AccountUpdatedEvent struct {
	HostEvent

	Spec  BaseHostAccountSpec `xml:"spec,typeattr" json:"spec"`
	Group bool                `xml:"group" json:"group"`
	// The previous account description
	PrevDescription string `xml:"prevDescription,omitempty" json:"prevDescription,omitempty"`
}

func init() {
	t["AccountUpdatedEvent"] = reflect.TypeOf((*AccountUpdatedEvent)(nil)).Elem()
}

type AcknowledgeAlarm AcknowledgeAlarmRequestType

func init() {
	t["AcknowledgeAlarm"] = reflect.TypeOf((*AcknowledgeAlarm)(nil)).Elem()
}

// The parameters of `AlarmManager.AcknowledgeAlarm`.
type AcknowledgeAlarmRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The Alarm to acknowledge.
	//
	// Required privileges: Alarm.Acknowledge
	//
	// Refers instance of `Alarm`.
	Alarm ManagedObjectReference `xml:"alarm" json:"alarm"`
	// The ManagedEntity for which to acknowledge the Alarm.
	//
	// Required privileges: System.Read
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["AcknowledgeAlarmRequestType"] = reflect.TypeOf((*AcknowledgeAlarmRequestType)(nil)).Elem()
}

type AcknowledgeAlarmResponse struct {
}

type AcquireCimServicesTicket AcquireCimServicesTicketRequestType

func init() {
	t["AcquireCimServicesTicket"] = reflect.TypeOf((*AcquireCimServicesTicket)(nil)).Elem()
}

type AcquireCimServicesTicketRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["AcquireCimServicesTicketRequestType"] = reflect.TypeOf((*AcquireCimServicesTicketRequestType)(nil)).Elem()
}

type AcquireCimServicesTicketResponse struct {
	Returnval HostServiceTicket `xml:"returnval" json:"returnval"`
}

type AcquireCloneTicket AcquireCloneTicketRequestType

func init() {
	t["AcquireCloneTicket"] = reflect.TypeOf((*AcquireCloneTicket)(nil)).Elem()
}

type AcquireCloneTicketRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["AcquireCloneTicketRequestType"] = reflect.TypeOf((*AcquireCloneTicketRequestType)(nil)).Elem()
}

type AcquireCloneTicketResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type AcquireCredentialsInGuest AcquireCredentialsInGuestRequestType

func init() {
	t["AcquireCredentialsInGuest"] = reflect.TypeOf((*AcquireCredentialsInGuest)(nil)).Elem()
}

// The parameters of `GuestAuthManager.AcquireCredentialsInGuest`.
type AcquireCredentialsInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// MoRef of the VM to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Query
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data used to acquire credentials.
	// See `GuestAuthentication`.
	RequestedAuth BaseGuestAuthentication `xml:"requestedAuth,typeattr" json:"requestedAuth"`
	// The sessionID number should be provided only when
	// responding to a server challenge. The sessionID number to be used with
	// the challenge is found in the
	// `GuestAuthenticationChallenge` object.
	SessionID int64 `xml:"sessionID,omitempty" json:"sessionID,omitempty"`
}

func init() {
	t["AcquireCredentialsInGuestRequestType"] = reflect.TypeOf((*AcquireCredentialsInGuestRequestType)(nil)).Elem()
}

type AcquireCredentialsInGuestResponse struct {
	Returnval BaseGuestAuthentication `xml:"returnval,typeattr" json:"returnval"`
}

type AcquireGenericServiceTicket AcquireGenericServiceTicketRequestType

func init() {
	t["AcquireGenericServiceTicket"] = reflect.TypeOf((*AcquireGenericServiceTicket)(nil)).Elem()
}

// The parameters of `SessionManager.AcquireGenericServiceTicket`.
type AcquireGenericServiceTicketRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// specification for the service request which will be
	// invoked with the ticket.
	Spec BaseSessionManagerServiceRequestSpec `xml:"spec,typeattr" json:"spec"`
}

func init() {
	t["AcquireGenericServiceTicketRequestType"] = reflect.TypeOf((*AcquireGenericServiceTicketRequestType)(nil)).Elem()
}

type AcquireGenericServiceTicketResponse struct {
	Returnval SessionManagerGenericServiceTicket `xml:"returnval" json:"returnval"`
}

type AcquireLocalTicket AcquireLocalTicketRequestType

func init() {
	t["AcquireLocalTicket"] = reflect.TypeOf((*AcquireLocalTicket)(nil)).Elem()
}

// The parameters of `SessionManager.AcquireLocalTicket`.
type AcquireLocalTicketRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// User requesting one-time password.
	UserName string `xml:"userName" json:"userName"`
}

func init() {
	t["AcquireLocalTicketRequestType"] = reflect.TypeOf((*AcquireLocalTicketRequestType)(nil)).Elem()
}

type AcquireLocalTicketResponse struct {
	Returnval SessionManagerLocalTicket `xml:"returnval" json:"returnval"`
}

type AcquireMksTicket AcquireMksTicketRequestType

func init() {
	t["AcquireMksTicket"] = reflect.TypeOf((*AcquireMksTicket)(nil)).Elem()
}

type AcquireMksTicketRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["AcquireMksTicketRequestType"] = reflect.TypeOf((*AcquireMksTicketRequestType)(nil)).Elem()
}

type AcquireMksTicketResponse struct {
	Returnval VirtualMachineMksTicket `xml:"returnval" json:"returnval"`
}

type AcquireTicket AcquireTicketRequestType

func init() {
	t["AcquireTicket"] = reflect.TypeOf((*AcquireTicket)(nil)).Elem()
}

// The parameters of `VirtualMachine.AcquireTicket`.
type AcquireTicketRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The type of service to acquire, the set of possible
	// values is described in `VirtualMachineTicketType_enum`.
	TicketType string `xml:"ticketType" json:"ticketType"`
}

func init() {
	t["AcquireTicketRequestType"] = reflect.TypeOf((*AcquireTicketRequestType)(nil)).Elem()
}

type AcquireTicketResponse struct {
	Returnval VirtualMachineTicket `xml:"returnval" json:"returnval"`
}

// This data object type defines the action initiated by a scheduled task or alarm.
//
// This is an abstract type.
// A client creates a scheduled task or an alarm each of which triggers
// an action, defined by a subclass of this type.
type Action struct {
	DynamicData
}

func init() {
	t["Action"] = reflect.TypeOf((*Action)(nil)).Elem()
}

// Base fault for Active Directory related problems.
type ActiveDirectoryFault struct {
	VimFault

	// The error code reported by the Active Directory API.
	ErrorCode int32 `xml:"errorCode,omitempty" json:"errorCode,omitempty"`
}

func init() {
	t["ActiveDirectoryFault"] = reflect.TypeOf((*ActiveDirectoryFault)(nil)).Elem()
}

type ActiveDirectoryFaultFault BaseActiveDirectoryFault

func init() {
	t["ActiveDirectoryFaultFault"] = reflect.TypeOf((*ActiveDirectoryFaultFault)(nil)).Elem()
}

// The `ActiveDirectoryProfile` data object represents Active Directory
// configuration.
//
// Use the `ApplyProfile.policy` list for
// access to configuration data for the Active Directory profile. Use the
// `ApplyProfile.property` list for access to subprofiles, if any.
type ActiveDirectoryProfile struct {
	ApplyProfile
}

func init() {
	t["ActiveDirectoryProfile"] = reflect.TypeOf((*ActiveDirectoryProfile)(nil)).Elem()
}

// An attempt to enable Enhanced VMotion Compatibility on a cluster, or to
// select a less-featureful EVC mode for a cluster where EVC is already
// enabled, has failed for the following reason:
//   - The cluster contains hosts that expose additional compatibility-
//     relevant CPU features beyond those present in the baseline of the
//     requested EVC mode.
//   - Those hosts have powered-on or suspended virtual machines.
//
// Therefore the EVC configuration has been rejected since it may suppress
// CPU features that are currently in-use.
type ActiveVMsBlockingEVC struct {
	EVCConfigFault

	// The requested EVC mode.
	EvcMode string `xml:"evcMode,omitempty" json:"evcMode,omitempty"`
	// Hosts with active virtual machines that are blocking the operation,
	// because the hosts expose compatibility-relevant CPU features not present
	// in the baseline of the requested EVC mode.
	//
	// Note that in rare cases, a host may be on this list even if its
	// `maxEVCModeKey` corresponds to the
	// requested EVC mode. This means that even though that EVC mode is the
	// best match for the host's hardware, the host still has some features
	// beyond those present in the baseline for that EVC mode.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The names of the hosts in the host array.
	HostName []string `xml:"hostName,omitempty" json:"hostName,omitempty"`
}

func init() {
	t["ActiveVMsBlockingEVC"] = reflect.TypeOf((*ActiveVMsBlockingEVC)(nil)).Elem()
}

type ActiveVMsBlockingEVCFault ActiveVMsBlockingEVC

func init() {
	t["ActiveVMsBlockingEVCFault"] = reflect.TypeOf((*ActiveVMsBlockingEVCFault)(nil)).Elem()
}

type AddAuthorizationRole AddAuthorizationRoleRequestType

func init() {
	t["AddAuthorizationRole"] = reflect.TypeOf((*AddAuthorizationRole)(nil)).Elem()
}

// The parameters of `AuthorizationManager.AddAuthorizationRole`.
type AddAuthorizationRoleRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Name of the new role.
	Name string `xml:"name" json:"name"`
	// List of privileges to assign to the role.
	PrivIds []string `xml:"privIds,omitempty" json:"privIds,omitempty"`
}

func init() {
	t["AddAuthorizationRoleRequestType"] = reflect.TypeOf((*AddAuthorizationRoleRequestType)(nil)).Elem()
}

type AddAuthorizationRoleResponse struct {
	Returnval int32 `xml:"returnval" json:"returnval"`
}

type AddCustomFieldDef AddCustomFieldDefRequestType

func init() {
	t["AddCustomFieldDef"] = reflect.TypeOf((*AddCustomFieldDef)(nil)).Elem()
}

// The parameters of `CustomFieldsManager.AddCustomFieldDef`.
type AddCustomFieldDefRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the field.
	Name string `xml:"name" json:"name"`
	// The managed object type to which this field
	// will apply
	MoType string `xml:"moType,omitempty" json:"moType,omitempty"`
	// Privilege policy to apply to FieldDef being
	// created
	FieldDefPolicy *PrivilegePolicyDef `xml:"fieldDefPolicy,omitempty" json:"fieldDefPolicy,omitempty"`
	// Privilege policy to apply to instances of field
	FieldPolicy *PrivilegePolicyDef `xml:"fieldPolicy,omitempty" json:"fieldPolicy,omitempty"`
}

func init() {
	t["AddCustomFieldDefRequestType"] = reflect.TypeOf((*AddCustomFieldDefRequestType)(nil)).Elem()
}

type AddCustomFieldDefResponse struct {
	Returnval CustomFieldDef `xml:"returnval" json:"returnval"`
}

// The parameters of `DistributedVirtualSwitch.AddDVPortgroup_Task`.
type AddDVPortgroupRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specification for the portgroup.
	Spec []DVPortgroupConfigSpec `xml:"spec" json:"spec"`
}

func init() {
	t["AddDVPortgroupRequestType"] = reflect.TypeOf((*AddDVPortgroupRequestType)(nil)).Elem()
}

type AddDVPortgroup_Task AddDVPortgroupRequestType

func init() {
	t["AddDVPortgroup_Task"] = reflect.TypeOf((*AddDVPortgroup_Task)(nil)).Elem()
}

type AddDVPortgroup_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostVsanSystem.AddDisks_Task`.
type AddDisksRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// list of disks to add for use by the VSAN service
	Disk []HostScsiDisk `xml:"disk" json:"disk"`
}

func init() {
	t["AddDisksRequestType"] = reflect.TypeOf((*AddDisksRequestType)(nil)).Elem()
}

type AddDisks_Task AddDisksRequestType

func init() {
	t["AddDisks_Task"] = reflect.TypeOf((*AddDisks_Task)(nil)).Elem()
}

type AddDisks_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type AddFilter AddFilterRequestType

func init() {
	t["AddFilter"] = reflect.TypeOf((*AddFilter)(nil)).Elem()
}

type AddFilterEntities AddFilterEntitiesRequestType

func init() {
	t["AddFilterEntities"] = reflect.TypeOf((*AddFilterEntities)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.AddFilterEntities`.
type AddFilterEntitiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The filter id.
	FilterId string `xml:"filterId" json:"filterId"`
	// The list of additional managed entities. Only
	// entities of type HostSystem or
	// ClusterComputeResource are valid.
	//
	// Refers instances of `ManagedEntity`.
	Entities []ManagedObjectReference `xml:"entities,omitempty" json:"entities,omitempty"`
}

func init() {
	t["AddFilterEntitiesRequestType"] = reflect.TypeOf((*AddFilterEntitiesRequestType)(nil)).Elem()
}

type AddFilterEntitiesResponse struct {
}

// The parameters of `HealthUpdateManager.AddFilter`.
type AddFilterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The provider identifier.
	ProviderId string `xml:"providerId" json:"providerId"`
	// The filter name.
	FilterName string `xml:"filterName" json:"filterName"`
	// The list of HealthUpdateInfo IDs that should be
	// filtered.
	InfoIds []string `xml:"infoIds,omitempty" json:"infoIds,omitempty"`
}

func init() {
	t["AddFilterRequestType"] = reflect.TypeOf((*AddFilterRequestType)(nil)).Elem()
}

type AddFilterResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type AddGuestAlias AddGuestAliasRequestType

func init() {
	t["AddGuestAlias"] = reflect.TypeOf((*AddGuestAlias)(nil)).Elem()
}

// The parameters of `GuestAliasManager.AddGuestAlias`.
type AddGuestAliasRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.ModifyAliases
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data for this operation. See
	// `GuestAuthentication`. These credentials must satisfy
	// authentication requirements
	// for a guest account on the specified virtual machine.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// Username for the guest account on the virtual machine.
	Username string `xml:"username" json:"username"`
	// Indicates whether the certificate associated with the
	// alias should be mapped. If an alias certificate is mapped,
	// guest operation requests that use that alias do not have
	// to specify the guest account username in the
	// `SAMLTokenAuthentication` object. If mapCert is
	// false, the request must specify the username.
	MapCert bool `xml:"mapCert" json:"mapCert"`
	// X.509 certificate from the VMware SSO Server,
	// in base64 encoded DER format. The ESXi
	// Server uses this certificate to authenticate guest
	// operation requests.
	Base64Cert string `xml:"base64Cert" json:"base64Cert"`
	// Specifies the subject name for authentication.
	// The subject name (when present) corresponds to
	// the value of the Subject element
	// in SAML tokens. The ESXi Server uses the subject
	// name to authenticate guest operation requests.
	AliasInfo GuestAuthAliasInfo `xml:"aliasInfo" json:"aliasInfo"`
}

func init() {
	t["AddGuestAliasRequestType"] = reflect.TypeOf((*AddGuestAliasRequestType)(nil)).Elem()
}

type AddGuestAliasResponse struct {
}

// The parameters of `ClusterComputeResource.AddHost_Task`.
type AddHostRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specifies the parameters needed to add a single host.
	Spec HostConnectSpec `xml:"spec" json:"spec"`
	// Flag to specify whether or not the host should be connected
	// immediately after it is added. The host will not be added if
	// a connection attempt is made and fails.
	AsConnected bool `xml:"asConnected" json:"asConnected"`
	// the resource pool for the root resource pool from the host.
	//
	// Required privileges: Resource.AssignVMToPool
	//
	// Refers instance of `ResourcePool`.
	ResourcePool *ManagedObjectReference `xml:"resourcePool,omitempty" json:"resourcePool,omitempty"`
	// Provide a licenseKey or licenseKeyType. See `LicenseManager`
	License string `xml:"license,omitempty" json:"license,omitempty"`
}

func init() {
	t["AddHostRequestType"] = reflect.TypeOf((*AddHostRequestType)(nil)).Elem()
}

type AddHost_Task AddHostRequestType

func init() {
	t["AddHost_Task"] = reflect.TypeOf((*AddHost_Task)(nil)).Elem()
}

type AddHost_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type AddInternetScsiSendTargets AddInternetScsiSendTargetsRequestType

func init() {
	t["AddInternetScsiSendTargets"] = reflect.TypeOf((*AddInternetScsiSendTargets)(nil)).Elem()
}

// The parameters of `HostStorageSystem.AddInternetScsiSendTargets`.
type AddInternetScsiSendTargetsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device of the Internet SCSI HBA adapter.
	IScsiHbaDevice string `xml:"iScsiHbaDevice" json:"iScsiHbaDevice"`
	// An array of iSCSI send targets.
	Targets []HostInternetScsiHbaSendTarget `xml:"targets" json:"targets"`
}

func init() {
	t["AddInternetScsiSendTargetsRequestType"] = reflect.TypeOf((*AddInternetScsiSendTargetsRequestType)(nil)).Elem()
}

type AddInternetScsiSendTargetsResponse struct {
}

type AddInternetScsiStaticTargets AddInternetScsiStaticTargetsRequestType

func init() {
	t["AddInternetScsiStaticTargets"] = reflect.TypeOf((*AddInternetScsiStaticTargets)(nil)).Elem()
}

// The parameters of `HostStorageSystem.AddInternetScsiStaticTargets`.
type AddInternetScsiStaticTargetsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device of the Internet SCSI HBA adapter.
	IScsiHbaDevice string `xml:"iScsiHbaDevice" json:"iScsiHbaDevice"`
	// An array of iSCSI static targets to add.
	Targets []HostInternetScsiHbaStaticTarget `xml:"targets" json:"targets"`
}

func init() {
	t["AddInternetScsiStaticTargetsRequestType"] = reflect.TypeOf((*AddInternetScsiStaticTargetsRequestType)(nil)).Elem()
}

type AddInternetScsiStaticTargetsResponse struct {
}

type AddKey AddKeyRequestType

func init() {
	t["AddKey"] = reflect.TypeOf((*AddKey)(nil)).Elem()
}

// The parameters of `CryptoManager.AddKey`.
type AddKeyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] The cryptographic key to add.
	Key CryptoKeyPlain `xml:"key" json:"key"`
}

func init() {
	t["AddKeyRequestType"] = reflect.TypeOf((*AddKeyRequestType)(nil)).Elem()
}

type AddKeyResponse struct {
}

type AddKeys AddKeysRequestType

func init() {
	t["AddKeys"] = reflect.TypeOf((*AddKeys)(nil)).Elem()
}

// The parameters of `CryptoManager.AddKeys`.
type AddKeysRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] List of cryptographic keys to add.
	Keys []CryptoKeyPlain `xml:"keys,omitempty" json:"keys,omitempty"`
}

func init() {
	t["AddKeysRequestType"] = reflect.TypeOf((*AddKeysRequestType)(nil)).Elem()
}

type AddKeysResponse struct {
	Returnval []CryptoKeyResult `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type AddLicense AddLicenseRequestType

func init() {
	t["AddLicense"] = reflect.TypeOf((*AddLicense)(nil)).Elem()
}

// The parameters of `LicenseManager.AddLicense`.
type AddLicenseRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A license. E.g. a serial license.
	LicenseKey string `xml:"licenseKey" json:"licenseKey"`
	// array of key-value labels. Ignored by ESX Server.
	Labels []KeyValue `xml:"labels,omitempty" json:"labels,omitempty"`
}

func init() {
	t["AddLicenseRequestType"] = reflect.TypeOf((*AddLicenseRequestType)(nil)).Elem()
}

type AddLicenseResponse struct {
	Returnval LicenseManagerLicenseInfo `xml:"returnval" json:"returnval"`
}

type AddMonitoredEntities AddMonitoredEntitiesRequestType

func init() {
	t["AddMonitoredEntities"] = reflect.TypeOf((*AddMonitoredEntities)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.AddMonitoredEntities`.
type AddMonitoredEntitiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The provider id.
	ProviderId string `xml:"providerId" json:"providerId"`
	// The entities that are newly monitored by this
	// provider.
	//
	// Refers instances of `ManagedEntity`.
	Entities []ManagedObjectReference `xml:"entities,omitempty" json:"entities,omitempty"`
}

func init() {
	t["AddMonitoredEntitiesRequestType"] = reflect.TypeOf((*AddMonitoredEntitiesRequestType)(nil)).Elem()
}

type AddMonitoredEntitiesResponse struct {
}

type AddNetworkResourcePool AddNetworkResourcePoolRequestType

func init() {
	t["AddNetworkResourcePool"] = reflect.TypeOf((*AddNetworkResourcePool)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.AddNetworkResourcePool`.
type AddNetworkResourcePoolRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// the network resource pool configuration specification.
	ConfigSpec []DVSNetworkResourcePoolConfigSpec `xml:"configSpec" json:"configSpec"`
}

func init() {
	t["AddNetworkResourcePoolRequestType"] = reflect.TypeOf((*AddNetworkResourcePoolRequestType)(nil)).Elem()
}

type AddNetworkResourcePoolResponse struct {
}

type AddPortGroup AddPortGroupRequestType

func init() {
	t["AddPortGroup"] = reflect.TypeOf((*AddPortGroup)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.AddPortGroup`.
type AddPortGroupRequestType struct {
	This    ManagedObjectReference `xml:"_this" json:"-"`
	Portgrp HostPortGroupSpec      `xml:"portgrp" json:"portgrp"`
}

func init() {
	t["AddPortGroupRequestType"] = reflect.TypeOf((*AddPortGroupRequestType)(nil)).Elem()
}

type AddPortGroupResponse struct {
}

type AddServiceConsoleVirtualNic AddServiceConsoleVirtualNicRequestType

func init() {
	t["AddServiceConsoleVirtualNic"] = reflect.TypeOf((*AddServiceConsoleVirtualNic)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.AddServiceConsoleVirtualNic`.
type AddServiceConsoleVirtualNicRequestType struct {
	This      ManagedObjectReference `xml:"_this" json:"-"`
	Portgroup string                 `xml:"portgroup" json:"portgroup"`
	Nic       HostVirtualNicSpec     `xml:"nic" json:"nic"`
}

func init() {
	t["AddServiceConsoleVirtualNicRequestType"] = reflect.TypeOf((*AddServiceConsoleVirtualNicRequestType)(nil)).Elem()
}

type AddServiceConsoleVirtualNicResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// The parameters of `Folder.AddStandaloneHost_Task`.
type AddStandaloneHostRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specifies the parameters needed to add a single host.
	Spec HostConnectSpec `xml:"spec" json:"spec"`
	// Optionally specify the configuration for the compute
	// resource that will be created to contain the host.
	CompResSpec BaseComputeResourceConfigSpec `xml:"compResSpec,omitempty,typeattr" json:"compResSpec,omitempty"`
	// Flag to specify whether or not the host should be
	// connected as soon as it is added. The host will not
	// be added if a connection attempt is made and fails.
	AddConnected bool `xml:"addConnected" json:"addConnected"`
	// Provide a licenseKey or licenseKeyType. See `LicenseManager`
	License string `xml:"license,omitempty" json:"license,omitempty"`
}

func init() {
	t["AddStandaloneHostRequestType"] = reflect.TypeOf((*AddStandaloneHostRequestType)(nil)).Elem()
}

type AddStandaloneHost_Task AddStandaloneHostRequestType

func init() {
	t["AddStandaloneHost_Task"] = reflect.TypeOf((*AddStandaloneHost_Task)(nil)).Elem()
}

type AddStandaloneHost_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type AddVirtualNic AddVirtualNicRequestType

func init() {
	t["AddVirtualNic"] = reflect.TypeOf((*AddVirtualNic)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.AddVirtualNic`.
type AddVirtualNicRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Note: Must be the empty string in case nic.distributedVirtualPort
	// is set.
	Portgroup string             `xml:"portgroup" json:"portgroup"`
	Nic       HostVirtualNicSpec `xml:"nic" json:"nic"`
}

func init() {
	t["AddVirtualNicRequestType"] = reflect.TypeOf((*AddVirtualNicRequestType)(nil)).Elem()
}

type AddVirtualNicResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type AddVirtualSwitch AddVirtualSwitchRequestType

func init() {
	t["AddVirtualSwitch"] = reflect.TypeOf((*AddVirtualSwitch)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.AddVirtualSwitch`.
type AddVirtualSwitchRequestType struct {
	This        ManagedObjectReference `xml:"_this" json:"-"`
	VswitchName string                 `xml:"vswitchName" json:"vswitchName"`
	Spec        *HostVirtualSwitchSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["AddVirtualSwitchRequestType"] = reflect.TypeOf((*AddVirtualSwitchRequestType)(nil)).Elem()
}

type AddVirtualSwitchResponse struct {
}

// Fault thrown if an attempt to disable the Administrator permission
// on a host of which the Administator permission has already been disabled.
type AdminDisabled struct {
	HostConfigFault
}

func init() {
	t["AdminDisabled"] = reflect.TypeOf((*AdminDisabled)(nil)).Elem()
}

type AdminDisabledFault AdminDisabled

func init() {
	t["AdminDisabledFault"] = reflect.TypeOf((*AdminDisabledFault)(nil)).Elem()
}

// Fault thrown if an attempt to enable the Administrator permission
// on a host of which the Administator permission is not disabled.
type AdminNotDisabled struct {
	HostConfigFault
}

func init() {
	t["AdminNotDisabled"] = reflect.TypeOf((*AdminNotDisabled)(nil)).Elem()
}

type AdminNotDisabledFault AdminNotDisabled

func init() {
	t["AdminNotDisabledFault"] = reflect.TypeOf((*AdminNotDisabledFault)(nil)).Elem()
}

// Default password for the Admin user on the host has not been changed.
type AdminPasswordNotChangedEvent struct {
	HostEvent
}

func init() {
	t["AdminPasswordNotChangedEvent"] = reflect.TypeOf((*AdminPasswordNotChangedEvent)(nil)).Elem()
}

// Virtual machine has a configured memory and/or CPU affinity that will
// prevent VMotion.
//
// This is an error for powered-on virtual machines.
type AffinityConfigured struct {
	MigrationFault

	// Configured affinity types for the virtual machine.
	//
	// See `AffinityType_enum` for valid values.
	ConfiguredAffinity []string `xml:"configuredAffinity" json:"configuredAffinity"`
}

func init() {
	t["AffinityConfigured"] = reflect.TypeOf((*AffinityConfigured)(nil)).Elem()
}

type AffinityConfiguredFault AffinityConfigured

func init() {
	t["AffinityConfiguredFault"] = reflect.TypeOf((*AffinityConfiguredFault)(nil)).Elem()
}

// The `AfterStartupTaskScheduler` data object establishes the time
// that a scheduled task will run after the vCenter server restarts.
type AfterStartupTaskScheduler struct {
	TaskScheduler

	// The delay in minutes after vCenter server is restarted.
	//
	// The value must be greater than or equal to 0.
	Minute int32 `xml:"minute" json:"minute"`
}

func init() {
	t["AfterStartupTaskScheduler"] = reflect.TypeOf((*AfterStartupTaskScheduler)(nil)).Elem()
}

// An AgentInstallFailed fault is thrown when VirtualCenter
// fails to install the VirtualCenter agent on a host.
//
// For example, a fault is
// thrown if the agent software cannot be uploaded to the host or an error occurred
// during the agent installation.
type AgentInstallFailed struct {
	HostConnectFault

	// The reason why the agent install failed, if known.
	//
	// Values should come from `AgentInstallFailedReason_enum`.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
	// The status code returned by the agent installer, if it was run.
	StatusCode int32 `xml:"statusCode,omitempty" json:"statusCode,omitempty"`
	// The output (stdout/stderr) from executing the agent installer.
	InstallerOutput string `xml:"installerOutput,omitempty" json:"installerOutput,omitempty"`
}

func init() {
	t["AgentInstallFailed"] = reflect.TypeOf((*AgentInstallFailed)(nil)).Elem()
}

type AgentInstallFailedFault AgentInstallFailed

func init() {
	t["AgentInstallFailedFault"] = reflect.TypeOf((*AgentInstallFailedFault)(nil)).Elem()
}

// This event records the acknowledgement of an Alarm
type AlarmAcknowledgedEvent struct {
	AlarmEvent

	// The entity that triggered the alarm.
	Source ManagedEntityEventArgument `xml:"source" json:"source"`
	// The entity with which the alarm is registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
}

func init() {
	t["AlarmAcknowledgedEvent"] = reflect.TypeOf((*AlarmAcknowledgedEvent)(nil)).Elem()
}

// Action invoked by triggered alarm.
//
// This is an abstract type.
type AlarmAction struct {
	DynamicData
}

func init() {
	t["AlarmAction"] = reflect.TypeOf((*AlarmAction)(nil)).Elem()
}

// This event records that an alarm was triggered.
type AlarmActionTriggeredEvent struct {
	AlarmEvent

	// The entity that triggered the alarm.
	Source ManagedEntityEventArgument `xml:"source" json:"source"`
	// The entity with which the alarm is registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
}

func init() {
	t["AlarmActionTriggeredEvent"] = reflect.TypeOf((*AlarmActionTriggeredEvent)(nil)).Elem()
}

// This event records the manual clearing of an Alarm
type AlarmClearedEvent struct {
	AlarmEvent

	// The entity that triggered the alarm.
	Source ManagedEntityEventArgument `xml:"source" json:"source"`
	// The entity with which the alarm is registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
	// The original alarm status from which it was cleared
	From string `xml:"from" json:"from"`
}

func init() {
	t["AlarmClearedEvent"] = reflect.TypeOf((*AlarmClearedEvent)(nil)).Elem()
}

// This event records the creation of an alarm.
type AlarmCreatedEvent struct {
	AlarmEvent

	// The entity with which the alarm is registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
}

func init() {
	t["AlarmCreatedEvent"] = reflect.TypeOf((*AlarmCreatedEvent)(nil)).Elem()
}

// Static strings for alarms.
type AlarmDescription struct {
	DynamicData

	// Descriptions of expression types for a trigger.
	Expr []BaseTypeDescription `xml:"expr,typeattr" json:"expr"`
	// *State Operator enum description*
	StateOperator []BaseElementDescription `xml:"stateOperator,typeattr" json:"stateOperator"`
	// *MetricAlarmExpression Metric Operator enum description*
	MetricOperator []BaseElementDescription `xml:"metricOperator,typeattr" json:"metricOperator"`
	// *Host System Connection State enum description*
	HostSystemConnectionState []BaseElementDescription `xml:"hostSystemConnectionState,typeattr" json:"hostSystemConnectionState"`
	// *Virtual Machine Power State enum description*
	VirtualMachinePowerState []BaseElementDescription `xml:"virtualMachinePowerState,typeattr" json:"virtualMachinePowerState"`
	// `DatastoreSummary.accessible` and
	// `description`
	DatastoreConnectionState []BaseElementDescription `xml:"datastoreConnectionState,omitempty,typeattr" json:"datastoreConnectionState,omitempty"`
	// *Host System Power State enum description*
	HostSystemPowerState []BaseElementDescription `xml:"hostSystemPowerState,omitempty,typeattr" json:"hostSystemPowerState,omitempty"`
	// *Guest Heartbeat Status enum description*
	VirtualMachineGuestHeartbeatStatus []BaseElementDescription `xml:"virtualMachineGuestHeartbeatStatus,omitempty,typeattr" json:"virtualMachineGuestHeartbeatStatus,omitempty"`
	// *ManagedEntity Status enum description*
	EntityStatus []BaseElementDescription `xml:"entityStatus,typeattr" json:"entityStatus"`
	// Action class descriptions for an alarm.
	Action []BaseTypeDescription `xml:"action,typeattr" json:"action"`
}

func init() {
	t["AlarmDescription"] = reflect.TypeOf((*AlarmDescription)(nil)).Elem()
}

// This event records the completion of an alarm email notification.
type AlarmEmailCompletedEvent struct {
	AlarmEvent

	// The entity with which the alarm is registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
	// The destination email address.
	To string `xml:"to" json:"to"`
}

func init() {
	t["AlarmEmailCompletedEvent"] = reflect.TypeOf((*AlarmEmailCompletedEvent)(nil)).Elem()
}

// This event records a failure to complete an alarm email notification.
type AlarmEmailFailedEvent struct {
	AlarmEvent

	// The entity with which the alarm is registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
	// The destination email address.
	To string `xml:"to" json:"to"`
	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["AlarmEmailFailedEvent"] = reflect.TypeOf((*AlarmEmailFailedEvent)(nil)).Elem()
}

// This event is an alarm events.
type AlarmEvent struct {
	Event

	// The associated alarm object.
	Alarm AlarmEventArgument `xml:"alarm" json:"alarm"`
}

func init() {
	t["AlarmEvent"] = reflect.TypeOf((*AlarmEvent)(nil)).Elem()
}

// The event argument is an Alarm object.
type AlarmEventArgument struct {
	EntityEventArgument

	// The Alarm object.
	//
	// Refers instance of `Alarm`.
	Alarm ManagedObjectReference `xml:"alarm" json:"alarm"`
}

func init() {
	t["AlarmEventArgument"] = reflect.TypeOf((*AlarmEventArgument)(nil)).Elem()
}

// Base type for the expressions specifying the conditions that define
// the status of an alarm.
type AlarmExpression struct {
	DynamicData
}

func init() {
	t["AlarmExpression"] = reflect.TypeOf((*AlarmExpression)(nil)).Elem()
}

// Alarm Filter used to filter/group alarms.
type AlarmFilterSpec struct {
	DynamicData

	// Status array which could be used to filter alarms according to their
	// triggered state.
	//
	// If all triggered alarms need to be matched an empty array or
	// ManagedEntity::red and ManagedEntity::yellow could be filled in the array.
	Status []ManagedEntityStatus `xml:"status,omitempty" json:"status,omitempty"`
	// Use values from `AlarmFilterSpecAlarmTypeByEntity_enum`
	TypeEntity string `xml:"typeEntity,omitempty" json:"typeEntity,omitempty"`
	// Use values from `AlarmFilterSpecAlarmTypeByTrigger_enum`
	TypeTrigger string `xml:"typeTrigger,omitempty" json:"typeTrigger,omitempty"`
}

func init() {
	t["AlarmFilterSpec"] = reflect.TypeOf((*AlarmFilterSpec)(nil)).Elem()
}

// Attributes of an alarm.
type AlarmInfo struct {
	AlarmSpec

	// The unique key.
	Key string `xml:"key" json:"key"`
	// The alarm object.
	//
	// Refers instance of `Alarm`.
	Alarm ManagedObjectReference `xml:"alarm" json:"alarm"`
	// The entity on which the alarm is registered.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// The time the alarm was created or modified.
	LastModifiedTime time.Time `xml:"lastModifiedTime" json:"lastModifiedTime"`
	// User name that modified the alarm most recently.
	LastModifiedUser string `xml:"lastModifiedUser" json:"lastModifiedUser"`
	// The event ID that records the alarm creation.
	CreationEventId int32 `xml:"creationEventId" json:"creationEventId"`
}

func init() {
	t["AlarmInfo"] = reflect.TypeOf((*AlarmInfo)(nil)).Elem()
}

// This event records the reconfiguration of an alarm.
type AlarmReconfiguredEvent struct {
	AlarmEvent

	// The entity with which the alarm is registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
	// The configuration values changed during the reconfiguration.
	ConfigChanges *ChangesInfoEventArgument `xml:"configChanges,omitempty" json:"configChanges,omitempty"`
}

func init() {
	t["AlarmReconfiguredEvent"] = reflect.TypeOf((*AlarmReconfiguredEvent)(nil)).Elem()
}

// This event records the removal of an alarm.
type AlarmRemovedEvent struct {
	AlarmEvent

	// The entity with which the alarm is registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
}

func init() {
	t["AlarmRemovedEvent"] = reflect.TypeOf((*AlarmRemovedEvent)(nil)).Elem()
}

// This event records the completion of an alarm-triggered script.
type AlarmScriptCompleteEvent struct {
	AlarmEvent

	// The entity with which the alarm is registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
	// The script triggered by the alarm.
	Script string `xml:"script" json:"script"`
}

func init() {
	t["AlarmScriptCompleteEvent"] = reflect.TypeOf((*AlarmScriptCompleteEvent)(nil)).Elem()
}

// This event records a failure to complete an alarm-triggered script.
type AlarmScriptFailedEvent struct {
	AlarmEvent

	// The entity with which the alarm is registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
	// The script triggered by the alarm.
	Script string `xml:"script" json:"script"`
	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["AlarmScriptFailedEvent"] = reflect.TypeOf((*AlarmScriptFailedEvent)(nil)).Elem()
}

// Tolerance and frequency limits of an alarm.
type AlarmSetting struct {
	DynamicData

	// Tolerance range for the metric triggers, measured in one hundredth percentage.
	//
	// A zero value means that the alarm
	// triggers whenever the metric value is above
	// or below the specified value.
	// A nonzero value means that the alarm
	// triggers only after reaching a certain percentage
	// above or below the nominal trigger value.
	ToleranceRange int32 `xml:"toleranceRange" json:"toleranceRange"`
	// How often the alarm is triggered, measured in seconds.
	//
	// A zero value means that the alarm is allowed
	// to trigger as often as possible.
	// A nonzero value means that any subsequent triggers
	// are suppressed for a period of seconds following a
	// reported trigger.
	ReportingFrequency int32 `xml:"reportingFrequency" json:"reportingFrequency"`
}

func init() {
	t["AlarmSetting"] = reflect.TypeOf((*AlarmSetting)(nil)).Elem()
}

// This event records the completion of an alarm SNMP notification.
type AlarmSnmpCompletedEvent struct {
	AlarmEvent

	// The entity with which the alarm is registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
}

func init() {
	t["AlarmSnmpCompletedEvent"] = reflect.TypeOf((*AlarmSnmpCompletedEvent)(nil)).Elem()
}

// This event records a failure to complete an alarm SNMP notification.
type AlarmSnmpFailedEvent struct {
	AlarmEvent

	// The entity with which the alarm is registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["AlarmSnmpFailedEvent"] = reflect.TypeOf((*AlarmSnmpFailedEvent)(nil)).Elem()
}

// Parameters for alarm creation.
type AlarmSpec struct {
	DynamicData

	// Name of the alarm.
	Name string `xml:"name" json:"name"`
	// System name of the alarm.
	//
	// This is set only for predefined Alarms - i.e. Alarms created by the
	// server or extensions automatically. After creation this value cannot be
	// modified. User-created Alarms do not have a systemName at all.
	//
	// The purpose of this field is to identify system-created Alarms
	// reliably, even if they are edited by users.
	//
	// When creating Alarms with systemName, the systemName and the name of the
	// alarm should be equal.
	//
	// When reconfiguring an Alarm with systemName, the same systemName should
	// be passed in the new AlarmSpec. Renaming Alarms with systemName is not
	// allowed, i.e. when reconfiguring, the name passed in the new AlarmSpec
	// should be equal to either the systemName or its localized version (the
	// current name in the Alarm's info).
	SystemName string `xml:"systemName,omitempty" json:"systemName,omitempty"`
	// Description of the alarm.
	Description string `xml:"description" json:"description"`
	// Flag to indicate whether or not the alarm is enabled or disabled.
	Enabled bool `xml:"enabled" json:"enabled"`
	// Top-level alarm expression that defines trigger conditions.
	Expression BaseAlarmExpression `xml:"expression,typeattr" json:"expression"`
	// Action to perform when the alarm is triggered.
	Action BaseAlarmAction `xml:"action,omitempty,typeattr" json:"action,omitempty"`
	// Frequency in seconds, which specifies how often appropriate actions
	// should repeat when an alarm does not change state.
	ActionFrequency int32 `xml:"actionFrequency,omitempty" json:"actionFrequency,omitempty"`
	// Tolerance and maximum frequency settings.
	Setting *AlarmSetting `xml:"setting,omitempty" json:"setting,omitempty"`
}

func init() {
	t["AlarmSpec"] = reflect.TypeOf((*AlarmSpec)(nil)).Elem()
}

// Information about the alarm's state.
type AlarmState struct {
	DynamicData

	// Unique key that identifies the alarm.
	Key string `xml:"key" json:"key"`
	// Entity on which the alarm is instantiated.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// Alarm object from which the AlarmState object is instantiated.
	//
	// Refers instance of `Alarm`.
	Alarm ManagedObjectReference `xml:"alarm" json:"alarm"`
	// Overall status of the alarm object.
	//
	// This is the value of the alarm's top-level expression.
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	OverallStatus ManagedEntityStatus `xml:"overallStatus" json:"overallStatus"`
	// Time the alarm triggered.
	Time time.Time `xml:"time" json:"time"`
	// Flag to indicate if the alarm's actions have been acknowledged for the
	// associated ManagedEntity.
	Acknowledged *bool `xml:"acknowledged" json:"acknowledged,omitempty"`
	// The user who acknowledged this triggering.
	//
	// If the triggering has not
	// been acknowledged, then the value is not valid.
	AcknowledgedByUser string `xml:"acknowledgedByUser,omitempty" json:"acknowledgedByUser,omitempty"`
	// The time this triggering was acknowledged.
	//
	// If the triggering has not
	// been acknowledged, then the value is not valid.
	AcknowledgedTime *time.Time `xml:"acknowledgedTime" json:"acknowledgedTime,omitempty"`
	// Contains the key of the event that has triggered the alarm.
	//
	// The value
	// is set only for event based alarms. The value is not set for gray or
	// manually reset alarms (via vim.AlarmManager.setAlarmStatus).
	EventKey int32 `xml:"eventKey,omitempty" json:"eventKey,omitempty"`
	// Flag to indicate if the alarm is disabled for the associated
	// ManagedEntity.
	Disabled *bool `xml:"disabled" json:"disabled,omitempty"`
}

func init() {
	t["AlarmState"] = reflect.TypeOf((*AlarmState)(nil)).Elem()
}

// This event records a status change for an alarm.
type AlarmStatusChangedEvent struct {
	AlarmEvent

	// The entity for which the alarm status has been changed.
	Source ManagedEntityEventArgument `xml:"source" json:"source"`
	// The entity with which the alarm is registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
	// The original alarm status.
	From string `xml:"from" json:"from"`
	// The new alarm status.
	To string `xml:"to" json:"to"`
}

func init() {
	t["AlarmStatusChangedEvent"] = reflect.TypeOf((*AlarmStatusChangedEvent)(nil)).Elem()
}

// This data object type describes one or more
// triggering transitions and an action to be done
// when an alarm is triggered.
//
// There are four triggering transitions; at least one of them must
// be provided. A gray state is considered the same as a green state,
// for the purpose of detecting transitions.
type AlarmTriggeringAction struct {
	AlarmAction

	// The action to be done when the alarm is triggered.
	Action BaseAction `xml:"action,typeattr" json:"action"`
	// Indicates on which transitions this action executes and repeats.
	//
	// This is optional only for backwards compatibility.
	TransitionSpecs []AlarmTriggeringActionTransitionSpec `xml:"transitionSpecs,omitempty" json:"transitionSpecs,omitempty"`
	// Deprecated as of vSphere API 4.0, use
	// `AlarmTriggeringActionTransitionSpec` .
	//
	// Flag to specify that the alarm should trigger on a transition
	// from green to yellow.
	Green2yellow bool `xml:"green2yellow" json:"green2yellow"`
	// Deprecated as of vSphere API 4.0, use
	// `AlarmTriggeringActionTransitionSpec` .
	//
	// Flag to specify that the alarm should trigger on a transition
	// from yellow to red.
	Yellow2red bool `xml:"yellow2red" json:"yellow2red"`
	// Deprecated as of vSphere API 4.0, use
	// `AlarmTriggeringActionTransitionSpec` .
	//
	// Flag to specify that the alarm should trigger on a transition
	// from red to yellow.
	Red2yellow bool `xml:"red2yellow" json:"red2yellow"`
	// Deprecated as of vSphere API 4.0, use
	// `AlarmTriggeringActionTransitionSpec` .
	//
	// Flag to specify that the alarm should trigger on a transition
	// from yellow to green.
	Yellow2green bool `xml:"yellow2green" json:"yellow2green"`
}

func init() {
	t["AlarmTriggeringAction"] = reflect.TypeOf((*AlarmTriggeringAction)(nil)).Elem()
}

// Specification indicating which on transitions this action fires.
//
// The existence of a Spec indicates that this action fires on
// transitions from that Spec's startState to finalState.
//
// There are six acceptable {startState, finalState} pairs:
// {green, yellow}, {green, red}, {yellow, red}, {red, yellow},
// {red, green} and {yellow, green}.
// Direct transitions have precedence over indirect.
// At least one of these pairs must be specified.
// Any deviation from the above will render the enclosing AlarmSpec invalid.
type AlarmTriggeringActionTransitionSpec struct {
	DynamicData

	// The state from which the alarm must transition for the action to
	// fire.
	//
	// Valid choices are red, yellow and green.
	StartState ManagedEntityStatus `xml:"startState" json:"startState"`
	// The state to which the alarm must transition for the action to fire.
	//
	// Valid choices are red, yellow, and green.
	FinalState ManagedEntityStatus `xml:"finalState" json:"finalState"`
	// Whether or not the action repeats, as per the actionFrequency defined
	// in the enclosing Alarm.
	Repeats bool `xml:"repeats" json:"repeats"`
}

func init() {
	t["AlarmTriggeringActionTransitionSpec"] = reflect.TypeOf((*AlarmTriggeringActionTransitionSpec)(nil)).Elem()
}

// This event records that the previously unlicensed virtual machines on
// the specified host are now licensed.
//
// After this event is entered into
// the event log, we expect to see that the (@link
// vim.event.Event.UnlicensedVirtualMachinesEvent
// UnlicensedVirtualMachinesEvent) (@link vim.ManagedEntity.configIssue
// configIssue) is removed from the host.
type AllVirtualMachinesLicensedEvent struct {
	LicenseEvent
}

func init() {
	t["AllVirtualMachinesLicensedEvent"] = reflect.TypeOf((*AllVirtualMachinesLicensedEvent)(nil)).Elem()
}

type AllocateIpv4Address AllocateIpv4AddressRequestType

func init() {
	t["AllocateIpv4Address"] = reflect.TypeOf((*AllocateIpv4Address)(nil)).Elem()
}

// The parameters of `IpPoolManager.AllocateIpv4Address`.
type AllocateIpv4AddressRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datacenter on which to find the pool
	//
	// Refers instance of `Datacenter`.
	Dc ManagedObjectReference `xml:"dc" json:"dc"`
	// The unique ID of the pool
	PoolId int32 `xml:"poolId" json:"poolId"`
	// The unique ID for this allocation
	AllocationId string `xml:"allocationId" json:"allocationId"`
}

func init() {
	t["AllocateIpv4AddressRequestType"] = reflect.TypeOf((*AllocateIpv4AddressRequestType)(nil)).Elem()
}

type AllocateIpv4AddressResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type AllocateIpv6Address AllocateIpv6AddressRequestType

func init() {
	t["AllocateIpv6Address"] = reflect.TypeOf((*AllocateIpv6Address)(nil)).Elem()
}

// The parameters of `IpPoolManager.AllocateIpv6Address`.
type AllocateIpv6AddressRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datacenter on which to find the pool
	//
	// Refers instance of `Datacenter`.
	Dc ManagedObjectReference `xml:"dc" json:"dc"`
	// The unique ID of the pool
	PoolId int32 `xml:"poolId" json:"poolId"`
	// The unique ID for this allocation
	AllocationId string `xml:"allocationId" json:"allocationId"`
}

func init() {
	t["AllocateIpv6AddressRequestType"] = reflect.TypeOf((*AllocateIpv6AddressRequestType)(nil)).Elem()
}

type AllocateIpv6AddressResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// This event records a failed user logon due to the user already being logged on.
type AlreadyAuthenticatedSessionEvent struct {
	SessionEvent
}

func init() {
	t["AlreadyAuthenticatedSessionEvent"] = reflect.TypeOf((*AlreadyAuthenticatedSessionEvent)(nil)).Elem()
}

// AlreadyBeingManaged fault is thrown by the host
// connect method if the host is already being managed
// by a VirtualCenter server.
type AlreadyBeingManaged struct {
	HostConnectFault

	// IP address of server that is currently managing the host.
	IpAddress string `xml:"ipAddress" json:"ipAddress"`
}

func init() {
	t["AlreadyBeingManaged"] = reflect.TypeOf((*AlreadyBeingManaged)(nil)).Elem()
}

type AlreadyBeingManagedFault AlreadyBeingManaged

func init() {
	t["AlreadyBeingManagedFault"] = reflect.TypeOf((*AlreadyBeingManagedFault)(nil)).Elem()
}

// AlreadyConnect fault is thrown by the host connect method
// if the host is already connected to a VirtualCenter server.
//
// This might occur if the host has been added more than once
// in the same VirtualCenter in different folders or compute
// resources.
type AlreadyConnected struct {
	HostConnectFault

	// Name of the host
	Name string `xml:"name" json:"name"`
}

func init() {
	t["AlreadyConnected"] = reflect.TypeOf((*AlreadyConnected)(nil)).Elem()
}

type AlreadyConnectedFault AlreadyConnected

func init() {
	t["AlreadyConnectedFault"] = reflect.TypeOf((*AlreadyConnectedFault)(nil)).Elem()
}

// An AlreadyExists fault is thrown when an attempt is made to add an element
// to a collection, if the element's key, name, or identifier already exists in that
// collection.
type AlreadyExists struct {
	VimFault

	Name string `xml:"name,omitempty" json:"name,omitempty"`
}

func init() {
	t["AlreadyExists"] = reflect.TypeOf((*AlreadyExists)(nil)).Elem()
}

type AlreadyExistsFault AlreadyExists

func init() {
	t["AlreadyExistsFault"] = reflect.TypeOf((*AlreadyExistsFault)(nil)).Elem()
}

// An AlreadyUpgraded fault is thrown when an attempt is made to upgrade the
// virtual hardware of a Virtual machine whose virtual hardware is already
// up-to-date.
type AlreadyUpgraded struct {
	VimFault
}

func init() {
	t["AlreadyUpgraded"] = reflect.TypeOf((*AlreadyUpgraded)(nil)).Elem()
}

type AlreadyUpgradedFault AlreadyUpgraded

func init() {
	t["AlreadyUpgradedFault"] = reflect.TypeOf((*AlreadyUpgradedFault)(nil)).Elem()
}

// A data object type that links multiple alarm expressions with AND operators.
type AndAlarmExpression struct {
	AlarmExpression

	// List of alarm expressions that define the overall status of the alarm.
	//   - The state of the alarm expression is gray if all subexpressions are gray.
	//     Otherwise, gray subexpressions are ignored.
	//   - The state is red if all subexpressions are red.
	//   - Otherwise, the state is yellow if all subexpressions are red or yellow.
	//   - Otherwise, the state of the alarm expression is green.
	Expression []BaseAlarmExpression `xml:"expression,typeattr" json:"expression"`
}

func init() {
	t["AndAlarmExpression"] = reflect.TypeOf((*AndAlarmExpression)(nil)).Elem()
}

// The `AnswerFile` data object contains host-specific information that a host
// will use in combination with a `HostProfile` for configuration.
//
// Answer files are stored on the vCenter Server, along with host profiles.
// An answer file is always associated with a particular host.
//
// To supply host-specific data:
//   - Specify deferred parameters when you call the
//     `HostProfile*.*HostProfile.ExecuteHostProfile`
//     method. The host profile engine will verify the set of parameters for the
//     additional configuration data.
//   - Use the complete required input list
//     (`ProfileExecuteResult*.*ProfileExecuteResult.requireInput`\[\])
//     as user input for the
//     `HostProfileManager*.*HostProfileManager.ApplyHostConfig_Task`
//     method. When you apply the profile, the vCenter Server saves the additional configuration
//     data in the `AnswerFile.userInput` list.
//   - Use the `HostProfileManager*.*HostProfileManager.UpdateAnswerFile_Task` method. This method will update an existing answer file or create a new one.
type AnswerFile struct {
	DynamicData

	// List containing host-specific configuration data.
	UserInput []ProfileDeferredPolicyOptionParameter `xml:"userInput,omitempty" json:"userInput,omitempty"`
	// Time at which the answer file was created.
	CreatedTime time.Time `xml:"createdTime" json:"createdTime"`
	// Time at which the answer file was last modified.
	ModifiedTime time.Time `xml:"modifiedTime" json:"modifiedTime"`
}

func init() {
	t["AnswerFile"] = reflect.TypeOf((*AnswerFile)(nil)).Elem()
}

// Base class for host-specific answer file options.
type AnswerFileCreateSpec struct {
	DynamicData

	// If "false", then the answer file will be saved without being validated.
	//
	// The default if not specified is "true".
	// This option should be used with caution, since the resulting answer
	// file will not be checked for errors.
	Validating *bool `xml:"validating" json:"validating,omitempty"`
}

func init() {
	t["AnswerFileCreateSpec"] = reflect.TypeOf((*AnswerFileCreateSpec)(nil)).Elem()
}

// The `AnswerFileOptionsCreateSpec`
// data object contains host-specific user input for an answer file.
type AnswerFileOptionsCreateSpec struct {
	AnswerFileCreateSpec

	// List of parameters that contain host-specific data.
	UserInput []ProfileDeferredPolicyOptionParameter `xml:"userInput,omitempty" json:"userInput,omitempty"`
}

func init() {
	t["AnswerFileOptionsCreateSpec"] = reflect.TypeOf((*AnswerFileOptionsCreateSpec)(nil)).Elem()
}

// The `AnswerFileSerializedCreateSpec` data object
// contains a serialized string representation of host-specific data for an answer file.
type AnswerFileSerializedCreateSpec struct {
	AnswerFileCreateSpec

	// Host-specific user input.
	AnswerFileConfigString string `xml:"answerFileConfigString" json:"answerFileConfigString"`
}

func init() {
	t["AnswerFileSerializedCreateSpec"] = reflect.TypeOf((*AnswerFileSerializedCreateSpec)(nil)).Elem()
}

// The `AnswerFileStatusError` data object describes an answer file
// error and identifies the profile or policy option with which the error
// is associated.
type AnswerFileStatusError struct {
	DynamicData

	// Path to a profile or a policy option for host-specific data.
	UserInputPath ProfilePropertyPath `xml:"userInputPath" json:"userInputPath"`
	// Message describing the error.
	ErrMsg LocalizableMessage `xml:"errMsg" json:"errMsg"`
}

func init() {
	t["AnswerFileStatusError"] = reflect.TypeOf((*AnswerFileStatusError)(nil)).Elem()
}

// The `AnswerFileStatusResult` data object shows the validity of the
// answer file associated with a host.
type AnswerFileStatusResult struct {
	DynamicData

	// Time that the answer file status was determined.
	CheckedTime time.Time `xml:"checkedTime" json:"checkedTime"`
	// Host associated with the answer file.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Status of the answer file.
	//
	// See `HostProfileManagerAnswerFileStatus_enum` for valid values.
	Status string `xml:"status" json:"status"`
	// If <code>status</code> is <code>invalid</code>, this property contains a list
	// of status error objects.
	Error []AnswerFileStatusError `xml:"error,omitempty" json:"error,omitempty"`
}

func init() {
	t["AnswerFileStatusResult"] = reflect.TypeOf((*AnswerFileStatusResult)(nil)).Elem()
}

// Could not update the answer file as it has invalid inputs.
type AnswerFileUpdateFailed struct {
	VimFault

	// Failures encountered during answer file update
	Failure []AnswerFileUpdateFailure `xml:"failure" json:"failure"`
}

func init() {
	t["AnswerFileUpdateFailed"] = reflect.TypeOf((*AnswerFileUpdateFailed)(nil)).Elem()
}

type AnswerFileUpdateFailedFault AnswerFileUpdateFailed

func init() {
	t["AnswerFileUpdateFailedFault"] = reflect.TypeOf((*AnswerFileUpdateFailedFault)(nil)).Elem()
}

// DataObject which represents the errors that occurred when an
// answer file update was performed.
type AnswerFileUpdateFailure struct {
	DynamicData

	// The user input that has the error
	UserInputPath ProfilePropertyPath `xml:"userInputPath" json:"userInputPath"`
	// Message which explains the error
	ErrMsg LocalizableMessage `xml:"errMsg" json:"errMsg"`
}

func init() {
	t["AnswerFileUpdateFailure"] = reflect.TypeOf((*AnswerFileUpdateFailure)(nil)).Elem()
}

type AnswerVM AnswerVMRequestType

func init() {
	t["AnswerVM"] = reflect.TypeOf((*AnswerVM)(nil)).Elem()
}

// The parameters of `VirtualMachine.AnswerVM`.
type AnswerVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The value from QuestionInfo.id that identifies the question
	// to answer.
	QuestionId string `xml:"questionId" json:"questionId"`
	// The contents of the QuestionInfo.choice.value array element
	// that identifies the desired answer.
	AnswerChoice string `xml:"answerChoice" json:"answerChoice"`
}

func init() {
	t["AnswerVMRequestType"] = reflect.TypeOf((*AnswerVMRequestType)(nil)).Elem()
}

type AnswerVMResponse struct {
}

// This fault is thrown when creating a quiesced snapshot failed
// because the (user-supplied) custom pre-freeze script in the
// virtual machine exited with a non-zero return code.
//
// This indicates that the script failed to perform its quiescing
// task, which causes us to fail the quiesced snapshot operation.
type ApplicationQuiesceFault struct {
	SnapshotFault
}

func init() {
	t["ApplicationQuiesceFault"] = reflect.TypeOf((*ApplicationQuiesceFault)(nil)).Elem()
}

type ApplicationQuiesceFaultFault ApplicationQuiesceFault

func init() {
	t["ApplicationQuiesceFaultFault"] = reflect.TypeOf((*ApplicationQuiesceFaultFault)(nil)).Elem()
}

// The parameters of `HostProfileManager.ApplyEntitiesConfig_Task`.
type ApplyEntitiesConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// An array of
	// `ApplyHostProfileConfigurationSpec`
	// objects. Each applyConfigSpecs object contains the data objects
	// required to remediate a host. The API caller should expand
	// a cluster to all its hosts for the purpose of providing the
	// required data object for configuration apply of each host.
	ApplyConfigSpecs []ApplyHostProfileConfigurationSpec `xml:"applyConfigSpecs,omitempty" json:"applyConfigSpecs,omitempty"`
}

func init() {
	t["ApplyEntitiesConfigRequestType"] = reflect.TypeOf((*ApplyEntitiesConfigRequestType)(nil)).Elem()
}

type ApplyEntitiesConfig_Task ApplyEntitiesConfigRequestType

func init() {
	t["ApplyEntitiesConfig_Task"] = reflect.TypeOf((*ApplyEntitiesConfig_Task)(nil)).Elem()
}

type ApplyEntitiesConfig_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.ApplyEvcModeVM_Task`.
type ApplyEvcModeVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The feature masks to apply to the virtual machine.
	// An empty set of masks will clear EVC settings.
	Mask []HostFeatureMask `xml:"mask,omitempty" json:"mask,omitempty"`
	// Defaults to true if not set. A true value implies
	// that any unspecified feature will not be exposed to the guest.
	// A false value will expose any unspecified feature to the guest
	// with the value of the host.
	CompleteMasks *bool `xml:"completeMasks" json:"completeMasks,omitempty"`
}

func init() {
	t["ApplyEvcModeVMRequestType"] = reflect.TypeOf((*ApplyEvcModeVMRequestType)(nil)).Elem()
}

type ApplyEvcModeVM_Task ApplyEvcModeVMRequestType

func init() {
	t["ApplyEvcModeVM_Task"] = reflect.TypeOf((*ApplyEvcModeVM_Task)(nil)).Elem()
}

type ApplyEvcModeVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostProfileManager.ApplyHostConfig_Task`.
type ApplyHostConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Host to be updated. User must have sufficient credentials and privileges
	// to satisfy the contents of the <code>configSpec</code>.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Set of configuration changes to be applied to the host.
	// The changes are returned by the
	// `HostProfile*.*HostProfile.ExecuteHostProfile`
	// method in the
	// `ProfileExecuteResult*.*ProfileExecuteResult.configSpec`
	// property.
	ConfigSpec HostConfigSpec `xml:"configSpec" json:"configSpec"`
	// Additional host-specific data to be applied to the host.
	// This data is the complete list of deferred parameters verified by the
	// `HostProfile*.*HostProfile.ExecuteHostProfile`
	// method, contained in the `ProfileExecuteResult` object
	// returned by the method.
	UserInput []ProfileDeferredPolicyOptionParameter `xml:"userInput,omitempty" json:"userInput,omitempty"`
}

func init() {
	t["ApplyHostConfigRequestType"] = reflect.TypeOf((*ApplyHostConfigRequestType)(nil)).Elem()
}

type ApplyHostConfig_Task ApplyHostConfigRequestType

func init() {
	t["ApplyHostConfig_Task"] = reflect.TypeOf((*ApplyHostConfig_Task)(nil)).Elem()
}

type ApplyHostConfig_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The `ApplyHostProfileConfigurationResult` data object contains the remediation
// results for a host: the time that the remediation happens, the status,
// the errors, and optinal compliance result after reboot.
type ApplyHostProfileConfigurationResult struct {
	DynamicData

	// Time that the host config apply starts.
	StartTime time.Time `xml:"startTime" json:"startTime"`
	// Time that the host config apply completes.
	CompleteTime time.Time `xml:"completeTime" json:"completeTime"`
	// Host to be remediated.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Status of the remediation.
	//
	// See
	// `ApplyHostProfileConfigurationResultStatus_enum`
	// for valid values.
	Status string `xml:"status" json:"status"`
	// If <code>status</code> is <code>fail</code>, this property contains
	// a list of status error message objects.
	Errors []LocalizedMethodFault `xml:"errors,omitempty" json:"errors,omitempty"`
}

func init() {
	t["ApplyHostProfileConfigurationResult"] = reflect.TypeOf((*ApplyHostProfileConfigurationResult)(nil)).Elem()
}

// The data object that contains the objects needed to remediate a host
// in host profile batch apply.
type ApplyHostProfileConfigurationSpec struct {
	ProfileExecuteResult

	// The host to be remediated.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The task requirements from the results of
	// `HostProfileManager.GenerateConfigTaskList` method
	TaskListRequirement []string `xml:"taskListRequirement,omitempty" json:"taskListRequirement,omitempty"`
	// Description of tasks that will be performed on the host
	// to carry out HostProfile application.
	TaskDescription []LocalizableMessage `xml:"taskDescription,omitempty" json:"taskDescription,omitempty"`
	// For a stateless host, there are two approaches to apply a host
	// profile:
	// (1) Reboot the host and apply the host profile at boot time.
	//
	// (2) Apply the host profile directly from VC. We call this as
	// regular apply.
	// The variable rebootStateless allows users to choose the first
	// approach from the two approaches above:
	// apply host profile by rebooting this host.
	RebootStateless *bool `xml:"rebootStateless" json:"rebootStateless,omitempty"`
	// For regular apply, when some of the tasks requires reboot,
	// that this variable is<code>true</code> indicates that the
	// reboot automatically happens in the batch profile apply
	// than that the user will manually reboot the system later.
	//
	// For stateless host, this variable takes effect only when
	// the variable <code>rebootStateless</code> above is
	// <code>false</code>.
	RebootHost *bool `xml:"rebootHost" json:"rebootHost,omitempty"`
	// This contains the error details.
	FaultData *LocalizedMethodFault `xml:"faultData,omitempty" json:"faultData,omitempty"`
}

func init() {
	t["ApplyHostProfileConfigurationSpec"] = reflect.TypeOf((*ApplyHostProfileConfigurationSpec)(nil)).Elem()
}

// The `ApplyProfile` data object is the base class for all data objects
// that define profile configuration data.
//
// <code>ApplyProfile</code> defines ESX configuration data storage and it
// supports recursive profile definition for the profile plug-in architecture.
type ApplyProfile struct {
	DynamicData

	// Indicates whether the profile is enabled.
	Enabled bool `xml:"enabled" json:"enabled"`
	// The list of policies comprising the profile.
	//
	// A `ProfilePolicy`
	// stores one or more configuration data values in a `PolicyOption`.
	// The policy option is one of the configuration options from the
	// `ProfilePolicyMetadata*.*ProfilePolicyMetadata.possibleOption`
	// list.
	Policy []ProfilePolicy `xml:"policy,omitempty" json:"policy,omitempty"`
	// Identifies the profile type.
	ProfileTypeName string `xml:"profileTypeName,omitempty" json:"profileTypeName,omitempty"`
	// Profile engine version.
	ProfileVersion string `xml:"profileVersion,omitempty" json:"profileVersion,omitempty"`
	// List of subprofiles for this profile.
	//
	// This list can change depending on which profile plug-ins are available in the system.
	// Subprofiles can be nested to arbitrary depths to represent host capabilities.
	Property []ProfileApplyProfileProperty `xml:"property,omitempty" json:"property,omitempty"`
	// Indicates whether this profile is marked as "favorite".
	Favorite *bool `xml:"favorite" json:"favorite,omitempty"`
	// Indicates whether this profile is marked as to-be-merged.
	ToBeMerged *bool `xml:"toBeMerged" json:"toBeMerged,omitempty"`
	// Indicates whether the selected array elements, with the current
	// as one of them, replace the profile array in the target host
	// profile.
	ToReplaceWith *bool `xml:"toReplaceWith" json:"toReplaceWith,omitempty"`
	// Indicates whether this profile is marked as to-be-deleted.
	ToBeDeleted *bool `xml:"toBeDeleted" json:"toBeDeleted,omitempty"`
	// Indicates that the member variable <code>enabled</code> of this profile
	// will be copied from source profile to target profiles at host profile
	// composition.
	CopyEnableStatus *bool `xml:"copyEnableStatus" json:"copyEnableStatus,omitempty"`
	// Indicates whether this profile will be displayed or not.
	Hidden *bool `xml:"hidden" json:"hidden,omitempty"`
}

func init() {
	t["ApplyProfile"] = reflect.TypeOf((*ApplyProfile)(nil)).Elem()
}

type ApplyRecommendation ApplyRecommendationRequestType

func init() {
	t["ApplyRecommendation"] = reflect.TypeOf((*ApplyRecommendation)(nil)).Elem()
}

// The parameters of `ClusterComputeResource.ApplyRecommendation`.
type ApplyRecommendationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The key field of the DrsRecommendation or Recommendation.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["ApplyRecommendationRequestType"] = reflect.TypeOf((*ApplyRecommendationRequestType)(nil)).Elem()
}

type ApplyRecommendationResponse struct {
}

// The parameters of `StorageResourceManager.ApplyStorageDrsRecommendation_Task`.
type ApplyStorageDrsRecommendationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The key fields of the Recommendations that are applied.
	Key []string `xml:"key" json:"key"`
}

func init() {
	t["ApplyStorageDrsRecommendationRequestType"] = reflect.TypeOf((*ApplyStorageDrsRecommendationRequestType)(nil)).Elem()
}

// The parameters of `StorageResourceManager.ApplyStorageDrsRecommendationToPod_Task`.
type ApplyStorageDrsRecommendationToPodRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The storage pod.
	//
	// Refers instance of `StoragePod`.
	Pod ManagedObjectReference `xml:"pod" json:"pod"`
	// The key field of the Recommendation.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["ApplyStorageDrsRecommendationToPodRequestType"] = reflect.TypeOf((*ApplyStorageDrsRecommendationToPodRequestType)(nil)).Elem()
}

type ApplyStorageDrsRecommendationToPod_Task ApplyStorageDrsRecommendationToPodRequestType

func init() {
	t["ApplyStorageDrsRecommendationToPod_Task"] = reflect.TypeOf((*ApplyStorageDrsRecommendationToPod_Task)(nil)).Elem()
}

type ApplyStorageDrsRecommendationToPod_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ApplyStorageDrsRecommendation_Task ApplyStorageDrsRecommendationRequestType

func init() {
	t["ApplyStorageDrsRecommendation_Task"] = reflect.TypeOf((*ApplyStorageDrsRecommendation_Task)(nil)).Elem()
}

type ApplyStorageDrsRecommendation_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Both `StorageResourceManager.RecommendDatastores` and
// `Datastore.DatastoreEnterMaintenanceMode` methods may invoke Storage DRS
// for recommendations on placing or evacuating virtual disks.
//
// All initial placement recommendations, and some enterMaintenanceMode
// recommendations need to be approved by the user. Recommendations that
// are approved will be applied using the
// `StorageResourceManager.ApplyStorageDrsRecommendation_Task`
// method.
// This class encapsulates the result of applying a subset of the
// recommendations.
type ApplyStorageRecommendationResult struct {
	DynamicData

	// The result applying the recommendation, if it was successful.
	//
	// This is the equivalent of the `TaskInfo.result` key for the
	// task launched when the recommendation was applied.
	//
	// Refers instance of `VirtualMachine`.
	Vm *ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
}

func init() {
	t["ApplyStorageRecommendationResult"] = reflect.TypeOf((*ApplyStorageRecommendationResult)(nil)).Elem()
}

type AreAlarmActionsEnabled AreAlarmActionsEnabledRequestType

func init() {
	t["AreAlarmActionsEnabled"] = reflect.TypeOf((*AreAlarmActionsEnabled)(nil)).Elem()
}

// The parameters of `AlarmManager.AreAlarmActionsEnabled`.
type AreAlarmActionsEnabledRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The managed entity to look up.
	//
	// Required privileges: System.Read
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["AreAlarmActionsEnabledRequestType"] = reflect.TypeOf((*AreAlarmActionsEnabledRequestType)(nil)).Elem()
}

type AreAlarmActionsEnabledResponse struct {
	Returnval bool `xml:"returnval" json:"returnval"`
}

// A boxed array of `AlarmAction`. To be used in `Any` placeholders.
type ArrayOfAlarmAction struct {
	AlarmAction []BaseAlarmAction `xml:"AlarmAction,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfAlarmAction"] = reflect.TypeOf((*ArrayOfAlarmAction)(nil)).Elem()
}

// A boxed array of `AlarmExpression`. To be used in `Any` placeholders.
type ArrayOfAlarmExpression struct {
	AlarmExpression []BaseAlarmExpression `xml:"AlarmExpression,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfAlarmExpression"] = reflect.TypeOf((*ArrayOfAlarmExpression)(nil)).Elem()
}

// A boxed array of `AlarmState`. To be used in `Any` placeholders.
type ArrayOfAlarmState struct {
	AlarmState []AlarmState `xml:"AlarmState,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfAlarmState"] = reflect.TypeOf((*ArrayOfAlarmState)(nil)).Elem()
}

// A boxed array of `AlarmTriggeringActionTransitionSpec`. To be used in `Any` placeholders.
type ArrayOfAlarmTriggeringActionTransitionSpec struct {
	AlarmTriggeringActionTransitionSpec []AlarmTriggeringActionTransitionSpec `xml:"AlarmTriggeringActionTransitionSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfAlarmTriggeringActionTransitionSpec"] = reflect.TypeOf((*ArrayOfAlarmTriggeringActionTransitionSpec)(nil)).Elem()
}

// A boxed array of `AnswerFileStatusError`. To be used in `Any` placeholders.
type ArrayOfAnswerFileStatusError struct {
	AnswerFileStatusError []AnswerFileStatusError `xml:"AnswerFileStatusError,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfAnswerFileStatusError"] = reflect.TypeOf((*ArrayOfAnswerFileStatusError)(nil)).Elem()
}

// A boxed array of `AnswerFileStatusResult`. To be used in `Any` placeholders.
type ArrayOfAnswerFileStatusResult struct {
	AnswerFileStatusResult []AnswerFileStatusResult `xml:"AnswerFileStatusResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfAnswerFileStatusResult"] = reflect.TypeOf((*ArrayOfAnswerFileStatusResult)(nil)).Elem()
}

// A boxed array of `AnswerFileUpdateFailure`. To be used in `Any` placeholders.
type ArrayOfAnswerFileUpdateFailure struct {
	AnswerFileUpdateFailure []AnswerFileUpdateFailure `xml:"AnswerFileUpdateFailure,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfAnswerFileUpdateFailure"] = reflect.TypeOf((*ArrayOfAnswerFileUpdateFailure)(nil)).Elem()
}

// A boxed array of `Any`. To be used in `Any` placeholders.
type ArrayOfAnyType struct {
	AnyType []AnyType `xml:"anyType,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfAnyType"] = reflect.TypeOf((*ArrayOfAnyType)(nil)).Elem()
}

type ArrayOfAnyURI struct {
	AnyURI []string `xml:"anyURI,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfAnyURI"] = reflect.TypeOf((*ArrayOfAnyURI)(nil)).Elem()
}

// A boxed array of `ApplyHostProfileConfigurationResult`. To be used in `Any` placeholders.
type ArrayOfApplyHostProfileConfigurationResult struct {
	ApplyHostProfileConfigurationResult []ApplyHostProfileConfigurationResult `xml:"ApplyHostProfileConfigurationResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfApplyHostProfileConfigurationResult"] = reflect.TypeOf((*ArrayOfApplyHostProfileConfigurationResult)(nil)).Elem()
}

// A boxed array of `ApplyHostProfileConfigurationSpec`. To be used in `Any` placeholders.
type ArrayOfApplyHostProfileConfigurationSpec struct {
	ApplyHostProfileConfigurationSpec []ApplyHostProfileConfigurationSpec `xml:"ApplyHostProfileConfigurationSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfApplyHostProfileConfigurationSpec"] = reflect.TypeOf((*ArrayOfApplyHostProfileConfigurationSpec)(nil)).Elem()
}

// A boxed array of `ApplyProfile`. To be used in `Any` placeholders.
type ArrayOfApplyProfile struct {
	ApplyProfile []BaseApplyProfile `xml:"ApplyProfile,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfApplyProfile"] = reflect.TypeOf((*ArrayOfApplyProfile)(nil)).Elem()
}

// A boxed array of `AuthorizationPrivilege`. To be used in `Any` placeholders.
type ArrayOfAuthorizationPrivilege struct {
	AuthorizationPrivilege []AuthorizationPrivilege `xml:"AuthorizationPrivilege,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfAuthorizationPrivilege"] = reflect.TypeOf((*ArrayOfAuthorizationPrivilege)(nil)).Elem()
}

// A boxed array of `AuthorizationRole`. To be used in `Any` placeholders.
type ArrayOfAuthorizationRole struct {
	AuthorizationRole []AuthorizationRole `xml:"AuthorizationRole,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfAuthorizationRole"] = reflect.TypeOf((*ArrayOfAuthorizationRole)(nil)).Elem()
}

// A boxed array of `AutoStartPowerInfo`. To be used in `Any` placeholders.
type ArrayOfAutoStartPowerInfo struct {
	AutoStartPowerInfo []AutoStartPowerInfo `xml:"AutoStartPowerInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfAutoStartPowerInfo"] = reflect.TypeOf((*ArrayOfAutoStartPowerInfo)(nil)).Elem()
}

type ArrayOfBase64Binary struct {
	Base64Binary [][]byte `xml:"base64Binary,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfBase64Binary"] = reflect.TypeOf((*ArrayOfBase64Binary)(nil)).Elem()
}

// A boxed array of `PrimitiveBoolean`. To be used in `Any` placeholders.
type ArrayOfBoolean struct {
	Boolean []bool `xml:"boolean,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfBoolean"] = reflect.TypeOf((*ArrayOfBoolean)(nil)).Elem()
}

// A boxed array of `PrimitiveByte`. To be used in `Any` placeholders.
type ArrayOfByte struct {
	Byte ByteSlice `xml:"byte,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfByte"] = reflect.TypeOf((*ArrayOfByte)(nil)).Elem()
}

// A boxed array of `ChangesInfoEventArgument`. To be used in `Any` placeholders.
type ArrayOfChangesInfoEventArgument struct {
	ChangesInfoEventArgument []ChangesInfoEventArgument `xml:"ChangesInfoEventArgument,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfChangesInfoEventArgument"] = reflect.TypeOf((*ArrayOfChangesInfoEventArgument)(nil)).Elem()
}

// A boxed array of `CheckResult`. To be used in `Any` placeholders.
type ArrayOfCheckResult struct {
	CheckResult []CheckResult `xml:"CheckResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfCheckResult"] = reflect.TypeOf((*ArrayOfCheckResult)(nil)).Elem()
}

// A boxed array of `ClusterAction`. To be used in `Any` placeholders.
type ArrayOfClusterAction struct {
	ClusterAction []BaseClusterAction `xml:"ClusterAction,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfClusterAction"] = reflect.TypeOf((*ArrayOfClusterAction)(nil)).Elem()
}

// A boxed array of `ClusterActionHistory`. To be used in `Any` placeholders.
type ArrayOfClusterActionHistory struct {
	ClusterActionHistory []ClusterActionHistory `xml:"ClusterActionHistory,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterActionHistory"] = reflect.TypeOf((*ArrayOfClusterActionHistory)(nil)).Elem()
}

// A boxed array of `ClusterAttemptedVmInfo`. To be used in `Any` placeholders.
type ArrayOfClusterAttemptedVmInfo struct {
	ClusterAttemptedVmInfo []ClusterAttemptedVmInfo `xml:"ClusterAttemptedVmInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterAttemptedVmInfo"] = reflect.TypeOf((*ArrayOfClusterAttemptedVmInfo)(nil)).Elem()
}

// A boxed array of `ClusterComputeResourceDVSSetting`. To be used in `Any` placeholders.
type ArrayOfClusterComputeResourceDVSSetting struct {
	ClusterComputeResourceDVSSetting []ClusterComputeResourceDVSSetting `xml:"ClusterComputeResourceDVSSetting,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterComputeResourceDVSSetting"] = reflect.TypeOf((*ArrayOfClusterComputeResourceDVSSetting)(nil)).Elem()
}

// A boxed array of `ClusterComputeResourceDVSSettingDVPortgroupToServiceMapping`. To be used in `Any` placeholders.
type ArrayOfClusterComputeResourceDVSSettingDVPortgroupToServiceMapping struct {
	ClusterComputeResourceDVSSettingDVPortgroupToServiceMapping []ClusterComputeResourceDVSSettingDVPortgroupToServiceMapping `xml:"ClusterComputeResourceDVSSettingDVPortgroupToServiceMapping,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterComputeResourceDVSSettingDVPortgroupToServiceMapping"] = reflect.TypeOf((*ArrayOfClusterComputeResourceDVSSettingDVPortgroupToServiceMapping)(nil)).Elem()
}

// A boxed array of `ClusterComputeResourceDvsProfile`. To be used in `Any` placeholders.
type ArrayOfClusterComputeResourceDvsProfile struct {
	ClusterComputeResourceDvsProfile []ClusterComputeResourceDvsProfile `xml:"ClusterComputeResourceDvsProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterComputeResourceDvsProfile"] = reflect.TypeOf((*ArrayOfClusterComputeResourceDvsProfile)(nil)).Elem()
}

// A boxed array of `ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping`. To be used in `Any` placeholders.
type ArrayOfClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping struct {
	ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping []ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping `xml:"ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping"] = reflect.TypeOf((*ArrayOfClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping)(nil)).Elem()
}

// A boxed array of `ClusterComputeResourceHostConfigurationInput`. To be used in `Any` placeholders.
type ArrayOfClusterComputeResourceHostConfigurationInput struct {
	ClusterComputeResourceHostConfigurationInput []ClusterComputeResourceHostConfigurationInput `xml:"ClusterComputeResourceHostConfigurationInput,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterComputeResourceHostConfigurationInput"] = reflect.TypeOf((*ArrayOfClusterComputeResourceHostConfigurationInput)(nil)).Elem()
}

// A boxed array of `ClusterComputeResourceHostEvacuationInfo`. To be used in `Any` placeholders.
type ArrayOfClusterComputeResourceHostEvacuationInfo struct {
	ClusterComputeResourceHostEvacuationInfo []ClusterComputeResourceHostEvacuationInfo `xml:"ClusterComputeResourceHostEvacuationInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterComputeResourceHostEvacuationInfo"] = reflect.TypeOf((*ArrayOfClusterComputeResourceHostEvacuationInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfClusterComputeResourceHostEvacuationInfo"] = "8.0.3.0"
}

// A boxed array of `ClusterComputeResourceHostVmkNicInfo`. To be used in `Any` placeholders.
type ArrayOfClusterComputeResourceHostVmkNicInfo struct {
	ClusterComputeResourceHostVmkNicInfo []ClusterComputeResourceHostVmkNicInfo `xml:"ClusterComputeResourceHostVmkNicInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterComputeResourceHostVmkNicInfo"] = reflect.TypeOf((*ArrayOfClusterComputeResourceHostVmkNicInfo)(nil)).Elem()
}

// A boxed array of `ClusterComputeResourceValidationResultBase`. To be used in `Any` placeholders.
type ArrayOfClusterComputeResourceValidationResultBase struct {
	ClusterComputeResourceValidationResultBase []BaseClusterComputeResourceValidationResultBase `xml:"ClusterComputeResourceValidationResultBase,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfClusterComputeResourceValidationResultBase"] = reflect.TypeOf((*ArrayOfClusterComputeResourceValidationResultBase)(nil)).Elem()
}

// A boxed array of `ClusterComputeResourceVcsSlots`. To be used in `Any` placeholders.
type ArrayOfClusterComputeResourceVcsSlots struct {
	ClusterComputeResourceVcsSlots []ClusterComputeResourceVcsSlots `xml:"ClusterComputeResourceVcsSlots,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterComputeResourceVcsSlots"] = reflect.TypeOf((*ArrayOfClusterComputeResourceVcsSlots)(nil)).Elem()
	minAPIVersionForType["ArrayOfClusterComputeResourceVcsSlots"] = "7.0.1.1"
}

// A boxed array of `ClusterDasAamNodeState`. To be used in `Any` placeholders.
type ArrayOfClusterDasAamNodeState struct {
	ClusterDasAamNodeState []ClusterDasAamNodeState `xml:"ClusterDasAamNodeState,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterDasAamNodeState"] = reflect.TypeOf((*ArrayOfClusterDasAamNodeState)(nil)).Elem()
}

// A boxed array of `ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots`. To be used in `Any` placeholders.
type ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots struct {
	ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots []ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots `xml:"ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots"] = reflect.TypeOf((*ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots)(nil)).Elem()
}

// A boxed array of `ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots`. To be used in `Any` placeholders.
type ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots struct {
	ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots []ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots `xml:"ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots"] = reflect.TypeOf((*ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots)(nil)).Elem()
}

// A boxed array of `ClusterDasVmConfigInfo`. To be used in `Any` placeholders.
type ArrayOfClusterDasVmConfigInfo struct {
	ClusterDasVmConfigInfo []ClusterDasVmConfigInfo `xml:"ClusterDasVmConfigInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterDasVmConfigInfo"] = reflect.TypeOf((*ArrayOfClusterDasVmConfigInfo)(nil)).Elem()
}

// A boxed array of `ClusterDasVmConfigSpec`. To be used in `Any` placeholders.
type ArrayOfClusterDasVmConfigSpec struct {
	ClusterDasVmConfigSpec []ClusterDasVmConfigSpec `xml:"ClusterDasVmConfigSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterDasVmConfigSpec"] = reflect.TypeOf((*ArrayOfClusterDasVmConfigSpec)(nil)).Elem()
}

// A boxed array of `ClusterDatastoreUpdateSpec`. To be used in `Any` placeholders.
type ArrayOfClusterDatastoreUpdateSpec struct {
	ClusterDatastoreUpdateSpec []ClusterDatastoreUpdateSpec `xml:"ClusterDatastoreUpdateSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterDatastoreUpdateSpec"] = reflect.TypeOf((*ArrayOfClusterDatastoreUpdateSpec)(nil)).Elem()
	minAPIVersionForType["ArrayOfClusterDatastoreUpdateSpec"] = "7.0.3.0"
}

// A boxed array of `ClusterDpmHostConfigInfo`. To be used in `Any` placeholders.
type ArrayOfClusterDpmHostConfigInfo struct {
	ClusterDpmHostConfigInfo []ClusterDpmHostConfigInfo `xml:"ClusterDpmHostConfigInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterDpmHostConfigInfo"] = reflect.TypeOf((*ArrayOfClusterDpmHostConfigInfo)(nil)).Elem()
}

// A boxed array of `ClusterDpmHostConfigSpec`. To be used in `Any` placeholders.
type ArrayOfClusterDpmHostConfigSpec struct {
	ClusterDpmHostConfigSpec []ClusterDpmHostConfigSpec `xml:"ClusterDpmHostConfigSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterDpmHostConfigSpec"] = reflect.TypeOf((*ArrayOfClusterDpmHostConfigSpec)(nil)).Elem()
}

// A boxed array of `ClusterDrsFaults`. To be used in `Any` placeholders.
type ArrayOfClusterDrsFaults struct {
	ClusterDrsFaults []ClusterDrsFaults `xml:"ClusterDrsFaults,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterDrsFaults"] = reflect.TypeOf((*ArrayOfClusterDrsFaults)(nil)).Elem()
}

// A boxed array of `ClusterDrsFaultsFaultsByVm`. To be used in `Any` placeholders.
type ArrayOfClusterDrsFaultsFaultsByVm struct {
	ClusterDrsFaultsFaultsByVm []BaseClusterDrsFaultsFaultsByVm `xml:"ClusterDrsFaultsFaultsByVm,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfClusterDrsFaultsFaultsByVm"] = reflect.TypeOf((*ArrayOfClusterDrsFaultsFaultsByVm)(nil)).Elem()
}

// A boxed array of `ClusterDrsMigration`. To be used in `Any` placeholders.
type ArrayOfClusterDrsMigration struct {
	ClusterDrsMigration []ClusterDrsMigration `xml:"ClusterDrsMigration,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterDrsMigration"] = reflect.TypeOf((*ArrayOfClusterDrsMigration)(nil)).Elem()
}

// A boxed array of `ClusterDrsRecommendation`. To be used in `Any` placeholders.
type ArrayOfClusterDrsRecommendation struct {
	ClusterDrsRecommendation []ClusterDrsRecommendation `xml:"ClusterDrsRecommendation,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterDrsRecommendation"] = reflect.TypeOf((*ArrayOfClusterDrsRecommendation)(nil)).Elem()
}

// A boxed array of `ClusterDrsVmConfigInfo`. To be used in `Any` placeholders.
type ArrayOfClusterDrsVmConfigInfo struct {
	ClusterDrsVmConfigInfo []ClusterDrsVmConfigInfo `xml:"ClusterDrsVmConfigInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterDrsVmConfigInfo"] = reflect.TypeOf((*ArrayOfClusterDrsVmConfigInfo)(nil)).Elem()
}

// A boxed array of `ClusterDrsVmConfigSpec`. To be used in `Any` placeholders.
type ArrayOfClusterDrsVmConfigSpec struct {
	ClusterDrsVmConfigSpec []ClusterDrsVmConfigSpec `xml:"ClusterDrsVmConfigSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterDrsVmConfigSpec"] = reflect.TypeOf((*ArrayOfClusterDrsVmConfigSpec)(nil)).Elem()
}

// A boxed array of `ClusterEVCManagerCheckResult`. To be used in `Any` placeholders.
type ArrayOfClusterEVCManagerCheckResult struct {
	ClusterEVCManagerCheckResult []ClusterEVCManagerCheckResult `xml:"ClusterEVCManagerCheckResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterEVCManagerCheckResult"] = reflect.TypeOf((*ArrayOfClusterEVCManagerCheckResult)(nil)).Elem()
}

// A boxed array of `ClusterFailoverHostAdmissionControlInfoHostStatus`. To be used in `Any` placeholders.
type ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus struct {
	ClusterFailoverHostAdmissionControlInfoHostStatus []ClusterFailoverHostAdmissionControlInfoHostStatus `xml:"ClusterFailoverHostAdmissionControlInfoHostStatus,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus"] = reflect.TypeOf((*ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus)(nil)).Elem()
}

// A boxed array of `ClusterGroupInfo`. To be used in `Any` placeholders.
type ArrayOfClusterGroupInfo struct {
	ClusterGroupInfo []BaseClusterGroupInfo `xml:"ClusterGroupInfo,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfClusterGroupInfo"] = reflect.TypeOf((*ArrayOfClusterGroupInfo)(nil)).Elem()
}

// A boxed array of `ClusterGroupSpec`. To be used in `Any` placeholders.
type ArrayOfClusterGroupSpec struct {
	ClusterGroupSpec []ClusterGroupSpec `xml:"ClusterGroupSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterGroupSpec"] = reflect.TypeOf((*ArrayOfClusterGroupSpec)(nil)).Elem()
}

// A boxed array of `ClusterHostRecommendation`. To be used in `Any` placeholders.
type ArrayOfClusterHostRecommendation struct {
	ClusterHostRecommendation []ClusterHostRecommendation `xml:"ClusterHostRecommendation,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterHostRecommendation"] = reflect.TypeOf((*ArrayOfClusterHostRecommendation)(nil)).Elem()
}

// A boxed array of `ClusterIoFilterInfo`. To be used in `Any` placeholders.
type ArrayOfClusterIoFilterInfo struct {
	ClusterIoFilterInfo []ClusterIoFilterInfo `xml:"ClusterIoFilterInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterIoFilterInfo"] = reflect.TypeOf((*ArrayOfClusterIoFilterInfo)(nil)).Elem()
}

// A boxed array of `ClusterNotAttemptedVmInfo`. To be used in `Any` placeholders.
type ArrayOfClusterNotAttemptedVmInfo struct {
	ClusterNotAttemptedVmInfo []ClusterNotAttemptedVmInfo `xml:"ClusterNotAttemptedVmInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterNotAttemptedVmInfo"] = reflect.TypeOf((*ArrayOfClusterNotAttemptedVmInfo)(nil)).Elem()
}

// A boxed array of `ClusterRecommendation`. To be used in `Any` placeholders.
type ArrayOfClusterRecommendation struct {
	ClusterRecommendation []ClusterRecommendation `xml:"ClusterRecommendation,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterRecommendation"] = reflect.TypeOf((*ArrayOfClusterRecommendation)(nil)).Elem()
}

// A boxed array of `ClusterRuleInfo`. To be used in `Any` placeholders.
type ArrayOfClusterRuleInfo struct {
	ClusterRuleInfo []BaseClusterRuleInfo `xml:"ClusterRuleInfo,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfClusterRuleInfo"] = reflect.TypeOf((*ArrayOfClusterRuleInfo)(nil)).Elem()
}

// A boxed array of `ClusterRuleSpec`. To be used in `Any` placeholders.
type ArrayOfClusterRuleSpec struct {
	ClusterRuleSpec []ClusterRuleSpec `xml:"ClusterRuleSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterRuleSpec"] = reflect.TypeOf((*ArrayOfClusterRuleSpec)(nil)).Elem()
}

// A boxed array of `ClusterTagCategoryUpdateSpec`. To be used in `Any` placeholders.
type ArrayOfClusterTagCategoryUpdateSpec struct {
	ClusterTagCategoryUpdateSpec []ClusterTagCategoryUpdateSpec `xml:"ClusterTagCategoryUpdateSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterTagCategoryUpdateSpec"] = reflect.TypeOf((*ArrayOfClusterTagCategoryUpdateSpec)(nil)).Elem()
	minAPIVersionForType["ArrayOfClusterTagCategoryUpdateSpec"] = "7.0.3.0"
}

// A boxed array of `ClusterVmOrchestrationInfo`. To be used in `Any` placeholders.
type ArrayOfClusterVmOrchestrationInfo struct {
	ClusterVmOrchestrationInfo []ClusterVmOrchestrationInfo `xml:"ClusterVmOrchestrationInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterVmOrchestrationInfo"] = reflect.TypeOf((*ArrayOfClusterVmOrchestrationInfo)(nil)).Elem()
}

// A boxed array of `ClusterVmOrchestrationSpec`. To be used in `Any` placeholders.
type ArrayOfClusterVmOrchestrationSpec struct {
	ClusterVmOrchestrationSpec []ClusterVmOrchestrationSpec `xml:"ClusterVmOrchestrationSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfClusterVmOrchestrationSpec"] = reflect.TypeOf((*ArrayOfClusterVmOrchestrationSpec)(nil)).Elem()
}

// A boxed array of `ComplianceFailure`. To be used in `Any` placeholders.
type ArrayOfComplianceFailure struct {
	ComplianceFailure []ComplianceFailure `xml:"ComplianceFailure,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfComplianceFailure"] = reflect.TypeOf((*ArrayOfComplianceFailure)(nil)).Elem()
}

// A boxed array of `ComplianceFailureComplianceFailureValues`. To be used in `Any` placeholders.
type ArrayOfComplianceFailureComplianceFailureValues struct {
	ComplianceFailureComplianceFailureValues []ComplianceFailureComplianceFailureValues `xml:"ComplianceFailureComplianceFailureValues,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfComplianceFailureComplianceFailureValues"] = reflect.TypeOf((*ArrayOfComplianceFailureComplianceFailureValues)(nil)).Elem()
}

// A boxed array of `ComplianceLocator`. To be used in `Any` placeholders.
type ArrayOfComplianceLocator struct {
	ComplianceLocator []ComplianceLocator `xml:"ComplianceLocator,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfComplianceLocator"] = reflect.TypeOf((*ArrayOfComplianceLocator)(nil)).Elem()
}

// A boxed array of `ComplianceResult`. To be used in `Any` placeholders.
type ArrayOfComplianceResult struct {
	ComplianceResult []ComplianceResult `xml:"ComplianceResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfComplianceResult"] = reflect.TypeOf((*ArrayOfComplianceResult)(nil)).Elem()
}

// A boxed array of `ComputeResourceHostSPBMLicenseInfo`. To be used in `Any` placeholders.
type ArrayOfComputeResourceHostSPBMLicenseInfo struct {
	ComputeResourceHostSPBMLicenseInfo []ComputeResourceHostSPBMLicenseInfo `xml:"ComputeResourceHostSPBMLicenseInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfComputeResourceHostSPBMLicenseInfo"] = reflect.TypeOf((*ArrayOfComputeResourceHostSPBMLicenseInfo)(nil)).Elem()
}

// A boxed array of `ConflictingConfigurationConfig`. To be used in `Any` placeholders.
type ArrayOfConflictingConfigurationConfig struct {
	ConflictingConfigurationConfig []ConflictingConfigurationConfig `xml:"ConflictingConfigurationConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfConflictingConfigurationConfig"] = reflect.TypeOf((*ArrayOfConflictingConfigurationConfig)(nil)).Elem()
}

// A boxed array of `CryptoKeyId`. To be used in `Any` placeholders.
type ArrayOfCryptoKeyId struct {
	CryptoKeyId []CryptoKeyId `xml:"CryptoKeyId,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfCryptoKeyId"] = reflect.TypeOf((*ArrayOfCryptoKeyId)(nil)).Elem()
}

// A boxed array of `CryptoKeyPlain`. To be used in `Any` placeholders.
type ArrayOfCryptoKeyPlain struct {
	CryptoKeyPlain []CryptoKeyPlain `xml:"CryptoKeyPlain,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfCryptoKeyPlain"] = reflect.TypeOf((*ArrayOfCryptoKeyPlain)(nil)).Elem()
}

// A boxed array of `CryptoKeyResult`. To be used in `Any` placeholders.
type ArrayOfCryptoKeyResult struct {
	CryptoKeyResult []CryptoKeyResult `xml:"CryptoKeyResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfCryptoKeyResult"] = reflect.TypeOf((*ArrayOfCryptoKeyResult)(nil)).Elem()
}

// A boxed array of `CryptoManagerHostKeyStatus`. To be used in `Any` placeholders.
type ArrayOfCryptoManagerHostKeyStatus struct {
	CryptoManagerHostKeyStatus []CryptoManagerHostKeyStatus `xml:"CryptoManagerHostKeyStatus,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfCryptoManagerHostKeyStatus"] = reflect.TypeOf((*ArrayOfCryptoManagerHostKeyStatus)(nil)).Elem()
	minAPIVersionForType["ArrayOfCryptoManagerHostKeyStatus"] = "8.0.1.0"
}

// A boxed array of `CryptoManagerKmipClusterStatus`. To be used in `Any` placeholders.
type ArrayOfCryptoManagerKmipClusterStatus struct {
	CryptoManagerKmipClusterStatus []CryptoManagerKmipClusterStatus `xml:"CryptoManagerKmipClusterStatus,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfCryptoManagerKmipClusterStatus"] = reflect.TypeOf((*ArrayOfCryptoManagerKmipClusterStatus)(nil)).Elem()
}

// A boxed array of `CryptoManagerKmipCryptoKeyStatus`. To be used in `Any` placeholders.
type ArrayOfCryptoManagerKmipCryptoKeyStatus struct {
	CryptoManagerKmipCryptoKeyStatus []CryptoManagerKmipCryptoKeyStatus `xml:"CryptoManagerKmipCryptoKeyStatus,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfCryptoManagerKmipCryptoKeyStatus"] = reflect.TypeOf((*ArrayOfCryptoManagerKmipCryptoKeyStatus)(nil)).Elem()
}

// A boxed array of `CryptoManagerKmipServerStatus`. To be used in `Any` placeholders.
type ArrayOfCryptoManagerKmipServerStatus struct {
	CryptoManagerKmipServerStatus []CryptoManagerKmipServerStatus `xml:"CryptoManagerKmipServerStatus,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfCryptoManagerKmipServerStatus"] = reflect.TypeOf((*ArrayOfCryptoManagerKmipServerStatus)(nil)).Elem()
}

// A boxed array of `CustomFieldDef`. To be used in `Any` placeholders.
type ArrayOfCustomFieldDef struct {
	CustomFieldDef []CustomFieldDef `xml:"CustomFieldDef,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfCustomFieldDef"] = reflect.TypeOf((*ArrayOfCustomFieldDef)(nil)).Elem()
}

// A boxed array of `CustomFieldValue`. To be used in `Any` placeholders.
type ArrayOfCustomFieldValue struct {
	CustomFieldValue []BaseCustomFieldValue `xml:"CustomFieldValue,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfCustomFieldValue"] = reflect.TypeOf((*ArrayOfCustomFieldValue)(nil)).Elem()
}

// A boxed array of `CustomizationAdapterMapping`. To be used in `Any` placeholders.
type ArrayOfCustomizationAdapterMapping struct {
	CustomizationAdapterMapping []CustomizationAdapterMapping `xml:"CustomizationAdapterMapping,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfCustomizationAdapterMapping"] = reflect.TypeOf((*ArrayOfCustomizationAdapterMapping)(nil)).Elem()
}

// A boxed array of `CustomizationIpV6Generator`. To be used in `Any` placeholders.
type ArrayOfCustomizationIpV6Generator struct {
	CustomizationIpV6Generator []BaseCustomizationIpV6Generator `xml:"CustomizationIpV6Generator,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfCustomizationIpV6Generator"] = reflect.TypeOf((*ArrayOfCustomizationIpV6Generator)(nil)).Elem()
}

// A boxed array of `CustomizationSpecInfo`. To be used in `Any` placeholders.
type ArrayOfCustomizationSpecInfo struct {
	CustomizationSpecInfo []CustomizationSpecInfo `xml:"CustomizationSpecInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfCustomizationSpecInfo"] = reflect.TypeOf((*ArrayOfCustomizationSpecInfo)(nil)).Elem()
}

// A boxed array of `DVPortConfigSpec`. To be used in `Any` placeholders.
type ArrayOfDVPortConfigSpec struct {
	DVPortConfigSpec []DVPortConfigSpec `xml:"DVPortConfigSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDVPortConfigSpec"] = reflect.TypeOf((*ArrayOfDVPortConfigSpec)(nil)).Elem()
}

// A boxed array of `DVPortgroupConfigSpec`. To be used in `Any` placeholders.
type ArrayOfDVPortgroupConfigSpec struct {
	DVPortgroupConfigSpec []DVPortgroupConfigSpec `xml:"DVPortgroupConfigSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDVPortgroupConfigSpec"] = reflect.TypeOf((*ArrayOfDVPortgroupConfigSpec)(nil)).Elem()
}

// A boxed array of `DVSHealthCheckConfig`. To be used in `Any` placeholders.
type ArrayOfDVSHealthCheckConfig struct {
	DVSHealthCheckConfig []BaseDVSHealthCheckConfig `xml:"DVSHealthCheckConfig,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfDVSHealthCheckConfig"] = reflect.TypeOf((*ArrayOfDVSHealthCheckConfig)(nil)).Elem()
}

// A boxed array of `DVSManagerPhysicalNicsList`. To be used in `Any` placeholders.
type ArrayOfDVSManagerPhysicalNicsList struct {
	DVSManagerPhysicalNicsList []DVSManagerPhysicalNicsList `xml:"DVSManagerPhysicalNicsList,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDVSManagerPhysicalNicsList"] = reflect.TypeOf((*ArrayOfDVSManagerPhysicalNicsList)(nil)).Elem()
	minAPIVersionForType["ArrayOfDVSManagerPhysicalNicsList"] = "8.0.0.1"
}

// A boxed array of `DVSNetworkResourcePool`. To be used in `Any` placeholders.
type ArrayOfDVSNetworkResourcePool struct {
	DVSNetworkResourcePool []DVSNetworkResourcePool `xml:"DVSNetworkResourcePool,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDVSNetworkResourcePool"] = reflect.TypeOf((*ArrayOfDVSNetworkResourcePool)(nil)).Elem()
}

// A boxed array of `DVSNetworkResourcePoolConfigSpec`. To be used in `Any` placeholders.
type ArrayOfDVSNetworkResourcePoolConfigSpec struct {
	DVSNetworkResourcePoolConfigSpec []DVSNetworkResourcePoolConfigSpec `xml:"DVSNetworkResourcePoolConfigSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDVSNetworkResourcePoolConfigSpec"] = reflect.TypeOf((*ArrayOfDVSNetworkResourcePoolConfigSpec)(nil)).Elem()
}

// A boxed array of `DVSVmVnicNetworkResourcePool`. To be used in `Any` placeholders.
type ArrayOfDVSVmVnicNetworkResourcePool struct {
	DVSVmVnicNetworkResourcePool []DVSVmVnicNetworkResourcePool `xml:"DVSVmVnicNetworkResourcePool,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDVSVmVnicNetworkResourcePool"] = reflect.TypeOf((*ArrayOfDVSVmVnicNetworkResourcePool)(nil)).Elem()
}

// A boxed array of `DasHeartbeatDatastoreInfo`. To be used in `Any` placeholders.
type ArrayOfDasHeartbeatDatastoreInfo struct {
	DasHeartbeatDatastoreInfo []DasHeartbeatDatastoreInfo `xml:"DasHeartbeatDatastoreInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDasHeartbeatDatastoreInfo"] = reflect.TypeOf((*ArrayOfDasHeartbeatDatastoreInfo)(nil)).Elem()
}

// A boxed array of `DatacenterBasicConnectInfo`. To be used in `Any` placeholders.
type ArrayOfDatacenterBasicConnectInfo struct {
	DatacenterBasicConnectInfo []DatacenterBasicConnectInfo `xml:"DatacenterBasicConnectInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDatacenterBasicConnectInfo"] = reflect.TypeOf((*ArrayOfDatacenterBasicConnectInfo)(nil)).Elem()
}

// A boxed array of `DatacenterMismatchArgument`. To be used in `Any` placeholders.
type ArrayOfDatacenterMismatchArgument struct {
	DatacenterMismatchArgument []DatacenterMismatchArgument `xml:"DatacenterMismatchArgument,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDatacenterMismatchArgument"] = reflect.TypeOf((*ArrayOfDatacenterMismatchArgument)(nil)).Elem()
}

// A boxed array of `DatastoreHostMount`. To be used in `Any` placeholders.
type ArrayOfDatastoreHostMount struct {
	DatastoreHostMount []DatastoreHostMount `xml:"DatastoreHostMount,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDatastoreHostMount"] = reflect.TypeOf((*ArrayOfDatastoreHostMount)(nil)).Elem()
}

// A boxed array of `DatastoreMountPathDatastorePair`. To be used in `Any` placeholders.
type ArrayOfDatastoreMountPathDatastorePair struct {
	DatastoreMountPathDatastorePair []DatastoreMountPathDatastorePair `xml:"DatastoreMountPathDatastorePair,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDatastoreMountPathDatastorePair"] = reflect.TypeOf((*ArrayOfDatastoreMountPathDatastorePair)(nil)).Elem()
}

// A boxed array of `DatastoreVVolContainerFailoverPair`. To be used in `Any` placeholders.
type ArrayOfDatastoreVVolContainerFailoverPair struct {
	DatastoreVVolContainerFailoverPair []DatastoreVVolContainerFailoverPair `xml:"DatastoreVVolContainerFailoverPair,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDatastoreVVolContainerFailoverPair"] = reflect.TypeOf((*ArrayOfDatastoreVVolContainerFailoverPair)(nil)).Elem()
}

// A boxed array of `DesiredSoftwareSpecComponentSpec`. To be used in `Any` placeholders.
type ArrayOfDesiredSoftwareSpecComponentSpec struct {
	DesiredSoftwareSpecComponentSpec []DesiredSoftwareSpecComponentSpec `xml:"DesiredSoftwareSpecComponentSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDesiredSoftwareSpecComponentSpec"] = reflect.TypeOf((*ArrayOfDesiredSoftwareSpecComponentSpec)(nil)).Elem()
	minAPIVersionForType["ArrayOfDesiredSoftwareSpecComponentSpec"] = "7.0.2.0"
}

// A boxed array of `DiagnosticManagerBundleInfo`. To be used in `Any` placeholders.
type ArrayOfDiagnosticManagerBundleInfo struct {
	DiagnosticManagerBundleInfo []DiagnosticManagerBundleInfo `xml:"DiagnosticManagerBundleInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDiagnosticManagerBundleInfo"] = reflect.TypeOf((*ArrayOfDiagnosticManagerBundleInfo)(nil)).Elem()
}

// A boxed array of `DiagnosticManagerLogDescriptor`. To be used in `Any` placeholders.
type ArrayOfDiagnosticManagerLogDescriptor struct {
	DiagnosticManagerLogDescriptor []DiagnosticManagerLogDescriptor `xml:"DiagnosticManagerLogDescriptor,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDiagnosticManagerLogDescriptor"] = reflect.TypeOf((*ArrayOfDiagnosticManagerLogDescriptor)(nil)).Elem()
}

// A boxed array of `DiskChangeExtent`. To be used in `Any` placeholders.
type ArrayOfDiskChangeExtent struct {
	DiskChangeExtent []DiskChangeExtent `xml:"DiskChangeExtent,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDiskChangeExtent"] = reflect.TypeOf((*ArrayOfDiskChangeExtent)(nil)).Elem()
}

// A boxed array of `DistributedVirtualPort`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualPort struct {
	DistributedVirtualPort []DistributedVirtualPort `xml:"DistributedVirtualPort,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualPort"] = reflect.TypeOf((*ArrayOfDistributedVirtualPort)(nil)).Elem()
}

// A boxed array of `DistributedVirtualPortgroupInfo`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualPortgroupInfo struct {
	DistributedVirtualPortgroupInfo []DistributedVirtualPortgroupInfo `xml:"DistributedVirtualPortgroupInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualPortgroupInfo"] = reflect.TypeOf((*ArrayOfDistributedVirtualPortgroupInfo)(nil)).Elem()
}

// A boxed array of `DistributedVirtualPortgroupProblem`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualPortgroupProblem struct {
	DistributedVirtualPortgroupProblem []DistributedVirtualPortgroupProblem `xml:"DistributedVirtualPortgroupProblem,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualPortgroupProblem"] = reflect.TypeOf((*ArrayOfDistributedVirtualPortgroupProblem)(nil)).Elem()
}

// A boxed array of `DistributedVirtualSwitchHostMember`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualSwitchHostMember struct {
	DistributedVirtualSwitchHostMember []DistributedVirtualSwitchHostMember `xml:"DistributedVirtualSwitchHostMember,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualSwitchHostMember"] = reflect.TypeOf((*ArrayOfDistributedVirtualSwitchHostMember)(nil)).Elem()
}

// A boxed array of `DistributedVirtualSwitchHostMemberConfigSpec`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualSwitchHostMemberConfigSpec struct {
	DistributedVirtualSwitchHostMemberConfigSpec []DistributedVirtualSwitchHostMemberConfigSpec `xml:"DistributedVirtualSwitchHostMemberConfigSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualSwitchHostMemberConfigSpec"] = reflect.TypeOf((*ArrayOfDistributedVirtualSwitchHostMemberConfigSpec)(nil)).Elem()
}

// A boxed array of `DistributedVirtualSwitchHostMemberHostUplinkState`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualSwitchHostMemberHostUplinkState struct {
	DistributedVirtualSwitchHostMemberHostUplinkState []DistributedVirtualSwitchHostMemberHostUplinkState `xml:"DistributedVirtualSwitchHostMemberHostUplinkState,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualSwitchHostMemberHostUplinkState"] = reflect.TypeOf((*ArrayOfDistributedVirtualSwitchHostMemberHostUplinkState)(nil)).Elem()
	minAPIVersionForType["ArrayOfDistributedVirtualSwitchHostMemberHostUplinkState"] = "8.0.3.0"
}

// A boxed array of `DistributedVirtualSwitchHostMemberPnicSpec`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualSwitchHostMemberPnicSpec struct {
	DistributedVirtualSwitchHostMemberPnicSpec []DistributedVirtualSwitchHostMemberPnicSpec `xml:"DistributedVirtualSwitchHostMemberPnicSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualSwitchHostMemberPnicSpec"] = reflect.TypeOf((*ArrayOfDistributedVirtualSwitchHostMemberPnicSpec)(nil)).Elem()
}

// A boxed array of `DistributedVirtualSwitchHostMemberTransportZoneInfo`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualSwitchHostMemberTransportZoneInfo struct {
	DistributedVirtualSwitchHostMemberTransportZoneInfo []DistributedVirtualSwitchHostMemberTransportZoneInfo `xml:"DistributedVirtualSwitchHostMemberTransportZoneInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualSwitchHostMemberTransportZoneInfo"] = reflect.TypeOf((*ArrayOfDistributedVirtualSwitchHostMemberTransportZoneInfo)(nil)).Elem()
}

// A boxed array of `DistributedVirtualSwitchHostProductSpec`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualSwitchHostProductSpec struct {
	DistributedVirtualSwitchHostProductSpec []DistributedVirtualSwitchHostProductSpec `xml:"DistributedVirtualSwitchHostProductSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualSwitchHostProductSpec"] = reflect.TypeOf((*ArrayOfDistributedVirtualSwitchHostProductSpec)(nil)).Elem()
}

// A boxed array of `DistributedVirtualSwitchInfo`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualSwitchInfo struct {
	DistributedVirtualSwitchInfo []DistributedVirtualSwitchInfo `xml:"DistributedVirtualSwitchInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualSwitchInfo"] = reflect.TypeOf((*ArrayOfDistributedVirtualSwitchInfo)(nil)).Elem()
}

// A boxed array of `DistributedVirtualSwitchKeyedOpaqueBlob`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob struct {
	DistributedVirtualSwitchKeyedOpaqueBlob []DistributedVirtualSwitchKeyedOpaqueBlob `xml:"DistributedVirtualSwitchKeyedOpaqueBlob,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob"] = reflect.TypeOf((*ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob)(nil)).Elem()
}

// A boxed array of `DistributedVirtualSwitchManagerCompatibilityResult`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualSwitchManagerCompatibilityResult struct {
	DistributedVirtualSwitchManagerCompatibilityResult []DistributedVirtualSwitchManagerCompatibilityResult `xml:"DistributedVirtualSwitchManagerCompatibilityResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualSwitchManagerCompatibilityResult"] = reflect.TypeOf((*ArrayOfDistributedVirtualSwitchManagerCompatibilityResult)(nil)).Elem()
}

// A boxed array of `DistributedVirtualSwitchManagerHostDvsFilterSpec`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec struct {
	DistributedVirtualSwitchManagerHostDvsFilterSpec []BaseDistributedVirtualSwitchManagerHostDvsFilterSpec `xml:"DistributedVirtualSwitchManagerHostDvsFilterSpec,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec"] = reflect.TypeOf((*ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec)(nil)).Elem()
}

// A boxed array of `DistributedVirtualSwitchNetworkOffloadSpec`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualSwitchNetworkOffloadSpec struct {
	DistributedVirtualSwitchNetworkOffloadSpec []DistributedVirtualSwitchNetworkOffloadSpec `xml:"DistributedVirtualSwitchNetworkOffloadSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualSwitchNetworkOffloadSpec"] = reflect.TypeOf((*ArrayOfDistributedVirtualSwitchNetworkOffloadSpec)(nil)).Elem()
	minAPIVersionForType["ArrayOfDistributedVirtualSwitchNetworkOffloadSpec"] = "8.0.0.1"
}

// A boxed array of `DistributedVirtualSwitchProductSpec`. To be used in `Any` placeholders.
type ArrayOfDistributedVirtualSwitchProductSpec struct {
	DistributedVirtualSwitchProductSpec []DistributedVirtualSwitchProductSpec `xml:"DistributedVirtualSwitchProductSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDistributedVirtualSwitchProductSpec"] = reflect.TypeOf((*ArrayOfDistributedVirtualSwitchProductSpec)(nil)).Elem()
}

// A boxed array of `PrimitiveDouble`. To be used in `Any` placeholders.
type ArrayOfDouble struct {
	Double []float64 `xml:"double,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDouble"] = reflect.TypeOf((*ArrayOfDouble)(nil)).Elem()
}

// A boxed array of `DpuStatusInfo`. To be used in `Any` placeholders.
type ArrayOfDpuStatusInfo struct {
	DpuStatusInfo []DpuStatusInfo `xml:"DpuStatusInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDpuStatusInfo"] = reflect.TypeOf((*ArrayOfDpuStatusInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfDpuStatusInfo"] = "8.0.0.1"
}

// A boxed array of `DpuStatusInfoOperationalInfo`. To be used in `Any` placeholders.
type ArrayOfDpuStatusInfoOperationalInfo struct {
	DpuStatusInfoOperationalInfo []DpuStatusInfoOperationalInfo `xml:"DpuStatusInfoOperationalInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDpuStatusInfoOperationalInfo"] = reflect.TypeOf((*ArrayOfDpuStatusInfoOperationalInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfDpuStatusInfoOperationalInfo"] = "8.0.0.1"
}

// A boxed array of `DvsApplyOperationFaultFaultOnObject`. To be used in `Any` placeholders.
type ArrayOfDvsApplyOperationFaultFaultOnObject struct {
	DvsApplyOperationFaultFaultOnObject []DvsApplyOperationFaultFaultOnObject `xml:"DvsApplyOperationFaultFaultOnObject,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDvsApplyOperationFaultFaultOnObject"] = reflect.TypeOf((*ArrayOfDvsApplyOperationFaultFaultOnObject)(nil)).Elem()
}

// A boxed array of `DvsFilterConfig`. To be used in `Any` placeholders.
type ArrayOfDvsFilterConfig struct {
	DvsFilterConfig []BaseDvsFilterConfig `xml:"DvsFilterConfig,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfDvsFilterConfig"] = reflect.TypeOf((*ArrayOfDvsFilterConfig)(nil)).Elem()
}

// A boxed array of `DvsHostInfrastructureTrafficResource`. To be used in `Any` placeholders.
type ArrayOfDvsHostInfrastructureTrafficResource struct {
	DvsHostInfrastructureTrafficResource []DvsHostInfrastructureTrafficResource `xml:"DvsHostInfrastructureTrafficResource,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDvsHostInfrastructureTrafficResource"] = reflect.TypeOf((*ArrayOfDvsHostInfrastructureTrafficResource)(nil)).Elem()
}

// A boxed array of `DvsHostVNicProfile`. To be used in `Any` placeholders.
type ArrayOfDvsHostVNicProfile struct {
	DvsHostVNicProfile []DvsHostVNicProfile `xml:"DvsHostVNicProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDvsHostVNicProfile"] = reflect.TypeOf((*ArrayOfDvsHostVNicProfile)(nil)).Elem()
}

// A boxed array of `DvsNetworkRuleQualifier`. To be used in `Any` placeholders.
type ArrayOfDvsNetworkRuleQualifier struct {
	DvsNetworkRuleQualifier []BaseDvsNetworkRuleQualifier `xml:"DvsNetworkRuleQualifier,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfDvsNetworkRuleQualifier"] = reflect.TypeOf((*ArrayOfDvsNetworkRuleQualifier)(nil)).Elem()
}

// A boxed array of `DvsOperationBulkFaultFaultOnHost`. To be used in `Any` placeholders.
type ArrayOfDvsOperationBulkFaultFaultOnHost struct {
	DvsOperationBulkFaultFaultOnHost []DvsOperationBulkFaultFaultOnHost `xml:"DvsOperationBulkFaultFaultOnHost,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDvsOperationBulkFaultFaultOnHost"] = reflect.TypeOf((*ArrayOfDvsOperationBulkFaultFaultOnHost)(nil)).Elem()
}

// A boxed array of `DvsOutOfSyncHostArgument`. To be used in `Any` placeholders.
type ArrayOfDvsOutOfSyncHostArgument struct {
	DvsOutOfSyncHostArgument []DvsOutOfSyncHostArgument `xml:"DvsOutOfSyncHostArgument,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDvsOutOfSyncHostArgument"] = reflect.TypeOf((*ArrayOfDvsOutOfSyncHostArgument)(nil)).Elem()
}

// A boxed array of `DvsProfile`. To be used in `Any` placeholders.
type ArrayOfDvsProfile struct {
	DvsProfile []DvsProfile `xml:"DvsProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDvsProfile"] = reflect.TypeOf((*ArrayOfDvsProfile)(nil)).Elem()
}

// A boxed array of `DvsServiceConsoleVNicProfile`. To be used in `Any` placeholders.
type ArrayOfDvsServiceConsoleVNicProfile struct {
	DvsServiceConsoleVNicProfile []DvsServiceConsoleVNicProfile `xml:"DvsServiceConsoleVNicProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDvsServiceConsoleVNicProfile"] = reflect.TypeOf((*ArrayOfDvsServiceConsoleVNicProfile)(nil)).Elem()
}

// A boxed array of `DvsTrafficRule`. To be used in `Any` placeholders.
type ArrayOfDvsTrafficRule struct {
	DvsTrafficRule []DvsTrafficRule `xml:"DvsTrafficRule,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDvsTrafficRule"] = reflect.TypeOf((*ArrayOfDvsTrafficRule)(nil)).Elem()
}

// A boxed array of `DvsVmVnicNetworkResourcePoolRuntimeInfo`. To be used in `Any` placeholders.
type ArrayOfDvsVmVnicNetworkResourcePoolRuntimeInfo struct {
	DvsVmVnicNetworkResourcePoolRuntimeInfo []DvsVmVnicNetworkResourcePoolRuntimeInfo `xml:"DvsVmVnicNetworkResourcePoolRuntimeInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDvsVmVnicNetworkResourcePoolRuntimeInfo"] = reflect.TypeOf((*ArrayOfDvsVmVnicNetworkResourcePoolRuntimeInfo)(nil)).Elem()
}

// A boxed array of `DvsVmVnicResourcePoolConfigSpec`. To be used in `Any` placeholders.
type ArrayOfDvsVmVnicResourcePoolConfigSpec struct {
	DvsVmVnicResourcePoolConfigSpec []DvsVmVnicResourcePoolConfigSpec `xml:"DvsVmVnicResourcePoolConfigSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDvsVmVnicResourcePoolConfigSpec"] = reflect.TypeOf((*ArrayOfDvsVmVnicResourcePoolConfigSpec)(nil)).Elem()
}

// A boxed array of `DvsVnicAllocatedResource`. To be used in `Any` placeholders.
type ArrayOfDvsVnicAllocatedResource struct {
	DvsVnicAllocatedResource []DvsVnicAllocatedResource `xml:"DvsVnicAllocatedResource,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDvsVnicAllocatedResource"] = reflect.TypeOf((*ArrayOfDvsVnicAllocatedResource)(nil)).Elem()
}

// A boxed array of `DynamicProperty`. To be used in `Any` placeholders.
type ArrayOfDynamicProperty struct {
	DynamicProperty []DynamicProperty `xml:"DynamicProperty,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfDynamicProperty"] = reflect.TypeOf((*ArrayOfDynamicProperty)(nil)).Elem()
}

// A boxed array of `EVCMode`. To be used in `Any` placeholders.
type ArrayOfEVCMode struct {
	EVCMode []EVCMode `xml:"EVCMode,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfEVCMode"] = reflect.TypeOf((*ArrayOfEVCMode)(nil)).Elem()
}

// A boxed array of `ElementDescription`. To be used in `Any` placeholders.
type ArrayOfElementDescription struct {
	ElementDescription []BaseElementDescription `xml:"ElementDescription,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfElementDescription"] = reflect.TypeOf((*ArrayOfElementDescription)(nil)).Elem()
}

// A boxed array of `EntityBackupConfig`. To be used in `Any` placeholders.
type ArrayOfEntityBackupConfig struct {
	EntityBackupConfig []EntityBackupConfig `xml:"EntityBackupConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfEntityBackupConfig"] = reflect.TypeOf((*ArrayOfEntityBackupConfig)(nil)).Elem()
}

// A boxed array of `EntityPrivilege`. To be used in `Any` placeholders.
type ArrayOfEntityPrivilege struct {
	EntityPrivilege []EntityPrivilege `xml:"EntityPrivilege,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfEntityPrivilege"] = reflect.TypeOf((*ArrayOfEntityPrivilege)(nil)).Elem()
}

// A boxed array of `EnumDescription`. To be used in `Any` placeholders.
type ArrayOfEnumDescription struct {
	EnumDescription []EnumDescription `xml:"EnumDescription,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfEnumDescription"] = reflect.TypeOf((*ArrayOfEnumDescription)(nil)).Elem()
}

// A boxed array of `Event`. To be used in `Any` placeholders.
type ArrayOfEvent struct {
	Event []BaseEvent `xml:"Event,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfEvent"] = reflect.TypeOf((*ArrayOfEvent)(nil)).Elem()
}

// A boxed array of `EventAlarmExpressionComparison`. To be used in `Any` placeholders.
type ArrayOfEventAlarmExpressionComparison struct {
	EventAlarmExpressionComparison []EventAlarmExpressionComparison `xml:"EventAlarmExpressionComparison,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfEventAlarmExpressionComparison"] = reflect.TypeOf((*ArrayOfEventAlarmExpressionComparison)(nil)).Elem()
}

// A boxed array of `EventArgDesc`. To be used in `Any` placeholders.
type ArrayOfEventArgDesc struct {
	EventArgDesc []EventArgDesc `xml:"EventArgDesc,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfEventArgDesc"] = reflect.TypeOf((*ArrayOfEventArgDesc)(nil)).Elem()
}

// A boxed array of `EventDescriptionEventDetail`. To be used in `Any` placeholders.
type ArrayOfEventDescriptionEventDetail struct {
	EventDescriptionEventDetail []EventDescriptionEventDetail `xml:"EventDescriptionEventDetail,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfEventDescriptionEventDetail"] = reflect.TypeOf((*ArrayOfEventDescriptionEventDetail)(nil)).Elem()
}

// A boxed array of `ExtManagedEntityInfo`. To be used in `Any` placeholders.
type ArrayOfExtManagedEntityInfo struct {
	ExtManagedEntityInfo []ExtManagedEntityInfo `xml:"ExtManagedEntityInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfExtManagedEntityInfo"] = reflect.TypeOf((*ArrayOfExtManagedEntityInfo)(nil)).Elem()
}

// A boxed array of `ExtSolutionManagerInfoTabInfo`. To be used in `Any` placeholders.
type ArrayOfExtSolutionManagerInfoTabInfo struct {
	ExtSolutionManagerInfoTabInfo []ExtSolutionManagerInfoTabInfo `xml:"ExtSolutionManagerInfoTabInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfExtSolutionManagerInfoTabInfo"] = reflect.TypeOf((*ArrayOfExtSolutionManagerInfoTabInfo)(nil)).Elem()
}

// A boxed array of `ExtendedEventPair`. To be used in `Any` placeholders.
type ArrayOfExtendedEventPair struct {
	ExtendedEventPair []ExtendedEventPair `xml:"ExtendedEventPair,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfExtendedEventPair"] = reflect.TypeOf((*ArrayOfExtendedEventPair)(nil)).Elem()
}

// A boxed array of `Extension`. To be used in `Any` placeholders.
type ArrayOfExtension struct {
	Extension []Extension `xml:"Extension,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfExtension"] = reflect.TypeOf((*ArrayOfExtension)(nil)).Elem()
}

// A boxed array of `ExtensionClientInfo`. To be used in `Any` placeholders.
type ArrayOfExtensionClientInfo struct {
	ExtensionClientInfo []ExtensionClientInfo `xml:"ExtensionClientInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfExtensionClientInfo"] = reflect.TypeOf((*ArrayOfExtensionClientInfo)(nil)).Elem()
}

// A boxed array of `ExtensionEventTypeInfo`. To be used in `Any` placeholders.
type ArrayOfExtensionEventTypeInfo struct {
	ExtensionEventTypeInfo []ExtensionEventTypeInfo `xml:"ExtensionEventTypeInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfExtensionEventTypeInfo"] = reflect.TypeOf((*ArrayOfExtensionEventTypeInfo)(nil)).Elem()
}

// A boxed array of `ExtensionFaultTypeInfo`. To be used in `Any` placeholders.
type ArrayOfExtensionFaultTypeInfo struct {
	ExtensionFaultTypeInfo []ExtensionFaultTypeInfo `xml:"ExtensionFaultTypeInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfExtensionFaultTypeInfo"] = reflect.TypeOf((*ArrayOfExtensionFaultTypeInfo)(nil)).Elem()
}

// A boxed array of `ExtensionManagerIpAllocationUsage`. To be used in `Any` placeholders.
type ArrayOfExtensionManagerIpAllocationUsage struct {
	ExtensionManagerIpAllocationUsage []ExtensionManagerIpAllocationUsage `xml:"ExtensionManagerIpAllocationUsage,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfExtensionManagerIpAllocationUsage"] = reflect.TypeOf((*ArrayOfExtensionManagerIpAllocationUsage)(nil)).Elem()
}

// A boxed array of `ExtensionPrivilegeInfo`. To be used in `Any` placeholders.
type ArrayOfExtensionPrivilegeInfo struct {
	ExtensionPrivilegeInfo []ExtensionPrivilegeInfo `xml:"ExtensionPrivilegeInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfExtensionPrivilegeInfo"] = reflect.TypeOf((*ArrayOfExtensionPrivilegeInfo)(nil)).Elem()
}

// A boxed array of `ExtensionResourceInfo`. To be used in `Any` placeholders.
type ArrayOfExtensionResourceInfo struct {
	ExtensionResourceInfo []ExtensionResourceInfo `xml:"ExtensionResourceInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfExtensionResourceInfo"] = reflect.TypeOf((*ArrayOfExtensionResourceInfo)(nil)).Elem()
}

// A boxed array of `ExtensionServerInfo`. To be used in `Any` placeholders.
type ArrayOfExtensionServerInfo struct {
	ExtensionServerInfo []ExtensionServerInfo `xml:"ExtensionServerInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfExtensionServerInfo"] = reflect.TypeOf((*ArrayOfExtensionServerInfo)(nil)).Elem()
}

// A boxed array of `ExtensionTaskTypeInfo`. To be used in `Any` placeholders.
type ArrayOfExtensionTaskTypeInfo struct {
	ExtensionTaskTypeInfo []ExtensionTaskTypeInfo `xml:"ExtensionTaskTypeInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfExtensionTaskTypeInfo"] = reflect.TypeOf((*ArrayOfExtensionTaskTypeInfo)(nil)).Elem()
}

// A boxed array of `FaultToleranceDiskSpec`. To be used in `Any` placeholders.
type ArrayOfFaultToleranceDiskSpec struct {
	FaultToleranceDiskSpec []FaultToleranceDiskSpec `xml:"FaultToleranceDiskSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfFaultToleranceDiskSpec"] = reflect.TypeOf((*ArrayOfFaultToleranceDiskSpec)(nil)).Elem()
}

// A boxed array of `FaultsByHost`. To be used in `Any` placeholders.
type ArrayOfFaultsByHost struct {
	FaultsByHost []FaultsByHost `xml:"FaultsByHost,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfFaultsByHost"] = reflect.TypeOf((*ArrayOfFaultsByHost)(nil)).Elem()
}

// A boxed array of `FaultsByVM`. To be used in `Any` placeholders.
type ArrayOfFaultsByVM struct {
	FaultsByVM []FaultsByVM `xml:"FaultsByVM,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfFaultsByVM"] = reflect.TypeOf((*ArrayOfFaultsByVM)(nil)).Elem()
}

// A boxed array of `FcoeConfigVlanRange`. To be used in `Any` placeholders.
type ArrayOfFcoeConfigVlanRange struct {
	FcoeConfigVlanRange []FcoeConfigVlanRange `xml:"FcoeConfigVlanRange,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfFcoeConfigVlanRange"] = reflect.TypeOf((*ArrayOfFcoeConfigVlanRange)(nil)).Elem()
}

// A boxed array of `FeatureEVCMode`. To be used in `Any` placeholders.
type ArrayOfFeatureEVCMode struct {
	FeatureEVCMode []FeatureEVCMode `xml:"FeatureEVCMode,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfFeatureEVCMode"] = reflect.TypeOf((*ArrayOfFeatureEVCMode)(nil)).Elem()
	minAPIVersionForType["ArrayOfFeatureEVCMode"] = "7.0.1.0"
}

// A boxed array of `FileInfo`. To be used in `Any` placeholders.
type ArrayOfFileInfo struct {
	FileInfo []BaseFileInfo `xml:"FileInfo,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfFileInfo"] = reflect.TypeOf((*ArrayOfFileInfo)(nil)).Elem()
}

// A boxed array of `FileLockInfo`. To be used in `Any` placeholders.
type ArrayOfFileLockInfo struct {
	FileLockInfo []FileLockInfo `xml:"FileLockInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfFileLockInfo"] = reflect.TypeOf((*ArrayOfFileLockInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfFileLockInfo"] = "8.0.2.0"
}

// A boxed array of `FileQuery`. To be used in `Any` placeholders.
type ArrayOfFileQuery struct {
	FileQuery []BaseFileQuery `xml:"FileQuery,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfFileQuery"] = reflect.TypeOf((*ArrayOfFileQuery)(nil)).Elem()
}

// A boxed array of `FirewallProfileRulesetProfile`. To be used in `Any` placeholders.
type ArrayOfFirewallProfileRulesetProfile struct {
	FirewallProfileRulesetProfile []FirewallProfileRulesetProfile `xml:"FirewallProfileRulesetProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfFirewallProfileRulesetProfile"] = reflect.TypeOf((*ArrayOfFirewallProfileRulesetProfile)(nil)).Elem()
}

// A boxed array of `FolderFailedHostResult`. To be used in `Any` placeholders.
type ArrayOfFolderFailedHostResult struct {
	FolderFailedHostResult []FolderFailedHostResult `xml:"FolderFailedHostResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfFolderFailedHostResult"] = reflect.TypeOf((*ArrayOfFolderFailedHostResult)(nil)).Elem()
}

// A boxed array of `FolderNewHostSpec`. To be used in `Any` placeholders.
type ArrayOfFolderNewHostSpec struct {
	FolderNewHostSpec []FolderNewHostSpec `xml:"FolderNewHostSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfFolderNewHostSpec"] = reflect.TypeOf((*ArrayOfFolderNewHostSpec)(nil)).Elem()
}

// A boxed array of `GuestAliases`. To be used in `Any` placeholders.
type ArrayOfGuestAliases struct {
	GuestAliases []GuestAliases `xml:"GuestAliases,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfGuestAliases"] = reflect.TypeOf((*ArrayOfGuestAliases)(nil)).Elem()
}

// A boxed array of `GuestAuthAliasInfo`. To be used in `Any` placeholders.
type ArrayOfGuestAuthAliasInfo struct {
	GuestAuthAliasInfo []GuestAuthAliasInfo `xml:"GuestAuthAliasInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfGuestAuthAliasInfo"] = reflect.TypeOf((*ArrayOfGuestAuthAliasInfo)(nil)).Elem()
}

// A boxed array of `GuestAuthSubject`. To be used in `Any` placeholders.
type ArrayOfGuestAuthSubject struct {
	GuestAuthSubject []BaseGuestAuthSubject `xml:"GuestAuthSubject,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfGuestAuthSubject"] = reflect.TypeOf((*ArrayOfGuestAuthSubject)(nil)).Elem()
}

// A boxed array of `GuestDiskInfo`. To be used in `Any` placeholders.
type ArrayOfGuestDiskInfo struct {
	GuestDiskInfo []GuestDiskInfo `xml:"GuestDiskInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfGuestDiskInfo"] = reflect.TypeOf((*ArrayOfGuestDiskInfo)(nil)).Elem()
}

// A boxed array of `GuestFileInfo`. To be used in `Any` placeholders.
type ArrayOfGuestFileInfo struct {
	GuestFileInfo []GuestFileInfo `xml:"GuestFileInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfGuestFileInfo"] = reflect.TypeOf((*ArrayOfGuestFileInfo)(nil)).Elem()
}

// A boxed array of `GuestInfoNamespaceGenerationInfo`. To be used in `Any` placeholders.
type ArrayOfGuestInfoNamespaceGenerationInfo struct {
	GuestInfoNamespaceGenerationInfo []GuestInfoNamespaceGenerationInfo `xml:"GuestInfoNamespaceGenerationInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfGuestInfoNamespaceGenerationInfo"] = reflect.TypeOf((*ArrayOfGuestInfoNamespaceGenerationInfo)(nil)).Elem()
}

// A boxed array of `GuestInfoVirtualDiskMapping`. To be used in `Any` placeholders.
type ArrayOfGuestInfoVirtualDiskMapping struct {
	GuestInfoVirtualDiskMapping []GuestInfoVirtualDiskMapping `xml:"GuestInfoVirtualDiskMapping,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfGuestInfoVirtualDiskMapping"] = reflect.TypeOf((*ArrayOfGuestInfoVirtualDiskMapping)(nil)).Elem()
}

// A boxed array of `GuestMappedAliases`. To be used in `Any` placeholders.
type ArrayOfGuestMappedAliases struct {
	GuestMappedAliases []GuestMappedAliases `xml:"GuestMappedAliases,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfGuestMappedAliases"] = reflect.TypeOf((*ArrayOfGuestMappedAliases)(nil)).Elem()
}

// A boxed array of `GuestNicInfo`. To be used in `Any` placeholders.
type ArrayOfGuestNicInfo struct {
	GuestNicInfo []GuestNicInfo `xml:"GuestNicInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfGuestNicInfo"] = reflect.TypeOf((*ArrayOfGuestNicInfo)(nil)).Elem()
}

// A boxed array of `GuestOsDescriptor`. To be used in `Any` placeholders.
type ArrayOfGuestOsDescriptor struct {
	GuestOsDescriptor []GuestOsDescriptor `xml:"GuestOsDescriptor,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfGuestOsDescriptor"] = reflect.TypeOf((*ArrayOfGuestOsDescriptor)(nil)).Elem()
}

// A boxed array of `GuestProcessInfo`. To be used in `Any` placeholders.
type ArrayOfGuestProcessInfo struct {
	GuestProcessInfo []GuestProcessInfo `xml:"GuestProcessInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfGuestProcessInfo"] = reflect.TypeOf((*ArrayOfGuestProcessInfo)(nil)).Elem()
}

// A boxed array of `GuestRegKeyRecordSpec`. To be used in `Any` placeholders.
type ArrayOfGuestRegKeyRecordSpec struct {
	GuestRegKeyRecordSpec []GuestRegKeyRecordSpec `xml:"GuestRegKeyRecordSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfGuestRegKeyRecordSpec"] = reflect.TypeOf((*ArrayOfGuestRegKeyRecordSpec)(nil)).Elem()
}

// A boxed array of `GuestRegValueSpec`. To be used in `Any` placeholders.
type ArrayOfGuestRegValueSpec struct {
	GuestRegValueSpec []GuestRegValueSpec `xml:"GuestRegValueSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfGuestRegValueSpec"] = reflect.TypeOf((*ArrayOfGuestRegValueSpec)(nil)).Elem()
}

// A boxed array of `GuestStackInfo`. To be used in `Any` placeholders.
type ArrayOfGuestStackInfo struct {
	GuestStackInfo []GuestStackInfo `xml:"GuestStackInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfGuestStackInfo"] = reflect.TypeOf((*ArrayOfGuestStackInfo)(nil)).Elem()
}

// A boxed array of `HbrManagerVmReplicationCapability`. To be used in `Any` placeholders.
type ArrayOfHbrManagerVmReplicationCapability struct {
	HbrManagerVmReplicationCapability []HbrManagerVmReplicationCapability `xml:"HbrManagerVmReplicationCapability,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHbrManagerVmReplicationCapability"] = reflect.TypeOf((*ArrayOfHbrManagerVmReplicationCapability)(nil)).Elem()
}

// A boxed array of `HealthUpdate`. To be used in `Any` placeholders.
type ArrayOfHealthUpdate struct {
	HealthUpdate []HealthUpdate `xml:"HealthUpdate,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHealthUpdate"] = reflect.TypeOf((*ArrayOfHealthUpdate)(nil)).Elem()
}

// A boxed array of `HealthUpdateInfo`. To be used in `Any` placeholders.
type ArrayOfHealthUpdateInfo struct {
	HealthUpdateInfo []HealthUpdateInfo `xml:"HealthUpdateInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHealthUpdateInfo"] = reflect.TypeOf((*ArrayOfHealthUpdateInfo)(nil)).Elem()
}

// A boxed array of `HostAccessControlEntry`. To be used in `Any` placeholders.
type ArrayOfHostAccessControlEntry struct {
	HostAccessControlEntry []HostAccessControlEntry `xml:"HostAccessControlEntry,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostAccessControlEntry"] = reflect.TypeOf((*ArrayOfHostAccessControlEntry)(nil)).Elem()
}

// A boxed array of `HostAccountSpec`. To be used in `Any` placeholders.
type ArrayOfHostAccountSpec struct {
	HostAccountSpec []BaseHostAccountSpec `xml:"HostAccountSpec,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfHostAccountSpec"] = reflect.TypeOf((*ArrayOfHostAccountSpec)(nil)).Elem()
}

// A boxed array of `HostActiveDirectory`. To be used in `Any` placeholders.
type ArrayOfHostActiveDirectory struct {
	HostActiveDirectory []HostActiveDirectory `xml:"HostActiveDirectory,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostActiveDirectory"] = reflect.TypeOf((*ArrayOfHostActiveDirectory)(nil)).Elem()
}

// A boxed array of `HostAssignableHardwareBinding`. To be used in `Any` placeholders.
type ArrayOfHostAssignableHardwareBinding struct {
	HostAssignableHardwareBinding []HostAssignableHardwareBinding `xml:"HostAssignableHardwareBinding,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostAssignableHardwareBinding"] = reflect.TypeOf((*ArrayOfHostAssignableHardwareBinding)(nil)).Elem()
}

// A boxed array of `HostAssignableHardwareConfigAttributeOverride`. To be used in `Any` placeholders.
type ArrayOfHostAssignableHardwareConfigAttributeOverride struct {
	HostAssignableHardwareConfigAttributeOverride []HostAssignableHardwareConfigAttributeOverride `xml:"HostAssignableHardwareConfigAttributeOverride,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostAssignableHardwareConfigAttributeOverride"] = reflect.TypeOf((*ArrayOfHostAssignableHardwareConfigAttributeOverride)(nil)).Elem()
}

// A boxed array of `HostAuthenticationStoreInfo`. To be used in `Any` placeholders.
type ArrayOfHostAuthenticationStoreInfo struct {
	HostAuthenticationStoreInfo []BaseHostAuthenticationStoreInfo `xml:"HostAuthenticationStoreInfo,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfHostAuthenticationStoreInfo"] = reflect.TypeOf((*ArrayOfHostAuthenticationStoreInfo)(nil)).Elem()
}

// A boxed array of `HostBootDevice`. To be used in `Any` placeholders.
type ArrayOfHostBootDevice struct {
	HostBootDevice []HostBootDevice `xml:"HostBootDevice,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostBootDevice"] = reflect.TypeOf((*ArrayOfHostBootDevice)(nil)).Elem()
}

// A boxed array of `HostCacheConfigurationInfo`. To be used in `Any` placeholders.
type ArrayOfHostCacheConfigurationInfo struct {
	HostCacheConfigurationInfo []HostCacheConfigurationInfo `xml:"HostCacheConfigurationInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostCacheConfigurationInfo"] = reflect.TypeOf((*ArrayOfHostCacheConfigurationInfo)(nil)).Elem()
}

// A boxed array of `HostCertificateManagerCertificateInfo`. To be used in `Any` placeholders.
type ArrayOfHostCertificateManagerCertificateInfo struct {
	HostCertificateManagerCertificateInfo []HostCertificateManagerCertificateInfo `xml:"HostCertificateManagerCertificateInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostCertificateManagerCertificateInfo"] = reflect.TypeOf((*ArrayOfHostCertificateManagerCertificateInfo)(nil)).Elem()
}

// A boxed array of `HostConnectInfoNetworkInfo`. To be used in `Any` placeholders.
type ArrayOfHostConnectInfoNetworkInfo struct {
	HostConnectInfoNetworkInfo []BaseHostConnectInfoNetworkInfo `xml:"HostConnectInfoNetworkInfo,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfHostConnectInfoNetworkInfo"] = reflect.TypeOf((*ArrayOfHostConnectInfoNetworkInfo)(nil)).Elem()
}

// A boxed array of `HostConnectSpec`. To be used in `Any` placeholders.
type ArrayOfHostConnectSpec struct {
	HostConnectSpec []HostConnectSpec `xml:"HostConnectSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostConnectSpec"] = reflect.TypeOf((*ArrayOfHostConnectSpec)(nil)).Elem()
}

// A boxed array of `HostCpuIdInfo`. To be used in `Any` placeholders.
type ArrayOfHostCpuIdInfo struct {
	HostCpuIdInfo []HostCpuIdInfo `xml:"HostCpuIdInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostCpuIdInfo"] = reflect.TypeOf((*ArrayOfHostCpuIdInfo)(nil)).Elem()
}

// A boxed array of `HostCpuPackage`. To be used in `Any` placeholders.
type ArrayOfHostCpuPackage struct {
	HostCpuPackage []HostCpuPackage `xml:"HostCpuPackage,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostCpuPackage"] = reflect.TypeOf((*ArrayOfHostCpuPackage)(nil)).Elem()
}

// A boxed array of `HostDatastoreBrowserSearchResults`. To be used in `Any` placeholders.
type ArrayOfHostDatastoreBrowserSearchResults struct {
	HostDatastoreBrowserSearchResults []HostDatastoreBrowserSearchResults `xml:"HostDatastoreBrowserSearchResults,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostDatastoreBrowserSearchResults"] = reflect.TypeOf((*ArrayOfHostDatastoreBrowserSearchResults)(nil)).Elem()
}

// A boxed array of `HostDatastoreConnectInfo`. To be used in `Any` placeholders.
type ArrayOfHostDatastoreConnectInfo struct {
	HostDatastoreConnectInfo []BaseHostDatastoreConnectInfo `xml:"HostDatastoreConnectInfo,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfHostDatastoreConnectInfo"] = reflect.TypeOf((*ArrayOfHostDatastoreConnectInfo)(nil)).Elem()
}

// A boxed array of `HostDatastoreSystemDatastoreResult`. To be used in `Any` placeholders.
type ArrayOfHostDatastoreSystemDatastoreResult struct {
	HostDatastoreSystemDatastoreResult []HostDatastoreSystemDatastoreResult `xml:"HostDatastoreSystemDatastoreResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostDatastoreSystemDatastoreResult"] = reflect.TypeOf((*ArrayOfHostDatastoreSystemDatastoreResult)(nil)).Elem()
}

// A boxed array of `HostDateTimeSystemTimeZone`. To be used in `Any` placeholders.
type ArrayOfHostDateTimeSystemTimeZone struct {
	HostDateTimeSystemTimeZone []HostDateTimeSystemTimeZone `xml:"HostDateTimeSystemTimeZone,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostDateTimeSystemTimeZone"] = reflect.TypeOf((*ArrayOfHostDateTimeSystemTimeZone)(nil)).Elem()
}

// A boxed array of `HostDhcpService`. To be used in `Any` placeholders.
type ArrayOfHostDhcpService struct {
	HostDhcpService []HostDhcpService `xml:"HostDhcpService,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostDhcpService"] = reflect.TypeOf((*ArrayOfHostDhcpService)(nil)).Elem()
}

// A boxed array of `HostDhcpServiceConfig`. To be used in `Any` placeholders.
type ArrayOfHostDhcpServiceConfig struct {
	HostDhcpServiceConfig []HostDhcpServiceConfig `xml:"HostDhcpServiceConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostDhcpServiceConfig"] = reflect.TypeOf((*ArrayOfHostDhcpServiceConfig)(nil)).Elem()
}

// A boxed array of `HostDiagnosticPartition`. To be used in `Any` placeholders.
type ArrayOfHostDiagnosticPartition struct {
	HostDiagnosticPartition []HostDiagnosticPartition `xml:"HostDiagnosticPartition,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostDiagnosticPartition"] = reflect.TypeOf((*ArrayOfHostDiagnosticPartition)(nil)).Elem()
}

// A boxed array of `HostDiagnosticPartitionCreateOption`. To be used in `Any` placeholders.
type ArrayOfHostDiagnosticPartitionCreateOption struct {
	HostDiagnosticPartitionCreateOption []HostDiagnosticPartitionCreateOption `xml:"HostDiagnosticPartitionCreateOption,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostDiagnosticPartitionCreateOption"] = reflect.TypeOf((*ArrayOfHostDiagnosticPartitionCreateOption)(nil)).Elem()
}

// A boxed array of `HostDiskConfigurationResult`. To be used in `Any` placeholders.
type ArrayOfHostDiskConfigurationResult struct {
	HostDiskConfigurationResult []HostDiskConfigurationResult `xml:"HostDiskConfigurationResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostDiskConfigurationResult"] = reflect.TypeOf((*ArrayOfHostDiskConfigurationResult)(nil)).Elem()
}

// A boxed array of `HostDiskMappingPartitionOption`. To be used in `Any` placeholders.
type ArrayOfHostDiskMappingPartitionOption struct {
	HostDiskMappingPartitionOption []HostDiskMappingPartitionOption `xml:"HostDiskMappingPartitionOption,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostDiskMappingPartitionOption"] = reflect.TypeOf((*ArrayOfHostDiskMappingPartitionOption)(nil)).Elem()
}

// A boxed array of `HostDiskPartitionAttributes`. To be used in `Any` placeholders.
type ArrayOfHostDiskPartitionAttributes struct {
	HostDiskPartitionAttributes []HostDiskPartitionAttributes `xml:"HostDiskPartitionAttributes,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostDiskPartitionAttributes"] = reflect.TypeOf((*ArrayOfHostDiskPartitionAttributes)(nil)).Elem()
}

// A boxed array of `HostDiskPartitionBlockRange`. To be used in `Any` placeholders.
type ArrayOfHostDiskPartitionBlockRange struct {
	HostDiskPartitionBlockRange []HostDiskPartitionBlockRange `xml:"HostDiskPartitionBlockRange,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostDiskPartitionBlockRange"] = reflect.TypeOf((*ArrayOfHostDiskPartitionBlockRange)(nil)).Elem()
}

// A boxed array of `HostDiskPartitionInfo`. To be used in `Any` placeholders.
type ArrayOfHostDiskPartitionInfo struct {
	HostDiskPartitionInfo []HostDiskPartitionInfo `xml:"HostDiskPartitionInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostDiskPartitionInfo"] = reflect.TypeOf((*ArrayOfHostDiskPartitionInfo)(nil)).Elem()
}

// A boxed array of `HostDvxClass`. To be used in `Any` placeholders.
type ArrayOfHostDvxClass struct {
	HostDvxClass []HostDvxClass `xml:"HostDvxClass,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostDvxClass"] = reflect.TypeOf((*ArrayOfHostDvxClass)(nil)).Elem()
	minAPIVersionForType["ArrayOfHostDvxClass"] = "8.0.0.1"
}

// A boxed array of `HostEventArgument`. To be used in `Any` placeholders.
type ArrayOfHostEventArgument struct {
	HostEventArgument []HostEventArgument `xml:"HostEventArgument,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostEventArgument"] = reflect.TypeOf((*ArrayOfHostEventArgument)(nil)).Elem()
}

// A boxed array of `HostFeatureCapability`. To be used in `Any` placeholders.
type ArrayOfHostFeatureCapability struct {
	HostFeatureCapability []HostFeatureCapability `xml:"HostFeatureCapability,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostFeatureCapability"] = reflect.TypeOf((*ArrayOfHostFeatureCapability)(nil)).Elem()
}

// A boxed array of `HostFeatureMask`. To be used in `Any` placeholders.
type ArrayOfHostFeatureMask struct {
	HostFeatureMask []HostFeatureMask `xml:"HostFeatureMask,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostFeatureMask"] = reflect.TypeOf((*ArrayOfHostFeatureMask)(nil)).Elem()
}

// A boxed array of `HostFeatureVersionInfo`. To be used in `Any` placeholders.
type ArrayOfHostFeatureVersionInfo struct {
	HostFeatureVersionInfo []HostFeatureVersionInfo `xml:"HostFeatureVersionInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostFeatureVersionInfo"] = reflect.TypeOf((*ArrayOfHostFeatureVersionInfo)(nil)).Elem()
}

// A boxed array of `HostFileSystemMountInfo`. To be used in `Any` placeholders.
type ArrayOfHostFileSystemMountInfo struct {
	HostFileSystemMountInfo []HostFileSystemMountInfo `xml:"HostFileSystemMountInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostFileSystemMountInfo"] = reflect.TypeOf((*ArrayOfHostFileSystemMountInfo)(nil)).Elem()
}

// A boxed array of `HostFirewallConfigRuleSetConfig`. To be used in `Any` placeholders.
type ArrayOfHostFirewallConfigRuleSetConfig struct {
	HostFirewallConfigRuleSetConfig []HostFirewallConfigRuleSetConfig `xml:"HostFirewallConfigRuleSetConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostFirewallConfigRuleSetConfig"] = reflect.TypeOf((*ArrayOfHostFirewallConfigRuleSetConfig)(nil)).Elem()
}

// A boxed array of `HostFirewallRule`. To be used in `Any` placeholders.
type ArrayOfHostFirewallRule struct {
	HostFirewallRule []HostFirewallRule `xml:"HostFirewallRule,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostFirewallRule"] = reflect.TypeOf((*ArrayOfHostFirewallRule)(nil)).Elem()
}

// A boxed array of `HostFirewallRuleset`. To be used in `Any` placeholders.
type ArrayOfHostFirewallRuleset struct {
	HostFirewallRuleset []HostFirewallRuleset `xml:"HostFirewallRuleset,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostFirewallRuleset"] = reflect.TypeOf((*ArrayOfHostFirewallRuleset)(nil)).Elem()
}

// A boxed array of `HostFirewallRulesetIpNetwork`. To be used in `Any` placeholders.
type ArrayOfHostFirewallRulesetIpNetwork struct {
	HostFirewallRulesetIpNetwork []HostFirewallRulesetIpNetwork `xml:"HostFirewallRulesetIpNetwork,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostFirewallRulesetIpNetwork"] = reflect.TypeOf((*ArrayOfHostFirewallRulesetIpNetwork)(nil)).Elem()
}

// A boxed array of `HostGraphicsConfigDeviceType`. To be used in `Any` placeholders.
type ArrayOfHostGraphicsConfigDeviceType struct {
	HostGraphicsConfigDeviceType []HostGraphicsConfigDeviceType `xml:"HostGraphicsConfigDeviceType,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostGraphicsConfigDeviceType"] = reflect.TypeOf((*ArrayOfHostGraphicsConfigDeviceType)(nil)).Elem()
}

// A boxed array of `HostGraphicsInfo`. To be used in `Any` placeholders.
type ArrayOfHostGraphicsInfo struct {
	HostGraphicsInfo []HostGraphicsInfo `xml:"HostGraphicsInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostGraphicsInfo"] = reflect.TypeOf((*ArrayOfHostGraphicsInfo)(nil)).Elem()
}

// A boxed array of `HostHardwareElementInfo`. To be used in `Any` placeholders.
type ArrayOfHostHardwareElementInfo struct {
	HostHardwareElementInfo []BaseHostHardwareElementInfo `xml:"HostHardwareElementInfo,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfHostHardwareElementInfo"] = reflect.TypeOf((*ArrayOfHostHardwareElementInfo)(nil)).Elem()
}

// A boxed array of `HostHostBusAdapter`. To be used in `Any` placeholders.
type ArrayOfHostHostBusAdapter struct {
	HostHostBusAdapter []BaseHostHostBusAdapter `xml:"HostHostBusAdapter,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfHostHostBusAdapter"] = reflect.TypeOf((*ArrayOfHostHostBusAdapter)(nil)).Elem()
}

// A boxed array of `HostInternetScsiHbaIscsiIpv6Address`. To be used in `Any` placeholders.
type ArrayOfHostInternetScsiHbaIscsiIpv6Address struct {
	HostInternetScsiHbaIscsiIpv6Address []HostInternetScsiHbaIscsiIpv6Address `xml:"HostInternetScsiHbaIscsiIpv6Address,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostInternetScsiHbaIscsiIpv6Address"] = reflect.TypeOf((*ArrayOfHostInternetScsiHbaIscsiIpv6Address)(nil)).Elem()
}

// A boxed array of `HostInternetScsiHbaParamValue`. To be used in `Any` placeholders.
type ArrayOfHostInternetScsiHbaParamValue struct {
	HostInternetScsiHbaParamValue []HostInternetScsiHbaParamValue `xml:"HostInternetScsiHbaParamValue,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostInternetScsiHbaParamValue"] = reflect.TypeOf((*ArrayOfHostInternetScsiHbaParamValue)(nil)).Elem()
}

// A boxed array of `HostInternetScsiHbaSendTarget`. To be used in `Any` placeholders.
type ArrayOfHostInternetScsiHbaSendTarget struct {
	HostInternetScsiHbaSendTarget []HostInternetScsiHbaSendTarget `xml:"HostInternetScsiHbaSendTarget,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostInternetScsiHbaSendTarget"] = reflect.TypeOf((*ArrayOfHostInternetScsiHbaSendTarget)(nil)).Elem()
}

// A boxed array of `HostInternetScsiHbaStaticTarget`. To be used in `Any` placeholders.
type ArrayOfHostInternetScsiHbaStaticTarget struct {
	HostInternetScsiHbaStaticTarget []HostInternetScsiHbaStaticTarget `xml:"HostInternetScsiHbaStaticTarget,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostInternetScsiHbaStaticTarget"] = reflect.TypeOf((*ArrayOfHostInternetScsiHbaStaticTarget)(nil)).Elem()
}

// A boxed array of `HostIoFilterInfo`. To be used in `Any` placeholders.
type ArrayOfHostIoFilterInfo struct {
	HostIoFilterInfo []HostIoFilterInfo `xml:"HostIoFilterInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostIoFilterInfo"] = reflect.TypeOf((*ArrayOfHostIoFilterInfo)(nil)).Elem()
}

// A boxed array of `HostIpConfigIpV6Address`. To be used in `Any` placeholders.
type ArrayOfHostIpConfigIpV6Address struct {
	HostIpConfigIpV6Address []HostIpConfigIpV6Address `xml:"HostIpConfigIpV6Address,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostIpConfigIpV6Address"] = reflect.TypeOf((*ArrayOfHostIpConfigIpV6Address)(nil)).Elem()
}

// A boxed array of `HostIpRouteEntry`. To be used in `Any` placeholders.
type ArrayOfHostIpRouteEntry struct {
	HostIpRouteEntry []HostIpRouteEntry `xml:"HostIpRouteEntry,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostIpRouteEntry"] = reflect.TypeOf((*ArrayOfHostIpRouteEntry)(nil)).Elem()
}

// A boxed array of `HostIpRouteOp`. To be used in `Any` placeholders.
type ArrayOfHostIpRouteOp struct {
	HostIpRouteOp []HostIpRouteOp `xml:"HostIpRouteOp,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostIpRouteOp"] = reflect.TypeOf((*ArrayOfHostIpRouteOp)(nil)).Elem()
}

// A boxed array of `HostLowLevelProvisioningManagerDiskLayoutSpec`. To be used in `Any` placeholders.
type ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec struct {
	HostLowLevelProvisioningManagerDiskLayoutSpec []HostLowLevelProvisioningManagerDiskLayoutSpec `xml:"HostLowLevelProvisioningManagerDiskLayoutSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec"] = reflect.TypeOf((*ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec)(nil)).Elem()
}

// A boxed array of `HostLowLevelProvisioningManagerFileDeleteResult`. To be used in `Any` placeholders.
type ArrayOfHostLowLevelProvisioningManagerFileDeleteResult struct {
	HostLowLevelProvisioningManagerFileDeleteResult []HostLowLevelProvisioningManagerFileDeleteResult `xml:"HostLowLevelProvisioningManagerFileDeleteResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostLowLevelProvisioningManagerFileDeleteResult"] = reflect.TypeOf((*ArrayOfHostLowLevelProvisioningManagerFileDeleteResult)(nil)).Elem()
}

// A boxed array of `HostLowLevelProvisioningManagerFileDeleteSpec`. To be used in `Any` placeholders.
type ArrayOfHostLowLevelProvisioningManagerFileDeleteSpec struct {
	HostLowLevelProvisioningManagerFileDeleteSpec []HostLowLevelProvisioningManagerFileDeleteSpec `xml:"HostLowLevelProvisioningManagerFileDeleteSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostLowLevelProvisioningManagerFileDeleteSpec"] = reflect.TypeOf((*ArrayOfHostLowLevelProvisioningManagerFileDeleteSpec)(nil)).Elem()
}

// A boxed array of `HostLowLevelProvisioningManagerFileReserveResult`. To be used in `Any` placeholders.
type ArrayOfHostLowLevelProvisioningManagerFileReserveResult struct {
	HostLowLevelProvisioningManagerFileReserveResult []HostLowLevelProvisioningManagerFileReserveResult `xml:"HostLowLevelProvisioningManagerFileReserveResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostLowLevelProvisioningManagerFileReserveResult"] = reflect.TypeOf((*ArrayOfHostLowLevelProvisioningManagerFileReserveResult)(nil)).Elem()
}

// A boxed array of `HostLowLevelProvisioningManagerFileReserveSpec`. To be used in `Any` placeholders.
type ArrayOfHostLowLevelProvisioningManagerFileReserveSpec struct {
	HostLowLevelProvisioningManagerFileReserveSpec []HostLowLevelProvisioningManagerFileReserveSpec `xml:"HostLowLevelProvisioningManagerFileReserveSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostLowLevelProvisioningManagerFileReserveSpec"] = reflect.TypeOf((*ArrayOfHostLowLevelProvisioningManagerFileReserveSpec)(nil)).Elem()
}

// A boxed array of `HostLowLevelProvisioningManagerSnapshotLayoutSpec`. To be used in `Any` placeholders.
type ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec struct {
	HostLowLevelProvisioningManagerSnapshotLayoutSpec []HostLowLevelProvisioningManagerSnapshotLayoutSpec `xml:"HostLowLevelProvisioningManagerSnapshotLayoutSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec"] = reflect.TypeOf((*ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec)(nil)).Elem()
}

// A boxed array of `HostMemberHealthCheckResult`. To be used in `Any` placeholders.
type ArrayOfHostMemberHealthCheckResult struct {
	HostMemberHealthCheckResult []BaseHostMemberHealthCheckResult `xml:"HostMemberHealthCheckResult,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfHostMemberHealthCheckResult"] = reflect.TypeOf((*ArrayOfHostMemberHealthCheckResult)(nil)).Elem()
}

// A boxed array of `HostMemberRuntimeInfo`. To be used in `Any` placeholders.
type ArrayOfHostMemberRuntimeInfo struct {
	HostMemberRuntimeInfo []HostMemberRuntimeInfo `xml:"HostMemberRuntimeInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostMemberRuntimeInfo"] = reflect.TypeOf((*ArrayOfHostMemberRuntimeInfo)(nil)).Elem()
}

// A boxed array of `HostMemoryTierInfo`. To be used in `Any` placeholders.
type ArrayOfHostMemoryTierInfo struct {
	HostMemoryTierInfo []HostMemoryTierInfo `xml:"HostMemoryTierInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostMemoryTierInfo"] = reflect.TypeOf((*ArrayOfHostMemoryTierInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfHostMemoryTierInfo"] = "7.0.3.0"
}

// A boxed array of `HostMultipathInfoLogicalUnit`. To be used in `Any` placeholders.
type ArrayOfHostMultipathInfoLogicalUnit struct {
	HostMultipathInfoLogicalUnit []HostMultipathInfoLogicalUnit `xml:"HostMultipathInfoLogicalUnit,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostMultipathInfoLogicalUnit"] = reflect.TypeOf((*ArrayOfHostMultipathInfoLogicalUnit)(nil)).Elem()
}

// A boxed array of `HostMultipathInfoPath`. To be used in `Any` placeholders.
type ArrayOfHostMultipathInfoPath struct {
	HostMultipathInfoPath []HostMultipathInfoPath `xml:"HostMultipathInfoPath,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostMultipathInfoPath"] = reflect.TypeOf((*ArrayOfHostMultipathInfoPath)(nil)).Elem()
}

// A boxed array of `HostMultipathStateInfoPath`. To be used in `Any` placeholders.
type ArrayOfHostMultipathStateInfoPath struct {
	HostMultipathStateInfoPath []HostMultipathStateInfoPath `xml:"HostMultipathStateInfoPath,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostMultipathStateInfoPath"] = reflect.TypeOf((*ArrayOfHostMultipathStateInfoPath)(nil)).Elem()
}

// A boxed array of `HostNasVolumeConfig`. To be used in `Any` placeholders.
type ArrayOfHostNasVolumeConfig struct {
	HostNasVolumeConfig []HostNasVolumeConfig `xml:"HostNasVolumeConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNasVolumeConfig"] = reflect.TypeOf((*ArrayOfHostNasVolumeConfig)(nil)).Elem()
}

// A boxed array of `HostNatService`. To be used in `Any` placeholders.
type ArrayOfHostNatService struct {
	HostNatService []HostNatService `xml:"HostNatService,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNatService"] = reflect.TypeOf((*ArrayOfHostNatService)(nil)).Elem()
}

// A boxed array of `HostNatServiceConfig`. To be used in `Any` placeholders.
type ArrayOfHostNatServiceConfig struct {
	HostNatServiceConfig []HostNatServiceConfig `xml:"HostNatServiceConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNatServiceConfig"] = reflect.TypeOf((*ArrayOfHostNatServiceConfig)(nil)).Elem()
}

// A boxed array of `HostNatServicePortForwardSpec`. To be used in `Any` placeholders.
type ArrayOfHostNatServicePortForwardSpec struct {
	HostNatServicePortForwardSpec []HostNatServicePortForwardSpec `xml:"HostNatServicePortForwardSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNatServicePortForwardSpec"] = reflect.TypeOf((*ArrayOfHostNatServicePortForwardSpec)(nil)).Elem()
}

// A boxed array of `HostNetStackInstance`. To be used in `Any` placeholders.
type ArrayOfHostNetStackInstance struct {
	HostNetStackInstance []HostNetStackInstance `xml:"HostNetStackInstance,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNetStackInstance"] = reflect.TypeOf((*ArrayOfHostNetStackInstance)(nil)).Elem()
}

// A boxed array of `HostNetworkConfigNetStackSpec`. To be used in `Any` placeholders.
type ArrayOfHostNetworkConfigNetStackSpec struct {
	HostNetworkConfigNetStackSpec []HostNetworkConfigNetStackSpec `xml:"HostNetworkConfigNetStackSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNetworkConfigNetStackSpec"] = reflect.TypeOf((*ArrayOfHostNetworkConfigNetStackSpec)(nil)).Elem()
}

// A boxed array of `HostNumaNode`. To be used in `Any` placeholders.
type ArrayOfHostNumaNode struct {
	HostNumaNode []HostNumaNode `xml:"HostNumaNode,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNumaNode"] = reflect.TypeOf((*ArrayOfHostNumaNode)(nil)).Elem()
}

// A boxed array of `HostNumericSensorInfo`. To be used in `Any` placeholders.
type ArrayOfHostNumericSensorInfo struct {
	HostNumericSensorInfo []HostNumericSensorInfo `xml:"HostNumericSensorInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNumericSensorInfo"] = reflect.TypeOf((*ArrayOfHostNumericSensorInfo)(nil)).Elem()
}

// A boxed array of `HostNvmeConnectSpec`. To be used in `Any` placeholders.
type ArrayOfHostNvmeConnectSpec struct {
	HostNvmeConnectSpec []HostNvmeConnectSpec `xml:"HostNvmeConnectSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNvmeConnectSpec"] = reflect.TypeOf((*ArrayOfHostNvmeConnectSpec)(nil)).Elem()
}

// A boxed array of `HostNvmeController`. To be used in `Any` placeholders.
type ArrayOfHostNvmeController struct {
	HostNvmeController []HostNvmeController `xml:"HostNvmeController,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNvmeController"] = reflect.TypeOf((*ArrayOfHostNvmeController)(nil)).Elem()
}

// A boxed array of `HostNvmeDisconnectSpec`. To be used in `Any` placeholders.
type ArrayOfHostNvmeDisconnectSpec struct {
	HostNvmeDisconnectSpec []HostNvmeDisconnectSpec `xml:"HostNvmeDisconnectSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNvmeDisconnectSpec"] = reflect.TypeOf((*ArrayOfHostNvmeDisconnectSpec)(nil)).Elem()
}

// A boxed array of `HostNvmeDiscoveryLogEntry`. To be used in `Any` placeholders.
type ArrayOfHostNvmeDiscoveryLogEntry struct {
	HostNvmeDiscoveryLogEntry []HostNvmeDiscoveryLogEntry `xml:"HostNvmeDiscoveryLogEntry,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNvmeDiscoveryLogEntry"] = reflect.TypeOf((*ArrayOfHostNvmeDiscoveryLogEntry)(nil)).Elem()
}

// A boxed array of `HostNvmeNamespace`. To be used in `Any` placeholders.
type ArrayOfHostNvmeNamespace struct {
	HostNvmeNamespace []HostNvmeNamespace `xml:"HostNvmeNamespace,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNvmeNamespace"] = reflect.TypeOf((*ArrayOfHostNvmeNamespace)(nil)).Elem()
}

// A boxed array of `HostNvmeTopologyInterface`. To be used in `Any` placeholders.
type ArrayOfHostNvmeTopologyInterface struct {
	HostNvmeTopologyInterface []HostNvmeTopologyInterface `xml:"HostNvmeTopologyInterface,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostNvmeTopologyInterface"] = reflect.TypeOf((*ArrayOfHostNvmeTopologyInterface)(nil)).Elem()
}

// A boxed array of `HostOpaqueNetworkInfo`. To be used in `Any` placeholders.
type ArrayOfHostOpaqueNetworkInfo struct {
	HostOpaqueNetworkInfo []HostOpaqueNetworkInfo `xml:"HostOpaqueNetworkInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostOpaqueNetworkInfo"] = reflect.TypeOf((*ArrayOfHostOpaqueNetworkInfo)(nil)).Elem()
}

// A boxed array of `HostOpaqueSwitch`. To be used in `Any` placeholders.
type ArrayOfHostOpaqueSwitch struct {
	HostOpaqueSwitch []HostOpaqueSwitch `xml:"HostOpaqueSwitch,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostOpaqueSwitch"] = reflect.TypeOf((*ArrayOfHostOpaqueSwitch)(nil)).Elem()
}

// A boxed array of `HostOpaqueSwitchPhysicalNicZone`. To be used in `Any` placeholders.
type ArrayOfHostOpaqueSwitchPhysicalNicZone struct {
	HostOpaqueSwitchPhysicalNicZone []HostOpaqueSwitchPhysicalNicZone `xml:"HostOpaqueSwitchPhysicalNicZone,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostOpaqueSwitchPhysicalNicZone"] = reflect.TypeOf((*ArrayOfHostOpaqueSwitchPhysicalNicZone)(nil)).Elem()
}

// A boxed array of `HostPartialMaintenanceModeRuntimeInfo`. To be used in `Any` placeholders.
type ArrayOfHostPartialMaintenanceModeRuntimeInfo struct {
	HostPartialMaintenanceModeRuntimeInfo []HostPartialMaintenanceModeRuntimeInfo `xml:"HostPartialMaintenanceModeRuntimeInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPartialMaintenanceModeRuntimeInfo"] = reflect.TypeOf((*ArrayOfHostPartialMaintenanceModeRuntimeInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfHostPartialMaintenanceModeRuntimeInfo"] = "8.0.3.0"
}

// A boxed array of `HostPatchManagerStatus`. To be used in `Any` placeholders.
type ArrayOfHostPatchManagerStatus struct {
	HostPatchManagerStatus []HostPatchManagerStatus `xml:"HostPatchManagerStatus,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPatchManagerStatus"] = reflect.TypeOf((*ArrayOfHostPatchManagerStatus)(nil)).Elem()
}

// A boxed array of `HostPatchManagerStatusPrerequisitePatch`. To be used in `Any` placeholders.
type ArrayOfHostPatchManagerStatusPrerequisitePatch struct {
	HostPatchManagerStatusPrerequisitePatch []HostPatchManagerStatusPrerequisitePatch `xml:"HostPatchManagerStatusPrerequisitePatch,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPatchManagerStatusPrerequisitePatch"] = reflect.TypeOf((*ArrayOfHostPatchManagerStatusPrerequisitePatch)(nil)).Elem()
}

// A boxed array of `HostPathSelectionPolicyOption`. To be used in `Any` placeholders.
type ArrayOfHostPathSelectionPolicyOption struct {
	HostPathSelectionPolicyOption []HostPathSelectionPolicyOption `xml:"HostPathSelectionPolicyOption,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPathSelectionPolicyOption"] = reflect.TypeOf((*ArrayOfHostPathSelectionPolicyOption)(nil)).Elem()
}

// A boxed array of `HostPciDevice`. To be used in `Any` placeholders.
type ArrayOfHostPciDevice struct {
	HostPciDevice []HostPciDevice `xml:"HostPciDevice,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPciDevice"] = reflect.TypeOf((*ArrayOfHostPciDevice)(nil)).Elem()
}

// A boxed array of `HostPciPassthruConfig`. To be used in `Any` placeholders.
type ArrayOfHostPciPassthruConfig struct {
	HostPciPassthruConfig []BaseHostPciPassthruConfig `xml:"HostPciPassthruConfig,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfHostPciPassthruConfig"] = reflect.TypeOf((*ArrayOfHostPciPassthruConfig)(nil)).Elem()
}

// A boxed array of `HostPciPassthruInfo`. To be used in `Any` placeholders.
type ArrayOfHostPciPassthruInfo struct {
	HostPciPassthruInfo []BaseHostPciPassthruInfo `xml:"HostPciPassthruInfo,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfHostPciPassthruInfo"] = reflect.TypeOf((*ArrayOfHostPciPassthruInfo)(nil)).Elem()
}

// A boxed array of `HostPlacedVirtualNicIdentifier`. To be used in `Any` placeholders.
type ArrayOfHostPlacedVirtualNicIdentifier struct {
	HostPlacedVirtualNicIdentifier []HostPlacedVirtualNicIdentifier `xml:"HostPlacedVirtualNicIdentifier,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPlacedVirtualNicIdentifier"] = reflect.TypeOf((*ArrayOfHostPlacedVirtualNicIdentifier)(nil)).Elem()
}

// A boxed array of `HostPlugStoreTopologyAdapter`. To be used in `Any` placeholders.
type ArrayOfHostPlugStoreTopologyAdapter struct {
	HostPlugStoreTopologyAdapter []HostPlugStoreTopologyAdapter `xml:"HostPlugStoreTopologyAdapter,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPlugStoreTopologyAdapter"] = reflect.TypeOf((*ArrayOfHostPlugStoreTopologyAdapter)(nil)).Elem()
}

// A boxed array of `HostPlugStoreTopologyDevice`. To be used in `Any` placeholders.
type ArrayOfHostPlugStoreTopologyDevice struct {
	HostPlugStoreTopologyDevice []HostPlugStoreTopologyDevice `xml:"HostPlugStoreTopologyDevice,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPlugStoreTopologyDevice"] = reflect.TypeOf((*ArrayOfHostPlugStoreTopologyDevice)(nil)).Elem()
}

// A boxed array of `HostPlugStoreTopologyPath`. To be used in `Any` placeholders.
type ArrayOfHostPlugStoreTopologyPath struct {
	HostPlugStoreTopologyPath []HostPlugStoreTopologyPath `xml:"HostPlugStoreTopologyPath,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPlugStoreTopologyPath"] = reflect.TypeOf((*ArrayOfHostPlugStoreTopologyPath)(nil)).Elem()
}

// A boxed array of `HostPlugStoreTopologyPlugin`. To be used in `Any` placeholders.
type ArrayOfHostPlugStoreTopologyPlugin struct {
	HostPlugStoreTopologyPlugin []HostPlugStoreTopologyPlugin `xml:"HostPlugStoreTopologyPlugin,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPlugStoreTopologyPlugin"] = reflect.TypeOf((*ArrayOfHostPlugStoreTopologyPlugin)(nil)).Elem()
}

// A boxed array of `HostPlugStoreTopologyTarget`. To be used in `Any` placeholders.
type ArrayOfHostPlugStoreTopologyTarget struct {
	HostPlugStoreTopologyTarget []HostPlugStoreTopologyTarget `xml:"HostPlugStoreTopologyTarget,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPlugStoreTopologyTarget"] = reflect.TypeOf((*ArrayOfHostPlugStoreTopologyTarget)(nil)).Elem()
}

// A boxed array of `HostPnicNetworkResourceInfo`. To be used in `Any` placeholders.
type ArrayOfHostPnicNetworkResourceInfo struct {
	HostPnicNetworkResourceInfo []HostPnicNetworkResourceInfo `xml:"HostPnicNetworkResourceInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPnicNetworkResourceInfo"] = reflect.TypeOf((*ArrayOfHostPnicNetworkResourceInfo)(nil)).Elem()
}

// A boxed array of `HostPortGroup`. To be used in `Any` placeholders.
type ArrayOfHostPortGroup struct {
	HostPortGroup []HostPortGroup `xml:"HostPortGroup,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPortGroup"] = reflect.TypeOf((*ArrayOfHostPortGroup)(nil)).Elem()
}

// A boxed array of `HostPortGroupConfig`. To be used in `Any` placeholders.
type ArrayOfHostPortGroupConfig struct {
	HostPortGroupConfig []HostPortGroupConfig `xml:"HostPortGroupConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPortGroupConfig"] = reflect.TypeOf((*ArrayOfHostPortGroupConfig)(nil)).Elem()
}

// A boxed array of `HostPortGroupPort`. To be used in `Any` placeholders.
type ArrayOfHostPortGroupPort struct {
	HostPortGroupPort []HostPortGroupPort `xml:"HostPortGroupPort,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPortGroupPort"] = reflect.TypeOf((*ArrayOfHostPortGroupPort)(nil)).Elem()
}

// A boxed array of `HostPortGroupProfile`. To be used in `Any` placeholders.
type ArrayOfHostPortGroupProfile struct {
	HostPortGroupProfile []HostPortGroupProfile `xml:"HostPortGroupProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPortGroupProfile"] = reflect.TypeOf((*ArrayOfHostPortGroupProfile)(nil)).Elem()
}

// A boxed array of `HostPowerPolicy`. To be used in `Any` placeholders.
type ArrayOfHostPowerPolicy struct {
	HostPowerPolicy []HostPowerPolicy `xml:"HostPowerPolicy,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPowerPolicy"] = reflect.TypeOf((*ArrayOfHostPowerPolicy)(nil)).Elem()
}

// A boxed array of `HostProfileManagerCompositionResultResultElement`. To be used in `Any` placeholders.
type ArrayOfHostProfileManagerCompositionResultResultElement struct {
	HostProfileManagerCompositionResultResultElement []HostProfileManagerCompositionResultResultElement `xml:"HostProfileManagerCompositionResultResultElement,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostProfileManagerCompositionResultResultElement"] = reflect.TypeOf((*ArrayOfHostProfileManagerCompositionResultResultElement)(nil)).Elem()
}

// A boxed array of `HostProfileManagerCompositionValidationResultResultElement`. To be used in `Any` placeholders.
type ArrayOfHostProfileManagerCompositionValidationResultResultElement struct {
	HostProfileManagerCompositionValidationResultResultElement []HostProfileManagerCompositionValidationResultResultElement `xml:"HostProfileManagerCompositionValidationResultResultElement,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostProfileManagerCompositionValidationResultResultElement"] = reflect.TypeOf((*ArrayOfHostProfileManagerCompositionValidationResultResultElement)(nil)).Elem()
}

// A boxed array of `HostProfilesEntityCustomizations`. To be used in `Any` placeholders.
type ArrayOfHostProfilesEntityCustomizations struct {
	HostProfilesEntityCustomizations []BaseHostProfilesEntityCustomizations `xml:"HostProfilesEntityCustomizations,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfHostProfilesEntityCustomizations"] = reflect.TypeOf((*ArrayOfHostProfilesEntityCustomizations)(nil)).Elem()
}

// A boxed array of `HostProtocolEndpoint`. To be used in `Any` placeholders.
type ArrayOfHostProtocolEndpoint struct {
	HostProtocolEndpoint []HostProtocolEndpoint `xml:"HostProtocolEndpoint,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostProtocolEndpoint"] = reflect.TypeOf((*ArrayOfHostProtocolEndpoint)(nil)).Elem()
}

// A boxed array of `HostProxySwitch`. To be used in `Any` placeholders.
type ArrayOfHostProxySwitch struct {
	HostProxySwitch []HostProxySwitch `xml:"HostProxySwitch,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostProxySwitch"] = reflect.TypeOf((*ArrayOfHostProxySwitch)(nil)).Elem()
}

// A boxed array of `HostProxySwitchConfig`. To be used in `Any` placeholders.
type ArrayOfHostProxySwitchConfig struct {
	HostProxySwitchConfig []HostProxySwitchConfig `xml:"HostProxySwitchConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostProxySwitchConfig"] = reflect.TypeOf((*ArrayOfHostProxySwitchConfig)(nil)).Elem()
}

// A boxed array of `HostProxySwitchHostLagConfig`. To be used in `Any` placeholders.
type ArrayOfHostProxySwitchHostLagConfig struct {
	HostProxySwitchHostLagConfig []HostProxySwitchHostLagConfig `xml:"HostProxySwitchHostLagConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostProxySwitchHostLagConfig"] = reflect.TypeOf((*ArrayOfHostProxySwitchHostLagConfig)(nil)).Elem()
}

// A boxed array of `HostPtpConfigPtpPort`. To be used in `Any` placeholders.
type ArrayOfHostPtpConfigPtpPort struct {
	HostPtpConfigPtpPort []HostPtpConfigPtpPort `xml:"HostPtpConfigPtpPort,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostPtpConfigPtpPort"] = reflect.TypeOf((*ArrayOfHostPtpConfigPtpPort)(nil)).Elem()
	minAPIVersionForType["ArrayOfHostPtpConfigPtpPort"] = "7.0.3.0"
}

// A boxed array of `HostQualifiedName`. To be used in `Any` placeholders.
type ArrayOfHostQualifiedName struct {
	HostQualifiedName []HostQualifiedName `xml:"HostQualifiedName,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostQualifiedName"] = reflect.TypeOf((*ArrayOfHostQualifiedName)(nil)).Elem()
	minAPIVersionForType["ArrayOfHostQualifiedName"] = "7.0.3.0"
}

// A boxed array of `HostRdmaDevice`. To be used in `Any` placeholders.
type ArrayOfHostRdmaDevice struct {
	HostRdmaDevice []HostRdmaDevice `xml:"HostRdmaDevice,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostRdmaDevice"] = reflect.TypeOf((*ArrayOfHostRdmaDevice)(nil)).Elem()
}

// A boxed array of `HostRuntimeInfoNetStackInstanceRuntimeInfo`. To be used in `Any` placeholders.
type ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo struct {
	HostRuntimeInfoNetStackInstanceRuntimeInfo []HostRuntimeInfoNetStackInstanceRuntimeInfo `xml:"HostRuntimeInfoNetStackInstanceRuntimeInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo"] = reflect.TypeOf((*ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo)(nil)).Elem()
}

// A boxed array of `HostScsiDisk`. To be used in `Any` placeholders.
type ArrayOfHostScsiDisk struct {
	HostScsiDisk []HostScsiDisk `xml:"HostScsiDisk,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostScsiDisk"] = reflect.TypeOf((*ArrayOfHostScsiDisk)(nil)).Elem()
}

// A boxed array of `HostScsiDiskPartition`. To be used in `Any` placeholders.
type ArrayOfHostScsiDiskPartition struct {
	HostScsiDiskPartition []HostScsiDiskPartition `xml:"HostScsiDiskPartition,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostScsiDiskPartition"] = reflect.TypeOf((*ArrayOfHostScsiDiskPartition)(nil)).Elem()
}

// A boxed array of `HostScsiTopologyInterface`. To be used in `Any` placeholders.
type ArrayOfHostScsiTopologyInterface struct {
	HostScsiTopologyInterface []HostScsiTopologyInterface `xml:"HostScsiTopologyInterface,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostScsiTopologyInterface"] = reflect.TypeOf((*ArrayOfHostScsiTopologyInterface)(nil)).Elem()
}

// A boxed array of `HostScsiTopologyLun`. To be used in `Any` placeholders.
type ArrayOfHostScsiTopologyLun struct {
	HostScsiTopologyLun []HostScsiTopologyLun `xml:"HostScsiTopologyLun,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostScsiTopologyLun"] = reflect.TypeOf((*ArrayOfHostScsiTopologyLun)(nil)).Elem()
}

// A boxed array of `HostScsiTopologyTarget`. To be used in `Any` placeholders.
type ArrayOfHostScsiTopologyTarget struct {
	HostScsiTopologyTarget []HostScsiTopologyTarget `xml:"HostScsiTopologyTarget,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostScsiTopologyTarget"] = reflect.TypeOf((*ArrayOfHostScsiTopologyTarget)(nil)).Elem()
}

// A boxed array of `HostService`. To be used in `Any` placeholders.
type ArrayOfHostService struct {
	HostService []HostService `xml:"HostService,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostService"] = reflect.TypeOf((*ArrayOfHostService)(nil)).Elem()
}

// A boxed array of `HostServiceConfig`. To be used in `Any` placeholders.
type ArrayOfHostServiceConfig struct {
	HostServiceConfig []HostServiceConfig `xml:"HostServiceConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostServiceConfig"] = reflect.TypeOf((*ArrayOfHostServiceConfig)(nil)).Elem()
}

// A boxed array of `HostSharedGpuCapabilities`. To be used in `Any` placeholders.
type ArrayOfHostSharedGpuCapabilities struct {
	HostSharedGpuCapabilities []HostSharedGpuCapabilities `xml:"HostSharedGpuCapabilities,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostSharedGpuCapabilities"] = reflect.TypeOf((*ArrayOfHostSharedGpuCapabilities)(nil)).Elem()
}

// A boxed array of `HostSnmpDestination`. To be used in `Any` placeholders.
type ArrayOfHostSnmpDestination struct {
	HostSnmpDestination []HostSnmpDestination `xml:"HostSnmpDestination,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostSnmpDestination"] = reflect.TypeOf((*ArrayOfHostSnmpDestination)(nil)).Elem()
}

// A boxed array of `HostSriovDevicePoolInfo`. To be used in `Any` placeholders.
type ArrayOfHostSriovDevicePoolInfo struct {
	HostSriovDevicePoolInfo []BaseHostSriovDevicePoolInfo `xml:"HostSriovDevicePoolInfo,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfHostSriovDevicePoolInfo"] = reflect.TypeOf((*ArrayOfHostSriovDevicePoolInfo)(nil)).Elem()
}

// A boxed array of `HostSslThumbprintInfo`. To be used in `Any` placeholders.
type ArrayOfHostSslThumbprintInfo struct {
	HostSslThumbprintInfo []HostSslThumbprintInfo `xml:"HostSslThumbprintInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostSslThumbprintInfo"] = reflect.TypeOf((*ArrayOfHostSslThumbprintInfo)(nil)).Elem()
}

// A boxed array of `HostStorageArrayTypePolicyOption`. To be used in `Any` placeholders.
type ArrayOfHostStorageArrayTypePolicyOption struct {
	HostStorageArrayTypePolicyOption []HostStorageArrayTypePolicyOption `xml:"HostStorageArrayTypePolicyOption,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostStorageArrayTypePolicyOption"] = reflect.TypeOf((*ArrayOfHostStorageArrayTypePolicyOption)(nil)).Elem()
}

// A boxed array of `HostStorageElementInfo`. To be used in `Any` placeholders.
type ArrayOfHostStorageElementInfo struct {
	HostStorageElementInfo []HostStorageElementInfo `xml:"HostStorageElementInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostStorageElementInfo"] = reflect.TypeOf((*ArrayOfHostStorageElementInfo)(nil)).Elem()
}

// A boxed array of `HostStorageOperationalInfo`. To be used in `Any` placeholders.
type ArrayOfHostStorageOperationalInfo struct {
	HostStorageOperationalInfo []HostStorageOperationalInfo `xml:"HostStorageOperationalInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostStorageOperationalInfo"] = reflect.TypeOf((*ArrayOfHostStorageOperationalInfo)(nil)).Elem()
}

// A boxed array of `HostStorageSystemDiskLocatorLedResult`. To be used in `Any` placeholders.
type ArrayOfHostStorageSystemDiskLocatorLedResult struct {
	HostStorageSystemDiskLocatorLedResult []HostStorageSystemDiskLocatorLedResult `xml:"HostStorageSystemDiskLocatorLedResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostStorageSystemDiskLocatorLedResult"] = reflect.TypeOf((*ArrayOfHostStorageSystemDiskLocatorLedResult)(nil)).Elem()
}

// A boxed array of `HostStorageSystemScsiLunResult`. To be used in `Any` placeholders.
type ArrayOfHostStorageSystemScsiLunResult struct {
	HostStorageSystemScsiLunResult []HostStorageSystemScsiLunResult `xml:"HostStorageSystemScsiLunResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostStorageSystemScsiLunResult"] = reflect.TypeOf((*ArrayOfHostStorageSystemScsiLunResult)(nil)).Elem()
}

// A boxed array of `HostStorageSystemVmfsVolumeResult`. To be used in `Any` placeholders.
type ArrayOfHostStorageSystemVmfsVolumeResult struct {
	HostStorageSystemVmfsVolumeResult []HostStorageSystemVmfsVolumeResult `xml:"HostStorageSystemVmfsVolumeResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostStorageSystemVmfsVolumeResult"] = reflect.TypeOf((*ArrayOfHostStorageSystemVmfsVolumeResult)(nil)).Elem()
}

// A boxed array of `HostSubSpecification`. To be used in `Any` placeholders.
type ArrayOfHostSubSpecification struct {
	HostSubSpecification []HostSubSpecification `xml:"HostSubSpecification,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostSubSpecification"] = reflect.TypeOf((*ArrayOfHostSubSpecification)(nil)).Elem()
}

// A boxed array of `HostSystemIdentificationInfo`. To be used in `Any` placeholders.
type ArrayOfHostSystemIdentificationInfo struct {
	HostSystemIdentificationInfo []HostSystemIdentificationInfo `xml:"HostSystemIdentificationInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostSystemIdentificationInfo"] = reflect.TypeOf((*ArrayOfHostSystemIdentificationInfo)(nil)).Elem()
}

// A boxed array of `HostSystemResourceInfo`. To be used in `Any` placeholders.
type ArrayOfHostSystemResourceInfo struct {
	HostSystemResourceInfo []HostSystemResourceInfo `xml:"HostSystemResourceInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostSystemResourceInfo"] = reflect.TypeOf((*ArrayOfHostSystemResourceInfo)(nil)).Elem()
}

// A boxed array of `HostSystemSwapConfigurationSystemSwapOption`. To be used in `Any` placeholders.
type ArrayOfHostSystemSwapConfigurationSystemSwapOption struct {
	HostSystemSwapConfigurationSystemSwapOption []BaseHostSystemSwapConfigurationSystemSwapOption `xml:"HostSystemSwapConfigurationSystemSwapOption,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfHostSystemSwapConfigurationSystemSwapOption"] = reflect.TypeOf((*ArrayOfHostSystemSwapConfigurationSystemSwapOption)(nil)).Elem()
}

// A boxed array of `HostTpmDigestInfo`. To be used in `Any` placeholders.
type ArrayOfHostTpmDigestInfo struct {
	HostTpmDigestInfo []HostTpmDigestInfo `xml:"HostTpmDigestInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostTpmDigestInfo"] = reflect.TypeOf((*ArrayOfHostTpmDigestInfo)(nil)).Elem()
}

// A boxed array of `HostTpmEventLogEntry`. To be used in `Any` placeholders.
type ArrayOfHostTpmEventLogEntry struct {
	HostTpmEventLogEntry []HostTpmEventLogEntry `xml:"HostTpmEventLogEntry,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostTpmEventLogEntry"] = reflect.TypeOf((*ArrayOfHostTpmEventLogEntry)(nil)).Elem()
}

// A boxed array of `HostTrustAuthorityAttestationInfo`. To be used in `Any` placeholders.
type ArrayOfHostTrustAuthorityAttestationInfo struct {
	HostTrustAuthorityAttestationInfo []HostTrustAuthorityAttestationInfo `xml:"HostTrustAuthorityAttestationInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostTrustAuthorityAttestationInfo"] = reflect.TypeOf((*ArrayOfHostTrustAuthorityAttestationInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfHostTrustAuthorityAttestationInfo"] = "7.0.1.0"
}

// A boxed array of `HostUnresolvedVmfsExtent`. To be used in `Any` placeholders.
type ArrayOfHostUnresolvedVmfsExtent struct {
	HostUnresolvedVmfsExtent []HostUnresolvedVmfsExtent `xml:"HostUnresolvedVmfsExtent,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostUnresolvedVmfsExtent"] = reflect.TypeOf((*ArrayOfHostUnresolvedVmfsExtent)(nil)).Elem()
}

// A boxed array of `HostUnresolvedVmfsResolutionResult`. To be used in `Any` placeholders.
type ArrayOfHostUnresolvedVmfsResolutionResult struct {
	HostUnresolvedVmfsResolutionResult []HostUnresolvedVmfsResolutionResult `xml:"HostUnresolvedVmfsResolutionResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostUnresolvedVmfsResolutionResult"] = reflect.TypeOf((*ArrayOfHostUnresolvedVmfsResolutionResult)(nil)).Elem()
}

// A boxed array of `HostUnresolvedVmfsResolutionSpec`. To be used in `Any` placeholders.
type ArrayOfHostUnresolvedVmfsResolutionSpec struct {
	HostUnresolvedVmfsResolutionSpec []HostUnresolvedVmfsResolutionSpec `xml:"HostUnresolvedVmfsResolutionSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostUnresolvedVmfsResolutionSpec"] = reflect.TypeOf((*ArrayOfHostUnresolvedVmfsResolutionSpec)(nil)).Elem()
}

// A boxed array of `HostUnresolvedVmfsVolume`. To be used in `Any` placeholders.
type ArrayOfHostUnresolvedVmfsVolume struct {
	HostUnresolvedVmfsVolume []HostUnresolvedVmfsVolume `xml:"HostUnresolvedVmfsVolume,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostUnresolvedVmfsVolume"] = reflect.TypeOf((*ArrayOfHostUnresolvedVmfsVolume)(nil)).Elem()
}

// A boxed array of `HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption`. To be used in `Any` placeholders.
type ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption struct {
	HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption []HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption `xml:"HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption"] = reflect.TypeOf((*ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption)(nil)).Elem()
}

// A boxed array of `HostVMotionCompatibility`. To be used in `Any` placeholders.
type ArrayOfHostVMotionCompatibility struct {
	HostVMotionCompatibility []HostVMotionCompatibility `xml:"HostVMotionCompatibility,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVMotionCompatibility"] = reflect.TypeOf((*ArrayOfHostVMotionCompatibility)(nil)).Elem()
}

// A boxed array of `HostVirtualNic`. To be used in `Any` placeholders.
type ArrayOfHostVirtualNic struct {
	HostVirtualNic []HostVirtualNic `xml:"HostVirtualNic,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVirtualNic"] = reflect.TypeOf((*ArrayOfHostVirtualNic)(nil)).Elem()
}

// A boxed array of `HostVirtualNicConfig`. To be used in `Any` placeholders.
type ArrayOfHostVirtualNicConfig struct {
	HostVirtualNicConfig []HostVirtualNicConfig `xml:"HostVirtualNicConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVirtualNicConfig"] = reflect.TypeOf((*ArrayOfHostVirtualNicConfig)(nil)).Elem()
}

// A boxed array of `HostVirtualNicManagerNicTypeSelection`. To be used in `Any` placeholders.
type ArrayOfHostVirtualNicManagerNicTypeSelection struct {
	HostVirtualNicManagerNicTypeSelection []HostVirtualNicManagerNicTypeSelection `xml:"HostVirtualNicManagerNicTypeSelection,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVirtualNicManagerNicTypeSelection"] = reflect.TypeOf((*ArrayOfHostVirtualNicManagerNicTypeSelection)(nil)).Elem()
}

// A boxed array of `HostVirtualSwitch`. To be used in `Any` placeholders.
type ArrayOfHostVirtualSwitch struct {
	HostVirtualSwitch []HostVirtualSwitch `xml:"HostVirtualSwitch,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVirtualSwitch"] = reflect.TypeOf((*ArrayOfHostVirtualSwitch)(nil)).Elem()
}

// A boxed array of `HostVirtualSwitchConfig`. To be used in `Any` placeholders.
type ArrayOfHostVirtualSwitchConfig struct {
	HostVirtualSwitchConfig []HostVirtualSwitchConfig `xml:"HostVirtualSwitchConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVirtualSwitchConfig"] = reflect.TypeOf((*ArrayOfHostVirtualSwitchConfig)(nil)).Elem()
}

// A boxed array of `HostVmciAccessManagerAccessSpec`. To be used in `Any` placeholders.
type ArrayOfHostVmciAccessManagerAccessSpec struct {
	HostVmciAccessManagerAccessSpec []HostVmciAccessManagerAccessSpec `xml:"HostVmciAccessManagerAccessSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVmciAccessManagerAccessSpec"] = reflect.TypeOf((*ArrayOfHostVmciAccessManagerAccessSpec)(nil)).Elem()
}

// A boxed array of `HostVmfsRescanResult`. To be used in `Any` placeholders.
type ArrayOfHostVmfsRescanResult struct {
	HostVmfsRescanResult []HostVmfsRescanResult `xml:"HostVmfsRescanResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVmfsRescanResult"] = reflect.TypeOf((*ArrayOfHostVmfsRescanResult)(nil)).Elem()
}

// A boxed array of `HostVsanInternalSystemCmmdsQuery`. To be used in `Any` placeholders.
type ArrayOfHostVsanInternalSystemCmmdsQuery struct {
	HostVsanInternalSystemCmmdsQuery []HostVsanInternalSystemCmmdsQuery `xml:"HostVsanInternalSystemCmmdsQuery,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVsanInternalSystemCmmdsQuery"] = reflect.TypeOf((*ArrayOfHostVsanInternalSystemCmmdsQuery)(nil)).Elem()
}

// A boxed array of `HostVsanInternalSystemDeleteVsanObjectsResult`. To be used in `Any` placeholders.
type ArrayOfHostVsanInternalSystemDeleteVsanObjectsResult struct {
	HostVsanInternalSystemDeleteVsanObjectsResult []HostVsanInternalSystemDeleteVsanObjectsResult `xml:"HostVsanInternalSystemDeleteVsanObjectsResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVsanInternalSystemDeleteVsanObjectsResult"] = reflect.TypeOf((*ArrayOfHostVsanInternalSystemDeleteVsanObjectsResult)(nil)).Elem()
}

// A boxed array of `HostVsanInternalSystemVsanObjectOperationResult`. To be used in `Any` placeholders.
type ArrayOfHostVsanInternalSystemVsanObjectOperationResult struct {
	HostVsanInternalSystemVsanObjectOperationResult []HostVsanInternalSystemVsanObjectOperationResult `xml:"HostVsanInternalSystemVsanObjectOperationResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVsanInternalSystemVsanObjectOperationResult"] = reflect.TypeOf((*ArrayOfHostVsanInternalSystemVsanObjectOperationResult)(nil)).Elem()
}

// A boxed array of `HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult`. To be used in `Any` placeholders.
type ArrayOfHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult struct {
	HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult []HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult `xml:"HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult"] = reflect.TypeOf((*ArrayOfHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult)(nil)).Elem()
}

// A boxed array of `HostVvolNQN`. To be used in `Any` placeholders.
type ArrayOfHostVvolNQN struct {
	HostVvolNQN []HostVvolNQN `xml:"HostVvolNQN,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVvolNQN"] = reflect.TypeOf((*ArrayOfHostVvolNQN)(nil)).Elem()
	minAPIVersionForType["ArrayOfHostVvolNQN"] = "8.0.2.0"
}

// A boxed array of `HostVvolVolumeHostVvolNQN`. To be used in `Any` placeholders.
type ArrayOfHostVvolVolumeHostVvolNQN struct {
	HostVvolVolumeHostVvolNQN []HostVvolVolumeHostVvolNQN `xml:"HostVvolVolumeHostVvolNQN,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHostVvolVolumeHostVvolNQN"] = reflect.TypeOf((*ArrayOfHostVvolVolumeHostVvolNQN)(nil)).Elem()
	minAPIVersionForType["ArrayOfHostVvolVolumeHostVvolNQN"] = "8.0.2.0"
}

// A boxed array of `HttpNfcLeaseDatastoreLeaseInfo`. To be used in `Any` placeholders.
type ArrayOfHttpNfcLeaseDatastoreLeaseInfo struct {
	HttpNfcLeaseDatastoreLeaseInfo []HttpNfcLeaseDatastoreLeaseInfo `xml:"HttpNfcLeaseDatastoreLeaseInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHttpNfcLeaseDatastoreLeaseInfo"] = reflect.TypeOf((*ArrayOfHttpNfcLeaseDatastoreLeaseInfo)(nil)).Elem()
}

// A boxed array of `HttpNfcLeaseDeviceUrl`. To be used in `Any` placeholders.
type ArrayOfHttpNfcLeaseDeviceUrl struct {
	HttpNfcLeaseDeviceUrl []HttpNfcLeaseDeviceUrl `xml:"HttpNfcLeaseDeviceUrl,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHttpNfcLeaseDeviceUrl"] = reflect.TypeOf((*ArrayOfHttpNfcLeaseDeviceUrl)(nil)).Elem()
}

// A boxed array of `HttpNfcLeaseHostInfo`. To be used in `Any` placeholders.
type ArrayOfHttpNfcLeaseHostInfo struct {
	HttpNfcLeaseHostInfo []HttpNfcLeaseHostInfo `xml:"HttpNfcLeaseHostInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHttpNfcLeaseHostInfo"] = reflect.TypeOf((*ArrayOfHttpNfcLeaseHostInfo)(nil)).Elem()
}

// A boxed array of `HttpNfcLeaseManifestEntry`. To be used in `Any` placeholders.
type ArrayOfHttpNfcLeaseManifestEntry struct {
	HttpNfcLeaseManifestEntry []HttpNfcLeaseManifestEntry `xml:"HttpNfcLeaseManifestEntry,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHttpNfcLeaseManifestEntry"] = reflect.TypeOf((*ArrayOfHttpNfcLeaseManifestEntry)(nil)).Elem()
}

// A boxed array of `HttpNfcLeaseProbeResult`. To be used in `Any` placeholders.
type ArrayOfHttpNfcLeaseProbeResult struct {
	HttpNfcLeaseProbeResult []HttpNfcLeaseProbeResult `xml:"HttpNfcLeaseProbeResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHttpNfcLeaseProbeResult"] = reflect.TypeOf((*ArrayOfHttpNfcLeaseProbeResult)(nil)).Elem()
	minAPIVersionForType["ArrayOfHttpNfcLeaseProbeResult"] = "7.0.2.0"
}

// A boxed array of `HttpNfcLeaseSourceFile`. To be used in `Any` placeholders.
type ArrayOfHttpNfcLeaseSourceFile struct {
	HttpNfcLeaseSourceFile []HttpNfcLeaseSourceFile `xml:"HttpNfcLeaseSourceFile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfHttpNfcLeaseSourceFile"] = reflect.TypeOf((*ArrayOfHttpNfcLeaseSourceFile)(nil)).Elem()
}

// A boxed array of `ID`. To be used in `Any` placeholders.
type ArrayOfID struct {
	ID []ID `xml:"ID,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfID"] = reflect.TypeOf((*ArrayOfID)(nil)).Elem()
}

// A boxed array of `ImportOperationBulkFaultFaultOnImport`. To be used in `Any` placeholders.
type ArrayOfImportOperationBulkFaultFaultOnImport struct {
	ImportOperationBulkFaultFaultOnImport []ImportOperationBulkFaultFaultOnImport `xml:"ImportOperationBulkFaultFaultOnImport,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfImportOperationBulkFaultFaultOnImport"] = reflect.TypeOf((*ArrayOfImportOperationBulkFaultFaultOnImport)(nil)).Elem()
}

// A boxed array of `ImportSpec`. To be used in `Any` placeholders.
type ArrayOfImportSpec struct {
	ImportSpec []BaseImportSpec `xml:"ImportSpec,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfImportSpec"] = reflect.TypeOf((*ArrayOfImportSpec)(nil)).Elem()
}

// A boxed array of `PrimitiveInt`. To be used in `Any` placeholders.
type ArrayOfInt struct {
	Int []int32 `xml:"int,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfInt"] = reflect.TypeOf((*ArrayOfInt)(nil)).Elem()
}

// A boxed array of `IoFilterHostIssue`. To be used in `Any` placeholders.
type ArrayOfIoFilterHostIssue struct {
	IoFilterHostIssue []IoFilterHostIssue `xml:"IoFilterHostIssue,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfIoFilterHostIssue"] = reflect.TypeOf((*ArrayOfIoFilterHostIssue)(nil)).Elem()
}

// A boxed array of `IpPool`. To be used in `Any` placeholders.
type ArrayOfIpPool struct {
	IpPool []IpPool `xml:"IpPool,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfIpPool"] = reflect.TypeOf((*ArrayOfIpPool)(nil)).Elem()
}

// A boxed array of `IpPoolAssociation`. To be used in `Any` placeholders.
type ArrayOfIpPoolAssociation struct {
	IpPoolAssociation []IpPoolAssociation `xml:"IpPoolAssociation,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfIpPoolAssociation"] = reflect.TypeOf((*ArrayOfIpPoolAssociation)(nil)).Elem()
}

// A boxed array of `IpPoolManagerIpAllocation`. To be used in `Any` placeholders.
type ArrayOfIpPoolManagerIpAllocation struct {
	IpPoolManagerIpAllocation []IpPoolManagerIpAllocation `xml:"IpPoolManagerIpAllocation,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfIpPoolManagerIpAllocation"] = reflect.TypeOf((*ArrayOfIpPoolManagerIpAllocation)(nil)).Elem()
}

// A boxed array of `IscsiDependencyEntity`. To be used in `Any` placeholders.
type ArrayOfIscsiDependencyEntity struct {
	IscsiDependencyEntity []IscsiDependencyEntity `xml:"IscsiDependencyEntity,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfIscsiDependencyEntity"] = reflect.TypeOf((*ArrayOfIscsiDependencyEntity)(nil)).Elem()
}

// A boxed array of `IscsiPortInfo`. To be used in `Any` placeholders.
type ArrayOfIscsiPortInfo struct {
	IscsiPortInfo []IscsiPortInfo `xml:"IscsiPortInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfIscsiPortInfo"] = reflect.TypeOf((*ArrayOfIscsiPortInfo)(nil)).Elem()
}

// A boxed array of `KernelModuleInfo`. To be used in `Any` placeholders.
type ArrayOfKernelModuleInfo struct {
	KernelModuleInfo []KernelModuleInfo `xml:"KernelModuleInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfKernelModuleInfo"] = reflect.TypeOf((*ArrayOfKernelModuleInfo)(nil)).Elem()
}

// A boxed array of `KeyAnyValue`. To be used in `Any` placeholders.
type ArrayOfKeyAnyValue struct {
	KeyAnyValue []KeyAnyValue `xml:"KeyAnyValue,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfKeyAnyValue"] = reflect.TypeOf((*ArrayOfKeyAnyValue)(nil)).Elem()
}

// A boxed array of `KeyValue`. To be used in `Any` placeholders.
type ArrayOfKeyValue struct {
	KeyValue []KeyValue `xml:"KeyValue,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfKeyValue"] = reflect.TypeOf((*ArrayOfKeyValue)(nil)).Elem()
}

// A boxed array of `KmipClusterInfo`. To be used in `Any` placeholders.
type ArrayOfKmipClusterInfo struct {
	KmipClusterInfo []KmipClusterInfo `xml:"KmipClusterInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfKmipClusterInfo"] = reflect.TypeOf((*ArrayOfKmipClusterInfo)(nil)).Elem()
}

// A boxed array of `KmipServerInfo`. To be used in `Any` placeholders.
type ArrayOfKmipServerInfo struct {
	KmipServerInfo []KmipServerInfo `xml:"KmipServerInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfKmipServerInfo"] = reflect.TypeOf((*ArrayOfKmipServerInfo)(nil)).Elem()
}

// A boxed array of `LicenseAssignmentManagerLicenseAssignment`. To be used in `Any` placeholders.
type ArrayOfLicenseAssignmentManagerLicenseAssignment struct {
	LicenseAssignmentManagerLicenseAssignment []LicenseAssignmentManagerLicenseAssignment `xml:"LicenseAssignmentManagerLicenseAssignment,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfLicenseAssignmentManagerLicenseAssignment"] = reflect.TypeOf((*ArrayOfLicenseAssignmentManagerLicenseAssignment)(nil)).Elem()
}

// A boxed array of `LicenseAvailabilityInfo`. To be used in `Any` placeholders.
type ArrayOfLicenseAvailabilityInfo struct {
	LicenseAvailabilityInfo []LicenseAvailabilityInfo `xml:"LicenseAvailabilityInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfLicenseAvailabilityInfo"] = reflect.TypeOf((*ArrayOfLicenseAvailabilityInfo)(nil)).Elem()
}

// A boxed array of `LicenseFeatureInfo`. To be used in `Any` placeholders.
type ArrayOfLicenseFeatureInfo struct {
	LicenseFeatureInfo []LicenseFeatureInfo `xml:"LicenseFeatureInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfLicenseFeatureInfo"] = reflect.TypeOf((*ArrayOfLicenseFeatureInfo)(nil)).Elem()
}

// A boxed array of `LicenseManagerLicenseInfo`. To be used in `Any` placeholders.
type ArrayOfLicenseManagerLicenseInfo struct {
	LicenseManagerLicenseInfo []LicenseManagerLicenseInfo `xml:"LicenseManagerLicenseInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfLicenseManagerLicenseInfo"] = reflect.TypeOf((*ArrayOfLicenseManagerLicenseInfo)(nil)).Elem()
}

// A boxed array of `LicenseReservationInfo`. To be used in `Any` placeholders.
type ArrayOfLicenseReservationInfo struct {
	LicenseReservationInfo []LicenseReservationInfo `xml:"LicenseReservationInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfLicenseReservationInfo"] = reflect.TypeOf((*ArrayOfLicenseReservationInfo)(nil)).Elem()
}

// A boxed array of `LocalizableMessage`. To be used in `Any` placeholders.
type ArrayOfLocalizableMessage struct {
	LocalizableMessage []LocalizableMessage `xml:"LocalizableMessage,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfLocalizableMessage"] = reflect.TypeOf((*ArrayOfLocalizableMessage)(nil)).Elem()
}

// A boxed array of `LocalizationManagerMessageCatalog`. To be used in `Any` placeholders.
type ArrayOfLocalizationManagerMessageCatalog struct {
	LocalizationManagerMessageCatalog []LocalizationManagerMessageCatalog `xml:"LocalizationManagerMessageCatalog,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfLocalizationManagerMessageCatalog"] = reflect.TypeOf((*ArrayOfLocalizationManagerMessageCatalog)(nil)).Elem()
}

// A boxed array of `PrimitiveLong`. To be used in `Any` placeholders.
type ArrayOfLong struct {
	Long []int64 `xml:"long,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfLong"] = reflect.TypeOf((*ArrayOfLong)(nil)).Elem()
}

// A boxed array of `ManagedEntityStatus_enum`. To be used in `Any` placeholders.
type ArrayOfManagedEntityStatus struct {
	ManagedEntityStatus []ManagedEntityStatus `xml:"ManagedEntityStatus,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfManagedEntityStatus"] = reflect.TypeOf((*ArrayOfManagedEntityStatus)(nil)).Elem()
}

// A boxed array of `ManagedObjectReference`. To be used in `Any` placeholders.
type ArrayOfManagedObjectReference struct {
	ManagedObjectReference []ManagedObjectReference `xml:"ManagedObjectReference,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfManagedObjectReference"] = reflect.TypeOf((*ArrayOfManagedObjectReference)(nil)).Elem()
}

// A boxed array of `MethodActionArgument`. To be used in `Any` placeholders.
type ArrayOfMethodActionArgument struct {
	MethodActionArgument []MethodActionArgument `xml:"MethodActionArgument,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfMethodActionArgument"] = reflect.TypeOf((*ArrayOfMethodActionArgument)(nil)).Elem()
}

// A boxed array of `MethodFault`. To be used in `Any` placeholders.
type ArrayOfMethodFault struct {
	MethodFault []BaseMethodFault `xml:"MethodFault,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfMethodFault"] = reflect.TypeOf((*ArrayOfMethodFault)(nil)).Elem()
}

// A boxed array of `MissingObject`. To be used in `Any` placeholders.
type ArrayOfMissingObject struct {
	MissingObject []MissingObject `xml:"MissingObject,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfMissingObject"] = reflect.TypeOf((*ArrayOfMissingObject)(nil)).Elem()
}

// A boxed array of `MissingProperty`. To be used in `Any` placeholders.
type ArrayOfMissingProperty struct {
	MissingProperty []MissingProperty `xml:"MissingProperty,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfMissingProperty"] = reflect.TypeOf((*ArrayOfMissingProperty)(nil)).Elem()
}

// A boxed array of `MultipleCertificatesVerifyFaultThumbprintData`. To be used in `Any` placeholders.
type ArrayOfMultipleCertificatesVerifyFaultThumbprintData struct {
	MultipleCertificatesVerifyFaultThumbprintData []MultipleCertificatesVerifyFaultThumbprintData `xml:"MultipleCertificatesVerifyFaultThumbprintData,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfMultipleCertificatesVerifyFaultThumbprintData"] = reflect.TypeOf((*ArrayOfMultipleCertificatesVerifyFaultThumbprintData)(nil)).Elem()
}

// A boxed array of `NasStorageProfile`. To be used in `Any` placeholders.
type ArrayOfNasStorageProfile struct {
	NasStorageProfile []NasStorageProfile `xml:"NasStorageProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNasStorageProfile"] = reflect.TypeOf((*ArrayOfNasStorageProfile)(nil)).Elem()
}

// A boxed array of `NetIpConfigInfoIpAddress`. To be used in `Any` placeholders.
type ArrayOfNetIpConfigInfoIpAddress struct {
	NetIpConfigInfoIpAddress []NetIpConfigInfoIpAddress `xml:"NetIpConfigInfoIpAddress,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNetIpConfigInfoIpAddress"] = reflect.TypeOf((*ArrayOfNetIpConfigInfoIpAddress)(nil)).Elem()
}

// A boxed array of `NetIpConfigSpecIpAddressSpec`. To be used in `Any` placeholders.
type ArrayOfNetIpConfigSpecIpAddressSpec struct {
	NetIpConfigSpecIpAddressSpec []NetIpConfigSpecIpAddressSpec `xml:"NetIpConfigSpecIpAddressSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNetIpConfigSpecIpAddressSpec"] = reflect.TypeOf((*ArrayOfNetIpConfigSpecIpAddressSpec)(nil)).Elem()
}

// A boxed array of `NetIpRouteConfigInfoIpRoute`. To be used in `Any` placeholders.
type ArrayOfNetIpRouteConfigInfoIpRoute struct {
	NetIpRouteConfigInfoIpRoute []NetIpRouteConfigInfoIpRoute `xml:"NetIpRouteConfigInfoIpRoute,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNetIpRouteConfigInfoIpRoute"] = reflect.TypeOf((*ArrayOfNetIpRouteConfigInfoIpRoute)(nil)).Elem()
}

// A boxed array of `NetIpRouteConfigSpecIpRouteSpec`. To be used in `Any` placeholders.
type ArrayOfNetIpRouteConfigSpecIpRouteSpec struct {
	NetIpRouteConfigSpecIpRouteSpec []NetIpRouteConfigSpecIpRouteSpec `xml:"NetIpRouteConfigSpecIpRouteSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNetIpRouteConfigSpecIpRouteSpec"] = reflect.TypeOf((*ArrayOfNetIpRouteConfigSpecIpRouteSpec)(nil)).Elem()
}

// A boxed array of `NetIpStackInfoDefaultRouter`. To be used in `Any` placeholders.
type ArrayOfNetIpStackInfoDefaultRouter struct {
	NetIpStackInfoDefaultRouter []NetIpStackInfoDefaultRouter `xml:"NetIpStackInfoDefaultRouter,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNetIpStackInfoDefaultRouter"] = reflect.TypeOf((*ArrayOfNetIpStackInfoDefaultRouter)(nil)).Elem()
}

// A boxed array of `NetIpStackInfoNetToMedia`. To be used in `Any` placeholders.
type ArrayOfNetIpStackInfoNetToMedia struct {
	NetIpStackInfoNetToMedia []NetIpStackInfoNetToMedia `xml:"NetIpStackInfoNetToMedia,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNetIpStackInfoNetToMedia"] = reflect.TypeOf((*ArrayOfNetIpStackInfoNetToMedia)(nil)).Elem()
}

// A boxed array of `NetStackInstanceProfile`. To be used in `Any` placeholders.
type ArrayOfNetStackInstanceProfile struct {
	NetStackInstanceProfile []NetStackInstanceProfile `xml:"NetStackInstanceProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNetStackInstanceProfile"] = reflect.TypeOf((*ArrayOfNetStackInstanceProfile)(nil)).Elem()
}

// A boxed array of `NoPermissionEntityPrivileges`. To be used in `Any` placeholders.
type ArrayOfNoPermissionEntityPrivileges struct {
	NoPermissionEntityPrivileges []NoPermissionEntityPrivileges `xml:"NoPermissionEntityPrivileges,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNoPermissionEntityPrivileges"] = reflect.TypeOf((*ArrayOfNoPermissionEntityPrivileges)(nil)).Elem()
	minAPIVersionForType["ArrayOfNoPermissionEntityPrivileges"] = "7.0.3.2"
}

// A boxed array of `NsxHostVNicProfile`. To be used in `Any` placeholders.
type ArrayOfNsxHostVNicProfile struct {
	NsxHostVNicProfile []NsxHostVNicProfile `xml:"NsxHostVNicProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNsxHostVNicProfile"] = reflect.TypeOf((*ArrayOfNsxHostVNicProfile)(nil)).Elem()
}

// A boxed array of `NumericRange`. To be used in `Any` placeholders.
type ArrayOfNumericRange struct {
	NumericRange []NumericRange `xml:"NumericRange,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNumericRange"] = reflect.TypeOf((*ArrayOfNumericRange)(nil)).Elem()
}

// A boxed array of `NvdimmDimmInfo`. To be used in `Any` placeholders.
type ArrayOfNvdimmDimmInfo struct {
	NvdimmDimmInfo []NvdimmDimmInfo `xml:"NvdimmDimmInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNvdimmDimmInfo"] = reflect.TypeOf((*ArrayOfNvdimmDimmInfo)(nil)).Elem()
}

// A boxed array of `NvdimmGuid`. To be used in `Any` placeholders.
type ArrayOfNvdimmGuid struct {
	NvdimmGuid []NvdimmGuid `xml:"NvdimmGuid,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNvdimmGuid"] = reflect.TypeOf((*ArrayOfNvdimmGuid)(nil)).Elem()
}

// A boxed array of `NvdimmInterleaveSetInfo`. To be used in `Any` placeholders.
type ArrayOfNvdimmInterleaveSetInfo struct {
	NvdimmInterleaveSetInfo []NvdimmInterleaveSetInfo `xml:"NvdimmInterleaveSetInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNvdimmInterleaveSetInfo"] = reflect.TypeOf((*ArrayOfNvdimmInterleaveSetInfo)(nil)).Elem()
}

// A boxed array of `NvdimmNamespaceDetails`. To be used in `Any` placeholders.
type ArrayOfNvdimmNamespaceDetails struct {
	NvdimmNamespaceDetails []NvdimmNamespaceDetails `xml:"NvdimmNamespaceDetails,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNvdimmNamespaceDetails"] = reflect.TypeOf((*ArrayOfNvdimmNamespaceDetails)(nil)).Elem()
}

// A boxed array of `NvdimmNamespaceInfo`. To be used in `Any` placeholders.
type ArrayOfNvdimmNamespaceInfo struct {
	NvdimmNamespaceInfo []NvdimmNamespaceInfo `xml:"NvdimmNamespaceInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNvdimmNamespaceInfo"] = reflect.TypeOf((*ArrayOfNvdimmNamespaceInfo)(nil)).Elem()
}

// A boxed array of `NvdimmRegionInfo`. To be used in `Any` placeholders.
type ArrayOfNvdimmRegionInfo struct {
	NvdimmRegionInfo []NvdimmRegionInfo `xml:"NvdimmRegionInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfNvdimmRegionInfo"] = reflect.TypeOf((*ArrayOfNvdimmRegionInfo)(nil)).Elem()
}

// A boxed array of `ObjectContent`. To be used in `Any` placeholders.
type ArrayOfObjectContent struct {
	ObjectContent []ObjectContent `xml:"ObjectContent,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfObjectContent"] = reflect.TypeOf((*ArrayOfObjectContent)(nil)).Elem()
}

// A boxed array of `ObjectSpec`. To be used in `Any` placeholders.
type ArrayOfObjectSpec struct {
	ObjectSpec []ObjectSpec `xml:"ObjectSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfObjectSpec"] = reflect.TypeOf((*ArrayOfObjectSpec)(nil)).Elem()
}

// A boxed array of `ObjectUpdate`. To be used in `Any` placeholders.
type ArrayOfObjectUpdate struct {
	ObjectUpdate []ObjectUpdate `xml:"ObjectUpdate,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfObjectUpdate"] = reflect.TypeOf((*ArrayOfObjectUpdate)(nil)).Elem()
}

// A boxed array of `OpaqueNetworkTargetInfo`. To be used in `Any` placeholders.
type ArrayOfOpaqueNetworkTargetInfo struct {
	OpaqueNetworkTargetInfo []OpaqueNetworkTargetInfo `xml:"OpaqueNetworkTargetInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfOpaqueNetworkTargetInfo"] = reflect.TypeOf((*ArrayOfOpaqueNetworkTargetInfo)(nil)).Elem()
}

// A boxed array of `OptionDef`. To be used in `Any` placeholders.
type ArrayOfOptionDef struct {
	OptionDef []OptionDef `xml:"OptionDef,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfOptionDef"] = reflect.TypeOf((*ArrayOfOptionDef)(nil)).Elem()
}

// A boxed array of `OptionProfile`. To be used in `Any` placeholders.
type ArrayOfOptionProfile struct {
	OptionProfile []OptionProfile `xml:"OptionProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfOptionProfile"] = reflect.TypeOf((*ArrayOfOptionProfile)(nil)).Elem()
}

// A boxed array of `OptionValue`. To be used in `Any` placeholders.
type ArrayOfOptionValue struct {
	OptionValue []BaseOptionValue `xml:"OptionValue,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfOptionValue"] = reflect.TypeOf((*ArrayOfOptionValue)(nil)).Elem()
}

// A boxed array of `OvfConsumerOstNode`. To be used in `Any` placeholders.
type ArrayOfOvfConsumerOstNode struct {
	OvfConsumerOstNode []OvfConsumerOstNode `xml:"OvfConsumerOstNode,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfOvfConsumerOstNode"] = reflect.TypeOf((*ArrayOfOvfConsumerOstNode)(nil)).Elem()
}

// A boxed array of `OvfConsumerOvfSection`. To be used in `Any` placeholders.
type ArrayOfOvfConsumerOvfSection struct {
	OvfConsumerOvfSection []OvfConsumerOvfSection `xml:"OvfConsumerOvfSection,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfOvfConsumerOvfSection"] = reflect.TypeOf((*ArrayOfOvfConsumerOvfSection)(nil)).Elem()
}

// A boxed array of `OvfDeploymentOption`. To be used in `Any` placeholders.
type ArrayOfOvfDeploymentOption struct {
	OvfDeploymentOption []OvfDeploymentOption `xml:"OvfDeploymentOption,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfOvfDeploymentOption"] = reflect.TypeOf((*ArrayOfOvfDeploymentOption)(nil)).Elem()
}

// A boxed array of `OvfFile`. To be used in `Any` placeholders.
type ArrayOfOvfFile struct {
	OvfFile []OvfFile `xml:"OvfFile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfOvfFile"] = reflect.TypeOf((*ArrayOfOvfFile)(nil)).Elem()
}

// A boxed array of `OvfFileItem`. To be used in `Any` placeholders.
type ArrayOfOvfFileItem struct {
	OvfFileItem []OvfFileItem `xml:"OvfFileItem,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfOvfFileItem"] = reflect.TypeOf((*ArrayOfOvfFileItem)(nil)).Elem()
}

// A boxed array of `OvfNetworkInfo`. To be used in `Any` placeholders.
type ArrayOfOvfNetworkInfo struct {
	OvfNetworkInfo []OvfNetworkInfo `xml:"OvfNetworkInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfOvfNetworkInfo"] = reflect.TypeOf((*ArrayOfOvfNetworkInfo)(nil)).Elem()
}

// A boxed array of `OvfNetworkMapping`. To be used in `Any` placeholders.
type ArrayOfOvfNetworkMapping struct {
	OvfNetworkMapping []OvfNetworkMapping `xml:"OvfNetworkMapping,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfOvfNetworkMapping"] = reflect.TypeOf((*ArrayOfOvfNetworkMapping)(nil)).Elem()
}

// A boxed array of `OvfOptionInfo`. To be used in `Any` placeholders.
type ArrayOfOvfOptionInfo struct {
	OvfOptionInfo []OvfOptionInfo `xml:"OvfOptionInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfOvfOptionInfo"] = reflect.TypeOf((*ArrayOfOvfOptionInfo)(nil)).Elem()
}

// A boxed array of `OvfResourceMap`. To be used in `Any` placeholders.
type ArrayOfOvfResourceMap struct {
	OvfResourceMap []OvfResourceMap `xml:"OvfResourceMap,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfOvfResourceMap"] = reflect.TypeOf((*ArrayOfOvfResourceMap)(nil)).Elem()
}

// A boxed array of `PerfCounterInfo`. To be used in `Any` placeholders.
type ArrayOfPerfCounterInfo struct {
	PerfCounterInfo []PerfCounterInfo `xml:"PerfCounterInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPerfCounterInfo"] = reflect.TypeOf((*ArrayOfPerfCounterInfo)(nil)).Elem()
}

// A boxed array of `PerfEntityMetricBase`. To be used in `Any` placeholders.
type ArrayOfPerfEntityMetricBase struct {
	PerfEntityMetricBase []BasePerfEntityMetricBase `xml:"PerfEntityMetricBase,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfPerfEntityMetricBase"] = reflect.TypeOf((*ArrayOfPerfEntityMetricBase)(nil)).Elem()
}

// A boxed array of `PerfInterval`. To be used in `Any` placeholders.
type ArrayOfPerfInterval struct {
	PerfInterval []PerfInterval `xml:"PerfInterval,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPerfInterval"] = reflect.TypeOf((*ArrayOfPerfInterval)(nil)).Elem()
}

// A boxed array of `PerfMetricId`. To be used in `Any` placeholders.
type ArrayOfPerfMetricId struct {
	PerfMetricId []PerfMetricId `xml:"PerfMetricId,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPerfMetricId"] = reflect.TypeOf((*ArrayOfPerfMetricId)(nil)).Elem()
}

// A boxed array of `PerfMetricSeries`. To be used in `Any` placeholders.
type ArrayOfPerfMetricSeries struct {
	PerfMetricSeries []BasePerfMetricSeries `xml:"PerfMetricSeries,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfPerfMetricSeries"] = reflect.TypeOf((*ArrayOfPerfMetricSeries)(nil)).Elem()
}

// A boxed array of `PerfMetricSeriesCSV`. To be used in `Any` placeholders.
type ArrayOfPerfMetricSeriesCSV struct {
	PerfMetricSeriesCSV []PerfMetricSeriesCSV `xml:"PerfMetricSeriesCSV,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPerfMetricSeriesCSV"] = reflect.TypeOf((*ArrayOfPerfMetricSeriesCSV)(nil)).Elem()
}

// A boxed array of `PerfQuerySpec`. To be used in `Any` placeholders.
type ArrayOfPerfQuerySpec struct {
	PerfQuerySpec []PerfQuerySpec `xml:"PerfQuerySpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPerfQuerySpec"] = reflect.TypeOf((*ArrayOfPerfQuerySpec)(nil)).Elem()
}

// A boxed array of `PerfSampleInfo`. To be used in `Any` placeholders.
type ArrayOfPerfSampleInfo struct {
	PerfSampleInfo []PerfSampleInfo `xml:"PerfSampleInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPerfSampleInfo"] = reflect.TypeOf((*ArrayOfPerfSampleInfo)(nil)).Elem()
}

// A boxed array of `PerformanceManagerCounterLevelMapping`. To be used in `Any` placeholders.
type ArrayOfPerformanceManagerCounterLevelMapping struct {
	PerformanceManagerCounterLevelMapping []PerformanceManagerCounterLevelMapping `xml:"PerformanceManagerCounterLevelMapping,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPerformanceManagerCounterLevelMapping"] = reflect.TypeOf((*ArrayOfPerformanceManagerCounterLevelMapping)(nil)).Elem()
}

// A boxed array of `Permission`. To be used in `Any` placeholders.
type ArrayOfPermission struct {
	Permission []Permission `xml:"Permission,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPermission"] = reflect.TypeOf((*ArrayOfPermission)(nil)).Elem()
}

// A boxed array of `PermissionProfile`. To be used in `Any` placeholders.
type ArrayOfPermissionProfile struct {
	PermissionProfile []PermissionProfile `xml:"PermissionProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPermissionProfile"] = reflect.TypeOf((*ArrayOfPermissionProfile)(nil)).Elem()
}

// A boxed array of `PhysicalNic`. To be used in `Any` placeholders.
type ArrayOfPhysicalNic struct {
	PhysicalNic []PhysicalNic `xml:"PhysicalNic,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPhysicalNic"] = reflect.TypeOf((*ArrayOfPhysicalNic)(nil)).Elem()
}

// A boxed array of `PhysicalNicConfig`. To be used in `Any` placeholders.
type ArrayOfPhysicalNicConfig struct {
	PhysicalNicConfig []PhysicalNicConfig `xml:"PhysicalNicConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPhysicalNicConfig"] = reflect.TypeOf((*ArrayOfPhysicalNicConfig)(nil)).Elem()
}

// A boxed array of `PhysicalNicHintInfo`. To be used in `Any` placeholders.
type ArrayOfPhysicalNicHintInfo struct {
	PhysicalNicHintInfo []PhysicalNicHintInfo `xml:"PhysicalNicHintInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPhysicalNicHintInfo"] = reflect.TypeOf((*ArrayOfPhysicalNicHintInfo)(nil)).Elem()
}

// A boxed array of `PhysicalNicIpHint`. To be used in `Any` placeholders.
type ArrayOfPhysicalNicIpHint struct {
	PhysicalNicIpHint []PhysicalNicIpHint `xml:"PhysicalNicIpHint,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPhysicalNicIpHint"] = reflect.TypeOf((*ArrayOfPhysicalNicIpHint)(nil)).Elem()
}

// A boxed array of `PhysicalNicLinkInfo`. To be used in `Any` placeholders.
type ArrayOfPhysicalNicLinkInfo struct {
	PhysicalNicLinkInfo []PhysicalNicLinkInfo `xml:"PhysicalNicLinkInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPhysicalNicLinkInfo"] = reflect.TypeOf((*ArrayOfPhysicalNicLinkInfo)(nil)).Elem()
}

// A boxed array of `PhysicalNicNameHint`. To be used in `Any` placeholders.
type ArrayOfPhysicalNicNameHint struct {
	PhysicalNicNameHint []PhysicalNicNameHint `xml:"PhysicalNicNameHint,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPhysicalNicNameHint"] = reflect.TypeOf((*ArrayOfPhysicalNicNameHint)(nil)).Elem()
}

// A boxed array of `PhysicalNicProfile`. To be used in `Any` placeholders.
type ArrayOfPhysicalNicProfile struct {
	PhysicalNicProfile []PhysicalNicProfile `xml:"PhysicalNicProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPhysicalNicProfile"] = reflect.TypeOf((*ArrayOfPhysicalNicProfile)(nil)).Elem()
}

// A boxed array of `PlacementAffinityRule`. To be used in `Any` placeholders.
type ArrayOfPlacementAffinityRule struct {
	PlacementAffinityRule []PlacementAffinityRule `xml:"PlacementAffinityRule,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPlacementAffinityRule"] = reflect.TypeOf((*ArrayOfPlacementAffinityRule)(nil)).Elem()
}

// A boxed array of `PlacementSpec`. To be used in `Any` placeholders.
type ArrayOfPlacementSpec struct {
	PlacementSpec []PlacementSpec `xml:"PlacementSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPlacementSpec"] = reflect.TypeOf((*ArrayOfPlacementSpec)(nil)).Elem()
}

// A boxed array of `PnicUplinkProfile`. To be used in `Any` placeholders.
type ArrayOfPnicUplinkProfile struct {
	PnicUplinkProfile []PnicUplinkProfile `xml:"PnicUplinkProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPnicUplinkProfile"] = reflect.TypeOf((*ArrayOfPnicUplinkProfile)(nil)).Elem()
}

// A boxed array of `PodDiskLocator`. To be used in `Any` placeholders.
type ArrayOfPodDiskLocator struct {
	PodDiskLocator []PodDiskLocator `xml:"PodDiskLocator,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPodDiskLocator"] = reflect.TypeOf((*ArrayOfPodDiskLocator)(nil)).Elem()
}

// A boxed array of `PolicyOption`. To be used in `Any` placeholders.
type ArrayOfPolicyOption struct {
	PolicyOption []BasePolicyOption `xml:"PolicyOption,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfPolicyOption"] = reflect.TypeOf((*ArrayOfPolicyOption)(nil)).Elem()
}

// A boxed array of `PrivilegeAvailability`. To be used in `Any` placeholders.
type ArrayOfPrivilegeAvailability struct {
	PrivilegeAvailability []PrivilegeAvailability `xml:"PrivilegeAvailability,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPrivilegeAvailability"] = reflect.TypeOf((*ArrayOfPrivilegeAvailability)(nil)).Elem()
}

// A boxed array of `ProductComponentInfo`. To be used in `Any` placeholders.
type ArrayOfProductComponentInfo struct {
	ProductComponentInfo []ProductComponentInfo `xml:"ProductComponentInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProductComponentInfo"] = reflect.TypeOf((*ArrayOfProductComponentInfo)(nil)).Elem()
}

// A boxed array of `ProfileApplyProfileProperty`. To be used in `Any` placeholders.
type ArrayOfProfileApplyProfileProperty struct {
	ProfileApplyProfileProperty []ProfileApplyProfileProperty `xml:"ProfileApplyProfileProperty,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfileApplyProfileProperty"] = reflect.TypeOf((*ArrayOfProfileApplyProfileProperty)(nil)).Elem()
}

// A boxed array of `ProfileDeferredPolicyOptionParameter`. To be used in `Any` placeholders.
type ArrayOfProfileDeferredPolicyOptionParameter struct {
	ProfileDeferredPolicyOptionParameter []ProfileDeferredPolicyOptionParameter `xml:"ProfileDeferredPolicyOptionParameter,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfileDeferredPolicyOptionParameter"] = reflect.TypeOf((*ArrayOfProfileDeferredPolicyOptionParameter)(nil)).Elem()
}

// A boxed array of `ProfileDescriptionSection`. To be used in `Any` placeholders.
type ArrayOfProfileDescriptionSection struct {
	ProfileDescriptionSection []ProfileDescriptionSection `xml:"ProfileDescriptionSection,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfileDescriptionSection"] = reflect.TypeOf((*ArrayOfProfileDescriptionSection)(nil)).Elem()
}

// A boxed array of `ProfileExecuteError`. To be used in `Any` placeholders.
type ArrayOfProfileExecuteError struct {
	ProfileExecuteError []ProfileExecuteError `xml:"ProfileExecuteError,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfileExecuteError"] = reflect.TypeOf((*ArrayOfProfileExecuteError)(nil)).Elem()
}

// A boxed array of `ProfileExpression`. To be used in `Any` placeholders.
type ArrayOfProfileExpression struct {
	ProfileExpression []BaseProfileExpression `xml:"ProfileExpression,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfProfileExpression"] = reflect.TypeOf((*ArrayOfProfileExpression)(nil)).Elem()
}

// A boxed array of `ProfileExpressionMetadata`. To be used in `Any` placeholders.
type ArrayOfProfileExpressionMetadata struct {
	ProfileExpressionMetadata []ProfileExpressionMetadata `xml:"ProfileExpressionMetadata,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfileExpressionMetadata"] = reflect.TypeOf((*ArrayOfProfileExpressionMetadata)(nil)).Elem()
}

// A boxed array of `ProfileMetadata`. To be used in `Any` placeholders.
type ArrayOfProfileMetadata struct {
	ProfileMetadata []ProfileMetadata `xml:"ProfileMetadata,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfileMetadata"] = reflect.TypeOf((*ArrayOfProfileMetadata)(nil)).Elem()
}

// A boxed array of `ProfileMetadataProfileOperationMessage`. To be used in `Any` placeholders.
type ArrayOfProfileMetadataProfileOperationMessage struct {
	ProfileMetadataProfileOperationMessage []ProfileMetadataProfileOperationMessage `xml:"ProfileMetadataProfileOperationMessage,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfileMetadataProfileOperationMessage"] = reflect.TypeOf((*ArrayOfProfileMetadataProfileOperationMessage)(nil)).Elem()
}

// A boxed array of `ProfileMetadataProfileSortSpec`. To be used in `Any` placeholders.
type ArrayOfProfileMetadataProfileSortSpec struct {
	ProfileMetadataProfileSortSpec []ProfileMetadataProfileSortSpec `xml:"ProfileMetadataProfileSortSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfileMetadataProfileSortSpec"] = reflect.TypeOf((*ArrayOfProfileMetadataProfileSortSpec)(nil)).Elem()
}

// A boxed array of `ProfileParameterMetadata`. To be used in `Any` placeholders.
type ArrayOfProfileParameterMetadata struct {
	ProfileParameterMetadata []ProfileParameterMetadata `xml:"ProfileParameterMetadata,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfileParameterMetadata"] = reflect.TypeOf((*ArrayOfProfileParameterMetadata)(nil)).Elem()
}

// A boxed array of `ProfileParameterMetadataParameterRelationMetadata`. To be used in `Any` placeholders.
type ArrayOfProfileParameterMetadataParameterRelationMetadata struct {
	ProfileParameterMetadataParameterRelationMetadata []ProfileParameterMetadataParameterRelationMetadata `xml:"ProfileParameterMetadataParameterRelationMetadata,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfileParameterMetadataParameterRelationMetadata"] = reflect.TypeOf((*ArrayOfProfileParameterMetadataParameterRelationMetadata)(nil)).Elem()
}

// A boxed array of `ProfilePolicy`. To be used in `Any` placeholders.
type ArrayOfProfilePolicy struct {
	ProfilePolicy []ProfilePolicy `xml:"ProfilePolicy,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfilePolicy"] = reflect.TypeOf((*ArrayOfProfilePolicy)(nil)).Elem()
}

// A boxed array of `ProfilePolicyMetadata`. To be used in `Any` placeholders.
type ArrayOfProfilePolicyMetadata struct {
	ProfilePolicyMetadata []ProfilePolicyMetadata `xml:"ProfilePolicyMetadata,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfilePolicyMetadata"] = reflect.TypeOf((*ArrayOfProfilePolicyMetadata)(nil)).Elem()
}

// A boxed array of `ProfilePolicyOptionMetadata`. To be used in `Any` placeholders.
type ArrayOfProfilePolicyOptionMetadata struct {
	ProfilePolicyOptionMetadata []BaseProfilePolicyOptionMetadata `xml:"ProfilePolicyOptionMetadata,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfProfilePolicyOptionMetadata"] = reflect.TypeOf((*ArrayOfProfilePolicyOptionMetadata)(nil)).Elem()
}

// A boxed array of `ProfileProfileStructureProperty`. To be used in `Any` placeholders.
type ArrayOfProfileProfileStructureProperty struct {
	ProfileProfileStructureProperty []ProfileProfileStructureProperty `xml:"ProfileProfileStructureProperty,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfileProfileStructureProperty"] = reflect.TypeOf((*ArrayOfProfileProfileStructureProperty)(nil)).Elem()
}

// A boxed array of `ProfilePropertyPath`. To be used in `Any` placeholders.
type ArrayOfProfilePropertyPath struct {
	ProfilePropertyPath []ProfilePropertyPath `xml:"ProfilePropertyPath,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfilePropertyPath"] = reflect.TypeOf((*ArrayOfProfilePropertyPath)(nil)).Elem()
}

// A boxed array of `ProfileUpdateFailedUpdateFailure`. To be used in `Any` placeholders.
type ArrayOfProfileUpdateFailedUpdateFailure struct {
	ProfileUpdateFailedUpdateFailure []ProfileUpdateFailedUpdateFailure `xml:"ProfileUpdateFailedUpdateFailure,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfProfileUpdateFailedUpdateFailure"] = reflect.TypeOf((*ArrayOfProfileUpdateFailedUpdateFailure)(nil)).Elem()
}

// A boxed array of `PropertyChange`. To be used in `Any` placeholders.
type ArrayOfPropertyChange struct {
	PropertyChange []PropertyChange `xml:"PropertyChange,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPropertyChange"] = reflect.TypeOf((*ArrayOfPropertyChange)(nil)).Elem()
}

// A boxed array of `PropertyFilterSpec`. To be used in `Any` placeholders.
type ArrayOfPropertyFilterSpec struct {
	PropertyFilterSpec []PropertyFilterSpec `xml:"PropertyFilterSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPropertyFilterSpec"] = reflect.TypeOf((*ArrayOfPropertyFilterSpec)(nil)).Elem()
}

// A boxed array of `PropertyFilterUpdate`. To be used in `Any` placeholders.
type ArrayOfPropertyFilterUpdate struct {
	PropertyFilterUpdate []PropertyFilterUpdate `xml:"PropertyFilterUpdate,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPropertyFilterUpdate"] = reflect.TypeOf((*ArrayOfPropertyFilterUpdate)(nil)).Elem()
}

// A boxed array of `PropertySpec`. To be used in `Any` placeholders.
type ArrayOfPropertySpec struct {
	PropertySpec []PropertySpec `xml:"PropertySpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfPropertySpec"] = reflect.TypeOf((*ArrayOfPropertySpec)(nil)).Elem()
}

// A boxed array of `Relation`. To be used in `Any` placeholders.
type ArrayOfRelation struct {
	Relation []Relation `xml:"Relation,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfRelation"] = reflect.TypeOf((*ArrayOfRelation)(nil)).Elem()
}

// A boxed array of `ReplicationInfoDiskSettings`. To be used in `Any` placeholders.
type ArrayOfReplicationInfoDiskSettings struct {
	ReplicationInfoDiskSettings []ReplicationInfoDiskSettings `xml:"ReplicationInfoDiskSettings,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfReplicationInfoDiskSettings"] = reflect.TypeOf((*ArrayOfReplicationInfoDiskSettings)(nil)).Elem()
}

// A boxed array of `ResourceConfigSpec`. To be used in `Any` placeholders.
type ArrayOfResourceConfigSpec struct {
	ResourceConfigSpec []ResourceConfigSpec `xml:"ResourceConfigSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfResourceConfigSpec"] = reflect.TypeOf((*ArrayOfResourceConfigSpec)(nil)).Elem()
}

// A boxed array of `RetrieveVStorageObjSpec`. To be used in `Any` placeholders.
type ArrayOfRetrieveVStorageObjSpec struct {
	RetrieveVStorageObjSpec []RetrieveVStorageObjSpec `xml:"RetrieveVStorageObjSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfRetrieveVStorageObjSpec"] = reflect.TypeOf((*ArrayOfRetrieveVStorageObjSpec)(nil)).Elem()
}

// A boxed array of `ScheduledTaskDetail`. To be used in `Any` placeholders.
type ArrayOfScheduledTaskDetail struct {
	ScheduledTaskDetail []ScheduledTaskDetail `xml:"ScheduledTaskDetail,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfScheduledTaskDetail"] = reflect.TypeOf((*ArrayOfScheduledTaskDetail)(nil)).Elem()
}

// A boxed array of `ScsiLun`. To be used in `Any` placeholders.
type ArrayOfScsiLun struct {
	ScsiLun []BaseScsiLun `xml:"ScsiLun,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfScsiLun"] = reflect.TypeOf((*ArrayOfScsiLun)(nil)).Elem()
}

// A boxed array of `ScsiLunDescriptor`. To be used in `Any` placeholders.
type ArrayOfScsiLunDescriptor struct {
	ScsiLunDescriptor []ScsiLunDescriptor `xml:"ScsiLunDescriptor,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfScsiLunDescriptor"] = reflect.TypeOf((*ArrayOfScsiLunDescriptor)(nil)).Elem()
}

// A boxed array of `ScsiLunDurableName`. To be used in `Any` placeholders.
type ArrayOfScsiLunDurableName struct {
	ScsiLunDurableName []ScsiLunDurableName `xml:"ScsiLunDurableName,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfScsiLunDurableName"] = reflect.TypeOf((*ArrayOfScsiLunDurableName)(nil)).Elem()
}

// A boxed array of `SelectionSet`. To be used in `Any` placeholders.
type ArrayOfSelectionSet struct {
	SelectionSet []BaseSelectionSet `xml:"SelectionSet,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfSelectionSet"] = reflect.TypeOf((*ArrayOfSelectionSet)(nil)).Elem()
}

// A boxed array of `SelectionSpec`. To be used in `Any` placeholders.
type ArrayOfSelectionSpec struct {
	SelectionSpec []BaseSelectionSpec `xml:"SelectionSpec,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfSelectionSpec"] = reflect.TypeOf((*ArrayOfSelectionSpec)(nil)).Elem()
}

// A boxed array of `ServiceConsolePortGroupProfile`. To be used in `Any` placeholders.
type ArrayOfServiceConsolePortGroupProfile struct {
	ServiceConsolePortGroupProfile []ServiceConsolePortGroupProfile `xml:"ServiceConsolePortGroupProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfServiceConsolePortGroupProfile"] = reflect.TypeOf((*ArrayOfServiceConsolePortGroupProfile)(nil)).Elem()
}

// A boxed array of `ServiceLocator`. To be used in `Any` placeholders.
type ArrayOfServiceLocator struct {
	ServiceLocator []ServiceLocator `xml:"ServiceLocator,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfServiceLocator"] = reflect.TypeOf((*ArrayOfServiceLocator)(nil)).Elem()
}

// A boxed array of `ServiceManagerServiceInfo`. To be used in `Any` placeholders.
type ArrayOfServiceManagerServiceInfo struct {
	ServiceManagerServiceInfo []ServiceManagerServiceInfo `xml:"ServiceManagerServiceInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfServiceManagerServiceInfo"] = reflect.TypeOf((*ArrayOfServiceManagerServiceInfo)(nil)).Elem()
}

// A boxed array of `ServiceProfile`. To be used in `Any` placeholders.
type ArrayOfServiceProfile struct {
	ServiceProfile []ServiceProfile `xml:"ServiceProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfServiceProfile"] = reflect.TypeOf((*ArrayOfServiceProfile)(nil)).Elem()
}

// A boxed array of `PrimitiveShort`. To be used in `Any` placeholders.
type ArrayOfShort struct {
	Short []int16 `xml:"short,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfShort"] = reflect.TypeOf((*ArrayOfShort)(nil)).Elem()
}

// A boxed array of `SoftwarePackage`. To be used in `Any` placeholders.
type ArrayOfSoftwarePackage struct {
	SoftwarePackage []SoftwarePackage `xml:"SoftwarePackage,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfSoftwarePackage"] = reflect.TypeOf((*ArrayOfSoftwarePackage)(nil)).Elem()
}

// A boxed array of `StaticRouteProfile`. To be used in `Any` placeholders.
type ArrayOfStaticRouteProfile struct {
	StaticRouteProfile []StaticRouteProfile `xml:"StaticRouteProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfStaticRouteProfile"] = reflect.TypeOf((*ArrayOfStaticRouteProfile)(nil)).Elem()
}

// A boxed array of `StorageDrsOptionSpec`. To be used in `Any` placeholders.
type ArrayOfStorageDrsOptionSpec struct {
	StorageDrsOptionSpec []StorageDrsOptionSpec `xml:"StorageDrsOptionSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfStorageDrsOptionSpec"] = reflect.TypeOf((*ArrayOfStorageDrsOptionSpec)(nil)).Elem()
}

// A boxed array of `StorageDrsPlacementRankVmSpec`. To be used in `Any` placeholders.
type ArrayOfStorageDrsPlacementRankVmSpec struct {
	StorageDrsPlacementRankVmSpec []StorageDrsPlacementRankVmSpec `xml:"StorageDrsPlacementRankVmSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfStorageDrsPlacementRankVmSpec"] = reflect.TypeOf((*ArrayOfStorageDrsPlacementRankVmSpec)(nil)).Elem()
}

// A boxed array of `StorageDrsVmConfigInfo`. To be used in `Any` placeholders.
type ArrayOfStorageDrsVmConfigInfo struct {
	StorageDrsVmConfigInfo []StorageDrsVmConfigInfo `xml:"StorageDrsVmConfigInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfStorageDrsVmConfigInfo"] = reflect.TypeOf((*ArrayOfStorageDrsVmConfigInfo)(nil)).Elem()
}

// A boxed array of `StorageDrsVmConfigSpec`. To be used in `Any` placeholders.
type ArrayOfStorageDrsVmConfigSpec struct {
	StorageDrsVmConfigSpec []StorageDrsVmConfigSpec `xml:"StorageDrsVmConfigSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfStorageDrsVmConfigSpec"] = reflect.TypeOf((*ArrayOfStorageDrsVmConfigSpec)(nil)).Elem()
}

// A boxed array of `StoragePerformanceSummary`. To be used in `Any` placeholders.
type ArrayOfStoragePerformanceSummary struct {
	StoragePerformanceSummary []StoragePerformanceSummary `xml:"StoragePerformanceSummary,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfStoragePerformanceSummary"] = reflect.TypeOf((*ArrayOfStoragePerformanceSummary)(nil)).Elem()
}

// A boxed array of `StorageRequirement`. To be used in `Any` placeholders.
type ArrayOfStorageRequirement struct {
	StorageRequirement []StorageRequirement `xml:"StorageRequirement,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfStorageRequirement"] = reflect.TypeOf((*ArrayOfStorageRequirement)(nil)).Elem()
}

// A boxed array of `PrimitiveString`. To be used in `Any` placeholders.
type ArrayOfString struct {
	String []string `xml:"string,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfString"] = reflect.TypeOf((*ArrayOfString)(nil)).Elem()
}

// A boxed array of `StructuredCustomizations`. To be used in `Any` placeholders.
type ArrayOfStructuredCustomizations struct {
	StructuredCustomizations []StructuredCustomizations `xml:"StructuredCustomizations,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfStructuredCustomizations"] = reflect.TypeOf((*ArrayOfStructuredCustomizations)(nil)).Elem()
}

// A boxed array of `SystemEventInfo`. To be used in `Any` placeholders.
type ArrayOfSystemEventInfo struct {
	SystemEventInfo []SystemEventInfo `xml:"SystemEventInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfSystemEventInfo"] = reflect.TypeOf((*ArrayOfSystemEventInfo)(nil)).Elem()
}

// A boxed array of `Tag`. To be used in `Any` placeholders.
type ArrayOfTag struct {
	Tag []Tag `xml:"Tag,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfTag"] = reflect.TypeOf((*ArrayOfTag)(nil)).Elem()
}

// A boxed array of `TaskInfo`. To be used in `Any` placeholders.
type ArrayOfTaskInfo struct {
	TaskInfo []TaskInfo `xml:"TaskInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfTaskInfo"] = reflect.TypeOf((*ArrayOfTaskInfo)(nil)).Elem()
}

// A boxed array of `TaskInfoState_enum`. To be used in `Any` placeholders.
type ArrayOfTaskInfoState struct {
	TaskInfoState []TaskInfoState `xml:"TaskInfoState,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfTaskInfoState"] = reflect.TypeOf((*ArrayOfTaskInfoState)(nil)).Elem()
}

// A boxed array of `TypeDescription`. To be used in `Any` placeholders.
type ArrayOfTypeDescription struct {
	TypeDescription []BaseTypeDescription `xml:"TypeDescription,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfTypeDescription"] = reflect.TypeOf((*ArrayOfTypeDescription)(nil)).Elem()
}

// A boxed array of `UpdateVirtualMachineFilesResultFailedVmFileInfo`. To be used in `Any` placeholders.
type ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo struct {
	UpdateVirtualMachineFilesResultFailedVmFileInfo []UpdateVirtualMachineFilesResultFailedVmFileInfo `xml:"UpdateVirtualMachineFilesResultFailedVmFileInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo"] = reflect.TypeOf((*ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo)(nil)).Elem()
}

type ArrayOfUri struct {
	Uri []string `xml:"uri,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfUri"] = reflect.TypeOf((*ArrayOfUri)(nil)).Elem()
}

// A boxed array of `UsbScanCodeSpecKeyEvent`. To be used in `Any` placeholders.
type ArrayOfUsbScanCodeSpecKeyEvent struct {
	UsbScanCodeSpecKeyEvent []UsbScanCodeSpecKeyEvent `xml:"UsbScanCodeSpecKeyEvent,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfUsbScanCodeSpecKeyEvent"] = reflect.TypeOf((*ArrayOfUsbScanCodeSpecKeyEvent)(nil)).Elem()
}

// A boxed array of `UserGroupProfile`. To be used in `Any` placeholders.
type ArrayOfUserGroupProfile struct {
	UserGroupProfile []UserGroupProfile `xml:"UserGroupProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfUserGroupProfile"] = reflect.TypeOf((*ArrayOfUserGroupProfile)(nil)).Elem()
}

// A boxed array of `UserPrivilegeResult`. To be used in `Any` placeholders.
type ArrayOfUserPrivilegeResult struct {
	UserPrivilegeResult []UserPrivilegeResult `xml:"UserPrivilegeResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfUserPrivilegeResult"] = reflect.TypeOf((*ArrayOfUserPrivilegeResult)(nil)).Elem()
}

// A boxed array of `UserProfile`. To be used in `Any` placeholders.
type ArrayOfUserProfile struct {
	UserProfile []UserProfile `xml:"UserProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfUserProfile"] = reflect.TypeOf((*ArrayOfUserProfile)(nil)).Elem()
}

// A boxed array of `UserSearchResult`. To be used in `Any` placeholders.
type ArrayOfUserSearchResult struct {
	UserSearchResult []BaseUserSearchResult `xml:"UserSearchResult,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfUserSearchResult"] = reflect.TypeOf((*ArrayOfUserSearchResult)(nil)).Elem()
}

// A boxed array of `UserSession`. To be used in `Any` placeholders.
type ArrayOfUserSession struct {
	UserSession []UserSession `xml:"UserSession,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfUserSession"] = reflect.TypeOf((*ArrayOfUserSession)(nil)).Elem()
}

// A boxed array of `VASAStorageArray`. To be used in `Any` placeholders.
type ArrayOfVASAStorageArray struct {
	VASAStorageArray []VASAStorageArray `xml:"VASAStorageArray,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVASAStorageArray"] = reflect.TypeOf((*ArrayOfVASAStorageArray)(nil)).Elem()
}

// A boxed array of `VASAStorageArrayDiscoverySvcInfo`. To be used in `Any` placeholders.
type ArrayOfVASAStorageArrayDiscoverySvcInfo struct {
	VASAStorageArrayDiscoverySvcInfo []VASAStorageArrayDiscoverySvcInfo `xml:"VASAStorageArrayDiscoverySvcInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVASAStorageArrayDiscoverySvcInfo"] = reflect.TypeOf((*ArrayOfVASAStorageArrayDiscoverySvcInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfVASAStorageArrayDiscoverySvcInfo"] = "8.0.0.0"
}

// A boxed array of `VAppCloneSpecNetworkMappingPair`. To be used in `Any` placeholders.
type ArrayOfVAppCloneSpecNetworkMappingPair struct {
	VAppCloneSpecNetworkMappingPair []VAppCloneSpecNetworkMappingPair `xml:"VAppCloneSpecNetworkMappingPair,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVAppCloneSpecNetworkMappingPair"] = reflect.TypeOf((*ArrayOfVAppCloneSpecNetworkMappingPair)(nil)).Elem()
}

// A boxed array of `VAppCloneSpecResourceMap`. To be used in `Any` placeholders.
type ArrayOfVAppCloneSpecResourceMap struct {
	VAppCloneSpecResourceMap []VAppCloneSpecResourceMap `xml:"VAppCloneSpecResourceMap,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVAppCloneSpecResourceMap"] = reflect.TypeOf((*ArrayOfVAppCloneSpecResourceMap)(nil)).Elem()
}

// A boxed array of `VAppEntityConfigInfo`. To be used in `Any` placeholders.
type ArrayOfVAppEntityConfigInfo struct {
	VAppEntityConfigInfo []VAppEntityConfigInfo `xml:"VAppEntityConfigInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVAppEntityConfigInfo"] = reflect.TypeOf((*ArrayOfVAppEntityConfigInfo)(nil)).Elem()
}

// A boxed array of `VAppOvfSectionInfo`. To be used in `Any` placeholders.
type ArrayOfVAppOvfSectionInfo struct {
	VAppOvfSectionInfo []VAppOvfSectionInfo `xml:"VAppOvfSectionInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVAppOvfSectionInfo"] = reflect.TypeOf((*ArrayOfVAppOvfSectionInfo)(nil)).Elem()
}

// A boxed array of `VAppOvfSectionSpec`. To be used in `Any` placeholders.
type ArrayOfVAppOvfSectionSpec struct {
	VAppOvfSectionSpec []VAppOvfSectionSpec `xml:"VAppOvfSectionSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVAppOvfSectionSpec"] = reflect.TypeOf((*ArrayOfVAppOvfSectionSpec)(nil)).Elem()
}

// A boxed array of `VAppProductInfo`. To be used in `Any` placeholders.
type ArrayOfVAppProductInfo struct {
	VAppProductInfo []VAppProductInfo `xml:"VAppProductInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVAppProductInfo"] = reflect.TypeOf((*ArrayOfVAppProductInfo)(nil)).Elem()
}

// A boxed array of `VAppProductSpec`. To be used in `Any` placeholders.
type ArrayOfVAppProductSpec struct {
	VAppProductSpec []VAppProductSpec `xml:"VAppProductSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVAppProductSpec"] = reflect.TypeOf((*ArrayOfVAppProductSpec)(nil)).Elem()
}

// A boxed array of `VAppPropertyInfo`. To be used in `Any` placeholders.
type ArrayOfVAppPropertyInfo struct {
	VAppPropertyInfo []VAppPropertyInfo `xml:"VAppPropertyInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVAppPropertyInfo"] = reflect.TypeOf((*ArrayOfVAppPropertyInfo)(nil)).Elem()
}

// A boxed array of `VAppPropertySpec`. To be used in `Any` placeholders.
type ArrayOfVAppPropertySpec struct {
	VAppPropertySpec []VAppPropertySpec `xml:"VAppPropertySpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVAppPropertySpec"] = reflect.TypeOf((*ArrayOfVAppPropertySpec)(nil)).Elem()
}

// A boxed array of `VMwareDVSPvlanConfigSpec`. To be used in `Any` placeholders.
type ArrayOfVMwareDVSPvlanConfigSpec struct {
	VMwareDVSPvlanConfigSpec []VMwareDVSPvlanConfigSpec `xml:"VMwareDVSPvlanConfigSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVMwareDVSPvlanConfigSpec"] = reflect.TypeOf((*ArrayOfVMwareDVSPvlanConfigSpec)(nil)).Elem()
}

// A boxed array of `VMwareDVSPvlanMapEntry`. To be used in `Any` placeholders.
type ArrayOfVMwareDVSPvlanMapEntry struct {
	VMwareDVSPvlanMapEntry []VMwareDVSPvlanMapEntry `xml:"VMwareDVSPvlanMapEntry,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVMwareDVSPvlanMapEntry"] = reflect.TypeOf((*ArrayOfVMwareDVSPvlanMapEntry)(nil)).Elem()
}

// A boxed array of `VMwareDVSVspanConfigSpec`. To be used in `Any` placeholders.
type ArrayOfVMwareDVSVspanConfigSpec struct {
	VMwareDVSVspanConfigSpec []VMwareDVSVspanConfigSpec `xml:"VMwareDVSVspanConfigSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVMwareDVSVspanConfigSpec"] = reflect.TypeOf((*ArrayOfVMwareDVSVspanConfigSpec)(nil)).Elem()
}

// A boxed array of `VMwareDvsLacpGroupConfig`. To be used in `Any` placeholders.
type ArrayOfVMwareDvsLacpGroupConfig struct {
	VMwareDvsLacpGroupConfig []VMwareDvsLacpGroupConfig `xml:"VMwareDvsLacpGroupConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVMwareDvsLacpGroupConfig"] = reflect.TypeOf((*ArrayOfVMwareDvsLacpGroupConfig)(nil)).Elem()
}

// A boxed array of `VMwareDvsLacpGroupSpec`. To be used in `Any` placeholders.
type ArrayOfVMwareDvsLacpGroupSpec struct {
	VMwareDvsLacpGroupSpec []VMwareDvsLacpGroupSpec `xml:"VMwareDvsLacpGroupSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVMwareDvsLacpGroupSpec"] = reflect.TypeOf((*ArrayOfVMwareDvsLacpGroupSpec)(nil)).Elem()
}

// A boxed array of `VMwareVspanSession`. To be used in `Any` placeholders.
type ArrayOfVMwareVspanSession struct {
	VMwareVspanSession []VMwareVspanSession `xml:"VMwareVspanSession,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVMwareVspanSession"] = reflect.TypeOf((*ArrayOfVMwareVspanSession)(nil)).Elem()
}

// A boxed array of `VStorageObjectAssociations`. To be used in `Any` placeholders.
type ArrayOfVStorageObjectAssociations struct {
	VStorageObjectAssociations []VStorageObjectAssociations `xml:"VStorageObjectAssociations,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVStorageObjectAssociations"] = reflect.TypeOf((*ArrayOfVStorageObjectAssociations)(nil)).Elem()
}

// A boxed array of `VStorageObjectAssociationsVmDiskAssociations`. To be used in `Any` placeholders.
type ArrayOfVStorageObjectAssociationsVmDiskAssociations struct {
	VStorageObjectAssociationsVmDiskAssociations []VStorageObjectAssociationsVmDiskAssociations `xml:"VStorageObjectAssociationsVmDiskAssociations,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVStorageObjectAssociationsVmDiskAssociations"] = reflect.TypeOf((*ArrayOfVStorageObjectAssociationsVmDiskAssociations)(nil)).Elem()
}

// A boxed array of `VStorageObjectSnapshotInfoVStorageObjectSnapshot`. To be used in `Any` placeholders.
type ArrayOfVStorageObjectSnapshotInfoVStorageObjectSnapshot struct {
	VStorageObjectSnapshotInfoVStorageObjectSnapshot []VStorageObjectSnapshotInfoVStorageObjectSnapshot `xml:"VStorageObjectSnapshotInfoVStorageObjectSnapshot,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVStorageObjectSnapshotInfoVStorageObjectSnapshot"] = reflect.TypeOf((*ArrayOfVStorageObjectSnapshotInfoVStorageObjectSnapshot)(nil)).Elem()
}

// A boxed array of `VVolHostPE`. To be used in `Any` placeholders.
type ArrayOfVVolHostPE struct {
	VVolHostPE []VVolHostPE `xml:"VVolHostPE,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVVolHostPE"] = reflect.TypeOf((*ArrayOfVVolHostPE)(nil)).Elem()
}

// A boxed array of `VVolVmConfigFileUpdateResultFailedVmConfigFileInfo`. To be used in `Any` placeholders.
type ArrayOfVVolVmConfigFileUpdateResultFailedVmConfigFileInfo struct {
	VVolVmConfigFileUpdateResultFailedVmConfigFileInfo []VVolVmConfigFileUpdateResultFailedVmConfigFileInfo `xml:"VVolVmConfigFileUpdateResultFailedVmConfigFileInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVVolVmConfigFileUpdateResultFailedVmConfigFileInfo"] = reflect.TypeOf((*ArrayOfVVolVmConfigFileUpdateResultFailedVmConfigFileInfo)(nil)).Elem()
}

// A boxed array of `VchaNodeRuntimeInfo`. To be used in `Any` placeholders.
type ArrayOfVchaNodeRuntimeInfo struct {
	VchaNodeRuntimeInfo []VchaNodeRuntimeInfo `xml:"VchaNodeRuntimeInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVchaNodeRuntimeInfo"] = reflect.TypeOf((*ArrayOfVchaNodeRuntimeInfo)(nil)).Elem()
}

// A boxed array of `VimVasaProviderInfo`. To be used in `Any` placeholders.
type ArrayOfVimVasaProviderInfo struct {
	VimVasaProviderInfo []VimVasaProviderInfo `xml:"VimVasaProviderInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVimVasaProviderInfo"] = reflect.TypeOf((*ArrayOfVimVasaProviderInfo)(nil)).Elem()
}

// A boxed array of `VimVasaProviderStatePerArray`. To be used in `Any` placeholders.
type ArrayOfVimVasaProviderStatePerArray struct {
	VimVasaProviderStatePerArray []VimVasaProviderStatePerArray `xml:"VimVasaProviderStatePerArray,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVimVasaProviderStatePerArray"] = reflect.TypeOf((*ArrayOfVimVasaProviderStatePerArray)(nil)).Elem()
}

// A boxed array of `VirtualAppLinkInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualAppLinkInfo struct {
	VirtualAppLinkInfo []VirtualAppLinkInfo `xml:"VirtualAppLinkInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualAppLinkInfo"] = reflect.TypeOf((*ArrayOfVirtualAppLinkInfo)(nil)).Elem()
}

// A boxed array of `VirtualDevice`. To be used in `Any` placeholders.
type ArrayOfVirtualDevice struct {
	VirtualDevice []BaseVirtualDevice `xml:"VirtualDevice,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfVirtualDevice"] = reflect.TypeOf((*ArrayOfVirtualDevice)(nil)).Elem()
}

// A boxed array of `VirtualDeviceBackingOption`. To be used in `Any` placeholders.
type ArrayOfVirtualDeviceBackingOption struct {
	VirtualDeviceBackingOption []BaseVirtualDeviceBackingOption `xml:"VirtualDeviceBackingOption,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfVirtualDeviceBackingOption"] = reflect.TypeOf((*ArrayOfVirtualDeviceBackingOption)(nil)).Elem()
}

// A boxed array of `VirtualDeviceConfigSpec`. To be used in `Any` placeholders.
type ArrayOfVirtualDeviceConfigSpec struct {
	VirtualDeviceConfigSpec []BaseVirtualDeviceConfigSpec `xml:"VirtualDeviceConfigSpec,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfVirtualDeviceConfigSpec"] = reflect.TypeOf((*ArrayOfVirtualDeviceConfigSpec)(nil)).Elem()
}

// A boxed array of `VirtualDeviceOption`. To be used in `Any` placeholders.
type ArrayOfVirtualDeviceOption struct {
	VirtualDeviceOption []BaseVirtualDeviceOption `xml:"VirtualDeviceOption,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfVirtualDeviceOption"] = reflect.TypeOf((*ArrayOfVirtualDeviceOption)(nil)).Elem()
}

// A boxed array of `VirtualDisk`. To be used in `Any` placeholders.
type ArrayOfVirtualDisk struct {
	VirtualDisk []VirtualDisk `xml:"VirtualDisk,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualDisk"] = reflect.TypeOf((*ArrayOfVirtualDisk)(nil)).Elem()
}

// A boxed array of `VirtualDiskDeltaDiskFormatsSupported`. To be used in `Any` placeholders.
type ArrayOfVirtualDiskDeltaDiskFormatsSupported struct {
	VirtualDiskDeltaDiskFormatsSupported []VirtualDiskDeltaDiskFormatsSupported `xml:"VirtualDiskDeltaDiskFormatsSupported,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualDiskDeltaDiskFormatsSupported"] = reflect.TypeOf((*ArrayOfVirtualDiskDeltaDiskFormatsSupported)(nil)).Elem()
}

// A boxed array of `VirtualDiskId`. To be used in `Any` placeholders.
type ArrayOfVirtualDiskId struct {
	VirtualDiskId []VirtualDiskId `xml:"VirtualDiskId,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualDiskId"] = reflect.TypeOf((*ArrayOfVirtualDiskId)(nil)).Elem()
}

// A boxed array of `VirtualDiskRuleSpec`. To be used in `Any` placeholders.
type ArrayOfVirtualDiskRuleSpec struct {
	VirtualDiskRuleSpec []VirtualDiskRuleSpec `xml:"VirtualDiskRuleSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualDiskRuleSpec"] = reflect.TypeOf((*ArrayOfVirtualDiskRuleSpec)(nil)).Elem()
}

// A boxed array of `VirtualMachineBaseIndependentFilterSpec`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineBaseIndependentFilterSpec struct {
	VirtualMachineBaseIndependentFilterSpec []BaseVirtualMachineBaseIndependentFilterSpec `xml:"VirtualMachineBaseIndependentFilterSpec,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineBaseIndependentFilterSpec"] = reflect.TypeOf((*ArrayOfVirtualMachineBaseIndependentFilterSpec)(nil)).Elem()
	minAPIVersionForType["ArrayOfVirtualMachineBaseIndependentFilterSpec"] = "7.0.2.1"
}

// A boxed array of `VirtualMachineBootOptionsBootableDevice`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineBootOptionsBootableDevice struct {
	VirtualMachineBootOptionsBootableDevice []BaseVirtualMachineBootOptionsBootableDevice `xml:"VirtualMachineBootOptionsBootableDevice,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineBootOptionsBootableDevice"] = reflect.TypeOf((*ArrayOfVirtualMachineBootOptionsBootableDevice)(nil)).Elem()
}

// A boxed array of `VirtualMachineCdromInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineCdromInfo struct {
	VirtualMachineCdromInfo []VirtualMachineCdromInfo `xml:"VirtualMachineCdromInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineCdromInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineCdromInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineCertThumbprint`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineCertThumbprint struct {
	VirtualMachineCertThumbprint []VirtualMachineCertThumbprint `xml:"VirtualMachineCertThumbprint,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineCertThumbprint"] = reflect.TypeOf((*ArrayOfVirtualMachineCertThumbprint)(nil)).Elem()
	minAPIVersionForType["ArrayOfVirtualMachineCertThumbprint"] = "7.0.3.1"
}

// A boxed array of `VirtualMachineConfigInfoDatastoreUrlPair`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineConfigInfoDatastoreUrlPair struct {
	VirtualMachineConfigInfoDatastoreUrlPair []VirtualMachineConfigInfoDatastoreUrlPair `xml:"VirtualMachineConfigInfoDatastoreUrlPair,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineConfigInfoDatastoreUrlPair"] = reflect.TypeOf((*ArrayOfVirtualMachineConfigInfoDatastoreUrlPair)(nil)).Elem()
}

// A boxed array of `VirtualMachineConfigOptionDescriptor`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineConfigOptionDescriptor struct {
	VirtualMachineConfigOptionDescriptor []VirtualMachineConfigOptionDescriptor `xml:"VirtualMachineConfigOptionDescriptor,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineConfigOptionDescriptor"] = reflect.TypeOf((*ArrayOfVirtualMachineConfigOptionDescriptor)(nil)).Elem()
}

// A boxed array of `VirtualMachineConfigSpec`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineConfigSpec struct {
	VirtualMachineConfigSpec []VirtualMachineConfigSpec `xml:"VirtualMachineConfigSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineConfigSpec"] = reflect.TypeOf((*ArrayOfVirtualMachineConfigSpec)(nil)).Elem()
}

// A boxed array of `VirtualMachineConnection`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineConnection struct {
	VirtualMachineConnection []BaseVirtualMachineConnection `xml:"VirtualMachineConnection,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineConnection"] = reflect.TypeOf((*ArrayOfVirtualMachineConnection)(nil)).Elem()
	minAPIVersionForType["ArrayOfVirtualMachineConnection"] = "7.0.1.0"
}

// A boxed array of `VirtualMachineCpuIdInfoSpec`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineCpuIdInfoSpec struct {
	VirtualMachineCpuIdInfoSpec []VirtualMachineCpuIdInfoSpec `xml:"VirtualMachineCpuIdInfoSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineCpuIdInfoSpec"] = reflect.TypeOf((*ArrayOfVirtualMachineCpuIdInfoSpec)(nil)).Elem()
}

// A boxed array of `VirtualMachineDatastoreInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineDatastoreInfo struct {
	VirtualMachineDatastoreInfo []VirtualMachineDatastoreInfo `xml:"VirtualMachineDatastoreInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineDatastoreInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineDatastoreInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineDatastoreVolumeOption`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineDatastoreVolumeOption struct {
	VirtualMachineDatastoreVolumeOption []VirtualMachineDatastoreVolumeOption `xml:"VirtualMachineDatastoreVolumeOption,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineDatastoreVolumeOption"] = reflect.TypeOf((*ArrayOfVirtualMachineDatastoreVolumeOption)(nil)).Elem()
}

// A boxed array of `VirtualMachineDeviceRuntimeInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineDeviceRuntimeInfo struct {
	VirtualMachineDeviceRuntimeInfo []VirtualMachineDeviceRuntimeInfo `xml:"VirtualMachineDeviceRuntimeInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineDeviceRuntimeInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineDeviceRuntimeInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineDisplayTopology`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineDisplayTopology struct {
	VirtualMachineDisplayTopology []VirtualMachineDisplayTopology `xml:"VirtualMachineDisplayTopology,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineDisplayTopology"] = reflect.TypeOf((*ArrayOfVirtualMachineDisplayTopology)(nil)).Elem()
}

// A boxed array of `VirtualMachineDvxClassInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineDvxClassInfo struct {
	VirtualMachineDvxClassInfo []VirtualMachineDvxClassInfo `xml:"VirtualMachineDvxClassInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineDvxClassInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineDvxClassInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfVirtualMachineDvxClassInfo"] = "8.0.0.1"
}

// A boxed array of `VirtualMachineDynamicPassthroughInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineDynamicPassthroughInfo struct {
	VirtualMachineDynamicPassthroughInfo []VirtualMachineDynamicPassthroughInfo `xml:"VirtualMachineDynamicPassthroughInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineDynamicPassthroughInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineDynamicPassthroughInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineFeatureRequirement`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineFeatureRequirement struct {
	VirtualMachineFeatureRequirement []VirtualMachineFeatureRequirement `xml:"VirtualMachineFeatureRequirement,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineFeatureRequirement"] = reflect.TypeOf((*ArrayOfVirtualMachineFeatureRequirement)(nil)).Elem()
}

// A boxed array of `VirtualMachineFileLayoutDiskLayout`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineFileLayoutDiskLayout struct {
	VirtualMachineFileLayoutDiskLayout []VirtualMachineFileLayoutDiskLayout `xml:"VirtualMachineFileLayoutDiskLayout,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineFileLayoutDiskLayout"] = reflect.TypeOf((*ArrayOfVirtualMachineFileLayoutDiskLayout)(nil)).Elem()
}

// A boxed array of `VirtualMachineFileLayoutExDiskLayout`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineFileLayoutExDiskLayout struct {
	VirtualMachineFileLayoutExDiskLayout []VirtualMachineFileLayoutExDiskLayout `xml:"VirtualMachineFileLayoutExDiskLayout,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineFileLayoutExDiskLayout"] = reflect.TypeOf((*ArrayOfVirtualMachineFileLayoutExDiskLayout)(nil)).Elem()
}

// A boxed array of `VirtualMachineFileLayoutExDiskUnit`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineFileLayoutExDiskUnit struct {
	VirtualMachineFileLayoutExDiskUnit []VirtualMachineFileLayoutExDiskUnit `xml:"VirtualMachineFileLayoutExDiskUnit,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineFileLayoutExDiskUnit"] = reflect.TypeOf((*ArrayOfVirtualMachineFileLayoutExDiskUnit)(nil)).Elem()
}

// A boxed array of `VirtualMachineFileLayoutExFileInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineFileLayoutExFileInfo struct {
	VirtualMachineFileLayoutExFileInfo []VirtualMachineFileLayoutExFileInfo `xml:"VirtualMachineFileLayoutExFileInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineFileLayoutExFileInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineFileLayoutExFileInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineFileLayoutExSnapshotLayout`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineFileLayoutExSnapshotLayout struct {
	VirtualMachineFileLayoutExSnapshotLayout []VirtualMachineFileLayoutExSnapshotLayout `xml:"VirtualMachineFileLayoutExSnapshotLayout,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineFileLayoutExSnapshotLayout"] = reflect.TypeOf((*ArrayOfVirtualMachineFileLayoutExSnapshotLayout)(nil)).Elem()
}

// A boxed array of `VirtualMachineFileLayoutSnapshotLayout`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineFileLayoutSnapshotLayout struct {
	VirtualMachineFileLayoutSnapshotLayout []VirtualMachineFileLayoutSnapshotLayout `xml:"VirtualMachineFileLayoutSnapshotLayout,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineFileLayoutSnapshotLayout"] = reflect.TypeOf((*ArrayOfVirtualMachineFileLayoutSnapshotLayout)(nil)).Elem()
}

// A boxed array of `VirtualMachineFloppyInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineFloppyInfo struct {
	VirtualMachineFloppyInfo []VirtualMachineFloppyInfo `xml:"VirtualMachineFloppyInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineFloppyInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineFloppyInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineIdeDiskDeviceInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineIdeDiskDeviceInfo struct {
	VirtualMachineIdeDiskDeviceInfo []VirtualMachineIdeDiskDeviceInfo `xml:"VirtualMachineIdeDiskDeviceInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineIdeDiskDeviceInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineIdeDiskDeviceInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineIdeDiskDevicePartitionInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineIdeDiskDevicePartitionInfo struct {
	VirtualMachineIdeDiskDevicePartitionInfo []VirtualMachineIdeDiskDevicePartitionInfo `xml:"VirtualMachineIdeDiskDevicePartitionInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineIdeDiskDevicePartitionInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineIdeDiskDevicePartitionInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineLegacyNetworkSwitchInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineLegacyNetworkSwitchInfo struct {
	VirtualMachineLegacyNetworkSwitchInfo []VirtualMachineLegacyNetworkSwitchInfo `xml:"VirtualMachineLegacyNetworkSwitchInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineLegacyNetworkSwitchInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineLegacyNetworkSwitchInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineMessage`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineMessage struct {
	VirtualMachineMessage []VirtualMachineMessage `xml:"VirtualMachineMessage,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineMessage"] = reflect.TypeOf((*ArrayOfVirtualMachineMessage)(nil)).Elem()
}

// A boxed array of `VirtualMachineMetadataManagerVmMetadataInput`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineMetadataManagerVmMetadataInput struct {
	VirtualMachineMetadataManagerVmMetadataInput []VirtualMachineMetadataManagerVmMetadataInput `xml:"VirtualMachineMetadataManagerVmMetadataInput,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineMetadataManagerVmMetadataInput"] = reflect.TypeOf((*ArrayOfVirtualMachineMetadataManagerVmMetadataInput)(nil)).Elem()
}

// A boxed array of `VirtualMachineMetadataManagerVmMetadataResult`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineMetadataManagerVmMetadataResult struct {
	VirtualMachineMetadataManagerVmMetadataResult []VirtualMachineMetadataManagerVmMetadataResult `xml:"VirtualMachineMetadataManagerVmMetadataResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineMetadataManagerVmMetadataResult"] = reflect.TypeOf((*ArrayOfVirtualMachineMetadataManagerVmMetadataResult)(nil)).Elem()
}

// A boxed array of `VirtualMachineNetworkInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineNetworkInfo struct {
	VirtualMachineNetworkInfo []VirtualMachineNetworkInfo `xml:"VirtualMachineNetworkInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineNetworkInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineNetworkInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineParallelInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineParallelInfo struct {
	VirtualMachineParallelInfo []VirtualMachineParallelInfo `xml:"VirtualMachineParallelInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineParallelInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineParallelInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachinePciPassthroughInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachinePciPassthroughInfo struct {
	VirtualMachinePciPassthroughInfo []BaseVirtualMachinePciPassthroughInfo `xml:"VirtualMachinePciPassthroughInfo,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachinePciPassthroughInfo"] = reflect.TypeOf((*ArrayOfVirtualMachinePciPassthroughInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachinePciSharedGpuPassthroughInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachinePciSharedGpuPassthroughInfo struct {
	VirtualMachinePciSharedGpuPassthroughInfo []VirtualMachinePciSharedGpuPassthroughInfo `xml:"VirtualMachinePciSharedGpuPassthroughInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachinePciSharedGpuPassthroughInfo"] = reflect.TypeOf((*ArrayOfVirtualMachinePciSharedGpuPassthroughInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachinePrecisionClockInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachinePrecisionClockInfo struct {
	VirtualMachinePrecisionClockInfo []VirtualMachinePrecisionClockInfo `xml:"VirtualMachinePrecisionClockInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachinePrecisionClockInfo"] = reflect.TypeOf((*ArrayOfVirtualMachinePrecisionClockInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineProfileDetailsDiskProfileDetails`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineProfileDetailsDiskProfileDetails struct {
	VirtualMachineProfileDetailsDiskProfileDetails []VirtualMachineProfileDetailsDiskProfileDetails `xml:"VirtualMachineProfileDetailsDiskProfileDetails,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineProfileDetailsDiskProfileDetails"] = reflect.TypeOf((*ArrayOfVirtualMachineProfileDetailsDiskProfileDetails)(nil)).Elem()
}

// A boxed array of `VirtualMachineProfileSpec`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineProfileSpec struct {
	VirtualMachineProfileSpec []BaseVirtualMachineProfileSpec `xml:"VirtualMachineProfileSpec,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineProfileSpec"] = reflect.TypeOf((*ArrayOfVirtualMachineProfileSpec)(nil)).Elem()
}

// A boxed array of `VirtualMachinePropertyRelation`. To be used in `Any` placeholders.
type ArrayOfVirtualMachinePropertyRelation struct {
	VirtualMachinePropertyRelation []VirtualMachinePropertyRelation `xml:"VirtualMachinePropertyRelation,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachinePropertyRelation"] = reflect.TypeOf((*ArrayOfVirtualMachinePropertyRelation)(nil)).Elem()
}

// A boxed array of `VirtualMachineQuickStatsMemoryTierStats`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineQuickStatsMemoryTierStats struct {
	VirtualMachineQuickStatsMemoryTierStats []VirtualMachineQuickStatsMemoryTierStats `xml:"VirtualMachineQuickStatsMemoryTierStats,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineQuickStatsMemoryTierStats"] = reflect.TypeOf((*ArrayOfVirtualMachineQuickStatsMemoryTierStats)(nil)).Elem()
	minAPIVersionForType["ArrayOfVirtualMachineQuickStatsMemoryTierStats"] = "7.0.3.0"
}

// A boxed array of `VirtualMachineRelocateSpecDiskLocator`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineRelocateSpecDiskLocator struct {
	VirtualMachineRelocateSpecDiskLocator []VirtualMachineRelocateSpecDiskLocator `xml:"VirtualMachineRelocateSpecDiskLocator,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineRelocateSpecDiskLocator"] = reflect.TypeOf((*ArrayOfVirtualMachineRelocateSpecDiskLocator)(nil)).Elem()
}

// A boxed array of `VirtualMachineScsiDiskDeviceInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineScsiDiskDeviceInfo struct {
	VirtualMachineScsiDiskDeviceInfo []VirtualMachineScsiDiskDeviceInfo `xml:"VirtualMachineScsiDiskDeviceInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineScsiDiskDeviceInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineScsiDiskDeviceInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineScsiPassthroughInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineScsiPassthroughInfo struct {
	VirtualMachineScsiPassthroughInfo []VirtualMachineScsiPassthroughInfo `xml:"VirtualMachineScsiPassthroughInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineScsiPassthroughInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineScsiPassthroughInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineSerialInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineSerialInfo struct {
	VirtualMachineSerialInfo []VirtualMachineSerialInfo `xml:"VirtualMachineSerialInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineSerialInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineSerialInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineSnapshotTree`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineSnapshotTree struct {
	VirtualMachineSnapshotTree []VirtualMachineSnapshotTree `xml:"VirtualMachineSnapshotTree,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineSnapshotTree"] = reflect.TypeOf((*ArrayOfVirtualMachineSnapshotTree)(nil)).Elem()
}

// A boxed array of `VirtualMachineSoundInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineSoundInfo struct {
	VirtualMachineSoundInfo []VirtualMachineSoundInfo `xml:"VirtualMachineSoundInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineSoundInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineSoundInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineSriovInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineSriovInfo struct {
	VirtualMachineSriovInfo []VirtualMachineSriovInfo `xml:"VirtualMachineSriovInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineSriovInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineSriovInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineSummary`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineSummary struct {
	VirtualMachineSummary []VirtualMachineSummary `xml:"VirtualMachineSummary,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineSummary"] = reflect.TypeOf((*ArrayOfVirtualMachineSummary)(nil)).Elem()
}

// A boxed array of `VirtualMachineUsageOnDatastore`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineUsageOnDatastore struct {
	VirtualMachineUsageOnDatastore []VirtualMachineUsageOnDatastore `xml:"VirtualMachineUsageOnDatastore,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineUsageOnDatastore"] = reflect.TypeOf((*ArrayOfVirtualMachineUsageOnDatastore)(nil)).Elem()
}

// A boxed array of `VirtualMachineUsbInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineUsbInfo struct {
	VirtualMachineUsbInfo []VirtualMachineUsbInfo `xml:"VirtualMachineUsbInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineUsbInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineUsbInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineVFlashModuleInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineVFlashModuleInfo struct {
	VirtualMachineVFlashModuleInfo []VirtualMachineVFlashModuleInfo `xml:"VirtualMachineVFlashModuleInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineVFlashModuleInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineVFlashModuleInfo)(nil)).Elem()
}

// A boxed array of `VirtualMachineVMCIDeviceFilterSpec`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineVMCIDeviceFilterSpec struct {
	VirtualMachineVMCIDeviceFilterSpec []VirtualMachineVMCIDeviceFilterSpec `xml:"VirtualMachineVMCIDeviceFilterSpec,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineVMCIDeviceFilterSpec"] = reflect.TypeOf((*ArrayOfVirtualMachineVMCIDeviceFilterSpec)(nil)).Elem()
}

// A boxed array of `VirtualMachineVMotionStunTimeInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineVMotionStunTimeInfo struct {
	VirtualMachineVMotionStunTimeInfo []VirtualMachineVMotionStunTimeInfo `xml:"VirtualMachineVMotionStunTimeInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineVMotionStunTimeInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineVMotionStunTimeInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfVirtualMachineVMotionStunTimeInfo"] = "8.0.2.0"
}

// A boxed array of `VirtualMachineVcpuConfig`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineVcpuConfig struct {
	VirtualMachineVcpuConfig []VirtualMachineVcpuConfig `xml:"VirtualMachineVcpuConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineVcpuConfig"] = reflect.TypeOf((*ArrayOfVirtualMachineVcpuConfig)(nil)).Elem()
}

// A boxed array of `VirtualMachineVendorDeviceGroupInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineVendorDeviceGroupInfo struct {
	VirtualMachineVendorDeviceGroupInfo []VirtualMachineVendorDeviceGroupInfo `xml:"VirtualMachineVendorDeviceGroupInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineVendorDeviceGroupInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineVendorDeviceGroupInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfVirtualMachineVendorDeviceGroupInfo"] = "8.0.0.1"
}

// A boxed array of `VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineVendorDeviceGroupInfoComponentDeviceInfo struct {
	VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo []VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo `xml:"VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineVendorDeviceGroupInfoComponentDeviceInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineVendorDeviceGroupInfoComponentDeviceInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfVirtualMachineVendorDeviceGroupInfoComponentDeviceInfo"] = "8.0.0.1"
}

// A boxed array of `VirtualMachineVgpuDeviceInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineVgpuDeviceInfo struct {
	VirtualMachineVgpuDeviceInfo []VirtualMachineVgpuDeviceInfo `xml:"VirtualMachineVgpuDeviceInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineVgpuDeviceInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineVgpuDeviceInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfVirtualMachineVgpuDeviceInfo"] = "7.0.3.0"
}

// A boxed array of `VirtualMachineVgpuProfileInfo`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineVgpuProfileInfo struct {
	VirtualMachineVgpuProfileInfo []VirtualMachineVgpuProfileInfo `xml:"VirtualMachineVgpuProfileInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineVgpuProfileInfo"] = reflect.TypeOf((*ArrayOfVirtualMachineVgpuProfileInfo)(nil)).Elem()
	minAPIVersionForType["ArrayOfVirtualMachineVgpuProfileInfo"] = "7.0.3.0"
}

// A boxed array of `VirtualMachineVirtualDeviceGroupsDeviceGroup`. To be used in `Any` placeholders.
type ArrayOfVirtualMachineVirtualDeviceGroupsDeviceGroup struct {
	VirtualMachineVirtualDeviceGroupsDeviceGroup []BaseVirtualMachineVirtualDeviceGroupsDeviceGroup `xml:"VirtualMachineVirtualDeviceGroupsDeviceGroup,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfVirtualMachineVirtualDeviceGroupsDeviceGroup"] = reflect.TypeOf((*ArrayOfVirtualMachineVirtualDeviceGroupsDeviceGroup)(nil)).Elem()
}

// A boxed array of `VirtualNicManagerNetConfig`. To be used in `Any` placeholders.
type ArrayOfVirtualNicManagerNetConfig struct {
	VirtualNicManagerNetConfig []VirtualNicManagerNetConfig `xml:"VirtualNicManagerNetConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualNicManagerNetConfig"] = reflect.TypeOf((*ArrayOfVirtualNicManagerNetConfig)(nil)).Elem()
}

// A boxed array of `VirtualPCIPassthroughAllowedDevice`. To be used in `Any` placeholders.
type ArrayOfVirtualPCIPassthroughAllowedDevice struct {
	VirtualPCIPassthroughAllowedDevice []VirtualPCIPassthroughAllowedDevice `xml:"VirtualPCIPassthroughAllowedDevice,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualPCIPassthroughAllowedDevice"] = reflect.TypeOf((*ArrayOfVirtualPCIPassthroughAllowedDevice)(nil)).Elem()
}

// A boxed array of `VirtualSCSISharing_enum`. To be used in `Any` placeholders.
type ArrayOfVirtualSCSISharing struct {
	VirtualSCSISharing []VirtualSCSISharing `xml:"VirtualSCSISharing,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualSCSISharing"] = reflect.TypeOf((*ArrayOfVirtualSCSISharing)(nil)).Elem()
}

// A boxed array of `VirtualSwitchProfile`. To be used in `Any` placeholders.
type ArrayOfVirtualSwitchProfile struct {
	VirtualSwitchProfile []VirtualSwitchProfile `xml:"VirtualSwitchProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVirtualSwitchProfile"] = reflect.TypeOf((*ArrayOfVirtualSwitchProfile)(nil)).Elem()
}

// A boxed array of `VmEventArgument`. To be used in `Any` placeholders.
type ArrayOfVmEventArgument struct {
	VmEventArgument []VmEventArgument `xml:"VmEventArgument,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVmEventArgument"] = reflect.TypeOf((*ArrayOfVmEventArgument)(nil)).Elem()
}

// A boxed array of `VmPodConfigForPlacement`. To be used in `Any` placeholders.
type ArrayOfVmPodConfigForPlacement struct {
	VmPodConfigForPlacement []VmPodConfigForPlacement `xml:"VmPodConfigForPlacement,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVmPodConfigForPlacement"] = reflect.TypeOf((*ArrayOfVmPodConfigForPlacement)(nil)).Elem()
}

// A boxed array of `VmPortGroupProfile`. To be used in `Any` placeholders.
type ArrayOfVmPortGroupProfile struct {
	VmPortGroupProfile []VmPortGroupProfile `xml:"VmPortGroupProfile,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVmPortGroupProfile"] = reflect.TypeOf((*ArrayOfVmPortGroupProfile)(nil)).Elem()
}

// A boxed array of `VmfsConfigOption`. To be used in `Any` placeholders.
type ArrayOfVmfsConfigOption struct {
	VmfsConfigOption []VmfsConfigOption `xml:"VmfsConfigOption,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVmfsConfigOption"] = reflect.TypeOf((*ArrayOfVmfsConfigOption)(nil)).Elem()
}

// A boxed array of `VmfsDatastoreOption`. To be used in `Any` placeholders.
type ArrayOfVmfsDatastoreOption struct {
	VmfsDatastoreOption []VmfsDatastoreOption `xml:"VmfsDatastoreOption,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVmfsDatastoreOption"] = reflect.TypeOf((*ArrayOfVmfsDatastoreOption)(nil)).Elem()
}

// A boxed array of `VnicPortArgument`. To be used in `Any` placeholders.
type ArrayOfVnicPortArgument struct {
	VnicPortArgument []VnicPortArgument `xml:"VnicPortArgument,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVnicPortArgument"] = reflect.TypeOf((*ArrayOfVnicPortArgument)(nil)).Elem()
}

// A boxed array of `VsanHostConfigInfo`. To be used in `Any` placeholders.
type ArrayOfVsanHostConfigInfo struct {
	VsanHostConfigInfo []VsanHostConfigInfo `xml:"VsanHostConfigInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVsanHostConfigInfo"] = reflect.TypeOf((*ArrayOfVsanHostConfigInfo)(nil)).Elem()
}

// A boxed array of `VsanHostConfigInfoNetworkInfoPortConfig`. To be used in `Any` placeholders.
type ArrayOfVsanHostConfigInfoNetworkInfoPortConfig struct {
	VsanHostConfigInfoNetworkInfoPortConfig []VsanHostConfigInfoNetworkInfoPortConfig `xml:"VsanHostConfigInfoNetworkInfoPortConfig,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVsanHostConfigInfoNetworkInfoPortConfig"] = reflect.TypeOf((*ArrayOfVsanHostConfigInfoNetworkInfoPortConfig)(nil)).Elem()
}

// A boxed array of `VsanHostDiskMapInfo`. To be used in `Any` placeholders.
type ArrayOfVsanHostDiskMapInfo struct {
	VsanHostDiskMapInfo []VsanHostDiskMapInfo `xml:"VsanHostDiskMapInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVsanHostDiskMapInfo"] = reflect.TypeOf((*ArrayOfVsanHostDiskMapInfo)(nil)).Elem()
}

// A boxed array of `VsanHostDiskMapResult`. To be used in `Any` placeholders.
type ArrayOfVsanHostDiskMapResult struct {
	VsanHostDiskMapResult []VsanHostDiskMapResult `xml:"VsanHostDiskMapResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVsanHostDiskMapResult"] = reflect.TypeOf((*ArrayOfVsanHostDiskMapResult)(nil)).Elem()
}

// A boxed array of `VsanHostDiskMapping`. To be used in `Any` placeholders.
type ArrayOfVsanHostDiskMapping struct {
	VsanHostDiskMapping []VsanHostDiskMapping `xml:"VsanHostDiskMapping,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVsanHostDiskMapping"] = reflect.TypeOf((*ArrayOfVsanHostDiskMapping)(nil)).Elem()
}

// A boxed array of `VsanHostDiskResult`. To be used in `Any` placeholders.
type ArrayOfVsanHostDiskResult struct {
	VsanHostDiskResult []VsanHostDiskResult `xml:"VsanHostDiskResult,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVsanHostDiskResult"] = reflect.TypeOf((*ArrayOfVsanHostDiskResult)(nil)).Elem()
}

// A boxed array of `VsanHostMembershipInfo`. To be used in `Any` placeholders.
type ArrayOfVsanHostMembershipInfo struct {
	VsanHostMembershipInfo []VsanHostMembershipInfo `xml:"VsanHostMembershipInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVsanHostMembershipInfo"] = reflect.TypeOf((*ArrayOfVsanHostMembershipInfo)(nil)).Elem()
}

// A boxed array of `VsanHostRuntimeInfoDiskIssue`. To be used in `Any` placeholders.
type ArrayOfVsanHostRuntimeInfoDiskIssue struct {
	VsanHostRuntimeInfoDiskIssue []VsanHostRuntimeInfoDiskIssue `xml:"VsanHostRuntimeInfoDiskIssue,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVsanHostRuntimeInfoDiskIssue"] = reflect.TypeOf((*ArrayOfVsanHostRuntimeInfoDiskIssue)(nil)).Elem()
}

// A boxed array of `VsanNewPolicyBatch`. To be used in `Any` placeholders.
type ArrayOfVsanNewPolicyBatch struct {
	VsanNewPolicyBatch []VsanNewPolicyBatch `xml:"VsanNewPolicyBatch,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVsanNewPolicyBatch"] = reflect.TypeOf((*ArrayOfVsanNewPolicyBatch)(nil)).Elem()
}

// A boxed array of `VsanPolicyChangeBatch`. To be used in `Any` placeholders.
type ArrayOfVsanPolicyChangeBatch struct {
	VsanPolicyChangeBatch []VsanPolicyChangeBatch `xml:"VsanPolicyChangeBatch,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVsanPolicyChangeBatch"] = reflect.TypeOf((*ArrayOfVsanPolicyChangeBatch)(nil)).Elem()
}

// A boxed array of `VsanPolicySatisfiability`. To be used in `Any` placeholders.
type ArrayOfVsanPolicySatisfiability struct {
	VsanPolicySatisfiability []VsanPolicySatisfiability `xml:"VsanPolicySatisfiability,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVsanPolicySatisfiability"] = reflect.TypeOf((*ArrayOfVsanPolicySatisfiability)(nil)).Elem()
}

// A boxed array of `VsanUpgradeSystemNetworkPartitionInfo`. To be used in `Any` placeholders.
type ArrayOfVsanUpgradeSystemNetworkPartitionInfo struct {
	VsanUpgradeSystemNetworkPartitionInfo []VsanUpgradeSystemNetworkPartitionInfo `xml:"VsanUpgradeSystemNetworkPartitionInfo,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVsanUpgradeSystemNetworkPartitionInfo"] = reflect.TypeOf((*ArrayOfVsanUpgradeSystemNetworkPartitionInfo)(nil)).Elem()
}

// A boxed array of `VsanUpgradeSystemPreflightCheckIssue`. To be used in `Any` placeholders.
type ArrayOfVsanUpgradeSystemPreflightCheckIssue struct {
	VsanUpgradeSystemPreflightCheckIssue []BaseVsanUpgradeSystemPreflightCheckIssue `xml:"VsanUpgradeSystemPreflightCheckIssue,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfVsanUpgradeSystemPreflightCheckIssue"] = reflect.TypeOf((*ArrayOfVsanUpgradeSystemPreflightCheckIssue)(nil)).Elem()
}

// A boxed array of `VsanUpgradeSystemUpgradeHistoryItem`. To be used in `Any` placeholders.
type ArrayOfVsanUpgradeSystemUpgradeHistoryItem struct {
	VsanUpgradeSystemUpgradeHistoryItem []BaseVsanUpgradeSystemUpgradeHistoryItem `xml:"VsanUpgradeSystemUpgradeHistoryItem,omitempty,typeattr" json:"_value"`
}

func init() {
	t["ArrayOfVsanUpgradeSystemUpgradeHistoryItem"] = reflect.TypeOf((*ArrayOfVsanUpgradeSystemUpgradeHistoryItem)(nil)).Elem()
}

// A boxed array of `VslmTagEntry`. To be used in `Any` placeholders.
type ArrayOfVslmTagEntry struct {
	VslmTagEntry []VslmTagEntry `xml:"VslmTagEntry,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfVslmTagEntry"] = reflect.TypeOf((*ArrayOfVslmTagEntry)(nil)).Elem()
}

type ArrayOfVslmInfrastructureObjectPolicy struct {
	VslmInfrastructureObjectPolicy []VslmInfrastructureObjectPolicy `xml:"vslmInfrastructureObjectPolicy,omitempty" json:"_value"`
}

func init() {
	t["ArrayOfvslmInfrastructureObjectPolicy"] = reflect.TypeOf((*ArrayOfVslmInfrastructureObjectPolicy)(nil)).Elem()
}

// An ArrayUpdateSpec data object type is a common superclass
// for supporting incremental updates to arrays.
//
// The common code pattern is:
//
//	class MyTypeSpec extrends ArrayUpdateSpec {
//	      MyTypeInfo info;
//	}
//
// The ArrayUpdateSpec contains the following:
//   - `*operation*`: the type of operation being performed.
//   - `*removeKey*`: In the case of a remove operation, the
//     key value that identifies the array to be removed.
type ArrayUpdateSpec struct {
	DynamicData

	// The type of operation being performed on the specified virtual device.
	Operation ArrayUpdateOperation `xml:"operation" json:"operation"`
	// Key for the element to be removed.
	//
	// Only used if the operation
	// is "remove".
	RemoveKey AnyType `xml:"removeKey,omitempty,typeattr" json:"removeKey,omitempty"`
}

func init() {
	t["ArrayUpdateSpec"] = reflect.TypeOf((*ArrayUpdateSpec)(nil)).Elem()
}

type AssignUserToGroup AssignUserToGroupRequestType

func init() {
	t["AssignUserToGroup"] = reflect.TypeOf((*AssignUserToGroup)(nil)).Elem()
}

// The parameters of `HostLocalAccountManager.AssignUserToGroup`.
type AssignUserToGroupRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// User ID of the account whose group membership is
	// being assigned.
	User string `xml:"user" json:"user"`
	// Destination group account to which the user is
	// being assigned.
	Group string `xml:"group" json:"group"`
}

func init() {
	t["AssignUserToGroupRequestType"] = reflect.TypeOf((*AssignUserToGroupRequestType)(nil)).Elem()
}

type AssignUserToGroupResponse struct {
}

type AssociateProfile AssociateProfileRequestType

func init() {
	t["AssociateProfile"] = reflect.TypeOf((*AssociateProfile)(nil)).Elem()
}

// The parameters of `Profile.AssociateProfile`.
type AssociateProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The entity(s) to associate with the profile.
	// If an entity is already associated with the profile, the association is
	// maintained and the vCenter Server does not perform any action.
	//
	// Refers instances of `ManagedEntity`.
	Entity []ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["AssociateProfileRequestType"] = reflect.TypeOf((*AssociateProfileRequestType)(nil)).Elem()
}

type AssociateProfileResponse struct {
}

// The parameters of `VirtualMachine.AttachDisk_Task`.
type AttachDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual disk to be operated. See
	// `ID`
	DiskId ID `xml:"diskId" json:"diskId"`
	// The datastore where the virtual disk is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// Key of the controller the disk will connect to.
	// It can be unset if there is only one controller
	// (SCSI or SATA) with the available slot in the
	// virtual machine. If there are multiple SCSI or
	// SATA controllers available, user must specify
	// the controller; if there is no available
	// controllers, a `MissingController`
	// fault will be thrown.
	ControllerKey int32 `xml:"controllerKey,omitempty" json:"controllerKey,omitempty"`
	// The unit number of the attached disk on its controller.
	// If unset, the next available slot on the specified
	// controller or the only available controller will be
	// assigned to the attached disk.
	UnitNumber *int32 `xml:"unitNumber" json:"unitNumber,omitempty"`
}

func init() {
	t["AttachDiskRequestType"] = reflect.TypeOf((*AttachDiskRequestType)(nil)).Elem()
}

type AttachDisk_Task AttachDiskRequestType

func init() {
	t["AttachDisk_Task"] = reflect.TypeOf((*AttachDisk_Task)(nil)).Elem()
}

type AttachDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type AttachScsiLun AttachScsiLunRequestType

func init() {
	t["AttachScsiLun"] = reflect.TypeOf((*AttachScsiLun)(nil)).Elem()
}

// The parameters of `HostStorageSystem.AttachScsiLunEx_Task`.
type AttachScsiLunExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// each element specifies UUID of LUN to be attached.
	LunUuid []string `xml:"lunUuid" json:"lunUuid"`
}

func init() {
	t["AttachScsiLunExRequestType"] = reflect.TypeOf((*AttachScsiLunExRequestType)(nil)).Elem()
}

type AttachScsiLunEx_Task AttachScsiLunExRequestType

func init() {
	t["AttachScsiLunEx_Task"] = reflect.TypeOf((*AttachScsiLunEx_Task)(nil)).Elem()
}

type AttachScsiLunEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostStorageSystem.AttachScsiLun`.
type AttachScsiLunRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The uuid of the ScsiLun to update.
	LunUuid string `xml:"lunUuid" json:"lunUuid"`
}

func init() {
	t["AttachScsiLunRequestType"] = reflect.TypeOf((*AttachScsiLunRequestType)(nil)).Elem()
}

type AttachScsiLunResponse struct {
}

type AttachTagToVStorageObject AttachTagToVStorageObjectRequestType

func init() {
	t["AttachTagToVStorageObject"] = reflect.TypeOf((*AttachTagToVStorageObject)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.AttachTagToVStorageObject`.
type AttachTagToVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The identifier(ID) of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The category to which the tag belongs.
	Category string `xml:"category" json:"category"`
	// The tag which has to be associated with the virtual storage
	// object.
	Tag string `xml:"tag" json:"tag"`
}

func init() {
	t["AttachTagToVStorageObjectRequestType"] = reflect.TypeOf((*AttachTagToVStorageObjectRequestType)(nil)).Elem()
}

type AttachTagToVStorageObjectResponse struct {
}

type AttachVmfsExtent AttachVmfsExtentRequestType

func init() {
	t["AttachVmfsExtent"] = reflect.TypeOf((*AttachVmfsExtent)(nil)).Elem()
}

// The parameters of `HostStorageSystem.AttachVmfsExtent`.
type AttachVmfsExtentRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The path of the VMFS to extend. See `FileSystemMountInfo`.
	VmfsPath string `xml:"vmfsPath" json:"vmfsPath"`
	// A data object that describes the specification of a
	// Disk partition.
	Extent HostScsiDiskPartition `xml:"extent" json:"extent"`
}

func init() {
	t["AttachVmfsExtentRequestType"] = reflect.TypeOf((*AttachVmfsExtentRequestType)(nil)).Elem()
}

type AttachVmfsExtentResponse struct {
}

// This fault is thrown when the requested change
// would result in a loss of full administrative privileges
// for at least one user or group.
type AuthMinimumAdminPermission struct {
	VimFault
}

func init() {
	t["AuthMinimumAdminPermission"] = reflect.TypeOf((*AuthMinimumAdminPermission)(nil)).Elem()
}

type AuthMinimumAdminPermissionFault AuthMinimumAdminPermission

func init() {
	t["AuthMinimumAdminPermissionFault"] = reflect.TypeOf((*AuthMinimumAdminPermissionFault)(nil)).Elem()
}

// The `AuthenticationProfile` data object represents the host configuration
// for authentication.
//
// If a profile plug-in defines policies or subprofiles, use the
// `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the additional configuration data.
type AuthenticationProfile struct {
	ApplyProfile

	// Subprofile representing the Active Directory configuration.
	ActiveDirectory *ActiveDirectoryProfile `xml:"activeDirectory,omitempty" json:"activeDirectory,omitempty"`
}

func init() {
	t["AuthenticationProfile"] = reflect.TypeOf((*AuthenticationProfile)(nil)).Elem()
}

// Static strings for authorization.
type AuthorizationDescription struct {
	DynamicData

	// Description of the privilege.
	Privilege []BaseElementDescription `xml:"privilege,typeattr" json:"privilege"`
	// Description of a category of similar privileges, grouped
	// together for convenience.
	PrivilegeGroup []BaseElementDescription `xml:"privilegeGroup,typeattr" json:"privilegeGroup"`
}

func init() {
	t["AuthorizationDescription"] = reflect.TypeOf((*AuthorizationDescription)(nil)).Elem()
}

// These events indicate authorization events.
type AuthorizationEvent struct {
	Event
}

func init() {
	t["AuthorizationEvent"] = reflect.TypeOf((*AuthorizationEvent)(nil)).Elem()
}

// This data object type provides access to some aspect of the system.
//
// Privileges are generally independent. This means a user with a privilege
// usually can perform an associated set of actions without needing any
// additional supporting privileges.
//
// Within each product version, privileges do not change.
// See `AuthorizationDescription` for
// detailed information on the privileges defined by the system.
type AuthorizationPrivilege struct {
	DynamicData

	// Unique identifier.
	PrivId string `xml:"privId" json:"privId"`
	// Determines whether or not the privilege is applied on the parent entity.
	OnParent bool `xml:"onParent" json:"onParent"`
	// Privilege name.
	Name string `xml:"name" json:"name"`
	// Group name.
	PrivGroupName string `xml:"privGroupName" json:"privGroupName"`
}

func init() {
	t["AuthorizationPrivilege"] = reflect.TypeOf((*AuthorizationPrivilege)(nil)).Elem()
}

// This data object type specifies a collection of privileges used
// to grant access to users on managed entities.
type AuthorizationRole struct {
	DynamicData

	// Unique role identifier.
	RoleId int32 `xml:"roleId" json:"roleId"`
	// Whether or not the role is system-defined.
	//
	// System-defined roles cannot be
	// changed.
	System bool `xml:"system" json:"system"`
	// System-defined or user-defined role name.
	Name string `xml:"name" json:"name"`
	// Displayable role information.
	Info BaseDescription `xml:"info,typeattr" json:"info"`
	// Privileges provided by this role, by privilege identifier.
	Privilege []string `xml:"privilege,omitempty" json:"privilege,omitempty"`
}

func init() {
	t["AuthorizationRole"] = reflect.TypeOf((*AuthorizationRole)(nil)).Elem()
}

// Defines the system default auto-start/auto-stop values.
type AutoStartDefaults struct {
	DynamicData

	// Indicates whether or not auto-start manager is enabled.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// System-default autoStart delay in seconds.
	//
	// The default is 120 seconds.
	StartDelay int32 `xml:"startDelay,omitempty" json:"startDelay,omitempty"`
	// System-default autoStop delay in seconds.
	//
	// The default is 120 seconds.
	StopDelay int32 `xml:"stopDelay,omitempty" json:"stopDelay,omitempty"`
	// System-default waitForHeartbeat setting.
	WaitForHeartbeat *bool `xml:"waitForHeartbeat" json:"waitForHeartbeat,omitempty"`
	// System-default power-off action.
	//
	// Used if the stopAction string in the
	// AutoPowerInfo object for a particular machine is set to systemDefault.
	// If stopAction and startAction for a virtual machine are both set to none,
	// that virtual machine is removed from the AutoStart sequence.
	StopAction string `xml:"stopAction,omitempty" json:"stopAction,omitempty"`
}

func init() {
	t["AutoStartDefaults"] = reflect.TypeOf((*AutoStartDefaults)(nil)).Elem()
}

// This object type describes the power-on / power-off behavior for a given virtual
// machine.
//
// Virtual machines can be configured to wait for a period of time before
// starting or to wait to receive a successful heartbeat from a virtual machine
// before starting the next virtual machine in the sequence.
//   - For a power-on operation, if waitForHeartbeat is true, then the power-on
//     sequence continues after the first heartbeat has been received. If
//     waitForHeartbeat is false, the system waits for the specified delay and
//     then continues the power-on sequence.
//   - For a power-off operation, if delay is non-zero, the requested power-off
//     action is invoked (powerOff, suspend, guestShutdown) on the virtual
//     machine and the system waits until the number of seconds specified in the
//     delay have passed.
//
// If startAction and stopAction for a virtual machine are both set to none, that
// virtual machine is removed from the AutoStart sequence.
// Virtual machines can be configured both to wait for a period of time before
// starting and to wait for a heartbeat. In such a case, the waiting virtual machine
// only waits until either of these conditions are met. In other words, a virtual
// machine starts in either of the following cases:
//   - After receiving a heartbeat but before the start delay has elapsed
//   - After the start delay has elapsed but before receiving a heartbeat
//
// This provides a better experience since as soon as one virtual machine begins
// sending heartbeats, indicating it has successfully started up, the next machine
// will begin starting up. This happens even if the startDelay has not yet elapsed.
// Similarly, if one virtual machine fails to begin sending heartbeats, perhaps
// because it could not start up, other machines are not blocked from starting up
// since the startDelay eventually elapses.
type AutoStartPowerInfo struct {
	DynamicData

	// Virtual machine to power on or power off.
	//
	// Refers instance of `VirtualMachine`.
	Key ManagedObjectReference `xml:"key" json:"key"`
	// The autostart priority of this virtual machine.
	//
	// Virtual machines with a lower
	// number are powered on first. On host shutdown, the virtual machines are
	// shut down in reverse order, meaning those with a higher number are powered off
	// first.
	//
	// Positive values indicate a start order and -1 indicates the machine can be
	// powered on at any time. Machines with a -1 value are typically powered on and
	// off after all virtual machines with positive startOrder values. Failure to
	// meet the following requirements results in an InvalidArgument exception:
	//   - startOrder must be set to -1 if startAction is set to none
	//   - startOrder must be -1 or positive integers. Values such as 0 or
	//     \-2 are not valid.
	//   - startOrder is relative to other virtual machines in the autostart
	//     sequence. Hence specifying a startOrder of 4 when there are only 3
	//     virtual machines in the Autostart sequence is not valid.
	//
	// If a newly established or changed startOrder value for a virtual machine
	// matches an existing startOrder value, the newly applied value takes
	// precedence, and the existing value is incremented by one. The incremented
	// startOrder value is checked for collisions, and the same rule is applied if
	// one is found. This simple system ensures no two virtual machines ever have the
	// same order number.
	//
	// For example, consider the case where there are three virtual machines with
	// different startOrder values. Virtual machine A has not yet established a
	// startOrder, virtual machine B has a startOrder value of 1 and Virtual Machine
	// C has a startOrder value of 2. If virtual machine A's startOrder is set to 1,
	// then virtual machine B's startOrder is incremented to 2. This creates a
	// conflict with virtual machine C's startOrder value, which is also incremented,
	// this time to 3.
	StartOrder int32 `xml:"startOrder" json:"startOrder"`
	// Delay in seconds before continuing with the next virtual machine in the order
	// of machines to be started.
	//
	// If the delay is specified as -1, then the system
	// default is used.
	StartDelay       int32                         `xml:"startDelay" json:"startDelay"`
	WaitForHeartbeat AutoStartWaitHeartbeatSetting `xml:"waitForHeartbeat" json:"waitForHeartbeat"`
	// How to start the virtual machine.
	//
	// Valid settings are none or powerOn.
	// If set to none, then the virtual machine does not participate in auto-start.
	StartAction string `xml:"startAction" json:"startAction"`
	// Delay in seconds before continuing with the next virtual machine in the order
	// sequence.
	//
	// If the delay is -1, then the system default is used.
	StopDelay int32 `xml:"stopDelay" json:"stopDelay"`
	// Defines the stop action for the virtual machine.
	//
	// Can be set to none,
	// systemDefault, powerOff, or suspend. If set to none, then the virtual machine
	// does not participate in auto-stop.
	StopAction string `xml:"stopAction" json:"stopAction"`
}

func init() {
	t["AutoStartPowerInfo"] = reflect.TypeOf((*AutoStartPowerInfo)(nil)).Elem()
}

type AutoStartPowerOff AutoStartPowerOffRequestType

func init() {
	t["AutoStartPowerOff"] = reflect.TypeOf((*AutoStartPowerOff)(nil)).Elem()
}

type AutoStartPowerOffRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["AutoStartPowerOffRequestType"] = reflect.TypeOf((*AutoStartPowerOffRequestType)(nil)).Elem()
}

type AutoStartPowerOffResponse struct {
}

type AutoStartPowerOn AutoStartPowerOnRequestType

func init() {
	t["AutoStartPowerOn"] = reflect.TypeOf((*AutoStartPowerOn)(nil)).Elem()
}

type AutoStartPowerOnRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["AutoStartPowerOnRequestType"] = reflect.TypeOf((*AutoStartPowerOnRequestType)(nil)).Elem()
}

type AutoStartPowerOnResponse struct {
}

// Thrown if backupConfig blob is corrupted
type BackupBlobReadFailure struct {
	DvsFault

	// The entity name on which backupConfig read failed
	EntityName string `xml:"entityName" json:"entityName"`
	// The entity type on which backupConfig read failed
	EntityType string `xml:"entityType" json:"entityType"`
	// The fault that occurred.
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["BackupBlobReadFailure"] = reflect.TypeOf((*BackupBlobReadFailure)(nil)).Elem()
}

type BackupBlobReadFailureFault BackupBlobReadFailure

func init() {
	t["BackupBlobReadFailureFault"] = reflect.TypeOf((*BackupBlobReadFailureFault)(nil)).Elem()
}

// Thrown if backupConfig blob write fails
type BackupBlobWriteFailure struct {
	DvsFault

	// The entity name on which backupConfig write failed
	EntityName string `xml:"entityName" json:"entityName"`
	// The entity type on which backupConfig write failed
	EntityType string `xml:"entityType" json:"entityType"`
	// The fault that occurred.
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["BackupBlobWriteFailure"] = reflect.TypeOf((*BackupBlobWriteFailure)(nil)).Elem()
}

type BackupBlobWriteFailureFault BackupBlobWriteFailure

func init() {
	t["BackupBlobWriteFailureFault"] = reflect.TypeOf((*BackupBlobWriteFailureFault)(nil)).Elem()
}

type BackupFirmwareConfiguration BackupFirmwareConfigurationRequestType

func init() {
	t["BackupFirmwareConfiguration"] = reflect.TypeOf((*BackupFirmwareConfiguration)(nil)).Elem()
}

type BackupFirmwareConfigurationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["BackupFirmwareConfigurationRequestType"] = reflect.TypeOf((*BackupFirmwareConfigurationRequestType)(nil)).Elem()
}

type BackupFirmwareConfigurationResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// This event records a failed user logon.
//
// Failed logons are due to no match existing
// between the provided user name and password combination and the combinations
// stored for authentication.
type BadUsernameSessionEvent struct {
	SessionEvent

	// The IP address of the peer that initiated the connection.
	//
	// This may
	// be the client that originated the session, or it may be an intervening
	// proxy if the binding uses a protocol that supports proxies, such as HTTP.
	IpAddress string `xml:"ipAddress" json:"ipAddress"`
}

func init() {
	t["BadUsernameSessionEvent"] = reflect.TypeOf((*BadUsernameSessionEvent)(nil)).Elem()
}

// This data object type contains the basic configuration for
// a virtual storage object or a virtual storage object snapshot.
type BaseConfigInfo struct {
	DynamicData

	// ID of this object.
	Id ID `xml:"id" json:"id"`
	// Descriptive name of this object.
	Name string `xml:"name" json:"name"`
	// The date and time this object was created.
	CreateTime time.Time `xml:"createTime" json:"createTime"`
	// Choice of the deletion behavior of this virtual storage object.
	//
	// If not set, the default value is false.
	KeepAfterDeleteVm *bool `xml:"keepAfterDeleteVm" json:"keepAfterDeleteVm,omitempty"`
	// Is virtual storage object relocation disabled.
	//
	// If not set, the default value is false.
	RelocationDisabled *bool `xml:"relocationDisabled" json:"relocationDisabled,omitempty"`
	// Is virtual storage object supports native snapshot.
	//
	// If not set, the default value is false.
	NativeSnapshotSupported *bool `xml:"nativeSnapshotSupported" json:"nativeSnapshotSupported,omitempty"`
	// If Virtua storage object has changed block tracking enabled.
	//
	// If not set, the default value is false.
	ChangedBlockTrackingEnabled *bool `xml:"changedBlockTrackingEnabled" json:"changedBlockTrackingEnabled,omitempty"`
	// Backing of this object.
	Backing BaseBaseConfigInfoBackingInfo `xml:"backing,typeattr" json:"backing"`
	// Metadata associated with the FCD if available.
	Metadata []KeyValue `xml:"metadata,omitempty" json:"metadata,omitempty" vim:"7.0.2.0"`
	// VClock associated with the fcd when the operation completed.
	//
	// The files is unset if the operation is a retrieve.
	Vclock *VslmVClockInfo `xml:"vclock,omitempty" json:"vclock,omitempty" vim:"7.0.2.0"`
	// IDs of the IO Filters associated with the virtual disk.
	//
	// See `IoFilterInfo.id`.
	// The client cannot modify this information on a virtual machine.
	Iofilter []string `xml:"iofilter,omitempty" json:"iofilter,omitempty"`
}

func init() {
	t["BaseConfigInfo"] = reflect.TypeOf((*BaseConfigInfo)(nil)).Elem()
}

// The data object type is a base type of backing of a virtual
// storage object.
type BaseConfigInfoBackingInfo struct {
	DynamicData

	// The datastore managed object where this backing is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["BaseConfigInfoBackingInfo"] = reflect.TypeOf((*BaseConfigInfoBackingInfo)(nil)).Elem()
}

// The data object type for disk file backing of a virtual storage
// object.
//
// Disk file backing provides full virtualization of the backend
// storage.
type BaseConfigInfoDiskFileBackingInfo struct {
	BaseConfigInfoFileBackingInfo

	// Provisioning type.
	//
	// See `BaseConfigInfoDiskFileBackingInfoProvisioningType_enum` for the
	// supported types.
	ProvisioningType string `xml:"provisioningType" json:"provisioningType"`
}

func init() {
	t["BaseConfigInfoDiskFileBackingInfo"] = reflect.TypeOf((*BaseConfigInfoDiskFileBackingInfo)(nil)).Elem()
}

// Information for file backing of a virtual storage
// object.
//
// File backing is mainly used for virtual disks.
type BaseConfigInfoFileBackingInfo struct {
	BaseConfigInfoBackingInfo

	// Full file path for the host file used in this backing.
	FilePath string `xml:"filePath" json:"filePath"`
	// Id refers to the backed storage object where the virtual storage object
	// is backed on.
	BackingObjectId string `xml:"backingObjectId,omitempty" json:"backingObjectId,omitempty"`
	// The parent of this virtual disk file, if this is a delta disk backing.
	//
	// This will be unset if this is the root disk backing.
	//
	// Note that the type of the backing is consistent throughout the chain;
	// any new delta disk backing which is added is of the same type as the
	// original disk. Also note that since the parent backing is not being
	// written to, it is possible that the parent backing may be shared among
	// multiple disks.
	//
	// Only raw disk mappings in
	// *virtual compatibility mode* can have parents.
	Parent BaseBaseConfigInfoFileBackingInfo `xml:"parent,omitempty,typeattr" json:"parent,omitempty"`
	// Size allocated by the FS for this file/chain/link/extent only.
	//
	// This property is used only for a delta disk whose
	// `BaseConfigInfoFileBackingInfo.parent` is set.
	DeltaSizeInMB int64 `xml:"deltaSizeInMB,omitempty" json:"deltaSizeInMB,omitempty"`
	// key id used to encrypt the backing disk.
	KeyId *CryptoKeyId `xml:"keyId,omitempty" json:"keyId,omitempty"`
}

func init() {
	t["BaseConfigInfoFileBackingInfo"] = reflect.TypeOf((*BaseConfigInfoFileBackingInfo)(nil)).Elem()
}

// This data object type contains information about raw device mapping.
type BaseConfigInfoRawDiskMappingBackingInfo struct {
	BaseConfigInfoFileBackingInfo

	// Unique identifier of the LUN accessed by the raw disk mapping.
	LunUuid string `xml:"lunUuid" json:"lunUuid"`
	// The compatibility mode of the raw disk mapping (RDM).
	//
	// This must be
	// specified when a new virtual disk with an RDM backing is created.
	//
	// See also `VirtualDiskCompatibilityMode_enum`.
	CompatibilityMode string `xml:"compatibilityMode" json:"compatibilityMode"`
}

func init() {
	t["BaseConfigInfoRawDiskMappingBackingInfo"] = reflect.TypeOf((*BaseConfigInfoRawDiskMappingBackingInfo)(nil)).Elem()
}

// The parameters of `Folder.BatchAddHostsToCluster_Task`.
type BatchAddHostsToClusterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specifies the cluster to which hosts need to be
	// added.
	//
	// Refers instance of `ClusterComputeResource`.
	Cluster ManagedObjectReference `xml:"cluster" json:"cluster"`
	// Specifies a list of new hosts to be added to
	// the cluster. Hosts are first added as standalone hosts.
	NewHosts []FolderNewHostSpec `xml:"newHosts,omitempty" json:"newHosts,omitempty"`
	// Specifies a list of existing hosts to be
	// added to the cluster. Hosts are first moved to the desired state
	// before moving them to cluster.
	//
	// Refers instances of `HostSystem`.
	ExistingHosts []ManagedObjectReference `xml:"existingHosts,omitempty" json:"existingHosts,omitempty"`
	// Specifies the configuration for the compute
	// resource that will be created to contain all the hosts.
	CompResSpec BaseComputeResourceConfigSpec `xml:"compResSpec,omitempty,typeattr" json:"compResSpec,omitempty"`
	// Specifies desired state for hosts once added to
	// the cluster. If not specified, hosts are added to the cluster in their
	// current state. See `FolderDesiredHostState_enum` for valid values.
	DesiredState string `xml:"desiredState,omitempty" json:"desiredState,omitempty"`
}

func init() {
	t["BatchAddHostsToClusterRequestType"] = reflect.TypeOf((*BatchAddHostsToClusterRequestType)(nil)).Elem()
}

type BatchAddHostsToCluster_Task BatchAddHostsToClusterRequestType

func init() {
	t["BatchAddHostsToCluster_Task"] = reflect.TypeOf((*BatchAddHostsToCluster_Task)(nil)).Elem()
}

type BatchAddHostsToCluster_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `Folder.BatchAddStandaloneHosts_Task`.
type BatchAddStandaloneHostsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specifies a list of host specifications for new hosts.
	NewHosts []FolderNewHostSpec `xml:"newHosts,omitempty" json:"newHosts,omitempty"`
	// Specifies the configuration for the compute
	// resource that will be created to contain all the
	// hosts.
	CompResSpec BaseComputeResourceConfigSpec `xml:"compResSpec,omitempty,typeattr" json:"compResSpec,omitempty"`
	// Flag to specify whether or not hosts should be
	// connected at the time they are added. A host will not
	// be added if a connection attempt is made and fails.
	AddConnected bool `xml:"addConnected" json:"addConnected"`
}

func init() {
	t["BatchAddStandaloneHostsRequestType"] = reflect.TypeOf((*BatchAddStandaloneHostsRequestType)(nil)).Elem()
}

type BatchAddStandaloneHosts_Task BatchAddStandaloneHostsRequestType

func init() {
	t["BatchAddStandaloneHosts_Task"] = reflect.TypeOf((*BatchAddStandaloneHosts_Task)(nil)).Elem()
}

type BatchAddStandaloneHosts_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type BatchQueryConnectInfo BatchQueryConnectInfoRequestType

func init() {
	t["BatchQueryConnectInfo"] = reflect.TypeOf((*BatchQueryConnectInfo)(nil)).Elem()
}

// The parameters of `Datacenter.BatchQueryConnectInfo`.
type BatchQueryConnectInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Information about the set of hosts to query.
	HostSpecs []HostConnectSpec `xml:"hostSpecs,omitempty" json:"hostSpecs,omitempty"`
}

func init() {
	t["BatchQueryConnectInfoRequestType"] = reflect.TypeOf((*BatchQueryConnectInfoRequestType)(nil)).Elem()
}

type BatchQueryConnectInfoResponse struct {
	Returnval []DatacenterBasicConnectInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// Results of Batch APIs.
type BatchResult struct {
	DynamicData

	// Enum value for @link BatchResult.Result
	Result string `xml:"result" json:"result"`
	// Host for which the result applies.
	HostKey string `xml:"hostKey" json:"hostKey"`
	// The datastore that is created.
	//
	// Refers instance of `Datastore`.
	Ds *ManagedObjectReference `xml:"ds,omitempty" json:"ds,omitempty"`
	// 'fault' would be set if the operation was not successful
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["BatchResult"] = reflect.TypeOf((*BatchResult)(nil)).Elem()
}

type BindVnic BindVnicRequestType

func init() {
	t["BindVnic"] = reflect.TypeOf((*BindVnic)(nil)).Elem()
}

// The parameters of `IscsiManager.BindVnic`.
type BindVnicRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// iSCSI adapter name for which the Virtual NIC to
	// be added.
	IScsiHbaName string `xml:"iScsiHbaName" json:"iScsiHbaName"`
	// Virtual NIC that is to be bound to the iSCSI HBA
	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
}

func init() {
	t["BindVnicRequestType"] = reflect.TypeOf((*BindVnicRequestType)(nil)).Elem()
}

type BindVnicResponse struct {
}

// Fault indicating that firewall configuration prevents
// an operation from completing successfully.
type BlockedByFirewall struct {
	HostConfigFault
}

func init() {
	t["BlockedByFirewall"] = reflect.TypeOf((*BlockedByFirewall)(nil)).Elem()
}

type BlockedByFirewallFault BlockedByFirewall

func init() {
	t["BlockedByFirewallFault"] = reflect.TypeOf((*BlockedByFirewallFault)(nil)).Elem()
}

// The BoolOption data object type describes if an option
// is supported ("true") and if the option is set to "true" or
// "false" by default.
type BoolOption struct {
	OptionType

	// The flag to indicate whether or not the
	// option is supported.
	Supported bool `xml:"supported" json:"supported"`
	// The default value for the option.
	DefaultValue bool `xml:"defaultValue" json:"defaultValue"`
}

func init() {
	t["BoolOption"] = reflect.TypeOf((*BoolOption)(nil)).Elem()
}

// The boolean type of setting or configuration that may get an
// inherited value.
type BoolPolicy struct {
	InheritablePolicy

	// The boolean value that is either set or inherited.
	Value *bool `xml:"value" json:"value,omitempty"`
}

func init() {
	t["BoolPolicy"] = reflect.TypeOf((*BoolPolicy)(nil)).Elem()
}

type BrowseDiagnosticLog BrowseDiagnosticLogRequestType

func init() {
	t["BrowseDiagnosticLog"] = reflect.TypeOf((*BrowseDiagnosticLog)(nil)).Elem()
}

// The parameters of `DiagnosticManager.BrowseDiagnosticLog`.
type BrowseDiagnosticLogRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specifies the host. If not specified, then it defaults
	// to the default server. For example, if called on
	// VirtualCenter, then the value defaults to VirtualCenter
	// logs.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// A string key specifying the key for the log file to
	// browse. Keys can be obtained using the queryDescriptions
	// method.
	Key string `xml:"key" json:"key"`
	// The line number for the first entry to be returned. If the
	// parameter is not specified, then the operation returns
	// with lines starting from the top of the log.
	Start int32 `xml:"start,omitempty" json:"start,omitempty"`
	// The number of lines to return. If not specified, then
	// all lines are returned from the start value to the end of
	// the file.
	Lines int32 `xml:"lines,omitempty" json:"lines,omitempty"`
}

func init() {
	t["BrowseDiagnosticLogRequestType"] = reflect.TypeOf((*BrowseDiagnosticLogRequestType)(nil)).Elem()
}

type BrowseDiagnosticLogResponse struct {
	Returnval DiagnosticManagerLogHeader `xml:"returnval" json:"returnval"`
}

// Fault indicating that the CAM server
// cannot be connected.
type CAMServerRefusedConnection struct {
	InvalidCAMServer
}

func init() {
	t["CAMServerRefusedConnection"] = reflect.TypeOf((*CAMServerRefusedConnection)(nil)).Elem()
}

type CAMServerRefusedConnectionFault CAMServerRefusedConnection

func init() {
	t["CAMServerRefusedConnectionFault"] = reflect.TypeOf((*CAMServerRefusedConnectionFault)(nil)).Elem()
}

type CanProvisionObjects CanProvisionObjectsRequestType

func init() {
	t["CanProvisionObjects"] = reflect.TypeOf((*CanProvisionObjects)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.CanProvisionObjects`.
type CanProvisionObjectsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of NewPolicyBatch structure with sizes and policies.
	Npbs []VsanNewPolicyBatch `xml:"npbs" json:"npbs"`
	// Optionally populate PolicyCost even though
	// object cannot be provisioned in the current cluster topology.
	IgnoreSatisfiability *bool `xml:"ignoreSatisfiability" json:"ignoreSatisfiability,omitempty"`
}

func init() {
	t["CanProvisionObjectsRequestType"] = reflect.TypeOf((*CanProvisionObjectsRequestType)(nil)).Elem()
}

type CanProvisionObjectsResponse struct {
	Returnval []VsanPolicySatisfiability `xml:"returnval" json:"returnval"`
}

type CancelRecommendation CancelRecommendationRequestType

func init() {
	t["CancelRecommendation"] = reflect.TypeOf((*CancelRecommendation)(nil)).Elem()
}

// The parameters of `ClusterComputeResource.CancelRecommendation`.
type CancelRecommendationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The key field of the Recommendation.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["CancelRecommendationRequestType"] = reflect.TypeOf((*CancelRecommendationRequestType)(nil)).Elem()
}

type CancelRecommendationResponse struct {
}

type CancelRetrievePropertiesEx CancelRetrievePropertiesExRequestType

func init() {
	t["CancelRetrievePropertiesEx"] = reflect.TypeOf((*CancelRetrievePropertiesEx)(nil)).Elem()
}

// The parameters of `PropertyCollector.CancelRetrievePropertiesEx`.
type CancelRetrievePropertiesExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// the token returned in the previous `RetrieveResult` returned on the same session by the
	// same `PropertyCollector`.
	Token string `xml:"token" json:"token"`
}

func init() {
	t["CancelRetrievePropertiesExRequestType"] = reflect.TypeOf((*CancelRetrievePropertiesExRequestType)(nil)).Elem()
}

type CancelRetrievePropertiesExResponse struct {
}

type CancelStorageDrsRecommendation CancelStorageDrsRecommendationRequestType

func init() {
	t["CancelStorageDrsRecommendation"] = reflect.TypeOf((*CancelStorageDrsRecommendation)(nil)).Elem()
}

// The parameters of `StorageResourceManager.CancelStorageDrsRecommendation`.
type CancelStorageDrsRecommendationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The key field of the Recommendation.
	Key []string `xml:"key" json:"key"`
}

func init() {
	t["CancelStorageDrsRecommendationRequestType"] = reflect.TypeOf((*CancelStorageDrsRecommendationRequestType)(nil)).Elem()
}

type CancelStorageDrsRecommendationResponse struct {
}

type CancelTask CancelTaskRequestType

func init() {
	t["CancelTask"] = reflect.TypeOf((*CancelTask)(nil)).Elem()
}

type CancelTaskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["CancelTaskRequestType"] = reflect.TypeOf((*CancelTaskRequestType)(nil)).Elem()
}

type CancelTaskResponse struct {
}

type CancelWaitForUpdates CancelWaitForUpdatesRequestType

func init() {
	t["CancelWaitForUpdates"] = reflect.TypeOf((*CancelWaitForUpdates)(nil)).Elem()
}

type CancelWaitForUpdatesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["CancelWaitForUpdatesRequestType"] = reflect.TypeOf((*CancelWaitForUpdatesRequestType)(nil)).Elem()
}

type CancelWaitForUpdatesResponse struct {
}

// An operation performed on the host was canceled.
//
// Typically,
// a previous event in the sequence of events contains more
// information about the cause of this cancellation.
type CanceledHostOperationEvent struct {
	HostEvent
}

func init() {
	t["CanceledHostOperationEvent"] = reflect.TypeOf((*CanceledHostOperationEvent)(nil)).Elem()
}

// This fault is thrown when an operation fails because of insufficient
// permissions to access a file.
type CannotAccessFile struct {
	FileFault
}

func init() {
	t["CannotAccessFile"] = reflect.TypeOf((*CannotAccessFile)(nil)).Elem()
}

type CannotAccessFileFault CannotAccessFile

func init() {
	t["CannotAccessFileFault"] = reflect.TypeOf((*CannotAccessFileFault)(nil)).Elem()
}

// An CannotAccessLocalSourceFault exception is thrown when a
// an attempt is made to upload license content
// and the local source cannot be accesed.
type CannotAccessLocalSource struct {
	VimFault
}

func init() {
	t["CannotAccessLocalSource"] = reflect.TypeOf((*CannotAccessLocalSource)(nil)).Elem()
}

type CannotAccessLocalSourceFault CannotAccessLocalSource

func init() {
	t["CannotAccessLocalSourceFault"] = reflect.TypeOf((*CannotAccessLocalSourceFault)(nil)).Elem()
}

// A network associated with the virtual machine is not accessible.
//
// If returned as
// part of migration checks, this is an error if either of the following is true,
// a warning otherwise:
//   - The virtual ethernet card device backing is a distributed virtual switch,
//     of which the destination host is not a member
//   - The virtual ethernet card device backing is a standard network and the
//     the device is connected
type CannotAccessNetwork struct {
	CannotAccessVmDevice

	// A reference to the network that cannot be accessed
	//
	// Refers instance of `Network`.
	Network *ManagedObjectReference `xml:"network,omitempty" json:"network,omitempty"`
}

func init() {
	t["CannotAccessNetwork"] = reflect.TypeOf((*CannotAccessNetwork)(nil)).Elem()
}

type CannotAccessNetworkFault BaseCannotAccessNetwork

func init() {
	t["CannotAccessNetworkFault"] = reflect.TypeOf((*CannotAccessNetworkFault)(nil)).Elem()
}

// One of the virtual machine's components is not accessible on the execution host.
//
// This is a base class. Subclasses will encode the type of component that is not
// accessible.
type CannotAccessVmComponent struct {
	VmConfigFault
}

func init() {
	t["CannotAccessVmComponent"] = reflect.TypeOf((*CannotAccessVmComponent)(nil)).Elem()
}

type CannotAccessVmComponentFault BaseCannotAccessVmComponent

func init() {
	t["CannotAccessVmComponentFault"] = reflect.TypeOf((*CannotAccessVmComponentFault)(nil)).Elem()
}

// One or more of the virtual machine's configuration files are not accessible.
type CannotAccessVmConfig struct {
	CannotAccessVmComponent

	// Contains the reason why the VM file could not be found.
	//
	// This is typically
	// a FileFault.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["CannotAccessVmConfig"] = reflect.TypeOf((*CannotAccessVmConfig)(nil)).Elem()
}

type CannotAccessVmConfigFault CannotAccessVmConfig

func init() {
	t["CannotAccessVmConfigFault"] = reflect.TypeOf((*CannotAccessVmConfigFault)(nil)).Elem()
}

// One of the virtual machine's devices uses a backing that is not accessible
// on the host.
//
// Following is a discussion of this fault's use in migration validation.
// This is an error if the device is currently connected and a warning
// otherwise. Devices that can be disconnected can only be connected if the virtual
// machine is powered on.
//
// The usage of this fault is slightly different if the backing of a device is
// inherently host-local, and therefore not shared or globally named among
// hosts. (Examples of such backings: physical CD-ROM drive, physical serial
// port.) If a device with such a backing is currently connected, that will
// be a migration error. If the device is disconnected, there will be a
// warning if no backing with the same name exists on the destination host.
// If the device is disconnected and a backing with the same name exists on
// the destination host, this is neither a warning nor an error case, even
// though the destination host's backing is not the same instance as the
// source host's. It is assumed that use of the host-local backing is what is
// desired for the device.
type CannotAccessVmDevice struct {
	CannotAccessVmComponent

	// The label of the device.
	Device string `xml:"device" json:"device"`
	// The backing of the device.
	Backing string `xml:"backing" json:"backing"`
	// The connected/disconnected state of the device.
	Connected bool `xml:"connected" json:"connected"`
}

func init() {
	t["CannotAccessVmDevice"] = reflect.TypeOf((*CannotAccessVmDevice)(nil)).Elem()
}

type CannotAccessVmDeviceFault BaseCannotAccessVmDevice

func init() {
	t["CannotAccessVmDeviceFault"] = reflect.TypeOf((*CannotAccessVmDeviceFault)(nil)).Elem()
}

// One of the virtual machine's virtual disks is not accessible.
type CannotAccessVmDisk struct {
	CannotAccessVmDevice

	// The reason why the disk could not be accessed
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["CannotAccessVmDisk"] = reflect.TypeOf((*CannotAccessVmDisk)(nil)).Elem()
}

type CannotAccessVmDiskFault BaseCannotAccessVmDisk

func init() {
	t["CannotAccessVmDiskFault"] = reflect.TypeOf((*CannotAccessVmDiskFault)(nil)).Elem()
}

// Can not add a host with fault tolerance vms to be standalone
type CannotAddHostWithFTVmAsStandalone struct {
	HostConnectFault
}

func init() {
	t["CannotAddHostWithFTVmAsStandalone"] = reflect.TypeOf((*CannotAddHostWithFTVmAsStandalone)(nil)).Elem()
}

type CannotAddHostWithFTVmAsStandaloneFault CannotAddHostWithFTVmAsStandalone

func init() {
	t["CannotAddHostWithFTVmAsStandaloneFault"] = reflect.TypeOf((*CannotAddHostWithFTVmAsStandaloneFault)(nil)).Elem()
}

// Can not add a host with fault tolerance vms to a different cluster other
// than the one used other vms in the same fault tolerance group.
type CannotAddHostWithFTVmToDifferentCluster struct {
	HostConnectFault
}

func init() {
	t["CannotAddHostWithFTVmToDifferentCluster"] = reflect.TypeOf((*CannotAddHostWithFTVmToDifferentCluster)(nil)).Elem()
}

type CannotAddHostWithFTVmToDifferentClusterFault CannotAddHostWithFTVmToDifferentCluster

func init() {
	t["CannotAddHostWithFTVmToDifferentClusterFault"] = reflect.TypeOf((*CannotAddHostWithFTVmToDifferentClusterFault)(nil)).Elem()
}

// Can not add a host with fault tolerance vms to a non HA enabled cluster
type CannotAddHostWithFTVmToNonHACluster struct {
	HostConnectFault
}

func init() {
	t["CannotAddHostWithFTVmToNonHACluster"] = reflect.TypeOf((*CannotAddHostWithFTVmToNonHACluster)(nil)).Elem()
}

type CannotAddHostWithFTVmToNonHAClusterFault CannotAddHostWithFTVmToNonHACluster

func init() {
	t["CannotAddHostWithFTVmToNonHAClusterFault"] = reflect.TypeOf((*CannotAddHostWithFTVmToNonHAClusterFault)(nil)).Elem()
}

// This fault is used to report that the DRS behavior cannot be modified
// for a FT secondary virtual machine
type CannotChangeDrsBehaviorForFtSecondary struct {
	VmFaultToleranceIssue

	// The virtual machine whose behavior cannot be modified
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Name of the virtual machine
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["CannotChangeDrsBehaviorForFtSecondary"] = reflect.TypeOf((*CannotChangeDrsBehaviorForFtSecondary)(nil)).Elem()
}

type CannotChangeDrsBehaviorForFtSecondaryFault CannotChangeDrsBehaviorForFtSecondary

func init() {
	t["CannotChangeDrsBehaviorForFtSecondaryFault"] = reflect.TypeOf((*CannotChangeDrsBehaviorForFtSecondaryFault)(nil)).Elem()
}

// This fault is used to report that the HA settings cannot be modified
// for a FT secondary virtual machine
type CannotChangeHaSettingsForFtSecondary struct {
	VmFaultToleranceIssue

	// The FT secondary virtual machine whose behavior cannot be modified
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Name of the FT secondary virtual machine
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["CannotChangeHaSettingsForFtSecondary"] = reflect.TypeOf((*CannotChangeHaSettingsForFtSecondary)(nil)).Elem()
}

type CannotChangeHaSettingsForFtSecondaryFault CannotChangeHaSettingsForFtSecondary

func init() {
	t["CannotChangeHaSettingsForFtSecondaryFault"] = reflect.TypeOf((*CannotChangeHaSettingsForFtSecondaryFault)(nil)).Elem()
}

// Fault thrown for cases that a VSAN cluster UUID may not be changed.
//
// For example, the VSAN cluster UUID for a host may not be changed so long
// as that host is enabled for VSAN.
// The VSAN cluster UUID for a given `ClusterComputeResource` may
// not be changed so long as that vim.ClusterComputeResource is enabled for
// VSAN.
//
// See also `HostVsanSystem.UpdateVsan_Task`, `ComputeResource.ReconfigureComputeResource_Task`.
type CannotChangeVsanClusterUuid struct {
	VsanFault
}

func init() {
	t["CannotChangeVsanClusterUuid"] = reflect.TypeOf((*CannotChangeVsanClusterUuid)(nil)).Elem()
}

type CannotChangeVsanClusterUuidFault CannotChangeVsanClusterUuid

func init() {
	t["CannotChangeVsanClusterUuidFault"] = reflect.TypeOf((*CannotChangeVsanClusterUuidFault)(nil)).Elem()
}

// Fault thrown for cases that a VSAN node UUID may not be changed.
//
// For example, the VSAN node UUID for a host may not be changed so long as
// that host is enabled for VSAN.
//
// See also `HostVsanSystem.UpdateVsan_Task`, `ComputeResource.ReconfigureComputeResource_Task`.
type CannotChangeVsanNodeUuid struct {
	VsanFault
}

func init() {
	t["CannotChangeVsanNodeUuid"] = reflect.TypeOf((*CannotChangeVsanNodeUuid)(nil)).Elem()
}

type CannotChangeVsanNodeUuidFault CannotChangeVsanNodeUuid

func init() {
	t["CannotChangeVsanNodeUuidFault"] = reflect.TypeOf((*CannotChangeVsanNodeUuidFault)(nil)).Elem()
}

// This fault is used if FT compatible hosts cannot be computed for a VM
type CannotComputeFTCompatibleHosts struct {
	VmFaultToleranceIssue

	// The virtual machine for FT compatible hosts is being computed
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Name of the virtual machine
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["CannotComputeFTCompatibleHosts"] = reflect.TypeOf((*CannotComputeFTCompatibleHosts)(nil)).Elem()
}

type CannotComputeFTCompatibleHostsFault CannotComputeFTCompatibleHosts

func init() {
	t["CannotComputeFTCompatibleHostsFault"] = reflect.TypeOf((*CannotComputeFTCompatibleHostsFault)(nil)).Elem()
}

// A CannotCreateFile exception is thrown if a file create
// operation fails.
type CannotCreateFile struct {
	FileFault
}

func init() {
	t["CannotCreateFile"] = reflect.TypeOf((*CannotCreateFile)(nil)).Elem()
}

type CannotCreateFileFault CannotCreateFile

func init() {
	t["CannotCreateFileFault"] = reflect.TypeOf((*CannotCreateFileFault)(nil)).Elem()
}

// The VirtualCenter server is unable to decrypt passwords stored in
// the customization specification.
type CannotDecryptPasswords struct {
	CustomizationFault
}

func init() {
	t["CannotDecryptPasswords"] = reflect.TypeOf((*CannotDecryptPasswords)(nil)).Elem()
}

type CannotDecryptPasswordsFault CannotDecryptPasswords

func init() {
	t["CannotDecryptPasswordsFault"] = reflect.TypeOf((*CannotDecryptPasswordsFault)(nil)).Elem()
}

// A CannotDeleteFile exception is thrown if a file-deletion
// operation fails.
type CannotDeleteFile struct {
	FileFault
}

func init() {
	t["CannotDeleteFile"] = reflect.TypeOf((*CannotDeleteFile)(nil)).Elem()
}

type CannotDeleteFileFault CannotDeleteFile

func init() {
	t["CannotDeleteFileFault"] = reflect.TypeOf((*CannotDeleteFileFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to disable DRS on a cluster,
// which contains a vApp.
type CannotDisableDrsOnClustersWithVApps struct {
	RuntimeFault
}

func init() {
	t["CannotDisableDrsOnClustersWithVApps"] = reflect.TypeOf((*CannotDisableDrsOnClustersWithVApps)(nil)).Elem()
}

type CannotDisableDrsOnClustersWithVAppsFault CannotDisableDrsOnClustersWithVApps

func init() {
	t["CannotDisableDrsOnClustersWithVAppsFault"] = reflect.TypeOf((*CannotDisableDrsOnClustersWithVAppsFault)(nil)).Elem()
}

// Fault thrown when an attempt is made to disable snapshots on a virtual
// machine which has a snapshot.
//
// To disable the snapshot feature, the
// virtual machine must not currently have a snapshot.
type CannotDisableSnapshot struct {
	VmConfigFault
}

func init() {
	t["CannotDisableSnapshot"] = reflect.TypeOf((*CannotDisableSnapshot)(nil)).Elem()
}

type CannotDisableSnapshotFault CannotDisableSnapshot

func init() {
	t["CannotDisableSnapshotFault"] = reflect.TypeOf((*CannotDisableSnapshotFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to disconnect a host, which
// has one or more fault tolerance vms and is not in maintenance mode.
type CannotDisconnectHostWithFaultToleranceVm struct {
	VimFault

	// The name of the host to be disconnected
	HostName string `xml:"hostName" json:"hostName"`
}

func init() {
	t["CannotDisconnectHostWithFaultToleranceVm"] = reflect.TypeOf((*CannotDisconnectHostWithFaultToleranceVm)(nil)).Elem()
}

type CannotDisconnectHostWithFaultToleranceVmFault CannotDisconnectHostWithFaultToleranceVm

func init() {
	t["CannotDisconnectHostWithFaultToleranceVmFault"] = reflect.TypeOf((*CannotDisconnectHostWithFaultToleranceVmFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to enable VM Component Protection
// on a cluster which contains a host that does not support this feature.
type CannotEnableVmcpForCluster struct {
	VimFault

	// Report the host with APD timeout disabled.
	//
	// If the host is set it points to the host which is the reason
	// for this fault i.e this host has ADPTimeout disabled.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// If set this reports the hostName.
	//
	// This is used for printing the host name in the
	// localized message as the host may have been removed
	// from the vCenter's inventory by the time localization would
	// be taking place.
	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
	// This reports the reason for host not meeting the requirements
	// for enabling vSphere VMCP.
	//
	// It can be the following reason.
	//   - APDTimeout disabled.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["CannotEnableVmcpForCluster"] = reflect.TypeOf((*CannotEnableVmcpForCluster)(nil)).Elem()
}

type CannotEnableVmcpForClusterFault CannotEnableVmcpForCluster

func init() {
	t["CannotEnableVmcpForClusterFault"] = reflect.TypeOf((*CannotEnableVmcpForClusterFault)(nil)).Elem()
}

// A virtual machine's total CPU feature requirements are determined by
// overlaying the requirements specified in its configuration (if any) on top
// of the requirements specified in the descriptor for its guest OS.
//
// It is
// therefore possible for a host change to implicitly change a virtual
// machine's CPU feature requirements. The guest OS descriptor may have
// different requirements on the new host. Or, if the virtual machine
// currently specifies requirements in its configuration, those requirements
// will be lost if the new host does not support this.
//
// This fault indicates that the virtual machine's CPU feature requirements
// would change because of a migration, and also that the destination host
// does not support storing CPU feature requirements in the virtual machine's
// configuration. (If the destination host does support such an action,
// WillModifyConfigCpuRequirements is used instead of this fault.)
//
// For a powered-off virtual machine, this is a warning. The migration may
// proceed, but the virtual machine will be operating under different
// CPU feature requirements if it is powered on after the migration.
//
// For a powered-on or suspended virtual machine, this is an error.
type CannotModifyConfigCpuRequirements struct {
	MigrationFault
}

func init() {
	t["CannotModifyConfigCpuRequirements"] = reflect.TypeOf((*CannotModifyConfigCpuRequirements)(nil)).Elem()
}

type CannotModifyConfigCpuRequirementsFault CannotModifyConfigCpuRequirements

func init() {
	t["CannotModifyConfigCpuRequirementsFault"] = reflect.TypeOf((*CannotModifyConfigCpuRequirementsFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to move a fault tolerance
// vm to a different resource pool or cluster.
type CannotMoveFaultToleranceVm struct {
	VimFault

	// The type of the move
	MoveType string `xml:"moveType" json:"moveType"`
	// The virtual machine name to be moved.
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["CannotMoveFaultToleranceVm"] = reflect.TypeOf((*CannotMoveFaultToleranceVm)(nil)).Elem()
}

type CannotMoveFaultToleranceVmFault CannotMoveFaultToleranceVm

func init() {
	t["CannotMoveFaultToleranceVmFault"] = reflect.TypeOf((*CannotMoveFaultToleranceVmFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to move a host which has
// one or more fault tolerance vms out of the current cluster.
type CannotMoveHostWithFaultToleranceVm struct {
	VimFault
}

func init() {
	t["CannotMoveHostWithFaultToleranceVm"] = reflect.TypeOf((*CannotMoveHostWithFaultToleranceVm)(nil)).Elem()
}

type CannotMoveHostWithFaultToleranceVmFault CannotMoveHostWithFaultToleranceVm

func init() {
	t["CannotMoveHostWithFaultToleranceVmFault"] = reflect.TypeOf((*CannotMoveHostWithFaultToleranceVmFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to relocate a virtual machine
// with virtual disk(s) having delta disk backing.
type CannotMoveVmWithDeltaDisk struct {
	MigrationFault

	// The label of the delta disk device
	Device string `xml:"device" json:"device"`
}

func init() {
	t["CannotMoveVmWithDeltaDisk"] = reflect.TypeOf((*CannotMoveVmWithDeltaDisk)(nil)).Elem()
}

type CannotMoveVmWithDeltaDiskFault CannotMoveVmWithDeltaDisk

func init() {
	t["CannotMoveVmWithDeltaDiskFault"] = reflect.TypeOf((*CannotMoveVmWithDeltaDiskFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to migrate a virtual machine
// with native delta disks to different datastores.
type CannotMoveVmWithNativeDeltaDisk struct {
	MigrationFault
}

func init() {
	t["CannotMoveVmWithNativeDeltaDisk"] = reflect.TypeOf((*CannotMoveVmWithNativeDeltaDisk)(nil)).Elem()
}

type CannotMoveVmWithNativeDeltaDiskFault CannotMoveVmWithNativeDeltaDisk

func init() {
	t["CannotMoveVmWithNativeDeltaDiskFault"] = reflect.TypeOf((*CannotMoveVmWithNativeDeltaDiskFault)(nil)).Elem()
}

// Fault thrown for the case that an attempt is made to move a host which
// is enabled for VSAN into an unsuitable `ClusterComputeResource`.
//
// The destination vim.ClusterComputeResource may be disabled for VSAN, or
// may be using VSAN with a different cluster UUID.
//
// See also `ClusterComputeResource.AddHost_Task`, `ClusterComputeResource.MoveHostInto_Task`, `ClusterComputeResource.MoveInto_Task`, `VsanClusterUuidMismatch`, `DestinationVsanDisabled`.
type CannotMoveVsanEnabledHost struct {
	VsanFault
}

func init() {
	t["CannotMoveVsanEnabledHost"] = reflect.TypeOf((*CannotMoveVsanEnabledHost)(nil)).Elem()
}

type CannotMoveVsanEnabledHostFault BaseCannotMoveVsanEnabledHost

func init() {
	t["CannotMoveVsanEnabledHostFault"] = reflect.TypeOf((*CannotMoveVsanEnabledHostFault)(nil)).Elem()
}

// This fault is thrown when Storage DRS cannot recommend to place disks of
// a virtual machine without moving existing virtual disks in a
// datastore cluster.
type CannotPlaceWithoutPrerequisiteMoves struct {
	VimFault
}

func init() {
	t["CannotPlaceWithoutPrerequisiteMoves"] = reflect.TypeOf((*CannotPlaceWithoutPrerequisiteMoves)(nil)).Elem()
}

type CannotPlaceWithoutPrerequisiteMovesFault CannotPlaceWithoutPrerequisiteMoves

func init() {
	t["CannotPlaceWithoutPrerequisiteMovesFault"] = reflect.TypeOf((*CannotPlaceWithoutPrerequisiteMovesFault)(nil)).Elem()
}

// This fault is reported when a user attempts to power off or
// suspend a VM when the HA master agent to which vCenter Server is
// connected does not manage the VM.
type CannotPowerOffVmInCluster struct {
	InvalidState

	// The operation being performed.
	//
	// Values come from
	// `CannotPowerOffVmInClusterOperation_enum`.
	Operation string `xml:"operation" json:"operation"`
	// The Virtual Machine
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Name of the Virtual Machine
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["CannotPowerOffVmInCluster"] = reflect.TypeOf((*CannotPowerOffVmInCluster)(nil)).Elem()
}

type CannotPowerOffVmInClusterFault CannotPowerOffVmInCluster

func init() {
	t["CannotPowerOffVmInClusterFault"] = reflect.TypeOf((*CannotPowerOffVmInClusterFault)(nil)).Elem()
}

// Fault thrown for the case that an attempt is made to reconfigure VSAN
// when HA is currently enabled for a given `ClusterComputeResource`.
//
// See also `ComputeResource.ReconfigureComputeResource_Task`.
type CannotReconfigureVsanWhenHaEnabled struct {
	VsanFault
}

func init() {
	t["CannotReconfigureVsanWhenHaEnabled"] = reflect.TypeOf((*CannotReconfigureVsanWhenHaEnabled)(nil)).Elem()
}

type CannotReconfigureVsanWhenHaEnabledFault CannotReconfigureVsanWhenHaEnabled

func init() {
	t["CannotReconfigureVsanWhenHaEnabledFault"] = reflect.TypeOf((*CannotReconfigureVsanWhenHaEnabledFault)(nil)).Elem()
}

// A network associated with the virtual machine is accessible, but it
// cannot be used for some reason.
type CannotUseNetwork struct {
	VmConfigFault

	// The label of the network device.
	Device string `xml:"device" json:"device"`
	// The backing of the network device.
	Backing string `xml:"backing" json:"backing"`
	// The connected/disconnected state of the device.
	Connected bool `xml:"connected" json:"connected"`
	// Reason describing why the network cannot be used.
	Reason string `xml:"reason" json:"reason"`
	// A reference to the network that cannot be used
	//
	// Refers instance of `Network`.
	Network *ManagedObjectReference `xml:"network,omitempty" json:"network,omitempty"`
}

func init() {
	t["CannotUseNetwork"] = reflect.TypeOf((*CannotUseNetwork)(nil)).Elem()
}

type CannotUseNetworkFault CannotUseNetwork

func init() {
	t["CannotUseNetworkFault"] = reflect.TypeOf((*CannotUseNetworkFault)(nil)).Elem()
}

// A particular product may or may not support certain features.
//
// This data object
// indicates whether or not a service instance implements these features. This data
// object type indicates the circumstances under which an operation throws a
// `NotSupported` fault.
//
// Support for some features is indicated by the presence or absence of
// the manager object from the service instance. For example, the AlarmManager manager
// object indicates collecting alarms is supported.
// Other features indicate whether or not a given operation on an
// object throws a `NotSupported` fault.
//
// Some capabilities depend on the host or virtual machine
// version. These are specified by using the vim.host.Capability and
// vim.vm.Capability objects.
type Capability struct {
	DynamicData

	// Indicates whether or not the service instance supports provisioning.
	//
	// For example, the `CloneVM` operation.
	ProvisioningSupported bool `xml:"provisioningSupported" json:"provisioningSupported"`
	// Indicates whether or not the service instance supports multiple hosts.
	MultiHostSupported bool `xml:"multiHostSupported" json:"multiHostSupported"`
	// Flag indicating whether host user accounts should have the option to
	// be granted shell access
	UserShellAccessSupported bool `xml:"userShellAccessSupported" json:"userShellAccessSupported"`
	// All supported Enhanced VMotion Compatibility modes.
	SupportedEVCMode []EVCMode `xml:"supportedEVCMode,omitempty" json:"supportedEVCMode,omitempty"`
	// All supported Enhanced VMotion Compatibility Graphics modes.
	SupportedEVCGraphicsMode []FeatureEVCMode `xml:"supportedEVCGraphicsMode,omitempty" json:"supportedEVCGraphicsMode,omitempty" vim:"7.0.1.0"`
	// Indicates whether network backup and restore feature is supported.
	NetworkBackupAndRestoreSupported *bool `xml:"networkBackupAndRestoreSupported" json:"networkBackupAndRestoreSupported,omitempty"`
	// Is DRS supported for Fault Tolerance VMs without enabling EVC.
	FtDrsWithoutEvcSupported *bool `xml:"ftDrsWithoutEvcSupported" json:"ftDrsWithoutEvcSupported,omitempty"`
	// Specifies if the workflow for setting up a HCI cluster is supported.
	HciWorkflowSupported *bool `xml:"hciWorkflowSupported" json:"hciWorkflowSupported,omitempty"`
	// Specifies the supported compute policy version.
	ComputePolicyVersion      int32 `xml:"computePolicyVersion,omitempty" json:"computePolicyVersion,omitempty"`
	ClusterPlacementSupported *bool `xml:"clusterPlacementSupported" json:"clusterPlacementSupported,omitempty"`
	// Specifies if lifecycle management of a Cluster is supported.
	LifecycleManagementSupported *bool `xml:"lifecycleManagementSupported" json:"lifecycleManagementSupported,omitempty"`
	// Specifies if host seeding for a cluster is supported.
	HostSeedingSupported *bool `xml:"hostSeedingSupported" json:"hostSeedingSupported,omitempty" vim:"7.0.2.0"`
	// Specifies if scalable shares for resource pools is supported.
	ScalableSharesSupported *bool `xml:"scalableSharesSupported" json:"scalableSharesSupported,omitempty"`
	// Specifies if highly available distributed clustering service is supported.
	HadcsSupported *bool `xml:"hadcsSupported" json:"hadcsSupported,omitempty" vim:"7.0.1.1"`
	// Specifies if desired configuration management platform is supported
	// on the cluster.
	ConfigMgmtSupported *bool `xml:"configMgmtSupported" json:"configMgmtSupported,omitempty" vim:"7.0.3.1"`
}

func init() {
	t["Capability"] = reflect.TypeOf((*Capability)(nil)).Elem()
}

// The parameters of `CertificateManager.CertMgrRefreshCACertificatesAndCRLs_Task`.
type CertMgrRefreshCACertificatesAndCRLsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// the hosts on which the certificates need to be refreshed
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["CertMgrRefreshCACertificatesAndCRLsRequestType"] = reflect.TypeOf((*CertMgrRefreshCACertificatesAndCRLsRequestType)(nil)).Elem()
}

type CertMgrRefreshCACertificatesAndCRLs_Task CertMgrRefreshCACertificatesAndCRLsRequestType

func init() {
	t["CertMgrRefreshCACertificatesAndCRLs_Task"] = reflect.TypeOf((*CertMgrRefreshCACertificatesAndCRLs_Task)(nil)).Elem()
}

type CertMgrRefreshCACertificatesAndCRLs_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `CertificateManager.CertMgrRefreshCertificates_Task`.
type CertMgrRefreshCertificatesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// the hosts on which the certificates need to be refreshed
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["CertMgrRefreshCertificatesRequestType"] = reflect.TypeOf((*CertMgrRefreshCertificatesRequestType)(nil)).Elem()
}

type CertMgrRefreshCertificates_Task CertMgrRefreshCertificatesRequestType

func init() {
	t["CertMgrRefreshCertificates_Task"] = reflect.TypeOf((*CertMgrRefreshCertificates_Task)(nil)).Elem()
}

type CertMgrRefreshCertificates_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `CertificateManager.CertMgrRevokeCertificates_Task`.
type CertMgrRevokeCertificatesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// the hosts on which the certificates need to be revoked
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["CertMgrRevokeCertificatesRequestType"] = reflect.TypeOf((*CertMgrRevokeCertificatesRequestType)(nil)).Elem()
}

type CertMgrRevokeCertificates_Task CertMgrRevokeCertificatesRequestType

func init() {
	t["CertMgrRevokeCertificates_Task"] = reflect.TypeOf((*CertMgrRevokeCertificates_Task)(nil)).Elem()
}

type CertMgrRevokeCertificates_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ChangeAccessMode ChangeAccessModeRequestType

func init() {
	t["ChangeAccessMode"] = reflect.TypeOf((*ChangeAccessMode)(nil)).Elem()
}

// The parameters of `HostAccessManager.ChangeAccessMode`.
type ChangeAccessModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The affected user or group.
	Principal string `xml:"principal" json:"principal"`
	// True if principal refers to a group account,
	// false otherwise.
	IsGroup bool `xml:"isGroup" json:"isGroup"`
	// AccessMode to be granted.
	// `accessOther` is meaningless and
	// will result in InvalidArgument exception.
	AccessMode HostAccessMode `xml:"accessMode" json:"accessMode"`
}

func init() {
	t["ChangeAccessModeRequestType"] = reflect.TypeOf((*ChangeAccessModeRequestType)(nil)).Elem()
}

type ChangeAccessModeResponse struct {
}

type ChangeFileAttributesInGuest ChangeFileAttributesInGuestRequestType

func init() {
	t["ChangeFileAttributesInGuest"] = reflect.TypeOf((*ChangeFileAttributesInGuest)(nil)).Elem()
}

// The parameters of `GuestFileManager.ChangeFileAttributesInGuest`.
type ChangeFileAttributesInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual Machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Modify
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The complete path to the file to be copied in
	// the guest. If the file points to an symbolic link, then the
	// attributes of the target file are changed.
	GuestFilePath string `xml:"guestFilePath" json:"guestFilePath"`
	// Specifies the different file attributes of the
	// guest file to be changed.
	// See `GuestFileAttributes`.
	// If any property is not specified, then the specific attribute of
	// the file will be unchanged.
	FileAttributes BaseGuestFileAttributes `xml:"fileAttributes,typeattr" json:"fileAttributes"`
}

func init() {
	t["ChangeFileAttributesInGuestRequestType"] = reflect.TypeOf((*ChangeFileAttributesInGuestRequestType)(nil)).Elem()
}

type ChangeFileAttributesInGuestResponse struct {
}

// The parameters of `CryptoManagerHost.ChangeKey_Task`.
type ChangeKeyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The key that replaces the existing core dump encryption key
	NewKey CryptoKeyPlain `xml:"newKey" json:"newKey"`
}

func init() {
	t["ChangeKeyRequestType"] = reflect.TypeOf((*ChangeKeyRequestType)(nil)).Elem()
}

type ChangeKey_Task ChangeKeyRequestType

func init() {
	t["ChangeKey_Task"] = reflect.TypeOf((*ChangeKey_Task)(nil)).Elem()
}

type ChangeKey_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ChangeLockdownMode ChangeLockdownModeRequestType

func init() {
	t["ChangeLockdownMode"] = reflect.TypeOf((*ChangeLockdownMode)(nil)).Elem()
}

// The parameters of `HostAccessManager.ChangeLockdownMode`.
type ChangeLockdownModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The new desired lockdown mode.
	//
	// If this is the same as the current lockdown mode state, the
	// operation will silently succeed and nothing will be changed.
	//
	// If this is `lockdownDisabled`
	// then lockdown mode will be disabled and the system will
	// start service DCUI if it is not running.
	//
	// If this is `lockdownNormal`
	// then lockdown mode will be enabled and the system will
	// start service DCUI if it is not running.
	//
	// If this is `lockdownStrict`
	// then lockdown mode will be enabled and the system will
	// stop service DCUI if it is running.
	Mode HostLockdownMode `xml:"mode" json:"mode"`
}

func init() {
	t["ChangeLockdownModeRequestType"] = reflect.TypeOf((*ChangeLockdownModeRequestType)(nil)).Elem()
}

type ChangeLockdownModeResponse struct {
}

type ChangeNFSUserPassword ChangeNFSUserPasswordRequestType

func init() {
	t["ChangeNFSUserPassword"] = reflect.TypeOf((*ChangeNFSUserPassword)(nil)).Elem()
}

// The parameters of `HostStorageSystem.ChangeNFSUserPassword`.
type ChangeNFSUserPasswordRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// New password.
	Password string `xml:"password" json:"password"`
}

func init() {
	t["ChangeNFSUserPasswordRequestType"] = reflect.TypeOf((*ChangeNFSUserPasswordRequestType)(nil)).Elem()
}

type ChangeNFSUserPasswordResponse struct {
}

type ChangeOwner ChangeOwnerRequestType

func init() {
	t["ChangeOwner"] = reflect.TypeOf((*ChangeOwner)(nil)).Elem()
}

// The parameters of `FileManager.ChangeOwner`.
type ChangeOwnerRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Name string                 `xml:"name" json:"name"`
	// Required privileges: System.View
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	Owner      string                  `xml:"owner" json:"owner"`
}

func init() {
	t["ChangeOwnerRequestType"] = reflect.TypeOf((*ChangeOwnerRequestType)(nil)).Elem()
}

type ChangeOwnerResponse struct {
}

type ChangePassword ChangePasswordRequestType

func init() {
	t["ChangePassword"] = reflect.TypeOf((*ChangePassword)(nil)).Elem()
}

// The parameters of `HostLocalAccountManager.ChangePassword`.
type ChangePasswordRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// the user whose password will be changed.
	User string `xml:"user" json:"user"`
	// the user's current (old) password.
	OldPassword string `xml:"oldPassword" json:"oldPassword"`
	// the user's new password.
	NewPassword string `xml:"newPassword" json:"newPassword"`
}

func init() {
	t["ChangePasswordRequestType"] = reflect.TypeOf((*ChangePasswordRequestType)(nil)).Elem()
}

type ChangePasswordResponse struct {
}

// The event argument contains changes.
type ChangesInfoEventArgument struct {
	DynamicData

	// Modified properties.
	Modified string `xml:"modified,omitempty" json:"modified,omitempty"`
	// Added properties.
	Added string `xml:"added,omitempty" json:"added,omitempty"`
	// Deleted properties.
	Deleted string `xml:"deleted,omitempty" json:"deleted,omitempty"`
}

func init() {
	t["ChangesInfoEventArgument"] = reflect.TypeOf((*ChangesInfoEventArgument)(nil)).Elem()
}

// The parameters of `ClusterEVCManager.CheckAddHostEvc_Task`.
type CheckAddHostEvcRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The spec that will be used to add the host.
	CnxSpec HostConnectSpec `xml:"cnxSpec" json:"cnxSpec"`
}

func init() {
	t["CheckAddHostEvcRequestType"] = reflect.TypeOf((*CheckAddHostEvcRequestType)(nil)).Elem()
}

type CheckAddHostEvc_Task CheckAddHostEvcRequestType

func init() {
	t["CheckAddHostEvc_Task"] = reflect.TypeOf((*CheckAddHostEvc_Task)(nil)).Elem()
}

type CheckAddHostEvc_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostProfileManager.CheckAnswerFileStatus_Task`.
type CheckAnswerFileStatusRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Set of hosts for which the answer file status will be checked.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["CheckAnswerFileStatusRequestType"] = reflect.TypeOf((*CheckAnswerFileStatusRequestType)(nil)).Elem()
}

type CheckAnswerFileStatus_Task CheckAnswerFileStatusRequestType

func init() {
	t["CheckAnswerFileStatus_Task"] = reflect.TypeOf((*CheckAnswerFileStatus_Task)(nil)).Elem()
}

type CheckAnswerFileStatus_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachineProvisioningChecker.CheckClone_Task`.
type CheckCloneRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The virtual machine we propose to clone.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The location of the new virtual machine.
	//
	// Refers instance of `Folder`.
	Folder ManagedObjectReference `xml:"folder" json:"folder"`
	// The name of the new virtual machine.
	Name string `xml:"name" json:"name"`
	// Specifies how to clone the virtual machine. In cases
	// where DRS would automatically select a host, all potential
	// hosts are tested against.
	Spec VirtualMachineCloneSpec `xml:"spec" json:"spec"`
	// The set of tests to run. If this argument is not set, all
	// tests will be run. See `CheckTestType_enum` for possible values.
	TestType []string `xml:"testType,omitempty" json:"testType,omitempty"`
}

func init() {
	t["CheckCloneRequestType"] = reflect.TypeOf((*CheckCloneRequestType)(nil)).Elem()
}

type CheckClone_Task CheckCloneRequestType

func init() {
	t["CheckClone_Task"] = reflect.TypeOf((*CheckClone_Task)(nil)).Elem()
}

type CheckClone_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachineCompatibilityChecker.CheckCompatibility_Task`.
type CheckCompatibilityRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The virtual machine we'd like to place.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The host we would like the virtual machine
	// to execute on. The host parameter may be left unset if the compute
	// resource associated with the pool represents a stand-alone host
	// or a DRS-enabled cluster. In the former case the stand-alone host is
	// used. In the latter case, each connected host in the cluster
	// that is not in maintenance mode is tested. If the virtual machine is a
	// template then either this parameter or the pool parameter must be set.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The resource pool we would like the virtual machine
	// to reside in. If the pool parameter is left unset, then the virtual
	// machine's current pool is assumed. If the virtual machine is a template
	// then either this parameter or the host parameter must be set.
	//
	// Refers instance of `ResourcePool`.
	Pool *ManagedObjectReference `xml:"pool,omitempty" json:"pool,omitempty"`
	// The set of tests to run. If this argument is not set, all
	// tests will be run. See `CheckTestType_enum` for possible values.
	TestType []string `xml:"testType,omitempty" json:"testType,omitempty"`
}

func init() {
	t["CheckCompatibilityRequestType"] = reflect.TypeOf((*CheckCompatibilityRequestType)(nil)).Elem()
}

type CheckCompatibility_Task CheckCompatibilityRequestType

func init() {
	t["CheckCompatibility_Task"] = reflect.TypeOf((*CheckCompatibility_Task)(nil)).Elem()
}

type CheckCompatibility_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `ProfileComplianceManager.CheckCompliance_Task`.
type CheckComplianceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If specified, check compliance against the specified profiles.
	// If not specified, use the profiles associated with the entities.
	// If both Profiles and Entities are specified, Check the compliance of each
	// Entity against each of the profile specified.
	//
	// For more information, look at the KMap below.
	//
	// P represents if Profile is specified.
	//
	// E represents if Entity is specified.
	//
	//	            P                        ^P
	//	  ---------------------------------------------------
	//	  | Check compliance      |  Profiles associated    |
	//	 E|  of each entity       |   with the specified    |
	//	  |  against each of the  |   entity will be used   |
	//	  |  profiles specified.  |   for checking          |
	//	  |                       |   compliance.           |
	//	  |                       |                         |
	//	  |                       |                         |
	//	  ---------------------------------------------------
	//	  | All entities          |   InvalidArgument       |
	//	  |  associated with the  |   Exception is thrown.  |
	//	  |  profile are checked. |                         |
	//	^E|                       |                         |
	//	  |                       |                         |
	//	  |                       |                         |
	//	  |                       |                         |
	//	  ---------------------------------------------------
	//
	// Refers instances of `Profile`.
	Profile []ManagedObjectReference `xml:"profile,omitempty" json:"profile,omitempty"`
	// If specified, the compliance check is done against this entity.
	//
	// Refers instances of `ManagedEntity`.
	Entity []ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["CheckComplianceRequestType"] = reflect.TypeOf((*CheckComplianceRequestType)(nil)).Elem()
}

type CheckCompliance_Task CheckComplianceRequestType

func init() {
	t["CheckCompliance_Task"] = reflect.TypeOf((*CheckCompliance_Task)(nil)).Elem()
}

type CheckCompliance_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `ClusterEVCManager.CheckConfigureEvcMode_Task`.
type CheckConfigureEvcModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A key referencing the desired EVC mode.
	EvcModeKey string `xml:"evcModeKey" json:"evcModeKey"`
	// A key referencing the desired EVC Graphics
	// mode `Capability.supportedEVCGraphicsMode`.
	EvcGraphicsModeKey string `xml:"evcGraphicsModeKey,omitempty" json:"evcGraphicsModeKey,omitempty" vim:"7.0.1.0"`
}

func init() {
	t["CheckConfigureEvcModeRequestType"] = reflect.TypeOf((*CheckConfigureEvcModeRequestType)(nil)).Elem()
}

type CheckConfigureEvcMode_Task CheckConfigureEvcModeRequestType

func init() {
	t["CheckConfigureEvcMode_Task"] = reflect.TypeOf((*CheckConfigureEvcMode_Task)(nil)).Elem()
}

type CheckConfigureEvcMode_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CheckCustomizationResources CheckCustomizationResourcesRequestType

func init() {
	t["CheckCustomizationResources"] = reflect.TypeOf((*CheckCustomizationResources)(nil)).Elem()
}

// The parameters of `CustomizationSpecManager.CheckCustomizationResources`.
type CheckCustomizationResourcesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Short name from the guest OS descriptor list describing the OS
	// we intend to customize.
	GuestOs string `xml:"guestOs" json:"guestOs"`
}

func init() {
	t["CheckCustomizationResourcesRequestType"] = reflect.TypeOf((*CheckCustomizationResourcesRequestType)(nil)).Elem()
}

type CheckCustomizationResourcesResponse struct {
}

type CheckCustomizationSpec CheckCustomizationSpecRequestType

func init() {
	t["CheckCustomizationSpec"] = reflect.TypeOf((*CheckCustomizationSpec)(nil)).Elem()
}

// The parameters of `VirtualMachine.CheckCustomizationSpec`.
type CheckCustomizationSpecRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The customization specification to check.
	Spec CustomizationSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CheckCustomizationSpecRequestType"] = reflect.TypeOf((*CheckCustomizationSpecRequestType)(nil)).Elem()
}

type CheckCustomizationSpecResponse struct {
}

type CheckForUpdates CheckForUpdatesRequestType

func init() {
	t["CheckForUpdates"] = reflect.TypeOf((*CheckForUpdates)(nil)).Elem()
}

// The parameters of `PropertyCollector.CheckForUpdates`.
type CheckForUpdatesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The data version currently known to the client. The value
	// must be either
	//   - the special initial version (an empty string)
	//   - a data version returned from `PropertyCollector.CheckForUpdates` or `PropertyCollector.WaitForUpdates` by the same `PropertyCollector` on the same session.
	//   - a non-truncated data version returned from `PropertyCollector.WaitForUpdatesEx` by the same `PropertyCollector` on the same
	//     session.
	Version string `xml:"version,omitempty" json:"version,omitempty"`
}

func init() {
	t["CheckForUpdatesRequestType"] = reflect.TypeOf((*CheckForUpdatesRequestType)(nil)).Elem()
}

type CheckForUpdatesResponse struct {
	Returnval *UpdateSet `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The parameters of `HostPatchManager.CheckHostPatch_Task`.
type CheckHostPatchRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// a list of urls pointing to metadata.zip.
	MetaUrls []string `xml:"metaUrls,omitempty" json:"metaUrls,omitempty"`
	// a list of urls pointing to an "offline" bundle. It is not supported in 5.0 or later.
	BundleUrls []string                                   `xml:"bundleUrls,omitempty" json:"bundleUrls,omitempty"`
	Spec       *HostPatchManagerPatchManagerOperationSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["CheckHostPatchRequestType"] = reflect.TypeOf((*CheckHostPatchRequestType)(nil)).Elem()
}

type CheckHostPatch_Task CheckHostPatchRequestType

func init() {
	t["CheckHostPatch_Task"] = reflect.TypeOf((*CheckHostPatch_Task)(nil)).Elem()
}

type CheckHostPatch_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachineProvisioningChecker.CheckInstantClone_Task`.
type CheckInstantCloneRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The virtual machine we propose to instant clone.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Specifies how to instant clone the virtual machine.
	Spec VirtualMachineInstantCloneSpec `xml:"spec" json:"spec"`
	// The set of tests to run. If this argument is not set, all
	// tests will be run. See `CheckTestType_enum` for possible values.
	TestType []string `xml:"testType,omitempty" json:"testType,omitempty"`
}

func init() {
	t["CheckInstantCloneRequestType"] = reflect.TypeOf((*CheckInstantCloneRequestType)(nil)).Elem()
}

type CheckInstantClone_Task CheckInstantCloneRequestType

func init() {
	t["CheckInstantClone_Task"] = reflect.TypeOf((*CheckInstantClone_Task)(nil)).Elem()
}

type CheckInstantClone_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CheckLicenseFeature CheckLicenseFeatureRequestType

func init() {
	t["CheckLicenseFeature"] = reflect.TypeOf((*CheckLicenseFeature)(nil)).Elem()
}

// The parameters of `LicenseManager.CheckLicenseFeature`.
type CheckLicenseFeatureRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Host to act on if LicenseManager is not on a host.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// Name of the feature to enable.
	FeatureKey string `xml:"featureKey" json:"featureKey"`
}

func init() {
	t["CheckLicenseFeatureRequestType"] = reflect.TypeOf((*CheckLicenseFeatureRequestType)(nil)).Elem()
}

type CheckLicenseFeatureResponse struct {
	Returnval bool `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachineProvisioningChecker.CheckMigrate_Task`.
type CheckMigrateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The virtual machine we propose to migrate.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The target host on which the virtual machines will run. The host
	// parameter may be left unset if the compute resource associated with
	// the target pool represents a stand-alone host or a DRS-enabled
	// cluster. In the former case the stand-alone host is used as the
	// target host. In the latter case, each connected host in the cluster
	// that is not in maintenance mode is tested as a target host.
	// If the virtual machine is a template then either this
	// parameter or the pool parameter must be set.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The target resource pool for the virtual machines. If the
	// pool parameter is left unset, the target pool for each particular
	// virtual machine's migration will be that virtual machine's current
	// pool. If the virtual machine is a template then either this
	// parameter or the host parameter must be set.
	// The pool parameter must be set for testing the feasibility of
	// migration to a different datacenter or different vCenter service.
	//
	// Refers instance of `ResourcePool`.
	Pool *ManagedObjectReference `xml:"pool,omitempty" json:"pool,omitempty"`
	// The power state that the virtual machines must have. If
	// this argument is not set, each virtual machine is evaluated
	// according to its current power state.
	State VirtualMachinePowerState `xml:"state,omitempty" json:"state,omitempty"`
	// The set of tests to run. If this argument is not set, all
	// tests will be run. See `CheckTestType_enum` for possible values.
	TestType []string `xml:"testType,omitempty" json:"testType,omitempty"`
}

func init() {
	t["CheckMigrateRequestType"] = reflect.TypeOf((*CheckMigrateRequestType)(nil)).Elem()
}

type CheckMigrate_Task CheckMigrateRequestType

func init() {
	t["CheckMigrate_Task"] = reflect.TypeOf((*CheckMigrate_Task)(nil)).Elem()
}

type CheckMigrate_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachineCompatibilityChecker.CheckPowerOn_Task`.
type CheckPowerOnRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The virtual machine to power on.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The host on which we want to power on the virtual machine.
	// The host parameter may be left unset if the compute
	// resource associated with the pool represents a stand-alone host
	// or a DRS-enabled cluster. In the former case the stand-alone host
	// is used. In the latter case, each connected host in the cluster
	// that is not in maintenance mode is tested. Either this parameter
	// or the pool parameter must be set.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The resource pool we would like the virtual machine to run
	// in. If the pool parameter is left unset, we use the host's
	// root resource pool.
	//
	// Refers instance of `ResourcePool`.
	Pool *ManagedObjectReference `xml:"pool,omitempty" json:"pool,omitempty"`
	// The set of tests to run. If this argument is not set,
	// all tests will be run. See `CheckTestType_enum` for possible values.
	TestType []string `xml:"testType,omitempty" json:"testType,omitempty"`
}

func init() {
	t["CheckPowerOnRequestType"] = reflect.TypeOf((*CheckPowerOnRequestType)(nil)).Elem()
}

type CheckPowerOn_Task CheckPowerOnRequestType

func init() {
	t["CheckPowerOn_Task"] = reflect.TypeOf((*CheckPowerOn_Task)(nil)).Elem()
}

type CheckPowerOn_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `Profile.CheckProfileCompliance_Task`.
type CheckProfileComplianceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If specified, the compliance check is performed on this entity.
	// If the entity is not specified, the vCenter Server runs a compliance check on all the
	// entities associated with the profile. The entity does not have to be associated with the
	// profile.
	//
	// Refers instances of `ManagedEntity`.
	Entity []ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["CheckProfileComplianceRequestType"] = reflect.TypeOf((*CheckProfileComplianceRequestType)(nil)).Elem()
}

type CheckProfileCompliance_Task CheckProfileComplianceRequestType

func init() {
	t["CheckProfileCompliance_Task"] = reflect.TypeOf((*CheckProfileCompliance_Task)(nil)).Elem()
}

type CheckProfileCompliance_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachineProvisioningChecker.CheckRelocate_Task`.
type CheckRelocateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The virtual machine we propose to relocate.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The specification of where to relocate the virtual machine.
	// In cases where DRS would automatically select a host, all potential
	// hosts are tested against.
	// The host parameter in the spec may be left unset for checking
	// feasibility of relocation to a different datacenter or different
	// vCenter service, if the compute resource associated with the
	// target pool represents a stand-alone host, the host is tested
	// against, otherwise each connected host in the cluster that is
	// not in maintenance mode represented by the target pool is tested
	// as a target host.
	Spec VirtualMachineRelocateSpec `xml:"spec" json:"spec"`
	// The set of tests to run. If this argument is not set, all
	// tests will be run. See `CheckTestType_enum` for possible values.
	TestType []string `xml:"testType,omitempty" json:"testType,omitempty"`
}

func init() {
	t["CheckRelocateRequestType"] = reflect.TypeOf((*CheckRelocateRequestType)(nil)).Elem()
}

type CheckRelocate_Task CheckRelocateRequestType

func init() {
	t["CheckRelocate_Task"] = reflect.TypeOf((*CheckRelocate_Task)(nil)).Elem()
}

type CheckRelocate_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The result of a call to any of the methods in either
// `VirtualMachineCompatibilityChecker` or `VirtualMachineProvisioningChecker`.
type CheckResult struct {
	DynamicData

	// The virtual machine involved in the testing.
	//
	// Refers instance of `VirtualMachine`.
	Vm *ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
	// The host involved in the testing.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// A list of faults representing problems which may
	// require attention, but which are not fatal.
	Warning []LocalizedMethodFault `xml:"warning,omitempty" json:"warning,omitempty"`
	// A list of faults representing problems which are fatal
	// to the operation.
	//
	// For `VirtualMachineProvisioningChecker` an error means that the
	// given provisioning operation would fail.
	// For `VirtualMachineCompatibilityChecker` an error means that either
	// a power-on of this virtual machine would fail, or that the
	// virtual machine would not run correctly once powered-on.
	Error []LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
}

func init() {
	t["CheckResult"] = reflect.TypeOf((*CheckResult)(nil)).Elem()
}

// The parameters of `VirtualMachineCompatibilityChecker.CheckVmConfig_Task`.
type CheckVmConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specification of the virtual machine to create.
	Spec VirtualMachineConfigSpec `xml:"spec" json:"spec"`
	// The existing virtual machine to apply the spec to.
	// If this is not provided, the spec is assumed to be for the creation
	// of a new virtual machine.
	//
	// Refers instance of `VirtualMachine`.
	Vm *ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
	// The host we would like the virtual machine
	// to execute on. The host parameter may be left unset if the compute
	// resource associated with the pool represents a stand-alone host
	// or a DRS-enabled cluster. In the former case the stand-alone host
	// is used. In the latter case, each connected host in the cluster
	// that is not in maintenance mode is tested. If the virtual machine
	// is a template, then either this parameter or the pool parameter
	// must be set.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The resource pool we would like the virtual machine
	// to reside in. If the pool parameter is left unset, then we use the
	// host's root resource pool.
	//
	// Refers instance of `ResourcePool`.
	Pool *ManagedObjectReference `xml:"pool,omitempty" json:"pool,omitempty"`
	// The set of tests to run. If this argument is not set, all
	// tests will be run. See `CheckTestType_enum` for possible values.
	TestType []string `xml:"testType,omitempty" json:"testType,omitempty"`
}

func init() {
	t["CheckVmConfigRequestType"] = reflect.TypeOf((*CheckVmConfigRequestType)(nil)).Elem()
}

type CheckVmConfig_Task CheckVmConfigRequestType

func init() {
	t["CheckVmConfig_Task"] = reflect.TypeOf((*CheckVmConfig_Task)(nil)).Elem()
}

type CheckVmConfig_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The ChoiceOption data object type defines a set of
// supported string values, a localizable description for each value,
// and the default value.
type ChoiceOption struct {
	OptionType

	// The set of possible selections and descriptions.
	ChoiceInfo []BaseElementDescription `xml:"choiceInfo,typeattr" json:"choiceInfo"`
	// The index in ChoiceOption.value that serves as the default value.
	DefaultIndex int32 `xml:"defaultIndex,omitempty" json:"defaultIndex,omitempty"`
}

func init() {
	t["ChoiceOption"] = reflect.TypeOf((*ChoiceOption)(nil)).Elem()
}

type ClearComplianceStatus ClearComplianceStatusRequestType

func init() {
	t["ClearComplianceStatus"] = reflect.TypeOf((*ClearComplianceStatus)(nil)).Elem()
}

// The parameters of `ProfileComplianceManager.ClearComplianceStatus`.
type ClearComplianceStatusRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If specified, clear the ComplianceResult related to the Profile.
	//
	// Refers instances of `Profile`.
	Profile []ManagedObjectReference `xml:"profile,omitempty" json:"profile,omitempty"`
	// If specified, clear the ComplianceResult related to the entity.
	// If profile and entity are not specified, all the ComplianceResults will be cleared.
	//
	// Refers instances of `ManagedEntity`.
	Entity []ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["ClearComplianceStatusRequestType"] = reflect.TypeOf((*ClearComplianceStatusRequestType)(nil)).Elem()
}

type ClearComplianceStatusResponse struct {
}

type ClearNFSUser ClearNFSUserRequestType

func init() {
	t["ClearNFSUser"] = reflect.TypeOf((*ClearNFSUser)(nil)).Elem()
}

type ClearNFSUserRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ClearNFSUserRequestType"] = reflect.TypeOf((*ClearNFSUserRequestType)(nil)).Elem()
}

type ClearNFSUserResponse struct {
}

type ClearSystemEventLog ClearSystemEventLogRequestType

func init() {
	t["ClearSystemEventLog"] = reflect.TypeOf((*ClearSystemEventLog)(nil)).Elem()
}

type ClearSystemEventLogRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ClearSystemEventLogRequestType"] = reflect.TypeOf((*ClearSystemEventLogRequestType)(nil)).Elem()
}

type ClearSystemEventLogResponse struct {
}

type ClearTriggeredAlarms ClearTriggeredAlarmsRequestType

func init() {
	t["ClearTriggeredAlarms"] = reflect.TypeOf((*ClearTriggeredAlarms)(nil)).Elem()
}

// The parameters of `AlarmManager.ClearTriggeredAlarms`.
type ClearTriggeredAlarmsRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	Filter AlarmFilterSpec        `xml:"filter" json:"filter"`
}

func init() {
	t["ClearTriggeredAlarmsRequestType"] = reflect.TypeOf((*ClearTriggeredAlarmsRequestType)(nil)).Elem()
}

type ClearTriggeredAlarmsResponse struct {
}

type ClearVStorageObjectControlFlags ClearVStorageObjectControlFlagsRequestType

func init() {
	t["ClearVStorageObjectControlFlags"] = reflect.TypeOf((*ClearVStorageObjectControlFlags)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.ClearVStorageObjectControlFlags`.
type ClearVStorageObjectControlFlagsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage
	// object is located.
	//
	// Required privileges: Datastore.FileManagement
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// control flags enum array to be cleared on the
	// VStorageObject. All control flags not included
	// in the array remain intact.
	ControlFlags []string `xml:"controlFlags,omitempty" json:"controlFlags,omitempty"`
}

func init() {
	t["ClearVStorageObjectControlFlagsRequestType"] = reflect.TypeOf((*ClearVStorageObjectControlFlagsRequestType)(nil)).Elem()
}

type ClearVStorageObjectControlFlagsResponse struct {
}

// Fault indicating that the clock skew in the system exceeds the limit.
type ClockSkew struct {
	HostConfigFault
}

func init() {
	t["ClockSkew"] = reflect.TypeOf((*ClockSkew)(nil)).Elem()
}

type ClockSkewFault ClockSkew

func init() {
	t["ClockSkewFault"] = reflect.TypeOf((*ClockSkewFault)(nil)).Elem()
}

// An attempt is being made to clone a virtual machine from a snapshot
// point, and this is not supported.
//
// See also `VirtualMachineCloneSpec.snapshot`, `VirtualMachineCapability.snapshotConfigSupported`, `HostCapability.cloneFromSnapshotSupported`.
type CloneFromSnapshotNotSupported struct {
	MigrationFault
}

func init() {
	t["CloneFromSnapshotNotSupported"] = reflect.TypeOf((*CloneFromSnapshotNotSupported)(nil)).Elem()
}

type CloneFromSnapshotNotSupportedFault CloneFromSnapshotNotSupported

func init() {
	t["CloneFromSnapshotNotSupportedFault"] = reflect.TypeOf((*CloneFromSnapshotNotSupportedFault)(nil)).Elem()
}

type CloneSession CloneSessionRequestType

func init() {
	t["CloneSession"] = reflect.TypeOf((*CloneSession)(nil)).Elem()
}

// The parameters of `SessionManager.CloneSession`.
type CloneSessionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// ticket string acquired via `SessionManager.AcquireCloneTicket`.
	CloneTicket string `xml:"cloneTicket" json:"cloneTicket"`
}

func init() {
	t["CloneSessionRequestType"] = reflect.TypeOf((*CloneSessionRequestType)(nil)).Elem()
}

type CloneSessionResponse struct {
	Returnval UserSession `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualApp.CloneVApp_Task`.
type CloneVAppRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the new vApp.
	Name string `xml:"name" json:"name"`
	// The parent entity of the new vApp. Must be of type
	// `ResourcePool` or `VirtualApp`.
	//
	// Refers instance of `ResourcePool`.
	Target ManagedObjectReference `xml:"target" json:"target"`
	// Specifies how to clone the vApp.
	Spec VAppCloneSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CloneVAppRequestType"] = reflect.TypeOf((*CloneVAppRequestType)(nil)).Elem()
}

type CloneVApp_Task CloneVAppRequestType

func init() {
	t["CloneVApp_Task"] = reflect.TypeOf((*CloneVApp_Task)(nil)).Elem()
}

type CloneVApp_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.CloneVM_Task`.
type CloneVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The location of the new virtual machine.
	//
	// Required privileges: VirtualMachine.Inventory.CreateFromExisting
	//
	// Refers instance of `Folder`.
	Folder ManagedObjectReference `xml:"folder" json:"folder"`
	// The name of the new virtual machine.
	Name string `xml:"name" json:"name"`
	// Specifies how to clone the virtual machine. The folder
	// specified in the spec takes precedence over the folder parameter.
	Spec VirtualMachineCloneSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CloneVMRequestType"] = reflect.TypeOf((*CloneVMRequestType)(nil)).Elem()
}

type CloneVM_Task CloneVMRequestType

func init() {
	t["CloneVM_Task"] = reflect.TypeOf((*CloneVM_Task)(nil)).Elem()
}

type CloneVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VcenterVStorageObjectManager.CloneVStorageObject_Task`.
type CloneVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The specification for cloning the virtual storage
	// object.
	Spec VslmCloneSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CloneVStorageObjectRequestType"] = reflect.TypeOf((*CloneVStorageObjectRequestType)(nil)).Elem()
}

type CloneVStorageObject_Task CloneVStorageObjectRequestType

func init() {
	t["CloneVStorageObject_Task"] = reflect.TypeOf((*CloneVStorageObject_Task)(nil)).Elem()
}

type CloneVStorageObject_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CloseInventoryViewFolder CloseInventoryViewFolderRequestType

func init() {
	t["CloseInventoryViewFolder"] = reflect.TypeOf((*CloseInventoryViewFolder)(nil)).Elem()
}

// The parameters of `InventoryView.CloseInventoryViewFolder`.
type CloseInventoryViewFolderRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// An array of managed object references. Each array entry is a
	// reference to an entity to collapse.
	//
	// Required privileges: System.View
	//
	// Refers instances of `ManagedEntity`.
	Entity []ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["CloseInventoryViewFolderRequestType"] = reflect.TypeOf((*CloseInventoryViewFolderRequestType)(nil)).Elem()
}

type CloseInventoryViewFolderResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// Base class for all action recommendations in VirtualCenter.
type ClusterAction struct {
	DynamicData

	// Type of the action.
	//
	// This is encoded to differentiate between
	// different types of actions aimed at achieving different goals.
	Type string `xml:"type" json:"type"`
	// The target object on which this action will be applied.
	//
	// For
	// instance, a migration action will have a virtual machine as its
	// target object, while a host power action will have a host as its
	// target action.
	Target *ManagedObjectReference `xml:"target,omitempty" json:"target,omitempty"`
}

func init() {
	t["ClusterAction"] = reflect.TypeOf((*ClusterAction)(nil)).Elem()
}

// Base class for all action history.
type ClusterActionHistory struct {
	DynamicData

	// The action that was executed recently.
	Action BaseClusterAction `xml:"action,typeattr" json:"action"`
	// The time when the action was executed.
	Time time.Time `xml:"time" json:"time"`
}

func init() {
	t["ClusterActionHistory"] = reflect.TypeOf((*ClusterActionHistory)(nil)).Elem()
}

// The `ClusterAffinityRuleSpec` data object defines a set
// of virtual machines.
//
// DRS will attempt to schedule the virtual machines
// to run on the same host.
type ClusterAffinityRuleSpec struct {
	ClusterRuleInfo

	// List of virtual machine references.
	//
	// Refers instances of `VirtualMachine`.
	Vm []ManagedObjectReference `xml:"vm" json:"vm"`
}

func init() {
	t["ClusterAffinityRuleSpec"] = reflect.TypeOf((*ClusterAffinityRuleSpec)(nil)).Elem()
}

// The `ClusterAntiAffinityRuleSpec` data object defines
// a set of virtual machines.
//
// DRS will attempt to schedule the virtual
// machines to run on different hosts.
type ClusterAntiAffinityRuleSpec struct {
	ClusterRuleInfo

	// List of virtual machine references.
	//
	// Refers instances of `VirtualMachine`.
	Vm []ManagedObjectReference `xml:"vm" json:"vm"`
}

func init() {
	t["ClusterAntiAffinityRuleSpec"] = reflect.TypeOf((*ClusterAntiAffinityRuleSpec)(nil)).Elem()
}

// This data class reports virtual machine powerOn information.
type ClusterAttemptedVmInfo struct {
	DynamicData

	// The virtual machine being powered on.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The ID of the task, which monitors powering on.
	//
	// Refers instance of `Task`.
	Task *ManagedObjectReference `xml:"task,omitempty" json:"task,omitempty"`
}

func init() {
	t["ClusterAttemptedVmInfo"] = reflect.TypeOf((*ClusterAttemptedVmInfo)(nil)).Elem()
}

// Describes an action for the initial placement of a virtual machine in a
// cluster.
//
// This action is used by the cross cluster placement API when a
// virtual machine needs to be placed across a set of given clusters. See
// `Folder.PlaceVmsXCluster`. This action encapsulates details
// about the chosen cluster (via the resource pool inside that cluster), the
// chosen host and the chosen datastores for the disks of the virtual machine.
type ClusterClusterInitialPlacementAction struct {
	ClusterAction

	// The host where the virtual machine should be initially placed.
	//
	// This field
	// is optional because the primary use case of
	// `Folder.PlaceVmsXCluster` is to select the best cluster for
	// placing VMs. This `ClusterClusterInitialPlacementAction.targetHost`
	// denotes the best host within the best cluster and it is only returned
	// if the client asks for it, which is determined by
	// `PlaceVmsXClusterSpec.hostRecommRequired`. If
	// `PlaceVmsXClusterSpec.hostRecommRequired` is set to true, then
	// the targetHost is returned with a valid value and if it is either set to
	// false or left unset, then targetHost is also left unset. When this field
	// is unset, then it means that the client did not ask for the target host
	// within the recommended cluster. It does not mean that there is no
	// recommended host for placing this VM in the recommended cluster.
	//
	// Refers instance of `HostSystem`.
	TargetHost *ManagedObjectReference `xml:"targetHost,omitempty" json:"targetHost,omitempty"`
	// The chosen resource pool for placing the virtual machine.
	//
	// This is non-
	// optional because recommending the best cluster (by recommending the
	// resource pool in the best cluster) is the primary use case for the
	// `ClusterClusterInitialPlacementAction`.
	//
	// Refers instance of `ResourcePool`.
	Pool ManagedObjectReference `xml:"pool" json:"pool"`
	// The config spec of the virtual machine to be placed.
	//
	// The `Folder.PlaceVmsXCluster` method takes
	// input of `VirtualMachineConfigSpec` from client and populates the backing
	// for each virtual disk and the VM home path in it unless the input
	// ConfigSpec already provides them. The existing settings in the input
	// ConfigSpec are preserved and not overridden in the returned ConfigSpec
	// in this action as well as the resulting
	// `ClusterRecommendation`. This field is set based on whether
	// the client needs `Folder.PlaceVmsXCluster` to recommend a
	// backing datastore for the disks of the candidate VMs or not, which is
	// specified via `PlaceVmsXClusterSpec.datastoreRecommRequired`.
	// If `PlaceVmsXClusterSpec.datastoreRecommRequired` is set to
	// true, then this
	// `ClusterClusterInitialPlacementAction.configSpec` is also set
	// with the backing of each disk populated. If
	// `PlaceVmsXClusterSpec.datastoreRecommRequired` is either set to
	// false or left unset, then this field is also left unset. When this field
	// is left unset, then it means that the client did not ask to populate the
	// backing datastore for the disks of the candidate VMs.
	ConfigSpec *VirtualMachineConfigSpec `xml:"configSpec,omitempty" json:"configSpec,omitempty"`
}

func init() {
	t["ClusterClusterInitialPlacementAction"] = reflect.TypeOf((*ClusterClusterInitialPlacementAction)(nil)).Elem()
	minAPIVersionForType["ClusterClusterInitialPlacementAction"] = "8.0.0.1"
}

// This event records that a compliance check was triggered
// on the cluster.
type ClusterComplianceCheckedEvent struct {
	ClusterEvent

	Profile ProfileEventArgument `xml:"profile" json:"profile"`
}

func init() {
	t["ClusterComplianceCheckedEvent"] = reflect.TypeOf((*ClusterComplianceCheckedEvent)(nil)).Elem()
}

// ClusterConfigResult is the result returned for the `ClusterComputeResource.ConfigureHCI_Task`
// method.
type ClusterComputeResourceClusterConfigResult struct {
	DynamicData

	// List of failed hosts.
	FailedHosts []FolderFailedHostResult `xml:"failedHosts,omitempty" json:"failedHosts,omitempty"`
	// List of successfully configured hosts.
	//
	// Refers instances of `HostSystem`.
	ConfiguredHosts []ManagedObjectReference `xml:"configuredHosts,omitempty" json:"configuredHosts,omitempty"`
}

func init() {
	t["ClusterComputeResourceClusterConfigResult"] = reflect.TypeOf((*ClusterComputeResourceClusterConfigResult)(nil)).Elem()
}

// The encryption mode policy for a cluster.
type ClusterComputeResourceCryptoModePolicy struct {
	DynamicData

	// The host key identifier.
	//
	// When set, all hosts in the cluster will use this key when enabling
	// the crypto safe mode. Only one of `ClusterComputeResourceCryptoModePolicy.keyId` and
	// `ClusterComputeResourceCryptoModePolicy.providerId` may be set.
	KeyId *CryptoKeyId `xml:"keyId,omitempty" json:"keyId,omitempty"`
	// The host key provider identifier.
	//
	// When set, all hosts in the cluster will use a key from the specified
	// key provider when enabling the crypto safe mode. Only one of
	// `ClusterComputeResourceCryptoModePolicy.keyId` and `ClusterComputeResourceCryptoModePolicy.providerId` may be set.
	ProviderId *KeyProviderId `xml:"providerId,omitempty" json:"providerId,omitempty"`
}

func init() {
	t["ClusterComputeResourceCryptoModePolicy"] = reflect.TypeOf((*ClusterComputeResourceCryptoModePolicy)(nil)).Elem()
	minAPIVersionForType["ClusterComputeResourceCryptoModePolicy"] = "8.0.3.0"
}

// Describes the validations applicable to the network settings.
//
// These
// are based off the information recorded in
// `dvsSetting`.
type ClusterComputeResourceDVSConfigurationValidation struct {
	ClusterComputeResourceValidationResultBase

	// Check if the DVS is alive.
	IsDvsValid bool `xml:"isDvsValid" json:"isDvsValid"`
	// Check if the portgroups are valid.
	IsDvpgValid bool `xml:"isDvpgValid" json:"isDvpgValid"`
}

func init() {
	t["ClusterComputeResourceDVSConfigurationValidation"] = reflect.TypeOf((*ClusterComputeResourceDVSConfigurationValidation)(nil)).Elem()
}

// Contains reference to the DVS, list of physical nics attached to it,
// and list of dvportgroups created on it while initially configuring a
// cluster by calling the `ClusterComputeResource.ConfigureHCI_Task` method.
type ClusterComputeResourceDVSSetting struct {
	DynamicData

	// Managed object reference to the DVS.
	//
	// Refers instance of `DistributedVirtualSwitch`.
	DvSwitch ManagedObjectReference `xml:"dvSwitch" json:"dvSwitch"`
	// List of physical nics attached to the DVS.
	PnicDevices []string `xml:"pnicDevices,omitempty" json:"pnicDevices,omitempty"`
	// Describes dvportgroups on the DVS and services residing on each one.
	DvPortgroupSetting []ClusterComputeResourceDVSSettingDVPortgroupToServiceMapping `xml:"dvPortgroupSetting,omitempty" json:"dvPortgroupSetting,omitempty"`
}

func init() {
	t["ClusterComputeResourceDVSSetting"] = reflect.TypeOf((*ClusterComputeResourceDVSSetting)(nil)).Elem()
}

type ClusterComputeResourceDVSSettingDVPortgroupToServiceMapping struct {
	DynamicData

	// Managed object reference to the dvportgroup.
	//
	// Refers instance of `DistributedVirtualPortgroup`.
	DvPortgroup ManagedObjectReference `xml:"dvPortgroup" json:"dvPortgroup"`
	// Service to be configured on the virtual nics attached to this
	// dvportgroup.
	//
	// See `HostVirtualNicManagerNicType_enum` for
	// supported values.
	Service string `xml:"service" json:"service"`
}

func init() {
	t["ClusterComputeResourceDVSSettingDVPortgroupToServiceMapping"] = reflect.TypeOf((*ClusterComputeResourceDVSSettingDVPortgroupToServiceMapping)(nil)).Elem()
}

// Describes DVS related information to be configured by calling
// `ClusterComputeResource.ConfigureHCI_Task` method.
//
// Consists of name of the DVS, the physical adapters to be attached to it
// and the list of dvportgroups to be created on this DVS.
type ClusterComputeResourceDvsProfile struct {
	DynamicData

	// Name of the new `DistributedVirtualSwitch`.
	DvsName string `xml:"dvsName,omitempty" json:"dvsName,omitempty"`
	// Managed object reference to an existing `DistributedVirtualSwitch`.
	//
	// Refers instance of `DistributedVirtualSwitch`.
	DvSwitch *ManagedObjectReference `xml:"dvSwitch,omitempty" json:"dvSwitch,omitempty"`
	// List of physical Nics to be attached to the DVS.
	PnicDevices        []string                                                          `xml:"pnicDevices,omitempty" json:"pnicDevices,omitempty"`
	DvPortgroupMapping []ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping `xml:"dvPortgroupMapping,omitempty" json:"dvPortgroupMapping,omitempty"`
}

func init() {
	t["ClusterComputeResourceDvsProfile"] = reflect.TypeOf((*ClusterComputeResourceDvsProfile)(nil)).Elem()
}

type ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping struct {
	DynamicData

	// Specification for a new `DistributedVirtualPortgroup`.
	DvPortgroupSpec *DVPortgroupConfigSpec `xml:"dvPortgroupSpec,omitempty" json:"dvPortgroupSpec,omitempty"`
	// Managed object reference to an existing `DistributedVirtualPortgroup`.
	//
	// Refers instance of `DistributedVirtualPortgroup`.
	DvPortgroup *ManagedObjectReference `xml:"dvPortgroup,omitempty" json:"dvPortgroup,omitempty"`
	// Service to be configured on the virtual nics attached to this
	// dvportgroup.
	//
	// See `HostVirtualNicManagerNicType_enum` for
	// supported values.
	Service string `xml:"service" json:"service"`
}

func init() {
	t["ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping"] = reflect.TypeOf((*ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping)(nil)).Elem()
}

// This data object captures a subset of initial configuration of the cluster,
// which was configured by calling the `ClusterComputeResource.ConfigureHCI_Task` method.
type ClusterComputeResourceHCIConfigInfo struct {
	DynamicData

	// Configuration pertinent to state of the HCI workflow.
	//
	// Valid
	// values are enumerated by the `HCIWorkflowState`
	// type.
	WorkflowState string `xml:"workflowState" json:"workflowState"`
	// Contains DVS related information captured while configuring
	// the cluster.
	DvsSetting []ClusterComputeResourceDVSSetting `xml:"dvsSetting,omitempty" json:"dvsSetting,omitempty"`
	// Contains a list of hosts that are currently configured using
	// `ClusterComputeResource.ConfigureHCI_Task` and `ClusterComputeResource.ExtendHCI_Task`
	// method.
	//
	// A failed host will not be part of this list.
	//
	// Refers instances of `HostSystem`.
	ConfiguredHosts []ManagedObjectReference `xml:"configuredHosts,omitempty" json:"configuredHosts,omitempty"`
	// Configuration of host services and host settings.
	HostConfigProfile *ClusterComputeResourceHostConfigurationProfile `xml:"hostConfigProfile,omitempty" json:"hostConfigProfile,omitempty"`
}

func init() {
	t["ClusterComputeResourceHCIConfigInfo"] = reflect.TypeOf((*ClusterComputeResourceHCIConfigInfo)(nil)).Elem()
}

// Specification to configure the cluster.
type ClusterComputeResourceHCIConfigSpec struct {
	DynamicData

	// Information related to network configuration.
	//
	// For each DvsProfile
	// object, specify either `ClusterComputeResourceDvsProfile.dvsName` or
	// `ClusterComputeResourceDvsProfile.dvSwitch`. Across all DvsProfile objects, specify
	// exactly one
	// `ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping.dvPortgroup` or
	// `ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping.dvPortgroupSpec` per
	// `ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping.service`.
	DvsProf []ClusterComputeResourceDvsProfile `xml:"dvsProf,omitempty" json:"dvsProf,omitempty"`
	// Configuration of host services and host settings.
	HostConfigProfile *ClusterComputeResourceHostConfigurationProfile `xml:"hostConfigProfile,omitempty" json:"hostConfigProfile,omitempty"`
	// vSan configuration specification.
	//
	// This is vim.vsan.ReconfigSpec object
	// represented via the VIM object.
	VSanConfigSpec *SDDCBase `xml:"vSanConfigSpec,omitempty" json:"vSanConfigSpec,omitempty"`
	// Describes cluster and EVC configuration.
	VcProf *ClusterComputeResourceVCProfile `xml:"vcProf,omitempty" json:"vcProf,omitempty"`
}

func init() {
	t["ClusterComputeResourceHCIConfigSpec"] = reflect.TypeOf((*ClusterComputeResourceHCIConfigSpec)(nil)).Elem()
}

// Host configuration input to configure hosts in a cluster.
type ClusterComputeResourceHostConfigurationInput struct {
	DynamicData

	// Refers instance of `HostSystem`.
	Host        ManagedObjectReference                 `xml:"host" json:"host"`
	HostVmkNics []ClusterComputeResourceHostVmkNicInfo `xml:"hostVmkNics,omitempty" json:"hostVmkNics,omitempty"`
	// To apply configuration on the host, the host is expected to be in
	// maintenance mode.
	//
	// This constraint can be relaxed by setting this
	// flag to true.
	AllowedInNonMaintenanceMode *bool `xml:"allowedInNonMaintenanceMode" json:"allowedInNonMaintenanceMode,omitempty"`
}

func init() {
	t["ClusterComputeResourceHostConfigurationInput"] = reflect.TypeOf((*ClusterComputeResourceHostConfigurationInput)(nil)).Elem()
}

// HostConfigurationProfile describes the configuration of services
// and settings which gets applied on every host in the HCI cluster.
type ClusterComputeResourceHostConfigurationProfile struct {
	DynamicData

	// Date and time settings
	DateTimeConfig *HostDateTimeConfig `xml:"dateTimeConfig,omitempty" json:"dateTimeConfig,omitempty"`
	// Desired lockdown mode
	LockdownMode HostLockdownMode `xml:"lockdownMode,omitempty" json:"lockdownMode,omitempty"`
}

func init() {
	t["ClusterComputeResourceHostConfigurationProfile"] = reflect.TypeOf((*ClusterComputeResourceHostConfigurationProfile)(nil)).Elem()
}

// Describes the validations applicable to the settings on the host.
type ClusterComputeResourceHostConfigurationValidation struct {
	ClusterComputeResourceValidationResultBase

	// Host being validated.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Check if the host is attached to the DVS on right adapters.
	IsDvsSettingValid *bool `xml:"isDvsSettingValid" json:"isDvsSettingValid,omitempty"`
	// Check if the adapters for services are present and on the right
	// portgroups.
	IsVmknicSettingValid *bool `xml:"isVmknicSettingValid" json:"isVmknicSettingValid,omitempty"`
	// Check if NTP is configured per specification.
	IsNtpSettingValid *bool `xml:"isNtpSettingValid" json:"isNtpSettingValid,omitempty"`
	// Check if lockdown mode is set per specification
	IsLockdownModeValid *bool `xml:"isLockdownModeValid" json:"isLockdownModeValid,omitempty"`
}

func init() {
	t["ClusterComputeResourceHostConfigurationValidation"] = reflect.TypeOf((*ClusterComputeResourceHostConfigurationValidation)(nil)).Elem()
}

// This data object describes what evacuation actions should be made for a given host.
type ClusterComputeResourceHostEvacuationInfo struct {
	DynamicData

	// Candidate host to be put into maintenance mode.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Specifies the list of required actions.
	//
	// Depending on the specified option values passed, additional
	// actions such as ones related to evacuation of specific objects,
	// additional memory reservation or allowing/disallowing certain groups
	// of operations may be taken when entering the desired flavor of
	// maintenance mode. The list of supported options and values may vary
	// based on the version of the ESXi host and Virtual Center.
	//
	// If unset, a default list of actions will be assumed based on the
	// selected flavor of maintenance mode as specified by the
	// `ClusterComputeResourceMaintenanceInfo.partialMMId` field. See `HostPartialMaintenanceModeId_enum`
	// for further information about individual flavors.
	Action []BaseOptionValue `xml:"action,omitempty,typeattr" json:"action,omitempty"`
}

func init() {
	t["ClusterComputeResourceHostEvacuationInfo"] = reflect.TypeOf((*ClusterComputeResourceHostEvacuationInfo)(nil)).Elem()
	minAPIVersionForType["ClusterComputeResourceHostEvacuationInfo"] = "8.0.3.0"
}

// This data object describes how a vmknic on a host must be configured.
type ClusterComputeResourceHostVmkNicInfo struct {
	DynamicData

	// NIC specification
	NicSpec HostVirtualNicSpec `xml:"nicSpec" json:"nicSpec"`
	// Service type for this adapter.
	//
	// See
	// `HostVirtualNicManagerNicType_enum` for supported values.
	Service string `xml:"service" json:"service"`
}

func init() {
	t["ClusterComputeResourceHostVmkNicInfo"] = reflect.TypeOf((*ClusterComputeResourceHostVmkNicInfo)(nil)).Elem()
}

// This data object describes how a given array of hosts will be put into maintenance mode.
type ClusterComputeResourceMaintenanceInfo struct {
	DynamicData

	// Indicates the flavor of maintenance mode requested.
	//
	// If set, specifies the desired flavor of partial
	// maintenance mode. Otherwise, full maintenance mode is assumed.
	// See `HostPartialMaintenanceModeId_enum` for supported values.
	PartialMMId string `xml:"partialMMId,omitempty" json:"partialMMId,omitempty"`
	// Evaucation information for each host
	HostEvacInfo []ClusterComputeResourceHostEvacuationInfo `xml:"hostEvacInfo,omitempty" json:"hostEvacInfo,omitempty"`
}

func init() {
	t["ClusterComputeResourceMaintenanceInfo"] = reflect.TypeOf((*ClusterComputeResourceMaintenanceInfo)(nil)).Elem()
	minAPIVersionForType["ClusterComputeResourceMaintenanceInfo"] = "8.0.3.0"
}

// The `ClusterComputeResourceSummary` data object
// encapsulates runtime properties of a `ClusterComputeResource`.
type ClusterComputeResourceSummary struct {
	ComputeResourceSummary

	// Deprecated as of vSphere API 4.0, use
	// `ClusterFailoverLevelAdmissionControlInfo.currentFailoverLevel`.
	//
	// Current failover level.
	//
	// This is the number of physical host failures that can
	// be tolerated without impacting the ability to satisfy the minimums for all
	// running virtual machines. This represents the current value, as opposed to
	// desired value configured by the user.
	CurrentFailoverLevel int32 `xml:"currentFailoverLevel" json:"currentFailoverLevel"`
	// Information about the current amount of resources available for a vSphere HA
	// cluster.
	//
	// The actual type of admissionControlInfo will depend on what kind of
	// `ClusterDasAdmissionControlPolicy` was used to configure the cluster.
	AdmissionControlInfo BaseClusterDasAdmissionControlInfo `xml:"admissionControlInfo,omitempty,typeattr" json:"admissionControlInfo,omitempty"`
	// Total number of migrations with VMotion that have been done internal to this
	// cluster.
	NumVmotions int32 `xml:"numVmotions" json:"numVmotions"`
	// The target balance, in terms of standard deviation, for a DRS cluster.
	//
	// Units are thousandths. For example, 12 represents 0.012.
	TargetBalance int32 `xml:"targetBalance,omitempty" json:"targetBalance,omitempty"`
	// The current balance, in terms of standard deviation, for a DRS cluster.
	//
	// Units are thousandths. For example, 12 represents 0.012.
	CurrentBalance int32 `xml:"currentBalance,omitempty" json:"currentBalance,omitempty"`
	// The DRS score of this cluster, in percentage.
	DrsScore int32 `xml:"drsScore,omitempty" json:"drsScore,omitempty"`
	// The number of VMs in this cluster corresponding to each DRS score
	// bucket.
	//
	// The buckets are defined as follows:
	//   - 0% - 20%
	//   - 21% - 40%
	//   - 41% - 60%
	//   - 61% - 80%
	//   - 81% - 100%
	NumVmsPerDrsScoreBucket []int32 `xml:"numVmsPerDrsScoreBucket,omitempty" json:"numVmsPerDrsScoreBucket,omitempty"`
	// The current usage summary for a DRS cluster.
	UsageSummary *ClusterUsageSummary `xml:"usageSummary,omitempty" json:"usageSummary,omitempty"`
	// The Enhanced VMotion Compatibility mode that is currently in effect
	// for all hosts in this cluster; unset if no EVC mode is active.
	//
	// See also `Capability.supportedEVCMode`.
	CurrentEVCModeKey string `xml:"currentEVCModeKey,omitempty" json:"currentEVCModeKey,omitempty"`
	// The Enhanced VMotion Compatibility Graphics mode that is currently in
	// effect for all hosts in this cluster; unset if no EVC mode is active.
	//
	// See also `Capability.supportedEVCGraphicsMode`.
	CurrentEVCGraphicsModeKey string `xml:"currentEVCGraphicsModeKey,omitempty" json:"currentEVCGraphicsModeKey,omitempty" vim:"7.0.1.0"`
	// Data pertaining to DAS.
	DasData BaseClusterDasData `xml:"dasData,omitempty,typeattr" json:"dasData,omitempty"`
	// Configuration pertinent to state of the cluster maintenance mode.
	//
	// Valid values are enumerated by the `ClusterMaintenanceModeStatus`
	// type.
	ClusterMaintenanceModeStatus string `xml:"clusterMaintenanceModeStatus,omitempty" json:"clusterMaintenanceModeStatus,omitempty" vim:"7.0.0.2"`
	// The health status of the vSphere Cluster Services in the cluster.
	//
	// Supported values are enumerated by the `VcsHealthStatus`
	// type.
	VcsHealthStatus string `xml:"vcsHealthStatus,omitempty" json:"vcsHealthStatus,omitempty" vim:"7.0.1.1"`
	// An array of hosts and number of resource slots on the host for
	// vSphere Cluster Services in the cluster.
	//
	// The number of resource slots on the host includes both following types:
	// 1\. Number of vCS VMs running on the host (resource reserved and occupied).
	// 2\. Number of reserved and unoccupied slots (reserved for new vCS VMs).
	VcsSlots []ClusterComputeResourceVcsSlots `xml:"vcsSlots,omitempty" json:"vcsSlots,omitempty" vim:"7.0.1.1"`
}

func init() {
	t["ClusterComputeResourceSummary"] = reflect.TypeOf((*ClusterComputeResourceSummary)(nil)).Elem()
}

// Describes cluster configuration for various vCenter services.
type ClusterComputeResourceVCProfile struct {
	DynamicData

	// Cluster configurarion.
	ClusterSpec *ClusterConfigSpecEx `xml:"clusterSpec,omitempty" json:"clusterSpec,omitempty"`
	// EVC mode key.
	EvcModeKey string `xml:"evcModeKey,omitempty" json:"evcModeKey,omitempty"`
	// EVC Graphics mode key
	EvcGraphicsModeKey string `xml:"evcGraphicsModeKey,omitempty" json:"evcGraphicsModeKey,omitempty" vim:"7.0.1.0"`
}

func init() {
	t["ClusterComputeResourceVCProfile"] = reflect.TypeOf((*ClusterComputeResourceVCProfile)(nil)).Elem()
}

// Describes the validation results.
type ClusterComputeResourceValidationResultBase struct {
	DynamicData

	// Describes the messages relevant to the validation result
	Info []LocalizableMessage `xml:"info,omitempty" json:"info,omitempty"`
}

func init() {
	t["ClusterComputeResourceValidationResultBase"] = reflect.TypeOf((*ClusterComputeResourceValidationResultBase)(nil)).Elem()
}

type ClusterComputeResourceVcsSlots struct {
	DynamicData

	// Identifier of the system for which the slots are applicable.
	SystemId string `xml:"systemId,omitempty" json:"systemId,omitempty" vim:"7.0.3.0"`
	// The host that has vSphere Cluster Services slots.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Datastores on the host which are recommended for vCLS VM deployment.
	//
	// Refers instances of `Datastore`.
	Datastore []ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty" vim:"7.0.3.0"`
	// The number of total vSphere Cluster Services slots on the host.
	TotalSlots int32 `xml:"totalSlots" json:"totalSlots"`
}

func init() {
	t["ClusterComputeResourceVcsSlots"] = reflect.TypeOf((*ClusterComputeResourceVcsSlots)(nil)).Elem()
	minAPIVersionForType["ClusterComputeResourceVcsSlots"] = "7.0.1.1"
}

// Deprecated as of VI API 2.5, use `ClusterConfigInfoEx`.
//
// A complete cluster configuration.
type ClusterConfigInfo struct {
	DynamicData

	// Cluster-wide configuration of the vSphere HA service.
	DasConfig ClusterDasConfigInfo `xml:"dasConfig" json:"dasConfig"`
	// List of virtual machine configurations for the vSphere HA
	// service.
	//
	// Each entry applies to one virtual machine.
	//
	// If a virtual machine is not specified in this array, the service uses
	// the default settings for that virtual machine.
	DasVmConfig []ClusterDasVmConfigInfo `xml:"dasVmConfig,omitempty" json:"dasVmConfig,omitempty"`
	// Cluster-wide configuration of the VMware DRS service.
	DrsConfig ClusterDrsConfigInfo `xml:"drsConfig" json:"drsConfig"`
	// List of virtual machine configurations for the VMware DRS
	// service.
	//
	// Each entry applies to one virtual machine.
	//
	// If a virtual machine is not specified in this array, the service uses
	// the default settings for that virtual machine.
	DrsVmConfig []ClusterDrsVmConfigInfo `xml:"drsVmConfig,omitempty" json:"drsVmConfig,omitempty"`
	// Cluster-wide rules.
	Rule []BaseClusterRuleInfo `xml:"rule,omitempty,typeattr" json:"rule,omitempty"`
}

func init() {
	t["ClusterConfigInfo"] = reflect.TypeOf((*ClusterConfigInfo)(nil)).Elem()
}

// The `ClusterConfigInfoEx` data object describes a complete cluster
// configuration.
//
// For information about configuring a cluster, see
// `ClusterConfigSpecEx`.
type ClusterConfigInfoEx struct {
	ComputeResourceConfigInfo

	// Configuration for vCLS system VMs deployment.
	SystemVMsConfig *ClusterSystemVMsConfigInfo `xml:"systemVMsConfig,omitempty" json:"systemVMsConfig,omitempty" vim:"7.0.3.0"`
	// Cluster-wide configuration of the vSphere HA service.
	DasConfig ClusterDasConfigInfo `xml:"dasConfig" json:"dasConfig"`
	// List of virtual machine configurations for the vSphere HA
	// service.
	//
	// Each entry applies to one virtual machine.
	//
	// If a virtual machine is not specified in this array, the service uses
	// the default settings for that virtual machine.
	DasVmConfig []ClusterDasVmConfigInfo `xml:"dasVmConfig,omitempty" json:"dasVmConfig,omitempty"`
	// Cluster-wide configuration of the VMware DRS service.
	DrsConfig ClusterDrsConfigInfo `xml:"drsConfig" json:"drsConfig"`
	// List of virtual machine configurations for the VMware DRS
	// service.
	//
	// Each entry applies to one virtual machine.
	//
	// If a virtual machine is not specified in this array, the service uses
	// the default settings for that virtual machine.
	DrsVmConfig []ClusterDrsVmConfigInfo `xml:"drsVmConfig,omitempty" json:"drsVmConfig,omitempty"`
	// Cluster-wide rules.
	Rule []BaseClusterRuleInfo `xml:"rule,omitempty,typeattr" json:"rule,omitempty"`
	// Cluster-wide configuration of VM orchestration.
	Orchestration *ClusterOrchestrationInfo `xml:"orchestration,omitempty" json:"orchestration,omitempty"`
	// List of virtual machine configurations that apply during cluster wide
	// VM orchestration.
	//
	// Each entry applies to one virtual machine.
	//
	// If a virtual machine is not specified in this array, the service uses
	// the default settings for that virtual machine.
	VmOrchestration []ClusterVmOrchestrationInfo `xml:"vmOrchestration,omitempty" json:"vmOrchestration,omitempty"`
	// Cluster-wide configuration of the VMware DPM service.
	DpmConfigInfo *ClusterDpmConfigInfo `xml:"dpmConfigInfo,omitempty" json:"dpmConfigInfo,omitempty"`
	// List of host configurations for the VMware DPM
	// service.
	//
	// Each entry applies to one host.
	//
	// If a host is not specified in this array, the service uses
	// the cluster default settings for that host.
	DpmHostConfig []ClusterDpmHostConfigInfo `xml:"dpmHostConfig,omitempty" json:"dpmHostConfig,omitempty"`
	// Cluster-wide configuration of the VMware VSAN service.
	VsanConfigInfo *VsanClusterConfigInfo `xml:"vsanConfigInfo,omitempty" json:"vsanConfigInfo,omitempty"`
	// List of host configurations for the VMware VSAN service.
	//
	// Each entry applies to one host.
	//
	// If a host is not specified in this array, the service uses
	// the cluster default settings for that host.
	VsanHostConfig []VsanHostConfigInfo `xml:"vsanHostConfig,omitempty" json:"vsanHostConfig,omitempty"`
	// Cluster-wide groups.
	Group []BaseClusterGroupInfo `xml:"group,omitempty,typeattr" json:"group,omitempty"`
	// Cluster-wide configuration of the VMware InfraUpdateHA service.
	InfraUpdateHaConfig *ClusterInfraUpdateHaConfigInfo `xml:"infraUpdateHaConfig,omitempty" json:"infraUpdateHaConfig,omitempty"`
	// Cluster-wide configuration of the ProactiveDRS service.
	ProactiveDrsConfig *ClusterProactiveDrsConfigInfo `xml:"proactiveDrsConfig,omitempty" json:"proactiveDrsConfig,omitempty"`
	// Cluster-wide configuration of the encryption mode.
	CryptoConfig *ClusterCryptoConfigInfo `xml:"cryptoConfig,omitempty" json:"cryptoConfig,omitempty"`
}

func init() {
	t["ClusterConfigInfoEx"] = reflect.TypeOf((*ClusterConfigInfoEx)(nil)).Elem()
}

// Deprecated as of VI API 2.5, use `ClusterConfigSpecEx`.
//
// A complete cluster configuration.
//
// All fields are defined as
// optional. In case of a reconfiguration, unset fields are
// unchanged.
type ClusterConfigSpec struct {
	DynamicData

	// Changes to the configuration of vSphere HA.
	DasConfig *ClusterDasConfigInfo `xml:"dasConfig,omitempty" json:"dasConfig,omitempty"`
	// Changes to the per-virtual-machine vSphere HA settings.
	DasVmConfigSpec []ClusterDasVmConfigSpec `xml:"dasVmConfigSpec,omitempty" json:"dasVmConfigSpec,omitempty"`
	// Changes to the configuration of the VMware DRS service.
	DrsConfig *ClusterDrsConfigInfo `xml:"drsConfig,omitempty" json:"drsConfig,omitempty"`
	// Changes to the per-virtual-machine DRS settings.
	DrsVmConfigSpec []ClusterDrsVmConfigSpec `xml:"drsVmConfigSpec,omitempty" json:"drsVmConfigSpec,omitempty"`
	// Changes to the set of rules.
	RulesSpec []ClusterRuleSpec `xml:"rulesSpec,omitempty" json:"rulesSpec,omitempty"`
}

func init() {
	t["ClusterConfigSpec"] = reflect.TypeOf((*ClusterConfigSpec)(nil)).Elem()
}

// The `ClusterConfigSpecEx` data object provides a set of update
// specifications for complete cluster configuration.
//
// You can configure a cluster when you create a new cluster
// (the `Folder.CreateClusterEx` method) or when you
// reconfigure an existing cluster
// (the `ComputeResource.ReconfigureComputeResource_Task` method).
//
// All fields are optional. If you set the <code>modify</code>
// parameter to <code>true</code> when you call
// `ComputeResource.ReconfigureComputeResource_Task`, an unset property has no effect
// on the existing property value in the cluster configuration on the Server.
// If you set the <code>modify</code> parameter to <code>false</code> when you
// reconfigure a cluster, the cluster configuration is reverted to the default
// values, then the new configuration values are applied.
//
// Use the properties defined for this object to configure
// the following services:
//
//   - HA (High Availability) -
//     provides failover protection for virtual machines
//     running in a cluster of ESX Server hosts.
//     The virtual machines are located in a `Datastore`, which
//     provides shared storage for the cluster.
//     When a failure occurs that affects a protected virtual machine,
//     HA will restart the virtual machine on another host.
//     When HA detects a host failure, either the host has failed or it may be
//     isolated from the network. The HA agent on an isolated host will power off
//     or shutdown the virtual machines running on that host so that they
//     can be restarted elsewhere.
//     See `ClusterDasVmSettingsIsolationResponse_enum` for information
//     about how a host handles network isolation.
//
//     When it chooses a failover host, HA selects a host that is compatible
//     with the virtual machine and that can support resource allocation for
//     that virtual machine so that service level guarantees remain intact.
//     HA does not consider hosts that are in maintenance mode, standby mode,
//     or which are disconnected from the vCenter Server. When a host powers
//     on or becomes available again, HA is reenabled on that host,
//     so it becomes available for failover again.
//     VMware recommends that you configure hosts and virtual machines
//     so that all virtual machines can run on all hosts in the cluster.
//     This will maximize the chances of restarting a VM after a failure.
//
//     HA also restarts a virtual machine after a guest operating system failure.
//     In this case, the virtual machine health monitoring service detects
//     the guest failure, and HA restarts the virtual machine on the same host.
//     The service monitors heartbeats from the VmTools service and optionally
//     heartbeats that are generated by a third-party application monitor.
//     See `ClusterVmToolsMonitoringSettings` and
//     `ClusterDasConfigInfo*.*ClusterDasConfigInfo.vmMonitoring`.
//
//     To enable HA for a cluster, set the
//     `ClusterDasConfigInfo*.*ClusterDasConfigInfo.enabled`
//     property to <code>true</code> and the
//     `ClusterDasConfigInfo*.*ClusterDasConfigInfo.hostMonitoring`
//     property to `enabled`.
//     (The vSphere API uses the substring "das" in object, property,
//     and method names for HA.<sup>1</sup>)
//
//   - DRS (Distributed Resource Scheduling) - provides automatic initial
//     virtual machine placement on any of the hosts in the cluster. DRS
//     also makes automatic resource relocation and optimization decisions
//     as hosts or virtual machines are added or removed from the cluster.
//     You can also configure DRS for manual control, so that it only makes
//     recommendations that you can review and carry out.
//
//     To enable DRS for a cluster, set the
//     `ClusterDrsConfigInfo*.*ClusterDrsConfigInfo.enabled`
//     property to <code>true</code>.
//
//   - DPM (Distributed Power Management) - supports optimized power
//     consumption on the cluster. When virtual machines in a DRS
//     cluster require fewer resources, DPM consolidates workloads
//     onto fewer servers while maintaining quality of service guarantees
//     and powers off the rest to reduce power consumption.
//     When more resources are required, DPM brings the powered-down hosts online.
//
//     To enable DPM for a cluster, set the
//     `ClusterDpmConfigInfo*.*ClusterDpmConfigInfo.enabled`
//     property to <code>true</code>.
//
//   - VSAN - aggregrates hosts' local disks to present a single
//     shared datastore to the cluster.
//
//     To enable VSAN for a cluster, set the
//     `VsanClusterConfigInfo.enabled` property to
//     <code>true</code> for `ClusterConfigSpecEx.vsanConfig`.
//
//   - InfraUpdateHA (Infrastructure update HA) - supports automatic
//     migration of virtual machines to hosts with low risk of a
//     catastrophic failure. Similar to DRS, you can also configure
//     InfraUpdateHA for manual control to only makes recommendations that
//     you can review and carry out. The health state of the hosts are
//     propagated to HA to enable restarting of virtual machines in healthy
//     hosts as possible.
//
//     To enable InfraUpdateHA for a cluster, set the
//     `ClusterInfraUpdateHaConfigInfo*.*ClusterInfraUpdateHaConfigInfo.enabled` property to
//     <code>true</code>.
//
//   - ProactiveDRS (Proactive Distributed Resources Scheduling) - supports
//     virtual machine load balancing decisions that take predicted
//     resource demand information into account.
//
//     To enable ProactiveDRS for a cluster, set the
//     `ClusterProactiveDrsConfigInfo*.*ClusterProactiveDrsConfigInfo.enabled` property to
//     <code>true</code>.
//
// The HA, DRS, and DPM services are integrated with the FT (Fault Tolerance)
// and EVC (Enhanced vMotion Compatibility) services.
// Use the `VirtualMachine.CreateSecondaryVM_Task` method to establish
// fault tolerance for a virtual machine. Use the vSphere Client to configure EVC.
// The HA, DRS, DPM, FT, and EVC services interact under
// the following circumstances.
//
//   - To determine initial placement of a virtual machine, DRS
//     checks to see if the HA admission control policy on a
//     potential host supports the addition of the powered on
//     virtual machine. With the default setting, DRS will not
//     power on more than four FT virtual machines per host.
//     You can use the configuration editor in the vSphere Client
//     to set the HA advanced option <code>das.maxFtVmsPerHost</code>
//     to the desired number or to zero to disable.
//
//   - When a host fails, HA determines placement within
//     the cluster when it restarts the virtual machines.
//     If there is insufficient capacity, and DPM has put one or more
//     compatible hosts into standby, HA relies on DPM to bring more
//     capacity online.
//
//   - To use FT in a cluster, the cluster must be HA-enabled.
//
//   - You can disable HA in a cluster while there are FT virtual
//     machines registered on hosts in the cluster.
//     While HA is disabled, powered on FT virtual machines will continue
//     to run, but HA will not restart any virtual machines after a failure.
//     When HA is disabled, you cannot use the following FT operations:
//
//   - Turn on FT (`VirtualMachine.CreateSecondaryVM_Task`)
//
//   - Enable FT (`VirtualMachine.EnableSecondaryVM_Task`)
//
//   - Power on an FT virtual machine
//     (`VirtualMachine.PowerOnVM_Task`)
//
//   - Test failover and test secondary restart
//     (`VirtualMachine.TerminateFaultTolerantVM_Task`)
//
//   - In a cluster using DRS and HA with admission control turned on
//     (`ClusterDasConfigInfo*.*ClusterDasConfigInfo.admissionControlEnabled`),
//     the vCenter Server might not migrate virtual machines from hosts
//     entering maintenance mode. This is because resources are reserved
//     to maintain the failover level. You must use vMotion to manually
//     migrate the virtual machines off the hosts.
//
//     When admission control is disabled, failover resource constraints
//     are not passed on to DRS and DPM. The constraints are not enforced.
//
//   - DRS determines virtual machine placement and status
//     (maintenance mode, standby mode) regardless of the impact
//     this might have on failover requirements.
//
//   - DPM powers off hosts (places them in standby mode)
//     even if doing so violates failover requirements.
//     If there is insufficient capacity when a failover
//     occurs, DPM will attempt to bring more capacity online
//     in order to correct the situation.
//
//   - You must enable EVC in a cluster to enable DRS to manage FT primary
//     and secondary virtual machine pairs in the cluster.
//     For information about EVC clusters, see `EVCMode`.
//
//     If EVC is disabled, vCenter automatically creates overrides
//     to disable DRS for FT primary/secondary pairs in the cluster.
//     vCenter will still use DRS to place a secondary virtual machine
//     when it powers on.
//     Attempts to remove the overrides or to enable DRS operations
//     will fail.
//
//   - EVC clusters support load balancing of powered on FT primary
//     and secondary virtual machines. DRS behavior
//     is governed by the overrides defined for the primary virtual
//     machine. The secondary inherits DRS behavior from its primary.
//     If you do not configure a DRS override for an FT virtual
//     machine, DRS uses the cluster default
//     (`ClusterDrsConfigInfo.defaultVmBehavior`).
//
// <sup>1</sup>High Availability was previously called Distributed
// Availability Services.
type ClusterConfigSpecEx struct {
	ComputeResourceConfigSpec

	// Configuration for vCLS system VMs deployment.
	SystemVMsConfig *ClusterSystemVMsConfigSpec `xml:"systemVMsConfig,omitempty" json:"systemVMsConfig,omitempty" vim:"7.0.3.0"`
	// HA configuration; includes default settings for virtual machines.
	DasConfig *ClusterDasConfigInfo `xml:"dasConfig,omitempty" json:"dasConfig,omitempty"`
	// HA configuration for individual virtual machines.
	//
	// The entries in this array override the cluster default
	// settings
	// (`ClusterDasConfigInfo*.*ClusterDasConfigInfo.defaultVmSettings`).
	// You cannot specify an HA override for a secondary FT virtual
	// machine. The secondary virtual machine will inherit whatever
	// settings apply to its primary virtual machine. If you
	// include an entry for a secondary, the reconfigure method
	// will throw the fault
	// `CannotChangeHaSettingsForFtSecondary`.
	DasVmConfigSpec []ClusterDasVmConfigSpec `xml:"dasVmConfigSpec,omitempty" json:"dasVmConfigSpec,omitempty"`
	// DRS configuration; includes default settings for virtual machines.
	DrsConfig *ClusterDrsConfigInfo `xml:"drsConfig,omitempty" json:"drsConfig,omitempty"`
	// DRS configuration for individual virtual machines.
	//
	// The entries in this array override the cluster default
	// settings
	// (`ClusterDrsConfigInfo*.*ClusterDrsConfigInfo.defaultVmBehavior`).
	// You cannot specify a DRS override for a secondary FT virtual
	// machine. The secondary virtual machine will inherit whatever
	// setting applies to its primary virtual machine. If you
	// include an entry for a secondary, the reconfigure method
	// will throw the fault
	// `CannotChangeDrsBehaviorForFtSecondary`.
	DrsVmConfigSpec []ClusterDrsVmConfigSpec `xml:"drsVmConfigSpec,omitempty" json:"drsVmConfigSpec,omitempty"`
	// Cluster affinity and anti-affinity rule configuration.
	RulesSpec []ClusterRuleSpec `xml:"rulesSpec,omitempty" json:"rulesSpec,omitempty"`
	// Cluster configuration of VM orchestration.
	Orchestration *ClusterOrchestrationInfo `xml:"orchestration,omitempty" json:"orchestration,omitempty"`
	// List of specific VM configurations that apply during cluster wide
	// VM orchestration.
	//
	// Each entry applies to one virtual machine, and
	// overrides the cluster default settings.
	VmOrchestrationSpec []ClusterVmOrchestrationSpec `xml:"vmOrchestrationSpec,omitempty" json:"vmOrchestrationSpec,omitempty"`
	// DPM configuration; includes default settings for hosts.
	DpmConfig *ClusterDpmConfigInfo `xml:"dpmConfig,omitempty" json:"dpmConfig,omitempty"`
	// DPM configuration for individual hosts.
	//
	// The entries in this array override the cluster default
	// settings
	// (`ClusterDpmConfigInfo*.*ClusterDpmConfigInfo.defaultDpmBehavior`).
	DpmHostConfigSpec []ClusterDpmHostConfigSpec `xml:"dpmHostConfigSpec,omitempty" json:"dpmHostConfigSpec,omitempty"`
	// VSAN configuration; includes default settings for hosts.
	//
	// When it is requested to change, vSAN related sub tasks will be
	// generated automatically per member hosts, which are identified
	// by using cluster reconfiguration task id as
	// `TaskInfo.parentTaskKey`, and should be monitored
	// and tracked separatedly.
	VsanConfig *VsanClusterConfigInfo `xml:"vsanConfig,omitempty" json:"vsanConfig,omitempty"`
	// VSAN configuration for individual hosts.
	//
	// The entries in this array override the cluster default settings
	// as specified in `VsanClusterConfigInfo`.
	VsanHostConfigSpec []VsanHostConfigInfo `xml:"vsanHostConfigSpec,omitempty" json:"vsanHostConfigSpec,omitempty"`
	// Cluster-wide group configuration.
	//
	// The array contains one or more group specification objects.
	// A group specification object contains a virtual machine group
	// (`ClusterVmGroup`) or a host group (`ClusterHostGroup`).
	// Groups can be related; see `ClusterVmHostRuleInfo`.
	GroupSpec []ClusterGroupSpec `xml:"groupSpec,omitempty" json:"groupSpec,omitempty"`
	// InfraUpdateHA configuration.
	InfraUpdateHaConfig *ClusterInfraUpdateHaConfigInfo `xml:"infraUpdateHaConfig,omitempty" json:"infraUpdateHaConfig,omitempty"`
	// ProactiveDrs configuration.
	ProactiveDrsConfig *ClusterProactiveDrsConfigInfo `xml:"proactiveDrsConfig,omitempty" json:"proactiveDrsConfig,omitempty"`
	// Flag to place the cluster in the HCI workflow during cluster creation.
	//
	// This flag is specified only at the time of cluster creation.
	// A cluster cannot be reconfigured to place it in the HCI workflow.
	InHciWorkflow *bool `xml:"inHciWorkflow" json:"inHciWorkflow,omitempty"`
	// Cluster-wide configuration of encryption mode.
	CryptoConfig *ClusterCryptoConfigInfo `xml:"cryptoConfig,omitempty" json:"cryptoConfig,omitempty"`
}

func init() {
	t["ClusterConfigSpecEx"] = reflect.TypeOf((*ClusterConfigSpecEx)(nil)).Elem()
}

// This event records when a cluster is created.
type ClusterCreatedEvent struct {
	ClusterEvent

	// The folder where the cluster is created.
	Parent FolderEventArgument `xml:"parent" json:"parent"`
}

func init() {
	t["ClusterCreatedEvent"] = reflect.TypeOf((*ClusterCreatedEvent)(nil)).Elem()
}

type ClusterCryptoConfigInfo struct {
	DynamicData

	// The cluster encryption mode.
	//
	// See `ClusterCryptoConfigInfoCryptoMode_enum` for supported values.
	CryptoMode string `xml:"cryptoMode,omitempty" json:"cryptoMode,omitempty"`
	// The encryption mode policy for the cluster.
	//
	// When unset, host keys will be automatically generated using the current
	// default key provider.
	Policy *ClusterComputeResourceCryptoModePolicy `xml:"policy,omitempty" json:"policy,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["ClusterCryptoConfigInfo"] = reflect.TypeOf((*ClusterCryptoConfigInfo)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, this object is no longer returned by
// vCenter Server. Availability information is now reported using
// `HostRuntimeInfo.dasHostState`.
//
// The `ClusterDasAamHostInfo` object contains a list of the ESX hosts
// in an HA cluster and a list that identifies the _primary_ hosts.
//
// (AAM is a component of the HA service.)
// The primary hosts share the joint responsibility of maintaining all cluster
// state and one will initiate failover actions should a failure occur.
//
// When you add an ESX host to a vSphere HA cluster, the host
// downloads HA agent components from the vCenter Server.
// The HA agent maintains communication with the vCenter Server.
//
// When the host downloads the HA agent, the host configures the agent
// to communicate with other agents in the cluster. A host that joins
// the cluster communicates with an existing primary host to complete
// its configuration (except when you are adding the first host to the cluster).
//   - The first five hosts added to the cluster are designated
//     as primary hosts. All subsequent hosts are designated as secondary hosts.
//   - If a primary host is removed from the cluster,
//     the vCenter Server promotes another host to primary status.
//   - There must be at least one functional primary host for vSphere HA
//     to operate correctly. If there is not an available primary host
//     (no response), host configuration for HA will fail.
//     If there is a total cluster failure, HA will begin restarting virtual
//     machines as soon as one host recovers and its HA agent is up and running.
//
// One of the primary hosts assumes the role of the active primary host.
// The active primary host responsibilities include the following activities:
//   - Decides where to restart virtual machines.
//   - Tracks failed restart attempts.
//   - Determines when it is appropriate to continue attempts to restart
//     a virtual machine.
//
// If the active primary host fails, another primary host replaces it.
type ClusterDasAamHostInfo struct {
	ClusterDasHostInfo

	// The state of HA on the hosts.
	HostDasState []ClusterDasAamNodeState `xml:"hostDasState,omitempty" json:"hostDasState,omitempty"`
	// The list of primary hosts.
	PrimaryHosts []string `xml:"primaryHosts,omitempty" json:"primaryHosts,omitempty"`
}

func init() {
	t["ClusterDasAamHostInfo"] = reflect.TypeOf((*ClusterDasAamHostInfo)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, this object is no longer returned by
// vCenter Server. See `HostRuntimeInfo.dasHostState` for a
// description of the objects now used.
//
// The `ClusterDasAamNodeState` data object represents the state
// of the HA service on an ESX host.
//
// (AAM is a component of this service.)
type ClusterDasAamNodeState struct {
	DynamicData

	// Reference to the host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Name of the host
	// (`HostSystem*.*ManagedEntity.name`).
	Name string `xml:"name" json:"name"`
	// Configuration state of the HA agent on the host.
	//
	// The property can be one of the following values:
	//
	// configuring
	// error
	// unconfiguring
	// running
	//
	// <code>configState</code> represents setting or resetting the HA
	// configuration on the host. If the configuration operation is
	// successful, the value of <code>configState</code> changes
	// to <code>running</code>. See `ClusterDasAamNodeStateDasState_enum`.
	ConfigState string `xml:"configState" json:"configState"`
	// The runtime state of the HA agent on the node.
	//
	// The property can be one of the following values:
	//
	// uninitialized
	// initialized
	// running
	// error
	// agentShutdown
	// nodeFailed
	//
	// See `ClusterDasAamNodeStateDasState_enum`.
	RuntimeState string `xml:"runtimeState" json:"runtimeState"`
}

func init() {
	t["ClusterDasAamNodeState"] = reflect.TypeOf((*ClusterDasAamNodeState)(nil)).Elem()
}

// Base class for admission control related information of a vSphere HA cluster.
type ClusterDasAdmissionControlInfo struct {
	DynamicData
}

func init() {
	t["ClusterDasAdmissionControlInfo"] = reflect.TypeOf((*ClusterDasAdmissionControlInfo)(nil)).Elem()
}

// Base class for specifying how admission control should be done for vSphere HA.
type ClusterDasAdmissionControlPolicy struct {
	DynamicData

	// Percentage of resource reduction that a cluster of VMs can tolerate
	// in case of a failover.
	ResourceReductionToToleratePercent *int32 `xml:"resourceReductionToToleratePercent" json:"resourceReductionToToleratePercent,omitempty"`
	// Flag that determines whether strict admission control for persistent
	// memory is enabled.
	//
	// By default, this value is false.
	// This flag can only be set to true if
	// `ClusterDasConfigInfo.admissionControlEnabled` is set to true.
	// When you use persistent memory admission control, the following
	// operations are prevented, if doing so would violate the
	// `ClusterDasConfigInfo.admissionControlEnabled`.
	//   - Creating a virtual machine with persistent memory.
	//   - Adding a virtual persistent memory device to a virtual machine.
	//   - Increasing the capacity of a virtual persistent memory device.
	PMemAdmissionControlEnabled *bool `xml:"pMemAdmissionControlEnabled" json:"pMemAdmissionControlEnabled,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["ClusterDasAdmissionControlPolicy"] = reflect.TypeOf((*ClusterDasAdmissionControlPolicy)(nil)).Elem()
}

// Base class for advanced runtime information related to the high
// availability service for a cluster.
type ClusterDasAdvancedRuntimeInfo struct {
	DynamicData

	// The information pertaining to the HA agents on the hosts
	DasHostInfo BaseClusterDasHostInfo `xml:"dasHostInfo,omitempty,typeattr" json:"dasHostInfo,omitempty"`
	// Whether HA VM Component Protection can be enabled for the cluster.
	VmcpSupported *ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo `xml:"vmcpSupported,omitempty" json:"vmcpSupported,omitempty"`
	// The map of a datastore to the set of hosts that are using
	// the datastore for storage heartbeating.
	HeartbeatDatastoreInfo []DasHeartbeatDatastoreInfo `xml:"heartbeatDatastoreInfo,omitempty" json:"heartbeatDatastoreInfo,omitempty"`
}

func init() {
	t["ClusterDasAdvancedRuntimeInfo"] = reflect.TypeOf((*ClusterDasAdvancedRuntimeInfo)(nil)).Elem()
}

// Class for capability to support VM Component Protection
type ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo struct {
	DynamicData

	// If all hosts in the cluster support the reaction of VM Component Protection
	// to storage All Paths Down timeout
	// (@link vim.host.MountInfo.InaccessibleReason#AllPathsDown\_Timeout}
	StorageAPDSupported bool `xml:"storageAPDSupported" json:"storageAPDSupported"`
	// If all hosts in the cluster support the reaction of VM Component Protection
	// to storage Permanent Device Loss
	// (@link vim.host.MountInfo.InaccessibleReason#PermanentDeviceLoss}
	StoragePDLSupported bool `xml:"storagePDLSupported" json:"storagePDLSupported"`
}

func init() {
	t["ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo"] = reflect.TypeOf((*ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo)(nil)).Elem()
}

// The `ClusterDasConfigInfo` data object contains configuration data
// about the HA service on a cluster.
//
// All fields are optional. If you set the <code>modify</code>
// parameter to <code>true</code> when you call
// `ComputeResource.ReconfigureComputeResource_Task`, an unset property has no effect
// on the existing property value in the cluster configuration on the Server.
// If you set the <code>modify</code> parameter to <code>false</code> when you
// reconfigure a cluster, the cluster configuration is reverted to the default
// values, then the new configuration values are applied.
type ClusterDasConfigInfo struct {
	DynamicData

	// Flag to indicate whether or not vSphere HA feature is enabled.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Level of HA Virtual Machine Health Monitoring Service.
	//
	// You can monitor both guest and application heartbeats, guest heartbeats only,
	// or you can disable the service. See `ClusterDasConfigInfoVmMonitoringState_enum`.
	// The default value is `vmMonitoringDisabled`.
	//
	// The Service level specified for the cluster determines
	// the possible monitoring settings that you can use for individual virtual machines.
	// See `ClusterVmToolsMonitoringSettings*.*ClusterVmToolsMonitoringSettings.vmMonitoring`.
	VmMonitoring string `xml:"vmMonitoring,omitempty" json:"vmMonitoring,omitempty"`
	// Determines whether HA restarts virtual machines after a host fails.
	//
	// The default value is
	// `ClusterDasConfigInfoServiceState_enum*.*enabled`.
	// This property is meaningful only when
	// `ClusterDasConfigInfo*.*ClusterDasConfigInfo.enabled` is <code>true</code>.
	//
	// When <code>hostMonitoring</code> is
	// `enabled`, HA restarts virtual machines
	// after a host fails.
	//
	// When <code>hostMonitoring</code> is
	// `disabled`, HA does not restart
	// virtual machines after a host fails.
	// The status of Host Monitoring does not affect other services such
	// as virtual machine Health Monitoring or Fault Tolerance.
	// The rest of the cluster operations follow normal processing.
	// No configuration information is lost and re-enabling the service
	// is a quick operation.
	HostMonitoring string `xml:"hostMonitoring,omitempty" json:"hostMonitoring,omitempty"`
	// This property indicates if vSphere HA VM Component Protection service
	// is enabled.
	//
	// The default value is `disabled`.
	//
	// When <code>vmComponentProtecting</code> is set to
	// `disabled`, reaction to all types of VM
	// component failures is disabled.
	//
	// When <code>vmComponentProtecting</code> is set to
	// `enabled`, VM Component Protection service
	// will detect and react to component failures. The actual reaction is determined
	// by `ClusterVmComponentProtectionSettings` which is referenced by both cluster
	// level configuration (`ClusterDasConfigInfo.defaultVmSettings`) and per-VM
	// override `ClusterConfigInfoEx.dasVmConfig`.
	VmComponentProtecting string `xml:"vmComponentProtecting,omitempty" json:"vmComponentProtecting,omitempty"`
	// Deprecated as of vSphere API 4.0, use
	// `ClusterFailoverLevelAdmissionControlPolicy` to set
	// `ClusterDasConfigInfo.admissionControlPolicy`.
	//
	// Configured failover level.
	//
	// This is the number of physical host failures
	// that can be tolerated without impacting the ability to satisfy the
	// minimums for all running virtual machines. Acceptable values range from one to
	// four.
	FailoverLevel int32 `xml:"failoverLevel,omitempty" json:"failoverLevel,omitempty"`
	// Virtual machine admission control policy for vSphere HA.
	//
	// The policies specify resource availability for failover support.
	//   - Failover host admission policy
	//     `ClusterFailoverHostAdmissionControlPolicy` -
	//     specify one or more dedicated failover hosts.
	//   - Failover level policy
	//     `ClusterFailoverLevelAdmissionControlPolicy` -
	//     the limit of host failures for which resources are reserved.
	//     When you use the failover level policy,
	//     HA partitions resources into slots. A slot represents the minimum
	//     CPU and memory resources that are required to support
	//     any powered on virtual machine in the cluster.
	//     To retrieve information about partitioned resources, use the
	//     `ClusterComputeResource.RetrieveDasAdvancedRuntimeInfo`
	//     method.
	//   - Resources admission policy
	//     `ClusterFailoverResourcesAdmissionControlPolicy` -
	//     CPU and memory resources reserved for failover support.
	//     When you use the resources policy, you can reserve
	//     a percentage of the aggregate cluster resource for failover.
	AdmissionControlPolicy BaseClusterDasAdmissionControlPolicy `xml:"admissionControlPolicy,omitempty,typeattr" json:"admissionControlPolicy,omitempty"`
	// Flag that determines whether strict admission control is enabled.
	//
	// When you use admission control, the following operations are
	// prevented, if doing so would violate the `ClusterDasConfigInfo.admissionControlPolicy`.
	//   - Powering on a virtual machine in the cluster.
	//   - Migrating a virtual machine into the cluster.
	//   - Increasing the CPU or memory reservation of powered-on
	//     virtual machines in the cluster.
	//
	// With admission control disabled, there is no assurance that
	// all virtual machines in the HA cluster can be restarted after
	// a host failure. VMware recommends that you do not disable
	// admission control, but you might need to do so temporarily,
	// for the following reasons:
	//   - If you need to violate the failover constraints when there
	//     are not enough resources to support them (for example,
	//     if you are placing hosts in standby mode to test them
	//     for use with DPM).
	//   - If an automated process needs to take actions that might
	//     temporarily violate the failover constraints (for example,
	//     as part of an upgrade directed by VMware Update Manager).
	//   - If you need to perform testing or maintenance operations.
	AdmissionControlEnabled *bool `xml:"admissionControlEnabled" json:"admissionControlEnabled,omitempty"`
	// Cluster-wide defaults for virtual machine HA settings.
	//
	// When a virtual machine has no HA configuration
	// (`ClusterDasVmConfigSpec`), it uses the values
	// specified here.
	DefaultVmSettings *ClusterDasVmSettings `xml:"defaultVmSettings,omitempty" json:"defaultVmSettings,omitempty"`
	// Advanced settings.
	Option []BaseOptionValue `xml:"option,omitempty,typeattr" json:"option,omitempty"`
	// The list of preferred datastores to use for storage heartbeating.
	//
	// Each of the specified datastores should be active and mounted
	// by more than one host. There is no limit on the number of specified
	// datastores and no priority among them.
	// The specified datastores will replace those previously specified and
	// an empty list will delete all such earlier specified ones.
	//
	// vCenter Server chooses the heartbeat datastores for a host from the
	// set specified by `ClusterDasConfigInfo.hBDatastoreCandidatePolicy`.
	// The choice is made based on datastore connectivity and storage array
	// redundancy (in case of VMFS).
	//
	// The final set of selected heartbeat datastores is reported via
	// `ClusterDasAdvancedRuntimeInfo.heartbeatDatastoreInfo`.
	//
	// Refers instances of `Datastore`.
	HeartbeatDatastore []ManagedObjectReference `xml:"heartbeatDatastore,omitempty" json:"heartbeatDatastore,omitempty"`
	// The policy on what datastores will be used by vCenter Server to choose
	// heartbeat datastores.
	//
	// See `ClusterDasConfigInfoHBDatastoreCandidate_enum` for all options.
	// The default value is
	// `allFeasibleDsWithUserPreference`.
	HBDatastoreCandidatePolicy string `xml:"hBDatastoreCandidatePolicy,omitempty" json:"hBDatastoreCandidatePolicy,omitempty"`
}

func init() {
	t["ClusterDasConfigInfo"] = reflect.TypeOf((*ClusterDasConfigInfo)(nil)).Elem()
}

// Base class for DAS data for high availability service for a cluster.
type ClusterDasData struct {
	DynamicData
}

func init() {
	t["ClusterDasData"] = reflect.TypeOf((*ClusterDasData)(nil)).Elem()
}

// This class contains the summary of the data that DAS needs/uses.
//
// The actual data is available in `ClusterDasDataDetails` and can be retrieved
// using the `ClusterComputeResource.RetrieveDasData` method.
// This class is meant for VMware internal use only.
type ClusterDasDataSummary struct {
	ClusterDasData

	// The version corresponding to the hostList
	HostListVersion int64 `xml:"hostListVersion" json:"hostListVersion"`
	// The version corresponding to the clusterConfig
	ClusterConfigVersion int64 `xml:"clusterConfigVersion" json:"clusterConfigVersion"`
	// The version corresponding to the compatList
	CompatListVersion int64 `xml:"compatListVersion" json:"compatListVersion"`
}

func init() {
	t["ClusterDasDataSummary"] = reflect.TypeOf((*ClusterDasDataSummary)(nil)).Elem()
}

// Advanced runtime information related to the high availability service
// for a cluster that has been configured with a failover level admission control
// policy.
//
// See `ClusterFailoverLevelAdmissionControlPolicy`.
type ClusterDasFailoverLevelAdvancedRuntimeInfo struct {
	ClusterDasAdvancedRuntimeInfo

	// Slot information for this cluster.
	SlotInfo ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo `xml:"slotInfo" json:"slotInfo"`
	// The total number of slots available in the cluster.
	//
	// See also `ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo`.
	TotalSlots int32 `xml:"totalSlots" json:"totalSlots"`
	// The number of slots currently being used.
	//
	// See also `ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo`.
	UsedSlots int32 `xml:"usedSlots" json:"usedSlots"`
	// The number of slots that are not used by currently powered on virtual machines
	// and not reserved to satisfy the configured failover level.
	//
	// This number gives
	// an indication of how many additional virtual machines can be powered on in
	// this cluster without violating the failover level (assuming the new virtual
	// machine's reservations are satisfied by the current slot size).
	// This value is computed as follows (where m is the configured failover level):
	// Remove the m largest hosts (ie. the ones with the most slots) from the list
	// of "good" hosts (see `ClusterDasFailoverLevelAdvancedRuntimeInfo.totalGoodHosts`). Sum up the number of slots on
	// the remaining hosts and deduct the number of currently used slots
	// (see `ClusterDasFailoverLevelAdvancedRuntimeInfo.usedSlots`). If this number is negative, use zero instead.
	//
	// See also `ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo`.
	UnreservedSlots int32 `xml:"unreservedSlots" json:"unreservedSlots"`
	// The total number of powered on vms in the cluster.
	TotalVms int32 `xml:"totalVms" json:"totalVms"`
	// The total number of hosts in the cluster.
	TotalHosts int32 `xml:"totalHosts" json:"totalHosts"`
	// The total number of connected hosts that are not in maintance mode and that
	// do not have any DAS-related config issues on them.
	TotalGoodHosts int32                                                 `xml:"totalGoodHosts" json:"totalGoodHosts"`
	HostSlots      []ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots `xml:"hostSlots,omitempty" json:"hostSlots,omitempty"`
	// The list of virtual machines whose reservations and memory overhead are not
	// satisfied by a single slot.
	VmsRequiringMultipleSlots []ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots `xml:"vmsRequiringMultipleSlots,omitempty" json:"vmsRequiringMultipleSlots,omitempty"`
}

func init() {
	t["ClusterDasFailoverLevelAdvancedRuntimeInfo"] = reflect.TypeOf((*ClusterDasFailoverLevelAdvancedRuntimeInfo)(nil)).Elem()
}

type ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots struct {
	DynamicData

	// The reference to the host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The number of slots in this host.
	Slots int32 `xml:"slots" json:"slots"`
}

func init() {
	t["ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots"] = reflect.TypeOf((*ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots)(nil)).Elem()
}

// A slot represents an amount of memory and cpu resources on a physical host for use
// by a virtual machine.
//
// It is used in computing the resources to be reserved for
// failover.
type ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo struct {
	DynamicData

	// Deprecated as of vSphere API 5.0, the number of vcpus is no longer used
	// for slot calculations.
	//
	// The number of virtual cpus of a slot is defined as the maximum number of
	// virtual cpus any powered on virtual machine has.
	NumVcpus int32 `xml:"numVcpus" json:"numVcpus"`
	// The cpu speed of a slot is defined as the maximum cpu reservation of any
	// powered on virtual machine in the cluster, or any otherwise defined minimum,
	// whichever is larger.
	CpuMHz int32 `xml:"cpuMHz" json:"cpuMHz"`
	// The memory size of a slot is defined as the maximum memory reservation plus
	// memory overhead of any powered on virtual machine in the cluster, or any
	// otherwise defined minimum, whichever is larger.
	MemoryMB int32 `xml:"memoryMB" json:"memoryMB"`
}

func init() {
	t["ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo"] = reflect.TypeOf((*ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo)(nil)).Elem()
}

type ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots struct {
	DynamicData

	// The reference to the virtual machine
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The number of slots required by this virtual machine
	Slots int32 `xml:"slots" json:"slots"`
}

func init() {
	t["ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots"] = reflect.TypeOf((*ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots)(nil)).Elem()
}

// The `ClusterDasFdmHostState` data object
// describes the availability state of each active host in a
// vSphere HA enabled cluster.
//
// In a vSphere HA cluster, the active hosts form a fault domain.
// A host is inactive if it is in standby or maintenance mode, or
// it has been disconnected from vCenter Server. A vSphere HA
// agent, called the Fault Domain Manager (FDM), runs on each host in the
// fault domain.
//
// One FDM serves as the master and the remaining FDMs as its slaves.
// The master is responsible for monitoring the availability of the hosts
// and VMs in the cluster, and restarting any VMs that fail due to a
// host failure or non-user-initiated power offs. The master is also
// responsible for reporting fault-domain state to vCenter Server.
//
// The master FDM is determined through election by the FDMs that are
// alive at the time. An election occurs in the following circumstances:
//   - When the vSphere HA feature is enabled for the cluster.
//   - When the master's host fails.
//   - When the management network is partitioned. In a network partition
//     there will be a master for each partition. However, only one master
//     will be responsible for a given VM. When the partition is
//     resolved, all but one of the masters will abdicate.
//   - After a host in a vSphere HA cluster powers back up following a failure
//     that caused all hosts in the cluster to power off.
//
// The slaves are responsible for reporting state updates to the master and
// restarting VMs as required. All FDMs provide the VM/Application Health
// Monitoring Service.
type ClusterDasFdmHostState struct {
	DynamicData

	// The Availability State of a host based on information
	// reported by the entity given by the
	// `ClusterDasFdmHostState.stateReporter` property.
	//
	// See
	// `ClusterDasFdmAvailabilityState_enum` for the set of
	// states.
	State string `xml:"state" json:"state"`
	// The entity reporting the state of the host.
	//
	// If the reporter is a host,
	// the property reports which host, whereas if the reporter is vCenter Server,
	// the property is unset.
	//
	// Refers instance of `HostSystem`.
	StateReporter *ManagedObjectReference `xml:"stateReporter,omitempty" json:"stateReporter,omitempty"`
}

func init() {
	t["ClusterDasFdmHostState"] = reflect.TypeOf((*ClusterDasFdmHostState)(nil)).Elem()
}

// HA specific advanced information pertaining to the hosts in the cluster.
type ClusterDasHostInfo struct {
	DynamicData
}

func init() {
	t["ClusterDasHostInfo"] = reflect.TypeOf((*ClusterDasHostInfo)(nil)).Elem()
}

// A host recommendation for a virtual machine managed by the VMware
// HA Service.
type ClusterDasHostRecommendation struct {
	DynamicData

	// The recommended host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Rating as computed by DRS for a DRS-enabled cluster.
	//
	// Rating
	// range from 1 to 5, and the higher the rating, the stronger DRS
	// suggests this host is picked for the operation.
	DrsRating int32 `xml:"drsRating,omitempty" json:"drsRating,omitempty"`
}

func init() {
	t["ClusterDasHostRecommendation"] = reflect.TypeOf((*ClusterDasHostRecommendation)(nil)).Elem()
}

// The `ClusterDasVmConfigInfo` data object contains
// the HA configuration for a single virtual machine.
//
// All fields are optional. If you set the <code>modify</code>
// parameter to <code>true</code> when you call
// `ComputeResource.ReconfigureComputeResource_Task`, an unset property has no effect
// on the existing property value in the cluster configuration on the Server.
// If you set the <code>modify</code> parameter to <code>false</code> when you
// reconfigure a cluster, the cluster configuration is reverted to the default
// values, then the new configuration values are applied.
type ClusterDasVmConfigInfo struct {
	DynamicData

	// Reference to the virtual machine.
	//
	// Refers instance of `VirtualMachine`.
	Key ManagedObjectReference `xml:"key" json:"key"`
	// Deprecated as of VI API 2.5, use
	// `ClusterDasVmConfigInfo.dasSettings*.*ClusterDasVmSettings.restartPriority`.
	// If you specify `ClusterDasVmConfigInfo.restartPriority` here and in
	// `ClusterDasVmSettings`, the value in `ClusterDasVmSettings`
	// has precedence.
	//
	// Restart priority for a virtual machine.
	//
	// If there is nothing specified here, then the defaults are picked up from
	// `ClusterDasConfigInfo.defaultVmSettings`.
	RestartPriority DasVmPriority `xml:"restartPriority,omitempty" json:"restartPriority,omitempty"`
	// Deprecated as of VI API 2.5, use
	// `ClusterDasVmConfigInfo.dasSettings*.*ClusterDasVmSettings.isolationResponse`.
	// If you specify both `ClusterDasVmConfigInfo.powerOffOnIsolation` and
	// `ClusterDasVmSettings.isolationResponse`, the value in
	// `ClusterDasVmSettings.isolationResponse` has precedence.
	//
	// Flag to indicate whether or not the virtual machine should be powered off if a
	// host determines that it is isolated from the rest of the compute resource.
	//
	// If there is nothing specified here, then the defaults are picked up from
	// `ClusterDasConfigInfo.defaultVmSettings`.
	PowerOffOnIsolation *bool `xml:"powerOffOnIsolation" json:"powerOffOnIsolation,omitempty"`
	// HA settings that apply to this virtual machine.
	//
	// Values specified in this object override the cluster-wide
	// defaults for virtual machines (`ClusterDasConfigInfo.defaultVmSettings`).
	DasSettings *ClusterDasVmSettings `xml:"dasSettings,omitempty" json:"dasSettings,omitempty"`
}

func init() {
	t["ClusterDasVmConfigInfo"] = reflect.TypeOf((*ClusterDasVmConfigInfo)(nil)).Elem()
}

// An incremental update to the per-virtual-machine vSphere HA configuration.
type ClusterDasVmConfigSpec struct {
	ArrayUpdateSpec

	Info *ClusterDasVmConfigInfo `xml:"info,omitempty" json:"info,omitempty"`
}

func init() {
	t["ClusterDasVmConfigSpec"] = reflect.TypeOf((*ClusterDasVmConfigSpec)(nil)).Elem()
}

// The `ClusterDasVmSettings` data object contains the HA configuration
// settings specified for a single virtual machine (identified by
// `ClusterDasVmConfigInfo*.*ClusterDasVmConfigInfo.key`)
// or as cluster-wide defaults
// `ClusterDasConfigInfo*.*ClusterDasConfigInfo.defaultVmSettings`
//
// All fields are optional. If you set the <code>modify</code> parameter to
// <code>true</code> when you call `ComputeResource.ReconfigureComputeResource_Task`,
// an unset property has no effect on the existing property value in the
// cluster configuration on the Server. If you set the <code>modify</code>
// parameter to <code>false</code> when you reconfigure a cluster, the cluster
// configuration is reverted to the default values, then the new configuration
// values are applied.
type ClusterDasVmSettings struct {
	DynamicData

	// Restart priority for a virtual machine.
	//
	// If not specified at either the cluster level or
	// the virtual machine level, this will default to <code>medium</code>.
	//
	// See also `ClusterDasVmSettingsRestartPriority_enum`.
	RestartPriority string `xml:"restartPriority,omitempty" json:"restartPriority,omitempty"`
	// This setting is used to specify a maximum time the lower priority VMs
	// should wait for the higher priority VMs to be ready.
	//
	// If the higher
	// priority Vms are not ready by this time, then the lower priority VMs
	// are restarted irrespective of the VM ready state. This timeout can be
	// used to prevent the failover of lower priority VMs to be stuck
	// infinitely.
	//
	// This timeout is not used if ready condition is
	// `none`
	//
	// Timeout specified in seconds. To use cluster setting for a VM override,
	// set to -1 in per-VM.
	// setting.
	RestartPriorityTimeout int32 `xml:"restartPriorityTimeout,omitempty" json:"restartPriorityTimeout,omitempty"`
	// Indicates whether or not the virtual machine should be powered off if a
	// host determines that it is isolated from the rest of the compute
	// resource.
	//
	// If not specified at either the cluster level or
	// the virtual machine level, this will default to <code>powerOff</code>.
	//
	// See also `ClusterDasVmSettingsIsolationResponse_enum`.
	IsolationResponse string `xml:"isolationResponse,omitempty" json:"isolationResponse,omitempty"`
	// Configuration for the VM Health Monitoring Service.
	VmToolsMonitoringSettings *ClusterVmToolsMonitoringSettings `xml:"vmToolsMonitoringSettings,omitempty" json:"vmToolsMonitoringSettings,omitempty"`
	// Configuration for the VM Component Protection Service.
	VmComponentProtectionSettings *ClusterVmComponentProtectionSettings `xml:"vmComponentProtectionSettings,omitempty" json:"vmComponentProtectionSettings,omitempty"`
}

func init() {
	t["ClusterDasVmSettings"] = reflect.TypeOf((*ClusterDasVmSettings)(nil)).Elem()
}

// An incremental update to a Datastore list.
type ClusterDatastoreUpdateSpec struct {
	ArrayUpdateSpec

	// Refers instance of `Datastore`.
	Datastore *ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty"`
}

func init() {
	t["ClusterDatastoreUpdateSpec"] = reflect.TypeOf((*ClusterDatastoreUpdateSpec)(nil)).Elem()
	minAPIVersionForType["ClusterDatastoreUpdateSpec"] = "7.0.3.0"
}

// The `ClusterDependencyRuleInfo` data object indentifies VM-to-VM
// dependencies.
//
// A VM-VM Dependency rule identifies the following groups.
//   - A virtual machine group - `ClusterDependencyRuleInfo.vmGroup`
//   - A "depends on" virtual machine group - `ClusterDependencyRuleInfo.dependsOnVmGroup`.
//
// The VMs in `ClusterDependencyRuleInfo.vmGroup` depends on the list of VMs specified in `ClusterDependencyRuleInfo.dependsOnVmGroup`.
//
// For example, this rule is used during vSphere HA VM recovery
// orchestration. vSphere HA will not restart the VMs in `ClusterDependencyRuleInfo.vmGroup`
// until all the VMs in `ClusterDependencyRuleInfo.dependsOnVmGroup` are deemded "ready" (See
// `ClusterVmReadiness`).
//
// All the virtual machines referenced by this rule must be in
// the same cluster.
type ClusterDependencyRuleInfo struct {
	ClusterRuleInfo

	// Virtual group name.
	//
	// The virtual group may contain one or more virtual
	// machines.
	// `ClusterVmGroup*.*ClusterGroupInfo.name`
	VmGroup string `xml:"vmGroup" json:"vmGroup"`
	// Depdendency virtual group name
	// (`ClusterVmGroup*.*ClusterGroupInfo.name`).
	//
	// The virtual group may contain one or more virtual machines.
	DependsOnVmGroup string `xml:"dependsOnVmGroup" json:"dependsOnVmGroup"`
}

func init() {
	t["ClusterDependencyRuleInfo"] = reflect.TypeOf((*ClusterDependencyRuleInfo)(nil)).Elem()
}

// This event records when a cluster is destroyed.
type ClusterDestroyedEvent struct {
	ClusterEvent
}

func init() {
	t["ClusterDestroyedEvent"] = reflect.TypeOf((*ClusterDestroyedEvent)(nil)).Elem()
}

// Configuration of the VMware DPM service.
//
// All fields are defined as optional. In case of a reconfiguration,
// unset fields are not changed.
type ClusterDpmConfigInfo struct {
	DynamicData

	// Flag indicating whether or not the service is enabled.
	//
	// This
	// service can not be enabled, unless DRS is enabled as well.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Specifies the default VMware DPM behavior for
	// hosts.
	//
	// This default behavior can be overridden on a per host
	// basis using the `ClusterDpmHostConfigInfo` object.
	DefaultDpmBehavior DpmBehavior `xml:"defaultDpmBehavior,omitempty" json:"defaultDpmBehavior,omitempty"`
	// DPM generates only those recommendations that are above the
	// specified rating.
	//
	// Ratings vary from 1 to 5. This setting applies
	// to both manual and automated (@link DpmBehavior) DPM clusters.
	HostPowerActionRate int32 `xml:"hostPowerActionRate,omitempty" json:"hostPowerActionRate,omitempty"`
	// Deprecated as of vSphere API 4.1, use
	// `ClusterDrsConfigInfo.option`.
	//
	// Advanced settings.
	Option []BaseOptionValue `xml:"option,omitempty,typeattr" json:"option,omitempty"`
}

func init() {
	t["ClusterDpmConfigInfo"] = reflect.TypeOf((*ClusterDpmConfigInfo)(nil)).Elem()
}

// DPM configuration for a single host.
//
// This makes
// it possible to override the default behavior for an individual
// host.
type ClusterDpmHostConfigInfo struct {
	DynamicData

	// Reference to the host.
	//
	// Refers instance of `HostSystem`.
	Key ManagedObjectReference `xml:"key" json:"key"`
	// Flag to indicate whether or not VirtualCenter is allowed to perform any
	// power related operations or recommendations for this host.
	//
	// If this flag is false, the host is effectively excluded from
	// DPM service.
	//
	// If no individual DPM specification exists for a host,
	// this property defaults to true.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Specifies the particular DPM behavior for this host.
	//
	// See also `ClusterDpmConfigInfo`.
	Behavior DpmBehavior `xml:"behavior,omitempty" json:"behavior,omitempty"`
}

func init() {
	t["ClusterDpmHostConfigInfo"] = reflect.TypeOf((*ClusterDpmHostConfigInfo)(nil)).Elem()
}

// The `ClusterDpmHostConfigSpec` data object provides information
// that the Server uses to update the DPM configuration for a
// single host (identified by the
// `ClusterDpmHostConfigInfo.key` property).
//
// The host DPM configuration overrides the cluster
// default DPM setting
// (`ClusterConfigSpecEx*.*ClusterConfigSpecEx.dpmConfig`).
//
// The vSphere API defines three update operations
// (`ArrayUpdateSpec*.*ArrayUpdateSpec.operation`).
//   - add: Define DPM behavior for a host. If the cluster
//     configuration already includes a DPM behavior override
//     for the specified host, this operation
//     removes the existing override and adds the new one.
//     The new DPM override will use the cluster default value
//     if you do not specify the behavior property
//     (`ClusterDpmConfigInfo.defaultDpmBehavior`).
//   - edit: Perform an incremental update to an existing
//     DPM configuration entry for a host.
//     The reconfigure method changes only the properties
//     that you set in the data object. The entry must exist
//     in the
//     `ClusterConfigSpecEx*.*ClusterConfigSpecEx.dpmHostConfigSpec` array.
//   - remove: Remove the DPM override for the specified
//     host. To identify the host to delete, use the
//     `ArrayUpdateSpec.removeKey` property
//     to specify the `ClusterDpmHostConfigInfo.key`
//     in the host override.
//
// Use the `ComputeResource.ReconfigureComputeResource_Task` method
// to update the DPM configuration. If you set the modify parameter
// to true, you can use any of the three operations (add, edit, or remove).
// If you set the modify parameter to false, you can use only the
// add operation.
type ClusterDpmHostConfigSpec struct {
	ArrayUpdateSpec

	Info *ClusterDpmHostConfigInfo `xml:"info,omitempty" json:"info,omitempty"`
}

func init() {
	t["ClusterDpmHostConfigSpec"] = reflect.TypeOf((*ClusterDpmHostConfigSpec)(nil)).Elem()
}

// The `ClusterDrsConfigInfo` data object contains configuration information
// for the VMware DRS service.
//
// All fields are optional. If you set the <code>modify</code>
// parameter to <code>true</code> when you call
// `ComputeResource.ReconfigureComputeResource_Task`, an unset property has no effect
// on the existing property value in the cluster configuration on the Server.
// If you set the <code>modify</code> parameter to <code>false</code> when you
// reconfigure a cluster, the cluster configuration is reverted to the default
// values, then the new configuration values are applied.
type ClusterDrsConfigInfo struct {
	DynamicData

	// Deprecated as of vSphere API 7.0.
	// To disable DRS load balancing, please use the lowest DRS aggressiveness
	// level, setting `ClusterDrsConfigInfo.vmotionRate` to 5, and/or
	// setting `ClusterDrsConfigInfo.defaultVmBehavior` to manual.
	// The former only generates manadatory move recommendations, not load
	// balancing recommendations. The latter only generates recommendations,
	// without executing them.
	// To remove all the child resource pools, please find the root resource
	// pool `ComputeResource.resourcePool`, and destroy all its
	// children `ResourcePool.DestroyChildren`.
	// Vice versa.
	//
	// Flag indicating whether or not DRS service is enabled.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Flag that dictates whether DRS Behavior overrides for individual
	// virtual machines (`ClusterDrsVmConfigInfo`) are enabled.
	//
	// The default
	// value is <code>true</code>.
	//
	// When this flag is <code>true</code>, the
	// `ClusterConfigSpecEx*.*ClusterConfigSpecEx.drsVmConfigSpec`
	// values override the `ClusterDrsConfigInfo.defaultVmBehavior`.
	//
	// When this flag is <code>false</code>, the
	// `ClusterDrsConfigInfo.defaultVmBehavior` value applies to all virtual
	// machines, with the following exception: in a cluster that has EVC disabled,
	// you cannot override the virtual machine setting
	// (`ClusterConfigSpecEx.drsVmConfigSpec`)
	// for Fault Tolerance virtual machines.
	EnableVmBehaviorOverrides *bool `xml:"enableVmBehaviorOverrides" json:"enableVmBehaviorOverrides,omitempty"`
	// Specifies the cluster-wide default DRS behavior for virtual machines.
	//
	// You can override the default behavior for a virtual machine
	// by using the `ClusterDrsVmConfigInfo` object.
	DefaultVmBehavior DrsBehavior `xml:"defaultVmBehavior,omitempty" json:"defaultVmBehavior,omitempty"`
	// Threshold for generated `ClusterRecommendation`s.
	//
	// DRS generates only those recommendations that are above the
	// specified vmotionRate. Ratings vary from 1 to 5. This setting applies
	// to manual, partiallyAutomated, and fullyAutomated
	// DRS clusters. See `DrsBehavior_enum`.
	VmotionRate int32 `xml:"vmotionRate,omitempty" json:"vmotionRate,omitempty"`
	// Specifies the scaling behavior of the shares of all resource pools
	// in the cluster.
	//
	// See `ResourceConfigSpecScaleSharesBehavior_enum`
	// for possible values. If any scaling behavior other than
	// `disabled` is specified,
	// the system will scale the CPU and memory shares allocated to each
	// resource pool with the total shares of all powered on virtual machines
	// under each respective pool. The system will also use the
	// `SharesInfo` set on each resource pool as a multiplier for the
	// scale. Setting the
	// `ClusterDrsConfigInfo.scaleDescendantsShares` on the cluster
	// is equivalent to setting the
	// `ResourceConfigSpec.scaleDescendantsShares` on the root
	// resource pool.
	ScaleDescendantsShares string `xml:"scaleDescendantsShares,omitempty" json:"scaleDescendantsShares,omitempty"`
	// Advanced settings.
	Option []BaseOptionValue `xml:"option,omitempty,typeattr" json:"option,omitempty"`
}

func init() {
	t["ClusterDrsConfigInfo"] = reflect.TypeOf((*ClusterDrsConfigInfo)(nil)).Elem()
}

// The faults generated by DRS when it tries to make recommendations
// for rule enforcement, power management, etc., and indexed in a tree
// structure with reason for recommendations and VM to migrate (optional)
// as the index keys.
type ClusterDrsFaults struct {
	DynamicData

	// A reason code explaining why this set of recommendations were attempted
	// by DRS when it generated the faults.
	Reason string `xml:"reason" json:"reason"`
	// The faults grouped by VMs that DRS was trying to migrate.
	FaultsByVm []BaseClusterDrsFaultsFaultsByVm `xml:"faultsByVm,typeattr" json:"faultsByVm"`
}

func init() {
	t["ClusterDrsFaults"] = reflect.TypeOf((*ClusterDrsFaults)(nil)).Elem()
}

// The faults generated by storage DRS when it tries to move a virtual disk.
type ClusterDrsFaultsFaultsByVirtualDisk struct {
	ClusterDrsFaultsFaultsByVm

	// The virtual disk that storage DRS was trying to migrate when it
	// generated the faults.
	//
	// If this property is NULL, the fault is not
	// associated with a particular virtual disk.
	Disk *VirtualDiskId `xml:"disk,omitempty" json:"disk,omitempty"`
}

func init() {
	t["ClusterDrsFaultsFaultsByVirtualDisk"] = reflect.TypeOf((*ClusterDrsFaultsFaultsByVirtualDisk)(nil)).Elem()
}

// FaultsByVm is the faults generated by DRS when it tries to
// move a VM.
type ClusterDrsFaultsFaultsByVm struct {
	DynamicData

	// The VM that DRS was trying to migrate when it generated the faults.
	//
	// If this property is NULL, the fault is not associated with a particular VM.
	//
	// Refers instance of `VirtualMachine`.
	Vm *ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
	// The faults generated by DRS when it was trying to move the given VM.
	Fault []LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["ClusterDrsFaultsFaultsByVm"] = reflect.TypeOf((*ClusterDrsFaultsFaultsByVm)(nil)).Elem()
}

// Describes a single virtual machine migration.
type ClusterDrsMigration struct {
	DynamicData

	// A unique key that identifies this recommendation.
	//
	// This
	// is used as an argument to
	// ComputeResource.applyRecommendation.
	Key string `xml:"key" json:"key"`
	// The time this recommendation was computed.
	Time time.Time `xml:"time" json:"time"`
	// The virtual machine selected for migration.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Current CPU load for the virtual machine, in MHz.
	//
	// This property is only populated for recommendations.
	CpuLoad int32 `xml:"cpuLoad,omitempty" json:"cpuLoad,omitempty"`
	// Current memory load for the virtual machine, in bytes.
	//
	// This field is only populated for recommendations.
	MemoryLoad int64 `xml:"memoryLoad,omitempty" json:"memoryLoad,omitempty"`
	// Source host.
	//
	// Refers instance of `HostSystem`.
	Source ManagedObjectReference `xml:"source" json:"source"`
	// Current CPU load on the source host, in MHz.
	SourceCpuLoad int32 `xml:"sourceCpuLoad,omitempty" json:"sourceCpuLoad,omitempty"`
	// Current memory usage on the source host, in bytes.
	SourceMemoryLoad int64 `xml:"sourceMemoryLoad,omitempty" json:"sourceMemoryLoad,omitempty"`
	// Destination host.
	//
	// Refers instance of `HostSystem`.
	Destination ManagedObjectReference `xml:"destination" json:"destination"`
	// Current CPU load on the destination host, in MHz.
	DestinationCpuLoad int32 `xml:"destinationCpuLoad,omitempty" json:"destinationCpuLoad,omitempty"`
	// Current memory usage on the destination host, in bytes.
	DestinationMemoryLoad int64 `xml:"destinationMemoryLoad,omitempty" json:"destinationMemoryLoad,omitempty"`
}

func init() {
	t["ClusterDrsMigration"] = reflect.TypeOf((*ClusterDrsMigration)(nil)).Elem()
}

// Deprecated as of VI API 2.5 use `ClusterRecommendation`.
//
// DrsRecommendation describes a recommendation to migrate
// one or more virtual machines.
type ClusterDrsRecommendation struct {
	DynamicData

	// Key to identify the recommendation when calling applyRecommendation.
	Key string `xml:"key" json:"key"`
	// A rating of the recommendation.
	//
	// Valid values range from 1 (lowest confidence) to 5 (highest confidence).
	Rating int32 `xml:"rating" json:"rating"`
	// A reason code explaining why this set of migrations is being suggested.
	Reason string `xml:"reason" json:"reason"`
	// Text that provides more information about the reason code for the suggested
	// set of migrations.
	ReasonText string `xml:"reasonText" json:"reasonText"`
	// Deprecated a more general `recommendation` list should be used. This recommendation type
	// and the migrationList is kept for backward compatibility.
	//
	// List of migrations in this recommendation and all the parent
	// recommendations on which this recommendation depends.
	//
	// All the
	// migrations in this list can be constructed from `ClusterRecommendation.prerequisite` and `ClusterRecommendation.action`.
	MigrationList []ClusterDrsMigration `xml:"migrationList" json:"migrationList"`
}

func init() {
	t["ClusterDrsRecommendation"] = reflect.TypeOf((*ClusterDrsRecommendation)(nil)).Elem()
}

// DRS configuration for a single virtual machine.
//
// This makes it possible
// to override the default behavior for an individual virtual machine.
type ClusterDrsVmConfigInfo struct {
	DynamicData

	// Reference to the virtual machine.
	//
	// Refers instance of `VirtualMachine`.
	Key ManagedObjectReference `xml:"key" json:"key"`
	// Flag to indicate whether or not VirtualCenter is allowed to perform any
	// DRS migration or initial placement recommendations for this virtual
	// machine.
	//
	// If this flag is false, the virtual machine is effectively excluded from
	// DRS.
	//
	// If no individual DRS specification exists for a virtual machine,
	// this property defaults to true.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Specifies the particular DRS behavior for this virtual machine.
	//
	// See also `ClusterDrsConfigInfo`.
	Behavior DrsBehavior `xml:"behavior,omitempty" json:"behavior,omitempty"`
}

func init() {
	t["ClusterDrsVmConfigInfo"] = reflect.TypeOf((*ClusterDrsVmConfigInfo)(nil)).Elem()
}

// Updates the per-virtual-machine DRS configuration.
//
// To update the DRS configuration of a virtual machine, a copy of this object
// is included in the `ClusterConfigSpecEx` object passed to the method
// `ComputeResource.ReconfigureComputeResource_Task`.
//
// If _reconfigureEx_ is used to
// incrementally update the cluster configuration (i.e., the parameter `*modify*` is true),
// then three operations are provided for updating the DRS configuration for a virtual machine.
// These operations are listed below (see `ArrayUpdateSpec` for more
// information on these operations).
//   - add: add a configuration for the virtual machine, overwritting the existing
//     configuration if one exists
//   - edit: incrmentally update the existing configuration; an existing configuration
//     must exist
//   - remove: remove the existing configuration; an existing configuration must exist
//
// If, instead, this method is used to overwrite the cluster configuration (i.e., the parameter
// `*modify*` is false) thereby creating a new configuration, only the add operation is allowed.
// In this case, _add_ creates a DRS configuration for a virtual machine in the new cluster
// configuration.
type ClusterDrsVmConfigSpec struct {
	ArrayUpdateSpec

	Info *ClusterDrsVmConfigInfo `xml:"info,omitempty" json:"info,omitempty"`
}

func init() {
	t["ClusterDrsVmConfigSpec"] = reflect.TypeOf((*ClusterDrsVmConfigSpec)(nil)).Elem()
}

type ClusterEVCManagerCheckResult struct {
	DynamicData

	// The EVC mode being tested for legal application.
	EvcModeKey string `xml:"evcModeKey" json:"evcModeKey"`
	// A problem that would prevent applying the desired EVC mode.
	Error LocalizedMethodFault `xml:"error" json:"error"`
	// The set of hosts which would generate the fault described by the
	// `ClusterEVCManagerCheckResult.error` property when the desired EVC mode is applied.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["ClusterEVCManagerCheckResult"] = reflect.TypeOf((*ClusterEVCManagerCheckResult)(nil)).Elem()
}

type ClusterEVCManagerEVCState struct {
	DynamicData

	// All supported EVC modes.
	//
	// Identical to
	// `Capability.supportedEVCMode`.
	SupportedEVCMode []EVCMode `xml:"supportedEVCMode" json:"supportedEVCMode"`
	// If unset, then EVC is disabled.
	//
	// If set, then EVC is enabled, and the
	// value references an EVC mode described in one of the elements of the
	// `ClusterEVCManagerEVCState.supportedEVCMode` array property. The EVC mode determines the
	// set of guaranteed clusterwide CPU features. While EVC is enabled, CPU
	// compatibility issues will not block any VMotion within the cluster
	// (unless some VM is specifically configured to do different CPUID
	// overrides).
	CurrentEVCModeKey string `xml:"currentEVCModeKey,omitempty" json:"currentEVCModeKey,omitempty"`
	// Deprecated as of vSphere API 6.5 use `ClusterEVCManagerEVCState.featureCapability`.
	//
	// When EVC is enabled, this array contains the CPU feature bits that are
	// guaranteed (by EVC) to be the same among all hosts in the cluster.
	//
	// This property has the same value as the guaranteedCPUFeatures property
	// of the configured EVC mode. On any host in the EVC cluster, the CPU
	// features either naturally match these values because of the CPU
	// hardware, or else CPU feature override is used to mask out differences
	// and enforce a match. This array is empty when EVC is disabled.
	GuaranteedCPUFeatures []HostCpuIdInfo `xml:"guaranteedCPUFeatures,omitempty" json:"guaranteedCPUFeatures,omitempty"`
	// When EVC is enabled, this array contains the feature capabilities that
	// are guaranteed (by EVC) to be the same among all hosts in the cluster.
	//
	// This property has the same value as the featureCapability property
	// of the configured EVC mode. On any host in the EVC cluster, the feature
	// capabilities either naturally match these values because of the CPU
	// hardware, or else feature masks are used to mask out differences and
	// enforce a match. This array is empty when EVC is disabled.
	FeatureCapability []HostFeatureCapability `xml:"featureCapability,omitempty" json:"featureCapability,omitempty"`
	// The masks (modifications to a host's feature capabilities) that limit a
	// host's capabilities to that of the EVC mode baseline.
	FeatureMask []HostFeatureMask `xml:"featureMask,omitempty" json:"featureMask,omitempty"`
	// The conditions that must be true of a host's feature capabilities in order
	// for the host to meet the minimum requirements of the EVC mode baseline.
	FeatureRequirement []VirtualMachineFeatureRequirement `xml:"featureRequirement,omitempty" json:"featureRequirement,omitempty"`
}

func init() {
	t["ClusterEVCManagerEVCState"] = reflect.TypeOf((*ClusterEVCManagerEVCState)(nil)).Elem()
}

type ClusterEnterMaintenanceMode ClusterEnterMaintenanceModeRequestType

func init() {
	t["ClusterEnterMaintenanceMode"] = reflect.TypeOf((*ClusterEnterMaintenanceMode)(nil)).Elem()
}

// The parameters of `ClusterComputeResource.ClusterEnterMaintenanceMode`.
type ClusterEnterMaintenanceModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The array of hosts to put into maintenance mode.
	//
	// Required privileges: Host.Config.Maintenance
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host" json:"host"`
	// An array of `OptionValue`
	// options for this query. The specified options override the
	// advanced options in `ClusterDrsConfigInfo`.
	Option []BaseOptionValue                      `xml:"option,omitempty,typeattr" json:"option,omitempty"`
	Info   *ClusterComputeResourceMaintenanceInfo `xml:"info,omitempty" json:"info,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["ClusterEnterMaintenanceModeRequestType"] = reflect.TypeOf((*ClusterEnterMaintenanceModeRequestType)(nil)).Elem()
}

type ClusterEnterMaintenanceModeResponse struct {
	Returnval ClusterEnterMaintenanceResult `xml:"returnval" json:"returnval"`
}

// EnterMaintenanceResult is the base class of the result returned to the
// `ClusterComputeResource.ClusterEnterMaintenanceMode` method.
type ClusterEnterMaintenanceResult struct {
	DynamicData

	// The list of recommendations for hosts that Virtual Center will
	// be able to evacuate.
	//
	// Each recommendation consists of a host
	// maintenance action `ClusterAction` for a host, along
	// with zero or more vmotions for evacuation. Application of the
	// recommendations is not supported currently. The client will have
	// to put the hosts into maintenance mode by calling the separate
	// method `HostSystem.EnterMaintenanceMode_Task`.
	Recommendations []ClusterRecommendation `xml:"recommendations,omitempty" json:"recommendations,omitempty"`
	// The faults that explain why the Virtual Center cannot evacuate
	// some hosts.
	Fault *ClusterDrsFaults `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["ClusterEnterMaintenanceResult"] = reflect.TypeOf((*ClusterEnterMaintenanceResult)(nil)).Elem()
}

// These are cluster events.
type ClusterEvent struct {
	Event
}

func init() {
	t["ClusterEvent"] = reflect.TypeOf((*ClusterEvent)(nil)).Elem()
}

// The current admission control related information if the cluster was configured
// with a FailoverHostAdmissionControlPolicy.
type ClusterFailoverHostAdmissionControlInfo struct {
	ClusterDasAdmissionControlInfo

	// Status of the failover hosts in the cluster.
	HostStatus []ClusterFailoverHostAdmissionControlInfoHostStatus `xml:"hostStatus,omitempty" json:"hostStatus,omitempty"`
}

func init() {
	t["ClusterFailoverHostAdmissionControlInfo"] = reflect.TypeOf((*ClusterFailoverHostAdmissionControlInfo)(nil)).Elem()
}

// Data object containing the status of a failover host.
type ClusterFailoverHostAdmissionControlInfoHostStatus struct {
	DynamicData

	// The failover host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The status of the failover host.
	//
	// The status is green for a connected host with no vSphere HA errors and
	// no virtual machines running on it.
	// The status is yellow for a connected host with no vSphere HA errors and
	// some virtual machines running on it.
	// The status red for a disconnected or not responding host, a host that
	// is in maintenance or standby mode or that has a vSphere HA error on it.
	Status ManagedEntityStatus `xml:"status" json:"status"`
}

func init() {
	t["ClusterFailoverHostAdmissionControlInfoHostStatus"] = reflect.TypeOf((*ClusterFailoverHostAdmissionControlInfoHostStatus)(nil)).Elem()
}

// The `ClusterFailoverHostAdmissionControlPolicy` dedicates
// one or more hosts for use during failover.
//
// When a host fails with this policy in place, vSphere HA attempts
// to restart its virtual machines on a dedicated failover host.
// If this is not possible, for example the failover host itself has failed
// or it has insufficient resources, HA attempts to restart those virtual
// machines on another host in the cluster.
//
// To support the availabilty of a failover host,
// the vCenter Server will prevent users from powering on virtual machines
// on that host, or from using vMotion to migrate virtual machines to the host.
// Also, DRS does not use the failover host for load balancing.
//
// To obtain the status of a failover host, use the
// `ClusterFailoverHostAdmissionControlInfo.hostStatus`
// property
// (`ClusterComputeResourceSummary*.*ClusterComputeResourceSummary.admissionControlInfo*.*ClusterFailoverHostAdmissionControlInfo.hostStatus`).
type ClusterFailoverHostAdmissionControlPolicy struct {
	ClusterDasAdmissionControlPolicy

	// List of managed object references to failover hosts.
	//
	// Refers instances of `HostSystem`.
	FailoverHosts []ManagedObjectReference `xml:"failoverHosts,omitempty" json:"failoverHosts,omitempty"`
	// Number of host failures that should be tolerated, still guaranteeing
	// sufficient resources to restart virtual machines on available hosts.
	//
	// If not set, we assume 1.
	FailoverLevel int32 `xml:"failoverLevel,omitempty" json:"failoverLevel,omitempty"`
}

func init() {
	t["ClusterFailoverHostAdmissionControlPolicy"] = reflect.TypeOf((*ClusterFailoverHostAdmissionControlPolicy)(nil)).Elem()
}

// The current admission control related information if the cluster was
// configured with a FailoverLevelAdmissionControlPolicy.
type ClusterFailoverLevelAdmissionControlInfo struct {
	ClusterDasAdmissionControlInfo

	// Current failover level.
	//
	// This is the number of physical host failures that
	// can be tolerated without impacting the ability to satisfy the minimums for
	// all running virtual machines. This represents the current value, as
	// opposed to desired value configured by the user.
	CurrentFailoverLevel int32 `xml:"currentFailoverLevel" json:"currentFailoverLevel"`
}

func init() {
	t["ClusterFailoverLevelAdmissionControlInfo"] = reflect.TypeOf((*ClusterFailoverLevelAdmissionControlInfo)(nil)).Elem()
}

// The `ClusterFailoverLevelAdmissionControlPolicy`
// defines the number of host failures that should be tolerated and still
// guarantee enough unfragmented resources to failover all powered on virtual
// machines on those failed hosts.
//
// When you use the failover level policy, vSphere HA partitions resources
// into slots. A slot represents the minimum CPU and memory resources
// that are required to support any powered-on virtual machine in the cluster.
//
// With the failover level policy in place, HA uses the following slot
// calculations to control virtual machine migration within the cluster:
//
//  1. Calculate the slot size from CPU and memory reservations.
//     The CPU value is the largest CPU reservation for all powered-on
//     virtual machines in the cluster. The memory value is the largest
//     memory reservation (plus memory overhead).
//
//     If your cluster contains any virtual machines that have much larger
//     reservations than the others, they will distort slot size calculation.
//     To avoid this, you can specify an upper bound for slot sizes;
//     use the configuration editor in the vSphere Client to set the
//     das.slotCpuInMHz and das.slotMemInMB attributes. When you use these
//     attributes, there is a risk that resource fragmentation will cause
//     virtual machines with resource requirements larger than the slot size
//     to be assigned multiple slots. In a cluster that is close to capacity,
//     there might be enough slots in aggregate for HA to successfully
//     failover a virtual machine. However, if those slots are located
//     on multiple hosts, a virtual machine assigned multiple slots cannot
//     use them because a virtual machine can run on only a single host
//     at a time.
//
//  2. Determine how many slots each host in the cluster can hold.
//     HA uses the CPU and memory resources in a host's root resource pool
//     to determine host slot capacity, not the total physical resources
//     of the host. Resources used for virtualization purposes are not
//     included. HA uses connected hosts that are not in maintenance mode
//     and that do not have any HA errors.
//
//     The CPU slot resource is the host CPU resource amount divided
//     by the CPU component of the slot size; the result is rounded down.
//     HA makes the same calculation for host memory resource amount.
//     HA compares the results; the lower of the two numbers is the
//     host slot capacity.
//
//  3. Determine the current failover capacity of the cluster. This is the
//     number of hosts (starting from the largest) that can fail and still
//     leave enough slots to satisfy all of the powered-on virtual machines.
//
//  4. Compare the current failover capacity to the configured
//     `ClusterFailoverLevelAdmissionControlPolicy.failoverLevel`.
//     If the current failover capacity is less than the configured
//     failover level, HA disallows the operation.
type ClusterFailoverLevelAdmissionControlPolicy struct {
	ClusterDasAdmissionControlPolicy

	// Number of host failures that should be tolerated, still guaranteeing
	// sufficient resources to restart virtual machines on available hosts.
	FailoverLevel int32 `xml:"failoverLevel" json:"failoverLevel"`
	// A policy for how to compute the slot size.
	//
	// If left unset, the slot is
	// computed using the maximum reservations and memory overhead of any
	// powered on virtual machine in the cluster.
	SlotPolicy BaseClusterSlotPolicy `xml:"slotPolicy,omitempty,typeattr" json:"slotPolicy,omitempty"`
}

func init() {
	t["ClusterFailoverLevelAdmissionControlPolicy"] = reflect.TypeOf((*ClusterFailoverLevelAdmissionControlPolicy)(nil)).Elem()
}

// The current admission control related information if the cluster was configured
// with a FailoverResourcesAdmissionControlPolicy.
type ClusterFailoverResourcesAdmissionControlInfo struct {
	ClusterDasAdmissionControlInfo

	// The percentage of cpu resources in the cluster available for failover.
	CurrentCpuFailoverResourcesPercent int32 `xml:"currentCpuFailoverResourcesPercent" json:"currentCpuFailoverResourcesPercent"`
	// The percentage of memory resources in the cluster available for failover.
	CurrentMemoryFailoverResourcesPercent int32 `xml:"currentMemoryFailoverResourcesPercent" json:"currentMemoryFailoverResourcesPercent"`
	// The percentage of persistent memory resources in the cluster available
	// for failover.
	CurrentPMemFailoverResourcesPercent int32 `xml:"currentPMemFailoverResourcesPercent,omitempty" json:"currentPMemFailoverResourcesPercent,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["ClusterFailoverResourcesAdmissionControlInfo"] = reflect.TypeOf((*ClusterFailoverResourcesAdmissionControlInfo)(nil)).Elem()
}

// The `ClusterFailoverResourcesAdmissionControlPolicy`
// reserves a specified percentage of aggregate cluster resources for failover.
//
// With the resources failover policy in place, vSphere HA uses the following
// calculations to control virtual machine migration in the cluster.
//  1. Calculate the total resource requirements for all powered-on
//     virtual machines in the cluster.
//  2. Calculate the total host resources available for virtual machines.
//  3. Calculate the Current CPU failover capacity, memory failover
//     capacity and optionally, persistent memory failover capacity
//     for the cluster.
//  4. Compare the current CPU failover capacity and current memory failover
//     capacity with the configured resource percentages
//     (`ClusterFailoverResourcesAdmissionControlPolicy.cpuFailoverResourcesPercent`
//     and
//     `ClusterFailoverResourcesAdmissionControlPolicy.memoryFailoverResourcesPercent`).
//     If either current capacity is less than the corresponding configured
//     capacity, HA does not allow the operation.
//
// HA uses the actual reservations of the virtual machines. If a virtual machine
// does not have reservations, meaning that the reservation is 0, a default
// of 0MB memory and 256MHz CPU is applied. This is controlled by the same
// HA advanced options used for the failover level policy
// (`ClusterFailoverLevelAdmissionControlPolicy`).
type ClusterFailoverResourcesAdmissionControlPolicy struct {
	ClusterDasAdmissionControlPolicy

	// Percentage of CPU resources in the cluster to reserve for failover.
	//
	// You can specify up to 100% of CPU resources for failover.
	CpuFailoverResourcesPercent int32 `xml:"cpuFailoverResourcesPercent" json:"cpuFailoverResourcesPercent"`
	// Percentage of memory resources in the cluster to reserve for failover.
	//
	// You can specify up to 100% of memory resources for failover.
	MemoryFailoverResourcesPercent int32 `xml:"memoryFailoverResourcesPercent" json:"memoryFailoverResourcesPercent"`
	// Number of host failures that should be tolerated, still guaranteeing
	// sufficient resources to restart virtual machines on available hosts.
	//
	// If not set, we assume 1.
	FailoverLevel int32 `xml:"failoverLevel,omitempty" json:"failoverLevel,omitempty"`
	// Flag to enable user input values for
	// `ClusterFailoverResourcesAdmissionControlPolicy.cpuFailoverResourcesPercent`
	// and
	// `ClusterFailoverResourcesAdmissionControlPolicy.memoryFailoverResourcesPercent`
	// By default, this is true and the default calculation is using the
	// `ClusterFailoverResourcesAdmissionControlPolicy.failoverLevel`
	// hosts' resources.
	//
	// If users want to override the percentage values,
	// they must disable the auto-compute by setting this field to false.
	AutoComputePercentages *bool `xml:"autoComputePercentages" json:"autoComputePercentages,omitempty"`
	// Percentage of persistent memory resources in the cluster to reserve for
	// the failover.
	//
	// You can specify up to 100% of persistent memory resources for failover.
	PMemFailoverResourcesPercent int32 `xml:"pMemFailoverResourcesPercent,omitempty" json:"pMemFailoverResourcesPercent,omitempty" vim:"7.0.2.0"`
	// Flag to enable user input values for
	// `ClusterFailoverResourcesAdmissionControlPolicy.pMemFailoverResourcesPercent`
	// By default, this is true and the default calculation is done using the
	// `ClusterFailoverResourcesAdmissionControlPolicy.failoverLevel` hosts' resources.
	//
	// If a user wants to override the percentage values, they
	// must disable the auto-compute by setting this field to false.
	AutoComputePMemFailoverResourcesPercent *bool `xml:"autoComputePMemFailoverResourcesPercent" json:"autoComputePMemFailoverResourcesPercent,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["ClusterFailoverResourcesAdmissionControlPolicy"] = reflect.TypeOf((*ClusterFailoverResourcesAdmissionControlPolicy)(nil)).Elem()
}

// This policy allows setting a fixed slot size
type ClusterFixedSizeSlotPolicy struct {
	ClusterSlotPolicy

	// The cpu component of the slot size (in MHz)
	Cpu int32 `xml:"cpu" json:"cpu"`
	// The memory component of the slot size (in megabytes)
	Memory int32 `xml:"memory" json:"memory"`
}

func init() {
	t["ClusterFixedSizeSlotPolicy"] = reflect.TypeOf((*ClusterFixedSizeSlotPolicy)(nil)).Elem()
}

// An `ClusterFtVmHostRuleInfo` object provides control of the
// placement of virtual machines across two host groups. The virtual machines
// and hosts referenced by an FT VM-Host rule must be in the same cluster.
//
// An FT VM-Host rule identifies the following groups.
//   - A virtual machine group name (`ClusterVmGroup`).
//   - An array of two host groups (`ClusterHostGroup`).
//
// `ClusterFtVmHostRuleInfo` stores only the names of the relevant
// virtual machine and host groups. The group contents are stored in
// the virtual machine and host group objects.
//
// When employing this rule, take care to ensure that the specified
// host groups have sufficient resources to support the requirements
// of all VMs specified.
type ClusterFtVmHostRuleInfo struct {
	ClusterRuleInfo

	// Virtual machine group name
	// (`ClusterVmGroup*.*ClusterGroupInfo.name`).
	//
	// The named virtual machine group may have zero or more VMs.
	// A virtual machine in this group may be a normal virtual machine
	// or a fault tolerant primary virtual machine; it cannot
	// be a fault tolerant secondary virtual machine.
	//
	// Control of FT secondary virtual machines is implied by the presence
	// of the primary FT virtual machine.
	//
	// A virtual machine in this group should not be referenced in any other
	// FT VM-Host rule or VM-Host rule `ClusterVmHostRuleInfo`.
	VmGroupName string `xml:"vmGroupName" json:"vmGroupName"`
	// Array of two Host Groups (`ClusterHostGroup`).
	//
	// The hostGroup array must have two host groups. Each host group in the
	// hostGroup array will have a set of hosts. For each Fault Tolerance primary
	// VM that is part of VmGroup, the primary and secondary VMs would be placed
	// on hosts that are not part of the same host group.
	//
	// The members of each host group should be disjoint from the members
	// of all other host group specified.
	HostGroupName []string `xml:"hostGroupName,omitempty" json:"hostGroupName,omitempty"`
}

func init() {
	t["ClusterFtVmHostRuleInfo"] = reflect.TypeOf((*ClusterFtVmHostRuleInfo)(nil)).Elem()
	minAPIVersionForType["ClusterFtVmHostRuleInfo"] = "8.0.3.0"
}

// `ClusterGroupInfo` is the base type for all virtual machine
// and host groups.
//
// All virtual machines and hosts that are part of a group
// must be part of the same cluster.
type ClusterGroupInfo struct {
	DynamicData

	// Unique name of the group.
	Name string `xml:"name" json:"name"`
	// Flag to indicate whether the group is created by the user or the system.
	UserCreated *bool `xml:"userCreated" json:"userCreated,omitempty"`
	// Unique ID for the group.
	//
	// uniqueID is unique within a cluster.
	// Groups residing in different clusters might share a uniqueID.
	UniqueID string `xml:"uniqueID,omitempty" json:"uniqueID,omitempty"`
}

func init() {
	t["ClusterGroupInfo"] = reflect.TypeOf((*ClusterGroupInfo)(nil)).Elem()
}

// An incremental update to the cluster-wide groups.
type ClusterGroupSpec struct {
	ArrayUpdateSpec

	Info BaseClusterGroupInfo `xml:"info,omitempty,typeattr" json:"info,omitempty"`
}

func init() {
	t["ClusterGroupSpec"] = reflect.TypeOf((*ClusterGroupSpec)(nil)).Elem()
}

// The `ClusterHostGroup` data object identifies hosts for VM-Host rules.
//
// VM-Host rules determine placement of virtual machines on hosts in a cluster.
// The logic specified in a `ClusterVmHostRuleInfo` object
// determines where virtual machines can be powered-on.
type ClusterHostGroup struct {
	ClusterGroupInfo

	// List of hosts that are part of this group.
	//
	// A host group can contain zero or more hosts.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["ClusterHostGroup"] = reflect.TypeOf((*ClusterHostGroup)(nil)).Elem()
}

// Describes a HostSystem's quarantine or maintenance mode change action.
type ClusterHostInfraUpdateHaModeAction struct {
	ClusterAction

	// Specify the action type.
	//
	// Values are of type
	// `OperationType`.
	OperationType string `xml:"operationType" json:"operationType"`
}

func init() {
	t["ClusterHostInfraUpdateHaModeAction"] = reflect.TypeOf((*ClusterHostInfraUpdateHaModeAction)(nil)).Elem()
}

// Describes a single host power action.
type ClusterHostPowerAction struct {
	ClusterAction

	// Specify whether the action is power on or power off
	OperationType HostPowerOperationType `xml:"operationType" json:"operationType"`
	// Estimated power consumption of the host.
	//
	// In case of power-on,
	// this is the projected increase in the cluster's power
	// consumption. In case of power off, this is the projected
	// decrease in the cluster's power consumption
	PowerConsumptionWatt int32 `xml:"powerConsumptionWatt,omitempty" json:"powerConsumptionWatt,omitempty"`
	// CPU capacity of the host in units of MHz.
	//
	// In case of power-on
	// action, this is the projected increase in the cluster's CPU
	// capacity. In case of power off, this is the projected decrease
	// in the cluster's CPU capacity.
	CpuCapacityMHz int32 `xml:"cpuCapacityMHz,omitempty" json:"cpuCapacityMHz,omitempty"`
	// Memory capacity of the host in units of MM.
	//
	// In case of power-on
	// action, this is the projected increase in the cluster's memory
	// capacity. In case of power off, this is the projected decrease
	// in the cluster's memory capacity.
	MemCapacityMB int32 `xml:"memCapacityMB,omitempty" json:"memCapacityMB,omitempty"`
}

func init() {
	t["ClusterHostPowerAction"] = reflect.TypeOf((*ClusterHostPowerAction)(nil)).Elem()
}

// A DRS recommended host for either powering on, resuming or
// reverting a virtual machine, or migrating a virtual machine from
// outside the cluster.
type ClusterHostRecommendation struct {
	DynamicData

	// The recommended host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Rating for the recommendation.
	//
	// Ratings range from 1 to 5, and
	// the higher the rating, the stronger DRS suggests this host is
	// picked for the operation.
	Rating int32 `xml:"rating" json:"rating"`
}

func init() {
	t["ClusterHostRecommendation"] = reflect.TypeOf((*ClusterHostRecommendation)(nil)).Elem()
}

// Configuration of the vSphere InfraUpdateHA service.
//
// All fields are defined as optional. In case of a reconfiguration,
// unset fields are not changed.
type ClusterInfraUpdateHaConfigInfo struct {
	DynamicData

	// Flag indicating whether or not the service is enabled.
	//
	// InfraUpdateHA
	// will not be active, unless DRS is enabled as well.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Configured behavior.
	//
	// Values are of type
	// `BehaviorType`.
	Behavior string `xml:"behavior,omitempty" json:"behavior,omitempty"`
	// Configured remediation for moderately degraded hosts.
	//
	// Values are of type
	// `RemediationType`.
	// Configuring MaintenanceMode for moderateRemedation and QuarantineMode for
	// severeRemediation is not supported and will throw InvalidArgument.
	ModerateRemediation string `xml:"moderateRemediation,omitempty" json:"moderateRemediation,omitempty"`
	// Configured remediation for severely degraded hosts.
	//
	// Values are of type
	// `RemediationType`.
	SevereRemediation string `xml:"severeRemediation,omitempty" json:"severeRemediation,omitempty"`
	// The list of health update providers configured for this cluster.
	//
	// Providers are identified by their id.
	//
	// When reconfiguring the cluster, a list with a single element {""} will
	// clear the list of providers.
	//
	// If the provider list is empty, InfraUpdateHA will not be active.
	Providers []string `xml:"providers,omitempty" json:"providers,omitempty"`
}

func init() {
	t["ClusterInfraUpdateHaConfigInfo"] = reflect.TypeOf((*ClusterInfraUpdateHaConfigInfo)(nil)).Elem()
}

// Describes an initial placement of a single virtual machine
type ClusterInitialPlacementAction struct {
	ClusterAction

	// The host where the virtual machine should be initially placed.
	//
	// Refers instance of `HostSystem`.
	TargetHost ManagedObjectReference `xml:"targetHost" json:"targetHost"`
	// The resource pool to place the virtual machine into in case this
	// action is for migrating from outside cluster.
	//
	// Refers instance of `ResourcePool`.
	Pool *ManagedObjectReference `xml:"pool,omitempty" json:"pool,omitempty"`
}

func init() {
	t["ClusterInitialPlacementAction"] = reflect.TypeOf((*ClusterInitialPlacementAction)(nil)).Elem()
}

// Information about an IO Filter on a compute resource.
type ClusterIoFilterInfo struct {
	IoFilterInfo

	// The operation that was performed for the IO Filter.
	//
	// The set of possible values are described in
	// `IoFilterOperation_enum`.
	// If opType is `uninstall`,
	// and the uninstallation of the filter was sucessful on all the hosts
	// in the cluster, the filter will be removed from the cluster's filter
	// list.
	OpType string `xml:"opType" json:"opType"`
	// The URL of the VIB package that the IO Filter is installed from.
	//
	// The property is unset if the information is not available.
	VibUrl string `xml:"vibUrl,omitempty" json:"vibUrl,omitempty"`
}

func init() {
	t["ClusterIoFilterInfo"] = reflect.TypeOf((*ClusterIoFilterInfo)(nil)).Elem()
}

// Describes a single VM migration action.
type ClusterMigrationAction struct {
	ClusterAction

	// The details of the migration action
	DrsMigration *ClusterDrsMigration `xml:"drsMigration,omitempty" json:"drsMigration,omitempty"`
}

func init() {
	t["ClusterMigrationAction"] = reflect.TypeOf((*ClusterMigrationAction)(nil)).Elem()
}

// The Cluster network config spec allows specification of
// the second network adapter is used for communication between
// the nodes of a VCHA cluster.
type ClusterNetworkConfigSpec struct {
	DynamicData

	// The portgroup that is associated with the VCHA Cluster IP
	// address for VCHA cluster traffic for the second adapter to be
	// added to the Active vCenter.
	//
	// Refers instance of `Network`.
	NetworkPortGroup ManagedObjectReference `xml:"networkPortGroup" json:"networkPortGroup"`
	// VCHA Cluster network configuration of the node.
	//
	// All cluster communication (state replication, heartbeat,
	// cluster messages) happens over this network.
	// Only a single Gateway IPv4 Address is supported.
	// IPAddress and NetMask must be specified or an InvalidArgument
	// exception will be reported.
	IpSettings CustomizationIPSettings `xml:"ipSettings" json:"ipSettings"`
}

func init() {
	t["ClusterNetworkConfigSpec"] = reflect.TypeOf((*ClusterNetworkConfigSpec)(nil)).Elem()
}

// This data class reports one virtual machine powerOn failure.
type ClusterNotAttemptedVmInfo struct {
	DynamicData

	// The virtual machine that can not be powered on.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The exception returned.
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["ClusterNotAttemptedVmInfo"] = reflect.TypeOf((*ClusterNotAttemptedVmInfo)(nil)).Elem()
}

// vSphere cluster VM orchestration settings.
//
// Used by vSphere HA when restarting failed VMs. For example, if a host
// fails, vSphere HA identifies the list of VMs to be restarted. The order in
// which the failed VMs to be restarted is determined by:
//   - VM restart priority setting (`ClusterDasVmSettings.restartPriority`).
//     Lower priority VMs are restarted only after higher priority VMs are
//     restarted and ready (`ClusterVmReadiness`).
//   - VM dependency rule (`ClusterDependencyRuleInfo`). If a VM
//     depends on other VMs, then it will be restarted only after all the VMs in
//     its dependency list are ready. Cyclic dependency is not permitted across
//     VMs. Also, higher priority VMs cannot depend on lower priority VMs.
type ClusterOrchestrationInfo struct {
	DynamicData

	// Cluster-wide defaults for virtual machine readiness
	DefaultVmReadiness *ClusterVmReadiness `xml:"defaultVmReadiness,omitempty" json:"defaultVmReadiness,omitempty"`
}

func init() {
	t["ClusterOrchestrationInfo"] = reflect.TypeOf((*ClusterOrchestrationInfo)(nil)).Elem()
}

// This event records when a cluster's host capacity cannot satisfy resource
// configuration constraints.
type ClusterOvercommittedEvent struct {
	ClusterEvent
}

func init() {
	t["ClusterOvercommittedEvent"] = reflect.TypeOf((*ClusterOvercommittedEvent)(nil)).Elem()
}

// PowerOnVmResult is the base class of the result returned to the
// `Datacenter.PowerOnMultiVM_Task` method.
type ClusterPowerOnVmResult struct {
	DynamicData

	// The list of virtual machines the Virtual Center has attempted to power on.
	//
	// For a virtual machine not managed by DRS, a task ID is also returned.
	Attempted []ClusterAttemptedVmInfo `xml:"attempted,omitempty" json:"attempted,omitempty"`
	// The list of virtual machines DRS can not find suitable hosts for powering on.
	//
	// There is one fault associated with each virtual machine.
	NotAttempted []ClusterNotAttemptedVmInfo `xml:"notAttempted,omitempty" json:"notAttempted,omitempty"`
	// The list of recommendations that need the client to approve manually.
	Recommendations []ClusterRecommendation `xml:"recommendations,omitempty" json:"recommendations,omitempty"`
}

func init() {
	t["ClusterPowerOnVmResult"] = reflect.TypeOf((*ClusterPowerOnVmResult)(nil)).Elem()
}

// The `ClusterPreemptibleVmPairInfo` data object contains the monitored and the
// preemptible VM pair in a HA-enabled cluster.
//
// Monitored virtual machine is a desired protected virtual machine in
// HA-enabled cluster when it is powered on. Any failures of this VM will
// continue to be handled by HA based on the VM's settings in cluster.
//
// Preemptible virtual machine is the desired protected virtual machine in HA
// when it is powered on. The lowest restart priority "disabled"
// `ClusterDasVmSettingsRestartPriority_enum` will be enforced for the
// `ClusterPreemptibleVmPairInfo.preemptibleVm`. A virtual machine can be marked as preemptible
// irrespective of its `powerState` but its
// extra configuration should identify it as preemptible.
//
// In case of failure of `ClusterPreemptibleVmPairInfo.monitoredVm`, the `ClusterPreemptibleVmPairInfo.preemptibleVm` will
// be terminated. This will free up any resources associated with
// `ClusterPreemptibleVmPairInfo.preemptibleVm`.
//
// In case of insufficient resources for failover of any VM in the cluster, the
// `ClusterPreemptibleVmPairInfo.preemptibleVm` will be terminated to free up resources.
//
// This data object is intended for VMware use and other usage is not
// supported. This data object will be removed in a future release.
type ClusterPreemptibleVmPairInfo struct {
	DynamicData

	// Server-assigned unique ID for pairs.
	//
	// When adding a new pair, do not
	// specify this property. The server will assign the key and any assigned
	// value will be ignored.
	Id int32 `xml:"id,omitempty" json:"id,omitempty"`
	// The virtual machine whose failure will cause the virtual machine specified
	// by `ClusterPreemptibleVmPairInfo.preemptibleVm` to be terminated.
	//
	// Refers instance of `VirtualMachine`.
	MonitoredVm ManagedObjectReference `xml:"monitoredVm" json:"monitoredVm"`
	// The preemptible virtual machine associated with the virtual machine
	// specified as `ClusterPreemptibleVmPairInfo.monitoredVm`.
	//
	// Refers instance of `VirtualMachine`.
	PreemptibleVm ManagedObjectReference `xml:"preemptibleVm" json:"preemptibleVm"`
}

func init() {
	t["ClusterPreemptibleVmPairInfo"] = reflect.TypeOf((*ClusterPreemptibleVmPairInfo)(nil)).Elem()
	minAPIVersionForType["ClusterPreemptibleVmPairInfo"] = "8.0.0.1"
}

// Provides monitored and preemptible VM pair along with any of the operations
// (add, edit or remove) to append, modify or remove this pair info from
// `ClusterPreemptibleVmPairInfo` list.
//
// This data object is intended for VMware use and other usage is not supported.
// This data object will be removed in a future release.
type ClusterPreemptibleVmPairSpec struct {
	ArrayUpdateSpec

	Info *ClusterPreemptibleVmPairInfo `xml:"info,omitempty" json:"info,omitempty"`
}

func init() {
	t["ClusterPreemptibleVmPairSpec"] = reflect.TypeOf((*ClusterPreemptibleVmPairSpec)(nil)).Elem()
	minAPIVersionForType["ClusterPreemptibleVmPairSpec"] = "8.0.0.1"
}

type ClusterProactiveDrsConfigInfo struct {
	DynamicData

	// Flag indicating whether or not the service is enabled.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
}

func init() {
	t["ClusterProactiveDrsConfigInfo"] = reflect.TypeOf((*ClusterProactiveDrsConfigInfo)(nil)).Elem()
}

// DataObject completely specifying the configuration of
// the profile.
type ClusterProfileCompleteConfigSpec struct {
	ClusterProfileConfigSpec

	// User defined compliance profile for the cluster.
	//
	// If unset, clear the complyProfile.
	ComplyProfile *ComplianceProfile `xml:"complyProfile,omitempty" json:"complyProfile,omitempty"`
}

func init() {
	t["ClusterProfileCompleteConfigSpec"] = reflect.TypeOf((*ClusterProfileCompleteConfigSpec)(nil)).Elem()
}

type ClusterProfileConfigInfo struct {
	ProfileConfigInfo

	// Compliance profile for the cluster
	ComplyProfile *ComplianceProfile `xml:"complyProfile,omitempty" json:"complyProfile,omitempty"`
}

func init() {
	t["ClusterProfileConfigInfo"] = reflect.TypeOf((*ClusterProfileConfigInfo)(nil)).Elem()
}

// DataObject which allows reconfiguration of a profile
// based on services that will be available on the cluster.
type ClusterProfileConfigServiceCreateSpec struct {
	ClusterProfileConfigSpec

	// Type of the service for which the ClusterProfile is being requested.
	//
	// If more than one service is specified, the created ClusterProfile
	// will cater for all the services.
	// Possible values are specified by
	// `ClusterProfileServiceType_enum`.
	// If unset, clear the compliance expressions on the profile.
	ServiceType []string `xml:"serviceType,omitempty" json:"serviceType,omitempty"`
}

func init() {
	t["ClusterProfileConfigServiceCreateSpec"] = reflect.TypeOf((*ClusterProfileConfigServiceCreateSpec)(nil)).Elem()
}

// DataObject which is a baseclass for other configuration
// specifications.
type ClusterProfileConfigSpec struct {
	ClusterProfileCreateSpec
}

func init() {
	t["ClusterProfileConfigSpec"] = reflect.TypeOf((*ClusterProfileConfigSpec)(nil)).Elem()
}

// Base class for Cluster CreateSpecs
type ClusterProfileCreateSpec struct {
	ProfileCreateSpec
}

func init() {
	t["ClusterProfileCreateSpec"] = reflect.TypeOf((*ClusterProfileCreateSpec)(nil)).Elem()
}

// Recommendation is the base class for any packaged group of
// actions that are intended to take the system from one
// state to another one.
type ClusterRecommendation struct {
	DynamicData

	// Key to identify the recommendation when calling applyRecommendation.
	Key string `xml:"key" json:"key"`
	// Type of the recommendation.
	//
	// This differentiates between various
	// of recommendations aimed at achieving different goals.
	Type string `xml:"type" json:"type"`
	// The time this recommendation was computed.
	Time time.Time `xml:"time" json:"time"`
	// A rating of the recommendation.
	//
	// Valid values range from 1 (lowest confidence) to 5 (highest confidence).
	Rating int32 `xml:"rating" json:"rating"`
	// A reason code explaining why this set of migrations is being suggested.
	Reason string `xml:"reason" json:"reason"`
	// Text that provides more information about the reason code for the suggested
	// set of migrations.
	ReasonText string `xml:"reasonText" json:"reasonText"`
	// Text that provides warnings about potential adverse implications of
	// applying this recommendation
	WarningText string `xml:"warningText,omitempty" json:"warningText,omitempty"`
	// Warning about potential adverse implications of applying a recommendation
	WarningDetails *LocalizableMessage `xml:"warningDetails,omitempty" json:"warningDetails,omitempty"`
	// This recommendation may depend on some other recommendations.
	//
	// The prerequisite recommendations are listed by their keys.
	Prerequisite []string `xml:"prerequisite,omitempty" json:"prerequisite,omitempty"`
	// List of actions that are executed as part of this recommendation
	Action []BaseClusterAction `xml:"action,omitempty,typeattr" json:"action,omitempty"`
	// The target object of this recommendation.
	Target *ManagedObjectReference `xml:"target,omitempty" json:"target,omitempty"`
}

func init() {
	t["ClusterRecommendation"] = reflect.TypeOf((*ClusterRecommendation)(nil)).Elem()
}

// This event records when a cluster is reconfigured.
type ClusterReconfiguredEvent struct {
	ClusterEvent

	// The configuration values changed during the reconfiguration.
	ConfigChanges *ChangesInfoEventArgument `xml:"configChanges,omitempty" json:"configChanges,omitempty"`
}

func init() {
	t["ClusterReconfiguredEvent"] = reflect.TypeOf((*ClusterReconfiguredEvent)(nil)).Elem()
}

// This class contains cpu, memory and storage usage information at cluster
// level.
type ClusterResourceUsageSummary struct {
	DynamicData

	CpuUsedMHz        int32 `xml:"cpuUsedMHz" json:"cpuUsedMHz"`
	CpuCapacityMHz    int32 `xml:"cpuCapacityMHz" json:"cpuCapacityMHz"`
	MemUsedMB         int32 `xml:"memUsedMB" json:"memUsedMB"`
	MemCapacityMB     int32 `xml:"memCapacityMB" json:"memCapacityMB"`
	PMemAvailableMB   int64 `xml:"pMemAvailableMB,omitempty" json:"pMemAvailableMB,omitempty"`
	PMemCapacityMB    int64 `xml:"pMemCapacityMB,omitempty" json:"pMemCapacityMB,omitempty"`
	StorageUsedMB     int64 `xml:"storageUsedMB" json:"storageUsedMB"`
	StorageCapacityMB int64 `xml:"storageCapacityMB" json:"storageCapacityMB"`
}

func init() {
	t["ClusterResourceUsageSummary"] = reflect.TypeOf((*ClusterResourceUsageSummary)(nil)).Elem()
}

// The `ClusterRuleInfo` data object is the base type for affinity
// and anti-affinity rules.
//
// The affinity and anti-affinity rules
// are DRS (Distributed Resource Scheduling) rules that affect the placement
// of virtual machines in a cluster. Hosts and virtual machines referenced
// in a DRS rule must be in the same cluster.
//
// Note: DRS rules are different than an individual host's CPU affinity rules
// (`VirtualMachineAffinityInfo`).
//
// The Server uses DRS rule objects to describe the current rule configuration
// (`ClusterConfigInfoEx*.*ClusterConfigInfoEx.rule`).
// Your client application uses rule objects to configure the affinity and
// anti-affinity rules
// (`ClusterConfigSpecEx*.*ClusterConfigSpecEx.rulesSpec`).
//
// You can create the following types of rules:
//   - An affinity rule defines a set of virtual machines that should run
//     on the same host.
//     The `ClusterAffinityRuleSpec` object describes a rule that
//     identifies virtual machines, but does not identify any specific host.
//   - An anti-affinity rule defines a set of virtual machines that should run
//     on different hosts.
//     The `ClusterAntiAffinityRuleSpec` object describes a rule that
//     identifies virtual machines, but does not identify any specific host.
//   - A VM-Host rule defines affinity and anti-affinity relationships between
//     virtual machines and hosts.
//     The `ClusterVmHostRuleInfo` object describes a rule that identifies
//     a virtual machine group (`ClusterVmGroup`) and affinity and
//     anti-affinity host groups (`ClusterHostGroup`).
//
// Rule configuration is a dynamic process. When you create or modify a DRS rule,
// the Server applies the rule to the cluster. If the existing cluster configuration
// violates the rule, the Server attempts to correct the situation. If that is not
// possible, the Server generates a fault and produces a log event.
// DRS rules do not have precedence; all rules are applied equally.
// DRS does not validate one rule against another. If you create conflicting
// rules, the older rule takes precedence and DRS disables the newer rule.
//
// Improperly used, DRS rules can fragment the cluster and inhibit the proper
// functioning of DRS, HA, and DPM services. vSphere services never
// take any actions that would result in the violation of mandatory DRS rules.
// An operation that violates a mandatory rule would produce the following
// consequences.
//   - DRS does not evacuate virtual machines to place a host in maintenance
//     mode.
//   - DRS does not place virtual machines for power-on or load balance virtual
//     machines.
//   - HA does not perform failovers.
//   - DPM does not optimize power management by placing hosts into standby
//     mode.
//
// To avoid these situations, exercise caution when creating more than one
// mandatory rule, or consider using only optional rules. Make sure that
// the number of hosts with which a virtual machine is related by affinity rule
// is large enough that losing a host does not prevent the virtual machine
// from running.
//
// For manual and partially automated DRS clusters, the Server produces migration
// recommendations to satisfy the DRS rules. You are not required to act on the
// recommendations, but the Server maintains the recommendations until the rules
// are satisfied.
type ClusterRuleInfo struct {
	DynamicData

	// Unique ID for rules.
	//
	// When adding a new rule, do not specify this property.
	// The Server will assign the key.
	Key int32 `xml:"key,omitempty" json:"key,omitempty"`
	// Flag to indicate whether or not the rule is currently satisfied.
	Status ManagedEntityStatus `xml:"status,omitempty" json:"status,omitempty"`
	// Flag to indicate whether or not the rule is enabled.
	//
	// Set this property
	// when you configure the rule. The default value is false (disabled).
	// If there is a rule conflict, the Server can override the setting to disable
	// a rule.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Name of the rule.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// Flag to indicate whether compliance with this rule is mandatory or optional.
	//
	// The default value is false (optional).
	//   - A mandatory rule will prevent a virtual machine from being powered on
	//     or migrated to a host that does not satisfy the rule.
	//   - An optional rule specifies a preference. DRS takes an optional rule
	//     into consideration when it places a virtual machine in the cluster.
	//     DRS will act on an optional rule as long as it does not impact
	//     the ability of the host to satisfy current CPU or memory requirements
	//     for virtual machines on the system. (As long as the operation does not
	//     cause any host to be more than 100% utilized.)
	Mandatory *bool `xml:"mandatory" json:"mandatory,omitempty"`
	// Flag to indicate whether the rule is created by the user or the system.
	UserCreated *bool `xml:"userCreated" json:"userCreated,omitempty"`
	// Flag to indicate whether or not the placement of Virtual Machines is currently
	// in compliance with this rule.
	//
	// The Server does not currently use this property.
	InCompliance *bool `xml:"inCompliance" json:"inCompliance,omitempty"`
	// UUID for the rule.
	//
	// When adding a new rule, do not specify this
	// property. The Server will assign the key.
	RuleUuid string `xml:"ruleUuid,omitempty" json:"ruleUuid,omitempty"`
}

func init() {
	t["ClusterRuleInfo"] = reflect.TypeOf((*ClusterRuleInfo)(nil)).Elem()
}

// An incremental update to the cluster rules.
type ClusterRuleSpec struct {
	ArrayUpdateSpec

	Info BaseClusterRuleInfo `xml:"info,omitempty,typeattr" json:"info,omitempty"`
}

func init() {
	t["ClusterRuleSpec"] = reflect.TypeOf((*ClusterRuleSpec)(nil)).Elem()
}

// The base class `ClusterSlotPolicy` is used for specifying how
// the slot size is to be computed for the failover level HA admission control
// policy.
//
// By default, vSphere HA defines the slot size using the largest memory
// and cpu reservations of any powered on virtual machine in the cluster.
// Subclasses of this class define various policies to modify how the slot size
// is chosen to prevent outlier virtual machines (i.e. those with much larger
// reservations than the average) from skewing the slot size. If such a policy is chosen,
// outlier virtual machines will use multiple slots. Using such a policy introduces
// a risk that vSphere HA will be unable to failover these virtual machines because
// of resource fragmentation.
type ClusterSlotPolicy struct {
	DynamicData
}

func init() {
	t["ClusterSlotPolicy"] = reflect.TypeOf((*ClusterSlotPolicy)(nil)).Elem()
}

// This event records when a cluster's overall status changed.
type ClusterStatusChangedEvent struct {
	ClusterEvent

	// The old (`status`).
	OldStatus string `xml:"oldStatus" json:"oldStatus"`
	// The new (`status`).
	NewStatus string `xml:"newStatus" json:"newStatus"`
}

func init() {
	t["ClusterStatusChangedEvent"] = reflect.TypeOf((*ClusterStatusChangedEvent)(nil)).Elem()
}

// Configuration for System VMs deployment.
type ClusterSystemVMsConfigInfo struct {
	DynamicData

	// The only datastores which can be used for System VMs deployment.
	//
	// Refers instances of `Datastore`.
	AllowedDatastores []ManagedObjectReference `xml:"allowedDatastores,omitempty" json:"allowedDatastores,omitempty"`
	// Datastores which cannot be used for System VMs deployment.
	//
	// Refers instances of `Datastore`.
	NotAllowedDatastores []ManagedObjectReference `xml:"notAllowedDatastores,omitempty" json:"notAllowedDatastores,omitempty"`
	// Tag categories identifying datastores, which cannot be used for System VMs
	// deployment.
	DsTagCategoriesToExclude []string `xml:"dsTagCategoriesToExclude,omitempty" json:"dsTagCategoriesToExclude,omitempty"`
	// The System VM deployment mode for vSphere clusters.
	//
	// Supported values are enumerated by the
	// `DeploymentMode`
	// type.
	// An unset value implies SYSTEM\_MANAGED,
	// unless the cluster is put in "Retreat Mode".
	DeploymentMode string `xml:"deploymentMode,omitempty" json:"deploymentMode,omitempty" vim:"8.0.2.0"`
}

func init() {
	t["ClusterSystemVMsConfigInfo"] = reflect.TypeOf((*ClusterSystemVMsConfigInfo)(nil)).Elem()
	minAPIVersionForType["ClusterSystemVMsConfigInfo"] = "7.0.3.0"
}

// Configuration for System VMs deployment.
type ClusterSystemVMsConfigSpec struct {
	DynamicData

	// The only datastores which can be used for System VMs deployment.
	AllowedDatastores []ClusterDatastoreUpdateSpec `xml:"allowedDatastores,omitempty" json:"allowedDatastores,omitempty"`
	// Datastores which cannot be used for System VMs deployment.
	NotAllowedDatastores []ClusterDatastoreUpdateSpec `xml:"notAllowedDatastores,omitempty" json:"notAllowedDatastores,omitempty"`
	// Tag categories identifying datastores, which cannot be used for System VMs
	// deployment.
	DsTagCategoriesToExclude []ClusterTagCategoryUpdateSpec `xml:"dsTagCategoriesToExclude,omitempty" json:"dsTagCategoriesToExclude,omitempty"`
	// The System VM deployment mode for vSphere clusters.
	//
	// Supported values are enumerated by the
	// `DeploymentMode`
	// type.
	// Providing an unset value does not modify deploymentMode.
	DeploymentMode string `xml:"deploymentMode,omitempty" json:"deploymentMode,omitempty" vim:"8.0.2.0"`
}

func init() {
	t["ClusterSystemVMsConfigSpec"] = reflect.TypeOf((*ClusterSystemVMsConfigSpec)(nil)).Elem()
	minAPIVersionForType["ClusterSystemVMsConfigSpec"] = "7.0.3.0"
}

// An incremental update to a TagCategory list.
type ClusterTagCategoryUpdateSpec struct {
	ArrayUpdateSpec

	Category string `xml:"category,omitempty" json:"category,omitempty"`
}

func init() {
	t["ClusterTagCategoryUpdateSpec"] = reflect.TypeOf((*ClusterTagCategoryUpdateSpec)(nil)).Elem()
	minAPIVersionForType["ClusterTagCategoryUpdateSpec"] = "7.0.3.0"
}

// This class contains cluster usage summary that is populated
// by DRS and used by Cloud Placement Engine in VCD.
type ClusterUsageSummary struct {
	DynamicData

	// Total CPU capacity of the cluster.
	TotalCpuCapacityMhz int32 `xml:"totalCpuCapacityMhz" json:"totalCpuCapacityMhz"`
	// Total memory capacity of the cluster.
	TotalMemCapacityMB int32 `xml:"totalMemCapacityMB" json:"totalMemCapacityMB"`
	// Sum of CPU reservation of all the Resource Pools and powered-on VMs in the cluster.
	CpuReservationMhz int32 `xml:"cpuReservationMhz" json:"cpuReservationMhz"`
	// Sum of memory reservation of all the Resource Pools and powered-on VMs in the cluster.
	MemReservationMB int32 `xml:"memReservationMB" json:"memReservationMB"`
	// Sum of CPU reservation of all the powered-off VMs in the cluster.
	PoweredOffCpuReservationMhz int32 `xml:"poweredOffCpuReservationMhz,omitempty" json:"poweredOffCpuReservationMhz,omitempty"`
	// Sum of memory reservation of all the powered-off VMs in the cluster.
	PoweredOffMemReservationMB int32 `xml:"poweredOffMemReservationMB,omitempty" json:"poweredOffMemReservationMB,omitempty"`
	// Sum of CPU demand of all the powered-on VMs in the cluster.
	CpuDemandMhz int32 `xml:"cpuDemandMhz" json:"cpuDemandMhz"`
	// Sum of memory demand of all the powered-on VMs in the cluster.
	MemDemandMB int32 `xml:"memDemandMB" json:"memDemandMB"`
	// Generation number of the usage stats.
	//
	// Updated during every DRS load
	// balancing call.
	StatsGenNumber int64 `xml:"statsGenNumber" json:"statsGenNumber"`
	// This is the current CPU entitlement across the cluster
	CpuEntitledMhz int32 `xml:"cpuEntitledMhz" json:"cpuEntitledMhz"`
	// This is the current memory entitlement across the cluster
	MemEntitledMB int32 `xml:"memEntitledMB" json:"memEntitledMB"`
	// The number of powered off VMs in the cluster
	PoweredOffVmCount int32 `xml:"poweredOffVmCount" json:"poweredOffVmCount"`
	// The number of VMs in the cluster
	TotalVmCount int32 `xml:"totalVmCount" json:"totalVmCount"`
}

func init() {
	t["ClusterUsageSummary"] = reflect.TypeOf((*ClusterUsageSummary)(nil)).Elem()
}

// vSphere HA Virtual Machine Component Protection Service settings.
//
// vSphere HA Virtual Machine Component Protection Service detects
// and reacts to storage failures that do not necessarily cause a
// virtual machine to go down, but may impact the health or QoS of
// the virtual machine.
//
// All fields are defined as optional. In case of a reconfiguration, fields left unset
// are not changed.
type ClusterVmComponentProtectionSettings struct {
	DynamicData

	// VM storage protection setting for storage failures categorized as All Paths
	// Down (APD).
	//
	// APD is a condition where a storage has become inaccessible
	// for unknown reasons. It only indicates loss of connectivity and does not indicate
	// storage device failure or LUN removal (Permenant Device Loss or PDL). The details
	// of APD and PDL are described in `HostMountInfoInaccessibleReason_enum`.
	//
	// This property is meaningful only when vSphere HA is turned on. Valid values are
	// specified by `ClusterVmComponentProtectionSettingsStorageVmReaction_enum`. The default value is
	// `disabled` for cluster setting and
	// `clusterDefault` for per-VM setting.
	//
	// When an APD condition happens and the host begins timing out I/Os
	// (@link vim.host.MountInfo.InaccessibleReason#AllPathsDown\_Timeout}, VM Component
	// Protection service will react based on the specific value of this property:
	//   - `**disabled**`, no reaction, i.e., no
	//     VM failover and no event reporting for the failures.
	//   - `**warning**`, service will issue events,
	//     alarms and/or config issues for component failures.
	//   - `**restartConservative**`, service will
	//     terminate the impacted VMs after a preconfigured time interval
	//     (`ClusterVmComponentProtectionSettings.vmTerminateDelayForAPDSec`) if they are to be restarted.
	//   - `**restartAggressive**`, service might
	//     terminate the impacted VMs after a preconfigured time interval
	//     (`ClusterVmComponentProtectionSettings.vmTerminateDelayForAPDSec`). In some cases, a VM is terminated
	//     even if it may not able to be restarted or lose Fault Tolerance redundancy.
	//   - `**clusterDefault**`, service will implement
	//     cluster default.
	VmStorageProtectionForAPD string `xml:"vmStorageProtectionForAPD,omitempty" json:"vmStorageProtectionForAPD,omitempty"`
	// This property indicates if APD timeout will be enabled for all the hosts
	// in the cluster when vSphere HA is configured.
	//
	// The details of APD timeout are
	// described in `HostMountInfoInaccessibleReason_enum`.
	//
	// If `ClusterDasConfigInfo.vmComponentProtecting` is `disabled`,
	// the property will be ignored. Otherwise, for each host in the cluster,
	// APD timeout will be enabled. Note that no change will be made for a host if it
	// already had APD timeout enabled.
	//
	// This property is meaningful only for cluster setting. It is ignored if specified at VM level.
	// The default value is false if not specified.
	//
	// Note that this property is not persisted by vSphere backend. It does not impact any cluster
	// reconfiguration or host operation (such as adding a host to a cluster) that might happen later.
	EnableAPDTimeoutForHosts *bool `xml:"enableAPDTimeoutForHosts" json:"enableAPDTimeoutForHosts,omitempty"`
	// The time interval after an APD timeout has been declared and before VM Component
	// Protection service will terminate the VM.
	//
	// The value only applies if
	// `ClusterVmComponentProtectionSettings.vmStorageProtectionForAPD` is set to `restartConservative` or
	// `restartAggressive`.
	//
	// The default value is 180 seconds if not specified. To use cluster setting for a VM override,
	// set to -1 in per-VM setting.
	VmTerminateDelayForAPDSec int32 `xml:"vmTerminateDelayForAPDSec,omitempty" json:"vmTerminateDelayForAPDSec,omitempty"`
	// Action taken by VM Component Protection service for a powered on VM when APD
	// condition clears after APD timeout.
	//
	// This property is meaningful only when vSphere HA is turned on. Valid values are
	// specified by `ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared_enum`. The default value is
	// `none` for cluster setting and
	// `useClusterDefault` for per-VM setting.
	VmReactionOnAPDCleared string `xml:"vmReactionOnAPDCleared,omitempty" json:"vmReactionOnAPDCleared,omitempty"`
	// VM storage protection setting for storage failures categorized as Permenant Device
	// Loss (PDL).
	//
	// PDL indicates storage device failure or LUN removal. In case of PDL,
	// the failed datastore or device is unlikely to recover. The details of PDL are
	// described in `HostMountInfoInaccessibleReason_enum`.
	//
	// This property is meaningful only when vSphere HA is turned on. Valid values are
	// `disabled`, `warning`,
	// `restartAggressive` and `clusterDefault`.
	// The default value is `disabled` for cluster setting and
	// `clusterDefault` for per-VM setting.
	//
	// When set to `restartAggressive`, VM Component Protection service
	// will immediately terminate the VMs impacted by PDL and will attempt to restart the VMs
	// with best effort. When set to the other values, the behavior is the same as described for
	// `ClusterVmComponentProtectionSettings.vmStorageProtectionForAPD`.
	VmStorageProtectionForPDL string `xml:"vmStorageProtectionForPDL,omitempty" json:"vmStorageProtectionForPDL,omitempty"`
}

func init() {
	t["ClusterVmComponentProtectionSettings"] = reflect.TypeOf((*ClusterVmComponentProtectionSettings)(nil)).Elem()
}

// The `ClusterVmGroup` data object identifies virtual machines
// for VM-Host rules.
//
// VM-Host rules determine placement of virtual machines
// on hosts in a cluster.
// The logic specified in a `ClusterVmHostRuleInfo` object
// determines where virtual machines can be powered-on.
//
// If a virtual machine is removed from the cluster, it loses its DRS group
// affiliation. The Server does not restore any group affiliations if the
// virtual machine is returned to the cluster.
type ClusterVmGroup struct {
	ClusterGroupInfo

	// List of virtual machines that are part of this group.
	//
	// A virtual machine group can contain zero or more virtual machines.
	//
	// Refers instances of `VirtualMachine`.
	Vm []ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
}

func init() {
	t["ClusterVmGroup"] = reflect.TypeOf((*ClusterVmGroup)(nil)).Elem()
}

// A `ClusterVmHostRuleInfo` object identifies virtual machines
// and host groups that determine virtual machine placement. The virtual
// machines and hosts referenced by a VM-Host rule must be in the same cluster.
//
// A VM-Host rule identifies the following groups.
//   - A virtual machine group (`ClusterVmGroup`).
//   - Two host groups - an affine host group and an anti-affine host group
//     (`ClusterHostGroup`).
//     At least one of the groups must contain one or more hosts.
//
// `ClusterVmHostRuleInfo` stores only the names of the relevant
// virtual machine and host groups. The group contents are stored in
// the virtual machine and host group objects.
//
// When you modify a VM-Host rule, only the fields that are specified are set.
type ClusterVmHostRuleInfo struct {
	ClusterRuleInfo

	// Virtual group name (`ClusterVmGroup*.*ClusterGroupInfo.name`).
	//
	// The virtual group may contain one or more virtual machines.
	VmGroupName string `xml:"vmGroupName,omitempty" json:"vmGroupName,omitempty"`
	// Name of the affine host group
	// (`ClusterHostGroup*.*ClusterGroupInfo.name`).
	//
	// The affine host group identifies hosts on which
	// `ClusterVmHostRuleInfo.vmGroupName` virtual machines can be powered-on.
	// The value of the `ClusterRuleInfo.mandatory` property
	// determines how the Server interprets the rule.
	AffineHostGroupName string `xml:"affineHostGroupName,omitempty" json:"affineHostGroupName,omitempty"`
	// Name of the anti-affine host group
	// (`ClusterHostGroup*.*ClusterGroupInfo.name`).
	//
	// The anti-affine host group identifies hosts on which
	// `ClusterVmHostRuleInfo.vmGroupName` virtual machines should not
	// be powered-on.
	// The value of the `ClusterRuleInfo.mandatory` property
	// determines how the Server interprets the rule.
	AntiAffineHostGroupName string `xml:"antiAffineHostGroupName,omitempty" json:"antiAffineHostGroupName,omitempty"`
}

func init() {
	t["ClusterVmHostRuleInfo"] = reflect.TypeOf((*ClusterVmHostRuleInfo)(nil)).Elem()
}

// The `ClusterVmOrchestrationInfo` data object contains the orchestration
// configuration for a single virtual machine.
//
// This makes it possible to
// override the defaut behavior for an individual virtual machine.
type ClusterVmOrchestrationInfo struct {
	DynamicData

	// Reference to the VM that the ready state is applied to.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Readiness policy that apply to this virtual machine.
	//
	// Values specified in this object override the cluster-wide
	// defaults for virtual machines.
	// `ClusterOrchestrationInfo.defaultVmReadiness`
	VmReadiness ClusterVmReadiness `xml:"vmReadiness" json:"vmReadiness"`
}

func init() {
	t["ClusterVmOrchestrationInfo"] = reflect.TypeOf((*ClusterVmOrchestrationInfo)(nil)).Elem()
}

// An incremental update to the per-VM orchestration config.
type ClusterVmOrchestrationSpec struct {
	ArrayUpdateSpec

	Info *ClusterVmOrchestrationInfo `xml:"info,omitempty" json:"info,omitempty"`
}

func init() {
	t["ClusterVmOrchestrationSpec"] = reflect.TypeOf((*ClusterVmOrchestrationSpec)(nil)).Elem()
}

// VM readiness policy specifies when a VM is deemed ready.
//
// This is used in cluster VM orchestration settings. For example, vSphere HA
// restarts lower priority VMs only after higher priority VMs are ready.
type ClusterVmReadiness struct {
	DynamicData

	// Ready condition for a virtual machine.
	//
	// See `ClusterVmReadinessReadyCondition_enum`.
	//
	// If not specified at either the cluster level or the virtual machine
	// level, this will default to `none`.
	ReadyCondition string `xml:"readyCondition,omitempty" json:"readyCondition,omitempty"`
	// Additional delay in seconds after ready condition is met.
	//
	// A VM is
	// considered ready at this point.
	//
	// If not specified in a VM override, cluster default setting is
	// used. Alternatively, set to -1 in per-VM setting to use cluster default
	// value.
	PostReadyDelay int32 `xml:"postReadyDelay,omitempty" json:"postReadyDelay,omitempty"`
}

func init() {
	t["ClusterVmReadiness"] = reflect.TypeOf((*ClusterVmReadiness)(nil)).Elem()
}

// The `ClusterVmToolsMonitoringSettings` data object contains
// virtual machine monitoring settings that are used by the Virtual Machine Health Monitoring Service.
//
// The Service checks the VMware Tools heartbeat of a virtual machine.
// If heartbeats have not been received within a specified time interval, the Service
// declares the virtual machine as failed and resets the virtual machine.
//
// These settings are applied to individual virtual machines during cluster reconfiguration
// (`ClusterDasVmConfigInfo*.*ClusterDasVmConfigInfo.dasSettings*.*ClusterDasVmSettings.vmToolsMonitoringSettings`). You can also specify them as default values
// (`ClusterDasConfigInfo*.*ClusterDasConfigInfo.defaultVmSettings`).
//
// All fields are optional. In case of a reconfiguration, fields left unset are not changed.
type ClusterVmToolsMonitoringSettings struct {
	DynamicData

	// Deprecated as of vSphere API 4.1, use `ClusterVmToolsMonitoringSettings.vmMonitoring`.
	//
	// Flag indicating whether or not the Virtual Machine Health Monitoring
	// service is enabled.
	//
	// The Server does not use this property.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Indicates the type of virtual machine monitoring.
	//
	// Specify a string value corresponding to one of the
	// following `ClusterDasConfigInfoVmMonitoringState_enum` values:
	//   - <code>vmMonitoringDisabled</code> (the default value)
	//   - <code>vmMonitoringOnly</code>
	//   - <code>vmAndAppMonitoring</code>
	//
	// The individual VMware Tools setting for virtual machine monitoring depends on
	// the HA Virtual Machine Health Monitoring Service level that is
	// defined for the cluster
	// (`ClusterDasConfigInfo*.*ClusterDasConfigInfo.vmMonitoring`).
	// The following list indicates the supported VMware Tools <code>vmMonitoring</code> values
	// according to the cluster configuration.
	//   - If the cluster configuration specifies <code>vmMonitoringDisabled</code>,
	//     the Service is disabled and the HA Service ignores the VMware Tools monitoring setting.
	//   - If the cluster configuration specifies <code>vmMonitoringOnly</code>,
	//     the Service supports <code>vmMonitoringOnly</code> or <code>vmMonitoringDisabled</code> only.
	//   - If the cluster configuration specifies <code>vmAndAppMonitoring</code>,
	//     you can use any of the `ClusterDasConfigInfoVmMonitoringState_enum` values.
	//
	// The `ClusterVmToolsMonitoringSettings.clusterSettings` value has no
	// effect on the constraint imposed by the HA Virtual Machine Health Monitoring Service
	// level that is defined for the cluster
	// (`ClusterDasConfigInfo*.*ClusterDasConfigInfo.vmMonitoring`).
	//
	// Application monitoring events are generated regardless of the
	// currently configured type of virtual machine monitoring.
	// You can use these events even if monitoring is being disabled
	// or set to <code>vmMonitoringOnly</code>.
	VmMonitoring string `xml:"vmMonitoring,omitempty" json:"vmMonitoring,omitempty"`
	// Flag indicating whether to use the cluster settings or the per VM settings.
	//
	// The default value is true.
	ClusterSettings *bool `xml:"clusterSettings" json:"clusterSettings,omitempty"`
	// If no heartbeat has been received for at least the specified number of seconds,
	// the virtual machine is declared as failed.
	//
	// The default value is 30.
	FailureInterval int32 `xml:"failureInterval,omitempty" json:"failureInterval,omitempty"`
	// The number of seconds for the virtual machine's heartbeats to stabilize
	// after the virtual machine has been powered on.
	//
	// This time should include
	// the guest operating system boot-up time. The virtual machine monitoring
	// will begin only after this period.
	//
	// The default value is 120.
	MinUpTime int32 `xml:"minUpTime,omitempty" json:"minUpTime,omitempty"`
	// Maximum number of failures and automated resets allowed during the time that
	// `ClusterVmToolsMonitoringSettings.maxFailureWindow` specifies.
	//
	// If `ClusterVmToolsMonitoringSettings.maxFailureWindow` is -1
	// (no window), this represents the absolute number of failures after which
	// automated response is stopped.
	//
	// If a virtual machine exceeds this threshold, in-depth problem analysis is
	// usually needed.
	//
	// The default value is 3.
	MaxFailures int32 `xml:"maxFailures,omitempty" json:"maxFailures,omitempty"`
	// The number of seconds for the window during which up to `ClusterVmToolsMonitoringSettings.maxFailures`
	// resets can occur before automated responses stop.
	//
	// If set to -1, no failure window is specified.
	//
	// The default value is -1.
	MaxFailureWindow int32 `xml:"maxFailureWindow,omitempty" json:"maxFailureWindow,omitempty"`
}

func init() {
	t["ClusterVmToolsMonitoringSettings"] = reflect.TypeOf((*ClusterVmToolsMonitoringSettings)(nil)).Elem()
}

// The distributed virtual switch received a reconfiguration request to
// activate ipfix monitoring of the switch traffic.
//
// However, the address
// and/or the port of the ipfix collector has not been specified.
type CollectorAddressUnset struct {
	DvsFault
}

func init() {
	t["CollectorAddressUnset"] = reflect.TypeOf((*CollectorAddressUnset)(nil)).Elem()
}

type CollectorAddressUnsetFault CollectorAddressUnset

func init() {
	t["CollectorAddressUnsetFault"] = reflect.TypeOf((*CollectorAddressUnsetFault)(nil)).Elem()
}

type ComplianceFailure struct {
	DynamicData

	// String uniquely identifying the failure.
	FailureType string `xml:"failureType" json:"failureType"`
	// Message which describes the compliance failures
	// message.key serves as a key to the localized
	// message catalog.
	Message LocalizableMessage `xml:"message" json:"message"`
	// Name of the Expression which generated the ComplianceFailure
	ExpressionName string `xml:"expressionName,omitempty" json:"expressionName,omitempty"`
	// If complianceStatus is non-compliant, failureValues will
	// contain values of the non-compliant fields on the host and
	// in the profile.
	FailureValues []ComplianceFailureComplianceFailureValues `xml:"failureValues,omitempty" json:"failureValues,omitempty"`
}

func init() {
	t["ComplianceFailure"] = reflect.TypeOf((*ComplianceFailure)(nil)).Elem()
}

type ComplianceFailureComplianceFailureValues struct {
	DynamicData

	// Unique key to a message in the localized message catalog,
	// identifying the fields being compared.
	ComparisonIdentifier string `xml:"comparisonIdentifier" json:"comparisonIdentifier"`
	// Name of the profile instance, in case of non-singleton profiles.
	ProfileInstance string `xml:"profileInstance,omitempty" json:"profileInstance,omitempty"`
	// Value of the non-compliant field on the host.
	HostValue AnyType `xml:"hostValue,omitempty,typeattr" json:"hostValue,omitempty"`
	// Value of the non-compliant field in the profile.
	ProfileValue AnyType `xml:"profileValue,omitempty,typeattr" json:"profileValue,omitempty"`
}

func init() {
	t["ComplianceFailureComplianceFailureValues"] = reflect.TypeOf((*ComplianceFailureComplianceFailureValues)(nil)).Elem()
}

// This dataObject contains information about location of applyProfile
// which was responsible for generation of a particular ComplianceExpression.
type ComplianceLocator struct {
	DynamicData

	// Exression for which the Locator corresponds to
	ExpressionName string `xml:"expressionName" json:"expressionName"`
	// Complete path to the profile/policy which was responsible for the
	// generation of the ComplianceExpression.
	//
	// \[ProfilePath + policyId\] will uniquely identify a Policy.
	ApplyPath ProfilePropertyPath `xml:"applyPath" json:"applyPath"`
}

func init() {
	t["ComplianceLocator"] = reflect.TypeOf((*ComplianceLocator)(nil)).Elem()
}

// DataObject contains the verifications that need to be done
// to make sure the entity is in compliance.
type ComplianceProfile struct {
	DynamicData

	// List of expressions that make up the ComplianceChecks.
	Expression []BaseProfileExpression `xml:"expression,typeattr" json:"expression"`
	// Name of the Expression which is the root of the expression tree.
	RootExpression string `xml:"rootExpression" json:"rootExpression"`
}

func init() {
	t["ComplianceProfile"] = reflect.TypeOf((*ComplianceProfile)(nil)).Elem()
}

// DataObject representing the result from a ComplianceCheck
type ComplianceResult struct {
	DynamicData

	// Profile for which the ComplianceResult applies
	//
	// Refers instance of `Profile`.
	Profile *ManagedObjectReference `xml:"profile,omitempty" json:"profile,omitempty"`
	// Indicates the compliance status of the entity.
	//
	// See @link Status
	ComplianceStatus string `xml:"complianceStatus" json:"complianceStatus"`
	// Entity on which the compliance check was carried out.
	//
	// Entity can be a Cluster, Host and so on.
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
	// Time at which compliance check was last run on the entity
	CheckTime *time.Time `xml:"checkTime" json:"checkTime,omitempty"`
	// If complianceStatus is non-compliant, failure will
	// contain additional information about the compliance errors.
	Failure []ComplianceFailure `xml:"failure,omitempty" json:"failure,omitempty"`
}

func init() {
	t["ComplianceResult"] = reflect.TypeOf((*ComplianceResult)(nil)).Elem()
}

// The parameters of `HostProfileManager.CompositeHostProfile_Task`.
type CompositeHostProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Refers instance of `Profile`.
	Source ManagedObjectReference `xml:"source" json:"source"`
	// Refers instances of `Profile`.
	Targets                []ManagedObjectReference `xml:"targets,omitempty" json:"targets,omitempty"`
	ToBeMerged             *HostApplyProfile        `xml:"toBeMerged,omitempty" json:"toBeMerged,omitempty"`
	ToBeReplacedWith       *HostApplyProfile        `xml:"toBeReplacedWith,omitempty" json:"toBeReplacedWith,omitempty"`
	ToBeDeleted            *HostApplyProfile        `xml:"toBeDeleted,omitempty" json:"toBeDeleted,omitempty"`
	EnableStatusToBeCopied *HostApplyProfile        `xml:"enableStatusToBeCopied,omitempty" json:"enableStatusToBeCopied,omitempty"`
}

func init() {
	t["CompositeHostProfileRequestType"] = reflect.TypeOf((*CompositeHostProfileRequestType)(nil)).Elem()
}

type CompositeHostProfile_Task CompositeHostProfileRequestType

func init() {
	t["CompositeHostProfile_Task"] = reflect.TypeOf((*CompositeHostProfile_Task)(nil)).Elem()
}

type CompositeHostProfile_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// DataObject represents a composite Policy that is created by the user
// using different PolicyOptions.
//
// The options set in the CompositePolicyOption
// should be derived from the possible options as indicated by the
// CompositePolicyOptionMetadata.
type CompositePolicyOption struct {
	PolicyOption

	// List of policy options that are composed and applicable for
	// this composite policy option.
	//
	// The selected PolicyOptions in a CompositePolicyOption will be used in the
	// policy. PolicyOptions need not be specified if they are not desired for
	// the CompositePolicyOption.
	// Order of PolicyOptions in the PolicyOption array is not significant.
	// The host profile policy engine will not respect order of PolicyOptions.
	// It will apply PolicyOptions in a pre-determined order.
	// Clients of the API must produce PolicyOption in the same order as specified
	// in the metadata.
	Option []BasePolicyOption `xml:"option,omitempty,typeattr" json:"option,omitempty"`
}

func init() {
	t["CompositePolicyOption"] = reflect.TypeOf((*CompositePolicyOption)(nil)).Elem()
}

type ComputeDiskPartitionInfo ComputeDiskPartitionInfoRequestType

func init() {
	t["ComputeDiskPartitionInfo"] = reflect.TypeOf((*ComputeDiskPartitionInfo)(nil)).Elem()
}

type ComputeDiskPartitionInfoForResize ComputeDiskPartitionInfoForResizeRequestType

func init() {
	t["ComputeDiskPartitionInfoForResize"] = reflect.TypeOf((*ComputeDiskPartitionInfoForResize)(nil)).Elem()
}

// The parameters of `HostStorageSystem.ComputeDiskPartitionInfoForResize`.
type ComputeDiskPartitionInfoForResizeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The disk partition to resize.
	Partition HostScsiDiskPartition `xml:"partition" json:"partition"`
	// Specifies the desired block range for the resized
	// partition. The start of the block range specified should match
	// that of the current partition.
	BlockRange HostDiskPartitionBlockRange `xml:"blockRange" json:"blockRange"`
	// Specifies the desired partition format to be
	// computed from the block range.
	// If partitionFormat is not specified, the existing partitionFormat
	// on disk is used, if the disk is not blank and mbr otherwise.
	PartitionFormat string `xml:"partitionFormat,omitempty" json:"partitionFormat,omitempty"`
}

func init() {
	t["ComputeDiskPartitionInfoForResizeRequestType"] = reflect.TypeOf((*ComputeDiskPartitionInfoForResizeRequestType)(nil)).Elem()
}

type ComputeDiskPartitionInfoForResizeResponse struct {
	Returnval HostDiskPartitionInfo `xml:"returnval" json:"returnval"`
}

// The parameters of `HostStorageSystem.ComputeDiskPartitionInfo`.
type ComputeDiskPartitionInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the device path for the specific disk.
	DevicePath string `xml:"devicePath" json:"devicePath"`
	// A data object that describes the disk partition layout.
	Layout HostDiskPartitionLayout `xml:"layout" json:"layout"`
	// Specifies the desired partition format to be
	// computed from the block range.
	// If partitionFormat is not specified, the existing partitionFormat
	// on disk is used, if the disk is not blank and mbr otherwise.
	PartitionFormat string `xml:"partitionFormat,omitempty" json:"partitionFormat,omitempty"`
}

func init() {
	t["ComputeDiskPartitionInfoRequestType"] = reflect.TypeOf((*ComputeDiskPartitionInfoRequestType)(nil)).Elem()
}

type ComputeDiskPartitionInfoResponse struct {
	Returnval HostDiskPartitionInfo `xml:"returnval" json:"returnval"`
}

// Configuration of the compute resource; applies to both standalone hosts
// and clusters.
type ComputeResourceConfigInfo struct {
	DynamicData

	// Swapfile placement policy for virtual machines within this compute
	// resource.
	//
	// Any policy except for "inherit" is a valid value for this
	// property; the default is "vmDirectory". This setting will be honored
	// for each virtual machine within the compute resource for which the
	// following is true:
	//   - The virtual machine is executing on a host that has the
	//     `perVmSwapFiles` capability.
	//   - The virtual machine configuration's
	//     `swapPlacement` property is set
	//     to "inherit".
	//
	// See also `VirtualMachineConfigInfoSwapPlacementType_enum`.
	VmSwapPlacement string `xml:"vmSwapPlacement" json:"vmSwapPlacement"`
	// Flag indicating whether or not the SPBM(Storage Policy Based Management)
	// feature is enabled on this compute resource
	SpbmEnabled *bool `xml:"spbmEnabled" json:"spbmEnabled,omitempty"`
	// Key for Default Hardware Version used on this compute resource
	// in the format of `VirtualMachineConfigOptionDescriptor.key`.
	//
	// This field affects
	// `VirtualMachineConfigOptionDescriptor.defaultConfigOption` returned
	// by `ComputeResource.environmentBrowser` of this object and all its children
	// with this field unset.
	DefaultHardwareVersionKey string `xml:"defaultHardwareVersionKey,omitempty" json:"defaultHardwareVersionKey,omitempty"`
	// Key for Maximum Hardware Version used on this compute resource
	// in the format of `VirtualMachineConfigOptionDescriptor.key`.
	//
	// This field affects
	// `VirtualMachineConfigOptionDescriptor.defaultConfigOption` returned
	// by `ComputeResource.environmentBrowser` of this object and all its children
	// with this field unset.
	MaximumHardwareVersionKey string `xml:"maximumHardwareVersionKey,omitempty" json:"maximumHardwareVersionKey,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["ComputeResourceConfigInfo"] = reflect.TypeOf((*ComputeResourceConfigInfo)(nil)).Elem()
}

// Changes to apply to the compute resource configuration.
type ComputeResourceConfigSpec struct {
	DynamicData

	// New setting for the swapfile placement policy.
	//
	// Any change to this
	// policy will affect virtual machines that subsequently power on or
	// resume from a suspended state in this compute resource, or that
	// migrate to a host in this compute resource while powered on; virtual
	// machines that are currently powered on in this compute resource will
	// not yet be affected.
	//
	// See also `VirtualMachineConfigInfoSwapPlacementType_enum`.
	VmSwapPlacement string `xml:"vmSwapPlacement,omitempty" json:"vmSwapPlacement,omitempty"`
	// Flag indicating whether or not the SPBM(Storage Policy Based Management)
	// feature is enabled on this compute resource
	SpbmEnabled *bool `xml:"spbmEnabled" json:"spbmEnabled,omitempty"`
	// Key for Default Hardware Version to be used on this compute resource
	// in the format of `VirtualMachineConfigOptionDescriptor.key`.
	//
	// Setting this field affects
	// `VirtualMachineConfigOptionDescriptor.defaultConfigOption` returned
	// by `ComputeResource.environmentBrowser` of this object and all its children
	// with this field unset.
	DefaultHardwareVersionKey string `xml:"defaultHardwareVersionKey,omitempty" json:"defaultHardwareVersionKey,omitempty"`
	// Desired software spec for the set of physical compute resources.
	//
	// This
	// parameter is only supported in vim.Folder#createClusterEx operation.
	DesiredSoftwareSpec *DesiredSoftwareSpec `xml:"desiredSoftwareSpec,omitempty" json:"desiredSoftwareSpec,omitempty"`
	// Key for Maximum Hardware Version to be used on this compute resource
	// in the format of `VirtualMachineConfigOptionDescriptor.key`.
	//
	// Setting this field affects
	// `VirtualMachineConfigOptionDescriptor.defaultConfigOption` returned
	// by `ComputeResource.environmentBrowser` of this object and all its children
	// with this field unset.
	MaximumHardwareVersionKey string `xml:"maximumHardwareVersionKey,omitempty" json:"maximumHardwareVersionKey,omitempty" vim:"7.0.2.0"`
	// Flag indicating whether or not the vLCM (vSphere Lifecycle Manager)
	// Config Manager feature is enabled on this compute resource.
	//
	// If the
	// flag is not set, the Config Manager feature will be disabled by
	// default. This parameter is only supported in `Folder.CreateClusterEx`
	// operation.
	EnableConfigManager *bool `xml:"enableConfigManager" json:"enableConfigManager,omitempty" vim:"7.0.3.1"`
	// Specification for the host seeding operation.
	HostSeedSpec *ComputeResourceHostSeedSpec `xml:"hostSeedSpec,omitempty" json:"hostSeedSpec,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["ComputeResourceConfigSpec"] = reflect.TypeOf((*ComputeResourceConfigSpec)(nil)).Elem()
}

// The event argument is a ComputeResource object.
type ComputeResourceEventArgument struct {
	EntityEventArgument

	// The ComputeResource object.
	//
	// Refers instance of `ComputeResource`.
	ComputeResource ManagedObjectReference `xml:"computeResource" json:"computeResource"`
}

func init() {
	t["ComputeResourceEventArgument"] = reflect.TypeOf((*ComputeResourceEventArgument)(nil)).Elem()
}

// The `ComputeResourceHostSPBMLicenseInfo` data object
// encapsulates the SPBM(Storage Policy Based Management) license
// information for a host.
type ComputeResourceHostSPBMLicenseInfo struct {
	DynamicData

	// Refers instance of `HostSystem`.
	Host         ManagedObjectReference                                 `xml:"host" json:"host"`
	LicenseState ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState `xml:"licenseState" json:"licenseState"`
}

func init() {
	t["ComputeResourceHostSPBMLicenseInfo"] = reflect.TypeOf((*ComputeResourceHostSPBMLicenseInfo)(nil)).Elem()
}

type ComputeResourceHostSeedSpec struct {
	DynamicData

	// Specification for the seed host.
	SingleHostSpec ComputeResourceHostSeedSpecSingleHostSpec `xml:"singleHostSpec" json:"singleHostSpec"`
}

func init() {
	t["ComputeResourceHostSeedSpec"] = reflect.TypeOf((*ComputeResourceHostSeedSpec)(nil)).Elem()
	minAPIVersionForType["ComputeResourceHostSeedSpec"] = "8.0.3.0"
}

// This data object contains a specification for a single candidate host
// for the host seeding operation.
//
// If the candidate host is:
// \- A new host not managed by vCenter Server: A `HostConnectSpec`
// needs to be provided.
// \- A host managed by vCenter Server: A `HostSystem`
// needs to be provided.
type ComputeResourceHostSeedSpecSingleHostSpec struct {
	DynamicData

	// Connection Spec for a new host.
	NewHostCnxSpec *HostConnectSpec `xml:"newHostCnxSpec,omitempty" json:"newHostCnxSpec,omitempty"`
	// Reference to an existing host.
	//
	// Refers instance of `HostSystem`.
	ExistingHost *ManagedObjectReference `xml:"existingHost,omitempty" json:"existingHost,omitempty"`
}

func init() {
	t["ComputeResourceHostSeedSpecSingleHostSpec"] = reflect.TypeOf((*ComputeResourceHostSeedSpecSingleHostSpec)(nil)).Elem()
}

// This data object type encapsulates a typical set of ComputeResource information
// that is useful for list views and summary pages.
type ComputeResourceSummary struct {
	DynamicData

	// Aggregated CPU resources of all hosts, in MHz.
	TotalCpu int32 `xml:"totalCpu" json:"totalCpu"`
	// Aggregated memory resources of all hosts, in bytes.
	TotalMemory int64 `xml:"totalMemory" json:"totalMemory"`
	// Number of physical CPU cores.
	//
	// Physical CPU cores are the processors contained
	// by a CPU package.
	NumCpuCores int16 `xml:"numCpuCores" json:"numCpuCores"`
	// Aggregated number of CPU threads.
	NumCpuThreads int16 `xml:"numCpuThreads" json:"numCpuThreads"`
	// Effective CPU resources (in MHz) available to run virtual machines.
	//
	// This is the
	// aggregated effective resource level from all running hosts. Hosts that are in
	// maintenance mode or are unresponsive are not counted. Resources used by the
	// VMware Service Console are not included in the aggregate. This value represents
	// the amount of resources available for the root resource pool for running
	// virtual machines.
	EffectiveCpu int32 `xml:"effectiveCpu" json:"effectiveCpu"`
	// Effective memory resources (in MB) available to run virtual machines.
	//
	// This is the aggregated effective resource level from all running hosts. Hosts
	// that are in maintenance mode or are unresponsive are not counted.
	// Resources used by the VMware Service Console are not included in the aggregate.
	// This value represents the amount of resources available for the root
	// resource pool for running virtual machines.
	EffectiveMemory int64 `xml:"effectiveMemory" json:"effectiveMemory"`
	// Total number of hosts.
	NumHosts int32 `xml:"numHosts" json:"numHosts"`
	// Total number of effective hosts.
	NumEffectiveHosts int32 `xml:"numEffectiveHosts" json:"numEffectiveHosts"`
	// Overall alarm status.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	OverallStatus ManagedEntityStatus `xml:"overallStatus" json:"overallStatus"`
}

func init() {
	t["ComputeResourceSummary"] = reflect.TypeOf((*ComputeResourceSummary)(nil)).Elem()
}

// A ConcurrentAccess fault is thrown when an operation
// fails because another operation has modified the
// datastructure.
//
// For non-transactional operations, such as a recursive
// delete of a subtree of the inventory, the operation might
// fail with ConcurrentAccess if another thread has added
// a new entity to the hierarchy.
type ConcurrentAccess struct {
	VimFault
}

func init() {
	t["ConcurrentAccess"] = reflect.TypeOf((*ConcurrentAccess)(nil)).Elem()
}

type ConcurrentAccessFault ConcurrentAccess

func init() {
	t["ConcurrentAccessFault"] = reflect.TypeOf((*ConcurrentAccessFault)(nil)).Elem()
}

// The ConfigTarget class contains information about "physical" devices that can
// be used to back virtual devices.
type ConfigTarget struct {
	DynamicData

	// Number of logical CPUs that can be used to run virtual machines.
	//
	// If invoked against a cluster, this is the total number of logical CPUs
	// available in the cluster.
	NumCpus int32 `xml:"numCpus" json:"numCpus"`
	// Number of physical CPU cores that are available to run virtual machines.
	//
	// If invoked against a cluster, this is the total number of physical CPUs
	// available in the cluster.
	NumCpuCores int32 `xml:"numCpuCores" json:"numCpuCores"`
	// Number of NUMA nodes.
	//
	// If invoked against a cluster, this is the total number of NUMA nodes
	// available in the cluster.
	NumNumaNodes int32 `xml:"numNumaNodes" json:"numNumaNodes"`
	// Maximum number of CPUs available on a single host.
	//
	// For standalone hosts, this value will be the same as numCpus.
	MaxCpusPerHost int32 `xml:"maxCpusPerHost,omitempty" json:"maxCpusPerHost,omitempty"`
	// Presence of System Management Controller, indicates the host is
	// Apple hardware, and thus capable of running Mac OS guest as VM.
	SmcPresent *bool `xml:"smcPresent" json:"smcPresent,omitempty"`
	// List of datastores available for virtual disks and associated storage.
	Datastore []VirtualMachineDatastoreInfo `xml:"datastore,omitempty" json:"datastore,omitempty"`
	// List of networks available for virtual network adapters.
	Network []VirtualMachineNetworkInfo `xml:"network,omitempty" json:"network,omitempty"`
	// List of opaque networks available for virtual network adapters.
	OpaqueNetwork []OpaqueNetworkTargetInfo `xml:"opaqueNetwork,omitempty" json:"opaqueNetwork,omitempty"`
	// List of networks available from DistributedVirtualSwitch for virtual
	// network adapters.
	DistributedVirtualPortgroup []DistributedVirtualPortgroupInfo `xml:"distributedVirtualPortgroup,omitempty" json:"distributedVirtualPortgroup,omitempty"`
	// List of distributed virtual switch available for virtual network
	// adapters.
	DistributedVirtualSwitch []DistributedVirtualSwitchInfo `xml:"distributedVirtualSwitch,omitempty" json:"distributedVirtualSwitch,omitempty"`
	// List of CD-ROM devices available for use by virtual CD-ROMs.
	//
	// Used for
	// `VirtualCdromAtapiBackingInfo`.
	CdRom []VirtualMachineCdromInfo `xml:"cdRom,omitempty" json:"cdRom,omitempty"`
	// List of serial devices available to support virtualization.
	//
	// Used for
	// `VirtualSerialPortDeviceBackingInfo`.
	Serial []VirtualMachineSerialInfo `xml:"serial,omitempty" json:"serial,omitempty"`
	// List of parallel devices available to support virtualization.
	//
	// Used for
	// `VirtualParallelPortDeviceBackingInfo`.
	Parallel []VirtualMachineParallelInfo `xml:"parallel,omitempty" json:"parallel,omitempty"`
	// List of sound devices available to support virtualization.
	//
	// Used for
	// `VirtualSoundCardDeviceBackingInfo`.
	Sound []VirtualMachineSoundInfo `xml:"sound,omitempty" json:"sound,omitempty"`
	// List of USB devices on the host that are available to support
	// virtualization.
	//
	// Used for
	// `VirtualUSBUSBBackingInfo`.
	Usb []VirtualMachineUsbInfo `xml:"usb,omitempty" json:"usb,omitempty"`
	// List of floppy devices available for use by virtual floppies.
	//
	// Used for
	// `VirtualFloppyDeviceBackingInfo`.
	Floppy []VirtualMachineFloppyInfo `xml:"floppy,omitempty" json:"floppy,omitempty"`
	// Legacy switch names when using the LegacyNetworkBacking types.
	LegacyNetworkInfo []VirtualMachineLegacyNetworkSwitchInfo `xml:"legacyNetworkInfo,omitempty" json:"legacyNetworkInfo,omitempty"`
	// List of generic SCSI devices.
	ScsiPassthrough []VirtualMachineScsiPassthroughInfo `xml:"scsiPassthrough,omitempty" json:"scsiPassthrough,omitempty"`
	// List of physical SCSI disks that can be used as targets for raw disk mapping
	// backings.
	ScsiDisk []VirtualMachineScsiDiskDeviceInfo `xml:"scsiDisk,omitempty" json:"scsiDisk,omitempty"`
	// List of physical IDE disks that can be used as targets for raw disk backings.
	IdeDisk []VirtualMachineIdeDiskDeviceInfo `xml:"ideDisk,omitempty" json:"ideDisk,omitempty"`
	// Maximum recommended memory size, in MB, for creating a new virtual machine.
	MaxMemMBOptimalPerf int32 `xml:"maxMemMBOptimalPerf" json:"maxMemMBOptimalPerf"`
	// Maximum supported memory size, in MB, for creating a new virtual machine.
	//
	// Maximum allowed size is smaller of this and limit in
	// `GuestOsDescriptor.supportedMaxMemMB`. When invoked on the
	// cluster, maximum size that can be created on at least one host
	// in the cluster is reported.
	SupportedMaxMemMB int32 `xml:"supportedMaxMemMB,omitempty" json:"supportedMaxMemMB,omitempty"`
	// Information about the current available resources on the current resource pool
	// for a virtual machine.
	//
	// This field is only populated from an Environment browser
	// obtained from a virtual machine.
	ResourcePool *ResourcePoolRuntimeInfo `xml:"resourcePool,omitempty" json:"resourcePool,omitempty"`
	// Information whether a virtual machine with this ConfigTarget can auto vmotion.
	//
	// This field is only populated from an Environment browser obtained from a
	// virtual machine.
	AutoVmotion *bool `xml:"autoVmotion" json:"autoVmotion,omitempty"`
	// List of generic PCI devices.
	PciPassthrough []BaseVirtualMachinePciPassthroughInfo `xml:"pciPassthrough,omitempty,typeattr" json:"pciPassthrough,omitempty"`
	// List of SRIOV devices.
	Sriov []VirtualMachineSriovInfo `xml:"sriov,omitempty" json:"sriov,omitempty"`
	// List of vFlash modules.
	VFlashModule []VirtualMachineVFlashModuleInfo `xml:"vFlashModule,omitempty" json:"vFlashModule,omitempty"`
	// List of shared GPU passthrough types.
	SharedGpuPassthroughTypes []VirtualMachinePciSharedGpuPassthroughInfo `xml:"sharedGpuPassthroughTypes,omitempty" json:"sharedGpuPassthroughTypes,omitempty"`
	// Maximum available persistent memory reservation on a compute resource
	// in MB.
	AvailablePersistentMemoryReservationMB int64 `xml:"availablePersistentMemoryReservationMB,omitempty" json:"availablePersistentMemoryReservationMB,omitempty"`
	// List of Dynamic DirectPath PCI devices.
	DynamicPassthrough []VirtualMachineDynamicPassthroughInfo `xml:"dynamicPassthrough,omitempty" json:"dynamicPassthrough,omitempty"`
	// Intel SGX information.
	SgxTargetInfo *VirtualMachineSgxTargetInfo `xml:"sgxTargetInfo,omitempty" json:"sgxTargetInfo,omitempty"`
	// List of host clock resources available to support virtual precision
	// clock device.
	//
	// Used for
	// `VirtualPrecisionClockSystemClockBackingInfo`
	PrecisionClockInfo []VirtualMachinePrecisionClockInfo `xml:"precisionClockInfo,omitempty" json:"precisionClockInfo,omitempty"`
	// Indicates whether the compute resource is capable of running AMD Secure
	// Encrypted Virtualization (SEV) enabled virtual machines.
	//
	// The compute
	// resource supports SEV when this value is set to true.
	SevSupported *bool `xml:"sevSupported" json:"sevSupported,omitempty" vim:"7.0.1.0"`
	// List of vGPU device capabilities.
	VgpuDeviceInfo []VirtualMachineVgpuDeviceInfo `xml:"vgpuDeviceInfo,omitempty" json:"vgpuDeviceInfo,omitempty" vim:"7.0.3.0"`
	// List of vGPU profile attributes.
	VgpuProfileInfo []VirtualMachineVgpuProfileInfo `xml:"vgpuProfileInfo,omitempty" json:"vgpuProfileInfo,omitempty" vim:"7.0.3.0"`
	// List of PCI Vendor Device Groups.
	VendorDeviceGroupInfo []VirtualMachineVendorDeviceGroupInfo `xml:"vendorDeviceGroupInfo,omitempty" json:"vendorDeviceGroupInfo,omitempty" vim:"8.0.0.1"`
	// Max SMT (Simultaneous multithreading) threads.
	MaxSimultaneousThreads int32 `xml:"maxSimultaneousThreads,omitempty" json:"maxSimultaneousThreads,omitempty" vim:"8.0.0.1"`
	// List of Device Virtualization Extensions (DVX) classes.
	DvxClassInfo []VirtualMachineDvxClassInfo `xml:"dvxClassInfo,omitempty" json:"dvxClassInfo,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["ConfigTarget"] = reflect.TypeOf((*ConfigTarget)(nil)).Elem()
}

type ConfigureCryptoKey ConfigureCryptoKeyRequestType

func init() {
	t["ConfigureCryptoKey"] = reflect.TypeOf((*ConfigureCryptoKey)(nil)).Elem()
}

// The parameters of `HostSystem.ConfigureCryptoKey`.
type ConfigureCryptoKeyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The key to be used for coredump encryption. If unset, uses
	// existing host or cluster key or new key is generated from
	// the default KMIP server.
	KeyId *CryptoKeyId `xml:"keyId,omitempty" json:"keyId,omitempty"`
}

func init() {
	t["ConfigureCryptoKeyRequestType"] = reflect.TypeOf((*ConfigureCryptoKeyRequestType)(nil)).Elem()
}

type ConfigureCryptoKeyResponse struct {
}

// The parameters of `StorageResourceManager.ConfigureDatastoreIORM_Task`.
type ConfigureDatastoreIORMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datastore to be configured.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The configuration spec.
	Spec StorageIORMConfigSpec `xml:"spec" json:"spec"`
}

func init() {
	t["ConfigureDatastoreIORMRequestType"] = reflect.TypeOf((*ConfigureDatastoreIORMRequestType)(nil)).Elem()
}

type ConfigureDatastoreIORM_Task ConfigureDatastoreIORMRequestType

func init() {
	t["ConfigureDatastoreIORM_Task"] = reflect.TypeOf((*ConfigureDatastoreIORM_Task)(nil)).Elem()
}

type ConfigureDatastoreIORM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ConfigureDatastorePrincipal ConfigureDatastorePrincipalRequestType

func init() {
	t["ConfigureDatastorePrincipal"] = reflect.TypeOf((*ConfigureDatastorePrincipal)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.ConfigureDatastorePrincipal`.
type ConfigureDatastorePrincipalRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Datastore principal user name.
	UserName string `xml:"userName" json:"userName"`
	// Optional password for systems that require password for
	// user impersonation.
	Password string `xml:"password,omitempty" json:"password,omitempty"`
}

func init() {
	t["ConfigureDatastorePrincipalRequestType"] = reflect.TypeOf((*ConfigureDatastorePrincipalRequestType)(nil)).Elem()
}

type ConfigureDatastorePrincipalResponse struct {
}

// The parameters of `ClusterEVCManager.ConfigureEvcMode_Task`.
type ConfigureEvcModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A key referencing the desired EVC mode.
	EvcModeKey string `xml:"evcModeKey" json:"evcModeKey"`
	// A key referencing the desired EVC Graphics
	// mode `Capability.supportedEVCGraphicsMode`.
	EvcGraphicsModeKey string `xml:"evcGraphicsModeKey,omitempty" json:"evcGraphicsModeKey,omitempty" vim:"7.0.1.0"`
}

func init() {
	t["ConfigureEvcModeRequestType"] = reflect.TypeOf((*ConfigureEvcModeRequestType)(nil)).Elem()
}

type ConfigureEvcMode_Task ConfigureEvcModeRequestType

func init() {
	t["ConfigureEvcMode_Task"] = reflect.TypeOf((*ConfigureEvcMode_Task)(nil)).Elem()
}

type ConfigureEvcMode_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `ClusterComputeResource.ConfigureHCI_Task`.
type ConfigureHCIRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specification to configure the cluster,
	// see `ClusterComputeResourceHCIConfigSpec`
	// for details. The `DistributedVirtualSwitch` and
	// `DistributedVirtualPortgroup` objects contained
	// within the specification must be in the same datacenter as the
	// cluster. Specify `ClusterComputeResourceHCIConfigSpec.vSanConfigSpec` only when
	// vSan is enabled on the cluster.
	ClusterSpec ClusterComputeResourceHCIConfigSpec `xml:"clusterSpec" json:"clusterSpec"`
	// Inputs to configure each host in the cluster,
	// see `ClusterComputeResourceHostConfigurationInput`
	// for details. Hosts in this list should be part of the cluster and
	// should be in maintenance mode for them to be configured per
	// specification. If this parameter is not specified, the API
	// operates on all the hosts in the cluster. Hosts which were not
	// configured due to not being in maintenance
	// mode will be returned in `ClusterComputeResourceClusterConfigResult.failedHosts`.
	HostInputs []ClusterComputeResourceHostConfigurationInput `xml:"hostInputs,omitempty" json:"hostInputs,omitempty"`
}

func init() {
	t["ConfigureHCIRequestType"] = reflect.TypeOf((*ConfigureHCIRequestType)(nil)).Elem()
}

type ConfigureHCI_Task ConfigureHCIRequestType

func init() {
	t["ConfigureHCI_Task"] = reflect.TypeOf((*ConfigureHCI_Task)(nil)).Elem()
}

type ConfigureHCI_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostCacheConfigurationManager.ConfigureHostCache_Task`.
type ConfigureHostCacheRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specification for solid state drive cache configuration.
	Spec HostCacheConfigurationSpec `xml:"spec" json:"spec"`
}

func init() {
	t["ConfigureHostCacheRequestType"] = reflect.TypeOf((*ConfigureHostCacheRequestType)(nil)).Elem()
}

type ConfigureHostCache_Task ConfigureHostCacheRequestType

func init() {
	t["ConfigureHostCache_Task"] = reflect.TypeOf((*ConfigureHostCache_Task)(nil)).Elem()
}

type ConfigureHostCache_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ConfigureLicenseSource ConfigureLicenseSourceRequestType

func init() {
	t["ConfigureLicenseSource"] = reflect.TypeOf((*ConfigureLicenseSource)(nil)).Elem()
}

// The parameters of `LicenseManager.ConfigureLicenseSource`.
type ConfigureLicenseSourceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Host for which the license manager should be reconfigured.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// ServedSource or LocalSource.
	LicenseSource BaseLicenseSource `xml:"licenseSource,typeattr" json:"licenseSource"`
}

func init() {
	t["ConfigureLicenseSourceRequestType"] = reflect.TypeOf((*ConfigureLicenseSourceRequestType)(nil)).Elem()
}

type ConfigureLicenseSourceResponse struct {
}

type ConfigurePowerPolicy ConfigurePowerPolicyRequestType

func init() {
	t["ConfigurePowerPolicy"] = reflect.TypeOf((*ConfigurePowerPolicy)(nil)).Elem()
}

// The parameters of `HostPowerSystem.ConfigurePowerPolicy`.
type ConfigurePowerPolicyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A key from one of the policies in
	// `PowerSystemCapability.availablePolicy`.
	Key int32 `xml:"key" json:"key"`
}

func init() {
	t["ConfigurePowerPolicyRequestType"] = reflect.TypeOf((*ConfigurePowerPolicyRequestType)(nil)).Elem()
}

type ConfigurePowerPolicyResponse struct {
}

// The parameters of `StorageResourceManager.ConfigureStorageDrsForPod_Task`.
type ConfigureStorageDrsForPodRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The storage pod.
	//
	// Required privileges: StoragePod.Config
	//
	// Refers instance of `StoragePod`.
	Pod ManagedObjectReference `xml:"pod" json:"pod"`
	// A set of storage Drs configuration changes to apply to the storage pod.
	// The specification can be a complete set of changes or a partial
	// set of changes, applied incrementally.
	Spec StorageDrsConfigSpec `xml:"spec" json:"spec"`
	// Flag to specify whether the specification ("spec") should
	// be applied incrementally. If "modify" is false and the
	// operation succeeds, then the configuration of the storage pod
	// matches the specification exactly; in this case any unset
	// portions of the specification will result in unset or
	// default portions of the configuration.
	Modify bool `xml:"modify" json:"modify"`
}

func init() {
	t["ConfigureStorageDrsForPodRequestType"] = reflect.TypeOf((*ConfigureStorageDrsForPodRequestType)(nil)).Elem()
}

type ConfigureStorageDrsForPod_Task ConfigureStorageDrsForPodRequestType

func init() {
	t["ConfigureStorageDrsForPod_Task"] = reflect.TypeOf((*ConfigureStorageDrsForPod_Task)(nil)).Elem()
}

type ConfigureStorageDrsForPod_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostVFlashManager.ConfigureVFlashResourceEx_Task`.
type ConfigureVFlashResourceExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// An array of device path names that identify disks.
	// See `ScsiDisk`.
	DevicePath []string `xml:"devicePath,omitempty" json:"devicePath,omitempty"`
}

func init() {
	t["ConfigureVFlashResourceExRequestType"] = reflect.TypeOf((*ConfigureVFlashResourceExRequestType)(nil)).Elem()
}

type ConfigureVFlashResourceEx_Task ConfigureVFlashResourceExRequestType

func init() {
	t["ConfigureVFlashResourceEx_Task"] = reflect.TypeOf((*ConfigureVFlashResourceEx_Task)(nil)).Elem()
}

type ConfigureVFlashResourceEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Thrown if the configurations of the objects are in conflict.
type ConflictingConfiguration struct {
	DvsFault

	// The configurations that are in conflict.
	ConfigInConflict []ConflictingConfigurationConfig `xml:"configInConflict" json:"configInConflict"`
}

func init() {
	t["ConflictingConfiguration"] = reflect.TypeOf((*ConflictingConfiguration)(nil)).Elem()
}

// This class defines the configuration that is in conflict.
type ConflictingConfigurationConfig struct {
	DynamicData

	// The entity on which the configuration is in conflict.
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
	// The property paths that are in conflict.
	PropertyPath string `xml:"propertyPath" json:"propertyPath"`
}

func init() {
	t["ConflictingConfigurationConfig"] = reflect.TypeOf((*ConflictingConfigurationConfig)(nil)).Elem()
}

type ConflictingConfigurationFault ConflictingConfiguration

func init() {
	t["ConflictingConfigurationFault"] = reflect.TypeOf((*ConflictingConfigurationFault)(nil)).Elem()
}

// ConflictingDatastoreFound is thrown when the conflicting datastores
// with the same url but backed by different disks are found in the host
// and the target datacenter.
type ConflictingDatastoreFound struct {
	RuntimeFault

	// The name of the datastore.
	Name string `xml:"name" json:"name"`
	// The unique locator for the datastore.
	Url string `xml:"url" json:"url"`
}

func init() {
	t["ConflictingDatastoreFound"] = reflect.TypeOf((*ConflictingDatastoreFound)(nil)).Elem()
}

type ConflictingDatastoreFoundFault ConflictingDatastoreFound

func init() {
	t["ConflictingDatastoreFoundFault"] = reflect.TypeOf((*ConflictingDatastoreFoundFault)(nil)).Elem()
}

type ConnectNvmeController ConnectNvmeControllerRequestType

func init() {
	t["ConnectNvmeController"] = reflect.TypeOf((*ConnectNvmeController)(nil)).Elem()
}

// The parameters of `HostStorageSystem.ConnectNvmeControllerEx_Task`.
type ConnectNvmeControllerExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A list of data objects, each specifying the parameters
	// necessary to connect to an NVMe controller.
	ConnectSpec []HostNvmeConnectSpec `xml:"connectSpec,omitempty" json:"connectSpec,omitempty"`
}

func init() {
	t["ConnectNvmeControllerExRequestType"] = reflect.TypeOf((*ConnectNvmeControllerExRequestType)(nil)).Elem()
	minAPIVersionForType["ConnectNvmeControllerExRequestType"] = "7.0.3.0"
}

type ConnectNvmeControllerEx_Task ConnectNvmeControllerExRequestType

func init() {
	t["ConnectNvmeControllerEx_Task"] = reflect.TypeOf((*ConnectNvmeControllerEx_Task)(nil)).Elem()
}

type ConnectNvmeControllerEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostStorageSystem.ConnectNvmeController`.
type ConnectNvmeControllerRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A data object that specifies the parameters
	// necessary to connect to the controller.
	ConnectSpec HostNvmeConnectSpec `xml:"connectSpec" json:"connectSpec"`
}

func init() {
	t["ConnectNvmeControllerRequestType"] = reflect.TypeOf((*ConnectNvmeControllerRequestType)(nil)).Elem()
}

type ConnectNvmeControllerResponse struct {
}

type ConnectedIso struct {
	OvfExport

	// The CD-ROM drive that caused the event.
	Cdrom VirtualCdrom `xml:"cdrom" json:"cdrom"`
	// The filename of the ISO
	Filename string `xml:"filename" json:"filename"`
}

func init() {
	t["ConnectedIso"] = reflect.TypeOf((*ConnectedIso)(nil)).Elem()
}

type ConnectedIsoFault ConnectedIso

func init() {
	t["ConnectedIsoFault"] = reflect.TypeOf((*ConnectedIsoFault)(nil)).Elem()
}

type ConsolidateVMDisksRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ConsolidateVMDisksRequestType"] = reflect.TypeOf((*ConsolidateVMDisksRequestType)(nil)).Elem()
}

type ConsolidateVMDisks_Task ConsolidateVMDisksRequestType

func init() {
	t["ConsolidateVMDisks_Task"] = reflect.TypeOf((*ConsolidateVMDisks_Task)(nil)).Elem()
}

type ConsolidateVMDisks_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ContinueRetrievePropertiesEx ContinueRetrievePropertiesExRequestType

func init() {
	t["ContinueRetrievePropertiesEx"] = reflect.TypeOf((*ContinueRetrievePropertiesEx)(nil)).Elem()
}

// The parameters of `PropertyCollector.ContinueRetrievePropertiesEx`.
type ContinueRetrievePropertiesExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// the token returned in the previous `RetrieveResult` returned on the same session by the
	// same `PropertyCollector`.
	Token string `xml:"token" json:"token"`
}

func init() {
	t["ContinueRetrievePropertiesExRequestType"] = reflect.TypeOf((*ContinueRetrievePropertiesExRequestType)(nil)).Elem()
}

type ContinueRetrievePropertiesExResponse struct {
	Returnval RetrieveResult `xml:"returnval" json:"returnval"`
}

type ConvertNamespacePathToUuidPath ConvertNamespacePathToUuidPathRequestType

func init() {
	t["ConvertNamespacePathToUuidPath"] = reflect.TypeOf((*ConvertNamespacePathToUuidPath)(nil)).Elem()
}

// The parameters of `DatastoreNamespaceManager.ConvertNamespacePathToUuidPath`.
type ConvertNamespacePathToUuidPathRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datacenter of the namespace path. Needs to be set
	// when making the call to VC; ignored when the call is
	// made to ESX.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// Namesapce URL of the form
	// > \[ds://\]/vmfs/volumes/\[_datastore-uuid_\]/\[_directory-name_\]/...
	// >
	NamespaceUrl string `xml:"namespaceUrl" json:"namespaceUrl"`
}

func init() {
	t["ConvertNamespacePathToUuidPathRequestType"] = reflect.TypeOf((*ConvertNamespacePathToUuidPathRequestType)(nil)).Elem()
}

type ConvertNamespacePathToUuidPathResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// The parameters of `FileManager.CopyDatastoreFile_Task`.
type CopyDatastoreFileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the source, either a URL or a
	// datastore path referring to the file or folder to be copied.
	SourceName string `xml:"sourceName" json:"sourceName"`
	// If <code>sourceName</code> is a datastore path, the
	// datacenter for that datastore path.
	// Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>sourceName</code> must be a URL.
	//
	// Required privileges: System.View
	//
	// Refers instance of `Datacenter`.
	SourceDatacenter *ManagedObjectReference `xml:"sourceDatacenter,omitempty" json:"sourceDatacenter,omitempty"`
	// The name of the destination, either a
	// URL or a datastore path referring to the destination file
	// or folder.
	DestinationName string `xml:"destinationName" json:"destinationName"`
	// If <code>destinationName</code> is a datastore
	// path, the datacenter for that datastore path.
	// Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter, it is assumed that
	// the destination path belongs to the source datacenter.
	//
	// Required privileges: System.View
	//
	// Refers instance of `Datacenter`.
	DestinationDatacenter *ManagedObjectReference `xml:"destinationDatacenter,omitempty" json:"destinationDatacenter,omitempty"`
	// If true, overwrite any identically named file
	// at the destination. If not specified, it is assumed to be false.
	Force *bool `xml:"force" json:"force,omitempty"`
}

func init() {
	t["CopyDatastoreFileRequestType"] = reflect.TypeOf((*CopyDatastoreFileRequestType)(nil)).Elem()
}

type CopyDatastoreFile_Task CopyDatastoreFileRequestType

func init() {
	t["CopyDatastoreFile_Task"] = reflect.TypeOf((*CopyDatastoreFile_Task)(nil)).Elem()
}

type CopyDatastoreFile_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualDiskManager.CopyVirtualDisk_Task`.
type CopyVirtualDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the source, either a datastore path
	// or a URL referring to the virtual disk to be copied.
	SourceName string `xml:"sourceName" json:"sourceName"`
	// If <code>sourceName</code> is a datastore path, the
	// datacenter for that datastore path.
	// Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>sourceName</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	SourceDatacenter *ManagedObjectReference `xml:"sourceDatacenter,omitempty" json:"sourceDatacenter,omitempty"`
	// The name of the destination, either a datastore path
	// or a URL referring to the virtual disk to be created.
	DestName string `xml:"destName" json:"destName"`
	// If <code>destName</code> is a datastore
	// path, the datacenter for that datastore path.
	// Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter, it is assumed that
	// the destination path belongs to the source datacenter.
	//
	// Refers instance of `Datacenter`.
	DestDatacenter *ManagedObjectReference `xml:"destDatacenter,omitempty" json:"destDatacenter,omitempty"`
	// The specification of the virtual disk to be created.
	// If not specified, a preallocated format and busLogic adapter type is assumed.
	DestSpec BaseVirtualDiskSpec `xml:"destSpec,omitempty,typeattr" json:"destSpec,omitempty"`
	// The force flag is currently ignored. The FileAlreadyExists fault is thrown if
	// the destination file already exists.
	Force *bool `xml:"force" json:"force,omitempty"`
}

func init() {
	t["CopyVirtualDiskRequestType"] = reflect.TypeOf((*CopyVirtualDiskRequestType)(nil)).Elem()
}

type CopyVirtualDisk_Task CopyVirtualDiskRequestType

func init() {
	t["CopyVirtualDisk_Task"] = reflect.TypeOf((*CopyVirtualDisk_Task)(nil)).Elem()
}

type CopyVirtualDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Deprecated as of VI API 2.5, use `CpuIncompatible` and its other subclasses,
// not this one.
//
// Compatibility between the virtual machine's host and its CPU
// feature requirements cannot be determined, because not enough information
// is available about the CPU features of the host.
type CpuCompatibilityUnknown struct {
	CpuIncompatible
}

func init() {
	t["CpuCompatibilityUnknown"] = reflect.TypeOf((*CpuCompatibilityUnknown)(nil)).Elem()
}

type CpuCompatibilityUnknownFault CpuCompatibilityUnknown

func init() {
	t["CpuCompatibilityUnknownFault"] = reflect.TypeOf((*CpuCompatibilityUnknownFault)(nil)).Elem()
}

// Thrown when virtual CPUs cannot be hot-added or hot-removed from
// the virtual machine.
type CpuHotPlugNotSupported struct {
	VmConfigFault
}

func init() {
	t["CpuHotPlugNotSupported"] = reflect.TypeOf((*CpuHotPlugNotSupported)(nil)).Elem()
}

type CpuHotPlugNotSupportedFault CpuHotPlugNotSupported

func init() {
	t["CpuHotPlugNotSupportedFault"] = reflect.TypeOf((*CpuHotPlugNotSupportedFault)(nil)).Elem()
}

// Deprecated as of vSphere API 6.5 use
// `FeatureRequirementsNotMet`.
//
// The host is not compatible with the CPU feature requirements of the
// virtual machine, for a particular CPUID register.
//
// A subclass of this fault
// may be used to express the incompatibilities in a more easily
// understandable format.
type CpuIncompatible struct {
	VirtualHardwareCompatibilityIssue

	// The CpuIdInfo level where a problem was detected.
	//
	// Other levels may
	// also have problems.
	Level int32 `xml:"level" json:"level"`
	// The CpuIdInfo register where a problem was detected.
	//
	// Other registers
	// may also have problems. Possible register names are eax, ebx, ecx, or edx.
	RegisterName string `xml:"registerName" json:"registerName"`
	// The contents of the register on the target host, in CpuIdInfo register
	// format.
	//
	// The '-' character indicates an unknown value.
	RegisterBits string `xml:"registerBits,omitempty" json:"registerBits,omitempty"`
	// The desired values for the register's bits.
	//
	// The 'x' character indicates
	// don't-care.
	DesiredBits string `xml:"desiredBits,omitempty" json:"desiredBits,omitempty"`
	// The host that is not compatible with the requirements.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["CpuIncompatible"] = reflect.TypeOf((*CpuIncompatible)(nil)).Elem()
}

// Deprecated as of vSphere API 6.5 use
// `FeatureRequirementsNotMet`.
//
// Convenience subclass for calling out some named features among the
// incompatibilities found in CPUID level 1 register ecx.
type CpuIncompatible1ECX struct {
	CpuIncompatible

	// Flag to indicate bit 0 is incompatible.
	Sse3 bool `xml:"sse3" json:"sse3"`
	// Flag to indicate bit 1 is incompatible.
	Pclmulqdq *bool `xml:"pclmulqdq" json:"pclmulqdq,omitempty"`
	// Flag to indicate bit 9 is incompatible.
	Ssse3 bool `xml:"ssse3" json:"ssse3"`
	// Flag to indicate bit 19 is incompatible.
	Sse41 bool `xml:"sse41" json:"sse41"`
	// Flag to indicate bit 20 is incompatible.
	Sse42 bool `xml:"sse42" json:"sse42"`
	// Flag to indicate bit 25 is incompatible.
	Aes *bool `xml:"aes" json:"aes,omitempty"`
	// Flag to indicate that bits other than 0/1/9/19/20/25 are incompatible.
	//
	// I.e. the detected incompatibilities cannot be completely described by
	// the sse3, pclmulqdq, ssse3, sse41, sse42, and/or aes flags.
	Other bool `xml:"other" json:"other"`
	// Flag to indicate that the sse3, pclmulqdq, ssse3, sse41, sse42, and aes
	// flags are all false, and the "other" flag is true.
	//
	// Purely a convenience
	// property for the client processing this fault.
	OtherOnly bool `xml:"otherOnly" json:"otherOnly"`
}

func init() {
	t["CpuIncompatible1ECX"] = reflect.TypeOf((*CpuIncompatible1ECX)(nil)).Elem()
}

type CpuIncompatible1ECXFault CpuIncompatible1ECX

func init() {
	t["CpuIncompatible1ECXFault"] = reflect.TypeOf((*CpuIncompatible1ECXFault)(nil)).Elem()
}

// Deprecated as of vSphere API 6.5 use
// `FeatureRequirementsNotMet`.
//
// Convenience subclass for calling out some named features among the
// incompatibilities found in CPUID level 0x80000001 register edx.
type CpuIncompatible81EDX struct {
	CpuIncompatible

	// Flag to indicate bit 20 is incompatible.
	Nx bool `xml:"nx" json:"nx"`
	// Flag to indicate bit 25 is incompatible.
	Ffxsr bool `xml:"ffxsr" json:"ffxsr"`
	// Flag to indicate bit 27 is incompatible.
	Rdtscp bool `xml:"rdtscp" json:"rdtscp"`
	// Flag to indicate bit 29 is incompatible.
	Lm bool `xml:"lm" json:"lm"`
	// Flag to indicate that bits other than 20/25/27/29 are incompatible.
	//
	// I.e. the detected incompatibilities cannot be completely described by
	// the nx, ffxsr, rdtscp, and/or lm flags.
	Other bool `xml:"other" json:"other"`
	// Flag to indicate that the nx, ffxsr, rdtscp, and lm flags are all false,
	// and the "other" flag is true.
	//
	// Purely a convenience property for the
	// client processing this fault.
	OtherOnly bool `xml:"otherOnly" json:"otherOnly"`
}

func init() {
	t["CpuIncompatible81EDX"] = reflect.TypeOf((*CpuIncompatible81EDX)(nil)).Elem()
}

type CpuIncompatible81EDXFault CpuIncompatible81EDX

func init() {
	t["CpuIncompatible81EDXFault"] = reflect.TypeOf((*CpuIncompatible81EDXFault)(nil)).Elem()
}

type CpuIncompatibleFault BaseCpuIncompatible

func init() {
	t["CpuIncompatibleFault"] = reflect.TypeOf((*CpuIncompatibleFault)(nil)).Elem()
}

type CreateAlarm CreateAlarmRequestType

func init() {
	t["CreateAlarm"] = reflect.TypeOf((*CreateAlarm)(nil)).Elem()
}

// The parameters of `AlarmManager.CreateAlarm`.
type CreateAlarmRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The entity with which the alarm is associated.
	//
	// Required privileges: Alarm.Create
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// The specification for the new alarm.
	Spec BaseAlarmSpec `xml:"spec,typeattr" json:"spec"`
}

func init() {
	t["CreateAlarmRequestType"] = reflect.TypeOf((*CreateAlarmRequestType)(nil)).Elem()
}

type CreateAlarmResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `ResourcePool.CreateChildVM_Task`.
type CreateChildVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The configuration of the virtual machine hardware.
	Config VirtualMachineConfigSpec `xml:"config" json:"config"`
	// The target host on which the virtual machine will run. This must
	// specify a host that is a member of the ComputeResource indirectly
	// specified by the pool. For a stand-alone host or a cluster with DRS,
	// host can be omitted, and the system selects a default.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["CreateChildVMRequestType"] = reflect.TypeOf((*CreateChildVMRequestType)(nil)).Elem()
}

type CreateChildVM_Task CreateChildVMRequestType

func init() {
	t["CreateChildVM_Task"] = reflect.TypeOf((*CreateChildVM_Task)(nil)).Elem()
}

type CreateChildVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateCluster CreateClusterRequestType

func init() {
	t["CreateCluster"] = reflect.TypeOf((*CreateCluster)(nil)).Elem()
}

type CreateClusterEx CreateClusterExRequestType

func init() {
	t["CreateClusterEx"] = reflect.TypeOf((*CreateClusterEx)(nil)).Elem()
}

// The parameters of `Folder.CreateClusterEx`.
type CreateClusterExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Name for the new cluster.
	Name string `xml:"name" json:"name"`
	// Specification for the cluster.
	Spec ClusterConfigSpecEx `xml:"spec" json:"spec"`
}

func init() {
	t["CreateClusterExRequestType"] = reflect.TypeOf((*CreateClusterExRequestType)(nil)).Elem()
}

type CreateClusterExResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `Folder.CreateCluster`.
type CreateClusterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Name for the new cluster.
	Name string `xml:"name" json:"name"`
	// Specification for the cluster.
	Spec ClusterConfigSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CreateClusterRequestType"] = reflect.TypeOf((*CreateClusterRequestType)(nil)).Elem()
}

type CreateClusterResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateCollectorForEvents CreateCollectorForEventsRequestType

func init() {
	t["CreateCollectorForEvents"] = reflect.TypeOf((*CreateCollectorForEvents)(nil)).Elem()
}

// The parameters of `EventManager.CreateCollectorForEvents`.
type CreateCollectorForEventsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The event query filter.
	Filter EventFilterSpec `xml:"filter" json:"filter"`
}

func init() {
	t["CreateCollectorForEventsRequestType"] = reflect.TypeOf((*CreateCollectorForEventsRequestType)(nil)).Elem()
}

type CreateCollectorForEventsResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateCollectorForTasks CreateCollectorForTasksRequestType

func init() {
	t["CreateCollectorForTasks"] = reflect.TypeOf((*CreateCollectorForTasks)(nil)).Elem()
}

// The parameters of `TaskManager.CreateCollectorForTasks`.
type CreateCollectorForTasksRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specification for the task query filter.
	Filter TaskFilterSpec `xml:"filter" json:"filter"`
}

func init() {
	t["CreateCollectorForTasksRequestType"] = reflect.TypeOf((*CreateCollectorForTasksRequestType)(nil)).Elem()
}

type CreateCollectorForTasksResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateCollectorWithInfoFilterForTasks CreateCollectorWithInfoFilterForTasksRequestType

func init() {
	t["CreateCollectorWithInfoFilterForTasks"] = reflect.TypeOf((*CreateCollectorWithInfoFilterForTasks)(nil)).Elem()
}

// The parameters of `TaskManager.CreateCollectorWithInfoFilterForTasks`.
type CreateCollectorWithInfoFilterForTasksRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specification for the task query filter.
	Filter TaskFilterSpec `xml:"filter" json:"filter"`
	// The specification for the task info filter.
	InfoFilter *TaskInfoFilterSpec `xml:"infoFilter,omitempty" json:"infoFilter,omitempty"`
}

func init() {
	t["CreateCollectorWithInfoFilterForTasksRequestType"] = reflect.TypeOf((*CreateCollectorWithInfoFilterForTasksRequestType)(nil)).Elem()
	minAPIVersionForType["CreateCollectorWithInfoFilterForTasksRequestType"] = "8.0.3.0"
}

type CreateCollectorWithInfoFilterForTasksResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateContainerView CreateContainerViewRequestType

func init() {
	t["CreateContainerView"] = reflect.TypeOf((*CreateContainerView)(nil)).Elem()
}

// The parameters of `ViewManager.CreateContainerView`.
type CreateContainerViewRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A reference to an instance of a `Folder`,
	// `Datacenter`, `ComputeResource`,
	// `ResourcePool`, or `HostSystem` object.
	//
	// Required privileges: System.View
	//
	// Refers instance of `ManagedEntity`.
	Container ManagedObjectReference `xml:"container" json:"container"`
	// An optional list of managed entity types. The server
	// associates only objects of the specified type(s) with the view.
	// If you specify an empty array, the server uses all types.
	Type []string `xml:"type,omitempty" json:"type,omitempty"`
	// Whether to include only the immediate children of the
	// container instance, or to include additional objects by
	// following paths beyond the immediate children.
	//
	// When recursive is false, the list of objects contains
	// only immediate children.
	// When recursive is true, the server populates the list
	// by following references beyond the immediate children
	// (using a child's references, and then references in the
	// resulting objects, and so on).
	//
	// Depending on the container type, the server will use the following
	// properties of the container instance to obtain objects for the
	// view's object list:
	//   - `Folder` object - `Folder.childEntity`
	//     property.
	//     If recursive is false, the container list includes the reference
	//     to the child entity in the folder instance.
	//     If recursive is true, the server will follow the child
	//     folder path(s) to collect additional childEntity references.
	//   - `ResourcePool` object - `ResourcePool.vm`
	//     and `ResourcePool.resourcePool` properties.
	//     If recursive is false, the object list will contain references
	//     to the virtual machines associated with this resource pool,
	//     and references to virtual machines associated with the
	//     immediate child resource pools. If recursive is true,
	//     the server will follow all child resource pool paths
	//     extending from the immediate children (and their children,
	//     and so on) to collect additional references to virtual machines.
	//   - `ComputeResource` object - `ComputeResource.host`
	//     and `ComputeResource.resourcePool` properties.
	//     If recursive is false, the object list will contain references
	//     to the host systems associated with this compute resource,
	//     references to virtual machines associated with the
	//     host systems, and references to virtual machines associated
	//     with the immediate child resource pools.
	//     If recursive is true, the server will follow the child
	//     resource pool paths (and their child resource pool paths,
	//     and so on) to collect additional references to virtual machines.
	//   - `Datacenter` object - `Datacenter.vmFolder`,
	//     `Datacenter.hostFolder`,
	//     `Datacenter.datastoreFolder`, and
	//     `Datacenter.networkFolder` properties.
	//     If recursive is set to false, the server uses the
	//     immediate child folders for the virtual machines,
	//     hosts, datastores, and networks associated with this
	//     datacenter. If recursive is set to true, the server
	//     will follow the folder paths to collect references
	//     to additional objects.
	//   - `HostSystem` object - `HostSystem.vm`
	//     property.
	//     The view object list contains references to the virtual machines
	//     associated with this host system. The value of recursive does not
	//     affect this behavior.
	Recursive bool `xml:"recursive" json:"recursive"`
}

func init() {
	t["CreateContainerViewRequestType"] = reflect.TypeOf((*CreateContainerViewRequestType)(nil)).Elem()
}

type CreateContainerViewResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateCustomizationSpec CreateCustomizationSpecRequestType

func init() {
	t["CreateCustomizationSpec"] = reflect.TypeOf((*CreateCustomizationSpec)(nil)).Elem()
}

// The parameters of `CustomizationSpecManager.CreateCustomizationSpec`.
type CreateCustomizationSpecRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Item CustomizationSpecItem  `xml:"item" json:"item"`
}

func init() {
	t["CreateCustomizationSpecRequestType"] = reflect.TypeOf((*CreateCustomizationSpecRequestType)(nil)).Elem()
}

type CreateCustomizationSpecResponse struct {
}

// The parameters of `DistributedVirtualSwitch.CreateDVPortgroup_Task`.
type CreateDVPortgroupRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specification for the portgroup.
	Spec DVPortgroupConfigSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CreateDVPortgroupRequestType"] = reflect.TypeOf((*CreateDVPortgroupRequestType)(nil)).Elem()
}

type CreateDVPortgroup_Task CreateDVPortgroupRequestType

func init() {
	t["CreateDVPortgroup_Task"] = reflect.TypeOf((*CreateDVPortgroup_Task)(nil)).Elem()
}

type CreateDVPortgroup_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `Folder.CreateDVS_Task`.
type CreateDVSRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The `DVSCreateSpec`
	// to create the distributed virtual switch.
	Spec DVSCreateSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CreateDVSRequestType"] = reflect.TypeOf((*CreateDVSRequestType)(nil)).Elem()
}

type CreateDVS_Task CreateDVSRequestType

func init() {
	t["CreateDVS_Task"] = reflect.TypeOf((*CreateDVS_Task)(nil)).Elem()
}

type CreateDVS_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateDatacenter CreateDatacenterRequestType

func init() {
	t["CreateDatacenter"] = reflect.TypeOf((*CreateDatacenter)(nil)).Elem()
}

// The parameters of `Folder.CreateDatacenter`.
type CreateDatacenterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Name for the new datacenter. An entity name
	// must be a non-empty string of less than 80 characters.
	// The slash (/), backslash (\\) and percent (%) will be escaped
	// using the URL syntax. For example, %2F.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["CreateDatacenterRequestType"] = reflect.TypeOf((*CreateDatacenterRequestType)(nil)).Elem()
}

type CreateDatacenterResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateDefaultProfile CreateDefaultProfileRequestType

func init() {
	t["CreateDefaultProfile"] = reflect.TypeOf((*CreateDefaultProfile)(nil)).Elem()
}

// The parameters of `HostProfileManager.CreateDefaultProfile`.
type CreateDefaultProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Type of profile to create. The profile types
	// are system-defined
	// (`ApplyProfile*.*ApplyProfile.profileTypeName`).
	ProfileType string `xml:"profileType" json:"profileType"`
	// If specified, the method returns a profile object
	// containing data for the named profile. The type name does not have
	// to be system-defined. A user-defined profile can include various
	// dynamically-defined profiles.
	ProfileTypeName string `xml:"profileTypeName,omitempty" json:"profileTypeName,omitempty"`
	// Base profile used during the operation.
	//
	// Refers instance of `Profile`.
	Profile *ManagedObjectReference `xml:"profile,omitempty" json:"profile,omitempty"`
}

func init() {
	t["CreateDefaultProfileRequestType"] = reflect.TypeOf((*CreateDefaultProfileRequestType)(nil)).Elem()
}

type CreateDefaultProfileResponse struct {
	Returnval BaseApplyProfile `xml:"returnval,typeattr" json:"returnval"`
}

type CreateDescriptor CreateDescriptorRequestType

func init() {
	t["CreateDescriptor"] = reflect.TypeOf((*CreateDescriptor)(nil)).Elem()
}

// The parameters of `OvfManager.CreateDescriptor`.
type CreateDescriptorRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The entity to export. Supported types are `VirtualMachine`
	// and `VirtualApp`.
	//
	// Required privileges: VApp.Export
	//
	// Refers instance of `ManagedEntity`.
	Obj ManagedObjectReference `xml:"obj" json:"obj"`
	// Parameters to the method, bundled in an instance of
	// CreateDescriptorParams.
	Cdp OvfCreateDescriptorParams `xml:"cdp" json:"cdp"`
}

func init() {
	t["CreateDescriptorRequestType"] = reflect.TypeOf((*CreateDescriptorRequestType)(nil)).Elem()
}

type CreateDescriptorResponse struct {
	Returnval OvfCreateDescriptorResult `xml:"returnval" json:"returnval"`
}

type CreateDiagnosticPartition CreateDiagnosticPartitionRequestType

func init() {
	t["CreateDiagnosticPartition"] = reflect.TypeOf((*CreateDiagnosticPartition)(nil)).Elem()
}

// The parameters of `HostDiagnosticSystem.CreateDiagnosticPartition`.
type CreateDiagnosticPartitionRequestType struct {
	This ManagedObjectReference            `xml:"_this" json:"-"`
	Spec HostDiagnosticPartitionCreateSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CreateDiagnosticPartitionRequestType"] = reflect.TypeOf((*CreateDiagnosticPartitionRequestType)(nil)).Elem()
}

type CreateDiagnosticPartitionResponse struct {
}

type CreateDirectory CreateDirectoryRequestType

func init() {
	t["CreateDirectory"] = reflect.TypeOf((*CreateDirectory)(nil)).Elem()
}

// The parameters of `DatastoreNamespaceManager.CreateDirectory`.
type CreateDirectoryRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// datastore on which to create a top-level directory
	//
	// Required privileges: Datastore.Config
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// display name hint for the directory to create
	DisplayName string `xml:"displayName,omitempty" json:"displayName,omitempty"`
	// opaque storage policy to associate with the directory
	Policy string `xml:"policy,omitempty" json:"policy,omitempty"`
	// directory size in MB on vvol/vsan backed object storage.
	// default directory size will be used for vsan backed
	// object storage if not set.
	Size int64 `xml:"size,omitempty" json:"size,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["CreateDirectoryRequestType"] = reflect.TypeOf((*CreateDirectoryRequestType)(nil)).Elem()
}

type CreateDirectoryResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// The parameters of `VcenterVStorageObjectManager.CreateDiskFromSnapshot_Task`.
type CreateDiskFromSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The ID of the snapshot of the virtual storage object.
	SnapshotId ID `xml:"snapshotId" json:"snapshotId"`
	// A user friendly name to be associated with the new disk.
	Name string `xml:"name" json:"name"`
	// SPBM Profile requirement on the new virtual storage object.
	// If not specified datastore default policy would be
	// assigned.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
	// Crypto information of the new disk.
	// If unset and if profile contains an encryption iofilter and
	// if snapshto is unencrypted, then cyrpto will be of
	// type CryptoSpecEncrypt, and filled with keyId that is
	// automatically generated and keyProviderId that is the
	// default kms cluster.
	// If unset and if profile is a default policy and if snapshot
	// is unenrypted, then crypto is treated as CryptoSpecNoOp.
	// If unset and if profile contains an encryption iofilter and
	// if snapshot is encrypted, then cyrpto is treated as
	// CryptoSpecNoOp.
	// If unset and if profile is a default policy and if
	// snapshot is encrypted, then cyrpto is treated as
	// CryptoSpecDecrypt.
	// To recrypt the disk during creating disk, crypto has to be
	// present.
	Crypto BaseCryptoSpec `xml:"crypto,omitempty,typeattr" json:"crypto,omitempty"`
	// Relative location in the specified datastore where disk needs
	// to be created. If not specified disk gets created at the
	// defualt VStorageObject location on the specified datastore.
	Path string `xml:"path,omitempty" json:"path,omitempty"`
}

func init() {
	t["CreateDiskFromSnapshotRequestType"] = reflect.TypeOf((*CreateDiskFromSnapshotRequestType)(nil)).Elem()
}

type CreateDiskFromSnapshot_Task CreateDiskFromSnapshotRequestType

func init() {
	t["CreateDiskFromSnapshot_Task"] = reflect.TypeOf((*CreateDiskFromSnapshot_Task)(nil)).Elem()
}

type CreateDiskFromSnapshot_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VcenterVStorageObjectManager.CreateDisk_Task`.
type CreateDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specification of the virtual storage object
	// to be created.
	Spec VslmCreateSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CreateDiskRequestType"] = reflect.TypeOf((*CreateDiskRequestType)(nil)).Elem()
}

type CreateDisk_Task CreateDiskRequestType

func init() {
	t["CreateDisk_Task"] = reflect.TypeOf((*CreateDisk_Task)(nil)).Elem()
}

type CreateDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateFilter CreateFilterRequestType

func init() {
	t["CreateFilter"] = reflect.TypeOf((*CreateFilter)(nil)).Elem()
}

// The parameters of `PropertyCollector.CreateFilter`.
type CreateFilterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specifications for the filter.
	Spec PropertyFilterSpec `xml:"spec" json:"spec"`
	// Flag to specify whether a change to a nested property should report
	// only the nested change or the entire specified property value. If the
	// value is true, a change should report only the nested property. If
	// the value is false, a change should report the enclosing property
	// named in the filter.
	PartialUpdates bool `xml:"partialUpdates" json:"partialUpdates"`
}

func init() {
	t["CreateFilterRequestType"] = reflect.TypeOf((*CreateFilterRequestType)(nil)).Elem()
}

type CreateFilterResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateFolder CreateFolderRequestType

func init() {
	t["CreateFolder"] = reflect.TypeOf((*CreateFolder)(nil)).Elem()
}

// The parameters of `Folder.CreateFolder`.
type CreateFolderRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name to be given the new folder. An entity name
	// must be a non-empty string of less than 80 characters.
	// The slash (/), backslash (\\) and percent (%) will be escaped
	// using the URL syntax. For example, %2F. Any percent (%)
	// character used in this parameter must be escaped, unless
	// it is used to start an escape sequence. Clients may also
	// escape any other characters in this parameter.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["CreateFolderRequestType"] = reflect.TypeOf((*CreateFolderRequestType)(nil)).Elem()
}

type CreateFolderResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateGroup CreateGroupRequestType

func init() {
	t["CreateGroup"] = reflect.TypeOf((*CreateGroup)(nil)).Elem()
}

// The parameters of `HostLocalAccountManager.CreateGroup`.
type CreateGroupRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specification of group being created.
	Group BaseHostAccountSpec `xml:"group,typeattr" json:"group"`
}

func init() {
	t["CreateGroupRequestType"] = reflect.TypeOf((*CreateGroupRequestType)(nil)).Elem()
}

type CreateGroupResponse struct {
}

type CreateImportSpec CreateImportSpecRequestType

func init() {
	t["CreateImportSpec"] = reflect.TypeOf((*CreateImportSpec)(nil)).Elem()
}

// The parameters of `OvfManager.CreateImportSpec`.
type CreateImportSpecRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The OVF descriptor of the entity.
	OvfDescriptor string `xml:"ovfDescriptor" json:"ovfDescriptor"`
	// The resource pool to import the entity to. May be a
	// vApp.
	//
	// Required privileges: VApp.Import
	//
	// Refers instance of `ResourcePool`.
	ResourcePool ManagedObjectReference `xml:"resourcePool" json:"resourcePool"`
	// The datastore on which to create the inventory objects
	// of the entity, for example "storage1". The privilege
	// Datastore.AllocateSpace is required on the datastore.
	//
	// Required privileges: Datastore.AllocateSpace
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// Additional parameters to the method, bundled in an instance of
	// CreateImportSpecParams.
	Cisp OvfCreateImportSpecParams `xml:"cisp" json:"cisp"`
}

func init() {
	t["CreateImportSpecRequestType"] = reflect.TypeOf((*CreateImportSpecRequestType)(nil)).Elem()
}

type CreateImportSpecResponse struct {
	Returnval OvfCreateImportSpecResult `xml:"returnval" json:"returnval"`
}

type CreateInventoryView CreateInventoryViewRequestType

func init() {
	t["CreateInventoryView"] = reflect.TypeOf((*CreateInventoryView)(nil)).Elem()
}

type CreateInventoryViewRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["CreateInventoryViewRequestType"] = reflect.TypeOf((*CreateInventoryViewRequestType)(nil)).Elem()
}

type CreateInventoryViewResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateIpPool CreateIpPoolRequestType

func init() {
	t["CreateIpPool"] = reflect.TypeOf((*CreateIpPool)(nil)).Elem()
}

// The parameters of `IpPoolManager.CreateIpPool`.
type CreateIpPoolRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datacenter on which to create the pool.
	//
	// Required privileges: Datacenter.IpPoolConfig
	//
	// Refers instance of `Datacenter`.
	Dc ManagedObjectReference `xml:"dc" json:"dc"`
	// The IP pool to create on the server
	Pool IpPool `xml:"pool" json:"pool"`
}

func init() {
	t["CreateIpPoolRequestType"] = reflect.TypeOf((*CreateIpPoolRequestType)(nil)).Elem()
}

type CreateIpPoolResponse struct {
	Returnval int32 `xml:"returnval" json:"returnval"`
}

type CreateListView CreateListViewRequestType

func init() {
	t["CreateListView"] = reflect.TypeOf((*CreateListView)(nil)).Elem()
}

type CreateListViewFromView CreateListViewFromViewRequestType

func init() {
	t["CreateListViewFromView"] = reflect.TypeOf((*CreateListViewFromView)(nil)).Elem()
}

// The parameters of `ViewManager.CreateListViewFromView`.
type CreateListViewFromViewRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The view that will provide the object list for the
	// new ListView object.
	//
	// Refers instance of `View`.
	View ManagedObjectReference `xml:"view" json:"view"`
}

func init() {
	t["CreateListViewFromViewRequestType"] = reflect.TypeOf((*CreateListViewFromViewRequestType)(nil)).Elem()
}

type CreateListViewFromViewResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `ViewManager.CreateListView`.
type CreateListViewRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The initial list of objects in the view.
	//
	// Required privileges: System.View
	Obj []ManagedObjectReference `xml:"obj,omitempty" json:"obj,omitempty"`
}

func init() {
	t["CreateListViewRequestType"] = reflect.TypeOf((*CreateListViewRequestType)(nil)).Elem()
}

type CreateListViewResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateLocalDatastore CreateLocalDatastoreRequestType

func init() {
	t["CreateLocalDatastore"] = reflect.TypeOf((*CreateLocalDatastore)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.CreateLocalDatastore`.
type CreateLocalDatastoreRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of a datastore to create on the local host.
	Name string `xml:"name" json:"name"`
	// The file path for a directory in which the virtual machine data
	// will be stored.
	Path string `xml:"path" json:"path"`
}

func init() {
	t["CreateLocalDatastoreRequestType"] = reflect.TypeOf((*CreateLocalDatastoreRequestType)(nil)).Elem()
}

type CreateLocalDatastoreResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateNasDatastore CreateNasDatastoreRequestType

func init() {
	t["CreateNasDatastore"] = reflect.TypeOf((*CreateNasDatastore)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.CreateNasDatastore`.
type CreateNasDatastoreRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specification for creating a network-attached storage volume.
	Spec HostNasVolumeSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CreateNasDatastoreRequestType"] = reflect.TypeOf((*CreateNasDatastoreRequestType)(nil)).Elem()
}

type CreateNasDatastoreResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostNvdimmSystem.CreateNvdimmNamespace_Task`.
type CreateNvdimmNamespaceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Parameters to create the required namespace.
	CreateSpec NvdimmNamespaceCreateSpec `xml:"createSpec" json:"createSpec"`
}

func init() {
	t["CreateNvdimmNamespaceRequestType"] = reflect.TypeOf((*CreateNvdimmNamespaceRequestType)(nil)).Elem()
}

type CreateNvdimmNamespace_Task CreateNvdimmNamespaceRequestType

func init() {
	t["CreateNvdimmNamespace_Task"] = reflect.TypeOf((*CreateNvdimmNamespace_Task)(nil)).Elem()
}

type CreateNvdimmNamespace_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostNvdimmSystem.CreateNvdimmPMemNamespace_Task`.
type CreateNvdimmPMemNamespaceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Parameters to create the required namespace.
	CreateSpec NvdimmPMemNamespaceCreateSpec `xml:"createSpec" json:"createSpec"`
}

func init() {
	t["CreateNvdimmPMemNamespaceRequestType"] = reflect.TypeOf((*CreateNvdimmPMemNamespaceRequestType)(nil)).Elem()
}

type CreateNvdimmPMemNamespace_Task CreateNvdimmPMemNamespaceRequestType

func init() {
	t["CreateNvdimmPMemNamespace_Task"] = reflect.TypeOf((*CreateNvdimmPMemNamespace_Task)(nil)).Elem()
}

type CreateNvdimmPMemNamespace_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateNvmeOverRdmaAdapter CreateNvmeOverRdmaAdapterRequestType

func init() {
	t["CreateNvmeOverRdmaAdapter"] = reflect.TypeOf((*CreateNvmeOverRdmaAdapter)(nil)).Elem()
}

// The parameters of `HostStorageSystem.CreateNvmeOverRdmaAdapter`.
type CreateNvmeOverRdmaAdapterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device name of the RDMA device
	// to be used to create the software adapter.
	// Can be obtained from `HostRdmaDevice.device`.
	RdmaDeviceName string `xml:"rdmaDeviceName" json:"rdmaDeviceName"`
}

func init() {
	t["CreateNvmeOverRdmaAdapterRequestType"] = reflect.TypeOf((*CreateNvmeOverRdmaAdapterRequestType)(nil)).Elem()
}

type CreateNvmeOverRdmaAdapterResponse struct {
}

type CreateObjectScheduledTask CreateObjectScheduledTaskRequestType

func init() {
	t["CreateObjectScheduledTask"] = reflect.TypeOf((*CreateObjectScheduledTask)(nil)).Elem()
}

// The parameters of `ScheduledTaskManager.CreateObjectScheduledTask`.
type CreateObjectScheduledTaskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The managed object for which the
	// scheduled task triggers an action. You can
	// schedule tasks on any managed object.
	//
	// Required privileges: ScheduledTask.Create
	Obj ManagedObjectReference `xml:"obj" json:"obj"`
	// The specification for the new scheduled task.
	Spec BaseScheduledTaskSpec `xml:"spec,typeattr" json:"spec"`
}

func init() {
	t["CreateObjectScheduledTaskRequestType"] = reflect.TypeOf((*CreateObjectScheduledTaskRequestType)(nil)).Elem()
}

type CreateObjectScheduledTaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreatePerfInterval CreatePerfIntervalRequestType

func init() {
	t["CreatePerfInterval"] = reflect.TypeOf((*CreatePerfInterval)(nil)).Elem()
}

// The parameters of `PerformanceManager.CreatePerfInterval`.
type CreatePerfIntervalRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A custom interval, specified as the number of seconds to hold data in the
	// database, a user-specified unique name, and a sampling period (in
	// seconds).
	IntervalId PerfInterval `xml:"intervalId" json:"intervalId"`
}

func init() {
	t["CreatePerfIntervalRequestType"] = reflect.TypeOf((*CreatePerfIntervalRequestType)(nil)).Elem()
}

type CreatePerfIntervalResponse struct {
}

type CreateProfile CreateProfileRequestType

func init() {
	t["CreateProfile"] = reflect.TypeOf((*CreateProfile)(nil)).Elem()
}

// The parameters of `ProfileManager.CreateProfile`.
type CreateProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specification for the profile being created.
	// Usually a derived class CreateSpec can be used to create the Profile.
	CreateSpec BaseProfileCreateSpec `xml:"createSpec,typeattr" json:"createSpec"`
}

func init() {
	t["CreateProfileRequestType"] = reflect.TypeOf((*CreateProfileRequestType)(nil)).Elem()
}

type CreateProfileResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreatePropertyCollector CreatePropertyCollectorRequestType

func init() {
	t["CreatePropertyCollector"] = reflect.TypeOf((*CreatePropertyCollector)(nil)).Elem()
}

type CreatePropertyCollectorRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["CreatePropertyCollectorRequestType"] = reflect.TypeOf((*CreatePropertyCollectorRequestType)(nil)).Elem()
}

type CreatePropertyCollectorResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateRegistryKeyInGuest CreateRegistryKeyInGuestRequestType

func init() {
	t["CreateRegistryKeyInGuest"] = reflect.TypeOf((*CreateRegistryKeyInGuest)(nil)).Elem()
}

// The parameters of `GuestWindowsRegistryManager.CreateRegistryKeyInGuest`.
type CreateRegistryKeyInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Modify
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The path to the registry key to be created.
	KeyName GuestRegKeyNameSpec `xml:"keyName" json:"keyName"`
	// If true, the key is created in memory and is not
	// preserved across system reboot. Otherwise, it shall
	// persist in the file system.
	IsVolatile bool `xml:"isVolatile" json:"isVolatile"`
	// User defined class type for this key. May be omitted.
	ClassType string `xml:"classType,omitempty" json:"classType,omitempty"`
}

func init() {
	t["CreateRegistryKeyInGuestRequestType"] = reflect.TypeOf((*CreateRegistryKeyInGuestRequestType)(nil)).Elem()
}

type CreateRegistryKeyInGuestResponse struct {
}

type CreateResourcePool CreateResourcePoolRequestType

func init() {
	t["CreateResourcePool"] = reflect.TypeOf((*CreateResourcePool)(nil)).Elem()
}

// The parameters of `ResourcePool.CreateResourcePool`.
type CreateResourcePoolRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the ResourcePool. Any % (percent) character
	// used in this parameter must be escaped, unless it is used
	// to start an escape sequence. Clients may also escape any
	// other characters in this parameter.
	Name string `xml:"name" json:"name"`
	// The spec for the ResourcePool.
	// All values in ResourceAllocationInfo must be specified and
	// are not optional.
	Spec ResourceConfigSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CreateResourcePoolRequestType"] = reflect.TypeOf((*CreateResourcePoolRequestType)(nil)).Elem()
}

type CreateResourcePoolResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateScheduledTask CreateScheduledTaskRequestType

func init() {
	t["CreateScheduledTask"] = reflect.TypeOf((*CreateScheduledTask)(nil)).Elem()
}

// The parameters of `ScheduledTaskManager.CreateScheduledTask`.
type CreateScheduledTaskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The managed entity (or entities) for which the
	// scheduled task triggers an action. You can
	// schedule tasks on any managed entity. If the
	// scheduled task is associated with a leaf node in
	// the inventory tree, it applies only to a single
	// entity (virtual machine or host). If the
	// task is associated with a folder, a datacenter, a
	// compute resource, or a resource pool, it applies to
	// the virtual machine or host descendants of the entity.
	//
	// Required privileges: ScheduledTask.Create
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// The specification for the new scheduled task.
	Spec BaseScheduledTaskSpec `xml:"spec,typeattr" json:"spec"`
}

func init() {
	t["CreateScheduledTaskRequestType"] = reflect.TypeOf((*CreateScheduledTaskRequestType)(nil)).Elem()
}

type CreateScheduledTaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateScreenshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["CreateScreenshotRequestType"] = reflect.TypeOf((*CreateScreenshotRequestType)(nil)).Elem()
}

type CreateScreenshot_Task CreateScreenshotRequestType

func init() {
	t["CreateScreenshot_Task"] = reflect.TypeOf((*CreateScreenshot_Task)(nil)).Elem()
}

type CreateScreenshot_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.CreateSecondaryVMEx_Task`.
type CreateSecondaryVMExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The host where the secondary virtual machine is to be
	// created and powered on. If no host is specified, a compatible host will be
	// selected by the system. If a host cannot be found for the secondary or the specified
	// host is not suitable, the secondary will not be created and a fault will be returned.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// This parameter `FaultToleranceVMConfigSpec` can
	// be used to specify the storage location of the fault tolerance
	// tie-breaker file, secondary configuration file and secondary
	// disks.
	//
	// If the virtual machine is on a vSAN datastore, then the
	// Fault Tolerance secondary virtual machine and the tie-breaker
	// file also have to be placed on that same vSAN datastore.
	// Conversely, if a primary VM is not using vSAN datastore,
	// then its Fault Tolerance secondary virtual machine can
	// not be placed on a vSAN datastore. Fault Tolerance is not
	// supported for VMs that are using both vSAN and non-vSAN
	// datastores for its configuration and disks.
	//
	// If the virtual machine is using persistent memory for any of
	// its disks, then its corresponding secondary disk placement
	// entry should not be specified in the
	// `FaultToleranceVMConfigSpec`. The system will
	// automatically place the corresponding secondary disk on
	// persistent memory.
	Spec *FaultToleranceConfigSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["CreateSecondaryVMExRequestType"] = reflect.TypeOf((*CreateSecondaryVMExRequestType)(nil)).Elem()
}

type CreateSecondaryVMEx_Task CreateSecondaryVMExRequestType

func init() {
	t["CreateSecondaryVMEx_Task"] = reflect.TypeOf((*CreateSecondaryVMEx_Task)(nil)).Elem()
}

type CreateSecondaryVMEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.CreateSecondaryVM_Task`.
type CreateSecondaryVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The host where the secondary virtual machine is to be
	// created and powered on. If no host is specified, a compatible host will be
	// selected by the system. If a host cannot be found for the secondary or the specified
	// host is not suitable, the secondary will not be created and a fault will be returned.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["CreateSecondaryVMRequestType"] = reflect.TypeOf((*CreateSecondaryVMRequestType)(nil)).Elem()
}

type CreateSecondaryVM_Task CreateSecondaryVMRequestType

func init() {
	t["CreateSecondaryVM_Task"] = reflect.TypeOf((*CreateSecondaryVM_Task)(nil)).Elem()
}

type CreateSecondaryVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.CreateSnapshotEx_Task`.
type CreateSnapshotExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name for this snapshot. The name need not be unique for
	// this virtual machine.
	Name string `xml:"name" json:"name"`
	// A description for this snapshot. If omitted, a default
	// description may be provided.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// If TRUE, a dump of the internal state of the virtual machine
	// (basically a memory dump) is included in the snapshot. Memory snapshots
	// consume time and resources, and thus take longer to create.
	// When set to FALSE, the power state of the snapshot is set to powered off.
	//
	// `capabilities`
	// indicates whether or not this virtual machine supports this operation.
	// For a virtual machine in suspended state we always include memory
	// unless `VirtualMachineCapability.diskOnlySnapshotOnSuspendedVMSupported` is
	// true.
	Memory bool `xml:"memory" json:"memory"`
	// Spec for granular control over quiesce details.
	// If quiesceSpec is set and the virtual machine is powered on when the
	// snapshot is taken, VMware Tools is used to quiesce the file
	// system in the virtual machine. This assures that a disk snapshot
	// represents a consistent state of the guest file systems. If the virtual
	// machine is powered off or VMware Tools are not available, the quiesce
	// spec is ignored. If the spec type is `VirtualMachineGuestQuiesceSpec`, the
	// default quiescing process will be applied. If the spec type is
	// `VirtualMachineWindowsQuiesceSpec` and Guest OS is Windows, the parameters
	// will control the VSS process.
	QuiesceSpec BaseVirtualMachineGuestQuiesceSpec `xml:"quiesceSpec,omitempty,typeattr" json:"quiesceSpec,omitempty"`
}

func init() {
	t["CreateSnapshotExRequestType"] = reflect.TypeOf((*CreateSnapshotExRequestType)(nil)).Elem()
}

type CreateSnapshotEx_Task CreateSnapshotExRequestType

func init() {
	t["CreateSnapshotEx_Task"] = reflect.TypeOf((*CreateSnapshotEx_Task)(nil)).Elem()
}

type CreateSnapshotEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.CreateSnapshot_Task`.
type CreateSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name for this snapshot. The name need not be unique for
	// this virtual machine.
	Name string `xml:"name" json:"name"`
	// A description for this snapshot. If omitted, a default
	// description may be provided.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// If TRUE, a dump of the internal state of the virtual machine
	// (basically a memory dump) is included in the snapshot. Memory snapshots
	// consume time and resources, and thus take longer to create. When set to FALSE,
	// the power state of the snapshot is set to powered off.
	//
	// `capabilities`
	// indicates whether or not this virtual machine supports this operation.
	// For a virtual machine in suspended state we always include memory
	// unless `VirtualMachineCapability.diskOnlySnapshotOnSuspendedVMSupported` is
	// true.
	Memory bool `xml:"memory" json:"memory"`
	// If TRUE and the virtual machine is powered on when the
	// snapshot is taken, VMware Tools is used to quiesce the file
	// system in the virtual machine. This assures that a disk snapshot
	// represents a consistent state of the guest file systems. If the virtual machine
	// is powered off or VMware Tools are not available, the quiesce flag is ignored.
	Quiesce bool `xml:"quiesce" json:"quiesce"`
}

func init() {
	t["CreateSnapshotRequestType"] = reflect.TypeOf((*CreateSnapshotRequestType)(nil)).Elem()
}

type CreateSnapshot_Task CreateSnapshotRequestType

func init() {
	t["CreateSnapshot_Task"] = reflect.TypeOf((*CreateSnapshot_Task)(nil)).Elem()
}

type CreateSnapshot_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateSoftwareAdapter CreateSoftwareAdapterRequestType

func init() {
	t["CreateSoftwareAdapter"] = reflect.TypeOf((*CreateSoftwareAdapter)(nil)).Elem()
}

// The parameters of `HostStorageSystem.CreateSoftwareAdapter`.
type CreateSoftwareAdapterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A data object that specifices the parameters necessary
	// to create a software host bus adapter of a specific type.
	Spec BaseHostHbaCreateSpec `xml:"spec,typeattr" json:"spec"`
}

func init() {
	t["CreateSoftwareAdapterRequestType"] = reflect.TypeOf((*CreateSoftwareAdapterRequestType)(nil)).Elem()
	minAPIVersionForType["CreateSoftwareAdapterRequestType"] = "7.0.3.0"
}

type CreateSoftwareAdapterResponse struct {
}

type CreateStoragePod CreateStoragePodRequestType

func init() {
	t["CreateStoragePod"] = reflect.TypeOf((*CreateStoragePod)(nil)).Elem()
}

// The parameters of `Folder.CreateStoragePod`.
type CreateStoragePodRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Name for the new storage pod.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["CreateStoragePodRequestType"] = reflect.TypeOf((*CreateStoragePodRequestType)(nil)).Elem()
}

type CreateStoragePodResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateTask CreateTaskRequestType

func init() {
	t["CreateTask"] = reflect.TypeOf((*CreateTask)(nil)).Elem()
}

// This data object type specifies the type of task to be created
// when this action is triggered.
type CreateTaskAction struct {
	Action

	// Extension registered task type identifier
	// for type of task being created.
	TaskTypeId string `xml:"taskTypeId" json:"taskTypeId"`
	// Whether the task should be cancelable.
	Cancelable bool `xml:"cancelable" json:"cancelable"`
}

func init() {
	t["CreateTaskAction"] = reflect.TypeOf((*CreateTaskAction)(nil)).Elem()
}

// The parameters of `TaskManager.CreateTask`.
type CreateTaskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// ManagedObject with which Task will be associated
	Obj ManagedObjectReference `xml:"obj" json:"obj"`
	// Extension registered task type identifier
	// for type of task being created
	TaskTypeId string `xml:"taskTypeId" json:"taskTypeId"`
	// The name of the user on whose behalf the
	// Extension is creating the task
	InitiatedBy string `xml:"initiatedBy,omitempty" json:"initiatedBy,omitempty"`
	// True if the task should be cancelable,
	// false otherwise
	Cancelable bool `xml:"cancelable" json:"cancelable"`
	// Key of the task that is the parent of this task
	ParentTaskKey string `xml:"parentTaskKey,omitempty" json:"parentTaskKey,omitempty"`
	// Activation Id is a client-provided token to link an
	// API call with a task. When provided, the activationId is added to the
	// `TaskInfo`
	ActivationId string `xml:"activationId,omitempty" json:"activationId,omitempty"`
}

func init() {
	t["CreateTaskRequestType"] = reflect.TypeOf((*CreateTaskRequestType)(nil)).Elem()
}

type CreateTaskResponse struct {
	Returnval TaskInfo `xml:"returnval" json:"returnval"`
}

type CreateTemporaryDirectoryInGuest CreateTemporaryDirectoryInGuestRequestType

func init() {
	t["CreateTemporaryDirectoryInGuest"] = reflect.TypeOf((*CreateTemporaryDirectoryInGuest)(nil)).Elem()
}

// The parameters of `GuestFileManager.CreateTemporaryDirectoryInGuest`.
type CreateTemporaryDirectoryInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual Machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Modify
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The prefix to be given to the new temporary directory.
	Prefix string `xml:"prefix" json:"prefix"`
	// The suffix to be given to the new temporary directory.
	Suffix string `xml:"suffix" json:"suffix"`
	// The complete path to the directory in which to create the
	// new directory. If unset or an empty string, a guest-specific location
	// will be used.
	DirectoryPath string `xml:"directoryPath,omitempty" json:"directoryPath,omitempty"`
}

func init() {
	t["CreateTemporaryDirectoryInGuestRequestType"] = reflect.TypeOf((*CreateTemporaryDirectoryInGuestRequestType)(nil)).Elem()
}

type CreateTemporaryDirectoryInGuestResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type CreateTemporaryFileInGuest CreateTemporaryFileInGuestRequestType

func init() {
	t["CreateTemporaryFileInGuest"] = reflect.TypeOf((*CreateTemporaryFileInGuest)(nil)).Elem()
}

// The parameters of `GuestFileManager.CreateTemporaryFileInGuest`.
type CreateTemporaryFileInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual Machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Modify
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The prefix to be given to the new temporary file.
	Prefix string `xml:"prefix" json:"prefix"`
	// The suffix to be given to the new temporary file.
	Suffix string `xml:"suffix" json:"suffix"`
	// The complete path to the directory in which to
	// create the file.
	// If unset, or an empty string, a guest-specific location will be used.
	DirectoryPath string `xml:"directoryPath,omitempty" json:"directoryPath,omitempty"`
}

func init() {
	t["CreateTemporaryFileInGuestRequestType"] = reflect.TypeOf((*CreateTemporaryFileInGuestRequestType)(nil)).Elem()
}

type CreateTemporaryFileInGuestResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type CreateUser CreateUserRequestType

func init() {
	t["CreateUser"] = reflect.TypeOf((*CreateUser)(nil)).Elem()
}

// The parameters of `HostLocalAccountManager.CreateUser`.
type CreateUserRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specification of user being created.
	User BaseHostAccountSpec `xml:"user,typeattr" json:"user"`
}

func init() {
	t["CreateUserRequestType"] = reflect.TypeOf((*CreateUserRequestType)(nil)).Elem()
}

type CreateUserResponse struct {
}

type CreateVApp CreateVAppRequestType

func init() {
	t["CreateVApp"] = reflect.TypeOf((*CreateVApp)(nil)).Elem()
}

// The parameters of `ResourcePool.CreateVApp`.
type CreateVAppRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the vApp container in the inventory
	Name string `xml:"name" json:"name"`
	// The resource configuration for the vApp container (same as for a
	// regular resource pool).
	ResSpec ResourceConfigSpec `xml:"resSpec" json:"resSpec"`
	// The specification of the vApp specific meta-data.
	ConfigSpec VAppConfigSpec `xml:"configSpec" json:"configSpec"`
	// The parent folder for the vApp. This must be null if this is
	// a child vApp.
	//
	// Refers instance of `Folder`.
	VmFolder *ManagedObjectReference `xml:"vmFolder,omitempty" json:"vmFolder,omitempty"`
}

func init() {
	t["CreateVAppRequestType"] = reflect.TypeOf((*CreateVAppRequestType)(nil)).Elem()
}

type CreateVAppResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `Folder.CreateVM_Task`.
type CreateVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The configuration of the virtual machine hardware.
	Config VirtualMachineConfigSpec `xml:"config" json:"config"`
	// The resource pool to which the virtual machine will be attached.
	//
	// Required privileges: Resource.AssignVMToPool
	//
	// Refers instance of `ResourcePool`.
	Pool ManagedObjectReference `xml:"pool" json:"pool"`
	// The target host on which the virtual machine will run. This must
	// specify a host that is a member of the ComputeResource indirectly
	// specified by the pool. For a stand-alone host or a cluster with DRS,
	// host can be omitted, and the system selects a default.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["CreateVMRequestType"] = reflect.TypeOf((*CreateVMRequestType)(nil)).Elem()
}

type CreateVM_Task CreateVMRequestType

func init() {
	t["CreateVM_Task"] = reflect.TypeOf((*CreateVM_Task)(nil)).Elem()
}

type CreateVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualDiskManager.CreateVirtualDisk_Task`.
type CreateVirtualDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a
	// URL referring to the virtual disk to be created.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// The specification of the virtual disk to be created.
	Spec BaseVirtualDiskSpec `xml:"spec,typeattr" json:"spec"`
}

func init() {
	t["CreateVirtualDiskRequestType"] = reflect.TypeOf((*CreateVirtualDiskRequestType)(nil)).Elem()
}

type CreateVirtualDisk_Task CreateVirtualDiskRequestType

func init() {
	t["CreateVirtualDisk_Task"] = reflect.TypeOf((*CreateVirtualDisk_Task)(nil)).Elem()
}

type CreateVirtualDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateVmfsDatastore CreateVmfsDatastoreRequestType

func init() {
	t["CreateVmfsDatastore"] = reflect.TypeOf((*CreateVmfsDatastore)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.CreateVmfsDatastore`.
type CreateVmfsDatastoreRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specification for creating a datastore backed by a VMFS.
	Spec VmfsDatastoreCreateSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CreateVmfsDatastoreRequestType"] = reflect.TypeOf((*CreateVmfsDatastoreRequestType)(nil)).Elem()
}

type CreateVmfsDatastoreResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateVvolDatastore CreateVvolDatastoreRequestType

func init() {
	t["CreateVvolDatastore"] = reflect.TypeOf((*CreateVvolDatastore)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.CreateVvolDatastore`.
type CreateVvolDatastoreRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specification for creating a Virtual-Volume based datastore.
	Spec HostDatastoreSystemVvolDatastoreSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CreateVvolDatastoreRequestType"] = reflect.TypeOf((*CreateVvolDatastoreRequestType)(nil)).Elem()
}

type CreateVvolDatastoreResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Data Object representing a cryptographic key.
type CryptoKeyId struct {
	DynamicData

	// Unique key ID.
	//
	// When creating a key may be replaced with the ID generated by the KMS
	// server.
	// An empty string must be used when encrypting with a Trusted Key Provider,
	// because the key is generated at the time of encryption.
	KeyId string `xml:"keyId" json:"keyId"`
	// The provider holding the key data.
	//
	// May be ignored if the key is known to be stored in another provider.
	ProviderId *KeyProviderId `xml:"providerId,omitempty" json:"providerId,omitempty"`
}

func init() {
	t["CryptoKeyId"] = reflect.TypeOf((*CryptoKeyId)(nil)).Elem()
}

// Data Object representing a plain text cryptographic key.
type CryptoKeyPlain struct {
	DynamicData

	KeyId     CryptoKeyId `xml:"keyId" json:"keyId"`
	Algorithm string      `xml:"algorithm" json:"algorithm"`
	KeyData   string      `xml:"keyData" json:"keyData"`
}

func init() {
	t["CryptoKeyPlain"] = reflect.TypeOf((*CryptoKeyPlain)(nil)).Elem()
}

// CryptoKeyResult.java --
// Data Object representing a cryptographic key operation result.
type CryptoKeyResult struct {
	DynamicData

	KeyId   CryptoKeyId `xml:"keyId" json:"keyId"`
	Success bool        `xml:"success" json:"success"`
	Reason  string      `xml:"reason,omitempty" json:"reason,omitempty"`
	// Fault which includes details about the error.
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty" vim:"7.0.1.0"`
}

func init() {
	t["CryptoKeyResult"] = reflect.TypeOf((*CryptoKeyResult)(nil)).Elem()
}

type CryptoManagerHostDisable CryptoManagerHostDisableRequestType

func init() {
	t["CryptoManagerHostDisable"] = reflect.TypeOf((*CryptoManagerHostDisable)(nil)).Elem()
}

type CryptoManagerHostDisableRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["CryptoManagerHostDisableRequestType"] = reflect.TypeOf((*CryptoManagerHostDisableRequestType)(nil)).Elem()
}

type CryptoManagerHostDisableResponse struct {
}

type CryptoManagerHostEnable CryptoManagerHostEnableRequestType

func init() {
	t["CryptoManagerHostEnable"] = reflect.TypeOf((*CryptoManagerHostEnable)(nil)).Elem()
}

// The parameters of `CryptoManagerHost.CryptoManagerHostEnable`.
type CryptoManagerHostEnableRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The key to be used for core dump encryption
	InitialKey CryptoKeyPlain `xml:"initialKey" json:"initialKey"`
}

func init() {
	t["CryptoManagerHostEnableRequestType"] = reflect.TypeOf((*CryptoManagerHostEnableRequestType)(nil)).Elem()
}

type CryptoManagerHostEnableResponse struct {
}

// Status of a Crypto key on host.
type CryptoManagerHostKeyStatus struct {
	DynamicData

	// Crypto key Id.
	KeyId CryptoKeyId `xml:"keyId" json:"keyId"`
	// Whether the key is present in key cache for crypto operation.
	Present bool `xml:"present" json:"present"`
	// Key management type.
	//
	// See `CryptoManagerHostKeyManagementType_enum` for valid values.
	ManagementType string `xml:"managementType,omitempty" json:"managementType,omitempty"`
	// Whether the provider of the key has been granted access.
	AccessGranted *bool `xml:"accessGranted" json:"accessGranted,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["CryptoManagerHostKeyStatus"] = reflect.TypeOf((*CryptoManagerHostKeyStatus)(nil)).Elem()
	minAPIVersionForType["CryptoManagerHostKeyStatus"] = "8.0.1.0"
}

type CryptoManagerHostPrepare CryptoManagerHostPrepareRequestType

func init() {
	t["CryptoManagerHostPrepare"] = reflect.TypeOf((*CryptoManagerHostPrepare)(nil)).Elem()
}

type CryptoManagerHostPrepareRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["CryptoManagerHostPrepareRequestType"] = reflect.TypeOf((*CryptoManagerHostPrepareRequestType)(nil)).Elem()
}

type CryptoManagerHostPrepareResponse struct {
}

type CryptoManagerKmipCertSignRequest struct {
	DynamicData

	// Common name for the certificate sign request.
	//
	// This is fully qualified domain name that you wish to secure.
	CommonName string `xml:"commonName,omitempty" json:"commonName,omitempty"`
	// Organization name for the certificate sign request.
	//
	// Usually the legal name of a company or entity and
	// should include any suffixes such as Ltd., Inc., or Corp.
	Organization string `xml:"organization,omitempty" json:"organization,omitempty"`
	// Organizational unit name for the certificate sign request.
	//
	// Internal organization department/division name.
	OrganizationUnit string `xml:"organizationUnit,omitempty" json:"organizationUnit,omitempty"`
	// Locality name for the certificate sign request.
	//
	// Town, city, village, etc.
	Locality string `xml:"locality,omitempty" json:"locality,omitempty"`
	// State name for the certificate sign request.
	//
	// Province, region, county or state.
	State string `xml:"state,omitempty" json:"state,omitempty"`
	// Country Name for the certificate sign request.
	//
	// The two-letter ISO code for the country where your
	// organization is located.
	Country string `xml:"country,omitempty" json:"country,omitempty"`
	// Email address for the certificate sign request.
	//
	// The organization contact, usually of the certificate
	// administrator or IT department.
	Email string `xml:"email,omitempty" json:"email,omitempty"`
}

func init() {
	t["CryptoManagerKmipCertSignRequest"] = reflect.TypeOf((*CryptoManagerKmipCertSignRequest)(nil)).Elem()
	minAPIVersionForType["CryptoManagerKmipCertSignRequest"] = "8.0.1.0"
}

// Basic information of a certificate.
type CryptoManagerKmipCertificateInfo struct {
	DynamicData

	// Subject identifies whom the certificate is issued to.
	Subject string `xml:"subject" json:"subject"`
	// Issuer identifies the party that issued this certificate.
	Issuer string `xml:"issuer" json:"issuer"`
	// The unique serial number of the certificate given by issuer.
	SerialNumber string `xml:"serialNumber" json:"serialNumber"`
	// The beginning time of the period of validity.
	NotBefore time.Time `xml:"notBefore" json:"notBefore"`
	// The ending time of the period of validity.
	NotAfter time.Time `xml:"notAfter" json:"notAfter"`
	// The SSL SHA1 fingerprint of the certificate.
	Fingerprint string `xml:"fingerprint" json:"fingerprint"`
	// The timestamp when the state of the certificate is checked.
	CheckTime time.Time `xml:"checkTime" json:"checkTime"`
	// Total seconds since this certificate has entered valid state.
	//
	// It is the time difference between "now" and "notBefore".
	// If it is negative value, that means the certificate will become
	// valid in a future time.
	SecondsSinceValid int32 `xml:"secondsSinceValid,omitempty" json:"secondsSinceValid,omitempty"`
	// Total seconds before this certificate expires.
	//
	// It is the time difference between "notAfter" and "now".
	// If it is negative value, that means the certificate has already
	// expired.
	SecondsBeforeExpire int32 `xml:"secondsBeforeExpire,omitempty" json:"secondsBeforeExpire,omitempty"`
}

func init() {
	t["CryptoManagerKmipCertificateInfo"] = reflect.TypeOf((*CryptoManagerKmipCertificateInfo)(nil)).Elem()
}

// Status of a KMIP cluster.
type CryptoManagerKmipClusterStatus struct {
	DynamicData

	// The ID of the KMIP cluster.
	ClusterId KeyProviderId `xml:"clusterId" json:"clusterId"`
	// KMS cluster overall status.
	OverallStatus ManagedEntityStatus `xml:"overallStatus,omitempty" json:"overallStatus,omitempty"`
	// Key provider management type.
	//
	// See `KmipClusterInfoKmsManagementType_enum` for valid values.
	ManagementType string `xml:"managementType,omitempty" json:"managementType,omitempty"`
	// Status of the KMIP servers in this cluster.
	Servers []CryptoManagerKmipServerStatus `xml:"servers" json:"servers"`
	// The basic information about the client's certificate.
	ClientCertInfo *CryptoManagerKmipCertificateInfo `xml:"clientCertInfo,omitempty" json:"clientCertInfo,omitempty"`
}

func init() {
	t["CryptoManagerKmipClusterStatus"] = reflect.TypeOf((*CryptoManagerKmipClusterStatus)(nil)).Elem()
}

// Status of a Crypto key
type CryptoManagerKmipCryptoKeyStatus struct {
	DynamicData

	// Crypto key Id
	KeyId CryptoKeyId `xml:"keyId" json:"keyId"`
	// If the key is available for crypto operation
	KeyAvailable *bool `xml:"keyAvailable" json:"keyAvailable,omitempty"`
	// The reason for key not available, valid when keyAvailable is false.
	//
	// `CryptoManagerKmipCryptoKeyStatusKeyUnavailableReason_enum` lists the set of supported values.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
	// The list of VMs which use that key
	//
	// Refers instances of `VirtualMachine`.
	EncryptedVMs []ManagedObjectReference `xml:"encryptedVMs,omitempty" json:"encryptedVMs,omitempty"`
	// The lists of hosts which use that key as host key
	//
	// Refers instances of `HostSystem`.
	AffectedHosts []ManagedObjectReference `xml:"affectedHosts,omitempty" json:"affectedHosts,omitempty"`
	// The identifier list for the 3rd party who are using the key
	ReferencedByTags []string `xml:"referencedByTags,omitempty" json:"referencedByTags,omitempty"`
}

func init() {
	t["CryptoManagerKmipCryptoKeyStatus"] = reflect.TypeOf((*CryptoManagerKmipCryptoKeyStatus)(nil)).Elem()
}

// Crypto key custom attribute spec
type CryptoManagerKmipCustomAttributeSpec struct {
	DynamicData

	// Crypto key custom attributes
	Attributes []KeyValue `xml:"attributes,omitempty" json:"attributes,omitempty"`
}

func init() {
	t["CryptoManagerKmipCustomAttributeSpec"] = reflect.TypeOf((*CryptoManagerKmipCustomAttributeSpec)(nil)).Elem()
	minAPIVersionForType["CryptoManagerKmipCustomAttributeSpec"] = "8.0.1.0"
}

// Information about the KMIP server certificate.
type CryptoManagerKmipServerCertInfo struct {
	DynamicData

	// The server certificate.
	Certificate string `xml:"certificate" json:"certificate"`
	// The basic information about server's certificate.
	CertInfo *CryptoManagerKmipCertificateInfo `xml:"certInfo,omitempty" json:"certInfo,omitempty"`
	// Whether this KMS server is trusted by local Kmip client.
	ClientTrustServer *bool `xml:"clientTrustServer" json:"clientTrustServer,omitempty"`
}

func init() {
	t["CryptoManagerKmipServerCertInfo"] = reflect.TypeOf((*CryptoManagerKmipServerCertInfo)(nil)).Elem()
}

// Status of a KMIP server.
type CryptoManagerKmipServerStatus struct {
	DynamicData

	// Name of the KMIP server.
	Name string `xml:"name" json:"name"`
	// KMIP server status.
	Status ManagedEntityStatus `xml:"status" json:"status"`
	// KMIP server connection status description.
	ConnectionStatus string `xml:"connectionStatus" json:"connectionStatus"`
	// The basic information about the KMIP server's certificate.
	CertInfo *CryptoManagerKmipCertificateInfo `xml:"certInfo,omitempty" json:"certInfo,omitempty"`
	// Whether this KMS server is trusted by local Kmip client.
	ClientTrustServer *bool `xml:"clientTrustServer" json:"clientTrustServer,omitempty"`
	// Whether this KMS server trusts the local Kmip client.
	ServerTrustClient *bool `xml:"serverTrustClient" json:"serverTrustClient,omitempty"`
}

func init() {
	t["CryptoManagerKmipServerStatus"] = reflect.TypeOf((*CryptoManagerKmipServerStatus)(nil)).Elem()
}

// This data object type encapsulates virtual machine or disk encryption
// settings.
type CryptoSpec struct {
	DynamicData
}

func init() {
	t["CryptoSpec"] = reflect.TypeOf((*CryptoSpec)(nil)).Elem()
}

// This data object type encapsulates virtual machine or disk encryption
// settings for decryption operation.
type CryptoSpecDecrypt struct {
	CryptoSpec
}

func init() {
	t["CryptoSpecDecrypt"] = reflect.TypeOf((*CryptoSpecDecrypt)(nil)).Elem()
}

// This data object type encapsulates virtual machine or disk cryptographic
// settings for deep reencryption operation.
type CryptoSpecDeepRecrypt struct {
	CryptoSpec

	NewKeyId CryptoKeyId `xml:"newKeyId" json:"newKeyId"`
}

func init() {
	t["CryptoSpecDeepRecrypt"] = reflect.TypeOf((*CryptoSpecDeepRecrypt)(nil)).Elem()
}

// This data object type encapsulates virtual machine or disk cryptohraphic
// settings for encryption operation.
type CryptoSpecEncrypt struct {
	CryptoSpec

	CryptoKeyId CryptoKeyId `xml:"cryptoKeyId" json:"cryptoKeyId"`
}

func init() {
	t["CryptoSpecEncrypt"] = reflect.TypeOf((*CryptoSpecEncrypt)(nil)).Elem()
}

// This data object type indicates that the encryption settings of the
// virtual machine or disk should not be modified by the operation.
type CryptoSpecNoOp struct {
	CryptoSpec
}

func init() {
	t["CryptoSpecNoOp"] = reflect.TypeOf((*CryptoSpecNoOp)(nil)).Elem()
}

// This data object type indicates that the operation requires keys to be sent
// but the encryption settings of the virtual machine or disk
// should not be modified by the operation.
type CryptoSpecRegister struct {
	CryptoSpecNoOp

	// The key the VM/disk is already encrypted with.
	CryptoKeyId CryptoKeyId `xml:"cryptoKeyId" json:"cryptoKeyId"`
}

func init() {
	t["CryptoSpecRegister"] = reflect.TypeOf((*CryptoSpecRegister)(nil)).Elem()
}

// This data object type encapsulates virtual machine or disk cryptographic
// settings for shallow reencryption operation.
type CryptoSpecShallowRecrypt struct {
	CryptoSpec

	NewKeyId CryptoKeyId `xml:"newKeyId" json:"newKeyId"`
}

func init() {
	t["CryptoSpecShallowRecrypt"] = reflect.TypeOf((*CryptoSpecShallowRecrypt)(nil)).Elem()
}

type CryptoUnlockRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["CryptoUnlockRequestType"] = reflect.TypeOf((*CryptoUnlockRequestType)(nil)).Elem()
}

type CryptoUnlock_Task CryptoUnlockRequestType

func init() {
	t["CryptoUnlock_Task"] = reflect.TypeOf((*CryptoUnlock_Task)(nil)).Elem()
}

type CryptoUnlock_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CurrentTime CurrentTimeRequestType

func init() {
	t["CurrentTime"] = reflect.TypeOf((*CurrentTime)(nil)).Elem()
}

type CurrentTimeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["CurrentTimeRequestType"] = reflect.TypeOf((*CurrentTimeRequestType)(nil)).Elem()
}

type CurrentTimeResponse struct {
	Returnval time.Time `xml:"returnval" json:"returnval"`
}

// Describes a custom field.
type CustomFieldDef struct {
	DynamicData

	// A unique ID used to reference this custom field in assignments.
	//
	// This
	// ID is unique for the lifetime of the field (even across
	// rename operations).
	Key int32 `xml:"key" json:"key"`
	// Name of the field.
	Name string `xml:"name" json:"name"`
	// Type of the field.
	Type string `xml:"type" json:"type"`
	// Type of object for which the field is valid.
	//
	// If not specified,
	// the field is valid for all managed objects.
	ManagedObjectType string `xml:"managedObjectType,omitempty" json:"managedObjectType,omitempty"`
	// The set of privileges to apply on this field definition
	FieldDefPrivileges *PrivilegePolicyDef `xml:"fieldDefPrivileges,omitempty" json:"fieldDefPrivileges,omitempty"`
	// The set of privileges to apply on instances of this field
	FieldInstancePrivileges *PrivilegePolicyDef `xml:"fieldInstancePrivileges,omitempty" json:"fieldInstancePrivileges,omitempty"`
}

func init() {
	t["CustomFieldDef"] = reflect.TypeOf((*CustomFieldDef)(nil)).Elem()
}

// This event records the addition of a custom field definition.
type CustomFieldDefAddedEvent struct {
	CustomFieldDefEvent
}

func init() {
	t["CustomFieldDefAddedEvent"] = reflect.TypeOf((*CustomFieldDefAddedEvent)(nil)).Elem()
}

// This event records a custom field definition event.
type CustomFieldDefEvent struct {
	CustomFieldEvent

	// The unique identifier of the custom field definition.
	FieldKey int32 `xml:"fieldKey" json:"fieldKey"`
	// The name of the custom field.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["CustomFieldDefEvent"] = reflect.TypeOf((*CustomFieldDefEvent)(nil)).Elem()
}

// This event records the removal of a custom field definition.
type CustomFieldDefRemovedEvent struct {
	CustomFieldDefEvent
}

func init() {
	t["CustomFieldDefRemovedEvent"] = reflect.TypeOf((*CustomFieldDefRemovedEvent)(nil)).Elem()
}

// This event records the renaming of a custom field definition.
type CustomFieldDefRenamedEvent struct {
	CustomFieldDefEvent

	NewName string `xml:"newName" json:"newName"`
}

func init() {
	t["CustomFieldDefRenamedEvent"] = reflect.TypeOf((*CustomFieldDefRenamedEvent)(nil)).Elem()
}

// These are custom field events.
type CustomFieldEvent struct {
	Event
}

func init() {
	t["CustomFieldEvent"] = reflect.TypeOf((*CustomFieldEvent)(nil)).Elem()
}

// Subtype for string values (currently the only supported type).
type CustomFieldStringValue struct {
	CustomFieldValue

	// Value assigned to the custom field.
	Value string `xml:"value" json:"value"`
}

func init() {
	t["CustomFieldStringValue"] = reflect.TypeOf((*CustomFieldStringValue)(nil)).Elem()
}

// Base type for storing values.
type CustomFieldValue struct {
	DynamicData

	// The ID of the field to which this value belongs.
	Key int32 `xml:"key" json:"key"`
}

func init() {
	t["CustomFieldValue"] = reflect.TypeOf((*CustomFieldValue)(nil)).Elem()
}

// This event records a change to a custom field value for a particular entity.
type CustomFieldValueChangedEvent struct {
	CustomFieldEvent

	// The entity on which the field value was changed.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
	// The custom field whose value was changed for the entity.
	FieldKey int32 `xml:"fieldKey" json:"fieldKey"`
	// The name of the custom field at the time the value was changed.
	Name string `xml:"name" json:"name"`
	// The new value that was set.
	Value string `xml:"value" json:"value"`
	// The previous service state.
	PrevState string `xml:"prevState,omitempty" json:"prevState,omitempty"`
}

func init() {
	t["CustomFieldValueChangedEvent"] = reflect.TypeOf((*CustomFieldValueChangedEvent)(nil)).Elem()
}

// Data object type to associate a virtual network adapter with its IP settings.
type CustomizationAdapterMapping struct {
	DynamicData

	// The MAC address of a network adapter being customized.
	//
	// The client cannot change
	// this value because the guest operating system has no control over the MAC
	// address of a virtual network adapter.
	//
	// This property is optional. If it is not included, the customization process maps
	// the settings from the list of AdapterMappings.IPSettings in the
	// Specification.nicSettingMap to the virtual machine's network adapters, in PCI
	// slot order. The first virtual network adapter on the PCI bus is assigned
	// nicSettingMap\[0\].IPSettings, the second adapter is assigned
	// nicSettingMap\[1\].IPSettings, and so on.
	//
	// In vSphere 7.0 series, the MAC addresses must be specified in the
	// ascending order of pciSlotNumber, otherwise a MAC address mismatch error
	// will be reported. For further details, see the
	// https://kb.vmware.com/s/article/87648
	MacAddress string `xml:"macAddress,omitempty" json:"macAddress,omitempty"`
	// The IP settings for the associated virtual network adapter.
	Adapter CustomizationIPSettings `xml:"adapter" json:"adapter"`
}

func init() {
	t["CustomizationAdapterMapping"] = reflect.TypeOf((*CustomizationAdapterMapping)(nil)).Elem()
}

// Use automatic address configuration to generate linklocal ipv6 addresses
type CustomizationAutoIpV6Generator struct {
	CustomizationIpV6Generator
}

func init() {
	t["CustomizationAutoIpV6Generator"] = reflect.TypeOf((*CustomizationAutoIpV6Generator)(nil)).Elem()
}

// Guest customization settings to customize a Linux guest operating
// system with raw cloud-init data.
type CustomizationCloudinitPrep struct {
	CustomizationIdentitySettings

	// Metadata includes the network, instance id and hostname that cloud-init
	// processes to configure the VM.
	//
	// It is in json or yaml format.
	// The max size of the metadata is 524288 bytes.
	// See detail information about <a href="https://cloudinit.readthedocs.io/en/latest/topics/instancedata.html#"target="_blank">Instance Metadata</a>.
	Metadata string `xml:"metadata" json:"metadata"`
	// Userdata is the user custom content that cloud-init processes to
	// configure the VM.
	//
	// The max size of the userdata is 524288 bytes.
	// See detail information about <a href="https://cloudinit.readthedocs.io/en/latest/topics/format.html"target="_blank">User-Data formats</a>.
	Userdata string `xml:"userdata,omitempty" json:"userdata,omitempty"`
}

func init() {
	t["CustomizationCloudinitPrep"] = reflect.TypeOf((*CustomizationCloudinitPrep)(nil)).Elem()
	minAPIVersionForType["CustomizationCloudinitPrep"] = "7.0.3.0"
}

// Use a command-line program configured with the VirtualCenter server.
type CustomizationCustomIpGenerator struct {
	CustomizationIpGenerator

	// An optional argument that is passed to the utility for this IP address.
	//
	// The
	// meaning of this field is user-defined, in the script.
	Argument string `xml:"argument,omitempty" json:"argument,omitempty"`
}

func init() {
	t["CustomizationCustomIpGenerator"] = reflect.TypeOf((*CustomizationCustomIpGenerator)(nil)).Elem()
}

// Use a command-line program configured with the VirtualCenter server.
type CustomizationCustomIpV6Generator struct {
	CustomizationIpV6Generator

	// An optional argument that is passed to the utility for this ipv6 address.
	//
	// The
	// meaning of this field is user-defined, in the script.
	Argument string `xml:"argument,omitempty" json:"argument,omitempty"`
}

func init() {
	t["CustomizationCustomIpV6Generator"] = reflect.TypeOf((*CustomizationCustomIpV6Generator)(nil)).Elem()
}

// Specifies that the VirtualCenter server will launch an external application to
// generate the (hostname/IP).
//
// The command line for this application must be specified
// in the server configuration file (vpxd.cfg) in the vpxd/name-ip-generator key.
type CustomizationCustomName struct {
	CustomizationName

	// An optional argument that is passed to the utility for this IP address.
	//
	// The
	// meaning of this field is user-defined in the script.
	Argument string `xml:"argument,omitempty" json:"argument,omitempty"`
}

func init() {
	t["CustomizationCustomName"] = reflect.TypeOf((*CustomizationCustomName)(nil)).Elem()
}

// Use a DHCP server to configure the virtual network adapter.
type CustomizationDhcpIpGenerator struct {
	CustomizationIpGenerator
}

func init() {
	t["CustomizationDhcpIpGenerator"] = reflect.TypeOf((*CustomizationDhcpIpGenerator)(nil)).Elem()
}

// Use a DHCP server to configure ipv6 address
type CustomizationDhcpIpV6Generator struct {
	CustomizationIpV6Generator
}

func init() {
	t["CustomizationDhcpIpV6Generator"] = reflect.TypeOf((*CustomizationDhcpIpV6Generator)(nil)).Elem()
}

// Base for customization events.
type CustomizationEvent struct {
	VmEvent

	// The location of the in-guest customization log which will contain
	// details of the customization operation.
	LogLocation string `xml:"logLocation,omitempty" json:"logLocation,omitempty"`
}

func init() {
	t["CustomizationEvent"] = reflect.TypeOf((*CustomizationEvent)(nil)).Elem()
}

// The customization sequence in the guest failed.
type CustomizationFailed struct {
	CustomizationEvent

	// Reason why the customization failed @see CustomizationFailed.ReasonCode .
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["CustomizationFailed"] = reflect.TypeOf((*CustomizationFailed)(nil)).Elem()
}

// Base for exceptions that can be thrown from the customizer.
type CustomizationFault struct {
	VimFault
}

func init() {
	t["CustomizationFault"] = reflect.TypeOf((*CustomizationFault)(nil)).Elem()
}

type CustomizationFaultFault BaseCustomizationFault

func init() {
	t["CustomizationFaultFault"] = reflect.TypeOf((*CustomizationFaultFault)(nil)).Elem()
}

// Use a static IP Address for the virtual network adapter.
type CustomizationFixedIp struct {
	CustomizationIpGenerator

	IpAddress string `xml:"ipAddress" json:"ipAddress"`
}

func init() {
	t["CustomizationFixedIp"] = reflect.TypeOf((*CustomizationFixedIp)(nil)).Elem()
}

// Use a static ipv6 address for the virtual network adapter
type CustomizationFixedIpV6 struct {
	CustomizationIpV6Generator

	IpAddress  string `xml:"ipAddress" json:"ipAddress"`
	SubnetMask int32  `xml:"subnetMask" json:"subnetMask"`
}

func init() {
	t["CustomizationFixedIpV6"] = reflect.TypeOf((*CustomizationFixedIpV6)(nil)).Elem()
}

// A fixed name.
type CustomizationFixedName struct {
	CustomizationName

	// The virtual machine name specified by the client.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["CustomizationFixedName"] = reflect.TypeOf((*CustomizationFixedName)(nil)).Elem()
}

// A collection of global IP settings for a virtual network adapter.
//
// In Linux, DNS
// server settings are global. The settings can either be statically set or supplied
// by a DHCP server.
type CustomizationGlobalIPSettings struct {
	DynamicData

	// List of name resolution suffixes for the virtual network adapter.
	//
	// This list
	// applies to both Windows and Linux guest customization. For Linux, this setting
	// is global, whereas in Windows, this setting is listed on a per-adapter basis,
	// even though the setting is global in Windows.
	DnsSuffixList []string `xml:"dnsSuffixList,omitempty" json:"dnsSuffixList,omitempty"`
	// List of DNS servers, for a virtual network adapter with a static IP address.
	//
	// If
	// this list is empty, then the guest operating system is expected to use a DHCP
	// server to get its DNS server settings. These settings configure the virtual
	// machine to use the specified DNS servers. These DNS server settings are listed
	// in order of preference.
	DnsServerList []string `xml:"dnsServerList,omitempty" json:"dnsServerList,omitempty"`
}

func init() {
	t["CustomizationGlobalIPSettings"] = reflect.TypeOf((*CustomizationGlobalIPSettings)(nil)).Elem()
}

// The commands listed in the GuiRunOnce data object type are executed when a user
// logs on the first time after customization completes.
//
// The logon may be driven by
// the `AutoLogon` setting.
//
// The GuiRunOnce data object type maps to the GuiRunOnce key in the
// `sysprep.xml` answer file. These values are transferred into the
// `sysprep.xml` file that VirtualCenter stores on the target virtual disk. For
// more detailed information, see <a href="https://technet.microsoft.com/en-us/library/cc771830(v=ws.10).aspx"target="_blank">Performing Unattended Installations</a>.
type CustomizationGuiRunOnce struct {
	DynamicData

	// A list of commands to run at first user logon, after guest customization.
	CommandList []string `xml:"commandList" json:"commandList"`
}

func init() {
	t["CustomizationGuiRunOnce"] = reflect.TypeOf((*CustomizationGuiRunOnce)(nil)).Elem()
}

// The GuiUnattended type maps to the GuiUnattended key in the `sysprep.xml`
// answer file.
//
// These values are plugged directly into the `sysprep.xml` file
// that VirtualCenter stores on the target virtual disk. For more detailed
// information, see <a href="https://technet.microsoft.com/en-us/library/cc771830(v=ws.10).aspx"target="_blank">Performing Unattended Installations</a>.
type CustomizationGuiUnattended struct {
	DynamicData

	// The new administrator password for the machine.
	//
	// To specify that the password
	// should be set to blank (that is, no password), set the password value to NULL.
	// Because of encryption, "" is NOT a valid value.
	//
	// If password is set to blank and `CustomizationGuiUnattended.autoLogon` is set, the
	// guest customization will fail.
	//
	// If the XML file is generated by the VirtualCenter Customization Wizard, then the
	// password is encrypted. Otherwise, the client should set the plainText attribute
	// to true, so that the customization process does not attempt to decrypt the
	// string.
	Password *CustomizationPassword `xml:"password,omitempty" json:"password,omitempty"`
	// The time zone index for the virtual machine.
	//
	// Numbers correspond to time zones
	// listed at <a href="https://support.microsoft.com/en-us/help/973627/microsoft-time-zone-index-values"target="_blank">Microsoft Time Zone Index Values</a>.
	TimeZone int32 `xml:"timeZone" json:"timeZone"`
	// Flag to determine whether or not the machine automatically logs on as
	// Administrator.
	//
	// See also the password property.
	//
	// If the AutoLogon flag is set, `CustomizationGuiUnattended.password` must not be
	// blank or the guest customization will fail.
	AutoLogon bool `xml:"autoLogon" json:"autoLogon"`
	// If the AutoLogon flag is set, then the AutoLogonCount property specifies the
	// number of times the machine should automatically log on as Administrator.
	//
	// Generally it should be 1, but if your setup requires a number of reboots, you
	// may want to increase it. This number may be determined by the list of commands
	// executed by the `GuiRunOnce` command.
	AutoLogonCount int32 `xml:"autoLogonCount" json:"autoLogonCount"`
}

func init() {
	t["CustomizationGuiUnattended"] = reflect.TypeOf((*CustomizationGuiUnattended)(nil)).Elem()
}

// IP settings for a virtual network adapter.
type CustomizationIPSettings struct {
	DynamicData

	// Specification to obtain a unique IP address for this virtual network adapter.
	Ip BaseCustomizationIpGenerator `xml:"ip,typeattr" json:"ip"`
	// Subnet mask for this virtual network adapter.
	SubnetMask string `xml:"subnetMask,omitempty" json:"subnetMask,omitempty"`
	// For a virtual network adapter with a static IP address, this data object type
	// contains a list of gateways, in order of preference.
	Gateway []string `xml:"gateway,omitempty" json:"gateway,omitempty"`
	// This contains the IpGenerator, subnet mask and gateway info for all
	// the ipv6 addresses associated with the virtual network adapter.
	IpV6Spec *CustomizationIPSettingsIpV6AddressSpec `xml:"ipV6Spec,omitempty" json:"ipV6Spec,omitempty"`
	// A list of server IP addresses to use for DNS lookup in a Windows guest operating
	// system.
	//
	// In Windows, these settings are adapter-specific, whereas in Linux, they
	// are global. As a result, the Linux guest customization process ignores this
	// setting and looks for its DNS servers in the globalIPSettings object.
	//
	// Specify these servers in order of preference. If this list is not empty, and if
	// a DHCP IpGenerator is used, then these settings override the DHCP settings.
	DnsServerList []string `xml:"dnsServerList,omitempty" json:"dnsServerList,omitempty"`
	// A DNS domain suffix such as vmware.com.
	DnsDomain string `xml:"dnsDomain,omitempty" json:"dnsDomain,omitempty"`
	// The IP address of the primary WINS server.
	//
	// This property is ignored for Linux
	// guest operating systems.
	PrimaryWINS string `xml:"primaryWINS,omitempty" json:"primaryWINS,omitempty"`
	// The IP address of the secondary WINS server.
	//
	// This property is ignored for Linux
	// guest operating systems.
	SecondaryWINS string `xml:"secondaryWINS,omitempty" json:"secondaryWINS,omitempty"`
	// NetBIOS setting for Windows.
	NetBIOS CustomizationNetBIOSMode `xml:"netBIOS,omitempty" json:"netBIOS,omitempty"`
}

func init() {
	t["CustomizationIPSettings"] = reflect.TypeOf((*CustomizationIPSettings)(nil)).Elem()
}

// IPv6 settings
type CustomizationIPSettingsIpV6AddressSpec struct {
	DynamicData

	// ipv6 address generators
	Ip []BaseCustomizationIpV6Generator `xml:"ip,typeattr" json:"ip"`
	// gateways
	Gateway []string `xml:"gateway,omitempty" json:"gateway,omitempty"`
}

func init() {
	t["CustomizationIPSettingsIpV6AddressSpec"] = reflect.TypeOf((*CustomizationIPSettingsIpV6AddressSpec)(nil)).Elem()
}

// The Identification data object type provides information needed to join a workgroup
// or domain.
//
// The Identification data object type maps to the Identification key in the
// `sysprep.xml` answer file. These values are transferred into the
// `sysprep.xml` file that VirtualCenter stores on the target virtual disk. For
// more detailed information, see <a href="https://technet.microsoft.com/en-us/library/cc771830(v=ws.10).aspx"target="_blank">Performing Unattended Installations</a>.
type CustomizationIdentification struct {
	DynamicData

	// The workgroup that the virtual machine should join.
	//
	// If this value is supplied,
	// then the domain name and authentication fields must be empty.
	JoinWorkgroup string `xml:"joinWorkgroup,omitempty" json:"joinWorkgroup,omitempty"`
	// The domain that the virtual machine should join.
	//
	// If this value is supplied, then
	// domainAdmin and domainAdminPassword must also be supplied, and the workgroup
	// name must be empty.
	JoinDomain string `xml:"joinDomain,omitempty" json:"joinDomain,omitempty"`
	// This is the domain user account used for authentication if the virtual machine
	// is joining a domain.
	//
	// The user does not need to be a domain administrator, but
	// the account must have the privileges required to add computers to the domain.
	DomainAdmin string `xml:"domainAdmin,omitempty" json:"domainAdmin,omitempty"`
	// This is the password for the domain user account used for authentication if the
	// virtual machine is joining a domain.
	DomainAdminPassword *CustomizationPassword `xml:"domainAdminPassword,omitempty" json:"domainAdminPassword,omitempty"`
	// This is the MachineObjectOU which specifies the full LDAP path name of
	// the OU to which the computer belongs.
	//
	// For example, OU=MyOu,DC=MyDom,DC=MyCompany,DC=com
	// Refer to: https://docs.microsoft.com/en-us/windows-hardware/customize/
	// desktop/unattend/microsoft-windows-unattendedjoin-
	// identification-machineobjectou
	DomainOU string `xml:"domainOU,omitempty" json:"domainOU,omitempty" vim:"8.0.2.0"`
}

func init() {
	t["CustomizationIdentification"] = reflect.TypeOf((*CustomizationIdentification)(nil)).Elem()
}

// Base type for sysprep, sysprepText, or linuxPrep object type.
type CustomizationIdentitySettings struct {
	DynamicData
}

func init() {
	t["CustomizationIdentitySettings"] = reflect.TypeOf((*CustomizationIdentitySettings)(nil)).Elem()
}

// Base type for the various IP specification possibilities.
type CustomizationIpGenerator struct {
	DynamicData
}

func init() {
	t["CustomizationIpGenerator"] = reflect.TypeOf((*CustomizationIpGenerator)(nil)).Elem()
}

// Base type for the various IpV6 specification possibilities
type CustomizationIpV6Generator struct {
	DynamicData
}

func init() {
	t["CustomizationIpV6Generator"] = reflect.TypeOf((*CustomizationIpV6Generator)(nil)).Elem()
}

// The LicenseFilePrintData type maps directly to the LicenseFilePrintData key in the
// `sysprep.xml` answer file.
//
// These values are transferred into the
// `sysprep.xml` file that VirtualCenter stores on the target virtual disk. For
// more detailed information, see <a href="https://technet.microsoft.com/en-us/library/cc771830(v=ws.10).aspx"target="_blank">Performing Unattended Installations</a>.
// LicenseFilePrintData provides licensing information for Windows server operating
// systems.
type CustomizationLicenseFilePrintData struct {
	DynamicData

	// Server licensing mode
	AutoMode CustomizationLicenseDataMode `xml:"autoMode" json:"autoMode"`
	// This key is valid only if AutoMode = PerServer.
	//
	// The integer value indicates the
	// number of client licenses purchased for the VirtualCenter server being
	// installed.
	AutoUsers int32 `xml:"autoUsers,omitempty" json:"autoUsers,omitempty"`
}

func init() {
	t["CustomizationLicenseFilePrintData"] = reflect.TypeOf((*CustomizationLicenseFilePrintData)(nil)).Elem()
}

// Failed to set Linux identity.
type CustomizationLinuxIdentityFailed struct {
	CustomizationFailed
}

func init() {
	t["CustomizationLinuxIdentityFailed"] = reflect.TypeOf((*CustomizationLinuxIdentityFailed)(nil)).Elem()
}

// Base object type for optional operations supported by the customization process for
// Linux.
type CustomizationLinuxOptions struct {
	CustomizationOptions
}

func init() {
	t["CustomizationLinuxOptions"] = reflect.TypeOf((*CustomizationLinuxOptions)(nil)).Elem()
}

// This is the Linux counterpart to the Windows Sysprep object.
//
// LinuxPrep contains
// machine-wide settings that identify a Linux machine in the same way that the
// Sysprep type identifies a Windows machine.
type CustomizationLinuxPrep struct {
	CustomizationIdentitySettings

	// The network host name of the (Linux) virtual machine.
	HostName BaseCustomizationName `xml:"hostName,typeattr" json:"hostName"`
	// The fully qualified domain name.
	Domain string `xml:"domain" json:"domain"`
	// The case-sensitive timezone, such as Europe/Sofia.
	//
	// <a href="timezone.html"title="Display list of Valid timeZone values...">
	// **Valid timeZone values**</a> are based on the tz (timezone)
	// database used by Linux and other Unix systems.
	// The values are strings (xsd:string) in the form "Area/Location," in which
	// Area is a continent or ocean name, and Location is the city, island, or
	// other regional designation.
	//
	// See the <a href="https://kb.vmware.com/selfservice/microsites/search.do?language=en_US&cmd=displayKC&externalId=2145518"target="_blank">List of supported time zones for different vSphere versions in Linux/Unix systems</a>.
	TimeZone string `xml:"timeZone,omitempty" json:"timeZone,omitempty"`
	// Specifies whether the hardware clock is in UTC or local time.
	//   - True when the hardware clock is in UTC.
	//   - False when the hardware clock is in local time.
	HwClockUTC *bool `xml:"hwClockUTC" json:"hwClockUTC,omitempty"`
	// The script to run before and after GOS customization.
	ScriptText string `xml:"scriptText,omitempty" json:"scriptText,omitempty"`
	// The compatible customization method is an identifier of a customization
	// strategy which is implementable in a group of Linux operating systems.
	//
	// This value does not need to be set if your operating system is officially
	// supported by VMware guest operating system customization. When using a
	// Linux operating system which hasn't been officially supported and it is
	// designed to be 100% bug-for-bug compatible with an officially supported
	// Linux operating system, it can be customized by an existing customization
	// method.
	//
	// Please set the compatible customization method to a supported string value
	// e.g. "GOSC\_METHOD\_1".
	// See <a href="https://kb.vmware.com/s/article/95903"target="_blank">Supported compatible customization method list</a>.
	CompatibleCustomizationMethod string `xml:"compatibleCustomizationMethod,omitempty" json:"compatibleCustomizationMethod,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["CustomizationLinuxPrep"] = reflect.TypeOf((*CustomizationLinuxPrep)(nil)).Elem()
}

// A base object type for a virtual machine name that can be either fixed or
// auto-generated.
type CustomizationName struct {
	DynamicData
}

func init() {
	t["CustomizationName"] = reflect.TypeOf((*CustomizationName)(nil)).Elem()
}

// Network setup failed in the guest during customization.
type CustomizationNetworkSetupFailed struct {
	CustomizationFailed
}

func init() {
	t["CustomizationNetworkSetupFailed"] = reflect.TypeOf((*CustomizationNetworkSetupFailed)(nil)).Elem()
}

// Base object type for optional operations supported by the customization process.
type CustomizationOptions struct {
	DynamicData
}

func init() {
	t["CustomizationOptions"] = reflect.TypeOf((*CustomizationOptions)(nil)).Elem()
}

// Contains a password string and a flag that specifies whether the string is in plain
// text or encrypted.
type CustomizationPassword struct {
	DynamicData

	// The password string.
	//
	// It is encrypted if the associated plainText flag is false.
	Value string `xml:"value" json:"value"`
	// Flag to specify whether or not the password is in plain text, rather than
	// encrypted.
	PlainText bool `xml:"plainText" json:"plainText"`
}

func init() {
	t["CustomizationPassword"] = reflect.TypeOf((*CustomizationPassword)(nil)).Elem()
}

// A customization operation is already pending on this virtual
// machine and is awaiting power-up to complete.
type CustomizationPending struct {
	CustomizationFault
}

func init() {
	t["CustomizationPending"] = reflect.TypeOf((*CustomizationPending)(nil)).Elem()
}

type CustomizationPendingFault CustomizationPending

func init() {
	t["CustomizationPendingFault"] = reflect.TypeOf((*CustomizationPendingFault)(nil)).Elem()
}

// Specifies that a unique name should be generated by concatenating the base string
// with a number.
//
// Virtual machine names are unique across the set of hosts and virtual machines known
// to the VirtualCenter instance. VirtualCenter tracks the network names of virtual
// machines as well as hosts. VMware Tools runs in a guest operating system and
// reports information to VirtualCenter, including the network name of the guest.
type CustomizationPrefixName struct {
	CustomizationName

	// Base prefix, to which a unique number is appended.
	Base string `xml:"base" json:"base"`
}

func init() {
	t["CustomizationPrefixName"] = reflect.TypeOf((*CustomizationPrefixName)(nil)).Elem()
}

// The Specification data object type contains information required to customize a
// virtual machine when deploying it or migrating it to a new host.
type CustomizationSpec struct {
	DynamicData

	// Optional operations (either LinuxOptions or WinOptions).
	Options BaseCustomizationOptions `xml:"options,omitempty,typeattr" json:"options,omitempty"`
	// Network identity and settings, similar to Microsoft's Sysprep tool.
	//
	// This is a
	// Sysprep, LinuxPrep, CloudinitPrep, or SysprepText object.
	Identity BaseCustomizationIdentitySettings `xml:"identity,typeattr" json:"identity"`
	// Global IP settings constitute the IP settings that are not specific to a
	// particular virtual network adapter.
	GlobalIPSettings CustomizationGlobalIPSettings `xml:"globalIPSettings" json:"globalIPSettings"`
	// IP settings that are specific to a particular virtual network adapter.
	//
	// The
	// AdapterMapping object maps a network adapter's MAC address to its Adapter
	// settings object. May be empty if there are no network adapters, else should
	// match number of network adapters in the VM.
	NicSettingMap []CustomizationAdapterMapping `xml:"nicSettingMap,omitempty" json:"nicSettingMap,omitempty"`
	// Byte array containing the public key used to encrypt any passwords stored in the
	// specification.
	//
	// Both the client and the server can use this to determine if
	// stored passwords can be decrypted by the server or if the passwords need to be
	// re-entered and re-encrypted before the specification can be used.
	EncryptionKey ByteSlice `xml:"encryptionKey,omitempty" json:"encryptionKey,omitempty"`
}

func init() {
	t["CustomizationSpec"] = reflect.TypeOf((*CustomizationSpec)(nil)).Elem()
}

// Information about a specification.
type CustomizationSpecInfo struct {
	DynamicData

	// Unique name of the specification.
	Name string `xml:"name" json:"name"`
	// Description of the specification.
	Description string `xml:"description" json:"description"`
	// Guest operating system for this specification (Linux or Windows).
	Type string `xml:"type" json:"type"`
	// The changeVersion is a unique identifier for a given version
	// of the configuration.
	//
	// Each change to the configuration will
	// update this value. This is typically implemented as an ever
	// increasing count or a time-stamp. However, a client should
	// always treat this as an opaque string.
	//
	// If specified when updating a specification, the changes will only be
	// applied if the current changeVersion matches the specified changeVersion. This
	// field can be used to guard against updates that has happened
	// between the configInfo was read and until it is applied.
	ChangeVersion string `xml:"changeVersion,omitempty" json:"changeVersion,omitempty"`
	// Time when the specification was last modified.
	//
	// This time is ignored when
	// the CustomizationSpecItem containing this is used as an input to
	// CustomizationSpecManager.create.
	LastUpdateTime *time.Time `xml:"lastUpdateTime" json:"lastUpdateTime,omitempty"`
}

func init() {
	t["CustomizationSpecInfo"] = reflect.TypeOf((*CustomizationSpecInfo)(nil)).Elem()
}

// Specification information and the Specification object.
type CustomizationSpecItem struct {
	DynamicData

	// Information about the specification - name, description, and so on.
	Info CustomizationSpecInfo `xml:"info" json:"info"`
	// The customization specification.
	Spec CustomizationSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CustomizationSpecItem"] = reflect.TypeOf((*CustomizationSpecItem)(nil)).Elem()
}

type CustomizationSpecItemToXml CustomizationSpecItemToXmlRequestType

func init() {
	t["CustomizationSpecItemToXml"] = reflect.TypeOf((*CustomizationSpecItemToXml)(nil)).Elem()
}

// The parameters of `CustomizationSpecManager.CustomizationSpecItemToXml`.
type CustomizationSpecItemToXmlRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Item CustomizationSpecItem  `xml:"item" json:"item"`
}

func init() {
	t["CustomizationSpecItemToXmlRequestType"] = reflect.TypeOf((*CustomizationSpecItemToXmlRequestType)(nil)).Elem()
}

type CustomizationSpecItemToXmlResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// The customization sequence has started in the VM guest.
type CustomizationStartedEvent struct {
	CustomizationEvent
}

func init() {
	t["CustomizationStartedEvent"] = reflect.TypeOf((*CustomizationStartedEvent)(nil)).Elem()
}

// Use stateless autoconfiguration to configure to ipv6 address
type CustomizationStatelessIpV6Generator struct {
	CustomizationIpV6Generator
}

func init() {
	t["CustomizationStatelessIpV6Generator"] = reflect.TypeOf((*CustomizationStatelessIpV6Generator)(nil)).Elem()
}

// The customization sequence completed successfully in the guest.
type CustomizationSucceeded struct {
	CustomizationEvent
}

func init() {
	t["CustomizationSucceeded"] = reflect.TypeOf((*CustomizationSucceeded)(nil)).Elem()
}

// An object representation of a Windows `sysprep.xml` answer file.
//
// The sysprep
// type encloses all the individual keys listed in a `sysprep.xml` file. For
// more detailed information, see <a href="https://technet.microsoft.com/en-us/library/cc771830(v=ws.10).aspx"target="_blank">Performing Unattended Installations</a>.
type CustomizationSysprep struct {
	CustomizationIdentitySettings

	// An object representation of the sysprep GuiUnattended key.
	GuiUnattended CustomizationGuiUnattended `xml:"guiUnattended" json:"guiUnattended"`
	// An object representation of the sysprep UserData key.
	UserData CustomizationUserData `xml:"userData" json:"userData"`
	// An object representation of the sysprep GuiRunOnce key.
	GuiRunOnce *CustomizationGuiRunOnce `xml:"guiRunOnce,omitempty" json:"guiRunOnce,omitempty"`
	// An object representation of the sysprep Identification key.
	Identification CustomizationIdentification `xml:"identification" json:"identification"`
	// An object representation of the sysprep LicenseFilePrintData key.
	//
	// Required only
	// for Windows 2000 Server and Windows Server 2003.
	LicenseFilePrintData *CustomizationLicenseFilePrintData `xml:"licenseFilePrintData,omitempty" json:"licenseFilePrintData,omitempty"`
}

func init() {
	t["CustomizationSysprep"] = reflect.TypeOf((*CustomizationSysprep)(nil)).Elem()
}

// Sysprep failed to run in the guest during customization.
//
// This will most like
// have been caused by the fact that the wrong sysprep was used for the guest,
// so we include the version information in the event.
type CustomizationSysprepFailed struct {
	CustomizationFailed

	// The version string for the sysprep files that were included in the
	// customization package.
	SysprepVersion string `xml:"sysprepVersion" json:"sysprepVersion"`
	// The version string for the system
	SystemVersion string `xml:"systemVersion" json:"systemVersion"`
}

func init() {
	t["CustomizationSysprepFailed"] = reflect.TypeOf((*CustomizationSysprepFailed)(nil)).Elem()
}

// An alternate way to specify the `sysprep.xml` answer file.
//
// This string is
// written to the `sysprep.xml` answer file on the target virtual disk.
type CustomizationSysprepText struct {
	CustomizationIdentitySettings

	// Text for the `sysprep.xml` answer file.
	//
	// For additional details, see <a href="https://kb.vmware.com/selfservice/microsites/search.do?language=en_US&cmd=displayKC&externalId=2151684"target="_blank">Using custom sysprep.xml for vCenter Guest Customization</a> and
	// <a href="https://kb.vmware.com/selfservice/microsites/search.do?language=en_US&cmd=displayKC&externalId=1029174"target="_blank">Specifying network settings in custom sysprep.xml</a>.
	Value string `xml:"value" json:"value"`
}

func init() {
	t["CustomizationSysprepText"] = reflect.TypeOf((*CustomizationSysprepText)(nil)).Elem()
}

// The customization sequence failed unexpectedly in the guest.
type CustomizationUnknownFailure struct {
	CustomizationFailed
}

func init() {
	t["CustomizationUnknownFailure"] = reflect.TypeOf((*CustomizationUnknownFailure)(nil)).Elem()
}

// The IP address is left unspecified.
//
// The user must be prompted to supply an IP
// address.
type CustomizationUnknownIpGenerator struct {
	CustomizationIpGenerator
}

func init() {
	t["CustomizationUnknownIpGenerator"] = reflect.TypeOf((*CustomizationUnknownIpGenerator)(nil)).Elem()
}

// The ipv6 address is left unspecified.
//
// The user must be prompted to supply an ipv6
// address.
type CustomizationUnknownIpV6Generator struct {
	CustomizationIpV6Generator
}

func init() {
	t["CustomizationUnknownIpV6Generator"] = reflect.TypeOf((*CustomizationUnknownIpV6Generator)(nil)).Elem()
}

// Indicates that the name is not specified in advance.
//
// The client should prompt the
// user for the value to complete the specification.
type CustomizationUnknownName struct {
	CustomizationName
}

func init() {
	t["CustomizationUnknownName"] = reflect.TypeOf((*CustomizationUnknownName)(nil)).Elem()
}

// Personal data pertaining to the owner of the virtual machine.
//
// The UserData data object type maps to the UserData key in the `sysprep.xml`
// answer file. These values are transferred directly into the `sysprep.xml`
// file that VirtualCenter stores on the target virtual disk. For more detailed
// information, see <a href="https://technet.microsoft.com/en-us/library/cc771830(v=ws.10).aspx"target="_blank">Performing Unattended Installations</a>.
type CustomizationUserData struct {
	DynamicData

	// User's full name.
	FullName string `xml:"fullName" json:"fullName"`
	// User's organization.
	OrgName string `xml:"orgName" json:"orgName"`
	// The computer name of the (Windows) virtual machine.
	//
	// Computer name may contain
	// letters (A-Z), numbers(0-9) and hyphens (-) but no spaces or periods (.).
	// The name may not consists entirely of digits.
	// Computer name is restricted to 15 characters in length. If the computer
	// name is longer than 15 characters, it will be truncated to 15 characters.
	ComputerName BaseCustomizationName `xml:"computerName,typeattr" json:"computerName"`
	// Microsoft Sysprep requires that a valid serial number be included in the answer
	// file when mini-setup runs.
	//
	// This serial number is ignored if the original guest
	// operating system was installed using a volume-licensed CD.
	ProductId string `xml:"productId" json:"productId"`
}

func init() {
	t["CustomizationUserData"] = reflect.TypeOf((*CustomizationUserData)(nil)).Elem()
}

// Specifies that VirtualCenter should generate a virtual machine name from a base
// prefix comprising the virtual machine entity name.
//
// A number is appended, if
// necessary, to make it unique.
//
// Virtual machine names are unique across the set of hosts and virtual machines known
// to the VirtualCenter instance. VMware Tools reports the names of existing virtual
// machines.
type CustomizationVirtualMachineName struct {
	CustomizationName
}

func init() {
	t["CustomizationVirtualMachineName"] = reflect.TypeOf((*CustomizationVirtualMachineName)(nil)).Elem()
}

// Optional operations supported by the customization process for Windows.
type CustomizationWinOptions struct {
	CustomizationOptions

	// The customization process should modify the machine's security identifier (SID).
	//
	// For Vista OS and greater, SID will always be modified and a value of false will
	// generate an error.
	ChangeSID bool `xml:"changeSID" json:"changeSID"`
	// Deprecated as of VI API 2.5, this value is ignored. Removing user accounts
	// during customization is no longer supported. To change the
	// administrator password, set the administrator password to
	// blank in the master vm. Sysprep will then be able to change the
	// password to the one specified by the `CustomizationGuiUnattended.password`.
	//
	// If deleteAccounts is true, then all user accounts are removed from the system as
	// part of the customization.
	//
	// Mini-setup creates a new Administrator account with a
	// blank password.
	DeleteAccounts bool `xml:"deleteAccounts" json:"deleteAccounts"`
	// A value of type SysprepRebootOption specifying the action that should be
	// taken after running sysprep.
	//
	// Defaults to "reboot".
	Reboot CustomizationSysprepRebootOption `xml:"reboot,omitempty" json:"reboot,omitempty"`
}

func init() {
	t["CustomizationWinOptions"] = reflect.TypeOf((*CustomizationWinOptions)(nil)).Elem()
}

// The parameters of `VirtualMachineGuestCustomizationManager.CustomizeGuest_Task`.
type CustomizeGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The Virtual Machine managed object reference.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// Is a `CustomizationSpec`.
	// It specifies the virtual machine's configuration.
	Spec CustomizationSpec `xml:"spec" json:"spec"`
	// addtional key/value pair list to support
	// third party customization.
	ConfigParams []BaseOptionValue `xml:"configParams,omitempty,typeattr" json:"configParams,omitempty"`
}

func init() {
	t["CustomizeGuestRequestType"] = reflect.TypeOf((*CustomizeGuestRequestType)(nil)).Elem()
}

type CustomizeGuest_Task CustomizeGuestRequestType

func init() {
	t["CustomizeGuest_Task"] = reflect.TypeOf((*CustomizeGuest_Task)(nil)).Elem()
}

type CustomizeGuest_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.CustomizeVM_Task`.
type CustomizeVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The customization specification object.
	Spec CustomizationSpec `xml:"spec" json:"spec"`
}

func init() {
	t["CustomizeVMRequestType"] = reflect.TypeOf((*CustomizeVMRequestType)(nil)).Elem()
}

type CustomizeVM_Task CustomizeVMRequestType

func init() {
	t["CustomizeVM_Task"] = reflect.TypeOf((*CustomizeVM_Task)(nil)).Elem()
}

type CustomizeVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Management related configuration of a DistributedVirtualPort.
type DVPortConfigInfo struct {
	DynamicData

	// The name of the port.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// Deprecated as of vSphere API 5.5.
	//
	// The eligible entities that can connect to the port.
	//
	// If unset, there
	// is no restriction on which entity can connect to the port. If set,
	// only the entities in the specified list or their child entities are
	// allowed to connect to the port. If scopes are defined at both port
	// and portgroup level, they are taken as an "AND" relationship. If such
	// a relationship doesn't make sense, the reconfigure operation will
	// raise an exception.
	//
	// Refers instances of `ManagedEntity`.
	Scope []ManagedObjectReference `xml:"scope,omitempty" json:"scope,omitempty"`
	// A description string of the port.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// The network configuration of the port.
	Setting BaseDVPortSetting `xml:"setting,omitempty,typeattr" json:"setting,omitempty"`
	// The version string of the configuration.
	ConfigVersion string `xml:"configVersion" json:"configVersion"`
}

func init() {
	t["DVPortConfigInfo"] = reflect.TypeOf((*DVPortConfigInfo)(nil)).Elem()
}

// Specification to reconfigure a `DistributedVirtualPort`.
type DVPortConfigSpec struct {
	DynamicData

	// The operation to remove or modify the existing ports.
	//
	// The valid values
	// are:
	//   - `edit`
	//   - `remove`
	Operation string `xml:"operation" json:"operation"`
	// Key of the port to be reconfigured.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// The name of the port.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// Deprecated as of vSphere API 5.5.
	//
	// The eligible entities that can connect to the port, for detail see
	// `DVPortConfigInfo.scope`.
	//
	// Refers instances of `ManagedEntity`.
	Scope []ManagedObjectReference `xml:"scope,omitempty" json:"scope,omitempty"`
	// The description string of the port.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// The network setting of the port.
	Setting BaseDVPortSetting `xml:"setting,omitempty,typeattr" json:"setting,omitempty"`
	// The version string of the configuration.
	ConfigVersion string `xml:"configVersion,omitempty" json:"configVersion,omitempty"`
}

func init() {
	t["DVPortConfigSpec"] = reflect.TypeOf((*DVPortConfigSpec)(nil)).Elem()
}

// The virtual machine is configured to use a DVPort, which is not
// supported on the host.
//
// This could be because the host
// does not support VDS at all, or because the host has not
// joined a VDS.
type DVPortNotSupported struct {
	DeviceBackingNotSupported
}

func init() {
	t["DVPortNotSupported"] = reflect.TypeOf((*DVPortNotSupported)(nil)).Elem()
}

type DVPortNotSupportedFault DVPortNotSupported

func init() {
	t["DVPortNotSupportedFault"] = reflect.TypeOf((*DVPortNotSupportedFault)(nil)).Elem()
}

// The `DVPortSetting` data object
// describes the network configuration of a `DistributedVirtualPort`.
type DVPortSetting struct {
	DynamicData

	// Indicates whether this port is blocked.
	//
	// If a port is blocked,
	// packet forwarding is stopped.
	Blocked *BoolPolicy `xml:"blocked,omitempty" json:"blocked,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
	// there is no replacement.
	//
	// Indicates whether this port is allowed to do VMDirectPath Gen2 network passthrough.
	//
	// Direct path capability is defined at host, switch, and device levels.
	// See the <code>vmDirectPathGen2Supported</code> properties on the
	// `DVSFeatureCapability`,
	// `HostCapability`, `PhysicalNic`,
	// and `VirtualEthernetCardOption` objects.
	VmDirectPathGen2Allowed *BoolPolicy `xml:"vmDirectPathGen2Allowed,omitempty" json:"vmDirectPathGen2Allowed,omitempty"`
	// Network shaping policy for controlling throughput of inbound traffic.
	InShapingPolicy *DVSTrafficShapingPolicy `xml:"inShapingPolicy,omitempty" json:"inShapingPolicy,omitempty"`
	// Network shaping policy for controlling throughput of outbound traffic.
	OutShapingPolicy *DVSTrafficShapingPolicy `xml:"outShapingPolicy,omitempty" json:"outShapingPolicy,omitempty"`
	// Opaque binary blob that stores vendor specific configuration.
	VendorSpecificConfig *DVSVendorSpecificConfig `xml:"vendorSpecificConfig,omitempty" json:"vendorSpecificConfig,omitempty"`
	// Deprecated as of vSphere API 6.0
	// Use `DVPortgroupConfigInfo.vmVnicNetworkResourcePoolKey` instead
	// to reference the virtual NIC network resource pool.
	//
	// The key of user defined network resource pool to be associated with a port.
	//
	// The default value for this property is "-1", indicating that
	// this port is not associated with any network resource pool.
	NetworkResourcePoolKey *StringPolicy `xml:"networkResourcePoolKey,omitempty" json:"networkResourcePoolKey,omitempty"`
	// Configuration for Network Filter Policy.
	FilterPolicy *DvsFilterPolicy `xml:"filterPolicy,omitempty" json:"filterPolicy,omitempty"`
}

func init() {
	t["DVPortSetting"] = reflect.TypeOf((*DVPortSetting)(nil)).Elem()
}

// The state of a DistributedVirtualPort.
type DVPortState struct {
	DynamicData

	// Run time information of the port.
	//
	// This property is set only when the port is running.
	RuntimeInfo *DVPortStatus `xml:"runtimeInfo,omitempty" json:"runtimeInfo,omitempty"`
	// Statistics of the port.
	Stats DistributedVirtualSwitchPortStatistics `xml:"stats" json:"stats"`
	// Opaque binary blob that stores vendor-specific runtime state data.
	VendorSpecificState []DistributedVirtualSwitchKeyedOpaqueBlob `xml:"vendorSpecificState,omitempty" json:"vendorSpecificState,omitempty"`
}

func init() {
	t["DVPortState"] = reflect.TypeOf((*DVPortState)(nil)).Elem()
}

// The `DVPortStatus` data object
// contains runtime information about a `DistributedVirtualPort`.
type DVPortStatus struct {
	DynamicData

	// Indicates whether the port is in linkUp status.
	LinkUp bool `xml:"linkUp" json:"linkUp"`
	// Indicates whether the port is blocked by switch implementation.
	Blocked bool `xml:"blocked" json:"blocked"`
	// VLAN ID of the port.
	VlanIds []NumericRange `xml:"vlanIds,omitempty" json:"vlanIds,omitempty"`
	// True if the port VLAN tagging/stripping is disabled.
	TrunkingMode *bool `xml:"trunkingMode" json:"trunkingMode,omitempty"`
	// Maximum transmission unit (MTU) of the port.
	//
	// You can set the MTU only
	// at the switch level
	// (`VMwareDVSConfigSpec`).
	// If you attempt to change it at the portgroup or port level,
	// the Server throws an exception.
	Mtu int32 `xml:"mtu,omitempty" json:"mtu,omitempty"`
	// Name of the connected entity.
	LinkPeer string `xml:"linkPeer,omitempty" json:"linkPeer,omitempty"`
	// The MAC address that is used at this port.
	MacAddress string `xml:"macAddress,omitempty" json:"macAddress,omitempty"`
	// Additional information regarding the current status of the port.
	StatusDetail string `xml:"statusDetail,omitempty" json:"statusDetail,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer
	// supported and there is no replacement.
	//
	// Indicates whether VMDirectPath Gen 2 is active on this port.
	//
	// If false, the reason(s) for inactivity will be provided in one or
	// more of `DVPortStatus.vmDirectPathGen2InactiveReasonNetwork`,
	// `DVPortStatus.vmDirectPathGen2InactiveReasonOther`,
	// and `DVPortStatus.vmDirectPathGen2InactiveReasonExtended`.
	//
	// If the host software is not capable of VMDirectPath Gen 2,
	// this property will be unset. See
	// `HostCapability*.*HostCapability.vmDirectPathGen2Supported`.
	VmDirectPathGen2Active *bool `xml:"vmDirectPathGen2Active" json:"vmDirectPathGen2Active,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer
	// supported and there is no replacement.
	//
	// If `DVPortStatus.vmDirectPathGen2Active` is false, this array will be
	// populated with reasons for the inactivity that are related to network
	// state or configuration.
	//
	// The reasons are chosen from the
	// `DVPortStatusVmDirectPathGen2InactiveReasonNetwork_enum`
	// values.
	//
	// Other reasons for inactivity will be provided in
	// `DVPortStatus.vmDirectPathGen2InactiveReasonOther`. If there is a reason
	// for inactivity that cannot be described by the available constants,
	// `DVPortStatus.vmDirectPathGen2InactiveReasonExtended` will be populated
	// with an additional explanation provided by the platform.
	//
	// Note that this list of reasons is not guaranteed to be exhaustive.
	VmDirectPathGen2InactiveReasonNetwork []string `xml:"vmDirectPathGen2InactiveReasonNetwork,omitempty" json:"vmDirectPathGen2InactiveReasonNetwork,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer
	// supported and there is no replacement.
	//
	// If `DVPortStatus.vmDirectPathGen2Active` is false, this array will be
	// populated with reasons for the inactivity that are not related to
	// network state or configuration.
	//
	// The reasons are chosen from the
	// `DVPortStatusVmDirectPathGen2InactiveReasonOther_enum`
	// values.
	//
	// Network-related reasons for inactivity will be provided in
	// `DVPortStatus.vmDirectPathGen2InactiveReasonNetwork`. If there is a reason
	// for inactivity that cannot be described by the available constants,
	// `DVPortStatus.vmDirectPathGen2InactiveReasonExtended` will be populated
	// with an additional explanation provided by the platform.
	//
	// Note that this list of reasons is not guaranteed to be exhaustive.
	//
	// See also `HostCapability.vmDirectPathGen2Supported`.
	VmDirectPathGen2InactiveReasonOther []string `xml:"vmDirectPathGen2InactiveReasonOther,omitempty" json:"vmDirectPathGen2InactiveReasonOther,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer
	// supported and there is no replacement.
	//
	// If `DVPortStatus.vmDirectPathGen2Active` is false, this property may
	// contain an explanation provided by the platform, beyond the reasons
	// (if any) listed in `DVPortStatus.vmDirectPathGen2InactiveReasonNetwork`
	// and/or `DVPortStatus.vmDirectPathGen2InactiveReasonOther`.
	VmDirectPathGen2InactiveReasonExtended string `xml:"vmDirectPathGen2InactiveReasonExtended,omitempty" json:"vmDirectPathGen2InactiveReasonExtended,omitempty"`
}

func init() {
	t["DVPortStatus"] = reflect.TypeOf((*DVPortStatus)(nil)).Elem()
}

// The `DVPortgroupConfigInfo` data object defines
// the configuration of a `DistributedVirtualPortgroup`.
type DVPortgroupConfigInfo struct {
	DynamicData

	// Key of the portgroup.
	Key string `xml:"key" json:"key"`
	// Name of the portgroup.
	Name string `xml:"name" json:"name"`
	// Number of ports in the portgroup.
	NumPorts int32 `xml:"numPorts" json:"numPorts"`
	// Distributed virtual switch that the portgroup is defined on.
	//
	// This property should always be set unless the user's setting
	// does not have System.Read privilege on the object referred to
	// by this property.
	//
	// Refers instance of `DistributedVirtualSwitch`.
	DistributedVirtualSwitch *ManagedObjectReference `xml:"distributedVirtualSwitch,omitempty" json:"distributedVirtualSwitch,omitempty"`
	// Common network setting for all the ports in the portgroup.
	DefaultPortConfig BaseDVPortSetting `xml:"defaultPortConfig,omitempty,typeattr" json:"defaultPortConfig,omitempty"`
	// Description of the portgroup.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// Type of portgroup.
	//
	// See
	// `DistributedVirtualPortgroup*.*DistributedVirtualPortgroupPortgroupType_enum`
	// for possible values.
	Type string `xml:"type" json:"type"`
	// Backing type of portgroup.
	//
	// See
	// `DistributedVirtualPortgroup*.*DistributedVirtualPortgroupBackingType_enum`
	// for possible values.
	// The default value is "standard"
	BackingType string `xml:"backingType,omitempty" json:"backingType,omitempty"`
	// Portgroup policy.
	Policy BaseDVPortgroupPolicy `xml:"policy,typeattr" json:"policy"`
	// If set, a name will be automatically generated based on this format
	// string for a port when it is created in or moved into the portgroup.
	//
	// The format string can contain meta tags that will be resolved
	// to the corresponding values in generating a name, if applicable for
	// the port at the time of name generation.
	//
	// To insert a meta tag in the format string,
	// enclose the names defined as meta tag names inside angle brackets.
	// See `DistributedVirtualPortgroupMetaTagName_enum` for a list of
	// currently available meta tags. For example,
	// "redNetwork-&lt;portIndex&gt;" and "&lt;dvsName&gt;-pnic&lt;portIndex&gt;"
	// result in generated port names like "redNetwork-2" and "switch-pnic3".
	//
	// If a meta tag is recognized, but there is no applicable value, the tag
	// will be expanded to empty string. If an arbitrary name appears inside
	// a "&lt;&gt;" pair and is not recognized as one of the defined meta tags,
	// the substring is treated as-is and appear unchanged in the generated name.
	//
	// To prevent a meta tag from being expanded, prefix the meta tag with a
	// '\\' (backslash). For example, the format string "abc\\&lt;portIndex&gt;def"
	// results in the generated port name "abc&lt;portIndex&gt;def".
	PortNameFormat string `xml:"portNameFormat,omitempty" json:"portNameFormat,omitempty"`
	// Deprecated as of vSphere API 5.5.
	//
	// Eligible entities that can connect to the portgroup.
	//
	// If unset,
	// there is no restriction on which entity can connect to the portgroup.
	// If set, only the entities in the specified list or their child
	// entities are allowed to connect to the portgroup. If scopes are
	// defined at both port and portgroup level, they are taken as an "AND"
	// relationship. If such a relationship doesn't make sense, the
	// reconfigure operation will raise an exception.
	//
	// Refers instances of `ManagedEntity`.
	Scope []ManagedObjectReference `xml:"scope,omitempty" json:"scope,omitempty"`
	// Opaque binary blob that stores vendor specific configuration.
	VendorSpecificConfig []DistributedVirtualSwitchKeyedOpaqueBlob `xml:"vendorSpecificConfig,omitempty" json:"vendorSpecificConfig,omitempty"`
	// Configuration version number.
	ConfigVersion string `xml:"configVersion,omitempty" json:"configVersion,omitempty"`
	// If set to true, this property ignores the limit on the number of ports in the
	// portgroup.
	//
	// When a Virtual Machine/Host tries to connect to the portgroup and there
	// are no free ports available in the portgroup, new ports will be automatically
	// added to the portgroup. The flag is currently supported only for static portgroups.
	//
	// When this property is set to true, the portgroup becomes a potential candidate for
	// auto-shrink. Once the portgroup has auto-expanded then its disconnected ports are
	// likely to be deleted automatically, as a part of auto-shrink step, if there are more
	// than certain number of free ports. If the portgroup never auto-expanded, then it will
	// never lose any free ports.
	AutoExpand *bool `xml:"autoExpand" json:"autoExpand,omitempty"`
	// The key of virtual NIC network resource pool to be associated with a portgroup.
	//
	// The default value for this property is unset, indicating that
	// this portgroup is not associated with any virtual NIC network resource pool.
	// To clear the value of this property and revert to unset, set the
	// `DVPortgroupConfigSpec.vmVnicNetworkResourcePoolKey`
	// to "-1" in an update operation.
	VmVnicNetworkResourcePoolKey string `xml:"vmVnicNetworkResourcePoolKey,omitempty" json:"vmVnicNetworkResourcePoolKey,omitempty"`
	// Indicates whether the portgroup is an uplink portroup.
	Uplink *bool `xml:"uplink" json:"uplink,omitempty"`
	// The UUID of transport zone to be associated with a NSX portgroup.
	TransportZoneUuid string `xml:"transportZoneUuid,omitempty" json:"transportZoneUuid,omitempty"`
	// The name of transport zone to be associated with a NSX portgroup.
	TransportZoneName string `xml:"transportZoneName,omitempty" json:"transportZoneName,omitempty"`
	// The logical switch UUID, which is used by NSX portgroup
	LogicalSwitchUuid string `xml:"logicalSwitchUuid,omitempty" json:"logicalSwitchUuid,omitempty"`
	// The segment ID of logical switch
	SegmentId string `xml:"segmentId,omitempty" json:"segmentId,omitempty"`
}

func init() {
	t["DVPortgroupConfigInfo"] = reflect.TypeOf((*DVPortgroupConfigInfo)(nil)).Elem()
}

// The `DVPortgroupConfigSpec`
// data object contains configuration data for a
// `DistributedVirtualPortgroup`.
//
// Use the
// `DistributedVirtualPortgroup.ReconfigureDVPortgroup_Task`
// method to apply the configuration to the portgroup.
type DVPortgroupConfigSpec struct {
	DynamicData

	// Version string of the configuration that this spec is trying to
	// change.
	//
	// This property is required in reconfiguring a portgroup and
	// should be set to the same value as the
	// `DVPortgroupConfigInfo.configVersion`.
	// This property is ignored in creating a portgroup if set.
	ConfigVersion string `xml:"configVersion,omitempty" json:"configVersion,omitempty"`
	// Name of the portgroup.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// Number of ports in the portgroup.
	//
	// Setting this number larger than the
	// number of existing ports in the portgroup causes new ports to
	// be added to the portgroup to meet the number. Setting this property
	// smaller than the number of existing ports deletes the free ports
	// from the portgroup. If the number cannot be met by deleting free ports,
	// a fault is raised. If new ports are added to the portgroup, they
	// are also added to the switch. For portgroups of type ephemeral this
	// property is ignored.
	NumPorts int32 `xml:"numPorts,omitempty" json:"numPorts,omitempty"`
	// Format of the name of the ports when ports are created in the portgroup.
	//
	// For details see `DVPortgroupConfigInfo.portNameFormat`.
	PortNameFormat string `xml:"portNameFormat,omitempty" json:"portNameFormat,omitempty"`
	// Default network setting for all the ports in the portgroup.
	DefaultPortConfig BaseDVPortSetting `xml:"defaultPortConfig,omitempty,typeattr" json:"defaultPortConfig,omitempty"`
	// Description of the portgroup.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// Type of portgroup.
	//
	// See
	// `DistributedVirtualPortgroup*.*DistributedVirtualPortgroupPortgroupType_enum`
	// for possible values.
	Type string `xml:"type,omitempty" json:"type,omitempty"`
	// Backing type of portgroup.
	//
	// See
	// `DistributedVirtualPortgroup*.*DistributedVirtualPortgroupBackingType_enum`
	// for possible values.
	// The default value is "standard"
	BackingType string `xml:"backingType,omitempty" json:"backingType,omitempty"`
	// Deprecated as of vSphere API 5.5.
	//
	// Eligible entities that can connect to the port.
	//
	// See
	// `DVPortgroupConfigInfo*.*DVPortgroupConfigInfo.scope`.
	//
	// Refers instances of `ManagedEntity`.
	Scope []ManagedObjectReference `xml:"scope,omitempty" json:"scope,omitempty"`
	// Portgroup policy.
	Policy BaseDVPortgroupPolicy `xml:"policy,omitempty,typeattr" json:"policy,omitempty"`
	// Opaque binary blob that stores vendor specific configuration.
	VendorSpecificConfig []DistributedVirtualSwitchKeyedOpaqueBlob `xml:"vendorSpecificConfig,omitempty" json:"vendorSpecificConfig,omitempty"`
	// If set to true, this property ignores the limit on the number of ports in the
	// portgroup.
	//
	// When a Virtual Machine/Host tries to connect to the portgroup and there
	// are no free ports available in the portgroup, new ports will be automatically
	// added to the portgroup. The flag is currently supported only for static portgroups.
	//
	// Setting this property to true makes the portgroup a potential candidate for
	// auto-shrink. Once the portgroup has auto-expanded then its disconnected ports are
	// likely to be deleted automatically, as a part of auto-shrink step, if there are more
	// than certain number of free ports. If the portgroup never auto-expanded, then it will
	// never lose any free ports.
	AutoExpand *bool `xml:"autoExpand" json:"autoExpand,omitempty"`
	// The key of virtual NIC network resource pool to be associated with a portgroup.
	//
	// Setting this property to "-1", would mean that this portgroup
	// is not associated with any virtual NIC network resource pool.
	VmVnicNetworkResourcePoolKey string `xml:"vmVnicNetworkResourcePoolKey,omitempty" json:"vmVnicNetworkResourcePoolKey,omitempty"`
	// The UUID of transport zone to be associated with a NSX portgroup.
	TransportZoneUuid string `xml:"transportZoneUuid,omitempty" json:"transportZoneUuid,omitempty"`
	// The name of transport zone to be associated with a NSX portgroup.
	TransportZoneName string `xml:"transportZoneName,omitempty" json:"transportZoneName,omitempty"`
	// The logical switch UUID, which is used by NSX portgroup
	LogicalSwitchUuid string `xml:"logicalSwitchUuid,omitempty" json:"logicalSwitchUuid,omitempty"`
	// The segment ID of logical switch
	SegmentId string `xml:"segmentId,omitempty" json:"segmentId,omitempty"`
}

func init() {
	t["DVPortgroupConfigSpec"] = reflect.TypeOf((*DVPortgroupConfigSpec)(nil)).Elem()
}

// Two distributed virtual portgroup was created.
type DVPortgroupCreatedEvent struct {
	DVPortgroupEvent
}

func init() {
	t["DVPortgroupCreatedEvent"] = reflect.TypeOf((*DVPortgroupCreatedEvent)(nil)).Elem()
}

// Two distributed virtual portgroup was destroyed.
type DVPortgroupDestroyedEvent struct {
	DVPortgroupEvent
}

func init() {
	t["DVPortgroupDestroyedEvent"] = reflect.TypeOf((*DVPortgroupDestroyedEvent)(nil)).Elem()
}

// DVPortgroup related events.
type DVPortgroupEvent struct {
	Event
}

func init() {
	t["DVPortgroupEvent"] = reflect.TypeOf((*DVPortgroupEvent)(nil)).Elem()
}

// The DistributedVirtualPortgroup policies.
//
// This field is not applicable
// when queried directly against an ESX host.
type DVPortgroupPolicy struct {
	DynamicData

	// Allow the `DVPortSetting.blocked` setting
	// of an individual port to override the setting in
	// `DVPortgroupConfigInfo.defaultPortConfig` of
	// a portgroup.
	BlockOverrideAllowed bool `xml:"blockOverrideAllowed" json:"blockOverrideAllowed"`
	// Allow the `DVPortSetting.inShapingPolicy` or
	// `DVPortSetting.outShapingPolicy` settings
	// of an individual port to override the setting in
	// `DVPortgroupConfigInfo.defaultPortConfig` of
	// a portgroup.
	ShapingOverrideAllowed bool `xml:"shapingOverrideAllowed" json:"shapingOverrideAllowed"`
	// Allow the `DVPortSetting.vendorSpecificConfig`
	// setting of an individual port to override the setting in
	// `DVPortgroupConfigInfo.defaultPortConfig` of
	// a portgroup.
	VendorConfigOverrideAllowed bool `xml:"vendorConfigOverrideAllowed" json:"vendorConfigOverrideAllowed"`
	// Allow a live port to be moved in and out of the portgroup.
	LivePortMovingAllowed bool `xml:"livePortMovingAllowed" json:"livePortMovingAllowed"`
	// If true, reset the port network setting back to the portgroup setting
	// (thus removing the per-port setting) when the port is disconnected from
	// the connectee.
	PortConfigResetAtDisconnect bool `xml:"portConfigResetAtDisconnect" json:"portConfigResetAtDisconnect"`
	// Allow the setting of
	// `DVPortSetting.networkResourcePoolKey` of an
	// individual port to override the setting in
	// `DVPortgroupConfigInfo.defaultPortConfig`
	// of a portgroup.
	NetworkResourcePoolOverrideAllowed *bool `xml:"networkResourcePoolOverrideAllowed" json:"networkResourcePoolOverrideAllowed,omitempty"`
	// Allow the setting of
	// `DVPortSetting.filterPolicy`,
	// for an individual port to override the setting in
	// `DVPortgroupConfigInfo.defaultPortConfig` of
	// a portgroup.
	TrafficFilterOverrideAllowed *bool `xml:"trafficFilterOverrideAllowed" json:"trafficFilterOverrideAllowed,omitempty"`
}

func init() {
	t["DVPortgroupPolicy"] = reflect.TypeOf((*DVPortgroupPolicy)(nil)).Elem()
}

// Two distributed virtual portgroup was reconfigured.
type DVPortgroupReconfiguredEvent struct {
	DVPortgroupEvent

	// The reconfiguration spec.
	ConfigSpec DVPortgroupConfigSpec `xml:"configSpec" json:"configSpec"`
	// The configuration values changed during the reconfiguration.
	ConfigChanges *ChangesInfoEventArgument `xml:"configChanges,omitempty" json:"configChanges,omitempty"`
}

func init() {
	t["DVPortgroupReconfiguredEvent"] = reflect.TypeOf((*DVPortgroupReconfiguredEvent)(nil)).Elem()
}

// Two distributed virtual portgroup was renamed.
type DVPortgroupRenamedEvent struct {
	DVPortgroupEvent

	// The old portgroup name.
	OldName string `xml:"oldName" json:"oldName"`
	// The new portgroup name.
	NewName string `xml:"newName" json:"newName"`
}

func init() {
	t["DVPortgroupRenamedEvent"] = reflect.TypeOf((*DVPortgroupRenamedEvent)(nil)).Elem()
}

// The parameters of `DistributedVirtualPortgroup.DVPortgroupRollback_Task`.
type DVPortgroupRollbackRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The backup of Distributed Virtual PortGroup entity.
	EntityBackup *EntityBackupConfig `xml:"entityBackup,omitempty" json:"entityBackup,omitempty"`
}

func init() {
	t["DVPortgroupRollbackRequestType"] = reflect.TypeOf((*DVPortgroupRollbackRequestType)(nil)).Elem()
}

type DVPortgroupRollback_Task DVPortgroupRollbackRequestType

func init() {
	t["DVPortgroupRollback_Task"] = reflect.TypeOf((*DVPortgroupRollback_Task)(nil)).Elem()
}

type DVPortgroupRollback_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Class to specify selection criteria of list of vNetwork Distributed Portgroups.
type DVPortgroupSelection struct {
	SelectionSet

	// vSphere Distributed Switch uuid
	DvsUuid string `xml:"dvsUuid" json:"dvsUuid"`
	// List of vNetwork Distributed Portgroup keys
	PortgroupKey []string `xml:"portgroupKey" json:"portgroupKey"`
}

func init() {
	t["DVPortgroupSelection"] = reflect.TypeOf((*DVPortgroupSelection)(nil)).Elem()
}

// The `DVSBackupRestoreCapability` data object
// describes backup, restore, and rollback capabilities for distributed virtual
// switches and distributed virtual portgroups.
//
// Backup and restore capabilities are indicated for `DistributedVirtualSwitch`.
// Rollback capability is indicated for `DistributedVirtualSwitch`
// and `DistributedVirtualPortgroup`.
type DVSBackupRestoreCapability struct {
	DynamicData

	// Indicates whether backup, restore, and rollback are supported.
	BackupRestoreSupported bool `xml:"backupRestoreSupported" json:"backupRestoreSupported"`
}

func init() {
	t["DVSBackupRestoreCapability"] = reflect.TypeOf((*DVSBackupRestoreCapability)(nil)).Elem()
}

// The `DVSCapability` data object
// describes the distributed virtual switch features and indicates
// the level of configuration that is allowed.
type DVSCapability struct {
	DynamicData

	// Indicates whether this switch allows vCenter users to modify
	// the switch configuration at the switch level,
	// except for host member, policy, and scope operations.
	DvsOperationSupported *bool `xml:"dvsOperationSupported" json:"dvsOperationSupported,omitempty"`
	// Indicates whether this switch allows vCenter users to modify
	// the switch configuration at the portgroup level,
	// except for host member, policy, and scope operations.
	DvPortGroupOperationSupported *bool `xml:"dvPortGroupOperationSupported" json:"dvPortGroupOperationSupported,omitempty"`
	// Indicates whether this switch allows vCenter users to modify
	// the switch configuration at the port level,
	// except for host member, policy, and scope operations.
	DvPortOperationSupported *bool `xml:"dvPortOperationSupported" json:"dvPortOperationSupported,omitempty"`
	// List of host component product information that is compatible
	// with the current switch implementation.
	CompatibleHostComponentProductInfo []DistributedVirtualSwitchHostProductSpec `xml:"compatibleHostComponentProductInfo,omitempty" json:"compatibleHostComponentProductInfo,omitempty"`
	// Indicators for which version-specific distributed virtual switch
	// features are available on this switch.
	//
	// This information is read-only, with the following exception.
	// For a third-party distributed switch implementation, you can
	// set the property
	// `DVSFeatureCapability*.*DVSFeatureCapability.vmDirectPathGen2Supported`
	// during switch creation or when you call the
	// `DistributedVirtualSwitch.UpdateDvsCapability` method.
	FeaturesSupported BaseDVSFeatureCapability `xml:"featuresSupported,omitempty,typeattr" json:"featuresSupported,omitempty"`
}

func init() {
	t["DVSCapability"] = reflect.TypeOf((*DVSCapability)(nil)).Elem()
}

// Configuration of a `DistributedVirtualSwitch`.
type DVSConfigInfo struct {
	DynamicData

	// Generated UUID of the switch.
	//
	// Unique across vCenter Server
	// inventory and instances.
	Uuid string `xml:"uuid" json:"uuid"`
	// Name of the switch.
	Name string `xml:"name" json:"name"`
	// Number of standalone ports in the switch.
	//
	// Standalone ports are
	// ports that do not belong to any portgroup.
	NumStandalonePorts int32 `xml:"numStandalonePorts" json:"numStandalonePorts"`
	// Current number of ports, not including conflict ports.
	NumPorts int32 `xml:"numPorts" json:"numPorts"`
	// Maximum number of ports allowed in the switch,
	// not including conflict ports.
	MaxPorts int32 `xml:"maxPorts" json:"maxPorts"`
	// Uplink port policy.
	UplinkPortPolicy BaseDVSUplinkPortPolicy `xml:"uplinkPortPolicy,typeattr" json:"uplinkPortPolicy"`
	// List of uplink portgroups.
	//
	// When adding host members, the server
	// uses the `DVSConfigInfo.uplinkPortPolicy` to create a number of
	// uplink ports for the host. If portgroups are shown here,
	// those uplink ports will be added to the portgroups, with uplink ports
	// evenly spread among the portgroups.
	//
	// Refers instances of `DistributedVirtualPortgroup`.
	UplinkPortgroup []ManagedObjectReference `xml:"uplinkPortgroup,omitempty" json:"uplinkPortgroup,omitempty"`
	// Default configuration for the ports in the switch, if the port
	// does not inherit configuration from the parent portgroup or has
	// its own configuration.
	DefaultPortConfig BaseDVPortSetting `xml:"defaultPortConfig,typeattr" json:"defaultPortConfig"`
	// Hosts that join the switch.
	Host []DistributedVirtualSwitchHostMember `xml:"host,omitempty" json:"host,omitempty"`
	// Vendor, product, and version information for the implementation
	// module of the switch.
	ProductInfo DistributedVirtualSwitchProductSpec `xml:"productInfo" json:"productInfo"`
	// Intended vendor, product, and version information for the
	// implementation module of the switch.
	TargetInfo *DistributedVirtualSwitchProductSpec `xml:"targetInfo,omitempty" json:"targetInfo,omitempty"`
	// Key of the extension registered by the remote server that
	// controls the switch.
	ExtensionKey string `xml:"extensionKey,omitempty" json:"extensionKey,omitempty"`
	// Opaque binary blob that stores vendor specific configuration.
	VendorSpecificConfig []DistributedVirtualSwitchKeyedOpaqueBlob `xml:"vendorSpecificConfig,omitempty" json:"vendorSpecificConfig,omitempty"`
	// Usage policy of the switch.
	Policy *DVSPolicy `xml:"policy,omitempty" json:"policy,omitempty"`
	// Description string for the switch.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// Version string of the configuration.
	ConfigVersion string `xml:"configVersion" json:"configVersion"`
	// Human operator contact information.
	Contact DVSContactInfo `xml:"contact" json:"contact"`
	// IP address for the switch, specified using IPv4 dot notation.
	//
	// The
	// utility of this address is defined by other switch features.
	SwitchIpAddress string `xml:"switchIpAddress,omitempty" json:"switchIpAddress,omitempty"`
	// Create time of the switch.
	CreateTime time.Time `xml:"createTime" json:"createTime"`
	// Boolean to indicate if network I/O control is enabled on the
	// switch.
	NetworkResourceManagementEnabled *bool `xml:"networkResourceManagementEnabled" json:"networkResourceManagementEnabled,omitempty"`
	// Default host proxy switch maximum port number
	DefaultProxySwitchMaxNumPorts int32 `xml:"defaultProxySwitchMaxNumPorts,omitempty" json:"defaultProxySwitchMaxNumPorts,omitempty"`
	// VDS health check configuration.
	HealthCheckConfig []BaseDVSHealthCheckConfig `xml:"healthCheckConfig,omitempty,typeattr" json:"healthCheckConfig,omitempty"`
	// Host infrastructure traffic class resource configuration.
	InfrastructureTrafficResourceConfig []DvsHostInfrastructureTrafficResource `xml:"infrastructureTrafficResourceConfig,omitempty" json:"infrastructureTrafficResourceConfig,omitempty"`
	// Dynamic Host infrastructure traffic class resource configuration.
	NetResourcePoolTrafficResourceConfig []DvsHostInfrastructureTrafficResource `xml:"netResourcePoolTrafficResourceConfig,omitempty" json:"netResourcePoolTrafficResourceConfig,omitempty"`
	// Network resource control version of the switch.
	//
	// Possible value can be of
	// `DistributedVirtualSwitchNetworkResourceControlVersion_enum`.
	NetworkResourceControlVersion string `xml:"networkResourceControlVersion,omitempty" json:"networkResourceControlVersion,omitempty"`
	// The Virtual NIC network resource pool information for the switch.
	VmVnicNetworkResourcePool []DVSVmVnicNetworkResourcePool `xml:"vmVnicNetworkResourcePool,omitempty" json:"vmVnicNetworkResourcePool,omitempty"`
	// The percentage of physical nic link speed
	// `PhysicalNicLinkInfo.speedMb`
	// available for infrastructure traffic reservation.
	//
	// If this value is 75, then for a 1Gbps physical nic, only
	// 750Mbps is allowed for all infrastructure traffic reservations.
	PnicCapacityRatioForReservation int32 `xml:"pnicCapacityRatioForReservation,omitempty" json:"pnicCapacityRatioForReservation,omitempty"`
}

func init() {
	t["DVSConfigInfo"] = reflect.TypeOf((*DVSConfigInfo)(nil)).Elem()
}

// The `DVSConfigSpec`
// data object contains configuration data for a
// `DistributedVirtualSwitch`.
//
// Use the `DistributedVirtualSwitch.ReconfigureDvs_Task`
// method to apply the configuration to the
// switch.
type DVSConfigSpec struct {
	DynamicData

	// The version string of the configuration that this spec is trying to
	// change.
	//
	// This property is required in reconfiguring a switch
	// and should be set to the same value as
	// `DVSConfigInfo.configVersion`.
	// This property is ignored during switch creation.
	ConfigVersion string `xml:"configVersion,omitempty" json:"configVersion,omitempty"`
	// The name of the switch.
	//
	// Must be unique in the parent folder.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// The number of standalone ports in the switch.
	//
	// Standalone ports are
	// ports that do not belong to any portgroup. If set to a number larger
	// than number of existing standalone ports in the switch, new ports get
	// created to meet the number. If set to a number smaller than the number
	// of existing standalone ports, free ports (uplink ports excluded) are
	// deleted to meet the number. If the set number cannot be met by
	// deleting free standalone ports, a fault is raised.
	NumStandalonePorts int32 `xml:"numStandalonePorts,omitempty" json:"numStandalonePorts,omitempty"`
	// Deprecated as of vSphere API 5.0
	// The default value of this propoerty is maxint and there is no reason
	// for users to change it to a lower value.
	//
	// The maximum number of DistributedVirtualPorts allowed in the switch.
	//
	// If specified in a reconfigure operation, this number cannot be smaller
	// than the number of existing DistributedVirtualPorts.
	MaxPorts int32 `xml:"maxPorts,omitempty" json:"maxPorts,omitempty"`
	// The uplink port policy.
	UplinkPortPolicy BaseDVSUplinkPortPolicy `xml:"uplinkPortPolicy,omitempty,typeattr" json:"uplinkPortPolicy,omitempty"`
	// The uplink portgroups.
	//
	// Refers instances of `DistributedVirtualPortgroup`.
	UplinkPortgroup []ManagedObjectReference `xml:"uplinkPortgroup,omitempty" json:"uplinkPortgroup,omitempty"`
	// The default configuration for ports.
	DefaultPortConfig BaseDVPortSetting `xml:"defaultPortConfig,omitempty,typeattr" json:"defaultPortConfig,omitempty"`
	// The host member specification.
	//
	// A particular host should have only one entry
	// in this array. Duplicate entries for the same host will raise a fault.
	// The host version should be compatible with the version of
	// `DistributedVirtualSwitch`. Use
	// `DistributedVirtualSwitchManager.QueryDvsCheckCompatibility`
	// to check for compatibility.
	Host []DistributedVirtualSwitchHostMemberConfigSpec `xml:"host,omitempty" json:"host,omitempty"`
	// The key of the extension registered by a remote server that
	// controls the switch.
	ExtensionKey string `xml:"extensionKey,omitempty" json:"extensionKey,omitempty"`
	// Set the description string of the switch.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// The usage policy of the switch.
	Policy *DVSPolicy `xml:"policy,omitempty" json:"policy,omitempty"`
	// Set the opaque blob that stores vendor specific configuration.
	VendorSpecificConfig []DistributedVirtualSwitchKeyedOpaqueBlob `xml:"vendorSpecificConfig,omitempty" json:"vendorSpecificConfig,omitempty"`
	// Set the human operator contact information.
	Contact *DVSContactInfo `xml:"contact,omitempty" json:"contact,omitempty"`
	// IP address for the switch, specified using IPv4 dot notation.
	//
	// IPv6 address is not supported for this property.
	// The utility of this address is defined by other switch features.
	// switchIpAddress would be ignored when IPFIX collector uses IPv6.
	SwitchIpAddress string `xml:"switchIpAddress,omitempty" json:"switchIpAddress,omitempty"`
	// The default host proxy switch maximum port number
	DefaultProxySwitchMaxNumPorts int32 `xml:"defaultProxySwitchMaxNumPorts,omitempty" json:"defaultProxySwitchMaxNumPorts,omitempty"`
	// The host infrastructure traffic resource allocation specification.
	//
	// Only the traffic class resource allocations identified in the list
	// will be updated. The other traffic class resource allocations that are not
	// specified will not change.
	InfrastructureTrafficResourceConfig []DvsHostInfrastructureTrafficResource `xml:"infrastructureTrafficResourceConfig,omitempty" json:"infrastructureTrafficResourceConfig,omitempty"`
	// The dynamic host infrastructure traffic resource allocation
	// specification.
	NetResourcePoolTrafficResourceConfig []DvsHostInfrastructureTrafficResource `xml:"netResourcePoolTrafficResourceConfig,omitempty" json:"netResourcePoolTrafficResourceConfig,omitempty"`
	// Indicates the Network Resource Control APIs that are supported on the switch.
	//
	// Possible value can be of
	// `DistributedVirtualSwitchNetworkResourceControlVersion_enum`.
	NetworkResourceControlVersion string `xml:"networkResourceControlVersion,omitempty" json:"networkResourceControlVersion,omitempty"`
}

func init() {
	t["DVSConfigSpec"] = reflect.TypeOf((*DVSConfigSpec)(nil)).Elem()
}

// Contact information of a human operator.
type DVSContactInfo struct {
	DynamicData

	// The name of the person who is responsible for the switch.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// The contact information for the person.
	Contact string `xml:"contact,omitempty" json:"contact,omitempty"`
}

func init() {
	t["DVSContactInfo"] = reflect.TypeOf((*DVSContactInfo)(nil)).Elem()
}

// Specification to create a `DistributedVirtualSwitch`.
type DVSCreateSpec struct {
	DynamicData

	// Configuration data.
	ConfigSpec BaseDVSConfigSpec `xml:"configSpec,typeattr" json:"configSpec"`
	// Product information for this switch implementation.
	//
	// If you
	// do not specify this property, the Server will use the latest
	// version to create the `DistributedVirtualSwitch`.
	ProductInfo *DistributedVirtualSwitchProductSpec `xml:"productInfo,omitempty" json:"productInfo,omitempty"`
	// Capability of the switch.
	Capability *DVSCapability `xml:"capability,omitempty" json:"capability,omitempty"`
}

func init() {
	t["DVSCreateSpec"] = reflect.TypeOf((*DVSCreateSpec)(nil)).Elem()
}

// This data object type describes the network adapter failover
// detection algorithm for a network adapter team.
type DVSFailureCriteria struct {
	InheritablePolicy

	// To use link speed as the criteria, _checkSpeed_ must be one of
	// the following values:
	//   - `*exact*`: Use exact speed to detect link failure.
	//     `*speed*` is the configured exact speed in megabits per second.
	//   - `*minimum*`: Use minimum speed to detect failure.
	//     `*speed*` is the configured minimum speed in megabits per second.
	//   - **empty string**: Do not use link speed to detect failure.
	//     `*speed*` is unused in this case.
	CheckSpeed *StringPolicy `xml:"checkSpeed,omitempty" json:"checkSpeed,omitempty"`
	// See also `DVSFailureCriteria.checkSpeed`.
	Speed *IntPolicy `xml:"speed,omitempty" json:"speed,omitempty"`
	// The flag to indicate whether or not to use the link duplex reported
	// by the driver as link selection criteria.
	//
	// If `*checkDuplex*` is true, then fullDuplex is the configured
	// duplex mode. The link is considered bad if the link duplex reported
	// by driver is not the same as fullDuplex.
	//
	// If `*checkDuplex*` is false, then fullDuplex is unused, and
	// link duplexity is not used as a detection method.
	CheckDuplex *BoolPolicy `xml:"checkDuplex,omitempty" json:"checkDuplex,omitempty"`
	// See also `DVSFailureCriteria.checkDuplex`.
	FullDuplex *BoolPolicy `xml:"fullDuplex,omitempty" json:"fullDuplex,omitempty"`
	// The flag to indicate whether or not to use link error percentage
	// to detect failure.
	//
	// If `*checkErrorPercent*` is true, then percentage is the configured
	// error percentage that is tolerated. The link is considered bad
	// if error rate exceeds percentage.
	//
	// If `*checkErrorPercent*` is false, percentage is unused, and
	// error percentage is not used as a detection method.
	CheckErrorPercent *BoolPolicy `xml:"checkErrorPercent,omitempty" json:"checkErrorPercent,omitempty"`
	// See also `DVSFailureCriteria.checkErrorPercent`.
	Percentage *IntPolicy `xml:"percentage,omitempty" json:"percentage,omitempty"`
	// The flag to indicate whether or not to enable this property to
	// enable beacon probing as a method to validate
	// the link status of a physical network adapter.
	//
	// `*checkBeacon*` can be enabled only if the VirtualSwitch has been
	// configured to use the beacon. Attempting to set `*checkBeacon*`
	// on a PortGroup or VirtualSwitch that does not have beacon probing
	// configured for the applicable VirtualSwitch results in an error.
	CheckBeacon *BoolPolicy `xml:"checkBeacon,omitempty" json:"checkBeacon,omitempty"`
}

func init() {
	t["DVSFailureCriteria"] = reflect.TypeOf((*DVSFailureCriteria)(nil)).Elem()
}

// The `DVSFeatureCapability` data object
// represents the capabilities supported by a
// `DistributedVirtualSwitch`.
//
// These properties are read-only with
// the exception of
// `DVSFeatureCapability.vmDirectPathGen2Supported`.
type DVSFeatureCapability struct {
	DynamicData

	// Deprecated as of vSphere API 5.0, use
	// <code>networkResourceManagementCapability</code>.`DVSNetworkResourceManagementCapability.networkResourceManagementSupported`.
	//
	// Indicates whether network I/O control is
	// supported on the vSphere Distributed Switch.
	NetworkResourceManagementSupported bool `xml:"networkResourceManagementSupported" json:"networkResourceManagementSupported"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
	// there is no replacement.
	//
	// Indicates whether VMDirectPath Gen 2 is supported on the
	// distributed virtual switch.
	//
	// See
	// `HostCapability*.*HostCapability.vmDirectPathGen2Supported`
	// and `PhysicalNic*.*PhysicalNic.vmDirectPathGen2Supported`.
	//
	// For a third-party distributed switch implementation, you can
	// specify this property during switch creation or when you call the
	// `DistributedVirtualSwitch.UpdateDvsCapability` method.
	//
	// VMDirectPath Gen 2 is supported in
	// vSphere Distributed Switch Version 4.1 or later.
	VmDirectPathGen2Supported *bool `xml:"vmDirectPathGen2Supported" json:"vmDirectPathGen2Supported,omitempty"`
	// The available teaming modes for the vSphere Distributed Switch.
	//
	// The
	// value can be one or more of
	// `DistributedVirtualSwitchNicTeamingPolicyMode_enum`.
	NicTeamingPolicy []string `xml:"nicTeamingPolicy,omitempty" json:"nicTeamingPolicy,omitempty"`
	// Deprecated as of vSphere API 5.0, use
	// <code>networkResourceManagementCapability</code>.`DVSNetworkResourceManagementCapability.networkResourcePoolHighShareValue`.
	//
	// This is the value for `high`
	// in `DVSNetworkResourcePoolAllocationInfo.shares`.
	//
	// This
	// implicitly defines the legal range of share values to be between 1 and this.
	// This also defines values for other level types, such as
	// `normal` being one half of this value and
	// `low` being one fourth of this value.
	NetworkResourcePoolHighShareValue int32 `xml:"networkResourcePoolHighShareValue,omitempty" json:"networkResourcePoolHighShareValue,omitempty"`
	// Network resource management capabilities supported by a
	// distributed virtual switch.
	NetworkResourceManagementCapability *DVSNetworkResourceManagementCapability `xml:"networkResourceManagementCapability,omitempty" json:"networkResourceManagementCapability,omitempty"`
	// Health check capabilities supported by a `VmwareDistributedVirtualSwitch`.
	HealthCheckCapability BaseDVSHealthCheckCapability `xml:"healthCheckCapability,omitempty,typeattr" json:"healthCheckCapability,omitempty"`
	// Host rollback capability.
	//
	// If <code>rollbackCapability</code>.`DVSRollbackCapability.rollbackSupported`
	// is true, network operations that disconnect the the host are rolled back.
	RollbackCapability *DVSRollbackCapability `xml:"rollbackCapability,omitempty" json:"rollbackCapability,omitempty"`
	// Backup, restore, and rollback capabilities.
	//
	// Backup and restore
	// are supported only for `VmwareDistributedVirtualSwitch`.
	// Rollback is supported for `VmwareDistributedVirtualSwitch`
	// and `DistributedVirtualPortgroup`.
	// For information about backup and restore, see the
	// `DistributedVirtualSwitchManager` methods
	// `DistributedVirtualSwitchManager.DVSManagerExportEntity_Task` and
	// `DistributedVirtualSwitchManager.DVSManagerImportEntity_Task`.
	// For information about rollback, see the
	// `DistributedVirtualSwitch*.*DistributedVirtualSwitch.DVSRollback_Task`
	// and `DistributedVirtualPortgroup*.*DistributedVirtualPortgroup.DVPortgroupRollback_Task`
	// methods.
	BackupRestoreCapability *DVSBackupRestoreCapability `xml:"backupRestoreCapability,omitempty" json:"backupRestoreCapability,omitempty"`
	// Indicates whether Network Filter feature is
	// supported in vSphere Distributed Switch.
	NetworkFilterSupported *bool `xml:"networkFilterSupported" json:"networkFilterSupported,omitempty"`
	// Indicates whether MAC learning feature is
	// supported in vSphere Distributed Switch.
	MacLearningSupported *bool `xml:"macLearningSupported" json:"macLearningSupported,omitempty"`
}

func init() {
	t["DVSFeatureCapability"] = reflect.TypeOf((*DVSFeatureCapability)(nil)).Elem()
}

// Base class for connectee filters.
//
// This class serves as a base for different types of connectee filters.
// It has three sub-classes.
type DVSFilterSpecConnecteeSpec struct {
	DynamicData
}

func init() {
	t["DVSFilterSpecConnecteeSpec"] = reflect.TypeOf((*DVSFilterSpecConnecteeSpec)(nil)).Elem()
	minAPIVersionForType["DVSFilterSpecConnecteeSpec"] = "8.0.3.0"
}

// Sub-class for connectee filters.
//
// This is for the connectee type to be pnic.
// Two filters will apply, which are pnicName and hostName.
// This connectee whole-name will be made up from two names: pnicName and hostName.
type DVSFilterSpecPnicConnecteeSpec struct {
	DVSFilterSpecConnecteeSpec

	// The pnic name to be filtered in the connectee column.
	//
	// If set, port's connectee type being a pnic whose whole-name including this string are qualified.
	PnicNameSpec string `xml:"pnicNameSpec,omitempty" json:"pnicNameSpec,omitempty"`
}

func init() {
	t["DVSFilterSpecPnicConnecteeSpec"] = reflect.TypeOf((*DVSFilterSpecPnicConnecteeSpec)(nil)).Elem()
	minAPIVersionForType["DVSFilterSpecPnicConnecteeSpec"] = "8.0.3.0"
}

// Sub-class for Vlan filters.
//
// This is for the Vlan type to be private Vlan.
type DVSFilterSpecPvlanSpec struct {
	DVSFilterSpecVlanSpec

	// The private VLAN ID for ports.
	//
	// Possible values:
	// A value of 0 specifies that you do not want the port associated
	// with a VLAN.
	// A value from 1 to 4094 specifies a VLAN ID for the port.
	// If set, port private vlans matching are qualified.
	PvlanId int32 `xml:"pvlanId,omitempty" json:"pvlanId,omitempty"`
}

func init() {
	t["DVSFilterSpecPvlanSpec"] = reflect.TypeOf((*DVSFilterSpecPvlanSpec)(nil)).Elem()
	minAPIVersionForType["DVSFilterSpecPvlanSpec"] = "8.0.3.0"
}

// Sub-class for Vlan filters.
//
// This is for the Vlan type to be trunking.
type DVSFilterSpecTrunkVlanSpec struct {
	DVSFilterSpecVlanSpec

	// The VlanId range for the trunk port.
	//
	// The valid VlanId range is
	// from 0 to 4094. Overlapping ranges are allowed.
	// If set, port trunk ranges matching are qualified.
	Range *NumericRange `xml:"range,omitempty" json:"range,omitempty"`
}

func init() {
	t["DVSFilterSpecTrunkVlanSpec"] = reflect.TypeOf((*DVSFilterSpecTrunkVlanSpec)(nil)).Elem()
	minAPIVersionForType["DVSFilterSpecTrunkVlanSpec"] = "8.0.3.0"
}

// Sub-class for Vlan filters.
//
// This is for the Vlan type to be Vlan.
type DVSFilterSpecVlanIdSpec struct {
	DVSFilterSpecVlanSpec

	// The VLAN ID for ports.
	//
	// Possible values:
	// A value of 0 specifies that you do not want the port associated
	// with a VLAN.
	// A value from 1 to 4094 specifies a VLAN ID for the port.
	// If set,port vlans matching are qualified.
	VlanId int32 `xml:"vlanId,omitempty" json:"vlanId,omitempty"`
}

func init() {
	t["DVSFilterSpecVlanIdSpec"] = reflect.TypeOf((*DVSFilterSpecVlanIdSpec)(nil)).Elem()
	minAPIVersionForType["DVSFilterSpecVlanIdSpec"] = "8.0.3.0"
}

// Base class for VlanSpec filters.
//
// This class serves as a base for different types of VlanSpec filters.
// It has three sub-classes.
type DVSFilterSpecVlanSpec struct {
	DynamicData
}

func init() {
	t["DVSFilterSpecVlanSpec"] = reflect.TypeOf((*DVSFilterSpecVlanSpec)(nil)).Elem()
	minAPIVersionForType["DVSFilterSpecVlanSpec"] = "8.0.3.0"
}

// Sub-class for connectee filters.
//
// This is for the connectee type to be vm.
// Only one filter will apply, whici is vmName.
type DVSFilterSpecVmConnecteeSpec struct {
	DVSFilterSpecConnecteeSpec

	// The vm name to be filtered in the connectee column.
	//
	// If set, port's connectee type being a vm whose name including this string are qualified.
	VmNameSpec string `xml:"vmNameSpec,omitempty" json:"vmNameSpec,omitempty"`
}

func init() {
	t["DVSFilterSpecVmConnecteeSpec"] = reflect.TypeOf((*DVSFilterSpecVmConnecteeSpec)(nil)).Elem()
	minAPIVersionForType["DVSFilterSpecVmConnecteeSpec"] = "8.0.3.0"
}

// Sub-class for connectee filters.
//
// This is for the connectee type to be vmknic.
// Two filters will apply, which are vmknicName and hostName.
// This connectee whole-name will be made up from two names: vmknicName and hostName.
type DVSFilterSpecVmknicConnecteeSpec struct {
	DVSFilterSpecConnecteeSpec

	// The vmknic name to be filtered in the connectee column.
	//
	// If set, port's connectee type being a vmknic whose whole-name including this string are qualified.
	VmknicNameSpec string `xml:"vmknicNameSpec,omitempty" json:"vmknicNameSpec,omitempty"`
}

func init() {
	t["DVSFilterSpecVmknicConnecteeSpec"] = reflect.TypeOf((*DVSFilterSpecVmknicConnecteeSpec)(nil)).Elem()
	minAPIVersionForType["DVSFilterSpecVmknicConnecteeSpec"] = "8.0.3.0"
}

// Health check capabilities of health check supported by the
// vSphere Distributed Switch
type DVSHealthCheckCapability struct {
	DynamicData
}

func init() {
	t["DVSHealthCheckCapability"] = reflect.TypeOf((*DVSHealthCheckCapability)(nil)).Elem()
}

// The `DVSHealthCheckConfig` data object
// defines vSphere Distributed Switch health check configuration.
type DVSHealthCheckConfig struct {
	DynamicData

	// True if enable health check.
	Enable *bool `xml:"enable" json:"enable,omitempty"`
	// Interval of health check, in minutes.
	Interval int32 `xml:"interval,omitempty" json:"interval,omitempty"`
}

func init() {
	t["DVSHealthCheckConfig"] = reflect.TypeOf((*DVSHealthCheckConfig)(nil)).Elem()
}

// This data object type describes the information about the host local port.
//
// A host local port is created to resurrect the management network connection
// on a VMkernel Virtual NIC.
type DVSHostLocalPortInfo struct {
	DynamicData

	// UUID of the vSphere Distributed Switch that management interface is connected to.
	SwitchUuid string `xml:"switchUuid" json:"switchUuid"`
	// Portkey of the DVPort that management interface is now connected to.
	PortKey string `xml:"portKey" json:"portKey"`
	// The configuration of the new host local port.
	Setting BaseDVPortSetting `xml:"setting,typeattr" json:"setting"`
	// The Virtual NIC device connected to this port
	Vnic string `xml:"vnic" json:"vnic"`
}

func init() {
	t["DVSHostLocalPortInfo"] = reflect.TypeOf((*DVSHostLocalPortInfo)(nil)).Elem()
}

// This data object type describes MAC learning policy of a port.
type DVSMacLearningPolicy struct {
	InheritablePolicy

	// The flag to indicate if source MAC address learning is allowed.
	Enabled bool `xml:"enabled" json:"enabled"`
	// The flag to allow flooding of unlearned MAC for ingress traffic.
	AllowUnicastFlooding *bool `xml:"allowUnicastFlooding" json:"allowUnicastFlooding,omitempty"`
	// The maximum number of MAC addresses that can be learned.
	Limit *int32 `xml:"limit" json:"limit,omitempty"`
	// The default switching policy after MAC limit is exceeded.
	//
	// See `DVSMacLimitPolicyType_enum`
	// for valid values.
	LimitPolicy string `xml:"limitPolicy,omitempty" json:"limitPolicy,omitempty"`
}

func init() {
	t["DVSMacLearningPolicy"] = reflect.TypeOf((*DVSMacLearningPolicy)(nil)).Elem()
}

// This data object type describes MAC management policy of a port.
type DVSMacManagementPolicy struct {
	InheritablePolicy

	// The flag to indicate whether or not all traffic is seen
	// on the port.
	AllowPromiscuous *bool `xml:"allowPromiscuous" json:"allowPromiscuous,omitempty"`
	// The flag to indicate whether or not the Media Access
	// Control (MAC) address can be changed.
	MacChanges *bool `xml:"macChanges" json:"macChanges,omitempty"`
	// The flag to indicate whether or not the virtual network adapter
	// should be allowed to send network traffic with a different MAC
	// address than that of the virtual network adapter.
	ForgedTransmits *bool `xml:"forgedTransmits" json:"forgedTransmits,omitempty"`
	// The MAC learning policy.
	MacLearningPolicy *DVSMacLearningPolicy `xml:"macLearningPolicy,omitempty" json:"macLearningPolicy,omitempty"`
}

func init() {
	t["DVSMacManagementPolicy"] = reflect.TypeOf((*DVSMacManagementPolicy)(nil)).Elem()
}

// Configuration specification for a DistributedVirtualSwitch or
// DistributedVirtualPortgroup.
type DVSManagerDvsConfigTarget struct {
	DynamicData

	// List of any DistributedVirtualPortgroup available for host Virtual NIC connection.
	DistributedVirtualPortgroup []DistributedVirtualPortgroupInfo `xml:"distributedVirtualPortgroup,omitempty" json:"distributedVirtualPortgroup,omitempty"`
	// List of any DistributedVirtualSwitch available for host Virtual NIC connection.
	DistributedVirtualSwitch []DistributedVirtualSwitchInfo `xml:"distributedVirtualSwitch,omitempty" json:"distributedVirtualSwitch,omitempty"`
}

func init() {
	t["DVSManagerDvsConfigTarget"] = reflect.TypeOf((*DVSManagerDvsConfigTarget)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitchManager.DVSManagerExportEntity_Task`.
type DVSManagerExportEntityRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The selection criteria for a set of
	// entities to export the configuration.
	SelectionSet []BaseSelectionSet `xml:"selectionSet,typeattr" json:"selectionSet"`
}

func init() {
	t["DVSManagerExportEntityRequestType"] = reflect.TypeOf((*DVSManagerExportEntityRequestType)(nil)).Elem()
}

type DVSManagerExportEntity_Task DVSManagerExportEntityRequestType

func init() {
	t["DVSManagerExportEntity_Task"] = reflect.TypeOf((*DVSManagerExportEntity_Task)(nil)).Elem()
}

type DVSManagerExportEntity_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `DistributedVirtualSwitchManager.DVSManagerImportEntity_Task`.
type DVSManagerImportEntityRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Configuration of one or more entities to be imported.
	// The entity backup configuration is returned
	// by the `DistributedVirtualSwitchManager.DVSManagerExportEntity_Task` method.
	EntityBackup []EntityBackupConfig `xml:"entityBackup" json:"entityBackup"`
	// Specifies whether to create a new configuration
	// or restore a previous configuration. See `EntityImportType_enum` for valid values.
	ImportType string `xml:"importType" json:"importType"`
}

func init() {
	t["DVSManagerImportEntityRequestType"] = reflect.TypeOf((*DVSManagerImportEntityRequestType)(nil)).Elem()
}

type DVSManagerImportEntity_Task DVSManagerImportEntityRequestType

func init() {
	t["DVSManagerImportEntity_Task"] = reflect.TypeOf((*DVSManagerImportEntity_Task)(nil)).Elem()
}

type DVSManagerImportEntity_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type DVSManagerLookupDvPortGroup DVSManagerLookupDvPortGroupRequestType

func init() {
	t["DVSManagerLookupDvPortGroup"] = reflect.TypeOf((*DVSManagerLookupDvPortGroup)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitchManager.DVSManagerLookupDvPortGroup`.
type DVSManagerLookupDvPortGroupRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The UUID of the `DistributedVirtualSwitch`.
	SwitchUuid string `xml:"switchUuid" json:"switchUuid"`
	// The key that identifies a
	// `DistributedVirtualPortgroup`.
	PortgroupKey string `xml:"portgroupKey" json:"portgroupKey"`
}

func init() {
	t["DVSManagerLookupDvPortGroupRequestType"] = reflect.TypeOf((*DVSManagerLookupDvPortGroupRequestType)(nil)).Elem()
}

type DVSManagerLookupDvPortGroupResponse struct {
	Returnval *ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// This class is used to store valid PhysicalNics for a specific host
type DVSManagerPhysicalNicsList struct {
	DynamicData

	// Refers instance of `HostSystem`.
	Host         ManagedObjectReference `xml:"host" json:"host"`
	PhysicalNics []PhysicalNic          `xml:"physicalNics,omitempty" json:"physicalNics,omitempty"`
}

func init() {
	t["DVSManagerPhysicalNicsList"] = reflect.TypeOf((*DVSManagerPhysicalNicsList)(nil)).Elem()
	minAPIVersionForType["DVSManagerPhysicalNicsList"] = "8.0.0.1"
}

// The uplink port policy specifies an array of uniform names
// for the uplink ports across the hosts.
//
// The size of the array indicates
// the number of uplink ports that will be created for each host in the
// switch.
//
// When the names in this array change, the uplink ports on all the
// hosts are automatically renamed accordingly. Increasing the number
// of names in the array automatically creates additional uplink ports
// bearing the added name on each host. Decreasing the number of name
// automatically deletes the unused uplink ports on each host. Decreasing
// beyond the number of unused uplink port raises a fault.
//
// This policy overrides the portgroup port naming format
// (`DVPortgroupConfigSpec*.*DVPortgroupConfigSpec.portNameFormat`),
// if both are defined and the uplink ports are created in a uplink portgroup.
type DVSNameArrayUplinkPortPolicy struct {
	DVSUplinkPortPolicy

	// The uniform name of uplink ports on each host.
	UplinkPortName []string `xml:"uplinkPortName" json:"uplinkPortName"`
}

func init() {
	t["DVSNameArrayUplinkPortPolicy"] = reflect.TypeOf((*DVSNameArrayUplinkPortPolicy)(nil)).Elem()
}

// Dataobject representing the feature capabilities of network resource management
// supported by the vSphere Distributed Switch.
type DVSNetworkResourceManagementCapability struct {
	DynamicData

	// Indicates whether network I/O control is
	// supported on the vSphere Distributed Switch.
	//
	// Network I/O control
	// is supported in vSphere Distributed Switch Version 4.1 or later.
	NetworkResourceManagementSupported bool `xml:"networkResourceManagementSupported" json:"networkResourceManagementSupported"`
	// High share level (`SharesLevel_enum*.*high`)
	// for `DVSNetworkResourcePoolAllocationInfo*.*DVSNetworkResourcePoolAllocationInfo.shares`.
	//
	// The <code>networkResourcePoolHighshareValue</code> property implicitly defines
	// the legal range of share values to be between 1 and this value.
	// This property also defines values for other level types, such as
	// `normal` being one half of this value and
	// `low` being one fourth of this value.
	// This feature is supported in vSphere Distributed
	// Switch Version 4.1 or later.
	NetworkResourcePoolHighShareValue int32 `xml:"networkResourcePoolHighShareValue" json:"networkResourcePoolHighShareValue"`
	// Indicates whether Qos Tag(802.1p priority tag)is supported on the
	// vSphere Distributed Switch.
	//
	// Qos Tag is supported in vSphere
	// Distributed Switch Version 5.0 or later.
	QosSupported bool `xml:"qosSupported" json:"qosSupported"`
	// Indicates whether the switch supports creating user defined resource
	// pools.
	//
	// This feature is supported in vSphere Distributed
	// Switch Version 5.0 or later.
	UserDefinedNetworkResourcePoolsSupported bool `xml:"userDefinedNetworkResourcePoolsSupported" json:"userDefinedNetworkResourcePoolsSupported"`
	// Flag to indicate whether Network Resource Control version 3 is supported.
	//
	// The API supported by Network Resouce Control version 3 include:
	//  1. VM virtual NIC network resource specification
	//     `VirtualEthernetCardResourceAllocation`
	//  2. VM virtual NIC network resource pool specification
	//     `DVSVmVnicNetworkResourcePool`
	//  3. Host infrastructure traffic network resource specification
	//     `DvsHostInfrastructureTrafficResource`
	//
	// Network Resource Control version 3 is supported for Switch Version 6.0 or later.
	NetworkResourceControlVersion3Supported *bool `xml:"networkResourceControlVersion3Supported" json:"networkResourceControlVersion3Supported,omitempty"`
	// Indicates whether user defined infrastructure traffic pool
	// supported in vSphere Distributed Switch.
	UserDefinedInfraTrafficPoolSupported *bool `xml:"userDefinedInfraTrafficPoolSupported" json:"userDefinedInfraTrafficPoolSupported,omitempty"`
}

func init() {
	t["DVSNetworkResourceManagementCapability"] = reflect.TypeOf((*DVSNetworkResourceManagementCapability)(nil)).Elem()
}

// Deprecated as of vSphere API 6.0
// Use `DvsHostInfrastructureTrafficResource`
// to manage resource allocation for host infrastructure traffic.
// Use `DVSVmVnicNetworkResourcePool` to manage
// resource allocation for user defined pools.
//
// The `DVSNetworkResourcePool` data object
// describes the resource configuration and management
// of network resource pools.
type DVSNetworkResourcePool struct {
	DynamicData

	// Key of the network resource pool.
	Key string `xml:"key" json:"key"`
	// Name of the network resource pool.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// Description of the network resource pool.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// Configuration version for the network resource pool.
	ConfigVersion string `xml:"configVersion" json:"configVersion"`
	// Resource settings of the resource pool.
	AllocationInfo DVSNetworkResourcePoolAllocationInfo `xml:"allocationInfo" json:"allocationInfo"`
}

func init() {
	t["DVSNetworkResourcePool"] = reflect.TypeOf((*DVSNetworkResourcePool)(nil)).Elem()
}

// Resource allocation information for a network resource pool.
type DVSNetworkResourcePoolAllocationInfo struct {
	DynamicData

	// Maximum allowed usage for network clients belonging to
	// this resource pool per host.
	//
	// The utilization of network clients belonging to this resource pool
	// will not exceed the specified limit even if there are available
	// network resources. If set to -1, then there is no limit on the network
	// resource usage for clients belonging to this resource pool. Units are
	// in Mbits/sec. When setting the allocation of a particular resource
	// pool, if the property is unset, it is treated as no change and the
	// property is not updated. An unset limit value while reading back the
	// allocation information of a network resource pool indicates that
	// there is no limit on the network resource usage for the clients
	// belonging to this resource group.
	Limit *int64 `xml:"limit" json:"limit,omitempty"`
	// Share settings associated with the network resource pool to
	// facilitate proportional sharing of the physical network resources.
	//
	// If the property is unset when setting the allocation of a particular
	// resource pool, it is treated as unset and the property is not updated.
	// The property is always set when reading back the allocation
	// information of a network resource pool.
	Shares *SharesInfo `xml:"shares,omitempty" json:"shares,omitempty"`
	// 802.1p tag to be used for this resource pool.
	//
	// The tag is a priority value
	// in the range 0..7 for Quality of Service operations on network traffic.
	PriorityTag int32 `xml:"priorityTag,omitempty" json:"priorityTag,omitempty"`
}

func init() {
	t["DVSNetworkResourcePoolAllocationInfo"] = reflect.TypeOf((*DVSNetworkResourcePoolAllocationInfo)(nil)).Elem()
}

// The `DVSNetworkResourcePoolConfigSpec` data object
// contains properties to create or update a network resource pool
// for a distributed virtual switch.
type DVSNetworkResourcePoolConfigSpec struct {
	DynamicData

	// Key of the network resource pool.
	//
	// The property is ignored for
	// `DistributedVirtualSwitch*.*DistributedVirtualSwitch.AddNetworkResourcePool`
	// operations.
	Key string `xml:"key" json:"key"`
	// Unique identifier for a given version
	// of the configuration.
	//
	// Each change to the configuration will
	// update this value. This is typically implemented as a
	// non-decreasing count or a time-stamp. However, a client should
	// always treat this as an opaque string.
	//
	// If you specify the configuration version when you update
	// the resource configuration, the Server will apply the changes
	// only if the specified identifier matches the current
	// `DVSNetworkResourcePool*.*DVSNetworkResourcePool.configVersion`
	// value. You can use this field to guard against updates
	// that may have occurred between the time when the client
	// reads `DVSNetworkResourcePool.configVersion`
	// and when the configuration is applied.
	ConfigVersion string `xml:"configVersion,omitempty" json:"configVersion,omitempty"`
	// Network resource allocation for the network resource pool.
	AllocationInfo *DVSNetworkResourcePoolAllocationInfo `xml:"allocationInfo,omitempty" json:"allocationInfo,omitempty"`
	// User defined name for the resource pool.
	//
	// The property is required for
	// `DistributedVirtualSwitch*.*DistributedVirtualSwitch.AddNetworkResourcePool`
	// operations.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// User-defined description for the resource pool.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
}

func init() {
	t["DVSNetworkResourcePoolConfigSpec"] = reflect.TypeOf((*DVSNetworkResourcePoolConfigSpec)(nil)).Elem()
}

// The switch usage policy types
type DVSPolicy struct {
	DynamicData

	// Whether downloading a new proxy VirtualSwitch module to the host is
	// allowed to be automatically executed by the switch.
	AutoPreInstallAllowed *bool `xml:"autoPreInstallAllowed" json:"autoPreInstallAllowed,omitempty"`
	// Whether upgrading of the switch is allowed to be automatically
	// executed by the switch.
	AutoUpgradeAllowed *bool `xml:"autoUpgradeAllowed" json:"autoUpgradeAllowed,omitempty"`
	// Whether to allow upgrading a switch when some of the hosts failed to
	// install the needed module.
	//
	// The vCenter Server will reattempt the
	// pre-install operation of the host module on those failed hosts,
	// whenever they reconnect to vCenter.
	PartialUpgradeAllowed *bool `xml:"partialUpgradeAllowed" json:"partialUpgradeAllowed,omitempty"`
}

func init() {
	t["DVSPolicy"] = reflect.TypeOf((*DVSPolicy)(nil)).Elem()
}

// The `DVSRollbackCapability` data object
// describes the rollback capabilities for a `DistributedVirtualSwitch`.
type DVSRollbackCapability struct {
	DynamicData

	// Indicates whether rollback is supported on the distributed switch.
	RollbackSupported bool `xml:"rollbackSupported" json:"rollbackSupported"`
}

func init() {
	t["DVSRollbackCapability"] = reflect.TypeOf((*DVSRollbackCapability)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.DVSRollback_Task`.
type DVSRollbackRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Backup of a distributed virtual switch, returned by
	// the `DistributedVirtualSwitchManager.DVSManagerExportEntity_Task`
	// method.
	EntityBackup *EntityBackupConfig `xml:"entityBackup,omitempty" json:"entityBackup,omitempty"`
}

func init() {
	t["DVSRollbackRequestType"] = reflect.TypeOf((*DVSRollbackRequestType)(nil)).Elem()
}

type DVSRollback_Task DVSRollbackRequestType

func init() {
	t["DVSRollback_Task"] = reflect.TypeOf((*DVSRollback_Task)(nil)).Elem()
}

type DVSRollback_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The `DVSRuntimeInfo` data object defines
// runtime information for a vSphere Distributed Switch.
type DVSRuntimeInfo struct {
	DynamicData

	// Runtime information of the hosts that joined the switch.
	HostMemberRuntime []HostMemberRuntimeInfo `xml:"hostMemberRuntime,omitempty" json:"hostMemberRuntime,omitempty"`
	// The bandwidth reservation information for the switch.
	ResourceRuntimeInfo *DvsResourceRuntimeInfo `xml:"resourceRuntimeInfo,omitempty" json:"resourceRuntimeInfo,omitempty"`
}

func init() {
	t["DVSRuntimeInfo"] = reflect.TypeOf((*DVSRuntimeInfo)(nil)).Elem()
}

// This data object type describes security policy governing ports.
type DVSSecurityPolicy struct {
	InheritablePolicy

	// The flag to indicate whether or not all traffic is seen
	// on the port.
	AllowPromiscuous *BoolPolicy `xml:"allowPromiscuous,omitempty" json:"allowPromiscuous,omitempty"`
	// The flag to indicate whether or not the Media Access
	// Control (MAC) address can be changed.
	MacChanges *BoolPolicy `xml:"macChanges,omitempty" json:"macChanges,omitempty"`
	// The flag to indicate whether or not the virtual network adapter
	// should be allowed to send network traffic with a different MAC
	// address than that of the virtual network adapter.
	ForgedTransmits *BoolPolicy `xml:"forgedTransmits,omitempty" json:"forgedTransmits,omitempty"`
}

func init() {
	t["DVSSecurityPolicy"] = reflect.TypeOf((*DVSSecurityPolicy)(nil)).Elem()
}

// Class to specify selection criteria of vSphere Distributed Switch.
type DVSSelection struct {
	SelectionSet

	// vSphere Distributed Switch uuid
	DvsUuid string `xml:"dvsUuid" json:"dvsUuid"`
}

func init() {
	t["DVSSelection"] = reflect.TypeOf((*DVSSelection)(nil)).Elem()
}

// Summary of the distributed switch configuration.
type DVSSummary struct {
	DynamicData

	// The name of the switch.
	Name string `xml:"name" json:"name"`
	// The generated UUID of the switch.
	Uuid string `xml:"uuid" json:"uuid"`
	// Current number of ports, not including conflict ports.
	NumPorts int32 `xml:"numPorts" json:"numPorts"`
	// The product information for the implementation of the switch.
	ProductInfo *DistributedVirtualSwitchProductSpec `xml:"productInfo,omitempty" json:"productInfo,omitempty"`
	// The names of the hosts that join the switch.
	//
	// Refers instances of `HostSystem`.
	HostMember []ManagedObjectReference `xml:"hostMember,omitempty" json:"hostMember,omitempty"`
	// The Virtual Machines with Virtual NICs that connect to the switch.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	//
	// Refers instances of `VirtualMachine`.
	Vm []ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
	// The hosts with Virtual NICs that connect to the switch.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The names of the portgroups that are defined on the switch.
	PortgroupName []string `xml:"portgroupName,omitempty" json:"portgroupName,omitempty"`
	// A description string of the switch.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// The human operator contact information.
	Contact *DVSContactInfo `xml:"contact,omitempty" json:"contact,omitempty"`
	// The number of hosts in the switch.
	//
	// The value of this property
	// is not affected by the privileges granted to the current user.
	NumHosts int32 `xml:"numHosts,omitempty" json:"numHosts,omitempty"`
}

func init() {
	t["DVSSummary"] = reflect.TypeOf((*DVSSummary)(nil)).Elem()
}

// This data object type describes traffic shaping policy.
type DVSTrafficShapingPolicy struct {
	InheritablePolicy

	// The flag to indicate whether or not traffic shaper is enabled on
	// the port.
	Enabled *BoolPolicy `xml:"enabled,omitempty" json:"enabled,omitempty"`
	// The average bandwidth in bits per second if shaping is enabled on
	// the port.
	AverageBandwidth *LongPolicy `xml:"averageBandwidth,omitempty" json:"averageBandwidth,omitempty"`
	// The peak bandwidth during bursts in bits per second if traffic
	// shaping is enabled on the port.
	PeakBandwidth *LongPolicy `xml:"peakBandwidth,omitempty" json:"peakBandwidth,omitempty"`
	// The maximum burst size allowed in bytes if shaping is enabled on
	// the port.
	BurstSize *LongPolicy `xml:"burstSize,omitempty" json:"burstSize,omitempty"`
}

func init() {
	t["DVSTrafficShapingPolicy"] = reflect.TypeOf((*DVSTrafficShapingPolicy)(nil)).Elem()
}

// The base class for uplink port policy.
type DVSUplinkPortPolicy struct {
	DynamicData
}

func init() {
	t["DVSUplinkPortPolicy"] = reflect.TypeOf((*DVSUplinkPortPolicy)(nil)).Elem()
}

// This data object type describes vendor specific configuration.
type DVSVendorSpecificConfig struct {
	InheritablePolicy

	// An opaque binary blob that stores vendor specific configuration.
	KeyValue []DistributedVirtualSwitchKeyedOpaqueBlob `xml:"keyValue,omitempty" json:"keyValue,omitempty"`
}

func init() {
	t["DVSVendorSpecificConfig"] = reflect.TypeOf((*DVSVendorSpecificConfig)(nil)).Elem()
}

// DataObject describing the resource configuration and management of
// virtual NIC network resource pools.
type DVSVmVnicNetworkResourcePool struct {
	DynamicData

	// The key of the virtual NIC network resource pool.
	Key string `xml:"key" json:"key"`
	// The name of the virtual NIC network resource pool.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// The description of the virtual NIC network resource pool.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// The config version for the virtual NIC network resource pool.
	ConfigVersion string `xml:"configVersion" json:"configVersion"`
	// The resource settings of the virtual NIC network resource pool.
	AllocationInfo *DvsVmVnicResourceAllocation `xml:"allocationInfo,omitempty" json:"allocationInfo,omitempty"`
}

func init() {
	t["DVSVmVnicNetworkResourcePool"] = reflect.TypeOf((*DVSVmVnicNetworkResourcePool)(nil)).Elem()
}

// The `DailyTaskScheduler` data object sets the time for daily
// task execution.
//
// You set the hour and the inherited minute
// property to complete the schedule. By default, the scheduled task
// will run once every day at the specified hour and minute.
//
// If you set the interval to a value greater than 1, the task will
// execute at the specified daily interval. (For example, an interval
// of 2 will cause the task to execute at the specified hour and minute
// every 2 days.)
type DailyTaskScheduler struct {
	HourlyTaskScheduler

	// The hour at which the `RecurrentTaskScheduler` runs the task.
	//
	// Use UTC (Coordinated Universal Time) values in the range
	// 0 to 23, where 0 = 12:00 a.m. (UTC) and 12 = 12:00 p.m. (UTC).
	//
	// For vCenter 2.x and prior releases, use the server's local time.
	// For example, use Eastern Standard Time (EST) or Pacific Daylight Time (PDT),
	// rather than UTC.
	Hour int32 `xml:"hour" json:"hour"`
}

func init() {
	t["DailyTaskScheduler"] = reflect.TypeOf((*DailyTaskScheduler)(nil)).Elem()
}

// This event records when admission control checks have been disabled in a HA
// cluster.
type DasAdmissionControlDisabledEvent struct {
	ClusterEvent
}

func init() {
	t["DasAdmissionControlDisabledEvent"] = reflect.TypeOf((*DasAdmissionControlDisabledEvent)(nil)).Elem()
}

// This event records when admission control checks have been enabled in a HA cluster.
type DasAdmissionControlEnabledEvent struct {
	ClusterEvent
}

func init() {
	t["DasAdmissionControlEnabledEvent"] = reflect.TypeOf((*DasAdmissionControlEnabledEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, the event is no longer relevant.
//
// This event records that VirtualCenter has re-established contact with a
// primary host in this HA cluster.
type DasAgentFoundEvent struct {
	ClusterEvent
}

func init() {
	t["DasAgentFoundEvent"] = reflect.TypeOf((*DasAgentFoundEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, the event is no longer relevant.
//
// This event records that VirtualCenter cannot contact any primary host
// in this HA cluster.
//
// HA designates some hosts as primary hosts in the HA
// cluster. When adding a new host to an existing cluster, HA needs to
// contact one of the primary hosts to finish the configuration. VirtualCenter
// has lost contact with all primary nodes in the connected state. Attempts
// to configure HA on a host in this cluster will fail until a
// DasAgentFoundEvent is logged or unless this is the first node to be
// configured. For example, if all the other hosts are disconnected first.
type DasAgentUnavailableEvent struct {
	ClusterEvent
}

func init() {
	t["DasAgentUnavailableEvent"] = reflect.TypeOf((*DasAgentUnavailableEvent)(nil)).Elem()
}

// This event records that all hosts have been isolated from the network in a
// HA cluster.
type DasClusterIsolatedEvent struct {
	ClusterEvent
}

func init() {
	t["DasClusterIsolatedEvent"] = reflect.TypeOf((*DasClusterIsolatedEvent)(nil)).Elem()
}

// This fault indicates that some error has occurred during the
// configuration of the host for HA.
//
// This may be subclassed by a more specific fault.
type DasConfigFault struct {
	VimFault

	// The reason why the HA configuration failed, if known.
	//
	// Values should come from `DasConfigFaultDasConfigFaultReason_enum`.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
	// The output (stdout/stderr) from executing the configuration.
	Output string `xml:"output,omitempty" json:"output,omitempty"`
	// The list of events containing details why the configuration failed, if known.
	Event []BaseEvent `xml:"event,omitempty,typeattr" json:"event,omitempty"`
}

func init() {
	t["DasConfigFault"] = reflect.TypeOf((*DasConfigFault)(nil)).Elem()
}

type DasConfigFaultFault DasConfigFault

func init() {
	t["DasConfigFaultFault"] = reflect.TypeOf((*DasConfigFaultFault)(nil)).Elem()
}

// This event records when a cluster has been disabled for HA.
type DasDisabledEvent struct {
	ClusterEvent
}

func init() {
	t["DasDisabledEvent"] = reflect.TypeOf((*DasDisabledEvent)(nil)).Elem()
}

// This event records when a cluster has been enabled for HA.
type DasEnabledEvent struct {
	ClusterEvent
}

func init() {
	t["DasEnabledEvent"] = reflect.TypeOf((*DasEnabledEvent)(nil)).Elem()
}

// Class for the selection of heartbeat datastores
type DasHeartbeatDatastoreInfo struct {
	DynamicData

	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts" json:"hosts"`
}

func init() {
	t["DasHeartbeatDatastoreInfo"] = reflect.TypeOf((*DasHeartbeatDatastoreInfo)(nil)).Elem()
}

// This event records when a host failure has been detected by HA.
type DasHostFailedEvent struct {
	ClusterEvent

	// The host that failed.
	FailedHost HostEventArgument `xml:"failedHost" json:"failedHost"`
}

func init() {
	t["DasHostFailedEvent"] = reflect.TypeOf((*DasHostFailedEvent)(nil)).Elem()
}

// This event records that a host has been isolated from the network in a
// HA cluster.
//
// Since an isolated host cannot be distinguished from a failed
// host except by the isolated host itself, this event is logged when the
// isolated host regains network connectivity.
type DasHostIsolatedEvent struct {
	ClusterEvent

	// The host that was isolated.
	IsolatedHost HostEventArgument `xml:"isolatedHost" json:"isolatedHost"`
}

func init() {
	t["DasHostIsolatedEvent"] = reflect.TypeOf((*DasHostIsolatedEvent)(nil)).Elem()
}

// A DatabaseError exception is thrown if an
// operation failed when accessing the external
// database.
//
// This typically is because
// the database is (temporarily) unavailable or
// because of network problems.
type DatabaseError struct {
	RuntimeFault
}

func init() {
	t["DatabaseError"] = reflect.TypeOf((*DatabaseError)(nil)).Elem()
}

type DatabaseErrorFault DatabaseError

func init() {
	t["DatabaseErrorFault"] = reflect.TypeOf((*DatabaseErrorFault)(nil)).Elem()
}

// DatabaseSizeEstimate contains information about the size
// required to by the database.
type DatabaseSizeEstimate struct {
	DynamicData

	// The estimated size required in MB
	Size int64 `xml:"size" json:"size"`
}

func init() {
	t["DatabaseSizeEstimate"] = reflect.TypeOf((*DatabaseSizeEstimate)(nil)).Elem()
}

// DatabaseSizeParam contains information about a sample inventory.
//
// Using this
// information, database size requirements for that sample inventory can be computed.
// Depending on the accuracy of estimate desired, users can choose to specify
// the number of different types of managed entities. The numHosts and
// numVirtualMachines are the only two required fields. Rest are all optional
// fields filled up by Virtual Center based on some heuristics.
// These parameters need not represent a real inventory. The user can use these
// parameters to estimate the database size required by a hypothetical
// VirtualCenter setup.
type DatabaseSizeParam struct {
	DynamicData

	// Object to capture inventory description
	InventoryDesc InventoryDescription `xml:"inventoryDesc" json:"inventoryDesc"`
	// Object to capture performance statistics
	// related parameters
	PerfStatsDesc *PerformanceStatisticsDescription `xml:"perfStatsDesc,omitempty" json:"perfStatsDesc,omitempty"`
}

func init() {
	t["DatabaseSizeParam"] = reflect.TypeOf((*DatabaseSizeParam)(nil)).Elem()
}

// BasicConnectInfo consists of essential information about the host.
//
// This
// is a subset of `HostConnectInfo` and contains the information
// which is relevant when it comes to dealing with a set of hosts.
type DatacenterBasicConnectInfo struct {
	DynamicData

	// Target host.
	Hostname string `xml:"hostname,omitempty" json:"hostname,omitempty"`
	// Error encountered while querying the host.
	//
	// See
	// `Datacenter.QueryConnectionInfo` for the list of exceptions which can
	// be represented here.
	Error *LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
	// IP address of the VirtualCenter already managing this host, if any.
	ServerIp string `xml:"serverIp,omitempty" json:"serverIp,omitempty"`
	// Specifies the number of VMs on the host.
	NumVm int32 `xml:"numVm,omitempty" json:"numVm,omitempty"`
	// Specifies the number of powered-on VMs on the host.
	NumPoweredOnVm int32 `xml:"numPoweredOnVm,omitempty" json:"numPoweredOnVm,omitempty"`
	// Information about the software running on the host.
	HostProductInfo *AboutInfo `xml:"hostProductInfo,omitempty" json:"hostProductInfo,omitempty"`
	// Hardware vendor identification.
	HardwareVendor string `xml:"hardwareVendor,omitempty" json:"hardwareVendor,omitempty"`
	// System model identification.
	HardwareModel string `xml:"hardwareModel,omitempty" json:"hardwareModel,omitempty"`
}

func init() {
	t["DatacenterBasicConnectInfo"] = reflect.TypeOf((*DatacenterBasicConnectInfo)(nil)).Elem()
}

// Configuration of the datacenter.
type DatacenterConfigInfo struct {
	DynamicData

	// Key for Default Hardware Version used on this datacenter
	// in the format of `VirtualMachineConfigOptionDescriptor.key`.
	//
	// This field affects
	// `VirtualMachineConfigOptionDescriptor.defaultConfigOption` returned
	// by `ComputeResource.environmentBrowser` of all its children
	// with this field unset.
	DefaultHardwareVersionKey string `xml:"defaultHardwareVersionKey,omitempty" json:"defaultHardwareVersionKey,omitempty"`
	// Key for Maximum Hardware Version used on this datacenter
	// in the format of `VirtualMachineConfigOptionDescriptor.key`.
	//
	// This field affects
	// `VirtualMachineConfigOptionDescriptor.defaultConfigOption` returned
	// by `ComputeResource.environmentBrowser` of all its children
	// with this field unset.
	MaximumHardwareVersionKey string `xml:"maximumHardwareVersionKey,omitempty" json:"maximumHardwareVersionKey,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["DatacenterConfigInfo"] = reflect.TypeOf((*DatacenterConfigInfo)(nil)).Elem()
}

// Changes to apply to the datacenter configuration.
type DatacenterConfigSpec struct {
	DynamicData

	// Key for Default Hardware Version to be used on this datacenter
	// in the format of `VirtualMachineConfigOptionDescriptor.key`.
	//
	// Setting this field affects
	// `VirtualMachineConfigOptionDescriptor.defaultConfigOption` returned
	// by `ComputeResource.environmentBrowser` of all its children
	// with this field unset.
	DefaultHardwareVersionKey string `xml:"defaultHardwareVersionKey,omitempty" json:"defaultHardwareVersionKey,omitempty"`
	// Key for Maximum Hardware Version to be used on this datacenter
	// in the format of `VirtualMachineConfigOptionDescriptor.key`.
	//
	// Setting this field affects
	// `VirtualMachineConfigOptionDescriptor.defaultConfigOption` returned
	// by `ComputeResource.environmentBrowser` of all its children
	// with this field unset.
	MaximumHardwareVersionKey string `xml:"maximumHardwareVersionKey,omitempty" json:"maximumHardwareVersionKey,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["DatacenterConfigSpec"] = reflect.TypeOf((*DatacenterConfigSpec)(nil)).Elem()
}

type DatacenterCreatedEvent struct {
	DatacenterEvent

	// The folder where the datacenter is created.
	Parent FolderEventArgument `xml:"parent" json:"parent"`
}

func init() {
	t["DatacenterCreatedEvent"] = reflect.TypeOf((*DatacenterCreatedEvent)(nil)).Elem()
}

// These are datacenter events.
type DatacenterEvent struct {
	Event
}

func init() {
	t["DatacenterEvent"] = reflect.TypeOf((*DatacenterEvent)(nil)).Elem()
}

// The event argument is a Datacenter object.
type DatacenterEventArgument struct {
	EntityEventArgument

	// The Datacenter object.
	//
	// Refers instance of `Datacenter`.
	Datacenter ManagedObjectReference `xml:"datacenter" json:"datacenter"`
}

func init() {
	t["DatacenterEventArgument"] = reflect.TypeOf((*DatacenterEventArgument)(nil)).Elem()
}

// The input arguments had entities that did not belong to the same
// datacenter.
type DatacenterMismatch struct {
	MigrationFault

	// The list of invalid arguments.
	InvalidArgument []DatacenterMismatchArgument `xml:"invalidArgument" json:"invalidArgument"`
	// The expected datacenter for the arguments.
	//
	// Refers instance of `Datacenter`.
	ExpectedDatacenter ManagedObjectReference `xml:"expectedDatacenter" json:"expectedDatacenter"`
}

func init() {
	t["DatacenterMismatch"] = reflect.TypeOf((*DatacenterMismatch)(nil)).Elem()
}

// An input entity argument that belongs to a mismatched datacenter.
type DatacenterMismatchArgument struct {
	DynamicData

	// The invalid input entity.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// The datacenter for this entity.
	//
	// Refers instance of `Datacenter`.
	InputDatacenter *ManagedObjectReference `xml:"inputDatacenter,omitempty" json:"inputDatacenter,omitempty"`
}

func init() {
	t["DatacenterMismatchArgument"] = reflect.TypeOf((*DatacenterMismatchArgument)(nil)).Elem()
}

type DatacenterMismatchFault DatacenterMismatch

func init() {
	t["DatacenterMismatchFault"] = reflect.TypeOf((*DatacenterMismatchFault)(nil)).Elem()
}

type DatacenterRenamedEvent struct {
	DatacenterEvent

	// The old datacenter name.
	OldName string `xml:"oldName" json:"oldName"`
	// The new datacenter name.
	NewName string `xml:"newName" json:"newName"`
}

func init() {
	t["DatacenterRenamedEvent"] = reflect.TypeOf((*DatacenterRenamedEvent)(nil)).Elem()
}

// Information about the capabilities of this datastore.
type DatastoreCapability struct {
	DynamicData

	// Indicates whether or not directories can be created on this datastore.
	DirectoryHierarchySupported bool `xml:"directoryHierarchySupported" json:"directoryHierarchySupported"`
	// Indicates whether or not raw disk mappings can be created on this datastore.
	RawDiskMappingsSupported bool `xml:"rawDiskMappingsSupported" json:"rawDiskMappingsSupported"`
	// Indicates whether or not the datastore supports thin provisioning on a per file
	// basis.
	//
	// When thin provisioning is used, backing storage is lazily allocated.
	//
	// This is supported by VMFS3. VMFS2 always allocates storage eagerly. Thus, this
	// value is false for VMFS2. Most NAS systems always use thin provisioning.
	// They do not support configuring this on a per file basis, so for NAS systems
	// this value is also false.
	PerFileThinProvisioningSupported bool `xml:"perFileThinProvisioningSupported" json:"perFileThinProvisioningSupported"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Indicates whether the datastore supports Storage I/O Resource Management.
	StorageIORMSupported *bool `xml:"storageIORMSupported" json:"storageIORMSupported,omitempty"`
	// Indicates whether the datastore supports native snapshot feature which is
	// based on Copy-On-Write.
	NativeSnapshotSupported *bool `xml:"nativeSnapshotSupported" json:"nativeSnapshotSupported,omitempty"`
	// Indicates whether the datastore supports traditional top-level
	// directory creation.
	//
	// See also `DatastoreNamespaceManager`.
	TopLevelDirectoryCreateSupported *bool `xml:"topLevelDirectoryCreateSupported" json:"topLevelDirectoryCreateSupported,omitempty"`
	// Indicates whether the datastore supports the Flex-SE(SeSparse) feature.
	SeSparseSupported *bool `xml:"seSparseSupported" json:"seSparseSupported,omitempty"`
	// Indicates whether the datastore supports the vmfsSparse feature.
	//
	// True for VMFS3/VMFS5/NFS/NFS41, False for VMFS6.
	// If value is undefined, then it should be read as supported.
	VmfsSparseSupported *bool `xml:"vmfsSparseSupported" json:"vmfsSparseSupported,omitempty"`
	// Indicates whether the datastore supports the vsanSparse feature.
	VsanSparseSupported *bool `xml:"vsanSparseSupported" json:"vsanSparseSupported,omitempty"`
	// Deprecated as of vSphere API 8.0, and there is no replacement for it.
	//
	// Indicates whether the datastore supports the upit feature.
	UpitSupported *bool `xml:"upitSupported" json:"upitSupported,omitempty"`
	// On certain datastores (e.g.
	//
	// 2016 PMEM datastore) VMDK expand is not supported.
	// This field tells user if VMDK on this datastore can be expanded or not.
	// If value is undefined, then it should be read as supported.
	VmdkExpandSupported *bool `xml:"vmdkExpandSupported" json:"vmdkExpandSupported,omitempty"`
	// Indicates whether the datastore supports clustered VMDK feature.
	ClusteredVmdkSupported *bool `xml:"clusteredVmdkSupported" json:"clusteredVmdkSupported,omitempty"`
}

func init() {
	t["DatastoreCapability"] = reflect.TypeOf((*DatastoreCapability)(nil)).Elem()
}

// This event records when increase in a datastore's capacity is observed.
//
// It may happen due to different reasons, like extending or expanding a
// datastore.
type DatastoreCapacityIncreasedEvent struct {
	DatastoreEvent

	// The old datastore capacity.
	OldCapacity int64 `xml:"oldCapacity" json:"oldCapacity"`
	// The new datastore capacity.
	NewCapacity int64 `xml:"newCapacity" json:"newCapacity"`
}

func init() {
	t["DatastoreCapacityIncreasedEvent"] = reflect.TypeOf((*DatastoreCapacityIncreasedEvent)(nil)).Elem()
}

// This event records when a datastore is removed from VirtualCenter.
type DatastoreDestroyedEvent struct {
	DatastoreEvent
}

func init() {
	t["DatastoreDestroyedEvent"] = reflect.TypeOf((*DatastoreDestroyedEvent)(nil)).Elem()
}

// This event records when a host is added to VirtualCenter
// and datastores are discovered.
type DatastoreDiscoveredEvent struct {
	HostEvent

	// The associated datastore.
	Datastore DatastoreEventArgument `xml:"datastore" json:"datastore"`
}

func init() {
	t["DatastoreDiscoveredEvent"] = reflect.TypeOf((*DatastoreDiscoveredEvent)(nil)).Elem()
}

// This event records when a duplicate datastore name is found.
//
// This event is used in VirtualCenter 1.x and is included for
// backward compatibility.
type DatastoreDuplicatedEvent struct {
	DatastoreEvent
}

func init() {
	t["DatastoreDuplicatedEvent"] = reflect.TypeOf((*DatastoreDuplicatedEvent)(nil)).Elem()
}

type DatastoreEnterMaintenanceMode DatastoreEnterMaintenanceModeRequestType

func init() {
	t["DatastoreEnterMaintenanceMode"] = reflect.TypeOf((*DatastoreEnterMaintenanceMode)(nil)).Elem()
}

type DatastoreEnterMaintenanceModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DatastoreEnterMaintenanceModeRequestType"] = reflect.TypeOf((*DatastoreEnterMaintenanceModeRequestType)(nil)).Elem()
}

type DatastoreEnterMaintenanceModeResponse struct {
	Returnval StoragePlacementResult `xml:"returnval" json:"returnval"`
}

// These are datastore events.
type DatastoreEvent struct {
	Event

	// The associated datastore.
	Datastore *DatastoreEventArgument `xml:"datastore,omitempty" json:"datastore,omitempty"`
}

func init() {
	t["DatastoreEvent"] = reflect.TypeOf((*DatastoreEvent)(nil)).Elem()
}

// The event argument is a Datastore object.
type DatastoreEventArgument struct {
	EntityEventArgument

	// The Datastore object.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["DatastoreEventArgument"] = reflect.TypeOf((*DatastoreEventArgument)(nil)).Elem()
}

type DatastoreExitMaintenanceModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DatastoreExitMaintenanceModeRequestType"] = reflect.TypeOf((*DatastoreExitMaintenanceModeRequestType)(nil)).Elem()
}

type DatastoreExitMaintenanceMode_Task DatastoreExitMaintenanceModeRequestType

func init() {
	t["DatastoreExitMaintenanceMode_Task"] = reflect.TypeOf((*DatastoreExitMaintenanceMode_Task)(nil)).Elem()
}

type DatastoreExitMaintenanceMode_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This event records copy of a file or directory.
type DatastoreFileCopiedEvent struct {
	DatastoreFileEvent

	// Source datastore.
	SourceDatastore DatastoreEventArgument `xml:"sourceDatastore" json:"sourceDatastore"`
	// Datastore path of the source file or directory.
	SourceFile string `xml:"sourceFile" json:"sourceFile"`
}

func init() {
	t["DatastoreFileCopiedEvent"] = reflect.TypeOf((*DatastoreFileCopiedEvent)(nil)).Elem()
}

// This event records deletion of a file or directory.
type DatastoreFileDeletedEvent struct {
	DatastoreFileEvent
}

func init() {
	t["DatastoreFileDeletedEvent"] = reflect.TypeOf((*DatastoreFileDeletedEvent)(nil)).Elem()
}

// Base class for events related to datastore file and directory
// operations.
//
// Property _datastore_ inherited from DatastoreEvent refers
// to the destination datastore in case there is more than datastore
// involved in the operation.
type DatastoreFileEvent struct {
	DatastoreEvent

	// Datastore path of the target file or directory.
	TargetFile string `xml:"targetFile" json:"targetFile"`
	// Identifier of the initiator of the file operation.
	SourceOfOperation string `xml:"sourceOfOperation,omitempty" json:"sourceOfOperation,omitempty"`
	// Indicator whether the datastore file operation succeeded.
	Succeeded *bool `xml:"succeeded" json:"succeeded,omitempty"`
}

func init() {
	t["DatastoreFileEvent"] = reflect.TypeOf((*DatastoreFileEvent)(nil)).Elem()
}

// This event records move of a file or directory.
type DatastoreFileMovedEvent struct {
	DatastoreFileEvent

	// Source datastore.
	SourceDatastore DatastoreEventArgument `xml:"sourceDatastore" json:"sourceDatastore"`
	// Datastore path of the source file or directory.
	SourceFile string `xml:"sourceFile" json:"sourceFile"`
}

func init() {
	t["DatastoreFileMovedEvent"] = reflect.TypeOf((*DatastoreFileMovedEvent)(nil)).Elem()
}

// Host-specific datastore information.
type DatastoreHostMount struct {
	DynamicData

	// The host associated with this datastore.
	//
	// Refers instance of `HostSystem`.
	Key ManagedObjectReference `xml:"key" json:"key"`
	// Host-specific information about the mount.
	MountInfo HostMountInfo `xml:"mountInfo" json:"mountInfo"`
}

func init() {
	t["DatastoreHostMount"] = reflect.TypeOf((*DatastoreHostMount)(nil)).Elem()
}

// This event records that the configuration of storage I/O
// resource management for a datastore has changed.
type DatastoreIORMReconfiguredEvent struct {
	DatastoreEvent
}

func init() {
	t["DatastoreIORMReconfiguredEvent"] = reflect.TypeOf((*DatastoreIORMReconfiguredEvent)(nil)).Elem()
}

// Detailed information about a datastore.
//
// This is a base type for derived types
// that have more specific details about a datastore.
//
// See also `HostVmfsVolume`, `HostNasVolume`, `HostLocalFileSystemVolume`.
type DatastoreInfo struct {
	DynamicData

	// The name of the datastore.
	Name string `xml:"name" json:"name"`
	// The unique locator for the datastore.
	Url string `xml:"url" json:"url"`
	// Free space of this datastore, in bytes.
	//
	// The server periodically updates this
	// value. It can be explicitly refreshed with the Refresh operation.
	FreeSpace int64 `xml:"freeSpace" json:"freeSpace"`
	// The maximum size of a file that can reside on this file system volume.
	MaxFileSize int64 `xml:"maxFileSize" json:"maxFileSize"`
	// The maximum capacity of a virtual disk which can be created on this volume.
	MaxVirtualDiskCapacity int64 `xml:"maxVirtualDiskCapacity,omitempty" json:"maxVirtualDiskCapacity,omitempty"`
	// The maximum size of a snapshot or a swap file that can reside on this file system volume.
	MaxMemoryFileSize int64 `xml:"maxMemoryFileSize,omitempty" json:"maxMemoryFileSize,omitempty"`
	// Time when the free-space and capacity values in `DatastoreInfo` and
	// `DatastoreSummary` were updated.
	Timestamp *time.Time `xml:"timestamp" json:"timestamp,omitempty"`
	// The unique container ID of the datastore, if applicable.
	ContainerId string `xml:"containerId,omitempty" json:"containerId,omitempty"`
	// vSAN datastore container that this datastore is alias of.
	//
	// If this
	// field is unset then this datastore is not alias of any other vSAN
	// datastore.
	// See `DatastoreInfo.containerId`.
	AliasOf string `xml:"aliasOf,omitempty" json:"aliasOf,omitempty"`
}

func init() {
	t["DatastoreInfo"] = reflect.TypeOf((*DatastoreInfo)(nil)).Elem()
}

// Contains a mapping of an old mount path and its corresponding
// resignatured or remounted datastore
type DatastoreMountPathDatastorePair struct {
	DynamicData

	// Old file path where file system volume is mounted, which
	// should be `path` value in
	// `HostMountInfo`
	OldMountPath string `xml:"oldMountPath" json:"oldMountPath"`
	// The resignatured or remounted datastore corresponding to the oldMountPath
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["DatastoreMountPathDatastorePair"] = reflect.TypeOf((*DatastoreMountPathDatastorePair)(nil)).Elem()
}

type DatastoreNamespaceManagerDirectoryInfo struct {
	DynamicData

	// Size in MB of underlying object.
	Capacity int64 `xml:"capacity" json:"capacity"`
	// Used size in MB in the VMFS volume.
	Used int64 `xml:"used" json:"used"`
}

func init() {
	t["DatastoreNamespaceManagerDirectoryInfo"] = reflect.TypeOf((*DatastoreNamespaceManagerDirectoryInfo)(nil)).Elem()
	minAPIVersionForType["DatastoreNamespaceManagerDirectoryInfo"] = "8.0.1.0"
}

// This exception is thrown if a datastore is not
// writable on the target host.
type DatastoreNotWritableOnHost struct {
	InvalidDatastore

	// The target host on which the datastore is not writable.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["DatastoreNotWritableOnHost"] = reflect.TypeOf((*DatastoreNotWritableOnHost)(nil)).Elem()
}

type DatastoreNotWritableOnHostFault BaseDatastoreNotWritableOnHost

func init() {
	t["DatastoreNotWritableOnHostFault"] = reflect.TypeOf((*DatastoreNotWritableOnHostFault)(nil)).Elem()
}

// The DatastoreOption data object describes datastore options
// for a virtual machine.
type DatastoreOption struct {
	DynamicData

	// The type of file system volumes on which this virtual machine cannot have
	// its disk and configuration files.
	UnsupportedVolumes []VirtualMachineDatastoreVolumeOption `xml:"unsupportedVolumes,omitempty" json:"unsupportedVolumes,omitempty"`
}

func init() {
	t["DatastoreOption"] = reflect.TypeOf((*DatastoreOption)(nil)).Elem()
}

// This event records that a datastore principal was configured on a host.
type DatastorePrincipalConfigured struct {
	HostEvent

	DatastorePrincipal string `xml:"datastorePrincipal" json:"datastorePrincipal"`
}

func init() {
	t["DatastorePrincipalConfigured"] = reflect.TypeOf((*DatastorePrincipalConfigured)(nil)).Elem()
}

// This event records when a datastore is removed from a host
// but not from VirtualCenter.
type DatastoreRemovedOnHostEvent struct {
	HostEvent

	// The associated datastore.
	Datastore DatastoreEventArgument `xml:"datastore" json:"datastore"`
}

func init() {
	t["DatastoreRemovedOnHostEvent"] = reflect.TypeOf((*DatastoreRemovedOnHostEvent)(nil)).Elem()
}

// This event records the renaming of a datastore.
type DatastoreRenamedEvent struct {
	DatastoreEvent

	// The old datastore name.
	OldName string `xml:"oldName" json:"oldName"`
	// The new datastore name.
	NewName string `xml:"newName" json:"newName"`
}

func init() {
	t["DatastoreRenamedEvent"] = reflect.TypeOf((*DatastoreRenamedEvent)(nil)).Elem()
}

// This event records when a datastore is added to VirtualCenter
// and is renamed by VirtualCenter because this datastore already
// exists in VirtualCenter with a different name, or because the
// name conflicts with another datastore in VirtualCenter.
type DatastoreRenamedOnHostEvent struct {
	HostEvent

	// The old datastore name.
	OldName string `xml:"oldName" json:"oldName"`
	// The new datastore name.
	NewName string `xml:"newName" json:"newName"`
}

func init() {
	t["DatastoreRenamedOnHostEvent"] = reflect.TypeOf((*DatastoreRenamedOnHostEvent)(nil)).Elem()
}

// Summary information about the datastore.
//
// The status fields and managed object
// reference is not set when an object of this type is created. These fields and
// references are typically set later when these objects are associated with a host.
type DatastoreSummary struct {
	DynamicData

	// The reference to the managed object.
	//
	// Refers instance of `Datastore`.
	Datastore *ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty"`
	// The name of the datastore.
	Name string `xml:"name" json:"name"`
	// The unique locator for the datastore.
	//
	// This property is guaranteed to be valid
	// only if `DatastoreSummary.accessible` is true.
	Url string `xml:"url" json:"url"`
	// Maximum capacity of this datastore, in bytes.
	//
	// This value is updated
	// periodically by the server. It can be explicitly refreshed with the Refresh
	// operation. This property is guaranteed to be valid only if `DatastoreSummary.accessible`
	// is true.
	Capacity int64 `xml:"capacity" json:"capacity"`
	// Available space of this datastore, in bytes.
	//
	// The server periodically
	// updates this value. It can be explicitly refreshed with the Refresh operation.
	// This property is guaranteed to be valid only if `DatastoreSummary.accessible` is true.
	FreeSpace int64 `xml:"freeSpace" json:"freeSpace"`
	// Total additional storage space, in bytes, potentially used by all
	// virtual machines on this datastore.
	//
	// The server periodically updates this
	// value.
	// It can be explicitly refreshed with the `Datastore.RefreshDatastoreStorageInfo` operation.
	// This property is valid only if `DatastoreSummary.accessible` is true.
	Uncommitted int64 `xml:"uncommitted,omitempty" json:"uncommitted,omitempty"`
	// The connectivity status of this datastore.
	//
	// If this is set to false, meaning the
	// datastore is not accessible, this datastore's capacity and freespace properties
	// cannot be validated. Furthermore, if this property is set to false, some of the
	// properties in this summary and in `DatastoreInfo` should not be
	// used. Refer to the documentation for the property of your interest.
	// For datastores accessed from multiple hosts, vCenter Server reports
	// `DatastoreSummary.accessible` as an aggregated value of the
	// properties reported in `HostMountInfo`. For instance,
	// if a datastore is accessible through a subset of hosts, then the value of
	// `DatastoreSummary.accessible` will be reported as true by
	// vCenter Server. And the reason for a daastore being inaccessible from a host
	// will be reported in `HostMountInfo.inaccessibleReason`
	Accessible bool `xml:"accessible" json:"accessible"`
	// More than one host in the datacenter has been configured with access to the
	// datastore.
	//
	// This is only provided by VirtualCenter.
	MultipleHostAccess *bool `xml:"multipleHostAccess" json:"multipleHostAccess,omitempty"`
	// Type of file system volume, such as VMFS or NFS.
	//
	// See also `HostFileSystemVolume.type`.
	Type string `xml:"type" json:"type"`
	// The current maintenance mode state of the datastore.
	//
	// The set of
	// possible values is described in `DatastoreSummaryMaintenanceModeState_enum`.
	MaintenanceMode string `xml:"maintenanceMode,omitempty" json:"maintenanceMode,omitempty"`
}

func init() {
	t["DatastoreSummary"] = reflect.TypeOf((*DatastoreSummary)(nil)).Elem()
}

// A pair of source and target VVol containers and mapping of VVol
// IDs from source to target.
type DatastoreVVolContainerFailoverPair struct {
	DynamicData

	// Storage container on the source side.
	SrcContainer string `xml:"srcContainer,omitempty" json:"srcContainer,omitempty"`
	// Storage container on the target side.
	TgtContainer string `xml:"tgtContainer" json:"tgtContainer"`
	// Mapping of VVol IDs from source to target corresponding to the
	// given set of containers.
	VvolMapping []KeyValue `xml:"vvolMapping,omitempty" json:"vvolMapping,omitempty"`
}

func init() {
	t["DatastoreVVolContainerFailoverPair"] = reflect.TypeOf((*DatastoreVVolContainerFailoverPair)(nil)).Elem()
}

// The `DateTimeProfile` data object represents host date and time configuration.
//
// Use the `ApplyProfile.policy` list for access to configuration data
// for the date and time profile. Use the `ApplyProfile.property` list
// for access to subprofiles, if any.
type DateTimeProfile struct {
	ApplyProfile
}

func init() {
	t["DateTimeProfile"] = reflect.TypeOf((*DateTimeProfile)(nil)).Elem()
}

type DecodeLicense DecodeLicenseRequestType

func init() {
	t["DecodeLicense"] = reflect.TypeOf((*DecodeLicense)(nil)).Elem()
}

// The parameters of `LicenseManager.DecodeLicense`.
type DecodeLicenseRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A license. E.g. a serial license.
	LicenseKey string `xml:"licenseKey" json:"licenseKey"`
}

func init() {
	t["DecodeLicenseRequestType"] = reflect.TypeOf((*DecodeLicenseRequestType)(nil)).Elem()
}

type DecodeLicenseResponse struct {
	Returnval LicenseManagerLicenseInfo `xml:"returnval" json:"returnval"`
}

type DefragmentAllDisks DefragmentAllDisksRequestType

func init() {
	t["DefragmentAllDisks"] = reflect.TypeOf((*DefragmentAllDisks)(nil)).Elem()
}

type DefragmentAllDisksRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DefragmentAllDisksRequestType"] = reflect.TypeOf((*DefragmentAllDisksRequestType)(nil)).Elem()
}

type DefragmentAllDisksResponse struct {
}

// The parameters of `VirtualDiskManager.DefragmentVirtualDisk_Task`.
type DefragmentVirtualDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk that should be defragmented.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
}

func init() {
	t["DefragmentVirtualDiskRequestType"] = reflect.TypeOf((*DefragmentVirtualDiskRequestType)(nil)).Elem()
}

type DefragmentVirtualDisk_Task DefragmentVirtualDiskRequestType

func init() {
	t["DefragmentVirtualDisk_Task"] = reflect.TypeOf((*DefragmentVirtualDisk_Task)(nil)).Elem()
}

type DefragmentVirtualDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type DeleteCustomizationSpec DeleteCustomizationSpecRequestType

func init() {
	t["DeleteCustomizationSpec"] = reflect.TypeOf((*DeleteCustomizationSpec)(nil)).Elem()
}

// The parameters of `CustomizationSpecManager.DeleteCustomizationSpec`.
type DeleteCustomizationSpecRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Name string                 `xml:"name" json:"name"`
}

func init() {
	t["DeleteCustomizationSpecRequestType"] = reflect.TypeOf((*DeleteCustomizationSpecRequestType)(nil)).Elem()
}

type DeleteCustomizationSpecResponse struct {
}

// The parameters of `FileManager.DeleteDatastoreFile_Task`.
type DeleteDatastoreFileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the file or folder, either a URL or a datastore path
	// referring to the file or folder to be deleted.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Required privileges: System.View
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
}

func init() {
	t["DeleteDatastoreFileRequestType"] = reflect.TypeOf((*DeleteDatastoreFileRequestType)(nil)).Elem()
}

type DeleteDatastoreFile_Task DeleteDatastoreFileRequestType

func init() {
	t["DeleteDatastoreFile_Task"] = reflect.TypeOf((*DeleteDatastoreFile_Task)(nil)).Elem()
}

type DeleteDatastoreFile_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type DeleteDirectory DeleteDirectoryRequestType

func init() {
	t["DeleteDirectory"] = reflect.TypeOf((*DeleteDirectory)(nil)).Elem()
}

type DeleteDirectoryInGuest DeleteDirectoryInGuestRequestType

func init() {
	t["DeleteDirectoryInGuest"] = reflect.TypeOf((*DeleteDirectoryInGuest)(nil)).Elem()
}

// The parameters of `GuestFileManager.DeleteDirectoryInGuest`.
type DeleteDirectoryInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual Machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Modify
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The complete path to the directory to be deleted.
	DirectoryPath string `xml:"directoryPath" json:"directoryPath"`
	// If true, all subdirectories are also deleted.
	// If false, the directory must be empty for the operation to succeed.
	Recursive bool `xml:"recursive" json:"recursive"`
}

func init() {
	t["DeleteDirectoryInGuestRequestType"] = reflect.TypeOf((*DeleteDirectoryInGuestRequestType)(nil)).Elem()
}

type DeleteDirectoryInGuestResponse struct {
}

// The parameters of `DatastoreNamespaceManager.DeleteDirectory`.
type DeleteDirectoryRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datacenter of the datastore path. Needs to be set
	// when making the call to VC; ignored when the call is
	// made to ESX.
	//
	// Required privileges: System.View
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// Stable vmfs path of the directory to delete.
	DatastorePath string `xml:"datastorePath" json:"datastorePath"`
}

func init() {
	t["DeleteDirectoryRequestType"] = reflect.TypeOf((*DeleteDirectoryRequestType)(nil)).Elem()
}

type DeleteDirectoryResponse struct {
}

type DeleteFile DeleteFileRequestType

func init() {
	t["DeleteFile"] = reflect.TypeOf((*DeleteFile)(nil)).Elem()
}

type DeleteFileInGuest DeleteFileInGuestRequestType

func init() {
	t["DeleteFileInGuest"] = reflect.TypeOf((*DeleteFileInGuest)(nil)).Elem()
}

// The parameters of `GuestFileManager.DeleteFileInGuest`.
type DeleteFileInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual Machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Modify
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The complete path to the file or symbolic link to be deleted.
	FilePath string `xml:"filePath" json:"filePath"`
}

func init() {
	t["DeleteFileInGuestRequestType"] = reflect.TypeOf((*DeleteFileInGuestRequestType)(nil)).Elem()
}

type DeleteFileInGuestResponse struct {
}

// The parameters of `HostDatastoreBrowser.DeleteFile`.
type DeleteFileRequestType struct {
	This          ManagedObjectReference `xml:"_this" json:"-"`
	DatastorePath string                 `xml:"datastorePath" json:"datastorePath"`
}

func init() {
	t["DeleteFileRequestType"] = reflect.TypeOf((*DeleteFileRequestType)(nil)).Elem()
}

type DeleteFileResponse struct {
}

type DeleteHostSpecification DeleteHostSpecificationRequestType

func init() {
	t["DeleteHostSpecification"] = reflect.TypeOf((*DeleteHostSpecification)(nil)).Elem()
}

// The parameters of `HostSpecificationManager.DeleteHostSpecification`.
type DeleteHostSpecificationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specified host for which the specification will be
	// deleted.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["DeleteHostSpecificationRequestType"] = reflect.TypeOf((*DeleteHostSpecificationRequestType)(nil)).Elem()
}

type DeleteHostSpecificationResponse struct {
}

type DeleteHostSubSpecification DeleteHostSubSpecificationRequestType

func init() {
	t["DeleteHostSubSpecification"] = reflect.TypeOf((*DeleteHostSubSpecification)(nil)).Elem()
}

// The parameters of `HostSpecificationManager.DeleteHostSubSpecification`.
type DeleteHostSubSpecificationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specified host for which the sub specification will be
	// deleted.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The name of the host sub specification to be deleted.
	SubSpecName string `xml:"subSpecName" json:"subSpecName"`
}

func init() {
	t["DeleteHostSubSpecificationRequestType"] = reflect.TypeOf((*DeleteHostSubSpecificationRequestType)(nil)).Elem()
}

type DeleteHostSubSpecificationResponse struct {
}

type DeleteNvdimmBlockNamespacesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DeleteNvdimmBlockNamespacesRequestType"] = reflect.TypeOf((*DeleteNvdimmBlockNamespacesRequestType)(nil)).Elem()
}

type DeleteNvdimmBlockNamespaces_Task DeleteNvdimmBlockNamespacesRequestType

func init() {
	t["DeleteNvdimmBlockNamespaces_Task"] = reflect.TypeOf((*DeleteNvdimmBlockNamespaces_Task)(nil)).Elem()
}

type DeleteNvdimmBlockNamespaces_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostNvdimmSystem.DeleteNvdimmNamespace_Task`.
type DeleteNvdimmNamespaceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Details of namespace to be deleted.
	DeleteSpec NvdimmNamespaceDeleteSpec `xml:"deleteSpec" json:"deleteSpec"`
}

func init() {
	t["DeleteNvdimmNamespaceRequestType"] = reflect.TypeOf((*DeleteNvdimmNamespaceRequestType)(nil)).Elem()
}

type DeleteNvdimmNamespace_Task DeleteNvdimmNamespaceRequestType

func init() {
	t["DeleteNvdimmNamespace_Task"] = reflect.TypeOf((*DeleteNvdimmNamespace_Task)(nil)).Elem()
}

type DeleteNvdimmNamespace_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type DeleteRegistryKeyInGuest DeleteRegistryKeyInGuestRequestType

func init() {
	t["DeleteRegistryKeyInGuest"] = reflect.TypeOf((*DeleteRegistryKeyInGuest)(nil)).Elem()
}

// The parameters of `GuestWindowsRegistryManager.DeleteRegistryKeyInGuest`.
type DeleteRegistryKeyInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Modify
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The path to the registry key to be deleted.
	KeyName GuestRegKeyNameSpec `xml:"keyName" json:"keyName"`
	// If true, the key is deleted along with any subkeys (if
	// present). Otherwise, it shall only delete the key if it
	// has no subkeys.
	Recursive bool `xml:"recursive" json:"recursive"`
}

func init() {
	t["DeleteRegistryKeyInGuestRequestType"] = reflect.TypeOf((*DeleteRegistryKeyInGuestRequestType)(nil)).Elem()
}

type DeleteRegistryKeyInGuestResponse struct {
}

type DeleteRegistryValueInGuest DeleteRegistryValueInGuestRequestType

func init() {
	t["DeleteRegistryValueInGuest"] = reflect.TypeOf((*DeleteRegistryValueInGuest)(nil)).Elem()
}

// The parameters of `GuestWindowsRegistryManager.DeleteRegistryValueInGuest`.
type DeleteRegistryValueInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Modify
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The registry value name to be deleted.
	// The Value "name" (specified in
	// `GuestRegValueNameSpec`)
	// can be empty. If "name" is empty, it deletes the value
	// for the unnamed or default value of the given key.
	ValueName GuestRegValueNameSpec `xml:"valueName" json:"valueName"`
}

func init() {
	t["DeleteRegistryValueInGuestRequestType"] = reflect.TypeOf((*DeleteRegistryValueInGuestRequestType)(nil)).Elem()
}

type DeleteRegistryValueInGuestResponse struct {
}

type DeleteScsiLunState DeleteScsiLunStateRequestType

func init() {
	t["DeleteScsiLunState"] = reflect.TypeOf((*DeleteScsiLunState)(nil)).Elem()
}

// The parameters of `HostStorageSystem.DeleteScsiLunState`.
type DeleteScsiLunStateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The 'canonicalName' of the ScsiLun
	// whose state needs to be deleted.
	LunCanonicalName string `xml:"lunCanonicalName" json:"lunCanonicalName"`
}

func init() {
	t["DeleteScsiLunStateRequestType"] = reflect.TypeOf((*DeleteScsiLunStateRequestType)(nil)).Elem()
}

type DeleteScsiLunStateResponse struct {
}

// The parameters of `VcenterVStorageObjectManager.DeleteSnapshot_Task`.
type DeleteSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The ID of the snapshot of a virtual storage object.
	SnapshotId ID `xml:"snapshotId" json:"snapshotId"`
}

func init() {
	t["DeleteSnapshotRequestType"] = reflect.TypeOf((*DeleteSnapshotRequestType)(nil)).Elem()
}

type DeleteSnapshot_Task DeleteSnapshotRequestType

func init() {
	t["DeleteSnapshot_Task"] = reflect.TypeOf((*DeleteSnapshot_Task)(nil)).Elem()
}

type DeleteSnapshot_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VcenterVStorageObjectManager.DeleteVStorageObjectEx_Task`.
type DeleteVStorageObjectExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object to be deleted.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["DeleteVStorageObjectExRequestType"] = reflect.TypeOf((*DeleteVStorageObjectExRequestType)(nil)).Elem()
	minAPIVersionForType["DeleteVStorageObjectExRequestType"] = "7.0.2.0"
}

type DeleteVStorageObjectEx_Task DeleteVStorageObjectExRequestType

func init() {
	t["DeleteVStorageObjectEx_Task"] = reflect.TypeOf((*DeleteVStorageObjectEx_Task)(nil)).Elem()
}

type DeleteVStorageObjectEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VcenterVStorageObjectManager.DeleteVStorageObject_Task`.
type DeleteVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object to be deleted.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["DeleteVStorageObjectRequestType"] = reflect.TypeOf((*DeleteVStorageObjectRequestType)(nil)).Elem()
}

type DeleteVStorageObject_Task DeleteVStorageObjectRequestType

func init() {
	t["DeleteVStorageObject_Task"] = reflect.TypeOf((*DeleteVStorageObject_Task)(nil)).Elem()
}

type DeleteVStorageObject_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type DeleteVffsVolumeState DeleteVffsVolumeStateRequestType

func init() {
	t["DeleteVffsVolumeState"] = reflect.TypeOf((*DeleteVffsVolumeState)(nil)).Elem()
}

// The parameters of `HostStorageSystem.DeleteVffsVolumeState`.
type DeleteVffsVolumeStateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The VFFS UUID.
	VffsUuid string `xml:"vffsUuid" json:"vffsUuid"`
}

func init() {
	t["DeleteVffsVolumeStateRequestType"] = reflect.TypeOf((*DeleteVffsVolumeStateRequestType)(nil)).Elem()
}

type DeleteVffsVolumeStateResponse struct {
}

// The parameters of `VirtualDiskManager.DeleteVirtualDisk_Task`.
type DeleteVirtualDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk to be deleted.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
}

func init() {
	t["DeleteVirtualDiskRequestType"] = reflect.TypeOf((*DeleteVirtualDiskRequestType)(nil)).Elem()
}

type DeleteVirtualDisk_Task DeleteVirtualDiskRequestType

func init() {
	t["DeleteVirtualDisk_Task"] = reflect.TypeOf((*DeleteVirtualDisk_Task)(nil)).Elem()
}

type DeleteVirtualDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type DeleteVmfsVolumeState DeleteVmfsVolumeStateRequestType

func init() {
	t["DeleteVmfsVolumeState"] = reflect.TypeOf((*DeleteVmfsVolumeState)(nil)).Elem()
}

// The parameters of `HostStorageSystem.DeleteVmfsVolumeState`.
type DeleteVmfsVolumeStateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The VMFS UUID.
	VmfsUuid string `xml:"vmfsUuid" json:"vmfsUuid"`
}

func init() {
	t["DeleteVmfsVolumeStateRequestType"] = reflect.TypeOf((*DeleteVmfsVolumeStateRequestType)(nil)).Elem()
}

type DeleteVmfsVolumeStateResponse struct {
}

type DeleteVsanObjects DeleteVsanObjectsRequestType

func init() {
	t["DeleteVsanObjects"] = reflect.TypeOf((*DeleteVsanObjects)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.DeleteVsanObjects`.
type DeleteVsanObjectsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of object UUIDs to be deleted.
	Uuids []string `xml:"uuids" json:"uuids"`
	// Optional force delete.
	Force *bool `xml:"force" json:"force,omitempty"`
}

func init() {
	t["DeleteVsanObjectsRequestType"] = reflect.TypeOf((*DeleteVsanObjectsRequestType)(nil)).Elem()
}

type DeleteVsanObjectsResponse struct {
	Returnval []HostVsanInternalSystemDeleteVsanObjectsResult `xml:"returnval" json:"returnval"`
}

// Thrown on an attempt to use an unsupported delta disk format.
type DeltaDiskFormatNotSupported struct {
	VmConfigFault

	// The datastores which do not support the specified format.
	//
	// Refers instances of `Datastore`.
	Datastore []ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty"`
	// The format not supported.
	//
	// See `DeltaDiskFormat`.
	DeltaDiskFormat string `xml:"deltaDiskFormat" json:"deltaDiskFormat"`
}

func init() {
	t["DeltaDiskFormatNotSupported"] = reflect.TypeOf((*DeltaDiskFormatNotSupported)(nil)).Elem()
}

type DeltaDiskFormatNotSupportedFault DeltaDiskFormatNotSupported

func init() {
	t["DeltaDiskFormatNotSupportedFault"] = reflect.TypeOf((*DeltaDiskFormatNotSupportedFault)(nil)).Elem()
}

// Static strings used for describing an object or property.
type Description struct {
	DynamicData

	// Display label.
	Label string `xml:"label" json:"label"`
	// Summary description.
	Summary string `xml:"summary" json:"summary"`
}

func init() {
	t["Description"] = reflect.TypeOf((*Description)(nil)).Elem()
}

type DeselectVnic DeselectVnicRequestType

func init() {
	t["DeselectVnic"] = reflect.TypeOf((*DeselectVnic)(nil)).Elem()
}

type DeselectVnicForNicType DeselectVnicForNicTypeRequestType

func init() {
	t["DeselectVnicForNicType"] = reflect.TypeOf((*DeselectVnicForNicType)(nil)).Elem()
}

// The parameters of `HostVirtualNicManager.DeselectVnicForNicType`.
type DeselectVnicForNicTypeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The type of VirtualNic that would be deselected
	NicType string `xml:"nicType" json:"nicType"`
	// The device that uniquely identifies the VirtualNic.
	Device string `xml:"device" json:"device"`
}

func init() {
	t["DeselectVnicForNicTypeRequestType"] = reflect.TypeOf((*DeselectVnicForNicTypeRequestType)(nil)).Elem()
}

type DeselectVnicForNicTypeResponse struct {
}

type DeselectVnicRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DeselectVnicRequestType"] = reflect.TypeOf((*DeselectVnicRequestType)(nil)).Elem()
}

type DeselectVnicResponse struct {
}

// Desired Software Spec is defined as combination of base-image and add-on
// component which user wants to install on ESX host or cluster.
type DesiredSoftwareSpec struct {
	DynamicData

	// Describes a specific base-image spec for the ESX host.
	BaseImageSpec DesiredSoftwareSpecBaseImageSpec `xml:"baseImageSpec" json:"baseImageSpec"`
	// Vendor add-on info for desired software spec.
	VendorAddOnSpec *DesiredSoftwareSpecVendorAddOnSpec `xml:"vendorAddOnSpec,omitempty" json:"vendorAddOnSpec,omitempty"`
	// Additional components which should be part of the desired software
	// spec.
	//
	// These components would override the components present in
	// `DesiredSoftwareSpec.vendorAddOnSpec` and `DesiredSoftwareSpec.baseImageSpec`.
	Components []DesiredSoftwareSpecComponentSpec `xml:"components,omitempty" json:"components,omitempty" vim:"7.0.2.0"`
	// Components which should not be part of the desired software
	// spec.
	//
	// These components are not applied on the host.
	RemovedComponents []string `xml:"removedComponents,omitempty" json:"removedComponents,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["DesiredSoftwareSpec"] = reflect.TypeOf((*DesiredSoftwareSpec)(nil)).Elem()
}

// Describes base-image spec for the ESX host.
type DesiredSoftwareSpecBaseImageSpec struct {
	DynamicData

	// Version of the base-image.
	Version string `xml:"version" json:"version"`
}

func init() {
	t["DesiredSoftwareSpecBaseImageSpec"] = reflect.TypeOf((*DesiredSoftwareSpecBaseImageSpec)(nil)).Elem()
}

// Component information for the ESX host.
type DesiredSoftwareSpecComponentSpec struct {
	DynamicData

	// Name of the component.
	Name string `xml:"name" json:"name"`
	// Version of the component.
	//
	// This field is required in the
	// current release.
	Version string `xml:"version,omitempty" json:"version,omitempty"`
}

func init() {
	t["DesiredSoftwareSpecComponentSpec"] = reflect.TypeOf((*DesiredSoftwareSpecComponentSpec)(nil)).Elem()
	minAPIVersionForType["DesiredSoftwareSpecComponentSpec"] = "7.0.2.0"
}

// Vendor specific add-on info for ESX host.
type DesiredSoftwareSpecVendorAddOnSpec struct {
	DynamicData

	// Vendor add-on name.
	Name string `xml:"name" json:"name"`
	// Vendor add-on version.
	Version string `xml:"version" json:"version"`
}

func init() {
	t["DesiredSoftwareSpecVendorAddOnSpec"] = reflect.TypeOf((*DesiredSoftwareSpecVendorAddOnSpec)(nil)).Elem()
}

// For one of the networks that the virtual machine is using, the corresponding
// switch on the host is full.
//
// If returned as part of migration checks, this is an error
// if either of the following is true, a warning otherwise:
//   - The virtual ethernet card device backing is a distributed virtual switch
//   - The virtual ethernet card device backing is a standard network and the
//     the device is connected
type DestinationSwitchFull struct {
	CannotAccessNetwork
}

func init() {
	t["DestinationSwitchFull"] = reflect.TypeOf((*DestinationSwitchFull)(nil)).Elem()
}

type DestinationSwitchFullFault DestinationSwitchFull

func init() {
	t["DestinationSwitchFullFault"] = reflect.TypeOf((*DestinationSwitchFullFault)(nil)).Elem()
}

// Fault thrown for the case that an attempt is made to move a host which
// is enabled for VSAN into a `ClusterComputeResource` which is
// disabled for VSAN.
//
// See also `CannotMoveVsanEnabledHost`.
type DestinationVsanDisabled struct {
	CannotMoveVsanEnabledHost

	// Name of the disabled destination `ClusterComputeResource`.
	//
	// See also `ManagedEntity.name`.
	DestinationCluster string `xml:"destinationCluster" json:"destinationCluster"`
}

func init() {
	t["DestinationVsanDisabled"] = reflect.TypeOf((*DestinationVsanDisabled)(nil)).Elem()
}

type DestinationVsanDisabledFault DestinationVsanDisabled

func init() {
	t["DestinationVsanDisabledFault"] = reflect.TypeOf((*DestinationVsanDisabledFault)(nil)).Elem()
}

type DestroyChildren DestroyChildrenRequestType

func init() {
	t["DestroyChildren"] = reflect.TypeOf((*DestroyChildren)(nil)).Elem()
}

type DestroyChildrenRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DestroyChildrenRequestType"] = reflect.TypeOf((*DestroyChildrenRequestType)(nil)).Elem()
}

type DestroyChildrenResponse struct {
}

type DestroyCollector DestroyCollectorRequestType

func init() {
	t["DestroyCollector"] = reflect.TypeOf((*DestroyCollector)(nil)).Elem()
}

type DestroyCollectorRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DestroyCollectorRequestType"] = reflect.TypeOf((*DestroyCollectorRequestType)(nil)).Elem()
}

type DestroyCollectorResponse struct {
}

type DestroyDatastore DestroyDatastoreRequestType

func init() {
	t["DestroyDatastore"] = reflect.TypeOf((*DestroyDatastore)(nil)).Elem()
}

type DestroyDatastoreRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DestroyDatastoreRequestType"] = reflect.TypeOf((*DestroyDatastoreRequestType)(nil)).Elem()
}

type DestroyDatastoreResponse struct {
}

type DestroyIpPool DestroyIpPoolRequestType

func init() {
	t["DestroyIpPool"] = reflect.TypeOf((*DestroyIpPool)(nil)).Elem()
}

// The parameters of `IpPoolManager.DestroyIpPool`.
type DestroyIpPoolRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datacenter on which to find the pool
	//
	// Required privileges: Datacenter.IpPoolConfig
	//
	// Refers instance of `Datacenter`.
	Dc ManagedObjectReference `xml:"dc" json:"dc"`
	// The unique ID of the pool
	Id int32 `xml:"id" json:"id"`
	// If true, the pool will be destroyed even if it is in use
	Force bool `xml:"force" json:"force"`
}

func init() {
	t["DestroyIpPoolRequestType"] = reflect.TypeOf((*DestroyIpPoolRequestType)(nil)).Elem()
}

type DestroyIpPoolResponse struct {
}

type DestroyNetwork DestroyNetworkRequestType

func init() {
	t["DestroyNetwork"] = reflect.TypeOf((*DestroyNetwork)(nil)).Elem()
}

type DestroyNetworkRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DestroyNetworkRequestType"] = reflect.TypeOf((*DestroyNetworkRequestType)(nil)).Elem()
}

type DestroyNetworkResponse struct {
}

type DestroyProfile DestroyProfileRequestType

func init() {
	t["DestroyProfile"] = reflect.TypeOf((*DestroyProfile)(nil)).Elem()
}

type DestroyProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DestroyProfileRequestType"] = reflect.TypeOf((*DestroyProfileRequestType)(nil)).Elem()
}

type DestroyProfileResponse struct {
}

type DestroyPropertyCollector DestroyPropertyCollectorRequestType

func init() {
	t["DestroyPropertyCollector"] = reflect.TypeOf((*DestroyPropertyCollector)(nil)).Elem()
}

type DestroyPropertyCollectorRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DestroyPropertyCollectorRequestType"] = reflect.TypeOf((*DestroyPropertyCollectorRequestType)(nil)).Elem()
}

type DestroyPropertyCollectorResponse struct {
}

type DestroyPropertyFilter DestroyPropertyFilterRequestType

func init() {
	t["DestroyPropertyFilter"] = reflect.TypeOf((*DestroyPropertyFilter)(nil)).Elem()
}

type DestroyPropertyFilterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DestroyPropertyFilterRequestType"] = reflect.TypeOf((*DestroyPropertyFilterRequestType)(nil)).Elem()
}

type DestroyPropertyFilterResponse struct {
}

type DestroyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DestroyRequestType"] = reflect.TypeOf((*DestroyRequestType)(nil)).Elem()
}

type DestroyVffs DestroyVffsRequestType

func init() {
	t["DestroyVffs"] = reflect.TypeOf((*DestroyVffs)(nil)).Elem()
}

// The parameters of `HostStorageSystem.DestroyVffs`.
type DestroyVffsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The path of the VFFS to destroy. See `FileSystemMountInfo`.
	VffsPath string `xml:"vffsPath" json:"vffsPath"`
}

func init() {
	t["DestroyVffsRequestType"] = reflect.TypeOf((*DestroyVffsRequestType)(nil)).Elem()
}

type DestroyVffsResponse struct {
}

type DestroyView DestroyViewRequestType

func init() {
	t["DestroyView"] = reflect.TypeOf((*DestroyView)(nil)).Elem()
}

type DestroyViewRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DestroyViewRequestType"] = reflect.TypeOf((*DestroyViewRequestType)(nil)).Elem()
}

type DestroyViewResponse struct {
}

type Destroy_Task DestroyRequestType

func init() {
	t["Destroy_Task"] = reflect.TypeOf((*Destroy_Task)(nil)).Elem()
}

type Destroy_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.DetachDisk_Task`.
type DetachDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual disk to be operated. See
	// `ID`
	DiskId ID `xml:"diskId" json:"diskId"`
}

func init() {
	t["DetachDiskRequestType"] = reflect.TypeOf((*DetachDiskRequestType)(nil)).Elem()
}

type DetachDisk_Task DetachDiskRequestType

func init() {
	t["DetachDisk_Task"] = reflect.TypeOf((*DetachDisk_Task)(nil)).Elem()
}

type DetachDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type DetachScsiLun DetachScsiLunRequestType

func init() {
	t["DetachScsiLun"] = reflect.TypeOf((*DetachScsiLun)(nil)).Elem()
}

// The parameters of `HostStorageSystem.DetachScsiLunEx_Task`.
type DetachScsiLunExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// each element specifies UUID of LUN to be detached.
	LunUuid []string `xml:"lunUuid" json:"lunUuid"`
}

func init() {
	t["DetachScsiLunExRequestType"] = reflect.TypeOf((*DetachScsiLunExRequestType)(nil)).Elem()
}

type DetachScsiLunEx_Task DetachScsiLunExRequestType

func init() {
	t["DetachScsiLunEx_Task"] = reflect.TypeOf((*DetachScsiLunEx_Task)(nil)).Elem()
}

type DetachScsiLunEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostStorageSystem.DetachScsiLun`.
type DetachScsiLunRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The uuid of the ScsiLun device to detach.
	LunUuid string `xml:"lunUuid" json:"lunUuid"`
}

func init() {
	t["DetachScsiLunRequestType"] = reflect.TypeOf((*DetachScsiLunRequestType)(nil)).Elem()
}

type DetachScsiLunResponse struct {
}

type DetachTagFromVStorageObject DetachTagFromVStorageObjectRequestType

func init() {
	t["DetachTagFromVStorageObject"] = reflect.TypeOf((*DetachTagFromVStorageObject)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.DetachTagFromVStorageObject`.
type DetachTagFromVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The identifier(ID) of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The category to which the tag belongs.
	Category string `xml:"category" json:"category"`
	// The tag which has to be disassociated with the virtual storage
	// object.
	Tag string `xml:"tag" json:"tag"`
}

func init() {
	t["DetachTagFromVStorageObjectRequestType"] = reflect.TypeOf((*DetachTagFromVStorageObjectRequestType)(nil)).Elem()
}

type DetachTagFromVStorageObjectResponse struct {
}

// Specification used to create a host device backed virtual disk
type DeviceBackedVirtualDiskSpec struct {
	VirtualDiskSpec

	// The deviceName of the backing device
	//
	// See also `ScsiLun`.
	Device string `xml:"device" json:"device"`
}

func init() {
	t["DeviceBackedVirtualDiskSpec"] = reflect.TypeOf((*DeviceBackedVirtualDiskSpec)(nil)).Elem()
}

// The device is backed by a backing type which is not supported
// for this particular device.
//
// If this fault is returned as a subfault of
// DisallowedMigrationDeviceAttached, this indicates that although
// this backing for the device may be supported on the destination
// host, the hosts do not support the requested migration of the
// virtual machine while using this device with this backing.
type DeviceBackingNotSupported struct {
	DeviceNotSupported

	// The type of the backing.
	Backing string `xml:"backing" json:"backing"`
}

func init() {
	t["DeviceBackingNotSupported"] = reflect.TypeOf((*DeviceBackingNotSupported)(nil)).Elem()
}

type DeviceBackingNotSupportedFault BaseDeviceBackingNotSupported

func init() {
	t["DeviceBackingNotSupportedFault"] = reflect.TypeOf((*DeviceBackingNotSupportedFault)(nil)).Elem()
}

// The device in question is supported, but the device-controller
// combination is not supported.
//
// If this fault is returned as a subfault of
// DisallowedMigrationDeviceAttached, this indicates that although
// this device-controller combination may be supported on the
// destination host, the hosts do not support the requested migration
// of the virtual machine while using this device and controller.
type DeviceControllerNotSupported struct {
	DeviceNotSupported

	// The type of the controller.
	Controller string `xml:"controller" json:"controller"`
}

func init() {
	t["DeviceControllerNotSupported"] = reflect.TypeOf((*DeviceControllerNotSupported)(nil)).Elem()
}

type DeviceControllerNotSupportedFault DeviceControllerNotSupported

func init() {
	t["DeviceControllerNotSupportedFault"] = reflect.TypeOf((*DeviceControllerNotSupportedFault)(nil)).Elem()
}

// Identifier of a replication device group.
type DeviceGroupId struct {
	DynamicData

	// ID of the device group.
	Id string `xml:"id" json:"id"`
}

func init() {
	t["DeviceGroupId"] = reflect.TypeOf((*DeviceGroupId)(nil)).Elem()
}

// A DeviceHotPlugNotSupported exception is thrown if the specified device
// cannot be hot-added or hot-removed from the virtual machine
// at this time.
type DeviceHotPlugNotSupported struct {
	InvalidDeviceSpec
}

func init() {
	t["DeviceHotPlugNotSupported"] = reflect.TypeOf((*DeviceHotPlugNotSupported)(nil)).Elem()
}

type DeviceHotPlugNotSupportedFault DeviceHotPlugNotSupported

func init() {
	t["DeviceHotPlugNotSupportedFault"] = reflect.TypeOf((*DeviceHotPlugNotSupportedFault)(nil)).Elem()
}

// A DeviceNotFound exception is thrown if
// a device to be edited or removed
// cannot be found.
//
// Most likely, the client incorrectly passed
// the device key.
type DeviceNotFound struct {
	InvalidDeviceSpec
}

func init() {
	t["DeviceNotFound"] = reflect.TypeOf((*DeviceNotFound)(nil)).Elem()
}

type DeviceNotFoundFault DeviceNotFound

func init() {
	t["DeviceNotFoundFault"] = reflect.TypeOf((*DeviceNotFoundFault)(nil)).Elem()
}

// The virtual machine uses a device type that is not supported on the
// host.
//
// If this fault is returned as a subfault of
// `DisallowedMigrationDeviceAttached`, this indicates that although
// this device may be supported on the destination host, the hosts do
// not support the requested migration of the virtual machine while
// using this device.
type DeviceNotSupported struct {
	VirtualHardwareCompatibilityIssue

	// The label of the device.
	Device string `xml:"device" json:"device"`
	// The specific reason why the device is not supported.
	//
	// Values should come from `DeviceNotSupportedReason_enum`.
	// This might not be set if we're not sure of the reason, or
	// if this doesn't make sense in the context. For example,
	// in the `DisallowedMigrationDeviceAttached` context
	// we already know the problem.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["DeviceNotSupported"] = reflect.TypeOf((*DeviceNotSupported)(nil)).Elem()
}

type DeviceNotSupportedFault BaseDeviceNotSupported

func init() {
	t["DeviceNotSupportedFault"] = reflect.TypeOf((*DeviceNotSupportedFault)(nil)).Elem()
}

// A DeviceUnsupportedForVmPlatform exception is thrown if the specified device
// is not supported on the platform on which the virtual machine is being
// created/configured.
//
// For example, this exception might be thrown if a client
// incorrectly attempts to add a device supported only on ESX Server to a
// virtual machine on a hosted product.
type DeviceUnsupportedForVmPlatform struct {
	InvalidDeviceSpec
}

func init() {
	t["DeviceUnsupportedForVmPlatform"] = reflect.TypeOf((*DeviceUnsupportedForVmPlatform)(nil)).Elem()
}

type DeviceUnsupportedForVmPlatformFault DeviceUnsupportedForVmPlatform

func init() {
	t["DeviceUnsupportedForVmPlatformFault"] = reflect.TypeOf((*DeviceUnsupportedForVmPlatformFault)(nil)).Elem()
}

// A DeviceUnsupportedForVmVersion exception is thrown if a specific device
// is not supported for a given version of the virtual machine.
type DeviceUnsupportedForVmVersion struct {
	InvalidDeviceSpec

	// The current version of the virtual machine.
	CurrentVersion string `xml:"currentVersion" json:"currentVersion"`
	// The minimum expected virtual mahcine version needed to
	// support this device.
	ExpectedVersion string `xml:"expectedVersion" json:"expectedVersion"`
}

func init() {
	t["DeviceUnsupportedForVmVersion"] = reflect.TypeOf((*DeviceUnsupportedForVmVersion)(nil)).Elem()
}

type DeviceUnsupportedForVmVersionFault DeviceUnsupportedForVmVersion

func init() {
	t["DeviceUnsupportedForVmVersionFault"] = reflect.TypeOf((*DeviceUnsupportedForVmVersionFault)(nil)).Elem()
}

type DiagnosticManagerAuditRecordResult struct {
	DynamicData

	// Zero or more audit records returned.
	//
	// Each audit record is a UTF-8 string in RFC 5424 format. See RFC 5424,
	// page 8, for the ABNF grammar.
	//
	// The HOSTNAME and MSGID fields are set to "-", the structured data
	// contains the audit record parameters, no unstructured data will be
	// present, and each record is terminated with an ASCII LF (newline).
	Records []string `xml:"records,omitempty" json:"records,omitempty"`
	// The token to be used for subsequent read operations.
	//
	// The string is "opaque"; the format of this data changes over time.
	NextToken string `xml:"nextToken" json:"nextToken"`
}

func init() {
	t["DiagnosticManagerAuditRecordResult"] = reflect.TypeOf((*DiagnosticManagerAuditRecordResult)(nil)).Elem()
	minAPIVersionForType["DiagnosticManagerAuditRecordResult"] = "7.0.3.0"
}

// Describes a location of a diagnostic bundle and the server to which
// it belongs.
//
// This is a return type for the generateLogBundles operation.
type DiagnosticManagerBundleInfo struct {
	DynamicData

	// The host to which this diagnostic bundle belongs.
	//
	// If this is for the default server, then it is not set.
	//
	// Refers instance of `HostSystem`.
	System *ManagedObjectReference `xml:"system,omitempty" json:"system,omitempty"`
	// The location from which the diagnostic bundle can be downloaded.
	//
	// The host part of the URL is returned as '\*' if the hostname to be used
	// is the name of the server to which the call was made. For example, if
	// the call is made to vcsrv1.domain1.com, and the bundle is available
	// for download from http://vcsrv1.domain1.com/diagnostics/bundle.zip,
	// the URL returned may be http:// \* /diagnostics/bundle.zip. The client
	// replaces the asterisk with the server name on which it invoked the
	// call.
	Url string `xml:"url" json:"url"`
}

func init() {
	t["DiagnosticManagerBundleInfo"] = reflect.TypeOf((*DiagnosticManagerBundleInfo)(nil)).Elem()
}

// Describes a log file that is available on a server.
type DiagnosticManagerLogDescriptor struct {
	DynamicData

	// A key to identify the log file for browsing and download operations.
	Key string `xml:"key" json:"key"`
	// The filename of the log.
	FileName string `xml:"fileName" json:"fileName"`
	// The application that generated the log file.
	//
	// For more information on currently supported creators, see
	// `DiagnosticManagerLogCreator_enum`.
	Creator string `xml:"creator" json:"creator"`
	// Describes the format of the log file.
	//
	// For more information on currently supported formats, see
	// `DiagnosticManagerLogFormat_enum`.
	Format string `xml:"format" json:"format"`
	// Describes the mime-type of the returned file.
	//
	// Typical
	// mime-types include:
	//   - text/plain - for a plain log file
	MimeType string `xml:"mimeType" json:"mimeType"`
	// Localized description of log file.
	Info BaseDescription `xml:"info,typeattr" json:"info"`
}

func init() {
	t["DiagnosticManagerLogDescriptor"] = reflect.TypeOf((*DiagnosticManagerLogDescriptor)(nil)).Elem()
}

// A header that is returned with a set of log entries.
//
// This header describes where entries are located in the log file. Log
// files typically grow dynamically, so indexes based on line numbers may
// become inaccurate.
type DiagnosticManagerLogHeader struct {
	DynamicData

	// The first line of this log segment.
	LineStart int32 `xml:"lineStart" json:"lineStart"`
	// The last line of this log segment.
	LineEnd int32 `xml:"lineEnd" json:"lineEnd"`
	// Log entries, listed by line, for this log segment.
	LineText []string `xml:"lineText,omitempty" json:"lineText,omitempty"`
}

func init() {
	t["DiagnosticManagerLogHeader"] = reflect.TypeOf((*DiagnosticManagerLogHeader)(nil)).Elem()
}

// The digest file of the specified virtual disk is not supported.
//
// Typically, this fault is returned as part of a parent fault like
// `VmConfigIncompatibleForFaultTolerance`, indicating that the
// virtual disk's digest file needs to be changed before fault tolerance can be
// enabled on the associated virtual machine.
type DigestNotSupported struct {
	DeviceNotSupported
}

func init() {
	t["DigestNotSupported"] = reflect.TypeOf((*DigestNotSupported)(nil)).Elem()
}

type DigestNotSupportedFault DigestNotSupported

func init() {
	t["DigestNotSupportedFault"] = reflect.TypeOf((*DigestNotSupportedFault)(nil)).Elem()
}

// This fault is thrown when an operation fails because the specified
// directory is not empty.
type DirectoryNotEmpty struct {
	FileFault
}

func init() {
	t["DirectoryNotEmpty"] = reflect.TypeOf((*DirectoryNotEmpty)(nil)).Elem()
}

type DirectoryNotEmptyFault DirectoryNotEmpty

func init() {
	t["DirectoryNotEmptyFault"] = reflect.TypeOf((*DirectoryNotEmptyFault)(nil)).Elem()
}

// Fault thrown when an attempt is made to move a disk with associated snapshots to a destination host.
//
// If such a move were to occur, snapshots associated with the disk would be irrevocably
// lost. This is always an error.
type DisableAdminNotSupported struct {
	HostConfigFault
}

func init() {
	t["DisableAdminNotSupported"] = reflect.TypeOf((*DisableAdminNotSupported)(nil)).Elem()
}

type DisableAdminNotSupportedFault DisableAdminNotSupported

func init() {
	t["DisableAdminNotSupportedFault"] = reflect.TypeOf((*DisableAdminNotSupportedFault)(nil)).Elem()
}

type DisableAlarm DisableAlarmRequestType

func init() {
	t["DisableAlarm"] = reflect.TypeOf((*DisableAlarm)(nil)).Elem()
}

// The parameters of `AlarmManager.DisableAlarm`.
type DisableAlarmRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The Alarm being disabled.
	//
	// Required privileges: Alarm.ToggleEnableOnEntity
	//
	// Refers instance of `Alarm`.
	Alarm ManagedObjectReference `xml:"alarm" json:"alarm"`
	// The ManagedEntity on which to disable the alarm.
	//
	// Required privileges: System.Read
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["DisableAlarmRequestType"] = reflect.TypeOf((*DisableAlarmRequestType)(nil)).Elem()
}

type DisableAlarmResponse struct {
}

type DisableClusteredVmdkSupport DisableClusteredVmdkSupportRequestType

func init() {
	t["DisableClusteredVmdkSupport"] = reflect.TypeOf((*DisableClusteredVmdkSupport)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.DisableClusteredVmdkSupport`.
type DisableClusteredVmdkSupportRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Datastore on which clustered vmdk should be
	// disabled.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["DisableClusteredVmdkSupportRequestType"] = reflect.TypeOf((*DisableClusteredVmdkSupportRequestType)(nil)).Elem()
}

type DisableClusteredVmdkSupportResponse struct {
}

type DisableEvcModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DisableEvcModeRequestType"] = reflect.TypeOf((*DisableEvcModeRequestType)(nil)).Elem()
}

type DisableEvcMode_Task DisableEvcModeRequestType

func init() {
	t["DisableEvcMode_Task"] = reflect.TypeOf((*DisableEvcMode_Task)(nil)).Elem()
}

type DisableEvcMode_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type DisableFeature DisableFeatureRequestType

func init() {
	t["DisableFeature"] = reflect.TypeOf((*DisableFeature)(nil)).Elem()
}

// The parameters of `LicenseManager.DisableFeature`.
type DisableFeatureRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Host to act on if LicenseManager is not on a host.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// key of the feature to disable.
	FeatureKey string `xml:"featureKey" json:"featureKey"`
}

func init() {
	t["DisableFeatureRequestType"] = reflect.TypeOf((*DisableFeatureRequestType)(nil)).Elem()
}

type DisableFeatureResponse struct {
	Returnval bool `xml:"returnval" json:"returnval"`
}

type DisableHyperThreading DisableHyperThreadingRequestType

func init() {
	t["DisableHyperThreading"] = reflect.TypeOf((*DisableHyperThreading)(nil)).Elem()
}

type DisableHyperThreadingRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DisableHyperThreadingRequestType"] = reflect.TypeOf((*DisableHyperThreadingRequestType)(nil)).Elem()
}

type DisableHyperThreadingResponse struct {
}

type DisableMultipathPath DisableMultipathPathRequestType

func init() {
	t["DisableMultipathPath"] = reflect.TypeOf((*DisableMultipathPath)(nil)).Elem()
}

// The parameters of `HostStorageSystem.DisableMultipathPath`.
type DisableMultipathPathRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the path to disable.
	PathName string `xml:"pathName" json:"pathName"`
}

func init() {
	t["DisableMultipathPathRequestType"] = reflect.TypeOf((*DisableMultipathPathRequestType)(nil)).Elem()
}

type DisableMultipathPathResponse struct {
}

type DisableRuleset DisableRulesetRequestType

func init() {
	t["DisableRuleset"] = reflect.TypeOf((*DisableRuleset)(nil)).Elem()
}

// The parameters of `HostFirewallSystem.DisableRuleset`.
type DisableRulesetRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Id   string                 `xml:"id" json:"id"`
}

func init() {
	t["DisableRulesetRequestType"] = reflect.TypeOf((*DisableRulesetRequestType)(nil)).Elem()
}

type DisableRulesetResponse struct {
}

// The parameters of `VirtualMachine.DisableSecondaryVM_Task`.
type DisableSecondaryVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The secondary virtual machine specified will be disabed.
	// This field must specify a secondary virtual machine that is part of the fault
	// tolerant group that this virtual machine is currently associated with. It can
	// only be invoked from the primary virtual machine in the group.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
}

func init() {
	t["DisableSecondaryVMRequestType"] = reflect.TypeOf((*DisableSecondaryVMRequestType)(nil)).Elem()
}

type DisableSecondaryVM_Task DisableSecondaryVMRequestType

func init() {
	t["DisableSecondaryVM_Task"] = reflect.TypeOf((*DisableSecondaryVM_Task)(nil)).Elem()
}

type DisableSecondaryVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type DisableSmartCardAuthentication DisableSmartCardAuthenticationRequestType

func init() {
	t["DisableSmartCardAuthentication"] = reflect.TypeOf((*DisableSmartCardAuthentication)(nil)).Elem()
}

type DisableSmartCardAuthenticationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DisableSmartCardAuthenticationRequestType"] = reflect.TypeOf((*DisableSmartCardAuthenticationRequestType)(nil)).Elem()
}

type DisableSmartCardAuthenticationResponse struct {
}

// Fault thrown if the disallowed operation is invoked by the client.
//
// The
// change is disallowed because it conflicts with target state maintained
// by a service. The corresponding method is usually not disabled because
// only a subset of changes carried out by the method is disallowed. For
// example, an online extend executed via virtual machine reconfigure
// method is not allowed if replication is enabled on a virtual machine.
type DisallowedChangeByService struct {
	RuntimeFault

	// The service that has disallowed the change.
	ServiceName string `xml:"serviceName" json:"serviceName"`
	// The change this is not allowed, the set of possible values is
	// described in `DisallowedChangeByServiceDisallowedChange_enum`.
	DisallowedChange string `xml:"disallowedChange,omitempty" json:"disallowedChange,omitempty"`
}

func init() {
	t["DisallowedChangeByService"] = reflect.TypeOf((*DisallowedChangeByService)(nil)).Elem()
}

type DisallowedChangeByServiceFault DisallowedChangeByService

func init() {
	t["DisallowedChangeByServiceFault"] = reflect.TypeOf((*DisallowedChangeByServiceFault)(nil)).Elem()
}

// Thrown when the `VirtualMachine.ReconfigVM_Task` operation
// includes a change to the `VirtualDiskMode_enum`
// property.
//
// This property cannot be changed as long as a virtual machine
// has an existing snapshot.
type DisallowedDiskModeChange struct {
	InvalidDeviceSpec
}

func init() {
	t["DisallowedDiskModeChange"] = reflect.TypeOf((*DisallowedDiskModeChange)(nil)).Elem()
}

type DisallowedDiskModeChangeFault DisallowedDiskModeChange

func init() {
	t["DisallowedDiskModeChangeFault"] = reflect.TypeOf((*DisallowedDiskModeChangeFault)(nil)).Elem()
}

// The virtual machine is using a type of device that prevents migration.
type DisallowedMigrationDeviceAttached struct {
	MigrationFault

	// A fault specifies the particular device issue.
	//
	// This is typically
	// a subclass of VirtualHardwareCompatibilityIssue, such as
	// RawDiskNotSupported, RemoteDeviceNotSupported, or SharedBusControllerNotSupported
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["DisallowedMigrationDeviceAttached"] = reflect.TypeOf((*DisallowedMigrationDeviceAttached)(nil)).Elem()
}

type DisallowedMigrationDeviceAttachedFault DisallowedMigrationDeviceAttached

func init() {
	t["DisallowedMigrationDeviceAttachedFault"] = reflect.TypeOf((*DisallowedMigrationDeviceAttachedFault)(nil)).Elem()
}

// Fault thrown when an attempt is made to perform a disallowed operation on a
// host that has been configured as a failover host in an cluster that has High
// Availability enabled.
//
// See `ClusterFailoverHostAdmissionControlPolicy`.
// Examples of such operations are destroying a host, moving a host out of a cluster,
// or powering on a virtual machine on a specific host.
type DisallowedOperationOnFailoverHost struct {
	RuntimeFault

	// The failover host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Name of the failover host.
	Hostname string `xml:"hostname" json:"hostname"`
}

func init() {
	t["DisallowedOperationOnFailoverHost"] = reflect.TypeOf((*DisallowedOperationOnFailoverHost)(nil)).Elem()
}

type DisallowedOperationOnFailoverHostFault DisallowedOperationOnFailoverHost

func init() {
	t["DisallowedOperationOnFailoverHostFault"] = reflect.TypeOf((*DisallowedOperationOnFailoverHostFault)(nil)).Elem()
}

type DisconnectHostRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DisconnectHostRequestType"] = reflect.TypeOf((*DisconnectHostRequestType)(nil)).Elem()
}

type DisconnectHost_Task DisconnectHostRequestType

func init() {
	t["DisconnectHost_Task"] = reflect.TypeOf((*DisconnectHost_Task)(nil)).Elem()
}

type DisconnectHost_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type DisconnectNvmeController DisconnectNvmeControllerRequestType

func init() {
	t["DisconnectNvmeController"] = reflect.TypeOf((*DisconnectNvmeController)(nil)).Elem()
}

// The parameters of `HostStorageSystem.DisconnectNvmeControllerEx_Task`.
type DisconnectNvmeControllerExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A list of data objects, each specifying the parameters
	// necessary to disconnect an NVMe controller.
	DisconnectSpec []HostNvmeDisconnectSpec `xml:"disconnectSpec,omitempty" json:"disconnectSpec,omitempty"`
}

func init() {
	t["DisconnectNvmeControllerExRequestType"] = reflect.TypeOf((*DisconnectNvmeControllerExRequestType)(nil)).Elem()
	minAPIVersionForType["DisconnectNvmeControllerExRequestType"] = "7.0.3.0"
}

type DisconnectNvmeControllerEx_Task DisconnectNvmeControllerExRequestType

func init() {
	t["DisconnectNvmeControllerEx_Task"] = reflect.TypeOf((*DisconnectNvmeControllerEx_Task)(nil)).Elem()
}

type DisconnectNvmeControllerEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostStorageSystem.DisconnectNvmeController`.
type DisconnectNvmeControllerRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A data object that specifies the parameters
	// necessary to perform the disconnection.
	DisconnectSpec HostNvmeDisconnectSpec `xml:"disconnectSpec" json:"disconnectSpec"`
}

func init() {
	t["DisconnectNvmeControllerRequestType"] = reflect.TypeOf((*DisconnectNvmeControllerRequestType)(nil)).Elem()
}

type DisconnectNvmeControllerResponse struct {
}

// An attempt to enable Enhanced VMotion Compatibility on a cluster, or to
// select a less-featureful EVC mode for a cluster where EVC is already enabled,
// has failed because the cluster contains one or more disconnected hosts.
type DisconnectedHostsBlockingEVC struct {
	EVCConfigFault
}

func init() {
	t["DisconnectedHostsBlockingEVC"] = reflect.TypeOf((*DisconnectedHostsBlockingEVC)(nil)).Elem()
}

type DisconnectedHostsBlockingEVCFault DisconnectedHostsBlockingEVC

func init() {
	t["DisconnectedHostsBlockingEVCFault"] = reflect.TypeOf((*DisconnectedHostsBlockingEVCFault)(nil)).Elem()
}

type DiscoverFcoeHbas DiscoverFcoeHbasRequestType

func init() {
	t["DiscoverFcoeHbas"] = reflect.TypeOf((*DiscoverFcoeHbas)(nil)).Elem()
}

// The parameters of `HostStorageSystem.DiscoverFcoeHbas`.
type DiscoverFcoeHbasRequestType struct {
	This     ManagedObjectReference      `xml:"_this" json:"-"`
	FcoeSpec FcoeConfigFcoeSpecification `xml:"fcoeSpec" json:"fcoeSpec"`
}

func init() {
	t["DiscoverFcoeHbasRequestType"] = reflect.TypeOf((*DiscoverFcoeHbasRequestType)(nil)).Elem()
}

type DiscoverFcoeHbasResponse struct {
}

type DiscoverNvmeControllers DiscoverNvmeControllersRequestType

func init() {
	t["DiscoverNvmeControllers"] = reflect.TypeOf((*DiscoverNvmeControllers)(nil)).Elem()
}

// The parameters of `HostStorageSystem.DiscoverNvmeControllers`.
type DiscoverNvmeControllersRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A data object that specifies the parameters
	// necessary to retrieve the Discovery Log.
	DiscoverSpec HostNvmeDiscoverSpec `xml:"discoverSpec" json:"discoverSpec"`
}

func init() {
	t["DiscoverNvmeControllersRequestType"] = reflect.TypeOf((*DiscoverNvmeControllersRequestType)(nil)).Elem()
}

type DiscoverNvmeControllersResponse struct {
	Returnval HostNvmeDiscoveryLog `xml:"returnval" json:"returnval"`
}

// An area of the disk flagged as modified
type DiskChangeExtent struct {
	DynamicData

	// Start offset (in bytes) of modified area
	Start int64 `xml:"start" json:"start"`
	// Length (in bytes) of modified area
	Length int64 `xml:"length" json:"length"`
}

func init() {
	t["DiskChangeExtent"] = reflect.TypeOf((*DiskChangeExtent)(nil)).Elem()
}

// Data structure to describe areas in a disk associated with this VM that have
// been modified since a well-defined point in the past.
//
// Returned by
// `VirtualMachine.QueryChangedDiskAreas`. This data structure describes
// a subset of the disk identified by startOffset and length. All areas that
// have been modified within this interval are listed under changedArea.
type DiskChangeInfo struct {
	DynamicData

	// Start offset (in bytes) of disk area described by this data structure.
	StartOffset int64 `xml:"startOffset" json:"startOffset"`
	// Length (in bytes) of disk area described by this data structure.
	Length int64 `xml:"length" json:"length"`
	// Modified disk areas.
	//
	// Might be empty if no parts of the disk between
	// startOffset and startOffset + length were modified.
	ChangedArea []DiskChangeExtent `xml:"changedArea,omitempty" json:"changedArea,omitempty"`
}

func init() {
	t["DiskChangeInfo"] = reflect.TypeOf((*DiskChangeInfo)(nil)).Elem()
}

// This data object type contains the crypto information of all disks along
// the chain
type DiskCryptoSpec struct {
	DynamicData

	// The parent in the chain.
	Parent *DiskCryptoSpec `xml:"parent,omitempty" json:"parent,omitempty"`
	// Crypto information of the current disk.
	Crypto BaseCryptoSpec `xml:"crypto,typeattr" json:"crypto"`
}

func init() {
	t["DiskCryptoSpec"] = reflect.TypeOf((*DiskCryptoSpec)(nil)).Elem()
}

// Fault used for disks which have existing, non-VSAN partitions.
//
// See also `HostStorageSystem.UpdateDiskPartitions`, `HostVsanSystem.QueryDisksForVsan`.
type DiskHasPartitions struct {
	VsanDiskFault
}

func init() {
	t["DiskHasPartitions"] = reflect.TypeOf((*DiskHasPartitions)(nil)).Elem()
}

type DiskHasPartitionsFault DiskHasPartitions

func init() {
	t["DiskHasPartitionsFault"] = reflect.TypeOf((*DiskHasPartitionsFault)(nil)).Elem()
}

// Fault thrown for the case that an attempt is made to delete the last
// `VsanHostDiskMapping.nonSsd` from a `VsanHostDiskMapping`.
//
// See also `HostVsanSystem.RemoveDisk_Task`, `HostVsanSystem.RemoveDiskMapping_Task`.
type DiskIsLastRemainingNonSSD struct {
	VsanDiskFault
}

func init() {
	t["DiskIsLastRemainingNonSSD"] = reflect.TypeOf((*DiskIsLastRemainingNonSSD)(nil)).Elem()
}

type DiskIsLastRemainingNonSSDFault DiskIsLastRemainingNonSSD

func init() {
	t["DiskIsLastRemainingNonSSDFault"] = reflect.TypeOf((*DiskIsLastRemainingNonSSDFault)(nil)).Elem()
}

// Fault used for disks which are ineligible for VSAN because they are
// considered non-local.
//
// See also `HostVsanSystem.QueryDisksForVsan`.
type DiskIsNonLocal struct {
	VsanDiskFault
}

func init() {
	t["DiskIsNonLocal"] = reflect.TypeOf((*DiskIsNonLocal)(nil)).Elem()
}

type DiskIsNonLocalFault DiskIsNonLocal

func init() {
	t["DiskIsNonLocalFault"] = reflect.TypeOf((*DiskIsNonLocalFault)(nil)).Elem()
}

// Fault used for disks which are ineligible for VSAN because they are USB
// disks.
//
// See also `HostVsanSystem.QueryDisksForVsan`.
type DiskIsUSB struct {
	VsanDiskFault
}

func init() {
	t["DiskIsUSB"] = reflect.TypeOf((*DiskIsUSB)(nil)).Elem()
}

type DiskIsUSBFault DiskIsUSB

func init() {
	t["DiskIsUSBFault"] = reflect.TypeOf((*DiskIsUSBFault)(nil)).Elem()
}

// Specifying non-standard disk movement types is not supported.
//
// See also `VirtualMachineRelocateSpec.diskMoveType`, `VirtualMachineRelocateSpecDiskLocator.diskMoveType`.
type DiskMoveTypeNotSupported struct {
	MigrationFault
}

func init() {
	t["DiskMoveTypeNotSupported"] = reflect.TypeOf((*DiskMoveTypeNotSupported)(nil)).Elem()
}

type DiskMoveTypeNotSupportedFault DiskMoveTypeNotSupported

func init() {
	t["DiskMoveTypeNotSupportedFault"] = reflect.TypeOf((*DiskMoveTypeNotSupportedFault)(nil)).Elem()
}

// The host does not support the backings for the disks specified by the virtual
// machine.
//
// For example, this fault is thrown if a virtual machine is created from
// a template that specifies backings that the host does not have. Similarly, this fault
// is thrown if a virtual machine is registered on a host that does not support the
// specified backings.
type DiskNotSupported struct {
	VirtualHardwareCompatibilityIssue

	// The ID of disk that is not supported.
	Disk int32 `xml:"disk" json:"disk"`
}

func init() {
	t["DiskNotSupported"] = reflect.TypeOf((*DiskNotSupported)(nil)).Elem()
}

type DiskNotSupportedFault BaseDiskNotSupported

func init() {
	t["DiskNotSupportedFault"] = reflect.TypeOf((*DiskNotSupportedFault)(nil)).Elem()
}

// Fault used for disks which are too small for usage by VSAN.
type DiskTooSmall struct {
	VsanDiskFault
}

func init() {
	t["DiskTooSmall"] = reflect.TypeOf((*DiskTooSmall)(nil)).Elem()
}

type DiskTooSmallFault DiskTooSmall

func init() {
	t["DiskTooSmallFault"] = reflect.TypeOf((*DiskTooSmallFault)(nil)).Elem()
}

type DissociateProfile DissociateProfileRequestType

func init() {
	t["DissociateProfile"] = reflect.TypeOf((*DissociateProfile)(nil)).Elem()
}

// The parameters of `Profile.DissociateProfile`.
type DissociateProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of entities. The vCenter Server will remove the associations
	// that the profile has with the entities in the list. If unset,
	// the Server removes all the associations that the profile has with any
	// managed entities in the inventory.
	// If the specified entity is not associated with the profile,
	// the Server does not perform any action.
	//
	// Refers instances of `ManagedEntity`.
	Entity []ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["DissociateProfileRequestType"] = reflect.TypeOf((*DissociateProfileRequestType)(nil)).Elem()
}

type DissociateProfileResponse struct {
}

// The `DistributedVirtualPort` data object represents a port in a
// `DistributedVirtualSwitch`.
//
// Virtual ports are part of a distributed
// virtual portgroup. Servers create virtual ports according to the portgroup type
// (`DistributedVirtualPortgroup*.*DistributedVirtualPortgroup.config*.*DVPortgroupConfigInfo.type`).
// See `DistributedVirtualPortgroupPortgroupType_enum`.
//   - To configure host network access by port, set the distributed virtual port
//     in the host virtual NIC specification
//     (`HostVirtualNicSpec*.*HostVirtualNicSpec.distributedVirtualPort*.*DistributedVirtualSwitchPortConnection.portKey`).
//   - To configure virtual machine network access by port, set the port
//     in the virtual Ethernet card backing
//     (`VirtualEthernetCard*.*VirtualDevice.backing*.*VirtualEthernetCardDistributedVirtualPortBackingInfo.port*.*DistributedVirtualSwitchPortConnection.portKey`).
type DistributedVirtualPort struct {
	DynamicData

	// Port key.
	Key string `xml:"key" json:"key"`
	// Port configuration, including identifying information, network
	// settings, and the set of entities that can connect to the port.
	Config DVPortConfigInfo `xml:"config" json:"config"`
	// UUID of the `DistributedVirtualSwitch` to which the port belongs.
	DvsUuid string `xml:"dvsUuid" json:"dvsUuid"`
	// Key of the portgroup `DistributedVirtualPortgroup` to which
	// the port belongs, if any.
	PortgroupKey string `xml:"portgroupKey,omitempty" json:"portgroupKey,omitempty"`
	// `HostSystem` that services this port.
	//
	// Refers instance of `HostSystem`.
	ProxyHost *ManagedObjectReference `xml:"proxyHost,omitempty" json:"proxyHost,omitempty"`
	// Entity that connects to the port.
	Connectee *DistributedVirtualSwitchPortConnectee `xml:"connectee,omitempty" json:"connectee,omitempty"`
	// Specifies whether the port is a conflict port.
	//
	// A port could be marked
	// as conflict if an entity is discovered connecting to a port that is
	// already occupied, or if the host creates a port without conferring
	// with vCenter Server.
	//
	// The distributed virtual switch does not persist the runtime state
	// of a conflict port. Also, the port cannot move away from the host.
	// vCenter Server will not move a virtual machine (VMotion) that is
	// using a conflict port.
	Conflict bool `xml:"conflict" json:"conflict"`
	// If the port is marked conflict in the case of two entities connecting to
	// the same port (see
	// `DistributedVirtualPort.conflict`), this is the
	// key of the port which the connected entity is contending for.
	ConflictPortKey string `xml:"conflictPortKey,omitempty" json:"conflictPortKey,omitempty"`
	// Runtime state of the port.
	State *DVPortState `xml:"state,omitempty" json:"state,omitempty"`
	// Cookie representing the current instance of association between a
	// port and a virtual or physical NIC.
	//
	// See `DistributedVirtualSwitchPortConnection`.
	// The same cookie is present in the physical or virtual NIC configuration
	// (`DistributedVirtualSwitchPortConnection*.*DistributedVirtualSwitchPortConnection.connectionCookie`)
	// so that the Server can verify that the entity is the rightful
	// connectee of the port.
	ConnectionCookie int32 `xml:"connectionCookie,omitempty" json:"connectionCookie,omitempty"`
	// The last time the
	// `DistributedVirtualPort.state*.*DVPortState.runtimeInfo`
	// value was changed.
	LastStatusChange time.Time `xml:"lastStatusChange" json:"lastStatusChange"`
	// Specifies whether the port is a host local port.
	//
	// A host local port is created
	// to resurrect the management network connection on a VMkernel virtual NIC.
	// You cannot use vCenter Server to reconfigure this port and you cannot
	// reassign the port.
	HostLocalPort *bool `xml:"hostLocalPort" json:"hostLocalPort,omitempty"`
	// Populate the Id assigned to vmknic or vnic by external management plane
	// to port, if the port is connected to the nics.
	ExternalId string `xml:"externalId,omitempty" json:"externalId,omitempty"`
	// Populate the segmentPortId assigned to LSP.
	SegmentPortId string `xml:"segmentPortId,omitempty" json:"segmentPortId,omitempty"`
}

func init() {
	t["DistributedVirtualPort"] = reflect.TypeOf((*DistributedVirtualPort)(nil)).Elem()
}

// This class describes a DistributedVirtualPortgroup that a device backing
// can be attached to.
type DistributedVirtualPortgroupInfo struct {
	DynamicData

	// The name of the switch.
	SwitchName string `xml:"switchName" json:"switchName"`
	// The UUID of the switch.
	SwitchUuid string `xml:"switchUuid" json:"switchUuid"`
	// The name of the portgroup.
	PortgroupName string `xml:"portgroupName" json:"portgroupName"`
	// The key of the portgroup.
	PortgroupKey string `xml:"portgroupKey" json:"portgroupKey"`
	// The type of portgroup.
	//
	// See `DistributedVirtualPortgroupPortgroupType_enum`
	PortgroupType string `xml:"portgroupType" json:"portgroupType"`
	// Whether this portgroup is an uplink portgroup.
	UplinkPortgroup bool `xml:"uplinkPortgroup" json:"uplinkPortgroup"`
	// The portgroup.
	//
	// Refers instance of `DistributedVirtualPortgroup`.
	Portgroup ManagedObjectReference `xml:"portgroup" json:"portgroup"`
	// Indicates whether network bandwidth reservation is supported on
	// the portgroup
	NetworkReservationSupported *bool `xml:"networkReservationSupported" json:"networkReservationSupported,omitempty"`
	// Backing type of portgroup.
	//
	// See
	// `DistributedVirtualPortgroup*.*DistributedVirtualPortgroupBackingType_enum`
	// for possible values.
	// The default value is "standard".
	BackingType string `xml:"backingType,omitempty" json:"backingType,omitempty"`
	// The logical switch UUID, which is used by NSX portgroup
	LogicalSwitchUuid string `xml:"logicalSwitchUuid,omitempty" json:"logicalSwitchUuid,omitempty"`
	// The segment ID of logical switch, which is used by NSX portroup
	SegmentId string `xml:"segmentId,omitempty" json:"segmentId,omitempty"`
}

func init() {
	t["DistributedVirtualPortgroupInfo"] = reflect.TypeOf((*DistributedVirtualPortgroupInfo)(nil)).Elem()
}

// The `DistributedVirtualPortgroupNsxPortgroupOperationResult`
// data object defines the result of NSX port group operations, including
// create, reconfigure and delete.
type DistributedVirtualPortgroupNsxPortgroupOperationResult struct {
	DynamicData

	// The management object of NSX port group.
	//
	// For add operation, it indicates the port groups created successfully.
	// For reconfigure operation, it indicates the port groups updated
	// successfully.
	// For delete operation, it indicates the port groups failed deleted.
	//
	// Refers instances of `DistributedVirtualPortgroup`.
	Portgroups []ManagedObjectReference `xml:"portgroups,omitempty" json:"portgroups,omitempty"`
	// The failed port group operation details.
	Problems []DistributedVirtualPortgroupProblem `xml:"problems,omitempty" json:"problems,omitempty"`
}

func init() {
	t["DistributedVirtualPortgroupNsxPortgroupOperationResult"] = reflect.TypeOf((*DistributedVirtualPortgroupNsxPortgroupOperationResult)(nil)).Elem()
}

// The `DistributedVirtualPortgroupProblem`
// data object defines the error while excuting NSX port group operations.
type DistributedVirtualPortgroupProblem struct {
	DynamicData

	// The problematic logical switch UUID
	LogicalSwitchUuid string `xml:"logicalSwitchUuid" json:"logicalSwitchUuid"`
	// The failure reason for each problematic logical switch UUID
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["DistributedVirtualPortgroupProblem"] = reflect.TypeOf((*DistributedVirtualPortgroupProblem)(nil)).Elem()
}

// The `DistributedVirtualSwitchHostMember` data object represents an ESXi host that
// is a member of a distributed virtual switch.
//
// When you add a host to a switch
// (`DistributedVirtualSwitchHostMemberConfigSpec*.*DistributedVirtualSwitchHostMemberConfigSpec.host`),
// the Server creates a proxy switch (`HostProxySwitch`).
// The host member object contains information about the configuration
// and state of the proxy.
type DistributedVirtualSwitchHostMember struct {
	DynamicData

	// Host member runtime state.
	RuntimeState *DistributedVirtualSwitchHostMemberRuntimeState `xml:"runtimeState,omitempty" json:"runtimeState,omitempty"`
	// Host member configuration.
	Config DistributedVirtualSwitchHostMemberConfigInfo `xml:"config" json:"config"`
	// Vendor, product and version information for the proxy switch
	// module.
	ProductInfo *DistributedVirtualSwitchProductSpec `xml:"productInfo,omitempty" json:"productInfo,omitempty"`
	// Port keys of the uplink ports created for the host member.
	//
	// These ports
	// will be deleted after the host leaves the switch.
	UplinkPortKey []string `xml:"uplinkPortKey,omitempty" json:"uplinkPortKey,omitempty"`
	// Deprecated as of vSphere API 5.1, use
	// `HostMemberRuntimeInfo*.*HostMemberRuntimeInfo.status` instead.
	//
	// The host DistributedVirtualSwitch component status.
	//
	// See
	// `HostComponentState` for valid values.
	Status string `xml:"status" json:"status"`
	// Deprecated as of vSphere API 5.1, use
	// `HostMemberRuntimeInfo*.*HostMemberRuntimeInfo.statusDetail` instead.
	//
	// Additional information regarding the host's current status.
	StatusDetail string `xml:"statusDetail,omitempty" json:"statusDetail,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchHostMember"] = reflect.TypeOf((*DistributedVirtualSwitchHostMember)(nil)).Elem()
}

// Base class.
type DistributedVirtualSwitchHostMemberBacking struct {
	DynamicData
}

func init() {
	t["DistributedVirtualSwitchHostMemberBacking"] = reflect.TypeOf((*DistributedVirtualSwitchHostMemberBacking)(nil)).Elem()
}

// The `DistributedVirtualSwitchHostMemberConfigInfo` data object
// contains membership configuration information for the ESXi host.
type DistributedVirtualSwitchHostMemberConfigInfo struct {
	DynamicData

	// ESXi host.
	//
	// This property should always be set unless the user's setting
	// does not have System.Read privilege on the object referred to
	// by this property.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// Maximum number of ports than can be created in the proxy switch.
	//
	// _ESXi 5.0 and earlier hosts_:
	// If you change the maximum number of ports, you must reboot
	// the host for the new value to take effect.
	MaxProxySwitchPorts int32 `xml:"maxProxySwitchPorts" json:"maxProxySwitchPorts"`
	// Opaque binary blob that stores vendor specific configuration.
	VendorSpecificConfig []DistributedVirtualSwitchKeyedOpaqueBlob `xml:"vendorSpecificConfig,omitempty" json:"vendorSpecificConfig,omitempty"`
	// Host membership backing, specifying physical NIC, portgroup, and port
	// bindings for the proxy switch.
	Backing BaseDistributedVirtualSwitchHostMemberBacking `xml:"backing,typeattr" json:"backing"`
	// Indicate whether the proxy switch is used by NSX on this particular
	// host member of the VDS.
	NsxSwitch *bool `xml:"nsxSwitch" json:"nsxSwitch,omitempty"`
	// Indicate if ENS is enabled for this particular host member of
	// the VDS.
	//
	// It is read only.
	EnsEnabled *bool `xml:"ensEnabled" json:"ensEnabled,omitempty"`
	// Indicate if ENS interrupt mode is enabled for this particular host
	// member of the VDS.
	//
	// It is read only.
	EnsInterruptEnabled *bool `xml:"ensInterruptEnabled" json:"ensInterruptEnabled,omitempty"`
	// Indicate which transport zones this host joins by this VDS.
	TransportZones []DistributedVirtualSwitchHostMemberTransportZoneInfo `xml:"transportZones,omitempty" json:"transportZones,omitempty"`
	// Indicate which uplink ports are used by NSX-T.
	NsxtUsedUplinkNames []string `xml:"nsxtUsedUplinkNames,omitempty" json:"nsxtUsedUplinkNames,omitempty"`
	// Indicate if network offloading is enabled for this particular host
	// member of the VDS.
	//
	// Unset implies that network offloading is disabled.
	NetworkOffloadingEnabled *bool `xml:"networkOffloadingEnabled" json:"networkOffloadingEnabled,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["DistributedVirtualSwitchHostMemberConfigInfo"] = reflect.TypeOf((*DistributedVirtualSwitchHostMemberConfigInfo)(nil)).Elem()
}

// Specification to create or reconfigure ESXi host membership
// in a `DistributedVirtualSwitch`.
type DistributedVirtualSwitchHostMemberConfigSpec struct {
	DynamicData

	// Host member operation type.
	//
	// See
	// `ConfigSpecOperation_enum` for valid values.
	Operation string `xml:"operation" json:"operation"`
	// Identifies a host member of a `DistributedVirtualSwitch`
	// for a `Folder.CreateDVS_Task` or
	// `DistributedVirtualSwitch*.*DistributedVirtualSwitch.ReconfigureDvs_Task` operation.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Specifies the physical NICs to use as backing for the proxy switch
	// on the host.
	Backing BaseDistributedVirtualSwitchHostMemberBacking `xml:"backing,omitempty,typeattr" json:"backing,omitempty"`
	// Maximum number of ports allowed in the `HostProxySwitch`.
	//
	// _ESXi 5.0 and earlier hosts_: If you are reconfiguring an existing
	// host membership, that is, the proxy switch already exists, you must reboot
	// the host for the new setting to take effect.
	MaxProxySwitchPorts int32 `xml:"maxProxySwitchPorts,omitempty" json:"maxProxySwitchPorts,omitempty"`
	// Opaque binary blob that stores vendor specific configuration.
	VendorSpecificConfig []DistributedVirtualSwitchKeyedOpaqueBlob `xml:"vendorSpecificConfig,omitempty" json:"vendorSpecificConfig,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchHostMemberConfigSpec"] = reflect.TypeOf((*DistributedVirtualSwitchHostMemberConfigSpec)(nil)).Elem()
}

// The runtime state of uplink on the host.
type DistributedVirtualSwitchHostMemberHostUplinkState struct {
	DynamicData

	// Name of the uplink.
	UplinkName string `xml:"uplinkName" json:"uplinkName"`
	// The runtime state of the uplink.
	//
	// See `DistributedVirtualSwitchHostMemberHostUplinkStateState_enum` for supported values.
	State string `xml:"state" json:"state"`
}

func init() {
	t["DistributedVirtualSwitchHostMemberHostUplinkState"] = reflect.TypeOf((*DistributedVirtualSwitchHostMemberHostUplinkState)(nil)).Elem()
	minAPIVersionForType["DistributedVirtualSwitchHostMemberHostUplinkState"] = "8.0.3.0"
}

// The `DistributedVirtualSwitchHostMemberPnicBacking` data object
// specifies a set of physical NICs to use for a proxy switch.
//
// When you add a host to a distributed virtual switch
// (`DistributedVirtualSwitchHostMemberConfigSpec*.*DistributedVirtualSwitchHostMemberConfigSpec.host`),
// the host creates a proxy switch that will use the pNICs as uplinks.
type DistributedVirtualSwitchHostMemberPnicBacking struct {
	DistributedVirtualSwitchHostMemberBacking

	// List of physical NIC specifications.
	//
	// Each entry identifies
	// a pNIC to the proxy switch and optionally specifies uplink
	// portgroup and port connections for the pNIC.
	PnicSpec []DistributedVirtualSwitchHostMemberPnicSpec `xml:"pnicSpec,omitempty" json:"pnicSpec,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchHostMemberPnicBacking"] = reflect.TypeOf((*DistributedVirtualSwitchHostMemberPnicBacking)(nil)).Elem()
}

// Specification for an individual physical NIC.
type DistributedVirtualSwitchHostMemberPnicSpec struct {
	DynamicData

	// Name of the physical NIC to be added to the proxy switch.
	//
	// See `PhysicalNic*.*PhysicalNic.device`.
	PnicDevice string `xml:"pnicDevice" json:"pnicDevice"`
	// Key of the port to be connected to the physical NIC.
	UplinkPortKey string `xml:"uplinkPortKey,omitempty" json:"uplinkPortKey,omitempty"`
	// Key of the portgroup to be connected to the physical NIC.
	UplinkPortgroupKey string `xml:"uplinkPortgroupKey,omitempty" json:"uplinkPortgroupKey,omitempty"`
	// Cookie that represents this `DistributedVirtualSwitchPortConnection`
	// instance for the port.
	//
	// The cookie value is generated by the
	// Server. The Server ignores any value set by an SDK client.
	//
	// The same cookie is present in the distributed virtual port configuration
	// (`DistributedVirtualPort*.*DistributedVirtualPort.connectionCookie`)
	// so that the Server can verify that the entity is the rightful
	// connectee of the port.
	ConnectionCookie int32 `xml:"connectionCookie,omitempty" json:"connectionCookie,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchHostMemberPnicSpec"] = reflect.TypeOf((*DistributedVirtualSwitchHostMemberPnicSpec)(nil)).Elem()
}

// Runtime state of a host member.
type DistributedVirtualSwitchHostMemberRuntimeState struct {
	DynamicData

	// Current maximum number of ports allowed to be created in the
	// proxy switch.
	CurrentMaxProxySwitchPorts int32 `xml:"currentMaxProxySwitchPorts" json:"currentMaxProxySwitchPorts"`
}

func init() {
	t["DistributedVirtualSwitchHostMemberRuntimeState"] = reflect.TypeOf((*DistributedVirtualSwitchHostMemberRuntimeState)(nil)).Elem()
}

// Transport zone information.
type DistributedVirtualSwitchHostMemberTransportZoneInfo struct {
	DynamicData

	// The UUID of transport zone.
	Uuid string `xml:"uuid" json:"uuid"`
	// The type of transport zone.
	//
	// See `DistributedVirtualSwitchHostMemberTransportZoneType_enum` for valid values.
	Type string `xml:"type" json:"type"`
}

func init() {
	t["DistributedVirtualSwitchHostMemberTransportZoneInfo"] = reflect.TypeOf((*DistributedVirtualSwitchHostMemberTransportZoneInfo)(nil)).Elem()
}

// This data object type is a subset of `AboutInfo`.
//
// An object of
// this type can be used to describe the specification for a host.
type DistributedVirtualSwitchHostProductSpec struct {
	DynamicData

	// The product-line name.
	ProductLineId string `xml:"productLineId,omitempty" json:"productLineId,omitempty"`
	// Dot-separated version string.
	//
	// For example, "1.2".
	Version string `xml:"version,omitempty" json:"version,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchHostProductSpec"] = reflect.TypeOf((*DistributedVirtualSwitchHostProductSpec)(nil)).Elem()
}

// This class describes a DistributedVirtualSwitch that a device backing
// can attached to its ports.
type DistributedVirtualSwitchInfo struct {
	DynamicData

	// The name of the switch.
	SwitchName string `xml:"switchName" json:"switchName"`
	// The UUID of the switch.
	SwitchUuid string `xml:"switchUuid" json:"switchUuid"`
	// The switch.
	//
	// Refers instance of `DistributedVirtualSwitch`.
	DistributedVirtualSwitch ManagedObjectReference `xml:"distributedVirtualSwitch" json:"distributedVirtualSwitch"`
	// Indicates whether network bandwidth reservation is supported on
	// the switch
	NetworkReservationSupported *bool `xml:"networkReservationSupported" json:"networkReservationSupported,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchInfo"] = reflect.TypeOf((*DistributedVirtualSwitchInfo)(nil)).Elem()
}

// This class defines a data structure to hold opaque binary data
// identified by a key.
type DistributedVirtualSwitchKeyedOpaqueBlob struct {
	DynamicData

	// A key that identifies the opaque binary blob.
	Key string `xml:"key" json:"key"`
	// The opaque data.
	//
	// It is recommended that base64 encoding be used for binary
	// data.
	OpaqueData string `xml:"opaqueData" json:"opaqueData"`
}

func init() {
	t["DistributedVirtualSwitchKeyedOpaqueBlob"] = reflect.TypeOf((*DistributedVirtualSwitchKeyedOpaqueBlob)(nil)).Elem()
}

// This is the return type for the checkCompatibility method.
//
// This object
// has a host property and optionally a fault which would
// be populated only if that host is not compatible with a given dvsProductSpec.
// If the host is compatible then the error property would be unset.
type DistributedVirtualSwitchManagerCompatibilityResult struct {
	DynamicData

	// The host for which results are annotated.
	//
	// The whole object will be
	// filtered out if the caller did not have view permissions on the
	// host entity.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// This property contains the faults that makes the host not compatible
	// with a given DvsProductSpec.
	//
	// For example, a host might not be compatible
	// because it's an older version of ESX that doesn't support DVS.
	Error []LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchManagerCompatibilityResult"] = reflect.TypeOf((*DistributedVirtualSwitchManagerCompatibilityResult)(nil)).Elem()
}

// This class is used to specify ProductSpec for the DVS.
//
// The two properties are
// strictly mutually exclusive. If both properties are set, then
// an InvalidArgument fault would be thrown.
type DistributedVirtualSwitchManagerDvsProductSpec struct {
	DynamicData

	// The ProductSpec for new DVS
	NewSwitchProductSpec *DistributedVirtualSwitchProductSpec `xml:"newSwitchProductSpec,omitempty" json:"newSwitchProductSpec,omitempty"`
	// Get ProductSpec from the existing DVS
	//
	// Refers instance of `DistributedVirtualSwitch`.
	DistributedVirtualSwitch *ManagedObjectReference `xml:"distributedVirtualSwitch,omitempty" json:"distributedVirtualSwitch,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchManagerDvsProductSpec"] = reflect.TypeOf((*DistributedVirtualSwitchManagerDvsProductSpec)(nil)).Elem()
}

// Check host compatibility against all hosts specified in the array.
type DistributedVirtualSwitchManagerHostArrayFilter struct {
	DistributedVirtualSwitchManagerHostDvsFilterSpec

	// List of hosts to consider.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["DistributedVirtualSwitchManagerHostArrayFilter"] = reflect.TypeOf((*DistributedVirtualSwitchManagerHostArrayFilter)(nil)).Elem()
}

// Check host compatibility for all hosts in the container.
//
// If the recursive
// flag is true, then check hosts at all levels within this container, otherwise
// check only at the container level. In case of container being a `Datacenter`,
// the recursive flag is applied to its HostFolder.
type DistributedVirtualSwitchManagerHostContainer struct {
	DynamicData

	// Check compatibility of hosts in this container.
	//
	// The supported container
	// types are Datacenter, Folder, and ComputeResource.
	//
	// Refers instance of `ManagedEntity`.
	Container ManagedObjectReference `xml:"container" json:"container"`
	// If true, include hosts of all levels in the hierarchy with
	// container as root of the tree.
	//
	// In case of container being a `Datacenter`,
	// the recursive flag is applied to its HostFolder.
	Recursive bool `xml:"recursive" json:"recursive"`
}

func init() {
	t["DistributedVirtualSwitchManagerHostContainer"] = reflect.TypeOf((*DistributedVirtualSwitchManagerHostContainer)(nil)).Elem()
}

// Check host compatibility against all hosts in this
// `DistributedVirtualSwitchManagerHostContainer`
type DistributedVirtualSwitchManagerHostContainerFilter struct {
	DistributedVirtualSwitchManagerHostDvsFilterSpec

	// Container of hosts that are part of the filter.
	HostContainer DistributedVirtualSwitchManagerHostContainer `xml:"hostContainer" json:"hostContainer"`
}

func init() {
	t["DistributedVirtualSwitchManagerHostContainerFilter"] = reflect.TypeOf((*DistributedVirtualSwitchManagerHostContainerFilter)(nil)).Elem()
}

// Base class for filters to check host compatibility.
type DistributedVirtualSwitchManagerHostDvsFilterSpec struct {
	DynamicData

	// If this flag is true, then the filter returns the hosts in the
	// `DistributedVirtualSwitchManagerHostContainer`
	// that satisfy the criteria specified by this filter, otherwise
	// it returns hosts that don't meet the criteria.
	Inclusive bool `xml:"inclusive" json:"inclusive"`
}

func init() {
	t["DistributedVirtualSwitchManagerHostDvsFilterSpec"] = reflect.TypeOf((*DistributedVirtualSwitchManagerHostDvsFilterSpec)(nil)).Elem()
}

// Check host compatibility against all hosts in the DVS (or not in the DVS if
// inclusive flag in base class is false)
type DistributedVirtualSwitchManagerHostDvsMembershipFilter struct {
	DistributedVirtualSwitchManagerHostDvsFilterSpec

	// Refers instance of `DistributedVirtualSwitch`.
	DistributedVirtualSwitch ManagedObjectReference `xml:"distributedVirtualSwitch" json:"distributedVirtualSwitch"`
}

func init() {
	t["DistributedVirtualSwitchManagerHostDvsMembershipFilter"] = reflect.TypeOf((*DistributedVirtualSwitchManagerHostDvsMembershipFilter)(nil)).Elem()
}

// The `DistributedVirtualSwitchManagerImportResult`
// data object represents the results of a
// `DistributedVirtualSwitchManager.DVSManagerImportEntity_Task`
// operation.
//
// It contains lists of the switches and portgroups
// that were created. It also contains a list of faults
// that occurred during the operation.
type DistributedVirtualSwitchManagerImportResult struct {
	DynamicData

	// List of distributed virtual switches.
	//
	// Refers instances of `DistributedVirtualSwitch`.
	DistributedVirtualSwitch []ManagedObjectReference `xml:"distributedVirtualSwitch,omitempty" json:"distributedVirtualSwitch,omitempty"`
	// List of distributed virtual portgroups.
	//
	// Refers instances of `DistributedVirtualPortgroup`.
	DistributedVirtualPortgroup []ManagedObjectReference `xml:"distributedVirtualPortgroup,omitempty" json:"distributedVirtualPortgroup,omitempty"`
	// Faults that occurred on the entities during the import operation.
	ImportFault []ImportOperationBulkFaultFaultOnImport `xml:"importFault,omitempty" json:"importFault,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchManagerImportResult"] = reflect.TypeOf((*DistributedVirtualSwitchManagerImportResult)(nil)).Elem()
}

// Describe the network offload specification of a
// `VmwareDistributedVirtualSwitch`.
type DistributedVirtualSwitchNetworkOffloadSpec struct {
	DynamicData

	// Identifier of the specification.
	Id string `xml:"id" json:"id"`
	// Name of the specification.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// DPU types supported in the specification.
	Types []string `xml:"types,omitempty" json:"types,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchNetworkOffloadSpec"] = reflect.TypeOf((*DistributedVirtualSwitchNetworkOffloadSpec)(nil)).Elem()
	minAPIVersionForType["DistributedVirtualSwitchNetworkOffloadSpec"] = "8.0.0.1"
}

// Information about the entity that connects to a DistributedVirtualPort.
type DistributedVirtualSwitchPortConnectee struct {
	DynamicData

	// The connected entity.
	//
	// This property should always be set unless the user's setting
	// does not have System.Read privilege on the object referred to
	// by this property.
	//
	// Refers instance of `ManagedEntity`.
	ConnectedEntity *ManagedObjectReference `xml:"connectedEntity,omitempty" json:"connectedEntity,omitempty"`
	// The key of the virtual NIC that connects to this port.
	NicKey string `xml:"nicKey,omitempty" json:"nicKey,omitempty"`
	// The type of the connectee.
	//
	// See `ConnecteeType` for valid values.
	Type string `xml:"type,omitempty" json:"type,omitempty"`
	// A hint on address information of the NIC that connects to this port.
	AddressHint string `xml:"addressHint,omitempty" json:"addressHint,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchPortConnectee"] = reflect.TypeOf((*DistributedVirtualSwitchPortConnectee)(nil)).Elem()
}

// The `DistributedVirtualSwitchPortConnection` data object represents a connection
// or association between a `DistributedVirtualPortgroup` or a
// `DistributedVirtualPort` and one of the following entities:
//   - Virtual machine virtual NIC
//     (`VirtualEthernetCardDistributedVirtualPortBackingInfo`)
//   - Host virtual NIC (`HostVirtualNic`)
//   - Physical NIC (`HostNetworkInfo*.*HostNetworkInfo.pnic`)
type DistributedVirtualSwitchPortConnection struct {
	DynamicData

	// UUID of the switch (`DistributedVirtualSwitch*.*DistributedVirtualSwitch.uuid`).
	SwitchUuid string `xml:"switchUuid" json:"switchUuid"`
	// Key of the portgroup.
	//
	// If specified, the connection object represents a connection
	// or an association between a `DistributedVirtualPortgroup`
	// and a Virtual NIC or physical NIC.
	// In this case, setting the `DistributedVirtualSwitchPortConnection.portKey` is not necessary for a
	// early-binding portgroup and is not allowed for a late-binding portgroup.
	// The `DistributedVirtualSwitchPortConnection.portKey` property will be populated by the implementation
	// at the time of port binding.
	PortgroupKey string `xml:"portgroupKey,omitempty" json:"portgroupKey,omitempty"`
	// Key of the port.
	//
	// If specified, this object represents a connection
	// or an association between an individual `DistributedVirtualPort`
	// and a Virtual NIC or physical NIC. See `DistributedVirtualSwitchPortConnection.portgroupKey` for more information on populating
	// this property.
	PortKey string `xml:"portKey,omitempty" json:"portKey,omitempty"`
	// Cookie that represents this `DistributedVirtualSwitchPortConnection`
	// instance for the port.
	//
	// The cookie value is generated by the
	// Server. The Server ignores any value set by an SDK client.
	//
	// The same cookie is present in the distributed virtual port configuration
	// (`DistributedVirtualPort*.*DistributedVirtualPort.connectionCookie`)
	// so that the Server can verify that the entity is the rightful
	// connectee of the port.
	ConnectionCookie int32 `xml:"connectionCookie,omitempty" json:"connectionCookie,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchPortConnection"] = reflect.TypeOf((*DistributedVirtualSwitchPortConnection)(nil)).Elem()
}

// The criteria specification for selecting ports.
type DistributedVirtualSwitchPortCriteria struct {
	DynamicData

	// If set, only the connected ports are qualified.
	Connected *bool `xml:"connected" json:"connected,omitempty"`
	// If set, only the active ports are qualified.
	Active *bool `xml:"active" json:"active,omitempty"`
	// If set to true, only the uplink ports are qualified.
	//
	// If set to false, only
	// non-uplink ports are qualified.
	UplinkPort *bool `xml:"uplinkPort" json:"uplinkPort,omitempty"`
	// If set to true, only the NSX ports are qualified.
	//
	// If set to false, only
	// non-NSX ports are qualified.
	// NSX ports are ports of NSX port group.
	NsxPort *bool `xml:"nsxPort" json:"nsxPort,omitempty"`
	// Deprecated as of vSphere API 5.5.
	//
	// If set, only the ports of which the scope covers the entity are
	// qualified.
	//
	// Refers instance of `ManagedEntity`.
	Scope *ManagedObjectReference `xml:"scope,omitempty" json:"scope,omitempty"`
	// The keys of the portgroup that is used for the scope of `DistributedVirtualSwitchPortCriteria.inside`.
	//
	// If this property is unset, it means any portgroup. If `DistributedVirtualSwitchPortCriteria.inside`
	// is unset, this property is ignored.
	PortgroupKey []string `xml:"portgroupKey,omitempty" json:"portgroupKey,omitempty"`
	// If unset, all ports in the switch are qualified.
	//
	// If set to true, only ports inside `DistributedVirtualSwitchPortCriteria.portgroupKey` or any
	// portgroup, if not set, are qualified.
	// If set to false, only ports outside `DistributedVirtualSwitchPortCriteria.portgroupKey` or any
	// portgroup, if not set, are qualified.
	Inside *bool `xml:"inside" json:"inside,omitempty"`
	// If set, only the ports of which the key is in the array are
	// qualified.
	PortKey []string `xml:"portKey,omitempty" json:"portKey,omitempty"`
	// If set, only the ports that are present in one of the host are qualified.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchPortCriteria"] = reflect.TypeOf((*DistributedVirtualSwitchPortCriteria)(nil)).Elem()
}

// Statistic data of a DistributedVirtualPort.
type DistributedVirtualSwitchPortStatistics struct {
	DynamicData

	// The number of multicast packets received.
	PacketsInMulticast int64 `xml:"packetsInMulticast" json:"packetsInMulticast"`
	// The number of multicast packets forwarded.
	PacketsOutMulticast int64 `xml:"packetsOutMulticast" json:"packetsOutMulticast"`
	// The number of bytes received from multicast packets.
	BytesInMulticast int64 `xml:"bytesInMulticast" json:"bytesInMulticast"`
	// The number of bytes forwarded from multicast packets.
	BytesOutMulticast int64 `xml:"bytesOutMulticast" json:"bytesOutMulticast"`
	// The number of unicast packets received.
	PacketsInUnicast int64 `xml:"packetsInUnicast" json:"packetsInUnicast"`
	// The number of unicast packets forwarded.
	PacketsOutUnicast int64 `xml:"packetsOutUnicast" json:"packetsOutUnicast"`
	// The number of bytes received from unicast packets.
	BytesInUnicast int64 `xml:"bytesInUnicast" json:"bytesInUnicast"`
	// The number of bytes forwarded from unicast packets.
	BytesOutUnicast int64 `xml:"bytesOutUnicast" json:"bytesOutUnicast"`
	// The number of broadcast packets received.
	PacketsInBroadcast int64 `xml:"packetsInBroadcast" json:"packetsInBroadcast"`
	// The number of broadcast packets forwarded.
	PacketsOutBroadcast int64 `xml:"packetsOutBroadcast" json:"packetsOutBroadcast"`
	// The number of bytes received from broadcast packets.
	BytesInBroadcast int64 `xml:"bytesInBroadcast" json:"bytesInBroadcast"`
	// The number of bytes forwarded from broadcast packets.
	BytesOutBroadcast int64 `xml:"bytesOutBroadcast" json:"bytesOutBroadcast"`
	// The number of received packets dropped.
	PacketsInDropped int64 `xml:"packetsInDropped" json:"packetsInDropped"`
	// The number of packets to be forwarded dropped.
	PacketsOutDropped int64 `xml:"packetsOutDropped" json:"packetsOutDropped"`
	// The number of packets received that cause an exception.
	PacketsInException int64 `xml:"packetsInException" json:"packetsInException"`
	// The number of packets to be forwarded that cause an exception.
	PacketsOutException int64 `xml:"packetsOutException" json:"packetsOutException"`
	// The number of bytes received at a pnic on the behalf of a port's
	// connectee (inter-host rx).
	BytesInFromPnic int64 `xml:"bytesInFromPnic,omitempty" json:"bytesInFromPnic,omitempty"`
	// The number of bytes transmitted at a pnic on the behalf of a port's
	// connectee (inter-host tx).
	BytesOutToPnic int64 `xml:"bytesOutToPnic,omitempty" json:"bytesOutToPnic,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchPortStatistics"] = reflect.TypeOf((*DistributedVirtualSwitchPortStatistics)(nil)).Elem()
}

// This data object type is a subset of `AboutInfo`.
//
// An object of
// this type can be used to describe the specification for a proxy switch module
// of a `DistributedVirtualSwitch`.
type DistributedVirtualSwitchProductSpec struct {
	DynamicData

	// Short form of the product name.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// Name of the vendor of this product.
	Vendor string `xml:"vendor,omitempty" json:"vendor,omitempty"`
	// Dot-separated version string.
	//
	// For example, "1.2".
	Version string `xml:"version,omitempty" json:"version,omitempty"`
	// Build string for the server on which this call is made.
	//
	// For example, x.y.z-num.
	// This string does not apply to the API.
	Build string `xml:"build,omitempty" json:"build,omitempty"`
	// Forwarding class of the distributed virtual switch.
	ForwardingClass string `xml:"forwardingClass,omitempty" json:"forwardingClass,omitempty"`
	// The ID of the bundle if a host component bundle needs to be installed on
	// the host members to support the functionality of the switch.
	BundleId string `xml:"bundleId,omitempty" json:"bundleId,omitempty"`
	// The URL of the bundle that VMware Update Manager will use to install
	// the bundle on the host members, if `DistributedVirtualSwitchProductSpec.bundleId` is set.
	BundleUrl string `xml:"bundleUrl,omitempty" json:"bundleUrl,omitempty"`
}

func init() {
	t["DistributedVirtualSwitchProductSpec"] = reflect.TypeOf((*DistributedVirtualSwitchProductSpec)(nil)).Elem()
}

type DoesCustomizationSpecExist DoesCustomizationSpecExistRequestType

func init() {
	t["DoesCustomizationSpecExist"] = reflect.TypeOf((*DoesCustomizationSpecExist)(nil)).Elem()
}

// The parameters of `CustomizationSpecManager.DoesCustomizationSpecExist`.
type DoesCustomizationSpecExistRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Name string                 `xml:"name" json:"name"`
}

func init() {
	t["DoesCustomizationSpecExistRequestType"] = reflect.TypeOf((*DoesCustomizationSpecExistRequestType)(nil)).Elem()
}

type DoesCustomizationSpecExistResponse struct {
	Returnval bool `xml:"returnval" json:"returnval"`
}

// Fault indicating that the domain controller
// for domainName cannot be reached.
type DomainNotFound struct {
	ActiveDirectoryFault

	// The domain that cannot be accessed.
	DomainName string `xml:"domainName" json:"domainName"`
}

func init() {
	t["DomainNotFound"] = reflect.TypeOf((*DomainNotFound)(nil)).Elem()
}

type DomainNotFoundFault DomainNotFound

func init() {
	t["DomainNotFoundFault"] = reflect.TypeOf((*DomainNotFoundFault)(nil)).Elem()
}

type DownloadDescriptionTree DownloadDescriptionTreeRequestType

func init() {
	t["DownloadDescriptionTree"] = reflect.TypeOf((*DownloadDescriptionTree)(nil)).Elem()
}

type DownloadDescriptionTreeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["DownloadDescriptionTreeRequestType"] = reflect.TypeOf((*DownloadDescriptionTreeRequestType)(nil)).Elem()
}

type DownloadDescriptionTreeResponse struct {
	Returnval []byte `xml:"returnval" json:"returnval"`
}

// Data object describing the operational status of various DPU
// elements.
type DpuStatusInfo struct {
	HostHardwareElementInfo

	// Uniquely identify this DPU.
	//
	// Should be the VMware identifier
	// which can be composed from pci and other identifying elements.
	DpuId string `xml:"dpuId" json:"dpuId"`
	// The FRU this sensor monitors, if any.
	Fru     *HostFru                       `xml:"fru,omitempty" json:"fru,omitempty"`
	Sensors []DpuStatusInfoOperationalInfo `xml:"sensors,omitempty" json:"sensors,omitempty"`
}

func init() {
	t["DpuStatusInfo"] = reflect.TypeOf((*DpuStatusInfo)(nil)).Elem()
	minAPIVersionForType["DpuStatusInfo"] = "8.0.0.1"
}

// Sensor information provided by DPU that provides health status.
type DpuStatusInfoOperationalInfo struct {
	DynamicData

	// This string uniquely identifies a sensor in the DPU.
	SensorId string `xml:"sensorId" json:"sensorId"`
	// The health state of the element indicated by the sensor.
	//
	// See also `HostNumericSensorHealthState_enum`.
	HealthState BaseElementDescription `xml:"healthState,omitempty,typeattr" json:"healthState,omitempty"`
	// A description of the state of the sensor
	// such as: N watts, Y RPM, or other measurement.
	Reading string `xml:"reading" json:"reading"`
	// If provided by underying API, the base units in which the sensor
	// reading is specified, "RPM", "WATTS" and so forth.
	Units string `xml:"units,omitempty" json:"units,omitempty"`
	// Reports the ISO 8601 Timestamp when this sensor was last updated by
	// management controller if the this sensor is capable of tracking
	// when it was last updated.
	//
	// Property timeStampRaw, which comes from
	// vendor firmware is convertible to DateTime, it will be provided.
	TimeStamp *time.Time `xml:"timeStamp" json:"timeStamp,omitempty"`
}

func init() {
	t["DpuStatusInfoOperationalInfo"] = reflect.TypeOf((*DpuStatusInfoOperationalInfo)(nil)).Elem()
	minAPIVersionForType["DpuStatusInfoOperationalInfo"] = "8.0.0.1"
}

type DropConnections DropConnectionsRequestType

func init() {
	t["DropConnections"] = reflect.TypeOf((*DropConnections)(nil)).Elem()
}

// The parameters of `VirtualMachine.DropConnections`.
type DropConnectionsRequestType struct {
	This              ManagedObjectReference         `xml:"_this" json:"-"`
	ListOfConnections []BaseVirtualMachineConnection `xml:"listOfConnections,omitempty,typeattr" json:"listOfConnections,omitempty"`
}

func init() {
	t["DropConnectionsRequestType"] = reflect.TypeOf((*DropConnectionsRequestType)(nil)).Elem()
	minAPIVersionForType["DropConnectionsRequestType"] = "7.0.1.0"
}

type DropConnectionsResponse struct {
	Returnval bool `xml:"returnval" json:"returnval"`
}

// This event records when DRS is disabled on a cluster.
type DrsDisabledEvent struct {
	ClusterEvent
}

func init() {
	t["DrsDisabledEvent"] = reflect.TypeOf((*DrsDisabledEvent)(nil)).Elem()
}

// This fault is thrown when DRS cannot move a virtual machine because
// DRS is disabled on it (i.e., it is pinned on its registered host).
type DrsDisabledOnVm struct {
	VimFault
}

func init() {
	t["DrsDisabledOnVm"] = reflect.TypeOf((*DrsDisabledOnVm)(nil)).Elem()
}

type DrsDisabledOnVmFault DrsDisabledOnVm

func init() {
	t["DrsDisabledOnVmFault"] = reflect.TypeOf((*DrsDisabledOnVmFault)(nil)).Elem()
}

// This event records when DRS is enabled on a cluster.
type DrsEnabledEvent struct {
	ClusterEvent

	// The DRS automation level in (`DrsBehavior`)
	Behavior string `xml:"behavior" json:"behavior"`
}

func init() {
	t["DrsEnabledEvent"] = reflect.TypeOf((*DrsEnabledEvent)(nil)).Elem()
}

// This event records that the host has successfully entered standby mode initiated by
// Distributed Power Management.
//
// A host in this mode has no running virtual
// machines and no provisioning operations are occurring.
type DrsEnteredStandbyModeEvent struct {
	EnteredStandbyModeEvent
}

func init() {
	t["DrsEnteredStandbyModeEvent"] = reflect.TypeOf((*DrsEnteredStandbyModeEvent)(nil)).Elem()
}

// This event records that a host has begun the process of
// entering standby mode initiated by Distributed Power Management.
type DrsEnteringStandbyModeEvent struct {
	EnteringStandbyModeEvent
}

func init() {
	t["DrsEnteringStandbyModeEvent"] = reflect.TypeOf((*DrsEnteringStandbyModeEvent)(nil)).Elem()
}

// This event records that Distributed Power Management tried to bring a host out
// from standby mode, but the host failed to exit standby mode.
type DrsExitStandbyModeFailedEvent struct {
	ExitStandbyModeFailedEvent
}

func init() {
	t["DrsExitStandbyModeFailedEvent"] = reflect.TypeOf((*DrsExitStandbyModeFailedEvent)(nil)).Elem()
}

// This event records that Distributed Power Management brings this host
// out from standby mode.
type DrsExitedStandbyModeEvent struct {
	ExitedStandbyModeEvent
}

func init() {
	t["DrsExitedStandbyModeEvent"] = reflect.TypeOf((*DrsExitedStandbyModeEvent)(nil)).Elem()
}

// This event records that a host has begun the process of
// exiting standby mode initiated by Distributed Power Management.
type DrsExitingStandbyModeEvent struct {
	ExitingStandbyModeEvent
}

func init() {
	t["DrsExitingStandbyModeEvent"] = reflect.TypeOf((*DrsExitingStandbyModeEvent)(nil)).Elem()
}

// This event records DRS invocation failure.
type DrsInvocationFailedEvent struct {
	ClusterEvent
}

func init() {
	t["DrsInvocationFailedEvent"] = reflect.TypeOf((*DrsInvocationFailedEvent)(nil)).Elem()
}

// This event records that DRS has recovered from failure.
//
// It is triggered by a successful DRS invocation after repeated failure.
type DrsRecoveredFromFailureEvent struct {
	ClusterEvent
}

func init() {
	t["DrsRecoveredFromFailureEvent"] = reflect.TypeOf((*DrsRecoveredFromFailureEvent)(nil)).Elem()
}

// This event records when resource configuration
// specification synchronization fails on a host.
type DrsResourceConfigureFailedEvent struct {
	HostEvent

	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["DrsResourceConfigureFailedEvent"] = reflect.TypeOf((*DrsResourceConfigureFailedEvent)(nil)).Elem()
}

// This event records when resource configuration
// specification returns to synchronized from previous failure.
type DrsResourceConfigureSyncedEvent struct {
	HostEvent
}

func init() {
	t["DrsResourceConfigureSyncedEvent"] = reflect.TypeOf((*DrsResourceConfigureSyncedEvent)(nil)).Elem()
}

// This event records when a virtual machine comes into compliance with DRS rules.
type DrsRuleComplianceEvent struct {
	VmEvent
}

func init() {
	t["DrsRuleComplianceEvent"] = reflect.TypeOf((*DrsRuleComplianceEvent)(nil)).Elem()
}

// This event records when a virtual machine violates a DRS VM-Host rule.
type DrsRuleViolationEvent struct {
	VmEvent
}

func init() {
	t["DrsRuleViolationEvent"] = reflect.TypeOf((*DrsRuleViolationEvent)(nil)).Elem()
}

// This event records when a virtual machine violates a soft VM-Host rule.
type DrsSoftRuleViolationEvent struct {
	VmEvent
}

func init() {
	t["DrsSoftRuleViolationEvent"] = reflect.TypeOf((*DrsSoftRuleViolationEvent)(nil)).Elem()
}

// This event records a virtual machine migration that was recommended by DRS.
type DrsVmMigratedEvent struct {
	VmMigratedEvent
}

func init() {
	t["DrsVmMigratedEvent"] = reflect.TypeOf((*DrsVmMigratedEvent)(nil)).Elem()
}

// This event records when a virtual machine is powered on by DRS.
type DrsVmPoweredOnEvent struct {
	VmPoweredOnEvent
}

func init() {
	t["DrsVmPoweredOnEvent"] = reflect.TypeOf((*DrsVmPoweredOnEvent)(nil)).Elem()
}

// This fault is thrown when DRS tries to migrate a virtual machine to a host,
// but finds that the host is incompatible with the given virtual machine.
type DrsVmotionIncompatibleFault struct {
	VirtualHardwareCompatibilityIssue

	// The host that is incompatible with a given virtual machine.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["DrsVmotionIncompatibleFault"] = reflect.TypeOf((*DrsVmotionIncompatibleFault)(nil)).Elem()
}

type DrsVmotionIncompatibleFaultFault DrsVmotionIncompatibleFault

func init() {
	t["DrsVmotionIncompatibleFaultFault"] = reflect.TypeOf((*DrsVmotionIncompatibleFaultFault)(nil)).Elem()
}

type DuplicateCustomizationSpec DuplicateCustomizationSpecRequestType

func init() {
	t["DuplicateCustomizationSpec"] = reflect.TypeOf((*DuplicateCustomizationSpec)(nil)).Elem()
}

// The parameters of `CustomizationSpecManager.DuplicateCustomizationSpec`.
type DuplicateCustomizationSpecRequestType struct {
	This    ManagedObjectReference `xml:"_this" json:"-"`
	Name    string                 `xml:"name" json:"name"`
	NewName string                 `xml:"newName" json:"newName"`
}

func init() {
	t["DuplicateCustomizationSpecRequestType"] = reflect.TypeOf((*DuplicateCustomizationSpecRequestType)(nil)).Elem()
}

type DuplicateCustomizationSpecResponse struct {
}

// Fault used to denote a duplicate set of disks were incorrectly specified
// for a given operation.
//
// See also `HostVsanSystem.AddDisks_Task`, `HostVsanSystem.InitializeDisks_Task`.
type DuplicateDisks struct {
	VsanDiskFault
}

func init() {
	t["DuplicateDisks"] = reflect.TypeOf((*DuplicateDisks)(nil)).Elem()
}

type DuplicateDisksFault DuplicateDisks

func init() {
	t["DuplicateDisksFault"] = reflect.TypeOf((*DuplicateDisksFault)(nil)).Elem()
}

// This event records that a duplicate IP address has been observed in
// conflict with the vmotion or IP storage interface configured on the
// host.
type DuplicateIpDetectedEvent struct {
	HostEvent

	// The Duplicate IP address detected.
	DuplicateIP string `xml:"duplicateIP" json:"duplicateIP"`
	// The MAC associated with duplicate IP.
	MacAddress string `xml:"macAddress" json:"macAddress"`
}

func init() {
	t["DuplicateIpDetectedEvent"] = reflect.TypeOf((*DuplicateIpDetectedEvent)(nil)).Elem()
}

// A DuplicateName exception is thrown because a name already exists
// in the same name space.
type DuplicateName struct {
	VimFault

	// The name that is already bound in the name space.
	Name string `xml:"name" json:"name"`
	// Managed object that already holds the name.
	Object ManagedObjectReference `xml:"object" json:"object"`
}

func init() {
	t["DuplicateName"] = reflect.TypeOf((*DuplicateName)(nil)).Elem()
}

type DuplicateNameFault DuplicateName

func init() {
	t["DuplicateNameFault"] = reflect.TypeOf((*DuplicateNameFault)(nil)).Elem()
}

// Fault thrown for cases that duplicate network interface names are
// incorrectly specified for a VSAN operation.
//
// See also `HostVsanSystem.UpdateVsan_Task`, `ComputeResource.ReconfigureComputeResource_Task`.
type DuplicateVsanNetworkInterface struct {
	VsanFault

	// The network interface name found to be duplicated.
	Device string `xml:"device" json:"device"`
}

func init() {
	t["DuplicateVsanNetworkInterface"] = reflect.TypeOf((*DuplicateVsanNetworkInterface)(nil)).Elem()
}

type DuplicateVsanNetworkInterfaceFault DuplicateVsanNetworkInterface

func init() {
	t["DuplicateVsanNetworkInterfaceFault"] = reflect.TypeOf((*DuplicateVsanNetworkInterfaceFault)(nil)).Elem()
}

// This event is generated when an import operation is
// performed on a distributed virtual portgroup
type DvpgImportEvent struct {
	DVPortgroupEvent

	// The type of restore operation.
	//
	// See `EntityImportType_enum` for valid values
	ImportType string `xml:"importType" json:"importType"`
}

func init() {
	t["DvpgImportEvent"] = reflect.TypeOf((*DvpgImportEvent)(nil)).Elem()
}

// This event is generated when a restore operation is
// performed on a distributed virtual portgroup
type DvpgRestoreEvent struct {
	DVPortgroupEvent
}

func init() {
	t["DvpgRestoreEvent"] = reflect.TypeOf((*DvpgRestoreEvent)(nil)).Elem()
}

// This class defines network rule action to accept packets.
type DvsAcceptNetworkRuleAction struct {
	DvsNetworkRuleAction
}

func init() {
	t["DvsAcceptNetworkRuleAction"] = reflect.TypeOf((*DvsAcceptNetworkRuleAction)(nil)).Elem()
}

// Thrown if a vSphere Distributed Switch apply operation failed to set or remove
// some of the specified objects.
type DvsApplyOperationFault struct {
	DvsFault

	// Faults occurred on the host during a DistributedVirtualSwitch operation.
	ObjectFault []DvsApplyOperationFaultFaultOnObject `xml:"objectFault" json:"objectFault"`
}

func init() {
	t["DvsApplyOperationFault"] = reflect.TypeOf((*DvsApplyOperationFault)(nil)).Elem()
}

type DvsApplyOperationFaultFault DvsApplyOperationFault

func init() {
	t["DvsApplyOperationFaultFault"] = reflect.TypeOf((*DvsApplyOperationFaultFault)(nil)).Elem()
}

// The fault occurred during an apply operation.
type DvsApplyOperationFaultFaultOnObject struct {
	DynamicData

	// The object identifier.
	//
	// It should be UUID for vSphere Distributed Switches,
	// keys for vNetwork distributed portgroups and ports.
	ObjectId string `xml:"objectId" json:"objectId"`
	// The Type of the objects.
	Type string `xml:"type" json:"type"`
	// The fault that occurred.
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["DvsApplyOperationFaultFaultOnObject"] = reflect.TypeOf((*DvsApplyOperationFaultFaultOnObject)(nil)).Elem()
}

// This class defines network rule action to copy the packet to an
// associated slow-path service Virtual Machine and let the original
// frame continue.
type DvsCopyNetworkRuleAction struct {
	DvsNetworkRuleAction
}

func init() {
	t["DvsCopyNetworkRuleAction"] = reflect.TypeOf((*DvsCopyNetworkRuleAction)(nil)).Elem()
}

// A distributed virtual switch was created.
type DvsCreatedEvent struct {
	DvsEvent

	// The folder where the DistributedVirtualSwitch is created.
	Parent FolderEventArgument `xml:"parent" json:"parent"`
}

func init() {
	t["DvsCreatedEvent"] = reflect.TypeOf((*DvsCreatedEvent)(nil)).Elem()
}

// A distributed virtual switch was destroyed.
type DvsDestroyedEvent struct {
	DvsEvent
}

func init() {
	t["DvsDestroyedEvent"] = reflect.TypeOf((*DvsDestroyedEvent)(nil)).Elem()
}

// This class defines network rule action to drop packets.
type DvsDropNetworkRuleAction struct {
	DvsNetworkRuleAction
}

func init() {
	t["DvsDropNetworkRuleAction"] = reflect.TypeOf((*DvsDropNetworkRuleAction)(nil)).Elem()
}

// These are dvs-related events.
type DvsEvent struct {
	Event
}

func init() {
	t["DvsEvent"] = reflect.TypeOf((*DvsEvent)(nil)).Elem()
}

// The event argument is a Host object.
type DvsEventArgument struct {
	EntityEventArgument

	// The distributed virtual switch object.
	//
	// Refers instance of `DistributedVirtualSwitch`.
	Dvs ManagedObjectReference `xml:"dvs" json:"dvs"`
}

func init() {
	t["DvsEventArgument"] = reflect.TypeOf((*DvsEventArgument)(nil)).Elem()
}

// Base class for faults that can be thrown while invoking a distributed virtual switch
// operation.
type DvsFault struct {
	VimFault
}

func init() {
	t["DvsFault"] = reflect.TypeOf((*DvsFault)(nil)).Elem()
}

type DvsFaultFault BaseDvsFault

func init() {
	t["DvsFaultFault"] = reflect.TypeOf((*DvsFaultFault)(nil)).Elem()
}

// This class defines Network Filter configuration.
//
// ** Supported Qualifier and Actions **
// <table border="1"width="100%">
// <tr>
// <th>Network Filter Config</th>
// <th>Supported classes</th>
// </tr>
// <tr>
// <td>Qualifiers supported</td>
// <td>`SingleIp`, `IpRange`,
// `SingleMac`, `MacRange`,
// `DvsSingleIpPort`,
// `DvsSystemTrafficNetworkRuleQualifier`
// </td>
// </tr>
// <tr>
// <td>Actions Supported</td>
// <td>`DvsDropNetworkRuleAction`,
// `DvsAcceptNetworkRuleAction`,
// `DvsPuntNetworkRuleAction`,
// `DvsCopyNetworkRuleAction`,
// `DvsMacRewriteNetworkRuleAction`,
// `DvsGreEncapNetworkRuleAction`,
// `DvsLogNetworkRuleAction`,
// `DvsUpdateTagNetworkRuleAction`,
// `DvsRateLimitNetworkRuleAction`
// </td>
// </tr>
type DvsFilterConfig struct {
	InheritablePolicy

	// The key of Network Filter Config.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// The name of the network traffic filter agent.
	AgentName string `xml:"agentName,omitempty" json:"agentName,omitempty"`
	// The slot number of the network filter agent.
	SlotNumber string `xml:"slotNumber,omitempty" json:"slotNumber,omitempty"`
	// Network Filter Parameter
	Parameters *DvsFilterParameter `xml:"parameters,omitempty" json:"parameters,omitempty"`
	// This property specifies whether to allow all traffic or to deny all
	// traffic when a Network Filter fails to configure.
	//
	// Please see `DvsFilterOnFailure_enum`
	// for more details.
	OnFailure string `xml:"onFailure,omitempty" json:"onFailure,omitempty"`
}

func init() {
	t["DvsFilterConfig"] = reflect.TypeOf((*DvsFilterConfig)(nil)).Elem()
}

// The specification to reconfigure Network Filter.
//
// This specification allows the user to do fine-grained updates for the
// Filter in the port settings.
// If the operation is `remove`, only the
// `DistributedVirtualPort.key` needs to be specified.
// If other fields are specified, they will be ignored. We cannot remove
// an inherited element. Only when the inherited flag is set to false and
// parent does not have an element with same key this operation succeeds.
// If the operation is `add`, then
// `DistributedVirtualPort.key` should not be specified and
// other fields need to be specified. The inherited flag should be set to
// false.
// If the operation is `edit`, then
// `DistributedVirtualPort.key` needs be specified and
// specify the other properties that need modification. If the inherited
// flag is set to true, a `DvsFilterConfig` object of same
// key must exist at the parent's level. The property values in the spec
// object will be ignored and use the values from the parent's
// `DvsFilterConfig` object instead. If inherited
// flag is set to false, then the new modifications will be applied.
type DvsFilterConfigSpec struct {
	DvsFilterConfig

	// Operation type.
	//
	// See `ConfigSpecOperation_enum` for valid values.
	Operation string `xml:"operation" json:"operation"`
}

func init() {
	t["DvsFilterConfigSpec"] = reflect.TypeOf((*DvsFilterConfigSpec)(nil)).Elem()
}

// This class defines Network Filter parameter.
type DvsFilterParameter struct {
	DynamicData

	// List of parameters for a Network Filter.
	Parameters []string `xml:"parameters,omitempty" json:"parameters,omitempty"`
}

func init() {
	t["DvsFilterParameter"] = reflect.TypeOf((*DvsFilterParameter)(nil)).Elem()
}

// This class defines Network Filter Policy.
type DvsFilterPolicy struct {
	InheritablePolicy

	// List of Network Filter Configurations.
	//
	// In an update operation, the array can contain all
	// `DvsTrafficFilterConfigSpec` objects
	// or all `DvsFilterConfig` and
	// `DvsTrafficFilterConfig`
	// object, but not mixed of Config and Spec objects. If array of
	// `DvsFilterConfigSpec` and `DvsTrafficFilterConfigSpec` is used
	// for updating Network Filter then only the Network Filters
	// matching `DistributedVirtualPort.key` /
	// `DistributedVirtualPort.key`
	// is updated.
	// If array of `DvsFilterConfig` and
	// `DvsTrafficFilterConfig`
	// is used for updating port settings, the Network Filter
	// settings will be overridden with the new array specified. The
	// specified array should only contain `DvsFilterConfig` and
	// `DvsTrafficFilterConfig` objects with `InheritablePolicy.inherited` /
	// `InheritablePolicy.inherited` set to false.
	// `DvsFilterConfig*/*DvsTrafficFilterConfig` objects with
	// `InheritablePolicy.inherited*/*InheritablePolicy.inherited` as
	// true in the specified array will be ignored. The updated result will
	// include `DvsFilterConfig*/*DvsTrafficFilterConfig` objects
	// inherited from parent, if any.
	FilterConfig []BaseDvsFilterConfig `xml:"filterConfig,omitempty,typeattr" json:"filterConfig,omitempty"`
}

func init() {
	t["DvsFilterPolicy"] = reflect.TypeOf((*DvsFilterPolicy)(nil)).Elem()
}

// This class defines network rule action to GRE Encapsulate a packet.
type DvsGreEncapNetworkRuleAction struct {
	DvsNetworkRuleAction

	// Single IP address.
	//
	// Only IPv4 is supported for vSphere API 5.5.
	EncapsulationIp SingleIp `xml:"encapsulationIp" json:"encapsulationIp"`
}

func init() {
	t["DvsGreEncapNetworkRuleAction"] = reflect.TypeOf((*DvsGreEncapNetworkRuleAction)(nil)).Elem()
}

// Health check status of an switch is changed.
type DvsHealthStatusChangeEvent struct {
	HostEvent

	// UUID of the DVS the host is connected to.
	SwitchUuid string `xml:"switchUuid" json:"switchUuid"`
	// Health check status.
	HealthResult BaseHostMemberHealthCheckResult `xml:"healthResult,omitempty,typeattr" json:"healthResult,omitempty"`
}

func init() {
	t["DvsHealthStatusChangeEvent"] = reflect.TypeOf((*DvsHealthStatusChangeEvent)(nil)).Elem()
}

// The DVS configuration on the host was synchronized with that of
// the Virtual Center Server and the configuration is the same on
// the host and Virtual Center Server.
type DvsHostBackInSyncEvent struct {
	DvsEvent

	// The host that was synchronized.
	HostBackInSync HostEventArgument `xml:"hostBackInSync" json:"hostBackInSync"`
}

func init() {
	t["DvsHostBackInSyncEvent"] = reflect.TypeOf((*DvsHostBackInSyncEvent)(nil)).Elem()
}

// This class defines the resource allocation for a host infrastructure
// traffic class on a physical NIC
type DvsHostInfrastructureTrafficResource struct {
	DynamicData

	// The key of the host infrastructure resource.
	//
	// Possible value can be of
	// `DistributedVirtualSwitchHostInfrastructureTrafficClass_enum`.
	Key string `xml:"key" json:"key"`
	// The description of the host infrastructure resource.
	//
	// This property is ignored for update operation.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// The allocation settings of the host infrastructure resource.
	AllocationInfo DvsHostInfrastructureTrafficResourceAllocation `xml:"allocationInfo" json:"allocationInfo"`
}

func init() {
	t["DvsHostInfrastructureTrafficResource"] = reflect.TypeOf((*DvsHostInfrastructureTrafficResource)(nil)).Elem()
}

// Resource allocation information for a
// host infrastructure traffic class.
type DvsHostInfrastructureTrafficResourceAllocation struct {
	DynamicData

	// The maximum allowed usage for a traffic class belonging to
	// this resource pool per host physical NIC.
	//
	// The utilization of a traffic class will not exceed the specified limit
	// even if there are available network resources. If this value is unset
	// or set to -1 in an update operation, then there is no limit on the network
	// resource usage (only bounded by available resource and shares).
	// Units are in Mbits/sec.
	Limit *int64 `xml:"limit" json:"limit,omitempty"`
	// Network share.
	//
	// The value is used as a relative weight in competing for
	// shared bandwidth, in case of resource contention.
	Shares *SharesInfo `xml:"shares,omitempty" json:"shares,omitempty"`
	// Amount of bandwidth resource that is guaranteed available
	// to the host infrastructure traffic class.
	//
	// If the utilization is less than the reservation, the extra bandwidth
	// is used for other host infrastructure traffic class types. Reservation is not
	// allowed to exceed the value of
	// `DvsHostInfrastructureTrafficResourceAllocation.limit`, if
	// `DvsHostInfrastructureTrafficResourceAllocation.limit` is set.
	// Unit is Mbits/sec.
	Reservation *int64 `xml:"reservation" json:"reservation,omitempty"`
}

func init() {
	t["DvsHostInfrastructureTrafficResourceAllocation"] = reflect.TypeOf((*DvsHostInfrastructureTrafficResourceAllocation)(nil)).Elem()
}

// A host joined the distributed virtual switch.
type DvsHostJoinedEvent struct {
	DvsEvent

	// The host that joined DVS.
	HostJoined HostEventArgument `xml:"hostJoined" json:"hostJoined"`
}

func init() {
	t["DvsHostJoinedEvent"] = reflect.TypeOf((*DvsHostJoinedEvent)(nil)).Elem()
}

// A host left the distributed virtual switch.
type DvsHostLeftEvent struct {
	DvsEvent

	// The host that left DVS.
	HostLeft HostEventArgument `xml:"hostLeft" json:"hostLeft"`
}

func init() {
	t["DvsHostLeftEvent"] = reflect.TypeOf((*DvsHostLeftEvent)(nil)).Elem()
}

// A host has it's status or statusDetail updated.
type DvsHostStatusUpdated struct {
	DvsEvent

	// The host.
	HostMember HostEventArgument `xml:"hostMember" json:"hostMember"`
	// Host's old status.
	OldStatus string `xml:"oldStatus,omitempty" json:"oldStatus,omitempty"`
	// Host's new status.
	NewStatus string `xml:"newStatus,omitempty" json:"newStatus,omitempty"`
	// Comments regarding host's old status.
	OldStatusDetail string `xml:"oldStatusDetail,omitempty" json:"oldStatusDetail,omitempty"`
	// Comments regarding host's new status.
	NewStatusDetail string `xml:"newStatusDetail,omitempty" json:"newStatusDetail,omitempty"`
}

func init() {
	t["DvsHostStatusUpdated"] = reflect.TypeOf((*DvsHostStatusUpdated)(nil)).Elem()
}

// The `DvsHostVNicProfile` data object describes the IP configuration
// for a host Virtual NIC connected to a distributed virtual switch.
//
// The `DvsVNicProfile.ipConfig` property contains the Virtual NIC IP address.
// If a profile plug-in defines policies or subprofiles, use the
// `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the additional configuration data.
type DvsHostVNicProfile struct {
	DvsVNicProfile
}

func init() {
	t["DvsHostVNicProfile"] = reflect.TypeOf((*DvsHostVNicProfile)(nil)).Elem()
}

// The DVS configuration on the host diverged from that of
// the Virtual Center Server.
type DvsHostWentOutOfSyncEvent struct {
	DvsEvent

	// The host that went out of sync.
	HostOutOfSync DvsOutOfSyncHostArgument `xml:"hostOutOfSync" json:"hostOutOfSync"`
}

func init() {
	t["DvsHostWentOutOfSyncEvent"] = reflect.TypeOf((*DvsHostWentOutOfSyncEvent)(nil)).Elem()
}

// This event is generated when a import operation is
// performed on a distributed virtual switch
type DvsImportEvent struct {
	DvsEvent

	// The type of restore operation.
	//
	// See `EntityImportType_enum` for valid values
	ImportType string `xml:"importType" json:"importType"`
}

func init() {
	t["DvsImportEvent"] = reflect.TypeOf((*DvsImportEvent)(nil)).Elem()
}

// This class defines the IP Rule Qualifier.
//
// Here IP addresses of source
// and destination will be used for classifying packets.
type DvsIpNetworkRuleQualifier struct {
	DvsNetworkRuleQualifier

	// IP qualifier for source.
	//
	// If this property is NULL, it will match "any IPv4 or any IPv6 address".
	SourceAddress BaseIpAddress `xml:"sourceAddress,omitempty,typeattr" json:"sourceAddress,omitempty"`
	// IP qualifier for destination.
	//
	// If this property is NULL, it will match "any IPv4 or any IPv6 address".
	DestinationAddress BaseIpAddress `xml:"destinationAddress,omitempty,typeattr" json:"destinationAddress,omitempty"`
	// Protocols like TCP, UDP, ICMP etc.
	//
	// The valid value for a protocol
	// is got from IANA assigned value for the protocol. This can be got
	// from RFC 5237 and IANA website section related to protocol numbers.
	Protocol *IntExpression `xml:"protocol,omitempty" json:"protocol,omitempty"`
	// Source IP Port.
	SourceIpPort BaseDvsIpPort `xml:"sourceIpPort,omitempty,typeattr" json:"sourceIpPort,omitempty"`
	// Destination IP Port.
	DestinationIpPort BaseDvsIpPort `xml:"destinationIpPort,omitempty,typeattr" json:"destinationIpPort,omitempty"`
	// TCP flags.
	//
	// The valid values can be found at RFC 3168.
	// TCP flags are not supported by Traffic Filtering
	TcpFlags *IntExpression `xml:"tcpFlags,omitempty" json:"tcpFlags,omitempty"`
}

func init() {
	t["DvsIpNetworkRuleQualifier"] = reflect.TypeOf((*DvsIpNetworkRuleQualifier)(nil)).Elem()
}

// Base class for specifying Ports.
//
// Objects of the base class represent any port (single/range/list).
type DvsIpPort struct {
	NegatableExpression
}

func init() {
	t["DvsIpPort"] = reflect.TypeOf((*DvsIpPort)(nil)).Elem()
}

// This class defines a range of Ports.
type DvsIpPortRange struct {
	DvsIpPort

	// Starting port number of the ports range.
	StartPortNumber int32 `xml:"startPortNumber" json:"startPortNumber"`
	// Ending port number of the ports range.
	EndPortNumber int32 `xml:"endPortNumber" json:"endPortNumber"`
}

func init() {
	t["DvsIpPortRange"] = reflect.TypeOf((*DvsIpPortRange)(nil)).Elem()
}

// This class defines network rule action to just log the rule.
type DvsLogNetworkRuleAction struct {
	DvsNetworkRuleAction
}

func init() {
	t["DvsLogNetworkRuleAction"] = reflect.TypeOf((*DvsLogNetworkRuleAction)(nil)).Elem()
}

// This class defines the MAC Rule Qualifier.
//
// Here MAC addresses of source
// and destination will be used for classifying packets.
type DvsMacNetworkRuleQualifier struct {
	DvsNetworkRuleQualifier

	// MAC address for source.
	//
	// If this property is NULL, it will match "any MAC address".
	SourceAddress BaseMacAddress `xml:"sourceAddress,omitempty,typeattr" json:"sourceAddress,omitempty"`
	// MAC address for destination.
	//
	// If this property is NULL, it will match "any MAC address".
	DestinationAddress BaseMacAddress `xml:"destinationAddress,omitempty,typeattr" json:"destinationAddress,omitempty"`
	// Protocol used.
	//
	// This corresponds to the EtherType field in Ethernet
	// frame. The valid values can be found from IEEE list at:
	// http://standards.ieee.org/regauth/ as mentioned in RFC 5342.
	Protocol *IntExpression `xml:"protocol,omitempty" json:"protocol,omitempty"`
	// vlan id.
	VlanId *IntExpression `xml:"vlanId,omitempty" json:"vlanId,omitempty"`
}

func init() {
	t["DvsMacNetworkRuleQualifier"] = reflect.TypeOf((*DvsMacNetworkRuleQualifier)(nil)).Elem()
}

// This class defines network rule action to MAC Rewrite.
type DvsMacRewriteNetworkRuleAction struct {
	DvsNetworkRuleAction

	// Rewrite Destination MAC with this MAC address.
	RewriteMac string `xml:"rewriteMac" json:"rewriteMac"`
}

func init() {
	t["DvsMacRewriteNetworkRuleAction"] = reflect.TypeOf((*DvsMacRewriteNetworkRuleAction)(nil)).Elem()
}

// Two distributed virtual switches was merged.
type DvsMergedEvent struct {
	DvsEvent

	// The source DVS.
	SourceDvs DvsEventArgument `xml:"sourceDvs" json:"sourceDvs"`
	// The destination DVS.
	DestinationDvs DvsEventArgument `xml:"destinationDvs" json:"destinationDvs"`
}

func init() {
	t["DvsMergedEvent"] = reflect.TypeOf((*DvsMergedEvent)(nil)).Elem()
}

// This class is the base class for network rule action.
type DvsNetworkRuleAction struct {
	DynamicData
}

func init() {
	t["DvsNetworkRuleAction"] = reflect.TypeOf((*DvsNetworkRuleAction)(nil)).Elem()
}

// This class is the base class for identifying network traffic.
type DvsNetworkRuleQualifier struct {
	DynamicData

	// The key of the Qualifier
	Key string `xml:"key,omitempty" json:"key,omitempty"`
}

func init() {
	t["DvsNetworkRuleQualifier"] = reflect.TypeOf((*DvsNetworkRuleQualifier)(nil)).Elem()
}

// Thrown if
// `DVSCapability.dvsOperationSupported`
// is false and `DVSConfigInfo.extensionKey` is not same
// as the extension key of the login-session.
type DvsNotAuthorized struct {
	DvsFault

	// The extension key associated with the user-session.
	SessionExtensionKey string `xml:"sessionExtensionKey,omitempty" json:"sessionExtensionKey,omitempty"`
	// The value of `DVSConfigInfo.extensionKey`.
	DvsExtensionKey string `xml:"dvsExtensionKey,omitempty" json:"dvsExtensionKey,omitempty"`
}

func init() {
	t["DvsNotAuthorized"] = reflect.TypeOf((*DvsNotAuthorized)(nil)).Elem()
}

type DvsNotAuthorizedFault DvsNotAuthorized

func init() {
	t["DvsNotAuthorizedFault"] = reflect.TypeOf((*DvsNotAuthorizedFault)(nil)).Elem()
}

// Thrown if a DistributedVirtualSwitch operation failed on some of the host members.
type DvsOperationBulkFault struct {
	DvsFault

	// Faults occurred on the host during a DistributedVirtualSwitch operation.
	HostFault []DvsOperationBulkFaultFaultOnHost `xml:"hostFault" json:"hostFault"`
}

func init() {
	t["DvsOperationBulkFault"] = reflect.TypeOf((*DvsOperationBulkFault)(nil)).Elem()
}

type DvsOperationBulkFaultFault DvsOperationBulkFault

func init() {
	t["DvsOperationBulkFaultFault"] = reflect.TypeOf((*DvsOperationBulkFaultFault)(nil)).Elem()
}

// The fault occurred on the host during an operation.
type DvsOperationBulkFaultFaultOnHost struct {
	DynamicData

	// The host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The fault that occurred.
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["DvsOperationBulkFaultFaultOnHost"] = reflect.TypeOf((*DvsOperationBulkFaultFaultOnHost)(nil)).Elem()
}

// The host on which the DVS configuration is different from that
// of Virtual Center server.
type DvsOutOfSyncHostArgument struct {
	DynamicData

	// The host.
	OutOfSyncHost HostEventArgument `xml:"outOfSyncHost" json:"outOfSyncHost"`
	// The DVS configuration parameters that are different between
	// Virtual Center server and the host.
	ConfigParamters []string `xml:"configParamters" json:"configParamters"`
}

func init() {
	t["DvsOutOfSyncHostArgument"] = reflect.TypeOf((*DvsOutOfSyncHostArgument)(nil)).Elem()
}

// A port is blocked in the distributed virtual switch.
type DvsPortBlockedEvent struct {
	DvsEvent

	// The port key.
	PortKey string `xml:"portKey" json:"portKey"`
	// Reason for port's current status
	StatusDetail string `xml:"statusDetail,omitempty" json:"statusDetail,omitempty"`
	// The port runtime information.
	RuntimeInfo *DVPortStatus `xml:"runtimeInfo,omitempty" json:"runtimeInfo,omitempty"`
	// Previous state of the DvsPort.
	//
	// See `DvsEventPortBlockState_enum`
	PrevBlockState string `xml:"prevBlockState,omitempty" json:"prevBlockState,omitempty"`
}

func init() {
	t["DvsPortBlockedEvent"] = reflect.TypeOf((*DvsPortBlockedEvent)(nil)).Elem()
}

// A port is connected in the distributed virtual switch.
type DvsPortConnectedEvent struct {
	DvsEvent

	// The port key.
	PortKey string `xml:"portKey" json:"portKey"`
	// The port's connectee.
	Connectee *DistributedVirtualSwitchPortConnectee `xml:"connectee,omitempty" json:"connectee,omitempty"`
}

func init() {
	t["DvsPortConnectedEvent"] = reflect.TypeOf((*DvsPortConnectedEvent)(nil)).Elem()
}

// New ports are created in the distributed virtual switch.
type DvsPortCreatedEvent struct {
	DvsEvent

	// The key of the ports that are created.
	PortKey []string `xml:"portKey" json:"portKey"`
}

func init() {
	t["DvsPortCreatedEvent"] = reflect.TypeOf((*DvsPortCreatedEvent)(nil)).Elem()
}

// Existing ports are deleted in the distributed virtual switch.
type DvsPortDeletedEvent struct {
	DvsEvent

	// The key of the ports that are deleted.
	PortKey []string `xml:"portKey" json:"portKey"`
}

func init() {
	t["DvsPortDeletedEvent"] = reflect.TypeOf((*DvsPortDeletedEvent)(nil)).Elem()
}

// A port is disconnected in the distributed virtual switch.
type DvsPortDisconnectedEvent struct {
	DvsEvent

	// The port key.
	PortKey string `xml:"portKey" json:"portKey"`
	// The port's formal connectee.
	Connectee *DistributedVirtualSwitchPortConnectee `xml:"connectee,omitempty" json:"connectee,omitempty"`
}

func init() {
	t["DvsPortDisconnectedEvent"] = reflect.TypeOf((*DvsPortDisconnectedEvent)(nil)).Elem()
}

// A port has entered passthrough mode on the distributed virtual switch.
type DvsPortEnteredPassthruEvent struct {
	DvsEvent

	// The port key.
	PortKey string `xml:"portKey" json:"portKey"`
	// The port runtime information.
	RuntimeInfo *DVPortStatus `xml:"runtimeInfo,omitempty" json:"runtimeInfo,omitempty"`
}

func init() {
	t["DvsPortEnteredPassthruEvent"] = reflect.TypeOf((*DvsPortEnteredPassthruEvent)(nil)).Elem()
}

// A port has exited passthrough mode on the distributed virtual switch.
type DvsPortExitedPassthruEvent struct {
	DvsEvent

	// The port key.
	PortKey string `xml:"portKey" json:"portKey"`
	// The port runtime information.
	RuntimeInfo *DVPortStatus `xml:"runtimeInfo,omitempty" json:"runtimeInfo,omitempty"`
}

func init() {
	t["DvsPortExitedPassthruEvent"] = reflect.TypeOf((*DvsPortExitedPassthruEvent)(nil)).Elem()
}

// A port was moved into the distributed virtual portgroup.
type DvsPortJoinPortgroupEvent struct {
	DvsEvent

	// The port key.
	PortKey string `xml:"portKey" json:"portKey"`
	// The portgroup key.
	PortgroupKey string `xml:"portgroupKey" json:"portgroupKey"`
	// The portgroup name.
	PortgroupName string `xml:"portgroupName" json:"portgroupName"`
}

func init() {
	t["DvsPortJoinPortgroupEvent"] = reflect.TypeOf((*DvsPortJoinPortgroupEvent)(nil)).Elem()
}

// A port was moved out of the distributed virtual portgroup.
type DvsPortLeavePortgroupEvent struct {
	DvsEvent

	// The port key.
	PortKey string `xml:"portKey" json:"portKey"`
	// The portgroup key.
	PortgroupKey string `xml:"portgroupKey" json:"portgroupKey"`
	// The portgroup name.
	PortgroupName string `xml:"portgroupName" json:"portgroupName"`
}

func init() {
	t["DvsPortLeavePortgroupEvent"] = reflect.TypeOf((*DvsPortLeavePortgroupEvent)(nil)).Elem()
}

// A port of which link status is changed to down in the distributed
// virtual switch.
type DvsPortLinkDownEvent struct {
	DvsEvent

	// The port key.
	PortKey string `xml:"portKey" json:"portKey"`
	// The port runtime information.
	RuntimeInfo *DVPortStatus `xml:"runtimeInfo,omitempty" json:"runtimeInfo,omitempty"`
}

func init() {
	t["DvsPortLinkDownEvent"] = reflect.TypeOf((*DvsPortLinkDownEvent)(nil)).Elem()
}

// A port of which link status is changed to up in the distributed
// virtual switch.
type DvsPortLinkUpEvent struct {
	DvsEvent

	// The port key.
	PortKey string `xml:"portKey" json:"portKey"`
	// The port runtime information.
	RuntimeInfo *DVPortStatus `xml:"runtimeInfo,omitempty" json:"runtimeInfo,omitempty"`
}

func init() {
	t["DvsPortLinkUpEvent"] = reflect.TypeOf((*DvsPortLinkUpEvent)(nil)).Elem()
}

// Existing ports are reconfigured in the distributed virtual switch.
type DvsPortReconfiguredEvent struct {
	DvsEvent

	// The key of the ports that are reconfigured.
	PortKey []string `xml:"portKey" json:"portKey"`
	// The configuration values changed during the reconfiguration.
	ConfigChanges []ChangesInfoEventArgument `xml:"configChanges,omitempty" json:"configChanges,omitempty"`
}

func init() {
	t["DvsPortReconfiguredEvent"] = reflect.TypeOf((*DvsPortReconfiguredEvent)(nil)).Elem()
}

// A port of which runtime information is changed in the vNetwork Distributed
// Switch.
type DvsPortRuntimeChangeEvent struct {
	DvsEvent

	// The port key.
	PortKey string `xml:"portKey" json:"portKey"`
	// The new port runtime information.
	RuntimeInfo DVPortStatus `xml:"runtimeInfo" json:"runtimeInfo"`
}

func init() {
	t["DvsPortRuntimeChangeEvent"] = reflect.TypeOf((*DvsPortRuntimeChangeEvent)(nil)).Elem()
}

// A port is unblocked in the distributed virtual switch.
type DvsPortUnblockedEvent struct {
	DvsEvent

	// The port key.
	PortKey string `xml:"portKey" json:"portKey"`
	// The port runtime information.
	RuntimeInfo *DVPortStatus `xml:"runtimeInfo,omitempty" json:"runtimeInfo,omitempty"`
	// Previous state of the DvsPort.
	//
	// See `DvsEventPortBlockState_enum`
	PrevBlockState string `xml:"prevBlockState,omitempty" json:"prevBlockState,omitempty"`
}

func init() {
	t["DvsPortUnblockedEvent"] = reflect.TypeOf((*DvsPortUnblockedEvent)(nil)).Elem()
}

// A port of which vendor specific state is changed in the vNetwork Distributed
// Switch.
type DvsPortVendorSpecificStateChangeEvent struct {
	DvsEvent

	// The port key.
	PortKey string `xml:"portKey" json:"portKey"`
}

func init() {
	t["DvsPortVendorSpecificStateChangeEvent"] = reflect.TypeOf((*DvsPortVendorSpecificStateChangeEvent)(nil)).Elem()
}

// The `DvsProfile` data object represents the distributed virtual switch
// to which this host is connected.
//
// If a profile plug-in defines policies or subprofiles,
// use the `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the additional configuration data.
type DvsProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
	// Unique identifier for the distributed virtual switch.
	Name string `xml:"name" json:"name"`
	// List of subprofiles that map physical NICs to uplink ports.
	//
	// Use the `PnicUplinkProfile.key` property to access
	// subprofiles in the list.
	Uplink []PnicUplinkProfile `xml:"uplink,omitempty" json:"uplink,omitempty"`
}

func init() {
	t["DvsProfile"] = reflect.TypeOf((*DvsProfile)(nil)).Elem()
}

// This class defines network rule action to punt.
//
// i.e, forward packets
// to an associated slow-path service Virtual Machine.
type DvsPuntNetworkRuleAction struct {
	DvsNetworkRuleAction
}

func init() {
	t["DvsPuntNetworkRuleAction"] = reflect.TypeOf((*DvsPuntNetworkRuleAction)(nil)).Elem()
}

// This class defines network rule action to ratelimit packets.
type DvsRateLimitNetworkRuleAction struct {
	DvsNetworkRuleAction

	// Rate limit value specified in packets per second.
	PacketsPerSecond int32 `xml:"packetsPerSecond" json:"packetsPerSecond"`
}

func init() {
	t["DvsRateLimitNetworkRuleAction"] = reflect.TypeOf((*DvsRateLimitNetworkRuleAction)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.DvsReconfigureVmVnicNetworkResourcePool_Task`.
type DvsReconfigureVmVnicNetworkResourcePoolRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The Virtual NIC network resource pool configuration specification and operation type.
	ConfigSpec []DvsVmVnicResourcePoolConfigSpec `xml:"configSpec" json:"configSpec"`
}

func init() {
	t["DvsReconfigureVmVnicNetworkResourcePoolRequestType"] = reflect.TypeOf((*DvsReconfigureVmVnicNetworkResourcePoolRequestType)(nil)).Elem()
}

type DvsReconfigureVmVnicNetworkResourcePool_Task DvsReconfigureVmVnicNetworkResourcePoolRequestType

func init() {
	t["DvsReconfigureVmVnicNetworkResourcePool_Task"] = reflect.TypeOf((*DvsReconfigureVmVnicNetworkResourcePool_Task)(nil)).Elem()
}

type DvsReconfigureVmVnicNetworkResourcePool_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// A distributed virtual switch was reconfigured.
type DvsReconfiguredEvent struct {
	DvsEvent

	// The reconfiguration spec.
	ConfigSpec BaseDVSConfigSpec `xml:"configSpec,typeattr" json:"configSpec"`
	// The configuration values changed during the reconfiguration.
	ConfigChanges *ChangesInfoEventArgument `xml:"configChanges,omitempty" json:"configChanges,omitempty"`
}

func init() {
	t["DvsReconfiguredEvent"] = reflect.TypeOf((*DvsReconfiguredEvent)(nil)).Elem()
}

// A distributed virtual switch was renamed.
type DvsRenamedEvent struct {
	DvsEvent

	// The old DistributedVirtualSwitch name.
	OldName string `xml:"oldName" json:"oldName"`
	// The new DistributedVirtualSwitch name.
	NewName string `xml:"newName" json:"newName"`
}

func init() {
	t["DvsRenamedEvent"] = reflect.TypeOf((*DvsRenamedEvent)(nil)).Elem()
}

// This class defines the bandwidth reservation information for the
// vSphere Distributed Switch.
type DvsResourceRuntimeInfo struct {
	DynamicData

	// Capacity: Total Reservation allocated for Virtual Machine
	// Traffic for this switch.
	//
	// Units in Mbits/s.
	Capacity int32 `xml:"capacity,omitempty" json:"capacity,omitempty"`
	// usage: Current total usage.
	//
	// This is the sum of all reservations
	// allocated to `DVSVmVnicNetworkResourcePool` on this switch and the
	// sum of reservation taken by `VirtualEthernetCard` whose
	// backing is not associdated with any `DVSVmVnicNetworkResourcePool`.
	// Units in Mbits/s.
	Usage int32 `xml:"usage,omitempty" json:"usage,omitempty"`
	// Available: Current available resource for reservation (capacity - usage).
	//
	// Units in Mbits/s.
	Available int32 `xml:"available,omitempty" json:"available,omitempty"`
	// The reservation taken by `VirtualEthernetCard` of which the
	// backing is not associdated with any `DVSVmVnicNetworkResourcePool`
	AllocatedResource []DvsVnicAllocatedResource `xml:"allocatedResource,omitempty" json:"allocatedResource,omitempty"`
	// The runtime information of `DVSVmVnicNetworkResourcePool`.
	VmVnicNetworkResourcePoolRuntime []DvsVmVnicNetworkResourcePoolRuntimeInfo `xml:"vmVnicNetworkResourcePoolRuntime,omitempty" json:"vmVnicNetworkResourcePoolRuntime,omitempty"`
}

func init() {
	t["DvsResourceRuntimeInfo"] = reflect.TypeOf((*DvsResourceRuntimeInfo)(nil)).Elem()
}

// This event is generated when a restore operation is
// performed on a distributed virtual switch
type DvsRestoreEvent struct {
	DvsEvent
}

func init() {
	t["DvsRestoreEvent"] = reflect.TypeOf((*DvsRestoreEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 5.5.
//
// Thrown if a entity trying to connect to a port or portgroup but it is not in the
// port or portgroup's scope.
type DvsScopeViolated struct {
	DvsFault

	// The configured scope.
	//
	// Refers instances of `ManagedEntity`.
	Scope []ManagedObjectReference `xml:"scope" json:"scope"`
	// The entity that violates the scope.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["DvsScopeViolated"] = reflect.TypeOf((*DvsScopeViolated)(nil)).Elem()
}

type DvsScopeViolatedFault DvsScopeViolated

func init() {
	t["DvsScopeViolatedFault"] = reflect.TypeOf((*DvsScopeViolatedFault)(nil)).Elem()
}

// The `DvsServiceConsoleVNicProfile` data object describes the IP configuration
// for a service console Virtual NIC connected to a distributed virtual switch.
//
// The `DvsVNicProfile.ipConfig` property contains the Virtual NIC IP address.
// If a profile plug-in defines policies or subprofiles, use the
// `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the additional configuration data.
type DvsServiceConsoleVNicProfile struct {
	DvsVNicProfile
}

func init() {
	t["DvsServiceConsoleVNicProfile"] = reflect.TypeOf((*DvsServiceConsoleVNicProfile)(nil)).Elem()
}

// This class defines a Single Port
type DvsSingleIpPort struct {
	DvsIpPort

	// The IP port number.
	PortNumber int32 `xml:"portNumber" json:"portNumber"`
}

func init() {
	t["DvsSingleIpPort"] = reflect.TypeOf((*DvsSingleIpPort)(nil)).Elem()
}

// This class defines the System Traffic Qualifier.
//
// Here the type of
// traffic will be used for classifying packets.
type DvsSystemTrafficNetworkRuleQualifier struct {
	DvsNetworkRuleQualifier

	// Type of system traffic.
	//
	// See `DistributedVirtualSwitchHostInfrastructureTrafficClass_enum`
	// for valid values.
	TypeOfSystemTraffic *StringExpression `xml:"typeOfSystemTraffic,omitempty" json:"typeOfSystemTraffic,omitempty"`
}

func init() {
	t["DvsSystemTrafficNetworkRuleQualifier"] = reflect.TypeOf((*DvsSystemTrafficNetworkRuleQualifier)(nil)).Elem()
}

// This class defines Traffic Filter configuration.
//
// ** Supported Qualifier and Actions **
// <table border="1"width="100%">
// <tr>
// <th>Traffic Filter Config</th>
// <th>Supported classes</th>
// </tr>
// <tr>
// <td>Qualifiers supported</td>
// <td>`SingleIp`, `IpRange`,
// `SingleMac`, `MacRange`,
// `DvsSingleIpPort`,
// `DvsSystemTrafficNetworkRuleQualifier`
// </td>
// </tr>
// <tr>
// <td>Actions Supported</td>
// <td>`DvsDropNetworkRuleAction`,
// `DvsAcceptNetworkRuleAction`,
// `DvsPuntNetworkRuleAction`,
// `DvsCopyNetworkRuleAction`,
// `DvsMacRewriteNetworkRuleAction`,
// `DvsGreEncapNetworkRuleAction`,
// `DvsLogNetworkRuleAction`,
// `DvsUpdateTagNetworkRuleAction`,
// `DvsRateLimitNetworkRuleAction`
// </td>
// </tr>
type DvsTrafficFilterConfig struct {
	DvsFilterConfig

	// Network Traffic Ruleset
	TrafficRuleset *DvsTrafficRuleset `xml:"trafficRuleset,omitempty" json:"trafficRuleset,omitempty"`
}

func init() {
	t["DvsTrafficFilterConfig"] = reflect.TypeOf((*DvsTrafficFilterConfig)(nil)).Elem()
}

// The specification to reconfigure Traffic Filter.
//
// This specification allows the user to do fine-grained updates for the
// Traffic Filter in the port settings.
// If the operation is `remove`, only the
// `DistributedVirtualPort.key` needs to be specified.
// If other fields are specified, they will be ignored. We cannot remove
// an inherited element. Only when the inherited flag is set to false and
// parent does not have an element with same key this operation succeeds.
// If the operation is `add`, then
// `DistributedVirtualPort.key` should not be specified and
// other fields need to be specified. The inherited flag should be set to
// false.
// If the operation is `edit`, then
// `DistributedVirtualPort.key` needs be specified and
// specify the other properties that need modification. If the inherited
// flag is set to true, a `DvsTrafficFilterConfig` object of same
// key must exist at the parent's level. The property values in the spec
// object will be ignored and use the values from the parent's
// `DvsTrafficFilterConfig` object instead. If inherited
// flag is set to false, then the new modifications will be applied.
type DvsTrafficFilterConfigSpec struct {
	DvsTrafficFilterConfig

	// Operation type.
	//
	// See `ConfigSpecOperation_enum` for valid values.
	Operation string `xml:"operation" json:"operation"`
}

func init() {
	t["DvsTrafficFilterConfigSpec"] = reflect.TypeOf((*DvsTrafficFilterConfigSpec)(nil)).Elem()
}

// This class defines a single rule that will be applied to network traffic.
type DvsTrafficRule struct {
	DynamicData

	// The key of the rule
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// Description of the rule
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// Sequence of this rule.
	//
	// i.e, the order in which this rule appears
	// in the ruleset.
	Sequence int32 `xml:"sequence,omitempty" json:"sequence,omitempty"`
	// List of Network rule qualifiers.
	//
	// 'AND' of this array of
	// network rule qualifiers is applied as one network traffic rule.
	// If the TrafficRule belongs to
	// `DvsFilterPolicy` :
	// There can be a maximum of 1 `DvsIpNetworkRuleQualifier`,
	// 1 `DvsMacNetworkRuleQualifier` and
	// 1 `DvsSystemTrafficNetworkRuleQualifier` for a total of
	// 3 `DvsTrafficRule.qualifier`
	Qualifier []BaseDvsNetworkRuleQualifier `xml:"qualifier,omitempty,typeattr" json:"qualifier,omitempty"`
	// Action to be applied for this rule.
	Action BaseDvsNetworkRuleAction `xml:"action,omitempty,typeattr" json:"action,omitempty"`
	// Whether this rule needs to be applied to incoming packets,
	// to outgoing packets or both.
	//
	// See `DvsNetworkRuleDirectionType_enum` for valid values.
	Direction string `xml:"direction,omitempty" json:"direction,omitempty"`
}

func init() {
	t["DvsTrafficRule"] = reflect.TypeOf((*DvsTrafficRule)(nil)).Elem()
}

// This class defines a ruleset(set of rules) that will be
// applied to network traffic.
type DvsTrafficRuleset struct {
	DynamicData

	// The key of the ruleset.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// Whether ruleset is enabled or not.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Precedence of the ruleset.
	//
	// Rulesets for a port will be executed
	// in the order of their precedence.
	Precedence int32 `xml:"precedence,omitempty" json:"precedence,omitempty"`
	// List of rules belonging to this ruleset.
	Rules []DvsTrafficRule `xml:"rules,omitempty" json:"rules,omitempty"`
}

func init() {
	t["DvsTrafficRuleset"] = reflect.TypeOf((*DvsTrafficRuleset)(nil)).Elem()
}

// This class defines network rule action to tag packets(qos,dscp) or
// clear tags(clear qos, dscp tags) on packets.
//
// One or both of qos and dscp may be specified.
type DvsUpdateTagNetworkRuleAction struct {
	DvsNetworkRuleAction

	// QOS tag.
	//
	// IEEE 802.1p supports 3 bit Priority Code Point (PCP).
	// The valid values are between 0-7. Please refer the IEEE 802.1p
	// documentation for more details about what each value represents.
	// If qosTag is set to 0 then the tag on the packets will be cleared.
	QosTag int32 `xml:"qosTag,omitempty" json:"qosTag,omitempty"`
	// DSCP tag.
	//
	// The valid values for DSCP tag can be found in
	// 'Differentiated Services Field Codepoints' section of IANA website.
	// The information can also be got from reading all of the below RFC:
	// RFC 2474, RFC 2597, RFC 3246, RFC 5865.
	// If the dscpTag is set to 0 then the dscp tag on packets will be cleared.
	DscpTag int32 `xml:"dscpTag,omitempty" json:"dscpTag,omitempty"`
}

func init() {
	t["DvsUpdateTagNetworkRuleAction"] = reflect.TypeOf((*DvsUpdateTagNetworkRuleAction)(nil)).Elem()
}

// An upgrade for the distributed virtual switch is available.
type DvsUpgradeAvailableEvent struct {
	DvsEvent

	// The product info of the upgrade.
	ProductInfo DistributedVirtualSwitchProductSpec `xml:"productInfo" json:"productInfo"`
}

func init() {
	t["DvsUpgradeAvailableEvent"] = reflect.TypeOf((*DvsUpgradeAvailableEvent)(nil)).Elem()
}

// An upgrade for the distributed virtual switch is in progress.
type DvsUpgradeInProgressEvent struct {
	DvsEvent

	// The product info of the upgrade.
	ProductInfo DistributedVirtualSwitchProductSpec `xml:"productInfo" json:"productInfo"`
}

func init() {
	t["DvsUpgradeInProgressEvent"] = reflect.TypeOf((*DvsUpgradeInProgressEvent)(nil)).Elem()
}

// An upgrade for the distributed virtual switch is rejected.
type DvsUpgradeRejectedEvent struct {
	DvsEvent

	// The product info of the upgrade.
	ProductInfo DistributedVirtualSwitchProductSpec `xml:"productInfo" json:"productInfo"`
}

func init() {
	t["DvsUpgradeRejectedEvent"] = reflect.TypeOf((*DvsUpgradeRejectedEvent)(nil)).Elem()
}

// The distributed virtual switch was upgraded.
type DvsUpgradedEvent struct {
	DvsEvent

	// The product info of the upgrade.
	ProductInfo DistributedVirtualSwitchProductSpec `xml:"productInfo" json:"productInfo"`
}

func init() {
	t["DvsUpgradedEvent"] = reflect.TypeOf((*DvsUpgradedEvent)(nil)).Elem()
}

// The `DvsVNicProfile` data object is the base object
// for host and service console Virtual NIC subprofiles.
//
// If a profile plug-in defines additional policies or subprofiles, use the
// `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the configuration data.
type DvsVNicProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
	// IP address for the Virtual NIC belonging to a distributed virtual switch.
	IpConfig IpAddressProfile `xml:"ipConfig" json:"ipConfig"`
}

func init() {
	t["DvsVNicProfile"] = reflect.TypeOf((*DvsVNicProfile)(nil)).Elem()
}

// This class defines the runtime information for the
// virtual NIC network resource pool
type DvsVmVnicNetworkResourcePoolRuntimeInfo struct {
	DynamicData

	// The key of the virtual NIC network resource pool
	Key string `xml:"key" json:"key"`
	// The name of the virtual NIC network resource pool
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// Capacity: Reservation allocated for this Network Resource Pool.
	//
	// Units in Mbits/s.
	Capacity int32 `xml:"capacity,omitempty" json:"capacity,omitempty"`
	// usage: Reservation taken by all `VirtualEthernetCard` for which the
	// backing is associdated with this `DVSVmVnicNetworkResourcePool`.
	//
	// Units in Mbits/s.
	Usage int32 `xml:"usage,omitempty" json:"usage,omitempty"`
	// Available: Current available resource for reservation (capacity - usage).
	//
	// Units in Mbits/s.
	Available int32 `xml:"available,omitempty" json:"available,omitempty"`
	// The status of the virtual NIC network resource pool
	// See `ManagedEntityStatus_enum` for possible values
	//
	// `red` indicates that the
	// reservations used by all the virtual network adapters belonging
	// to this resource pool exceeds the total reservation quota allocated to the
	// resource pool. This can happen due to failure of one or more uplink
	// or if the user bypasses VirtualCenter and powers on VMs directly on host.
	// The reservation of one or more virtual network adapters cannot be guaranteed
	// and corrective action needs to be taken by the user.
	//
	// `green` indicates that the resource pool
	// is in good state. The reservations for all virtual network adapters can
	// be fulfilled.
	Status string `xml:"status" json:"status"`
	// The virtual network adapaters that
	// are currently associated with the resource pool
	AllocatedResource []DvsVnicAllocatedResource `xml:"allocatedResource,omitempty" json:"allocatedResource,omitempty"`
}

func init() {
	t["DvsVmVnicNetworkResourcePoolRuntimeInfo"] = reflect.TypeOf((*DvsVmVnicNetworkResourcePoolRuntimeInfo)(nil)).Elem()
}

// Resource allocation information for a virtual NIC network resource pool.
type DvsVmVnicResourceAllocation struct {
	DynamicData

	// Quota for the total amount of virtual machine nic reservation in this pool.
	//
	// Unit in Mbits/sec.
	ReservationQuota int64 `xml:"reservationQuota,omitempty" json:"reservationQuota,omitempty"`
}

func init() {
	t["DvsVmVnicResourceAllocation"] = reflect.TypeOf((*DvsVmVnicResourceAllocation)(nil)).Elem()
}

// The configuration specification data object to update the resource configuration
// for a virtual NIC network resource pool.
type DvsVmVnicResourcePoolConfigSpec struct {
	DynamicData

	// The type of operation on the virtual NIC network resource pool
	// Possible value can be of
	// `ConfigSpecOperation_enum`
	Operation string `xml:"operation" json:"operation"`
	// The key of the network resource pool.
	//
	// The property is ignored for add
	// operations.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// The configVersion is a unique identifier for a given version
	// of the configuration.
	//
	// Each change to the configuration will
	// update this value. This is typically implemented as a
	// non-decreasing count or a time-stamp. However, a client should
	// always treat this as an opaque string.
	//
	// If specified when updating the resource configuration, the
	// changes will only be applied if the current configVersion matches the
	// specified configVersion. This field can be used to guard against
	// updates that that may have occurred between the time when configVersion
	// was read and when it is applied.
	ConfigVersion string `xml:"configVersion,omitempty" json:"configVersion,omitempty"`
	// The resource allocation for the virtual NIC network resource pool.
	AllocationInfo *DvsVmVnicResourceAllocation `xml:"allocationInfo,omitempty" json:"allocationInfo,omitempty"`
	// The name for the virtual NIC network resource pool.
	//
	// The property is required for Add operations.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// The description for the virtual NIC network resource pool.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
}

func init() {
	t["DvsVmVnicResourcePoolConfigSpec"] = reflect.TypeOf((*DvsVmVnicResourcePoolConfigSpec)(nil)).Elem()
}

// This class defines the allocated resource information on a virtual NIC
type DvsVnicAllocatedResource struct {
	DynamicData

	// The virtual machine
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The virtual NIC key
	VnicKey string `xml:"vnicKey" json:"vnicKey"`
	// The reservation specification on the virtual NIC.
	//
	// Units in Mbits/s
	Reservation *int64 `xml:"reservation" json:"reservation,omitempty"`
}

func init() {
	t["DvsVnicAllocatedResource"] = reflect.TypeOf((*DvsVnicAllocatedResource)(nil)).Elem()
}

// DynamicArray is a data object type that represents an array of dynamically-typed
// objects.
//
// A client should only see a DynamicArray object when the element type
// is unknown (meaning the type is newer than the client). Otherwise, a client would
// see the type as T\[\] where T is known.
type DynamicArray struct {
	// Array of dynamic values.
	Val []AnyType `xml:"val,typeattr" json:"val"`
}

func init() {
	t["DynamicArray"] = reflect.TypeOf((*DynamicArray)(nil)).Elem()
}

type DynamicData struct {
}

func init() {
	t["DynamicData"] = reflect.TypeOf((*DynamicData)(nil)).Elem()
}

// The DynamicProperty data object type represents a name-value pair.
type DynamicProperty struct {
	// Path to the property.
	Name string `xml:"name" json:"name"`
	// Value of the property.
	Val AnyType `xml:"val,typeattr" json:"val"`
}

func init() {
	t["DynamicProperty"] = reflect.TypeOf((*DynamicProperty)(nil)).Elem()
}

// The host does not satisfy the admission requirements for the Enhanced
// VMotion Compatibility mode of the cluster.
type EVCAdmissionFailed struct {
	NotSupportedHostInCluster

	// The faults that caused this EVC test to fail
	// (e.g.
	//
	// FeatureRequirementsNotMet faults).
	Faults []LocalizedMethodFault `xml:"faults,omitempty" json:"faults,omitempty"`
}

func init() {
	t["EVCAdmissionFailed"] = reflect.TypeOf((*EVCAdmissionFailed)(nil)).Elem()
}

// The host's CPU hardware is a family/model that should support the
// Enhanced VMotion Compatibility mode of the cluster, but some necessary
// CPU features are not present.
type EVCAdmissionFailedCPUFeaturesForMode struct {
	EVCAdmissionFailed

	// The Enhanced VMotion Compatibility mode that is currently in effect for
	// the cluster.
	CurrentEVCModeKey string `xml:"currentEVCModeKey" json:"currentEVCModeKey"`
}

func init() {
	t["EVCAdmissionFailedCPUFeaturesForMode"] = reflect.TypeOf((*EVCAdmissionFailedCPUFeaturesForMode)(nil)).Elem()
}

type EVCAdmissionFailedCPUFeaturesForModeFault EVCAdmissionFailedCPUFeaturesForMode

func init() {
	t["EVCAdmissionFailedCPUFeaturesForModeFault"] = reflect.TypeOf((*EVCAdmissionFailedCPUFeaturesForModeFault)(nil)).Elem()
}

// The host's CPU hardware is a family/model that does not support any
// Enhanced VMotion Compatibility mode.
type EVCAdmissionFailedCPUModel struct {
	EVCAdmissionFailed
}

func init() {
	t["EVCAdmissionFailedCPUModel"] = reflect.TypeOf((*EVCAdmissionFailedCPUModel)(nil)).Elem()
}

type EVCAdmissionFailedCPUModelFault EVCAdmissionFailedCPUModel

func init() {
	t["EVCAdmissionFailedCPUModelFault"] = reflect.TypeOf((*EVCAdmissionFailedCPUModelFault)(nil)).Elem()
}

// The host's CPU hardware is a family/model that does not support the Enhanced
// VMotion Compatibility mode of the cluster.
type EVCAdmissionFailedCPUModelForMode struct {
	EVCAdmissionFailed

	// The Enhanced VMotion Compatibility mode that is currently in effect for
	// the cluster.
	CurrentEVCModeKey string `xml:"currentEVCModeKey" json:"currentEVCModeKey"`
}

func init() {
	t["EVCAdmissionFailedCPUModelForMode"] = reflect.TypeOf((*EVCAdmissionFailedCPUModelForMode)(nil)).Elem()
}

type EVCAdmissionFailedCPUModelForModeFault EVCAdmissionFailedCPUModelForMode

func init() {
	t["EVCAdmissionFailedCPUModelForModeFault"] = reflect.TypeOf((*EVCAdmissionFailedCPUModelForModeFault)(nil)).Elem()
}

// The host's CPU vendor does not match the required CPU vendor for the
// Enhanced VMotion Compatibility mode of the cluster.
type EVCAdmissionFailedCPUVendor struct {
	EVCAdmissionFailed

	// The CPU vendor required for entering the cluster.
	ClusterCPUVendor string `xml:"clusterCPUVendor" json:"clusterCPUVendor"`
	// The CPU vendor of the host.
	HostCPUVendor string `xml:"hostCPUVendor" json:"hostCPUVendor"`
}

func init() {
	t["EVCAdmissionFailedCPUVendor"] = reflect.TypeOf((*EVCAdmissionFailedCPUVendor)(nil)).Elem()
}

type EVCAdmissionFailedCPUVendorFault EVCAdmissionFailedCPUVendor

func init() {
	t["EVCAdmissionFailedCPUVendorFault"] = reflect.TypeOf((*EVCAdmissionFailedCPUVendorFault)(nil)).Elem()
}

// The host's CPU vendor is unknown, which prevents admission into an Enhanced
// VMotion Compatibility cluster.
type EVCAdmissionFailedCPUVendorUnknown struct {
	EVCAdmissionFailed
}

func init() {
	t["EVCAdmissionFailedCPUVendorUnknown"] = reflect.TypeOf((*EVCAdmissionFailedCPUVendorUnknown)(nil)).Elem()
}

type EVCAdmissionFailedCPUVendorUnknownFault EVCAdmissionFailedCPUVendorUnknown

func init() {
	t["EVCAdmissionFailedCPUVendorUnknownFault"] = reflect.TypeOf((*EVCAdmissionFailedCPUVendorUnknownFault)(nil)).Elem()
}

type EVCAdmissionFailedFault BaseEVCAdmissionFailed

func init() {
	t["EVCAdmissionFailedFault"] = reflect.TypeOf((*EVCAdmissionFailedFault)(nil)).Elem()
}

// The host is not connected, which prevents admission into an Enhanced
// VMotion Compatibility cluster.
type EVCAdmissionFailedHostDisconnected struct {
	EVCAdmissionFailed
}

func init() {
	t["EVCAdmissionFailedHostDisconnected"] = reflect.TypeOf((*EVCAdmissionFailedHostDisconnected)(nil)).Elem()
}

type EVCAdmissionFailedHostDisconnectedFault EVCAdmissionFailedHostDisconnected

func init() {
	t["EVCAdmissionFailedHostDisconnectedFault"] = reflect.TypeOf((*EVCAdmissionFailedHostDisconnectedFault)(nil)).Elem()
}

// The host's software does not support any Enhanced VMotion Compatibility mode.
type EVCAdmissionFailedHostSoftware struct {
	EVCAdmissionFailed
}

func init() {
	t["EVCAdmissionFailedHostSoftware"] = reflect.TypeOf((*EVCAdmissionFailedHostSoftware)(nil)).Elem()
}

type EVCAdmissionFailedHostSoftwareFault EVCAdmissionFailedHostSoftware

func init() {
	t["EVCAdmissionFailedHostSoftwareFault"] = reflect.TypeOf((*EVCAdmissionFailedHostSoftwareFault)(nil)).Elem()
}

// The host's software does not support the Enhanced VMotion Compatibility
// mode of the cluster.
type EVCAdmissionFailedHostSoftwareForMode struct {
	EVCAdmissionFailed
}

func init() {
	t["EVCAdmissionFailedHostSoftwareForMode"] = reflect.TypeOf((*EVCAdmissionFailedHostSoftwareForMode)(nil)).Elem()
}

type EVCAdmissionFailedHostSoftwareForModeFault EVCAdmissionFailedHostSoftwareForMode

func init() {
	t["EVCAdmissionFailedHostSoftwareForModeFault"] = reflect.TypeOf((*EVCAdmissionFailedHostSoftwareForModeFault)(nil)).Elem()
}

// An attempt to move or add a host into an Enhanced VMotion Compatibility
// cluster has failed for the following reason:
//   - The host exposes additional compatibility-relevant CPU features beyond
//     those present in the baseline mandated by the cluster's EVC mode.
//   - The host has powered-on or suspended virtual machines.
//
// Therefore the host may not be admitted into the cluster, since its virtual
// machines may be using CPU features suppressed in the cluster.
//
// Note that in rare cases, this may occur even if the host's
// `maxEVCModeKey` corresponds to the EVC
// mode of the cluster. This means that even though that EVC mode is the best
// match for the host's hardware, the host still has some features beyond
// those present in the baseline for that EVC mode.
type EVCAdmissionFailedVmActive struct {
	EVCAdmissionFailed
}

func init() {
	t["EVCAdmissionFailedVmActive"] = reflect.TypeOf((*EVCAdmissionFailedVmActive)(nil)).Elem()
}

type EVCAdmissionFailedVmActiveFault EVCAdmissionFailedVmActive

func init() {
	t["EVCAdmissionFailedVmActiveFault"] = reflect.TypeOf((*EVCAdmissionFailedVmActiveFault)(nil)).Elem()
}

// An attempt to enable Enhanced VMotion Compatibility on a cluster has failed.
type EVCConfigFault struct {
	VimFault

	// The faults that caused this EVC test to fail,
	// such as `FeatureRequirementsNotMet` faults.
	Faults []LocalizedMethodFault `xml:"faults,omitempty" json:"faults,omitempty"`
}

func init() {
	t["EVCConfigFault"] = reflect.TypeOf((*EVCConfigFault)(nil)).Elem()
}

type EVCConfigFaultFault BaseEVCConfigFault

func init() {
	t["EVCConfigFaultFault"] = reflect.TypeOf((*EVCConfigFaultFault)(nil)).Elem()
}

// The `EVCMode` data object describes an Enhanced vMotion Compatibility mode.
//
// An EVC mode is associated with a set of CPU features. A vCenter Server defines
// the available EVC modes. You use them to establish a common set of features
// for compatibility between hosts in a cluster. An EVC-enabled cluster supports
// safe vMotion of virtual machines across a range of CPU generations.
// You must use the vSphere Client to configure EVC.
//
// When you add a host to an EVC-enabled cluster, the vCenter Server determines
// the CPU compatibility to preserve vMotion compatibility within the cluster.
// If the host CPU is compatible with those already in the cluster, the Server
// adds the host to the cluster and configures it for compatible operation.
// Hosts that are not compatible are not allowed to join the cluster.
//
// The inherited `ElementDescription.key` property is a string value
// that uniquely identifies an EVC mode. The vCenter Server assigns
// the key value; the vSphere API uses the key to identify modes
// in summary and information objects:
//   - `ClusterComputeResourceSummary*.*ClusterComputeResourceSummary.currentEVCModeKey`
//   - `HostListSummary*.*HostListSummary.currentEVCModeKey`
//   - `HostListSummary*.*HostListSummary.maxEVCModeKey`
//   - `VirtualMachineRuntimeInfo*.*VirtualMachineRuntimeInfo.minRequiredEVCModeKey`
//
// The inherited `Description.label` and `Description.summary`
// properties are human-readable strings.
//
// You can use the `EVCMode.track` and `EVCMode.vendorTier` properties to determine
// feature-superset relationships between modes without examining the
// individual feature bits in `EVCMode.guaranteedCPUFeatures`.
// The CPU feature baseline of mode A is a superset of mode B's baseline
// if and only if:
//   - modeA.track is the same as or a superset of modeB.track
//   - modeA.vendorTier is equal to or greater than modeB.vendorTier
//
// Use the `EVCMode.track` and `EVCMode.vendorTier` properties only for the
// purpose of feature-superset calculations as described above. Do not use
// them to infer the presence or absence of specific features. The
// property values for a given mode may change across releases
// as the set of available EVC modes changes, to better represent mode
// relationships.
type EVCMode struct {
	ElementDescription

	// Deprecated as of vSphere API 6.5 use `EVCMode.featureCapability`.
	//
	// Describes the CPU feature baseline associated with the EVC mode.
	//
	// On the cluster where a particular EVC mode is configured,
	// those CPU features are guaranteed, either because the host
	// hardware naturally matches those features or because CPU feature override
	// is used to mask out differences and enforce a match.
	GuaranteedCPUFeatures []HostCpuIdInfo `xml:"guaranteedCPUFeatures,omitempty" json:"guaranteedCPUFeatures,omitempty"`
	// Describes the feature capability baseline associated with the EVC mode.
	//
	// On the cluster where a particular EVC mode is configured,
	// these features capabilities are guaranteed, either because the host
	// hardware naturally matches those features or because feature masks
	// are used to mask out differences and enforce a match.
	FeatureCapability []HostFeatureCapability `xml:"featureCapability,omitempty" json:"featureCapability,omitempty"`
	// The masks (modifications to a host's feature capabilities) that limit a
	// host's capabilities to that of the EVC mode baseline.
	FeatureMask []HostFeatureMask `xml:"featureMask,omitempty" json:"featureMask,omitempty"`
	// The conditions that must be true of a host's feature capabilities in order
	// for the host to meet the minimum requirements of the EVC mode baseline.
	FeatureRequirement []VirtualMachineFeatureRequirement `xml:"featureRequirement,omitempty" json:"featureRequirement,omitempty"`
	// CPU hardware vendor required for this mode.
	Vendor string `xml:"vendor" json:"vendor"`
	// Identifiers for feature groups that are at least partially present in
	// the `EVCMode.guaranteedCPUFeatures` array for this mode.
	//
	// Use this property to compare track values from two modes.
	// Do not use this property to determine the presence or absence of
	// specific features.
	Track []string `xml:"track,omitempty" json:"track,omitempty"`
	// Index for ordering the set of modes that apply to a given CPU vendor.
	//
	// Use this property to compare vendor tier values from two modes.
	// Do not use this property to determine the presence or absence
	// of specific features.
	VendorTier int32 `xml:"vendorTier" json:"vendorTier"`
}

func init() {
	t["EVCMode"] = reflect.TypeOf((*EVCMode)(nil)).Elem()
}

// An attempt to enable Enhanced VMotion Compatibility on a cluster, or change
// the EVC configuration on an EVC-enabled cluster, has failed because the
// selected EVC mode is not legal for the CPU hardware vendor of the hosts
// currently in the cluster.
type EVCModeIllegalByVendor struct {
	EVCConfigFault

	// The CPU vendor in use in the cluster.
	ClusterCPUVendor string `xml:"clusterCPUVendor" json:"clusterCPUVendor"`
	// The CPU vendor for the requested EVC mode.
	ModeCPUVendor string `xml:"modeCPUVendor" json:"modeCPUVendor"`
}

func init() {
	t["EVCModeIllegalByVendor"] = reflect.TypeOf((*EVCModeIllegalByVendor)(nil)).Elem()
}

type EVCModeIllegalByVendorFault EVCModeIllegalByVendor

func init() {
	t["EVCModeIllegalByVendorFault"] = reflect.TypeOf((*EVCModeIllegalByVendorFault)(nil)).Elem()
}

// An attempt to enable Enhanced VMotion Compatibility on a cluster has failed
// because there are hosts in the cluster with a CPU feature baseline below the
// desired EVC mode.
type EVCModeUnsupportedByHosts struct {
	EVCConfigFault

	// The requested EVC mode.
	EvcMode string `xml:"evcMode,omitempty" json:"evcMode,omitempty"`
	// The set of hosts which are blocking EVC because their CPU hardware does
	// not support the requested EVC mode.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The names of the hosts in the host array.
	HostName []string `xml:"hostName,omitempty" json:"hostName,omitempty"`
}

func init() {
	t["EVCModeUnsupportedByHosts"] = reflect.TypeOf((*EVCModeUnsupportedByHosts)(nil)).Elem()
}

type EVCModeUnsupportedByHostsFault EVCModeUnsupportedByHosts

func init() {
	t["EVCModeUnsupportedByHostsFault"] = reflect.TypeOf((*EVCModeUnsupportedByHostsFault)(nil)).Elem()
}

// An attempt to enable Enhanced VMotion Compatibility (EVC) on a cluster has
// failed because one or more hosts in the cluster do not match the desired
// featureset and lack hardware support for EVC.
type EVCUnsupportedByHostHardware struct {
	EVCConfigFault

	// The set of hosts which are blocking EVC because their CPU hardware does
	// not support CPUID override.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host" json:"host"`
	// The names of the hosts in the host array.
	HostName []string `xml:"hostName" json:"hostName"`
}

func init() {
	t["EVCUnsupportedByHostHardware"] = reflect.TypeOf((*EVCUnsupportedByHostHardware)(nil)).Elem()
}

type EVCUnsupportedByHostHardwareFault EVCUnsupportedByHostHardware

func init() {
	t["EVCUnsupportedByHostHardwareFault"] = reflect.TypeOf((*EVCUnsupportedByHostHardwareFault)(nil)).Elem()
}

// An attempt to enable Enhanced VMotion Compatibility (EVC) on a cluster has
// failed because one or more hosts in the cluster lack software support for
// EVC.
type EVCUnsupportedByHostSoftware struct {
	EVCConfigFault

	// The set of hosts which are blocking EVC because their virtualization
	// software does not support CPUID override.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host" json:"host"`
	// The names of the hosts in the host array.
	HostName []string `xml:"hostName" json:"hostName"`
}

func init() {
	t["EVCUnsupportedByHostSoftware"] = reflect.TypeOf((*EVCUnsupportedByHostSoftware)(nil)).Elem()
}

type EVCUnsupportedByHostSoftwareFault EVCUnsupportedByHostSoftware

func init() {
	t["EVCUnsupportedByHostSoftwareFault"] = reflect.TypeOf((*EVCUnsupportedByHostSoftwareFault)(nil)).Elem()
}

// The parameters of `VirtualDiskManager.EagerZeroVirtualDisk_Task`.
type EagerZeroVirtualDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk that should be inflated.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
}

func init() {
	t["EagerZeroVirtualDiskRequestType"] = reflect.TypeOf((*EagerZeroVirtualDiskRequestType)(nil)).Elem()
}

type EagerZeroVirtualDisk_Task EagerZeroVirtualDiskRequestType

func init() {
	t["EagerZeroVirtualDisk_Task"] = reflect.TypeOf((*EagerZeroVirtualDisk_Task)(nil)).Elem()
}

type EagerZeroVirtualDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Only virtual machines on eight different hosts can have a single
// virtual disk backing opened for read at once.
//
// This fault occurs when moving or powering on this virtual
// machine would cause a violation of the above constraint.
// This only occurs when multiple virtual machines are sharing a
// single disk backing.
//
// Note that there is no limit on the number of virtual machines
// who share a disk backings, so long as they are running on
// eight or fewer hosts.
type EightHostLimitViolated struct {
	VmConfigFault
}

func init() {
	t["EightHostLimitViolated"] = reflect.TypeOf((*EightHostLimitViolated)(nil)).Elem()
}

type EightHostLimitViolatedFault EightHostLimitViolated

func init() {
	t["EightHostLimitViolatedFault"] = reflect.TypeOf((*EightHostLimitViolatedFault)(nil)).Elem()
}

// Static strings used for describing an object model string or enumeration.
type ElementDescription struct {
	Description

	// Enumeration or literal ID being described.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["ElementDescription"] = reflect.TypeOf((*ElementDescription)(nil)).Elem()
}

type EmitSyslogMark EmitSyslogMarkRequestType

func init() {
	t["EmitSyslogMark"] = reflect.TypeOf((*EmitSyslogMark)(nil)).Elem()
}

// The parameters of `DiagnosticManager.EmitSyslogMark`.
type EmitSyslogMarkRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The string to be used.
	Message string `xml:"message" json:"message"`
}

func init() {
	t["EmitSyslogMarkRequestType"] = reflect.TypeOf((*EmitSyslogMarkRequestType)(nil)).Elem()
	minAPIVersionForType["EmitSyslogMarkRequestType"] = "8.0.0.2"
}

type EmitSyslogMarkResponse struct {
}

type EnableAlarm EnableAlarmRequestType

func init() {
	t["EnableAlarm"] = reflect.TypeOf((*EnableAlarm)(nil)).Elem()
}

type EnableAlarmActions EnableAlarmActionsRequestType

func init() {
	t["EnableAlarmActions"] = reflect.TypeOf((*EnableAlarmActions)(nil)).Elem()
}

// The parameters of `AlarmManager.EnableAlarmActions`.
type EnableAlarmActionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The managed entity on which to set a schedule.
	//
	// Required privileges: Alarm.DisableActions
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// true, if alarms are enabled during the schedule.
	Enabled bool `xml:"enabled" json:"enabled"`
}

func init() {
	t["EnableAlarmActionsRequestType"] = reflect.TypeOf((*EnableAlarmActionsRequestType)(nil)).Elem()
}

type EnableAlarmActionsResponse struct {
}

// The parameters of `AlarmManager.EnableAlarm`.
type EnableAlarmRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The Alarm being enabled.
	//
	// Required privileges: Alarm.ToggleEnableOnEntity
	//
	// Refers instance of `Alarm`.
	Alarm ManagedObjectReference `xml:"alarm" json:"alarm"`
	// The ManagedEntity on which to enable the alarm.
	//
	// Required privileges: System.Read
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["EnableAlarmRequestType"] = reflect.TypeOf((*EnableAlarmRequestType)(nil)).Elem()
}

type EnableAlarmResponse struct {
}

type EnableClusteredVmdkSupport EnableClusteredVmdkSupportRequestType

func init() {
	t["EnableClusteredVmdkSupport"] = reflect.TypeOf((*EnableClusteredVmdkSupport)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.EnableClusteredVmdkSupport`.
type EnableClusteredVmdkSupportRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Datastore on which clustered vmdk should be
	// enabled
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["EnableClusteredVmdkSupportRequestType"] = reflect.TypeOf((*EnableClusteredVmdkSupportRequestType)(nil)).Elem()
}

type EnableClusteredVmdkSupportResponse struct {
}

type EnableCrypto EnableCryptoRequestType

func init() {
	t["EnableCrypto"] = reflect.TypeOf((*EnableCrypto)(nil)).Elem()
}

// The parameters of `HostSystem.EnableCrypto`.
type EnableCryptoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The key to be used for coredump encryption
	KeyPlain CryptoKeyPlain `xml:"keyPlain" json:"keyPlain"`
}

func init() {
	t["EnableCryptoRequestType"] = reflect.TypeOf((*EnableCryptoRequestType)(nil)).Elem()
}

type EnableCryptoResponse struct {
}

type EnableFeature EnableFeatureRequestType

func init() {
	t["EnableFeature"] = reflect.TypeOf((*EnableFeature)(nil)).Elem()
}

// The parameters of `LicenseManager.EnableFeature`.
type EnableFeatureRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Host to act on if LicenseManager is not on a host.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// Name of the feature to enable.
	FeatureKey string `xml:"featureKey" json:"featureKey"`
}

func init() {
	t["EnableFeatureRequestType"] = reflect.TypeOf((*EnableFeatureRequestType)(nil)).Elem()
}

type EnableFeatureResponse struct {
	Returnval bool `xml:"returnval" json:"returnval"`
}

type EnableHyperThreading EnableHyperThreadingRequestType

func init() {
	t["EnableHyperThreading"] = reflect.TypeOf((*EnableHyperThreading)(nil)).Elem()
}

type EnableHyperThreadingRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["EnableHyperThreadingRequestType"] = reflect.TypeOf((*EnableHyperThreadingRequestType)(nil)).Elem()
}

type EnableHyperThreadingResponse struct {
}

type EnableMultipathPath EnableMultipathPathRequestType

func init() {
	t["EnableMultipathPath"] = reflect.TypeOf((*EnableMultipathPath)(nil)).Elem()
}

// The parameters of `HostStorageSystem.EnableMultipathPath`.
type EnableMultipathPathRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the path to enable.
	PathName string `xml:"pathName" json:"pathName"`
}

func init() {
	t["EnableMultipathPathRequestType"] = reflect.TypeOf((*EnableMultipathPathRequestType)(nil)).Elem()
}

type EnableMultipathPathResponse struct {
}

type EnableNetworkResourceManagement EnableNetworkResourceManagementRequestType

func init() {
	t["EnableNetworkResourceManagement"] = reflect.TypeOf((*EnableNetworkResourceManagement)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.EnableNetworkResourceManagement`.
type EnableNetworkResourceManagementRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If true, enables I/O control. If false,
	// disables network I/O control.
	Enable bool `xml:"enable" json:"enable"`
}

func init() {
	t["EnableNetworkResourceManagementRequestType"] = reflect.TypeOf((*EnableNetworkResourceManagementRequestType)(nil)).Elem()
}

type EnableNetworkResourceManagementResponse struct {
}

type EnableRuleset EnableRulesetRequestType

func init() {
	t["EnableRuleset"] = reflect.TypeOf((*EnableRuleset)(nil)).Elem()
}

// The parameters of `HostFirewallSystem.EnableRuleset`.
type EnableRulesetRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Id   string                 `xml:"id" json:"id"`
}

func init() {
	t["EnableRulesetRequestType"] = reflect.TypeOf((*EnableRulesetRequestType)(nil)).Elem()
}

type EnableRulesetResponse struct {
}

// The parameters of `VirtualMachine.EnableSecondaryVM_Task`.
type EnableSecondaryVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The secondary virtual machine specified will be enabled.
	// This field must specify a secondary virtual machine that is part of the fault
	// tolerant group that this virtual machine is currently associated with. It can
	// only be invoked from the primary virtual machine in the group.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The host on which the secondary virtual machine is to be
	// enabled and possibly powered on. If no host is specified, a compatible host
	// will be selected by the system. If the secondary virtual machine is not
	// compatible with the specified host, the secondary will not be re-enabled
	// and a fault will be returned.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["EnableSecondaryVMRequestType"] = reflect.TypeOf((*EnableSecondaryVMRequestType)(nil)).Elem()
}

type EnableSecondaryVM_Task EnableSecondaryVMRequestType

func init() {
	t["EnableSecondaryVM_Task"] = reflect.TypeOf((*EnableSecondaryVM_Task)(nil)).Elem()
}

type EnableSecondaryVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type EnableSmartCardAuthentication EnableSmartCardAuthenticationRequestType

func init() {
	t["EnableSmartCardAuthentication"] = reflect.TypeOf((*EnableSmartCardAuthentication)(nil)).Elem()
}

type EnableSmartCardAuthenticationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["EnableSmartCardAuthenticationRequestType"] = reflect.TypeOf((*EnableSmartCardAuthenticationRequestType)(nil)).Elem()
}

type EnableSmartCardAuthenticationResponse struct {
}

// An EncryptionKeyRequired fault occurs when an operation fails due
// to one or more required encryption keys.
type EncryptionKeyRequired struct {
	InvalidState

	// A list of required key identifiers.
	RequiredKey []CryptoKeyId `xml:"requiredKey,omitempty" json:"requiredKey,omitempty"`
}

func init() {
	t["EncryptionKeyRequired"] = reflect.TypeOf((*EncryptionKeyRequired)(nil)).Elem()
}

type EncryptionKeyRequiredFault EncryptionKeyRequired

func init() {
	t["EncryptionKeyRequiredFault"] = reflect.TypeOf((*EncryptionKeyRequiredFault)(nil)).Elem()
}

type EnterLockdownMode EnterLockdownModeRequestType

func init() {
	t["EnterLockdownMode"] = reflect.TypeOf((*EnterLockdownMode)(nil)).Elem()
}

type EnterLockdownModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["EnterLockdownModeRequestType"] = reflect.TypeOf((*EnterLockdownModeRequestType)(nil)).Elem()
}

type EnterLockdownModeResponse struct {
}

// The parameters of `HostSystem.EnterMaintenanceMode_Task`.
type EnterMaintenanceModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The task completes when the host successfully enters maintenance
	// mode or the timeout expires, and in the latter case the task
	// contains a Timeout fault. If the timeout is less than or equal to
	// zero, there is no timeout. The timeout is specified in seconds.
	Timeout int32 `xml:"timeout" json:"timeout"`
	// This is a parameter only supported by VirtualCenter.
	// If set to true, for a DRS disabled cluster, the task will not
	// succeed unless all powered-off virtual machines have been manually
	// reregistered; for a DRS enabled cluster, VirtualCenter will
	// automatically reregister powered-off virtual machines and a
	// powered-off virtual machine may remain at the host only for two
	// reasons: (a) no compatible host found for reregistration, (b) DRS
	// is disabled for the virtual machine. If set to false, powered-off
	// virtual machines do not need to be moved.
	EvacuatePoweredOffVms *bool `xml:"evacuatePoweredOffVms" json:"evacuatePoweredOffVms,omitempty"`
	// Any additional actions to be taken by the host upon
	// entering maintenance mode. If omitted, default actions will
	// be taken as documented in the `HostMaintenanceSpec`.
	MaintenanceSpec *HostMaintenanceSpec `xml:"maintenanceSpec,omitempty" json:"maintenanceSpec,omitempty"`
}

func init() {
	t["EnterMaintenanceModeRequestType"] = reflect.TypeOf((*EnterMaintenanceModeRequestType)(nil)).Elem()
}

type EnterMaintenanceMode_Task EnterMaintenanceModeRequestType

func init() {
	t["EnterMaintenanceMode_Task"] = reflect.TypeOf((*EnterMaintenanceMode_Task)(nil)).Elem()
}

type EnterMaintenanceMode_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This event records that the host has completely entered
// maintenance mode.
//
// A host in this mode has no running virtual machines and no
// provisioning operations are occurring.
type EnteredMaintenanceModeEvent struct {
	HostEvent
}

func init() {
	t["EnteredMaintenanceModeEvent"] = reflect.TypeOf((*EnteredMaintenanceModeEvent)(nil)).Elem()
}

// This event records that the host has successfully entered
// standby mode.
//
// A host in this mode has no running virtual machines and no
// provisioning operations are occurring.
type EnteredStandbyModeEvent struct {
	HostEvent
}

func init() {
	t["EnteredStandbyModeEvent"] = reflect.TypeOf((*EnteredStandbyModeEvent)(nil)).Elem()
}

// This event records that a host has begun the process of entering
// maintenance mode.
//
// All virtual machine operations
// are blocked, except the following:
//   - MigrateVM
//   - PowerOffVM
//   - SuspendVM
//   - ShutdownGuest
//   - StandbyGuest
type EnteringMaintenanceModeEvent struct {
	HostEvent
}

func init() {
	t["EnteringMaintenanceModeEvent"] = reflect.TypeOf((*EnteringMaintenanceModeEvent)(nil)).Elem()
}

// This event records that a host has begun the process of entering
// standby mode.
//
// All virtual machine operations
// are blocked, except the following:
//   - MigrateVM
//   - PowerOffVM
//   - SuspendVM
//   - ShutdownGuest
//   - StandbyGuest
type EnteringStandbyModeEvent struct {
	HostEvent
}

func init() {
	t["EnteringStandbyModeEvent"] = reflect.TypeOf((*EnteringStandbyModeEvent)(nil)).Elem()
}

// `EntityBackup` is an abstract data object that contains
// the related entity backup and restore elements for virtual distributed
// switches and virtual distributed portgroups.
//
// See the following elements:
//   - `EntityBackupConfig`
//   - `EntityImportType_enum`
//   - `EntityType_enum`
type EntityBackup struct {
	DynamicData
}

func init() {
	t["EntityBackup"] = reflect.TypeOf((*EntityBackup)(nil)).Elem()
}

// The `EntityBackupConfig` data object
// contains `VmwareDistributedVirtualSwitch`
// or `DistributedVirtualPortgroup` backup
// configuration data produced by the
// `DistributedVirtualSwitchManager.DVSManagerExportEntity_Task`
// method.
//
// It also contains properties that support
// `DistributedVirtualSwitchManager.DVSManagerImportEntity_Task`
// operations.
//
// A `DistributedVirtualSwitchManager.DVSManagerExportEntity_Task` operation
// sets properties that identify the entity instance
// (`EntityBackupConfig.entityType`,
// `EntityBackupConfig.key`, and
// `EntityBackupConfig.name`) and
// inventory location (`EntityBackupConfig.container`).
// When you import a backup configuration, you can set
// the <code>key</code>, <code>name</code>, and <code>container</code>
// properties in accordance with the <code>importType</code>
// specified in the call to
// `DistributedVirtualSwitchManager.DVSManagerImportEntity_Task`.
// See `EntityImportType_enum`.
type EntityBackupConfig struct {
	DynamicData

	// Type of the exported entity
	// (`DistributedVirtualSwitchManager.DVSManagerExportEntity_Task`).
	//
	// See `EntityType_enum`
	// for valid values.
	EntityType string `xml:"entityType" json:"entityType"`
	// Opaque blob that contains the configuration of the entity.
	ConfigBlob []byte `xml:"configBlob" json:"configBlob"`
	// Unique identifier of the exported entity or the entity to be restored
	// through an import operation.
	//   - If you are importing a virtual distributed switch and the import type is
	//     `applyToEntitySpecified`,
	//     set the <code>key</code> to
	//     `DistributedVirtualSwitch*.*DistributedVirtualSwitch.uuid`.
	//   - If you are importing a virtual distributed portgroup and the import type is
	//     `applyToEntitySpecified`,
	//     set the <code>key</code> to
	//     `DistributedVirtualPortgroup*.*DistributedVirtualPortgroup.key`.
	//
	// The Server ignores the key value when the import operation creates a new entity.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// Name of the exported entity or the entity to be restored with the backup configuration.
	//
	// If you are importing an entity and the import type is
	// `applyToEntitySpecified`,
	// the Server will use this value to rename the existing entity.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// Container for this entity.
	//
	// If `EntityBackupConfig.entityType` is "distributedVirtualSwitch",
	// the container type is `Folder`. If `EntityBackupConfig.entityType`
	// is "distributedVirtualPortgroup", the container type is
	// `DistributedVirtualSwitch`.
	//
	// Refers instance of `ManagedEntity`.
	Container *ManagedObjectReference `xml:"container,omitempty" json:"container,omitempty"`
	// Configuration version.
	ConfigVersion string `xml:"configVersion,omitempty" json:"configVersion,omitempty"`
}

func init() {
	t["EntityBackupConfig"] = reflect.TypeOf((*EntityBackupConfig)(nil)).Elem()
}

// The event argument is a managed entity object.
//
// Subclasses of this type distinguish the different managed entities
// referenced in event objects.
type EntityEventArgument struct {
	EventArgument

	// Name of the entity, including its full path from the root of the inventory.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["EntityEventArgument"] = reflect.TypeOf((*EntityEventArgument)(nil)).Elem()
}

// This class defines whether a set of privileges are granted for a managed entity.
type EntityPrivilege struct {
	DynamicData

	// The entity on which the privileges are checked.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// whether a set of privileges are granted for the managed entity.
	PrivAvailability []PrivilegeAvailability `xml:"privAvailability" json:"privAvailability"`
}

func init() {
	t["EntityPrivilege"] = reflect.TypeOf((*EntityPrivilege)(nil)).Elem()
}

// Static strings used for describing an enumerated type.
type EnumDescription struct {
	DynamicData

	// Type of enumeration being described.
	Key string `xml:"key" json:"key"`
	// Element descriptions of all the tags for that enumerated type.
	Tags []BaseElementDescription `xml:"tags,typeattr" json:"tags"`
}

func init() {
	t["EnumDescription"] = reflect.TypeOf((*EnumDescription)(nil)).Elem()
}

// Represent search criteria and filters on a `VirtualMachineConfigOption`
// object.
type EnvironmentBrowserConfigOptionQuerySpec struct {
	DynamicData

	// The key found in the VirtualMachineConfigOptionDescriptor,
	// obtained by invoking the
	// `EnvironmentBrowser.QueryConfigOptionDescriptor` operation.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// The host whose ConfigOption is requested.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The Guest OS IDs whose `VirtualMachineConfigOption` is requested
	// `GuestOsIdentifier`
	GuestId []string `xml:"guestId,omitempty" json:"guestId,omitempty"`
}

func init() {
	t["EnvironmentBrowserConfigOptionQuerySpec"] = reflect.TypeOf((*EnvironmentBrowserConfigOptionQuerySpec)(nil)).Elem()
}

// This event is a general error event from upgrade.
type ErrorUpgradeEvent struct {
	UpgradeEvent
}

func init() {
	t["ErrorUpgradeEvent"] = reflect.TypeOf((*ErrorUpgradeEvent)(nil)).Elem()
}

type EstimateDatabaseSize EstimateDatabaseSizeRequestType

func init() {
	t["EstimateDatabaseSize"] = reflect.TypeOf((*EstimateDatabaseSize)(nil)).Elem()
}

// The parameters of `ResourcePlanningManager.EstimateDatabaseSize`.
type EstimateDatabaseSizeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// `DatabaseSizeParam`
	// Contains the summary of an inventory for which the database size
	// requirements are to be computed. It also contains
	// the historic interval setting for which the database
	// computations are to be done. This is an optional parameter and
	// the current virtual center historical settings are used by default.
	// There are many other optional fields in the dbSizeParam structure
	// that are appropriately filled up based on some heuristics.
	DbSizeParam DatabaseSizeParam `xml:"dbSizeParam" json:"dbSizeParam"`
}

func init() {
	t["EstimateDatabaseSizeRequestType"] = reflect.TypeOf((*EstimateDatabaseSizeRequestType)(nil)).Elem()
}

type EstimateDatabaseSizeResponse struct {
	Returnval DatabaseSizeEstimate `xml:"returnval" json:"returnval"`
}

type EstimateStorageForConsolidateSnapshotsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["EstimateStorageForConsolidateSnapshotsRequestType"] = reflect.TypeOf((*EstimateStorageForConsolidateSnapshotsRequestType)(nil)).Elem()
}

type EstimateStorageForConsolidateSnapshots_Task EstimateStorageForConsolidateSnapshotsRequestType

func init() {
	t["EstimateStorageForConsolidateSnapshots_Task"] = reflect.TypeOf((*EstimateStorageForConsolidateSnapshots_Task)(nil)).Elem()
}

type EstimateStorageForConsolidateSnapshots_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type EsxAgentHostManagerUpdateConfig EsxAgentHostManagerUpdateConfigRequestType

func init() {
	t["EsxAgentHostManagerUpdateConfig"] = reflect.TypeOf((*EsxAgentHostManagerUpdateConfig)(nil)).Elem()
}

// The parameters of `HostEsxAgentHostManager.EsxAgentHostManagerUpdateConfig`.
type EsxAgentHostManagerUpdateConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// configuration of agent virtual machine resources
	ConfigInfo HostEsxAgentHostManagerConfigInfo `xml:"configInfo" json:"configInfo"`
}

func init() {
	t["EsxAgentHostManagerUpdateConfigRequestType"] = reflect.TypeOf((*EsxAgentHostManagerUpdateConfigRequestType)(nil)).Elem()
}

type EsxAgentHostManagerUpdateConfigResponse struct {
}

// The parameters of `HostVsanSystem.EvacuateVsanNode_Task`.
type EvacuateVsanNodeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specifies the data evacuation mode. See `HostMaintenanceSpec`.
	// If unspecified, the default mode chosen will be
	// `ensureObjectAccessibility`.
	MaintenanceSpec HostMaintenanceSpec `xml:"maintenanceSpec" json:"maintenanceSpec"`
	// Time to wait for the task to complete in seconds.
	// If the value is less than or equal to zero, there
	// is no timeout. The operation fails with a Timedout
	// exception if it timed out.
	Timeout int32 `xml:"timeout" json:"timeout"`
}

func init() {
	t["EvacuateVsanNodeRequestType"] = reflect.TypeOf((*EvacuateVsanNodeRequestType)(nil)).Elem()
}

type EvacuateVsanNode_Task EvacuateVsanNodeRequestType

func init() {
	t["EvacuateVsanNode_Task"] = reflect.TypeOf((*EvacuateVsanNode_Task)(nil)).Elem()
}

type EvacuateVsanNode_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Deprecated as of vSphere API 4.0, this is not used by the system.
//
// Specify an evaluation license source.
//
// Feature licensing is not required while the remaining hours is greater than zero.
type EvaluationLicenseSource struct {
	LicenseSource

	// The number of remaining hours before product evaluation expires
	RemainingHours int64 `xml:"remainingHours,omitempty" json:"remainingHours,omitempty"`
}

func init() {
	t["EvaluationLicenseSource"] = reflect.TypeOf((*EvaluationLicenseSource)(nil)).Elem()
}

type EvcManager EvcManagerRequestType

func init() {
	t["EvcManager"] = reflect.TypeOf((*EvcManager)(nil)).Elem()
}

type EvcManagerRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["EvcManagerRequestType"] = reflect.TypeOf((*EvcManagerRequestType)(nil)).Elem()
}

type EvcManagerResponse struct {
	Returnval *ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// This event is the base data object type from which all events inherit.
//
// All event
// objects are data structures that describe events. While event data objects are data
// structures that describe events, event data type documentation may describe what the
// event records, rather than the data structure, itself.
type Event struct {
	DynamicData

	// The event ID.
	Key int32 `xml:"key" json:"key"`
	// The parent or group ID.
	ChainId int32 `xml:"chainId" json:"chainId"`
	// The time the event was created.
	CreatedTime time.Time `xml:"createdTime" json:"createdTime"`
	// The user who caused the event.
	UserName string `xml:"userName" json:"userName"`
	// The Datacenter object of the event.
	Datacenter *DatacenterEventArgument `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// The ComputeResource object of the event.
	ComputeResource *ComputeResourceEventArgument `xml:"computeResource,omitempty" json:"computeResource,omitempty"`
	// The Host object of the event.
	Host *HostEventArgument `xml:"host,omitempty" json:"host,omitempty"`
	// The VirtualMachine object of the event.
	Vm *VmEventArgument `xml:"vm,omitempty" json:"vm,omitempty"`
	// The Datastore object of the event.
	Ds *DatastoreEventArgument `xml:"ds,omitempty" json:"ds,omitempty"`
	// The Network object of the event.
	Net *NetworkEventArgument `xml:"net,omitempty" json:"net,omitempty"`
	// The DistributedVirtualSwitch object of the event.
	Dvs *DvsEventArgument `xml:"dvs,omitempty" json:"dvs,omitempty"`
	// A formatted text message describing the event.
	//
	// The message may be localized.
	FullFormattedMessage string `xml:"fullFormattedMessage,omitempty" json:"fullFormattedMessage,omitempty"`
	// The user entered tag to identify the operations and their side effects
	ChangeTag string `xml:"changeTag,omitempty" json:"changeTag,omitempty"`
}

func init() {
	t["Event"] = reflect.TypeOf((*Event)(nil)).Elem()
}

// An alarm expression that uses the event stream to trigger the alarm.
//
// This alarm is triggered when an event matching this expression gets logged.
type EventAlarmExpression struct {
	AlarmExpression

	// The attributes/values to compare.
	Comparisons []EventAlarmExpressionComparison `xml:"comparisons,omitempty" json:"comparisons,omitempty"`
	// Deprecated use <code>eventTypeId</code> instead.
	//
	// The type of the event to trigger the alarm on.
	EventType string `xml:"eventType" json:"eventType"`
	// The eventTypeId of the event to match.
	//
	// The semantics of how eventTypeId matching is done is as follows:
	//   - If the event being matched is of type `EventEx`
	//     or `ExtendedEvent`, then we match this value
	//     against the <code>eventTypeId</code> (for <code>EventEx</code>) or
	//     <code>eventId</code> (for <code>ExtendedEvent</code>) member of the Event.
	//   - Otherwise, we match it against the type of the Event itself.
	//
	// Either <code>eventType</code> or <code>eventTypeId</code> _must_
	// be set.
	EventTypeId string `xml:"eventTypeId,omitempty" json:"eventTypeId,omitempty"`
	// Name of the type of managed object on which the event is logged.
	//
	// An event alarm defined on a `ManagedEntity`
	// is propagated to child entities in the VirtualCenter inventory depending
	// on the value of this attribute. If objectType is any of the following,
	// the alarm is propagated down to all children of that type:
	//   - A datacenter: `Datacenter`.
	//   - A cluster of host systems: `ClusterComputeResource`.
	//   - A single host system: `HostSystem`.
	//   - A resource pool representing a set of physical resources on a single host:
	//     `ResourcePool`.
	//   - A virtual machine: `VirtualMachine`.
	//   - A datastore: `Datastore`.
	//   - A network: `Network`.
	//   - A distributed virtual switch: `DistributedVirtualSwitch`.
	//
	// If objectType is unspecified or not contained in the above list,
	// the event alarm is not propagated down to child entities in the
	// VirtualCenter inventory.
	//
	// It is possible to specify an event alarm containing two (or more) different
	// EventAlarmExpression's which contain different objectTypes. In such a case,
	// the event is propagated to all child entities with specified type(s).
	ObjectType string `xml:"objectType,omitempty" json:"objectType,omitempty"`
	// The alarm's new state when this condition is evaluated and satisfied.
	//
	// If not specified then there is no change to alarm status, and all
	// actions are fired (rather than those for the transition).
	Status ManagedEntityStatus `xml:"status,omitempty" json:"status,omitempty"`
}

func init() {
	t["EventAlarmExpression"] = reflect.TypeOf((*EventAlarmExpression)(nil)).Elem()
}

// Encapsulates Comparison of an event's attribute to a value.
type EventAlarmExpressionComparison struct {
	DynamicData

	// The attribute of the event to compare
	AttributeName string `xml:"attributeName" json:"attributeName"`
	// An operator from the list above
	Operator string `xml:"operator" json:"operator"`
	// The value to compare against
	Value string `xml:"value" json:"value"`
}

func init() {
	t["EventAlarmExpressionComparison"] = reflect.TypeOf((*EventAlarmExpressionComparison)(nil)).Elem()
}

// Describes an available event argument name for an Event type, which
// can be used in `EventAlarmExpression`.
type EventArgDesc struct {
	DynamicData

	// The name of the argument
	Name string `xml:"name" json:"name"`
	// The type of the argument.
	Type string `xml:"type" json:"type"`
	// The localized description of the event argument.
	//
	// The key holds
	// the localization prefix for the argument, which is decided by
	// the Event type that it is actually declared in, which may be a
	// base type of this event type.
	Description BaseElementDescription `xml:"description,omitempty,typeattr" json:"description,omitempty"`
}

func init() {
	t["EventArgDesc"] = reflect.TypeOf((*EventArgDesc)(nil)).Elem()
}

// This is the base type for event argument types.
//
// Event argument objects, which inherit from a common subtype,
// are used to manage supplementary properties of different kinds
// of event objects.
type EventArgument struct {
	DynamicData
}

func init() {
	t["EventArgument"] = reflect.TypeOf((*EventArgument)(nil)).Elem()
}

// This data object provides static, locale-specific strings for event objects.
type EventDescription struct {
	DynamicData

	// *Event Category enum*
	Category []BaseElementDescription `xml:"category,typeattr" json:"category"`
	// The event class description details.
	EventInfo []EventDescriptionEventDetail `xml:"eventInfo" json:"eventInfo"`
	// Localized descriptions of all enumerated types that are used for
	// member declarations in event classes.
	EnumeratedTypes []EnumDescription `xml:"enumeratedTypes,omitempty" json:"enumeratedTypes,omitempty"`
}

func init() {
	t["EventDescription"] = reflect.TypeOf((*EventDescription)(nil)).Elem()
}

// Each Event object provides an automatic event message string through
// its `fullFormattedMessage`
// property.
//
// However, you can use the EventDetail object's properties to
// format an event message string that is appropriate when viewed from
// a specific context. The variable information (vm.name, and so on) is
// derived from the Event object's event arguments
// (`VmEventArgument`, and so on).
type EventDescriptionEventDetail struct {
	DynamicData

	// Type of event being described.
	Key string `xml:"key" json:"key"`
	// A string that is a short human-parseable description of the event.
	//
	// This is not the full message string (which may contain details
	// of the arguments, etc.), but merely a more understandable, and
	// localized, description of what the event stands for. It is meant
	// for contexts where the _name_ of the event has to be displayed
	// to end-users, e.g. when creating Event-based Alarms.
	// \` \*
	//
	// E.g., for `VmPoweredOnEvent`, the eventDescription
	// in English might say "VM Powered On".
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// A category of events.
	Category string `xml:"category" json:"category"`
	// A string that is appropriate in the context of a specific
	// Datacenter.
	//
	// For example, a renaming event in this context produces
	// the following string:
	//
	// "Renamed {vm.name} from {oldName} to {newName}"
	//
	// where `oldName` and
	// `newName` are properties of the
	// VmRenamedEvent object.
	FormatOnDatacenter string `xml:"formatOnDatacenter" json:"formatOnDatacenter"`
	// A string that is appropriate in the context of a specific cluster.
	//
	// For example, a powering on event in this context produces the
	// following string:
	//
	// "{vm.name} on {host.name} is powered on".
	FormatOnComputeResource string `xml:"formatOnComputeResource" json:"formatOnComputeResource"`
	// A string that is appropriate in the context
	// of a specific Host.
	//
	// For example, a powering on event in this
	// context produces the following string:
	//
	// "{vm.name} is powered on"
	FormatOnHost string `xml:"formatOnHost" json:"formatOnHost"`
	// A string that is appropriate for the context of a specific
	// virtual machine.
	//
	// For example, a powering on event in this context
	// produces the following string:
	//
	// "Virtual machine on {host.name} is powered on"
	FormatOnVm string `xml:"formatOnVm" json:"formatOnVm"`
	// A string whose context is not entity-specific.
	//
	// For example, a
	// powering on event produces the following string:
	//
	// "{vm.name} on {host.name} in {datacenter.name} is powered on"
	FullFormat string `xml:"fullFormat" json:"fullFormat"`
	// A detailed description of the event.
	//
	// It includes common causes
	// and actions to remediate them. It may also include links to kb
	// articles and other diagnostic information.
	// For example, the BadUserNameSessionEvent may produce the
	// following string:
	//
	//	<EventLongDescription id="vim.event.BadUserNameSessionEvent">
	//	   <description>
	//	      The user could not be logged in because of an unknown or invalid
	//	      user name.
	//	   </description>
	//	   <cause>
	//	      <description>The user name was unknown to the system</description>
	//	      <action>Use a user name known to the system user directory</action>
	//	      <action>(On Linux) Check if the user directory is correctly
	//	              configured.</action>
	//	      <action>Check the health of the domain controller (if you are using
	//	              Active Directory)</action>
	//	   </cause>
	//	   <cause>
	//	      <description>The user provided an invalid password</description>
	//	      <action>Supply the correct password</action>
	//	   </cause>
	//	</EventLongDescription>
	LongDescription string `xml:"longDescription,omitempty" json:"longDescription,omitempty"`
}

func init() {
	t["EventDescriptionEventDetail"] = reflect.TypeOf((*EventDescriptionEventDetail)(nil)).Elem()
}

// EventEx is a dynamically typed Event class, whose type is indicated by its
// eventTypeId property.
//
// A collection of eventTypeIds is registered by Extensions, which can now
// pass in optional type information for each eventTypeId which indicates the
// applicable argument names and types, among other properties.
//
// EventEx allows event arguments of any type, though today, the system
// only supports "string" and "moid" (a string which can be interpreted as an
// object ID in the system) as argument types. In the future, the system
// may optionally strongly check the types of the arguments in the event
// against the declared type information, based on how the event type is
// declared.
//
// EventEx also allows arbitrary "event object"s - the object which the
// event refers to. You can put in any object identifier as the objectId,
// but objectType should be filled in only if the object is actually present
// in the VC Server's ManagedEntity inventory.
type EventEx struct {
	Event

	// The type of the event.
	EventTypeId string `xml:"eventTypeId" json:"eventTypeId"`
	// The severity level of the message: null=&gt;info.
	//
	// See also `EventEventSeverity_enum`.
	Severity string `xml:"severity,omitempty" json:"severity,omitempty"`
	// An arbitrary message string, not localized.
	Message string `xml:"message,omitempty" json:"message,omitempty"`
	// The event arguments associated with the event
	Arguments []KeyAnyValue `xml:"arguments,omitempty" json:"arguments,omitempty"`
	// The ID of the object (VM, Host, Folder..) which the event pertains to.
	//
	// Federated or local inventory path.
	ObjectId string `xml:"objectId,omitempty" json:"objectId,omitempty"`
	// the type of the object, if known to the VirtualCenter inventory
	ObjectType string `xml:"objectType,omitempty" json:"objectType,omitempty"`
	// The name of the object
	ObjectName string `xml:"objectName,omitempty" json:"objectName,omitempty"`
	// The fault that triggered the event, if any
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["EventEx"] = reflect.TypeOf((*EventEx)(nil)).Elem()
}

// Event filter used to query events in the history collector database.
//
// The client creates an event history collector with a filter specification,
// then retrieves the events from the event history collector.
type EventFilterSpec struct {
	DynamicData

	// The filter specification for retrieving events by managed entity.
	//
	// If the property is not set, then events attached to all managed entities
	// are collected.
	Entity *EventFilterSpecByEntity `xml:"entity,omitempty" json:"entity,omitempty"`
	// The filter specification for retrieving tasks by time.
	//
	// If the property is not set, then events with any time stamp are collected.
	Time *EventFilterSpecByTime `xml:"time,omitempty" json:"time,omitempty"`
	// The filter specification for retrieving events by username.
	//
	// If the property is not set, then events belonging to any user are collected.
	UserName *EventFilterSpecByUsername `xml:"userName,omitempty" json:"userName,omitempty"`
	// The filter specification for retrieving events by chain ID.
	//
	// If the property is not set, events with any chain ID are collected.
	EventChainId int32 `xml:"eventChainId,omitempty" json:"eventChainId,omitempty"`
	// This property, if set, limits the set of collected events to those
	// associated with the specified alarm.
	//
	// If the property is not set, events are collected regardless of their
	// association with alarms.
	//
	// Refers instance of `Alarm`.
	Alarm *ManagedObjectReference `xml:"alarm,omitempty" json:"alarm,omitempty"`
	// This property, if set, limits the set of collected events to those
	// associated with the specified scheduled task.
	//
	// If the property is not set, events are collected regardless of their
	// association with any scheduled task.
	//
	// Refers instance of `ScheduledTask`.
	ScheduledTask *ManagedObjectReference `xml:"scheduledTask,omitempty" json:"scheduledTask,omitempty"`
	// Flag to specify whether or not to prepare the full formatted message
	// for each event.
	//
	// If the property is not set, the collected events do not include
	// the full formatted message.
	DisableFullMessage *bool `xml:"disableFullMessage" json:"disableFullMessage,omitempty"`
	// This property, if set, limits the set of collected events to those
	// associated with the specified category.
	//
	// If the property is not set, events are collected regardless of their
	// association with any category.
	// "category" here is the same as Event.severity.
	Category []string `xml:"category,omitempty" json:"category,omitempty"`
	// Deprecated as of vSphere API 4.0, use `EventFilterSpec.eventTypeId` instead.
	//
	// This property, if set, limits the set of collected events to those
	// specified types.
	//
	// If the property is not set, events are collected regardless of their
	// types.
	Type []string `xml:"type,omitempty" json:"type,omitempty"`
	// This property, if set, limits the set of filtered events to those that
	// have it.
	//
	// If not set, or the size of it 0, the tag of an event is
	// disregarded. A blank string indicates events without tags.
	Tag []string `xml:"tag,omitempty" json:"tag,omitempty"`
	// This property, if set, limits the set of collected events to those
	// specified types.
	//
	// Note: if both `EventFilterSpec.eventTypeId` and `EventFilterSpec.type` are specified, an
	// exception may be thrown by `EventManager.CreateCollectorForEvents`.
	//
	// The semantics of how eventTypeId matching is done is as follows:
	//   - If the event being collected is of type `EventEx`
	//     or `ExtendedEvent`, then we match against the
	//     <code>eventTypeId</code> (for <code>EventEx</code>) or
	//     <code>eventId</code> (for <code>ExtendedEvent</code>) member of the Event.
	//   - Otherwise, we match against the type of the Event itself.
	//
	// If neither this property, nor <code>type</code>, is set, events are
	// collected regardless of their types.
	EventTypeId []string `xml:"eventTypeId,omitempty" json:"eventTypeId,omitempty"`
	// This property, if set, specifies the maximum number of returned events.
	//
	// If unset, the default maximum number will be used.
	// Using this property with `EventManager.CreateCollectorForEvents` is more
	// efficient than a call to `HistoryCollector.SetCollectorPageSize`.
	MaxCount int32 `xml:"maxCount,omitempty" json:"maxCount,omitempty"`
	// This property, if set, specifies whether latest page should be populated on Collector creation.
	//
	// True for delayed population and false for immediate.
	// If unset, the latest page is populated immediately.
	DelayedInit *bool `xml:"delayedInit" json:"delayedInit,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["EventFilterSpec"] = reflect.TypeOf((*EventFilterSpec)(nil)).Elem()
}

// This option specifies a managed entity used to filter event history.
//
// If the specified managed entity is a Folder or a ResourcePool, the query
// will actually be performed on the entities contained within that Folder
// or ResourcePool, so you cannot query for events on Folders and
// ResourcePools themselves this way.
type EventFilterSpecByEntity struct {
	DynamicData

	// The managed entity to which the event pertains.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// Specification of related managed entities in the inventory hierarchy.
	Recursion EventFilterSpecRecursionOption `xml:"recursion" json:"recursion"`
}

func init() {
	t["EventFilterSpecByEntity"] = reflect.TypeOf((*EventFilterSpecByEntity)(nil)).Elem()
}

// This option specifies a time range used to filter event history.
type EventFilterSpecByTime struct {
	DynamicData

	// The beginning of the time range.
	//
	// If this property is not set, then events are collected from
	// the earliest time in the database.
	BeginTime *time.Time `xml:"beginTime" json:"beginTime,omitempty"`
	// The end of the time range.
	//
	// If this property is not specified, then events are collected up to
	// the latest time in the database.
	EndTime *time.Time `xml:"endTime" json:"endTime,omitempty"`
}

func init() {
	t["EventFilterSpecByTime"] = reflect.TypeOf((*EventFilterSpecByTime)(nil)).Elem()
}

// This option specifies users used to filter event history.
type EventFilterSpecByUsername struct {
	DynamicData

	// filter by system user
	// true for system user event
	SystemUser bool `xml:"systemUser" json:"systemUser"`
	// all interested username list
	// If this property is not set, then all regular user events are
	// collected
	UserList []string `xml:"userList,omitempty" json:"userList,omitempty"`
}

func init() {
	t["EventFilterSpecByUsername"] = reflect.TypeOf((*EventFilterSpecByUsername)(nil)).Elem()
}

type ExecuteHostProfile ExecuteHostProfileRequestType

func init() {
	t["ExecuteHostProfile"] = reflect.TypeOf((*ExecuteHostProfile)(nil)).Elem()
}

// The parameters of `HostProfile.ExecuteHostProfile`.
type ExecuteHostProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Host on which to execute the profile.
	// The host does not have to be associated with the profile.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Additional configuration data to be applied to the host.
	// This should contain all of the host-specific data, including data from from
	// previous calls to the method.
	DeferredParam []ProfileDeferredPolicyOptionParameter `xml:"deferredParam,omitempty" json:"deferredParam,omitempty"`
}

func init() {
	t["ExecuteHostProfileRequestType"] = reflect.TypeOf((*ExecuteHostProfileRequestType)(nil)).Elem()
}

type ExecuteHostProfileResponse struct {
	Returnval BaseProfileExecuteResult `xml:"returnval,typeattr" json:"returnval"`
}

type ExecuteSimpleCommand ExecuteSimpleCommandRequestType

func init() {
	t["ExecuteSimpleCommand"] = reflect.TypeOf((*ExecuteSimpleCommand)(nil)).Elem()
}

// The parameters of `SimpleCommand.ExecuteSimpleCommand`.
type ExecuteSimpleCommandRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// An arbitrary collection of arguments.
	Arguments []string `xml:"arguments,omitempty" json:"arguments,omitempty"`
}

func init() {
	t["ExecuteSimpleCommandRequestType"] = reflect.TypeOf((*ExecuteSimpleCommandRequestType)(nil)).Elem()
}

type ExecuteSimpleCommandResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type ExitLockdownMode ExitLockdownModeRequestType

func init() {
	t["ExitLockdownMode"] = reflect.TypeOf((*ExitLockdownMode)(nil)).Elem()
}

type ExitLockdownModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ExitLockdownModeRequestType"] = reflect.TypeOf((*ExitLockdownModeRequestType)(nil)).Elem()
}

type ExitLockdownModeResponse struct {
}

// This event records that the host is no longer in
// maintenance mode.
type ExitMaintenanceModeEvent struct {
	HostEvent
}

func init() {
	t["ExitMaintenanceModeEvent"] = reflect.TypeOf((*ExitMaintenanceModeEvent)(nil)).Elem()
}

// The parameters of `HostSystem.ExitMaintenanceMode_Task`.
type ExitMaintenanceModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Number of seconds to wait for the exit maintenance mode to
	// succeed. If the timeout is less than or equal to zero, there
	// is no timeout.
	Timeout int32 `xml:"timeout" json:"timeout"`
}

func init() {
	t["ExitMaintenanceModeRequestType"] = reflect.TypeOf((*ExitMaintenanceModeRequestType)(nil)).Elem()
}

type ExitMaintenanceMode_Task ExitMaintenanceModeRequestType

func init() {
	t["ExitMaintenanceMode_Task"] = reflect.TypeOf((*ExitMaintenanceMode_Task)(nil)).Elem()
}

type ExitMaintenanceMode_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This event records that the host failed to exit standby mode.
type ExitStandbyModeFailedEvent struct {
	HostEvent
}

func init() {
	t["ExitStandbyModeFailedEvent"] = reflect.TypeOf((*ExitStandbyModeFailedEvent)(nil)).Elem()
}

// This event records that the host is no longer in
// standby mode.
type ExitedStandbyModeEvent struct {
	HostEvent
}

func init() {
	t["ExitedStandbyModeEvent"] = reflect.TypeOf((*ExitedStandbyModeEvent)(nil)).Elem()
}

// This event records that a host has begun the process of
// exiting standby mode.
type ExitingStandbyModeEvent struct {
	HostEvent
}

func init() {
	t["ExitingStandbyModeEvent"] = reflect.TypeOf((*ExitingStandbyModeEvent)(nil)).Elem()
}

type ExpandVmfsDatastore ExpandVmfsDatastoreRequestType

func init() {
	t["ExpandVmfsDatastore"] = reflect.TypeOf((*ExpandVmfsDatastore)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.ExpandVmfsDatastore`.
type ExpandVmfsDatastoreRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datastore whose capacity should be increased.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The specification describing which extent of the VMFS
	// datastore to expand.
	Spec VmfsDatastoreExpandSpec `xml:"spec" json:"spec"`
}

func init() {
	t["ExpandVmfsDatastoreRequestType"] = reflect.TypeOf((*ExpandVmfsDatastoreRequestType)(nil)).Elem()
}

type ExpandVmfsDatastoreResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ExpandVmfsExtent ExpandVmfsExtentRequestType

func init() {
	t["ExpandVmfsExtent"] = reflect.TypeOf((*ExpandVmfsExtent)(nil)).Elem()
}

// The parameters of `HostStorageSystem.ExpandVmfsExtent`.
type ExpandVmfsExtentRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The path of the VMFS to expand. See `FileSystemMountInfo`.
	VmfsPath string `xml:"vmfsPath" json:"vmfsPath"`
	// The disk partition corresponding to the extent to be
	// expanded.
	Extent HostScsiDiskPartition `xml:"extent" json:"extent"`
}

func init() {
	t["ExpandVmfsExtentRequestType"] = reflect.TypeOf((*ExpandVmfsExtentRequestType)(nil)).Elem()
}

type ExpandVmfsExtentResponse struct {
}

// An ExpiredAddonLicense fault is thrown if an attempt to acquire an Addon license
// 'feature failed for count 'count'.
type ExpiredAddonLicense struct {
	ExpiredFeatureLicense
}

func init() {
	t["ExpiredAddonLicense"] = reflect.TypeOf((*ExpiredAddonLicense)(nil)).Elem()
}

type ExpiredAddonLicenseFault ExpiredAddonLicense

func init() {
	t["ExpiredAddonLicenseFault"] = reflect.TypeOf((*ExpiredAddonLicenseFault)(nil)).Elem()
}

// An ExpiredEditionLicense fault is thrown if an attempt to acquire an Edition license
// 'feature failed for count 'count'.
type ExpiredEditionLicense struct {
	ExpiredFeatureLicense
}

func init() {
	t["ExpiredEditionLicense"] = reflect.TypeOf((*ExpiredEditionLicense)(nil)).Elem()
}

type ExpiredEditionLicenseFault ExpiredEditionLicense

func init() {
	t["ExpiredEditionLicenseFault"] = reflect.TypeOf((*ExpiredEditionLicenseFault)(nil)).Elem()
}

// An ExpiredFeatureLicense fault is thrown if an attempt to acquire an Addon license
// 'feature failed for count 'count'.
type ExpiredFeatureLicense struct {
	NotEnoughLicenses

	Feature        string    `xml:"feature" json:"feature"`
	Count          int32     `xml:"count" json:"count"`
	ExpirationDate time.Time `xml:"expirationDate" json:"expirationDate"`
}

func init() {
	t["ExpiredFeatureLicense"] = reflect.TypeOf((*ExpiredFeatureLicense)(nil)).Elem()
}

type ExpiredFeatureLicenseFault BaseExpiredFeatureLicense

func init() {
	t["ExpiredFeatureLicenseFault"] = reflect.TypeOf((*ExpiredFeatureLicenseFault)(nil)).Elem()
}

// The parameters of `HostProfileManager.ExportAnswerFile_Task`.
type ExportAnswerFileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Host with which the answer file is associated.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["ExportAnswerFileRequestType"] = reflect.TypeOf((*ExportAnswerFileRequestType)(nil)).Elem()
}

type ExportAnswerFile_Task ExportAnswerFileRequestType

func init() {
	t["ExportAnswerFile_Task"] = reflect.TypeOf((*ExportAnswerFile_Task)(nil)).Elem()
}

type ExportAnswerFile_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ExportProfile ExportProfileRequestType

func init() {
	t["ExportProfile"] = reflect.TypeOf((*ExportProfile)(nil)).Elem()
}

type ExportProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ExportProfileRequestType"] = reflect.TypeOf((*ExportProfileRequestType)(nil)).Elem()
}

type ExportProfileResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type ExportSnapshot ExportSnapshotRequestType

func init() {
	t["ExportSnapshot"] = reflect.TypeOf((*ExportSnapshot)(nil)).Elem()
}

type ExportSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ExportSnapshotRequestType"] = reflect.TypeOf((*ExportSnapshotRequestType)(nil)).Elem()
}

type ExportSnapshotResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ExportVApp ExportVAppRequestType

func init() {
	t["ExportVApp"] = reflect.TypeOf((*ExportVApp)(nil)).Elem()
}

type ExportVAppRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ExportVAppRequestType"] = reflect.TypeOf((*ExportVAppRequestType)(nil)).Elem()
}

type ExportVAppResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ExportVm ExportVmRequestType

func init() {
	t["ExportVm"] = reflect.TypeOf((*ExportVm)(nil)).Elem()
}

type ExportVmRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ExportVmRequestType"] = reflect.TypeOf((*ExportVmRequestType)(nil)).Elem()
}

type ExportVmResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This data object encapsulates extended product information for an extension.
type ExtExtendedProductInfo struct {
	DynamicData

	// URL to extension vendor.
	CompanyUrl string `xml:"companyUrl,omitempty" json:"companyUrl,omitempty"`
	// URL to vendor's description of this extension.
	ProductUrl string `xml:"productUrl,omitempty" json:"productUrl,omitempty"`
	// URL to management UI for this extension.
	ManagementUrl string `xml:"managementUrl,omitempty" json:"managementUrl,omitempty"`
	// The VirtualMachine or VirtualApp that is running this extension.
	//
	// Refers instance of `ManagedEntity`.
	Self *ManagedObjectReference `xml:"self,omitempty" json:"self,omitempty"`
}

func init() {
	t["ExtExtendedProductInfo"] = reflect.TypeOf((*ExtExtendedProductInfo)(nil)).Elem()
}

// This data object contains information about entities managed by this
// extension.
//
// The data can be used by clients to show extra information
// about managed virtual machines or vApps, such as a custom icon and a
// description of the entity.
type ExtManagedEntityInfo struct {
	DynamicData

	// Managed entity type, as defined by the extension.
	//
	// This matches the
	// `type` field in the configuration
	// about a virtual machine or vApp.
	Type string `xml:"type" json:"type"`
	// The URL to a 16x16 pixel icon in PNG format for entities of this
	// type managed by this extension.
	//
	// The design of the icon should
	// allow for the possibility of it being badged with the power state
	// of the entity by the vSphere client. If you do not provide this
	// icon, the icon at
	// `iconUrl`, if found, is
	// scaled down to 16x16 pixels.
	SmallIconUrl string `xml:"smallIconUrl,omitempty" json:"smallIconUrl,omitempty"`
	// The URL to an icon in PNG format that is no larger than 256x256
	// pixels.
	//
	// This icon will be scaled to 16x16, 32x32, 64x64, and
	// 128x128 if needed. The icon is shown for all entities of this type
	// managed by this extension.
	IconUrl string `xml:"iconUrl,omitempty" json:"iconUrl,omitempty"`
	// Description of this managed entity type.
	//
	// This is typically displayed
	// by clients, and should provide users with information about the
	// function of entities of this type.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
}

func init() {
	t["ExtManagedEntityInfo"] = reflect.TypeOf((*ExtManagedEntityInfo)(nil)).Elem()
}

// This data object encapsulates the Solution Manager configuration for
// this extension.
type ExtSolutionManagerInfo struct {
	DynamicData

	// Deprecated as of vSphere API 5.1, see client documentation for the
	// preferred way to integrate custom user interfaces.
	//
	// List of tabs that must be shown in the Solution Manager for this extension.
	//
	// Tabs are shown ordered by their position in this array.
	Tab []ExtSolutionManagerInfoTabInfo `xml:"tab,omitempty" json:"tab,omitempty"`
	// URL for an icon for this extension.
	//
	// The icon will be shown in the Solution
	// Manager for this extension. The icon must be 16x16, and should be in PNG
	// format.
	SmallIconUrl string `xml:"smallIconUrl,omitempty" json:"smallIconUrl,omitempty"`
}

func init() {
	t["ExtSolutionManagerInfo"] = reflect.TypeOf((*ExtSolutionManagerInfo)(nil)).Elem()
}

// Deprecated as of vSphere API 5.1.
//
// This data object contains information about a tab to show in the
// Solution Manager for this extension.
type ExtSolutionManagerInfoTabInfo struct {
	DynamicData

	// The name of the tab.
	Label string `xml:"label" json:"label"`
	// The URL for the webpage to show in the tab.
	//
	// Extra parameters will be added
	// to this URL when vSphere Client loads it. See the "Customizing the vSphere
	// Client" technical note for more information.
	Url string `xml:"url" json:"url"`
}

func init() {
	t["ExtSolutionManagerInfoTabInfo"] = reflect.TypeOf((*ExtSolutionManagerInfoTabInfo)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.ExtendDisk_Task`.
type ExtendDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual disk to be extended.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual disk is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The new capacity of the virtual disk in MB.
	NewCapacityInMB int64 `xml:"newCapacityInMB" json:"newCapacityInMB"`
}

func init() {
	t["ExtendDiskRequestType"] = reflect.TypeOf((*ExtendDiskRequestType)(nil)).Elem()
}

type ExtendDisk_Task ExtendDiskRequestType

func init() {
	t["ExtendDisk_Task"] = reflect.TypeOf((*ExtendDisk_Task)(nil)).Elem()
}

type ExtendDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `ClusterComputeResource.ExtendHCI_Task`.
type ExtendHCIRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Inputs to configure specified set of hosts in the
	// cluster. See
	// `ClusterComputeResourceHostConfigurationInput`
	// for details. Hosts in this list should be part of the cluster and
	// should be in maintenance mode for them to be configured per
	// specification. Hosts which were not configured due to not
	// being in maintenance mode will be returned in
	// `ClusterComputeResourceClusterConfigResult.failedHosts`. Specify
	// `ClusterComputeResourceHostConfigurationInput.hostVmkNics` only if `dvsSetting`
	// is set.
	HostInputs []ClusterComputeResourceHostConfigurationInput `xml:"hostInputs,omitempty" json:"hostInputs,omitempty"`
	// Specification to configure vSAN on specified set of
	// hosts. See vim.vsan.ReconfigSpec for details. This parameter
	// should be specified only when vSan is enabled on the cluster.
	VSanConfigSpec *SDDCBase `xml:"vSanConfigSpec,omitempty" json:"vSanConfigSpec,omitempty"`
}

func init() {
	t["ExtendHCIRequestType"] = reflect.TypeOf((*ExtendHCIRequestType)(nil)).Elem()
}

type ExtendHCI_Task ExtendHCIRequestType

func init() {
	t["ExtendHCI_Task"] = reflect.TypeOf((*ExtendHCI_Task)(nil)).Elem()
}

type ExtendHCI_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ExtendVffs ExtendVffsRequestType

func init() {
	t["ExtendVffs"] = reflect.TypeOf((*ExtendVffs)(nil)).Elem()
}

// The parameters of `HostStorageSystem.ExtendVffs`.
type ExtendVffsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The path of the VFFS to extend. See `FileSystemMountInfo`.
	VffsPath string `xml:"vffsPath" json:"vffsPath"`
	// Device path of the SSD disk.
	DevicePath string `xml:"devicePath" json:"devicePath"`
	// A data object that describes the SSD disk partition
	// information. If this property is not provided, partition
	// information will be computed and generated.
	Spec *HostDiskPartitionSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["ExtendVffsRequestType"] = reflect.TypeOf((*ExtendVffsRequestType)(nil)).Elem()
}

type ExtendVffsResponse struct {
}

// The parameters of `VirtualDiskManager.ExtendVirtualDisk_Task`.
type ExtendVirtualDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk whose capacity should be expanded.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// The new capacty of the virtual disk in Kb.
	NewCapacityKb int64 `xml:"newCapacityKb" json:"newCapacityKb"`
	// If true, the extended part of the disk will be
	// explicitly filled with zeroes.
	EagerZero *bool `xml:"eagerZero" json:"eagerZero,omitempty"`
}

func init() {
	t["ExtendVirtualDiskRequestType"] = reflect.TypeOf((*ExtendVirtualDiskRequestType)(nil)).Elem()
}

type ExtendVirtualDisk_Task ExtendVirtualDiskRequestType

func init() {
	t["ExtendVirtualDisk_Task"] = reflect.TypeOf((*ExtendVirtualDisk_Task)(nil)).Elem()
}

type ExtendVirtualDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ExtendVmfsDatastore ExtendVmfsDatastoreRequestType

func init() {
	t["ExtendVmfsDatastore"] = reflect.TypeOf((*ExtendVmfsDatastore)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.ExtendVmfsDatastore`.
type ExtendVmfsDatastoreRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datastore whose capacity should be increased.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The specification describing what extents to add to a
	// VMFS datastore.
	Spec VmfsDatastoreExtendSpec `xml:"spec" json:"spec"`
}

func init() {
	t["ExtendVmfsDatastoreRequestType"] = reflect.TypeOf((*ExtendVmfsDatastoreRequestType)(nil)).Elem()
}

type ExtendVmfsDatastoreResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ExtendedDescription struct {
	Description

	// Key to the localized message string in the catalog.
	//
	// If the localized string contains parameters, values to the
	// parameters will be provided in #messageArg.
	// E.g: If the message in the catalog is
	// "IP address is {address}", value for "address"
	// will be provided by #messageArg.
	// Both summary and label in Description will have a corresponding
	// entry in the message catalog with the keys
	// &lt;messageCatalogKeyPrefix&gt;.summary and &lt;messageCatalogKeyPrefix&gt;.label
	// respectively.
	// Description.summary and Description.label will contain
	// the strings in server locale.
	MessageCatalogKeyPrefix string `xml:"messageCatalogKeyPrefix" json:"messageCatalogKeyPrefix"`
	// Provides named arguments that can be used to localize the
	// message in the catalog.
	MessageArg []KeyAnyValue `xml:"messageArg,omitempty" json:"messageArg,omitempty"`
}

func init() {
	t["ExtendedDescription"] = reflect.TypeOf((*ExtendedDescription)(nil)).Elem()
}

type ExtendedElementDescription struct {
	ElementDescription

	// Key to the localized message string in the catalog.
	//
	// If the localized string contains parameters, values to the
	// parameters will be provided in #messageArg.
	// E.g: If the message in the catalog is
	// "IP address is {address}", value for "address"
	// will be provided by #messageArg.
	// Both summary and label in ElementDescription will have a corresponding
	// entry in the message catalog with the keys
	// &lt;messageCatalogKeyPrefix&gt;.summary and &lt;messageCatalogKeyPrefix&gt;.label
	// respectively.
	// ElementDescription.summary and ElementDescription.label will contain
	// the strings in server locale.
	MessageCatalogKeyPrefix string `xml:"messageCatalogKeyPrefix" json:"messageCatalogKeyPrefix"`
	// Provides named arguments that can be used to localize the
	// message in the catalog.
	MessageArg []KeyAnyValue `xml:"messageArg,omitempty" json:"messageArg,omitempty"`
}

func init() {
	t["ExtendedElementDescription"] = reflect.TypeOf((*ExtendedElementDescription)(nil)).Elem()
}

// This event is the base class for extended events.
type ExtendedEvent struct {
	GeneralEvent

	// The id of the type of extended event.
	EventTypeId string `xml:"eventTypeId" json:"eventTypeId"`
	// The object on which the event was logged.
	ManagedObject ManagedObjectReference `xml:"managedObject" json:"managedObject"`
	// Key/value pairs associated with event.
	Data []ExtendedEventPair `xml:"data,omitempty" json:"data,omitempty"`
}

func init() {
	t["ExtendedEvent"] = reflect.TypeOf((*ExtendedEvent)(nil)).Elem()
}

// key/value pair
type ExtendedEventPair struct {
	DynamicData

	Key   string `xml:"key" json:"key"`
	Value string `xml:"value" json:"value"`
}

func init() {
	t["ExtendedEventPair"] = reflect.TypeOf((*ExtendedEventPair)(nil)).Elem()
}

// This fault is the container for faults logged by extensions.
type ExtendedFault struct {
	VimFault

	// The id of the type of extended fault.
	FaultTypeId string `xml:"faultTypeId" json:"faultTypeId"`
	// Key/value pairs associated with fault.
	Data []KeyValue `xml:"data,omitempty" json:"data,omitempty"`
}

func init() {
	t["ExtendedFault"] = reflect.TypeOf((*ExtendedFault)(nil)).Elem()
}

type ExtendedFaultFault ExtendedFault

func init() {
	t["ExtendedFaultFault"] = reflect.TypeOf((*ExtendedFaultFault)(nil)).Elem()
}

// This data object type contains all information about an extension.
//
// An extension may contain zero or more server interfaces and zero
// or more clients.
type Extension struct {
	DynamicData

	// Description of extension.
	Description BaseDescription `xml:"description,typeattr" json:"description"`
	// Extension key.
	//
	// Should follow java package naming conventions
	// for uniqueness (e.g. "com.example.management").
	//
	// Extension names can only contain characters belonging to the
	// lower ASCII character set (UTF-7) with the exception of the
	// following characters:
	//  1. All whitespace characters ("space" - ascii character 0x20 is allowed)
	//  2. Control characters
	//  3. Comma (ascii 0x2c), Forward slash (ascii 0x2f), Backward slash (ascii 0x5c),
	//     Hash/Pound (ascii 0x23), Plus (ascii 0x2b), Greater (ascii 0x3e), Lesser (ascii 0x3c),
	//     Equals (ascii 0x3d), Semi-colon (ascii 0x3b) and Double quote (ascii 0x22).
	Key string `xml:"key" json:"key"`
	// Company information.
	Company string `xml:"company,omitempty" json:"company,omitempty"`
	// Type of extension (example may include CP-DVS, NUOVA-DVS, etc.).
	Type string `xml:"type,omitempty" json:"type,omitempty"`
	// Extension version number as a dot-separated string.
	//
	// For example, "1.0.0"
	Version string `xml:"version" json:"version"`
	// Subject name from client certificate.
	SubjectName string `xml:"subjectName,omitempty" json:"subjectName,omitempty"`
	// Servers for this extension.
	Server []ExtensionServerInfo `xml:"server,omitempty" json:"server,omitempty"`
	// Clients for this extension.
	Client []ExtensionClientInfo `xml:"client,omitempty" json:"client,omitempty"`
	// Definitions of tasks defined by this extension.
	TaskList []ExtensionTaskTypeInfo `xml:"taskList,omitempty" json:"taskList,omitempty"`
	// Definitions of events defined by this extension.
	EventList []ExtensionEventTypeInfo `xml:"eventList,omitempty" json:"eventList,omitempty"`
	// Definitions of faults defined by this extension.
	FaultList []ExtensionFaultTypeInfo `xml:"faultList,omitempty" json:"faultList,omitempty"`
	// Definitions privileges defined by this extension.
	PrivilegeList []ExtensionPrivilegeInfo `xml:"privilegeList,omitempty" json:"privilegeList,omitempty"`
	// Resource data for all locales
	ResourceList []ExtensionResourceInfo `xml:"resourceList,omitempty" json:"resourceList,omitempty"`
	// Last extension heartbeat time.
	LastHeartbeatTime time.Time `xml:"lastHeartbeatTime" json:"lastHeartbeatTime"`
	// Health specification provided by this extension.
	HealthInfo *ExtensionHealthInfo `xml:"healthInfo,omitempty" json:"healthInfo,omitempty"`
	// OVF consumer specification provided by this extension.
	OvfConsumerInfo *ExtensionOvfConsumerInfo `xml:"ovfConsumerInfo,omitempty" json:"ovfConsumerInfo,omitempty"`
	// Extended product information, such as URLs to vendor, product, etc.
	ExtendedProductInfo *ExtExtendedProductInfo `xml:"extendedProductInfo,omitempty" json:"extendedProductInfo,omitempty"`
	// Information about entities managed by this extension.
	//
	// An extension can
	// register virtual machines as managed by itself, by setting the
	// `managedBy` property of the virtual
	// machine.
	ManagedEntityInfo []ExtManagedEntityInfo `xml:"managedEntityInfo,omitempty" json:"managedEntityInfo,omitempty"`
	// Opt-in to the Solution Manager.
	//
	// If set to true, this extension will be
	// shown in the Solution Manager. If not set, or set to false, this extension
	// is not shown in the Solution Manager.
	ShownInSolutionManager *bool `xml:"shownInSolutionManager" json:"shownInSolutionManager,omitempty"`
	// Solution Manager configuration for this extension.
	SolutionManagerInfo *ExtSolutionManagerInfo `xml:"solutionManagerInfo,omitempty" json:"solutionManagerInfo,omitempty"`
}

func init() {
	t["Extension"] = reflect.TypeOf((*Extension)(nil)).Elem()
}

// This data object type describes a client of the extension.
type ExtensionClientInfo struct {
	DynamicData

	// Client version number as a dot-separated string.
	//
	// For example, "1.0.0"
	Version string `xml:"version" json:"version"`
	// Description of client.
	Description BaseDescription `xml:"description,typeattr" json:"description"`
	// Company information.
	Company string `xml:"company" json:"company"`
	// Type of client (examples may include win32, .net, linux, etc.).
	Type string `xml:"type" json:"type"`
	// Plugin url.
	Url string `xml:"url" json:"url"`
}

func init() {
	t["ExtensionClientInfo"] = reflect.TypeOf((*ExtensionClientInfo)(nil)).Elem()
}

// This data object type describes event types defined by the extension.
type ExtensionEventTypeInfo struct {
	DynamicData

	// The ID of the event type.
	//
	// Should follow java package
	// naming conventions for uniqueness.
	EventID string `xml:"eventID" json:"eventID"`
	// Optional XML descriptor for the EventType.
	//
	// The structure of this descriptor is:
	//
	//	<EventType>
	//	  <eventTypeID>eventID</eventTypeID>
	//	  <description>Optional description for event eventID</description>
	//	  <-- Optional arguments: -->
	//	  <arguments>
	//	     <-- Zero or more of: -->
	//	     <argument>
	//	       <name>argName</name>
	//	       <type>argtype</name>
	//	     </argument>
	//	  </arguments>
	//	</EventType>
	//
	// where _argtype_ can be one of the following:
	//   - This is an example list and should be considered as incomplete.
	//
	// <!-- -->
	//   - Primitive types:
	//   - _string_
	//   - _bool_
	//   - _int_
	//   - _long_
	//   - _float_
	//   - _moid_
	//   - Entity reference types:
	//   - _vm_
	//   - _host_
	//   - _resourcepool_
	//   - _computeresource_
	//   - _datacenter_
	//   - _datastore_
	//   - _network_
	//   - _dvs_
	EventTypeSchema string `xml:"eventTypeSchema,omitempty" json:"eventTypeSchema,omitempty"`
}

func init() {
	t["ExtensionEventTypeInfo"] = reflect.TypeOf((*ExtensionEventTypeInfo)(nil)).Elem()
}

// This data object type describes fault types defined by the extension.
type ExtensionFaultTypeInfo struct {
	DynamicData

	// The ID of the fault type.
	//
	// Should follow java package
	// naming conventions for uniqueness.
	FaultID string `xml:"faultID" json:"faultID"`
}

func init() {
	t["ExtensionFaultTypeInfo"] = reflect.TypeOf((*ExtensionFaultTypeInfo)(nil)).Elem()
}

// This data object encapsulates the health specification for the
// extension.
type ExtensionHealthInfo struct {
	DynamicData

	Url string `xml:"url" json:"url"`
}

func init() {
	t["ExtensionHealthInfo"] = reflect.TypeOf((*ExtensionHealthInfo)(nil)).Elem()
}

// This data object type contains usage information about an
// extension's IP allocation usage.
type ExtensionManagerIpAllocationUsage struct {
	DynamicData

	// Key of the extension whose usage is being
	// reported.
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
	// Number of IP addresses allocated from IP pools.
	NumAddresses int32 `xml:"numAddresses" json:"numAddresses"`
}

func init() {
	t["ExtensionManagerIpAllocationUsage"] = reflect.TypeOf((*ExtensionManagerIpAllocationUsage)(nil)).Elem()
}

// This data object contains configuration for extensions that also extend the OVF
// functionality of vCenter server.
//
// `*Note:*` This feature is for internal use only.
type ExtensionOvfConsumerInfo struct {
	DynamicData

	// Callback url for the OVF consumer.
	//
	// This URL must point to a SOAP API
	// implementing the OVF consumer interface.
	//
	// Example: https://extension-host:8081/
	//
	// This callback is for internal use only.
	CallbackUrl string `xml:"callbackUrl" json:"callbackUrl"`
	// A list of fully qualified OVF section types that this consumer handles.
	//
	// Fully qualified means that each section type must be prefixed with its namespace
	// enclosed in curly braces. See the examples below.
	//
	// An InvalidArgument error is thrown if there is overlap between OVF consumers,
	// meaning that the same section type appears in the sectionType list of more than
	// one OVF consumer.
	//
	// Example: \[ "{http://www.vmware.com/schema/vServiceManager}vServiceDependency",
	// "{http://www.vmware.com/schema/vServiceManager}vServiceBinding" \]
	SectionType []string `xml:"sectionType" json:"sectionType"`
}

func init() {
	t["ExtensionOvfConsumerInfo"] = reflect.TypeOf((*ExtensionOvfConsumerInfo)(nil)).Elem()
}

// This data object type describes privileges defined by the extension.
type ExtensionPrivilegeInfo struct {
	DynamicData

	// The ID of the privilege.
	//
	// The format should be
	// &quot;&lt;group name&gt;.&lt;privilege name&gt;&quot;.
	// The group name should be the same as the privGroupName
	// property.
	//
	// The privilege name should follow java package naming
	// conventions for uniqueness. The set of characters allowed
	// follow the same rules as `Extension.key`.
	PrivID string `xml:"privID" json:"privID"`
	// Hierarchical group name.
	//
	// Each level of the grouping hierarchy is
	// separated by a "." so group names may not include a ".".
	// `AuthorizationPrivilege.privGroupName`.
	PrivGroupName string `xml:"privGroupName" json:"privGroupName"`
}

func init() {
	t["ExtensionPrivilegeInfo"] = reflect.TypeOf((*ExtensionPrivilegeInfo)(nil)).Elem()
}

// This data object encapsulates the message resources for all locales.
type ExtensionResourceInfo struct {
	DynamicData

	Locale string `xml:"locale" json:"locale"`
	// Module for a resource type and other message or fault resources.
	//
	// Examples: "task" for task, "event" for event and "auth" for "privilege".
	Module string     `xml:"module" json:"module"`
	Data   []KeyValue `xml:"data" json:"data"`
}

func init() {
	t["ExtensionResourceInfo"] = reflect.TypeOf((*ExtensionResourceInfo)(nil)).Elem()
}

// This data object type describes a server for the extension.
type ExtensionServerInfo struct {
	DynamicData

	// Server url.
	Url string `xml:"url" json:"url"`
	// Server description.
	Description BaseDescription `xml:"description,typeattr" json:"description"`
	// Company information.
	Company string `xml:"company" json:"company"`
	// Type of server (examples may include SOAP, REST, HTTP, etc.).
	Type string `xml:"type" json:"type"`
	// Extension administrator email addresses.
	AdminEmail []string `xml:"adminEmail" json:"adminEmail"`
	// Thumbprint of the extension server certificate presented to clients
	ServerThumbprint string `xml:"serverThumbprint,omitempty" json:"serverThumbprint,omitempty"`
	// X.509 certificate of the extension server presented to clients in PEM
	// format according to RFC 7468
	ServerCertificate string `xml:"serverCertificate,omitempty" json:"serverCertificate,omitempty" vim:"8.0.2.0"`
}

func init() {
	t["ExtensionServerInfo"] = reflect.TypeOf((*ExtensionServerInfo)(nil)).Elem()
}

// This data object type describes task types defined by the extension.
type ExtensionTaskTypeInfo struct {
	DynamicData

	// The ID of the task type.
	//
	// Should follow java package
	// naming conventions for uniqueness.
	TaskID string `xml:"taskID" json:"taskID"`
}

func init() {
	t["ExtensionTaskTypeInfo"] = reflect.TypeOf((*ExtensionTaskTypeInfo)(nil)).Elem()
}

type ExtractOvfEnvironment ExtractOvfEnvironmentRequestType

func init() {
	t["ExtractOvfEnvironment"] = reflect.TypeOf((*ExtractOvfEnvironment)(nil)).Elem()
}

type ExtractOvfEnvironmentRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ExtractOvfEnvironmentRequestType"] = reflect.TypeOf((*ExtractOvfEnvironmentRequestType)(nil)).Elem()
}

type ExtractOvfEnvironmentResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// Fault type that could be thrown when enabling SPBM(Storage Policy
// Based Management) feature of a compute resource.
type FailToEnableSPBM struct {
	NotEnoughLicenses

	// The compute resource
	//
	// Refers instance of `ComputeResource`.
	Cs ManagedObjectReference `xml:"cs" json:"cs"`
	// The computer resource name
	CsName string `xml:"csName" json:"csName"`
	// Array of `ComputeResourceHostSPBMLicenseInfo` that
	// contains SPBM license information for all hosts in the compute resource
	HostLicenseStates []ComputeResourceHostSPBMLicenseInfo `xml:"hostLicenseStates" json:"hostLicenseStates"`
}

func init() {
	t["FailToEnableSPBM"] = reflect.TypeOf((*FailToEnableSPBM)(nil)).Elem()
}

type FailToEnableSPBMFault FailToEnableSPBM

func init() {
	t["FailToEnableSPBMFault"] = reflect.TypeOf((*FailToEnableSPBMFault)(nil)).Elem()
}

// Thrown when trying to state lock a Fault Tolerance VM, and the
// other VM in the same Fault Tolerance pair is already locked.
type FailToLockFaultToleranceVMs struct {
	RuntimeFault

	// The name of the vm to be locked.
	VmName string `xml:"vmName" json:"vmName"`
	// The vm to be locked, this can be a Fault Tolerance primary or secondary VM
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The vm that is already locked, this can be a Fault Tolerance primary or secondary VM
	//
	// Refers instance of `VirtualMachine`.
	AlreadyLockedVm ManagedObjectReference `xml:"alreadyLockedVm" json:"alreadyLockedVm"`
}

func init() {
	t["FailToLockFaultToleranceVMs"] = reflect.TypeOf((*FailToLockFaultToleranceVMs)(nil)).Elem()
}

type FailToLockFaultToleranceVMsFault FailToLockFaultToleranceVMs

func init() {
	t["FailToLockFaultToleranceVMsFault"] = reflect.TypeOf((*FailToLockFaultToleranceVMsFault)(nil)).Elem()
}

// This event records that the amount of cluster resources has increased
// and is now sufficient to satisfy the configured HA failover level.
type FailoverLevelRestored struct {
	ClusterEvent
}

func init() {
	t["FailoverLevelRestored"] = reflect.TypeOf((*FailoverLevelRestored)(nil)).Elem()
}

type FailoverNodeInfo struct {
	DynamicData

	// VCHA Cluster network configuration of the node.
	//
	// All cluster communication (state replication, heartbeat,
	// cluster messages) happens over this network.
	ClusterIpSettings CustomizationIPSettings `xml:"clusterIpSettings" json:"clusterIpSettings"`
	// Failover IP address that this node will assume after the failover
	// to serve client requests.
	//
	// Each failover node can have a different
	// failover IP address.
	FailoverIp *CustomizationIPSettings `xml:"failoverIp,omitempty" json:"failoverIp,omitempty"`
	// BIOS UUID for the node.
	//
	// It is set only if the VCHA Cluster was
	// formed using automatic provisioning by the deploy API.
	BiosUuid string `xml:"biosUuid,omitempty" json:"biosUuid,omitempty"`
}

func init() {
	t["FailoverNodeInfo"] = reflect.TypeOf((*FailoverNodeInfo)(nil)).Elem()
}

// Represents the identity of a replication fault domain.
//
// Fault domains IDs are globally
// unique.
type FaultDomainId struct {
	DynamicData

	// ID of the fault domain.
	Id string `xml:"id" json:"id"`
}

func init() {
	t["FaultDomainId"] = reflect.TypeOf((*FaultDomainId)(nil)).Elem()
}

// More than one VM in the same fault tolerance group are placed on the same host
type FaultToleranceAntiAffinityViolated struct {
	MigrationFault

	// The name of the host.
	HostName string `xml:"hostName" json:"hostName"`
	// The host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["FaultToleranceAntiAffinityViolated"] = reflect.TypeOf((*FaultToleranceAntiAffinityViolated)(nil)).Elem()
}

type FaultToleranceAntiAffinityViolatedFault FaultToleranceAntiAffinityViolated

func init() {
	t["FaultToleranceAntiAffinityViolatedFault"] = reflect.TypeOf((*FaultToleranceAntiAffinityViolatedFault)(nil)).Elem()
}

// The memory size, reservation, limit or shares of a virtual machine cannot
// be edited if Fault Tolerance is turned on
type FaultToleranceCannotEditMem struct {
	VmConfigFault

	// The name of the VM.
	VmName string `xml:"vmName" json:"vmName"`
	// The VM.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
}

func init() {
	t["FaultToleranceCannotEditMem"] = reflect.TypeOf((*FaultToleranceCannotEditMem)(nil)).Elem()
}

type FaultToleranceCannotEditMemFault FaultToleranceCannotEditMem

func init() {
	t["FaultToleranceCannotEditMemFault"] = reflect.TypeOf((*FaultToleranceCannotEditMemFault)(nil)).Elem()
}

// FaultToleranceConfigInfo is a data object type containing Fault Tolerance
// settings for this virtual machine.
//
// role, instanceUuids and configPaths contain information about the
// whole fault tolerance group.
type FaultToleranceConfigInfo struct {
	DynamicData

	// The index of the current VM in instanceUuids array starting from 1, so
	// 1 means that it is the primary VM.
	Role int32 `xml:"role" json:"role"`
	// The instanceUuid of all the VMs in this fault tolerance group.
	//
	// The
	// first element is the instanceUuid of the primary VM.
	InstanceUuids []string `xml:"instanceUuids" json:"instanceUuids"`
	// The configuration file path for all the VMs in this fault tolerance
	// group.
	ConfigPaths []string `xml:"configPaths" json:"configPaths"`
	// Indicates whether a secondary VM is orphaned (no longer associated with
	// the primary VM).
	Orphaned *bool `xml:"orphaned" json:"orphaned,omitempty"`
}

func init() {
	t["FaultToleranceConfigInfo"] = reflect.TypeOf((*FaultToleranceConfigInfo)(nil)).Elem()
}

// FaultToleranceConfigSpec contains information about the metadata file
// and vmdk files for a fault tolerant VM pair.
type FaultToleranceConfigSpec struct {
	DynamicData

	// Metadata file information
	MetaDataPath *FaultToleranceMetaSpec `xml:"metaDataPath,omitempty" json:"metaDataPath,omitempty"`
	// Placement information for secondary
	SecondaryVmSpec *FaultToleranceVMConfigSpec `xml:"secondaryVmSpec,omitempty" json:"secondaryVmSpec,omitempty"`
	// Indicates whether FT Metro Cluster is enabled/disabled.
	//
	// \- If TRUE, FT Metro Cluster is enabled for the VM. An implicit
	// Anti-HostGroup will be generated from HostGroup defined for FT
	// primary, then affine the primary with one HostGroup and affine the
	// secondary with another HostGroup.
	// \- If FALSE or unset, FT Metro Cluster is disabled for the VM. Both FT
	// primary and secondary will be put in the same HostGroup.
	MetroFtEnabled *bool `xml:"metroFtEnabled" json:"metroFtEnabled,omitempty" vim:"8.0.3.0"`
	// Indicate the Host Group (`ClusterHostGroup`) for FT
	// Metro Cluster enabled Virtual Machine.
	//
	// Based on the selected Host Group, FT can divide the hosts in the cluster
	// into two groups and ensure to place FT primary and FT secondary in
	// different groups.
	MetroFtHostGroup string `xml:"metroFtHostGroup,omitempty" json:"metroFtHostGroup,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["FaultToleranceConfigSpec"] = reflect.TypeOf((*FaultToleranceConfigSpec)(nil)).Elem()
}

// Convenience subclass for calling out some named features among the
// incompatibilities found in CPUID level 1 register ecx for FT vms.
type FaultToleranceCpuIncompatible struct {
	CpuIncompatible

	// Flag to indicate CPU model is incompatible.
	Model bool `xml:"model" json:"model"`
	// Flag to indicate CPU family is incompatible.
	Family bool `xml:"family" json:"family"`
	// Flag to indicate CPU stepping is incompatible.
	Stepping bool `xml:"stepping" json:"stepping"`
}

func init() {
	t["FaultToleranceCpuIncompatible"] = reflect.TypeOf((*FaultToleranceCpuIncompatible)(nil)).Elem()
}

type FaultToleranceCpuIncompatibleFault FaultToleranceCpuIncompatible

func init() {
	t["FaultToleranceCpuIncompatibleFault"] = reflect.TypeOf((*FaultToleranceCpuIncompatibleFault)(nil)).Elem()
}

// FaultToleranceDiskSpec contains disk managed object and destination
// datastore of disks associated with a VM.
type FaultToleranceDiskSpec struct {
	DynamicData

	// Disk Managed Object
	Disk BaseVirtualDevice `xml:"disk,typeattr" json:"disk"`
	// Destination location for disk
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["FaultToleranceDiskSpec"] = reflect.TypeOf((*FaultToleranceDiskSpec)(nil)).Elem()
}

// This data object encapsulates the Datastore for the shared metadata file
// for a fault tolerant pair of VMs.
type FaultToleranceMetaSpec struct {
	DynamicData

	// Datastore for the metadata file
	//
	// Refers instance of `Datastore`.
	MetaDataDatastore ManagedObjectReference `xml:"metaDataDatastore" json:"metaDataDatastore"`
}

func init() {
	t["FaultToleranceMetaSpec"] = reflect.TypeOf((*FaultToleranceMetaSpec)(nil)).Elem()
}

// Fault Tolerance VM requires thick disks
type FaultToleranceNeedsThickDisk struct {
	MigrationFault

	// The name of the VM.
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["FaultToleranceNeedsThickDisk"] = reflect.TypeOf((*FaultToleranceNeedsThickDisk)(nil)).Elem()
}

type FaultToleranceNeedsThickDiskFault FaultToleranceNeedsThickDisk

func init() {
	t["FaultToleranceNeedsThickDiskFault"] = reflect.TypeOf((*FaultToleranceNeedsThickDiskFault)(nil)).Elem()
}

// This fault is thrown when fault tolerance has not been licensed on the
// source or destination host.
//
// It must be licensed on both hosts.
type FaultToleranceNotLicensed struct {
	VmFaultToleranceIssue

	// The host name
	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
}

func init() {
	t["FaultToleranceNotLicensed"] = reflect.TypeOf((*FaultToleranceNotLicensed)(nil)).Elem()
}

type FaultToleranceNotLicensedFault FaultToleranceNotLicensed

func init() {
	t["FaultToleranceNotLicensedFault"] = reflect.TypeOf((*FaultToleranceNotLicensedFault)(nil)).Elem()
}

// The destination host does not have the same build or Fault Tolerance
// feature version number as the source host.
type FaultToleranceNotSameBuild struct {
	MigrationFault

	// The string.
	Build string `xml:"build" json:"build"`
}

func init() {
	t["FaultToleranceNotSameBuild"] = reflect.TypeOf((*FaultToleranceNotSameBuild)(nil)).Elem()
}

type FaultToleranceNotSameBuildFault FaultToleranceNotSameBuild

func init() {
	t["FaultToleranceNotSameBuildFault"] = reflect.TypeOf((*FaultToleranceNotSameBuildFault)(nil)).Elem()
}

// FaultTolerancePrimaryConfigInfo is a data object type containing Fault Tolerance
// settings for a primary virtual machine in a fault tolerance group
type FaultTolerancePrimaryConfigInfo struct {
	FaultToleranceConfigInfo

	// Refers instances of `VirtualMachine`.
	Secondaries []ManagedObjectReference `xml:"secondaries" json:"secondaries"`
}

func init() {
	t["FaultTolerancePrimaryConfigInfo"] = reflect.TypeOf((*FaultTolerancePrimaryConfigInfo)(nil)).Elem()
}

// This fault is used to report that VirtualCenter did not attempt to power on
// a Fault Tolerance secondary virtual machine because it was unable to
// power on the corresponding Fault Tolerance primary virtual machine.
type FaultTolerancePrimaryPowerOnNotAttempted struct {
	VmFaultToleranceIssue

	// The secondary virtual machine that was not attempted
	//
	// Refers instance of `VirtualMachine`.
	SecondaryVm ManagedObjectReference `xml:"secondaryVm" json:"secondaryVm"`
	// The corresponding primary virtual machine
	//
	// Refers instance of `VirtualMachine`.
	PrimaryVm ManagedObjectReference `xml:"primaryVm" json:"primaryVm"`
}

func init() {
	t["FaultTolerancePrimaryPowerOnNotAttempted"] = reflect.TypeOf((*FaultTolerancePrimaryPowerOnNotAttempted)(nil)).Elem()
}

type FaultTolerancePrimaryPowerOnNotAttemptedFault FaultTolerancePrimaryPowerOnNotAttempted

func init() {
	t["FaultTolerancePrimaryPowerOnNotAttemptedFault"] = reflect.TypeOf((*FaultTolerancePrimaryPowerOnNotAttemptedFault)(nil)).Elem()
}

// FaultToleranceSecondaryConfigInfo is a data object type containing Fault Tolerance
// settings for a secondary virtual machine in a fault tolerance group
type FaultToleranceSecondaryConfigInfo struct {
	FaultToleranceConfigInfo

	// Refers instance of `VirtualMachine`.
	PrimaryVM ManagedObjectReference `xml:"primaryVM" json:"primaryVM"`
}

func init() {
	t["FaultToleranceSecondaryConfigInfo"] = reflect.TypeOf((*FaultToleranceSecondaryConfigInfo)(nil)).Elem()
}

// FaultToleranceSecondaryOpResult is a data object that reports on
// the outcome of the `VirtualMachine.CreateSecondaryVM_Task` or
// `VirtualMachine.EnableSecondaryVM_Task` operation.
type FaultToleranceSecondaryOpResult struct {
	DynamicData

	// The Secondary VirtualMachine
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Whether an attempt was made to power on the secondary.
	//
	// If
	// an attempt was made, `FaultToleranceSecondaryOpResult.powerOnResult` will report the
	// status of this attempt.
	PowerOnAttempted bool `xml:"powerOnAttempted" json:"powerOnAttempted"`
	// The powerOnResult property reports the outcome of powering on the
	// Secondary VirtualMachine if a power on was required.
	//
	// A power on will
	// be attempted if the Primary Virtual Machine is powered on when the
	// operation is performed. This object is only reported if `FaultToleranceSecondaryOpResult.powerOnAttempted` is true. If the outcome of the power-on attempt
	// is not successful, the returned `ClusterPowerOnVmResult`
	// object will include an instance of `ClusterNotAttemptedVmInfo`
	// whereas if the attempt was successful, then an instance of
	// `ClusterAttemptedVmInfo` is returned. When
	// `ClusterAttemptedVmInfo` is returned, its
	// `ClusterAttemptedVmInfo.task` property is only set if the cluster
	// is a HA-only cluster.
	PowerOnResult *ClusterPowerOnVmResult `xml:"powerOnResult,omitempty" json:"powerOnResult,omitempty"`
}

func init() {
	t["FaultToleranceSecondaryOpResult"] = reflect.TypeOf((*FaultToleranceSecondaryOpResult)(nil)).Elem()
}

// FaultToleranceVMConfigSpec contains information about placement of
// fault tolerant VM.
type FaultToleranceVMConfigSpec struct {
	DynamicData

	// Datastore for the configuration file for the virtual machine, e.g., the
	// .vmx file.
	//
	// This also implicitly defines the configuration directory.
	//
	// Refers instance of `Datastore`.
	VmConfig *ManagedObjectReference `xml:"vmConfig,omitempty" json:"vmConfig,omitempty"`
	// Array of disks associated with the VM
	Disks []FaultToleranceDiskSpec `xml:"disks,omitempty" json:"disks,omitempty"`
}

func init() {
	t["FaultToleranceVMConfigSpec"] = reflect.TypeOf((*FaultToleranceVMConfigSpec)(nil)).Elem()
}

// A FaultToleranceVmNotDasProtected fault occurs when an Fault Tolerance VM
// is not protected by HA and the operation for terminating the primary VM
// or secondary VM is invoked.
type FaultToleranceVmNotDasProtected struct {
	VimFault

	// The Fault Toelrance primary VM
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Name of the VM
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["FaultToleranceVmNotDasProtected"] = reflect.TypeOf((*FaultToleranceVmNotDasProtected)(nil)).Elem()
}

type FaultToleranceVmNotDasProtectedFault FaultToleranceVmNotDasProtected

func init() {
	t["FaultToleranceVmNotDasProtectedFault"] = reflect.TypeOf((*FaultToleranceVmNotDasProtectedFault)(nil)).Elem()
}

// Group of faults associated with Host.
//
// This Class is used in e.g.
// `HostEnterMaintenanceResult`.
type FaultsByHost struct {
	DynamicData

	// The Host in the cluster for which faults were generated.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The array of faults related to the given Host.
	Faults []LocalizedMethodFault `xml:"faults,omitempty" json:"faults,omitempty"`
}

func init() {
	t["FaultsByHost"] = reflect.TypeOf((*FaultsByHost)(nil)).Elem()
}

// VM specific faults.
//
// This Class is used in e.g.
// `HostEnterMaintenanceResult`.
type FaultsByVM struct {
	DynamicData

	// The VM for which faults were generated.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The array of faults related to the given VM.
	Faults []LocalizedMethodFault `xml:"faults,omitempty" json:"faults,omitempty"`
}

func init() {
	t["FaultsByVM"] = reflect.TypeOf((*FaultsByVM)(nil)).Elem()
}

// This data object type describes an FCoE configuration as it pertains
// to an underlying physical NIC.
//
// Terminology is borrowed from T11's working draft of the Fibre Channel
// Backbone 5 standard (FC-BB-5). The draft can be found at
// http://www.t11.org.
type FcoeConfig struct {
	DynamicData

	// 802.1p priority class used for FCoE traffic.
	PriorityClass int32 `xml:"priorityClass" json:"priorityClass"`
	// Source MAC address used for FCoE traffic.
	//
	// This MAC address is associated with the logical construct that is a
	// physical NIC's associated underlying FCoE Controller, as defined in the
	// FC-BB-5 standard.
	// This MAC address should be of the form "xx:xx:xx:xx:xx:xx", where 'x' is
	// a hexadecimal digit. Valid MAC addresses are unicast addresses.
	SourceMac string `xml:"sourceMac" json:"sourceMac"`
	// VLAN ranges associated with this FcoeConfig.
	VlanRange []FcoeConfigVlanRange `xml:"vlanRange" json:"vlanRange"`
	// Settable capabilities for this FcoeConfig.
	Capabilities FcoeConfigFcoeCapabilities `xml:"capabilities" json:"capabilities"`
	// Indicates whether this FcoeConfig is "active" (has been used in
	// conjunction with a parent physical network adapter for FCoE
	// discovery).
	FcoeActive bool `xml:"fcoeActive" json:"fcoeActive"`
}

func init() {
	t["FcoeConfig"] = reflect.TypeOf((*FcoeConfig)(nil)).Elem()
}

// Flags which indicate what parameters are settable for this FcoeConfig.
type FcoeConfigFcoeCapabilities struct {
	DynamicData

	PriorityClass    bool `xml:"priorityClass" json:"priorityClass"`
	SourceMacAddress bool `xml:"sourceMacAddress" json:"sourceMacAddress"`
	VlanRange        bool `xml:"vlanRange" json:"vlanRange"`
}

func init() {
	t["FcoeConfigFcoeCapabilities"] = reflect.TypeOf((*FcoeConfigFcoeCapabilities)(nil)).Elem()
}

// An FcoeSpecification contains values relevant to issuing FCoE discovery.
//
// Non-mandatory values are denoted '@optional'.
type FcoeConfigFcoeSpecification struct {
	DynamicData

	// The name of this FcoeSpecification's underlying PhysicalNic
	UnderlyingPnic string `xml:"underlyingPnic" json:"underlyingPnic"`
	// 802.1p priority class to use for FCoE traffic.
	PriorityClass int32 `xml:"priorityClass,omitempty" json:"priorityClass,omitempty"`
	// Source MAC address to use for FCoE traffic.
	//
	// This MAC address is associated with the logical construct that is a
	// physical NIC's associated underlying FCoE Controller, as defined in
	// the FC-BB-5 standard.
	// This MAC address should be of the form "xx:xx:xx:xx:xx:xx", where 'x'
	// is a hexadecimal digit. Valid MAC addresses are unicast addresses.
	SourceMac string `xml:"sourceMac,omitempty" json:"sourceMac,omitempty"`
	// VLAN ranges to use for FCoE traffic.
	VlanRange []FcoeConfigVlanRange `xml:"vlanRange,omitempty" json:"vlanRange,omitempty"`
}

func init() {
	t["FcoeConfigFcoeSpecification"] = reflect.TypeOf((*FcoeConfigFcoeSpecification)(nil)).Elem()
}

// Used to represent inclusive intervals of VLAN IDs.
//
// Valid VLAN IDs fall within the range \[0,4094\], and the low value of a
// VlanRange must be less than or equal to the high value.
type FcoeConfigVlanRange struct {
	DynamicData

	VlanLow  int32 `xml:"vlanLow" json:"vlanLow"`
	VlanHigh int32 `xml:"vlanHigh" json:"vlanHigh"`
}

func init() {
	t["FcoeConfigVlanRange"] = reflect.TypeOf((*FcoeConfigVlanRange)(nil)).Elem()
}

// Deprecated as of vSphere API 8.0. Software FCoE not supported.
//
// Base class for faults that can be thrown while invoking FCoE management operations.
type FcoeFault struct {
	VimFault
}

func init() {
	t["FcoeFault"] = reflect.TypeOf((*FcoeFault)(nil)).Elem()
}

type FcoeFaultFault BaseFcoeFault

func init() {
	t["FcoeFaultFault"] = reflect.TypeOf((*FcoeFaultFault)(nil)).Elem()
}

// Deprecated as of vSphere API 8.0. Software FCoE not supported.
//
// This fault indicates the given Software Fcoe NIC has no uplink ports
// that is required for initiating a discovery.
type FcoeFaultPnicHasNoPortSet struct {
	FcoeFault

	NicDevice string `xml:"nicDevice" json:"nicDevice"`
}

func init() {
	t["FcoeFaultPnicHasNoPortSet"] = reflect.TypeOf((*FcoeFaultPnicHasNoPortSet)(nil)).Elem()
}

type FcoeFaultPnicHasNoPortSetFault FcoeFaultPnicHasNoPortSet

func init() {
	t["FcoeFaultPnicHasNoPortSetFault"] = reflect.TypeOf((*FcoeFaultPnicHasNoPortSetFault)(nil)).Elem()
}

// The `FeatureEVCMode` data object describes an Enhanced vMotion
// Compatibility mode for VMFeature.
//
// An Feature EVC mode is associated with a set of features. This object
// is modeled after EVCMode, which is more CPU-centric. Members that
// are specific to CPU are removed in favor of VMFeature EVC properties.
// For more information about EVC interaction, see `EVCMode`.
//
// The inherited `ElementDescription.key` property is a string value
// that uniquely identifies an EVC mode. The vCenter Server assigns
// the key value; the vSphere API uses the key to identify modes
// in summary and information objects, for example:
//   - `ClusterComputeResourceSummary*.*ClusterComputeResourceSummary.currentEVCGraphicsModeKey`
//   - `HostListSummary*.*HostListSummary.currentEVCGraphicsModeKey`
//
// The inherited `Description.label` and `Description.summary`
// properties are human-readable strings.
type FeatureEVCMode struct {
	ElementDescription

	// The masks (modifications to a host's feature capabilities) that limit a
	// host's capabilities to that of the EVC mode baseline.
	Mask []HostFeatureMask `xml:"mask,omitempty" json:"mask,omitempty"`
	// Describes the feature capability baseline associated with the EVC mode.
	//
	// On the cluster where a particular EVC mode is configured,
	// these features capabilities are guaranteed, either because the host
	// hardware naturally matches those features or because feature masks
	// are used to mask out differences and enforce a match.
	Capability []HostFeatureCapability `xml:"capability,omitempty" json:"capability,omitempty"`
	// The conditions that must be true of a host's feature capabilities in order
	// for the host to meet the minimum requirements of the EVC mode baseline.
	Requirement []VirtualMachineFeatureRequirement `xml:"requirement,omitempty" json:"requirement,omitempty"`
}

func init() {
	t["FeatureEVCMode"] = reflect.TypeOf((*FeatureEVCMode)(nil)).Elem()
	minAPIVersionForType["FeatureEVCMode"] = "7.0.1.0"
}

// The host does not meet feature requirements of the virtual machine.
type FeatureRequirementsNotMet struct {
	VirtualHardwareCompatibilityIssue

	// The feature requirements that were not met.
	FeatureRequirement []VirtualMachineFeatureRequirement `xml:"featureRequirement,omitempty" json:"featureRequirement,omitempty"`
	// The virtual machine whose feature requirements were not met.
	//
	// Refers instance of `VirtualMachine`.
	Vm *ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
	// The host whose capabilities did not meet the virtual machine's feature requirements.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["FeatureRequirementsNotMet"] = reflect.TypeOf((*FeatureRequirementsNotMet)(nil)).Elem()
}

type FeatureRequirementsNotMetFault FeatureRequirementsNotMet

func init() {
	t["FeatureRequirementsNotMetFault"] = reflect.TypeOf((*FeatureRequirementsNotMetFault)(nil)).Elem()
}

type FetchAuditRecords FetchAuditRecordsRequestType

func init() {
	t["FetchAuditRecords"] = reflect.TypeOf((*FetchAuditRecords)(nil)).Elem()
}

// The parameters of `DiagnosticManager.FetchAuditRecords`.
type FetchAuditRecordsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The token to be used for the operation. The first call must
	// be made without a token. All subsequent calls use the token
	// returned in AuditRecordStatus.
	Token string `xml:"token,omitempty" json:"token,omitempty"`
}

func init() {
	t["FetchAuditRecordsRequestType"] = reflect.TypeOf((*FetchAuditRecordsRequestType)(nil)).Elem()
	minAPIVersionForType["FetchAuditRecordsRequestType"] = "7.0.3.0"
}

type FetchAuditRecordsResponse struct {
	Returnval DiagnosticManagerAuditRecordResult `xml:"returnval" json:"returnval"`
}

type FetchDVPortKeys FetchDVPortKeysRequestType

func init() {
	t["FetchDVPortKeys"] = reflect.TypeOf((*FetchDVPortKeys)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.FetchDVPortKeys`.
type FetchDVPortKeysRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The port selection criteria. If unset, the operation
	// returns the keys of all the ports in the switch.
	Criteria *DistributedVirtualSwitchPortCriteria `xml:"criteria,omitempty" json:"criteria,omitempty"`
}

func init() {
	t["FetchDVPortKeysRequestType"] = reflect.TypeOf((*FetchDVPortKeysRequestType)(nil)).Elem()
}

type FetchDVPortKeysResponse struct {
	Returnval []string `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type FetchDVPorts FetchDVPortsRequestType

func init() {
	t["FetchDVPorts"] = reflect.TypeOf((*FetchDVPorts)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.FetchDVPorts`.
type FetchDVPortsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The port selection criteria. If unset, the operation
	// returns the keys of all the ports in the portgroup.
	Criteria *DistributedVirtualSwitchPortCriteria `xml:"criteria,omitempty" json:"criteria,omitempty"`
}

func init() {
	t["FetchDVPortsRequestType"] = reflect.TypeOf((*FetchDVPortsRequestType)(nil)).Elem()
}

type FetchDVPortsResponse struct {
	Returnval []DistributedVirtualPort `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type FetchSystemEventLog FetchSystemEventLogRequestType

func init() {
	t["FetchSystemEventLog"] = reflect.TypeOf((*FetchSystemEventLog)(nil)).Elem()
}

type FetchSystemEventLogRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["FetchSystemEventLogRequestType"] = reflect.TypeOf((*FetchSystemEventLogRequestType)(nil)).Elem()
}

type FetchSystemEventLogResponse struct {
	Returnval []SystemEventInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type FetchUserPrivilegeOnEntities FetchUserPrivilegeOnEntitiesRequestType

func init() {
	t["FetchUserPrivilegeOnEntities"] = reflect.TypeOf((*FetchUserPrivilegeOnEntities)(nil)).Elem()
}

// The parameters of `AuthorizationManager.FetchUserPrivilegeOnEntities`.
type FetchUserPrivilegeOnEntitiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// are the entities to retrieve privileges on
	//
	// Required privileges: System.View
	//
	// Refers instances of `ManagedEntity`.
	Entities []ManagedObjectReference `xml:"entities" json:"entities"`
	// is the user to retrieve privileges for
	UserName string `xml:"userName" json:"userName"`
}

func init() {
	t["FetchUserPrivilegeOnEntitiesRequestType"] = reflect.TypeOf((*FetchUserPrivilegeOnEntitiesRequestType)(nil)).Elem()
}

type FetchUserPrivilegeOnEntitiesResponse struct {
	Returnval []UserPrivilegeResult `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// This fault is thrown when an operation attempts to create a file using the name of
// an existing file.
type FileAlreadyExists struct {
	FileFault
}

func init() {
	t["FileAlreadyExists"] = reflect.TypeOf((*FileAlreadyExists)(nil)).Elem()
}

type FileAlreadyExistsFault FileAlreadyExists

func init() {
	t["FileAlreadyExistsFault"] = reflect.TypeOf((*FileAlreadyExistsFault)(nil)).Elem()
}

// The virtual machine has a port (either a SerialPort or a ParallelPort) which is
// backed by a file.
//
// This is an error when migrating a virtual machine with the device
// connected, and can be returned as a subfault of DisallowedMigrationDeviceAttached.
type FileBackedPortNotSupported struct {
	DeviceNotSupported
}

func init() {
	t["FileBackedPortNotSupported"] = reflect.TypeOf((*FileBackedPortNotSupported)(nil)).Elem()
}

type FileBackedPortNotSupportedFault FileBackedPortNotSupported

func init() {
	t["FileBackedPortNotSupportedFault"] = reflect.TypeOf((*FileBackedPortNotSupportedFault)(nil)).Elem()
}

// Specification used to create a file based virtual disk
type FileBackedVirtualDiskSpec struct {
	VirtualDiskSpec

	// Specify the capacity of the virtual disk in Kb.
	CapacityKb int64 `xml:"capacityKb" json:"capacityKb"`
	// Virtual Disk Profile requirement.
	//
	// Profiles are solution specifics.
	// Profile Based Storage Management is a vSphere server extension.
	// The API users who want to provision VMs using Storage Profiles, need to
	// interact with it.
	// This is an optional parameter and if user doesn't specify profile,
	// the default behavior will apply.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
	// Encryption options for the new virtual disk.
	Crypto BaseCryptoSpec `xml:"crypto,omitempty,typeattr" json:"crypto,omitempty"`
}

func init() {
	t["FileBackedVirtualDiskSpec"] = reflect.TypeOf((*FileBackedVirtualDiskSpec)(nil)).Elem()
}

// The common base type for all file-related exceptions.
type FileFault struct {
	VimFault

	// The file in question.
	File string `xml:"file" json:"file"`
}

func init() {
	t["FileFault"] = reflect.TypeOf((*FileFault)(nil)).Elem()
}

type FileFaultFault BaseFileFault

func init() {
	t["FileFaultFault"] = reflect.TypeOf((*FileFaultFault)(nil)).Elem()
}

// This data object type contains rudimentary information about a file in a
// datastore.
//
// The information here is not meant to cover all information in
// traditional file systems, but rather to provide sufficient information for files
// that are associated with virtual machines. Derived types describe the known file
// types for a datastore.
type FileInfo struct {
	DynamicData

	// The path relative to the folder path in the search results.
	Path string `xml:"path" json:"path"`
	// User friendly name.
	FriendlyName string `xml:"friendlyName,omitempty" json:"friendlyName,omitempty"`
	// The size of the file in bytes.
	FileSize int64 `xml:"fileSize,omitempty" json:"fileSize,omitempty"`
	// The last date and time the file was modified.
	Modification *time.Time `xml:"modification" json:"modification,omitempty"`
	// The user name of the owner of the file.
	Owner string `xml:"owner,omitempty" json:"owner,omitempty"`
}

func init() {
	t["FileInfo"] = reflect.TypeOf((*FileInfo)(nil)).Elem()
}

// The File information available on a particular file on the host that
// can be fetched.
//
// Attempt is made to query and fetch as much information
// as possible depending on the file system the file is residing on.
type FileLockInfo struct {
	DynamicData

	FilePath  string `xml:"filePath" json:"filePath"`
	Host      string `xml:"host" json:"host"`
	Mac       string `xml:"mac" json:"mac"`
	Id        string `xml:"id" json:"id"`
	WorldName string `xml:"worldName" json:"worldName"`
	OwnerId   string `xml:"ownerId,omitempty" json:"ownerId,omitempty"`
	LockMode  string `xml:"lockMode" json:"lockMode"`
	// Optional future - will be fetched if available.
	Acquired  *time.Time `xml:"acquired" json:"acquired,omitempty"`
	Heartbeat *time.Time `xml:"heartbeat" json:"heartbeat,omitempty"`
	RefCount  int32      `xml:"refCount,omitempty" json:"refCount,omitempty"`
}

func init() {
	t["FileLockInfo"] = reflect.TypeOf((*FileLockInfo)(nil)).Elem()
	minAPIVersionForType["FileLockInfo"] = "8.0.2.0"
}

type FileLockInfoResult struct {
	DynamicData

	// FileLockInfo entries populated based on results fetched from host.
	//
	// If a single path is provided result should contain a single entry.
	// For a generic VM name potentially multiple entries could be fetched
	// and populated. Refer to `FileManager.QueryFileLockInfo` for
	// more details.
	LockInfo []FileLockInfo        `xml:"lockInfo,omitempty" json:"lockInfo,omitempty"`
	Fault    *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["FileLockInfoResult"] = reflect.TypeOf((*FileLockInfoResult)(nil)).Elem()
	minAPIVersionForType["FileLockInfoResult"] = "8.0.2.0"
}

// Thrown if an attempt is made to lock a file that is already in use.
type FileLocked struct {
	FileFault
}

func init() {
	t["FileLocked"] = reflect.TypeOf((*FileLocked)(nil)).Elem()
}

type FileLockedFault FileLocked

func init() {
	t["FileLockedFault"] = reflect.TypeOf((*FileLockedFault)(nil)).Elem()
}

// This fault is thrown when an operation fails because the name of the
// specified file is too long.
type FileNameTooLong struct {
	FileFault
}

func init() {
	t["FileNameTooLong"] = reflect.TypeOf((*FileNameTooLong)(nil)).Elem()
}

type FileNameTooLongFault FileNameTooLong

func init() {
	t["FileNameTooLongFault"] = reflect.TypeOf((*FileNameTooLongFault)(nil)).Elem()
}

// This fault is thrown when an operation fails because the specified file
// does not exist.
type FileNotFound struct {
	FileFault
}

func init() {
	t["FileNotFound"] = reflect.TypeOf((*FileNotFound)(nil)).Elem()
}

type FileNotFoundFault FileNotFound

func init() {
	t["FileNotFoundFault"] = reflect.TypeOf((*FileNotFoundFault)(nil)).Elem()
}

// Thrown if an attempt is made to write to a read-only file.
type FileNotWritable struct {
	FileFault
}

func init() {
	t["FileNotWritable"] = reflect.TypeOf((*FileNotWritable)(nil)).Elem()
}

type FileNotWritableFault FileNotWritable

func init() {
	t["FileNotWritableFault"] = reflect.TypeOf((*FileNotWritableFault)(nil)).Elem()
}

// The data object type that describes the base query specification.
//
// Contains query
// filters and details that apply to every file. Querying only file details generally
// does not require opening files and so is an efficient query. Derived types add
// query parameters specific to the type of file.
type FileQuery struct {
	DynamicData
}

func init() {
	t["FileQuery"] = reflect.TypeOf((*FileQuery)(nil)).Elem()
}

// The FileInfo.Details data object type is a set of flags for a search request.
//
// This search request specifies which details to return for each matching file.
// This data object type is here to ensure that there is one flag corresponding to
// each FileInfo property other than the path name, which a search always returns.
type FileQueryFlags struct {
	DynamicData

	// The flag to indicate whether or not the files that match this query
	// specification are returned along with file type information.
	//
	// This field must
	// be set to return specific details about the file type.
	FileType bool `xml:"fileType" json:"fileType"`
	// The flag to indicate whether or not the size of the file is returned.
	FileSize bool `xml:"fileSize" json:"fileSize"`
	// The flag to indicate whether or not to return the date and time the file was
	// last modified.
	Modification bool `xml:"modification" json:"modification"`
	// The flag to indicate whether or not to return the file owner.
	FileOwner *bool `xml:"fileOwner" json:"fileOwner,omitempty"`
}

func init() {
	t["FileQueryFlags"] = reflect.TypeOf((*FileQueryFlags)(nil)).Elem()
}

// This fault is thrown when an operation fails because the file is larger
// than the maximum file size supported by the datastore.
type FileTooLarge struct {
	FileFault

	// The name of the datastore that does not support the file's size.
	Datastore string `xml:"datastore" json:"datastore"`
	// The size (in bytes) of the file.
	FileSize int64 `xml:"fileSize" json:"fileSize"`
	// The max file size (in bytes) supported on the datastore.
	MaxFileSize int64 `xml:"maxFileSize,omitempty" json:"maxFileSize,omitempty"`
}

func init() {
	t["FileTooLarge"] = reflect.TypeOf((*FileTooLarge)(nil)).Elem()
}

type FileTooLargeFault FileTooLarge

func init() {
	t["FileTooLargeFault"] = reflect.TypeOf((*FileTooLargeFault)(nil)).Elem()
}

// Represents the information about a
// `GuestFileManager.InitiateFileTransferFromGuest` operation
// of `GuestFileManager` object.
//
// The user can use the URL provided in url property to transfer
// the file from the guest. The user should send a HTTP GET request to the
// URL. Entire file content will be returned in the body of the response
// message.
type FileTransferInformation struct {
	DynamicData

	// File attributes of the file that is being transferred from the guest.
	Attributes BaseGuestFileAttributes `xml:"attributes,typeattr" json:"attributes"`
	// Total size of the file in bytes.
	Size int64 `xml:"size" json:"size"`
	// Specifies the URL to which the user has to send HTTP GET request.
	//
	// Multiple GET requests cannot be sent to the URL simultaneously. URL
	// will become invalid once a successful GET request is sent.
	//
	// The host part of the URL is returned as '\*' if the hostname to be used
	// is the name of the server to which the call was made. For example, if
	// the call is made to esx-svr-1.domain1.com, and the file is available for
	// download from
	// `https://esx-svr-1.domain1.com/guestFile?id=1&token=1234`,
	// the URL returned may be
	// `https://&#42;/guestFile?id=1&token=1234`.
	// The client replaces the asterisk with the server name on which it
	// invoked the call.
	//
	// The URL is valid only for 10 minutes from the time it is generated.
	// Also, the URL becomes invalid whenever the virtual machine is powered
	// off, suspended or unregistered.
	Url string `xml:"url" json:"url"`
}

func init() {
	t["FileTransferInformation"] = reflect.TypeOf((*FileTransferInformation)(nil)).Elem()
}

// This fault is thrown when creating a quiesced snapshot failed
// because the create snapshot operation exceeded the time limit
// for holding off I/O in the frozen VM.
//
// This indicates that when we attempted to thaw the VM after
// creating the snapshot, we got an error back indicating that
// the VM was not frozen anymore. In this case, we roll back
// the entire snapshot create operation and throw this exception.
type FilesystemQuiesceFault struct {
	SnapshotFault
}

func init() {
	t["FilesystemQuiesceFault"] = reflect.TypeOf((*FilesystemQuiesceFault)(nil)).Elem()
}

type FilesystemQuiesceFaultFault FilesystemQuiesceFault

func init() {
	t["FilesystemQuiesceFaultFault"] = reflect.TypeOf((*FilesystemQuiesceFaultFault)(nil)).Elem()
}

// A FilterInUse fault indicates that some error has occurred because an
// IO filter was in use.
type FilterInUse struct {
	ResourceInUse

	// Virtual disks that use the filter.
	Disk []VirtualDiskId `xml:"disk,omitempty" json:"disk,omitempty"`
}

func init() {
	t["FilterInUse"] = reflect.TypeOf((*FilterInUse)(nil)).Elem()
}

type FilterInUseFault FilterInUse

func init() {
	t["FilterInUseFault"] = reflect.TypeOf((*FilterInUseFault)(nil)).Elem()
}

type FindAllByDnsName FindAllByDnsNameRequestType

func init() {
	t["FindAllByDnsName"] = reflect.TypeOf((*FindAllByDnsName)(nil)).Elem()
}

// The parameters of `SearchIndex.FindAllByDnsName`.
type FindAllByDnsNameRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If specified, restricts the query to entities in
	// a particular datacenter. If not specified, the entire inventory is
	// searched.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// The fully qualified domain name to find.
	DnsName string `xml:"dnsName" json:"dnsName"`
	// If true, search for virtual machines, otherwise search for
	// hosts.
	VmSearch bool `xml:"vmSearch" json:"vmSearch"`
}

func init() {
	t["FindAllByDnsNameRequestType"] = reflect.TypeOf((*FindAllByDnsNameRequestType)(nil)).Elem()
}

type FindAllByDnsNameResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type FindAllByIp FindAllByIpRequestType

func init() {
	t["FindAllByIp"] = reflect.TypeOf((*FindAllByIp)(nil)).Elem()
}

// The parameters of `SearchIndex.FindAllByIp`.
type FindAllByIpRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If specified, restricts the query to entities in
	// a particular datacenter. If not specified, the entire inventory is
	// searched.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// The dot-decimal notation formatted IP address to find.
	Ip string `xml:"ip" json:"ip"`
	// If true, search for virtual machines, otherwise search for
	// hosts.
	VmSearch bool `xml:"vmSearch" json:"vmSearch"`
}

func init() {
	t["FindAllByIpRequestType"] = reflect.TypeOf((*FindAllByIpRequestType)(nil)).Elem()
}

type FindAllByIpResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type FindAllByUuid FindAllByUuidRequestType

func init() {
	t["FindAllByUuid"] = reflect.TypeOf((*FindAllByUuid)(nil)).Elem()
}

// The parameters of `SearchIndex.FindAllByUuid`.
type FindAllByUuidRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If specified, restricts the query to entities in
	// a particular datacenter. If not specified, the entire inventory is
	// searched.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// The UUID to find. If vmSearch is true, the UUID can be either BIOS
	// or instance UUID.
	Uuid string `xml:"uuid" json:"uuid"`
	// If true, search for virtual machines, otherwise search for
	// hosts.
	VmSearch bool `xml:"vmSearch" json:"vmSearch"`
	// Should only be set when vmSearch is true. If specified, search
	// for virtual machines whose instance UUID matches the given uuid.
	// Otherwise, search for virtual machines whose BIOS UUID matches the given
	// uuid.
	InstanceUuid *bool `xml:"instanceUuid" json:"instanceUuid,omitempty"`
}

func init() {
	t["FindAllByUuidRequestType"] = reflect.TypeOf((*FindAllByUuidRequestType)(nil)).Elem()
}

type FindAllByUuidResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type FindAssociatedProfile FindAssociatedProfileRequestType

func init() {
	t["FindAssociatedProfile"] = reflect.TypeOf((*FindAssociatedProfile)(nil)).Elem()
}

// The parameters of `ProfileManager.FindAssociatedProfile`.
type FindAssociatedProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Entity for which profile is being looked up.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["FindAssociatedProfileRequestType"] = reflect.TypeOf((*FindAssociatedProfileRequestType)(nil)).Elem()
}

type FindAssociatedProfileResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type FindByDatastorePath FindByDatastorePathRequestType

func init() {
	t["FindByDatastorePath"] = reflect.TypeOf((*FindByDatastorePath)(nil)).Elem()
}

// The parameters of `SearchIndex.FindByDatastorePath`.
type FindByDatastorePathRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specifies the datacenter to which the datastore path belongs.
	//
	// Refers instance of `Datacenter`.
	Datacenter ManagedObjectReference `xml:"datacenter" json:"datacenter"`
	// A datastore path to the .vmx file for the virtual machine.
	Path string `xml:"path" json:"path"`
}

func init() {
	t["FindByDatastorePathRequestType"] = reflect.TypeOf((*FindByDatastorePathRequestType)(nil)).Elem()
}

type FindByDatastorePathResponse struct {
	Returnval *ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type FindByDnsName FindByDnsNameRequestType

func init() {
	t["FindByDnsName"] = reflect.TypeOf((*FindByDnsName)(nil)).Elem()
}

// The parameters of `SearchIndex.FindByDnsName`.
type FindByDnsNameRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If specified, restricts the query to entities in
	// a particular datacenter. If not specified, the entire inventory is
	// searched.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// The fully qualified domain name to find.
	DnsName string `xml:"dnsName" json:"dnsName"`
	// if true, search for virtual machines, otherwise search for
	// hosts.
	VmSearch bool `xml:"vmSearch" json:"vmSearch"`
}

func init() {
	t["FindByDnsNameRequestType"] = reflect.TypeOf((*FindByDnsNameRequestType)(nil)).Elem()
}

type FindByDnsNameResponse struct {
	Returnval *ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type FindByInventoryPath FindByInventoryPathRequestType

func init() {
	t["FindByInventoryPath"] = reflect.TypeOf((*FindByInventoryPath)(nil)).Elem()
}

// The parameters of `SearchIndex.FindByInventoryPath`.
type FindByInventoryPathRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The path to the entity.
	InventoryPath string `xml:"inventoryPath" json:"inventoryPath"`
}

func init() {
	t["FindByInventoryPathRequestType"] = reflect.TypeOf((*FindByInventoryPathRequestType)(nil)).Elem()
}

type FindByInventoryPathResponse struct {
	Returnval *ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type FindByIp FindByIpRequestType

func init() {
	t["FindByIp"] = reflect.TypeOf((*FindByIp)(nil)).Elem()
}

// The parameters of `SearchIndex.FindByIp`.
type FindByIpRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If specified, restricts the query to entities in
	// a particular datacenter. If not specified, the entire inventory is
	// searched.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// The dot-decimal notation formatted IP address to find.
	Ip string `xml:"ip" json:"ip"`
	// if true, search for virtual machines, otherwise search for
	// hosts.
	VmSearch bool `xml:"vmSearch" json:"vmSearch"`
}

func init() {
	t["FindByIpRequestType"] = reflect.TypeOf((*FindByIpRequestType)(nil)).Elem()
}

type FindByIpResponse struct {
	Returnval *ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type FindByUuid FindByUuidRequestType

func init() {
	t["FindByUuid"] = reflect.TypeOf((*FindByUuid)(nil)).Elem()
}

// The parameters of `SearchIndex.FindByUuid`.
type FindByUuidRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If specified, restricts the query to entities in
	// a particular datacenter. If not specified, the entire inventory is
	// searched.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// The UUID to find. If vmSearch is true, the uuid can be either BIOS
	// or instance UUID.
	Uuid string `xml:"uuid" json:"uuid"`
	// If true, search for virtual machines, otherwise search for
	// hosts.
	VmSearch bool `xml:"vmSearch" json:"vmSearch"`
	// Should only be set when vmSearch is true. If specified, search
	// for virtual machines whose instance UUID matches the given uuid.
	// Otherwise, search for virtual machines whose BIOS UUID matches the given
	// uuid.
	InstanceUuid *bool `xml:"instanceUuid" json:"instanceUuid,omitempty"`
}

func init() {
	t["FindByUuidRequestType"] = reflect.TypeOf((*FindByUuidRequestType)(nil)).Elem()
}

type FindByUuidResponse struct {
	Returnval *ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type FindChild FindChildRequestType

func init() {
	t["FindChild"] = reflect.TypeOf((*FindChild)(nil)).Elem()
}

// The parameters of `SearchIndex.FindChild`.
type FindChildRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A reference to a managed entity.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// The name of the child object.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["FindChildRequestType"] = reflect.TypeOf((*FindChildRequestType)(nil)).Elem()
}

type FindChildResponse struct {
	Returnval *ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type FindExtension FindExtensionRequestType

func init() {
	t["FindExtension"] = reflect.TypeOf((*FindExtension)(nil)).Elem()
}

// The parameters of `ExtensionManager.FindExtension`.
type FindExtensionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Key to search for.
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
}

func init() {
	t["FindExtensionRequestType"] = reflect.TypeOf((*FindExtensionRequestType)(nil)).Elem()
}

type FindExtensionResponse struct {
	Returnval *Extension `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type FindRulesForVm FindRulesForVmRequestType

func init() {
	t["FindRulesForVm"] = reflect.TypeOf((*FindRulesForVm)(nil)).Elem()
}

// The parameters of `ClusterComputeResource.FindRulesForVm`.
type FindRulesForVmRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The vm whose rules need to be looked up.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
}

func init() {
	t["FindRulesForVmRequestType"] = reflect.TypeOf((*FindRulesForVmRequestType)(nil)).Elem()
}

type FindRulesForVmResponse struct {
	Returnval []BaseClusterRuleInfo `xml:"returnval,omitempty,typeattr" json:"returnval,omitempty"`
}

// The `FirewallProfile` data object represents a host firewall configuration.
//
// If a profile plug-in defines policies or subprofiles, use the
// `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the additional configuration data.
type FirewallProfile struct {
	ApplyProfile

	// List of Rulesets that will be configured for the firewall subprofile.
	//
	// The rulesets can be enabled or disabled from the profile.
	Ruleset []FirewallProfileRulesetProfile `xml:"ruleset,omitempty" json:"ruleset,omitempty"`
}

func init() {
	t["FirewallProfile"] = reflect.TypeOf((*FirewallProfile)(nil)).Elem()
}

type FirewallProfileRulesetProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["FirewallProfileRulesetProfile"] = reflect.TypeOf((*FirewallProfileRulesetProfile)(nil)).Elem()
}

// The FloatOption data object type defines the minimum, maximum,
// and default values for a float option.
type FloatOption struct {
	OptionType

	// The minimum value.
	Min float32 `xml:"min" json:"min"`
	// The maximum value.
	Max float32 `xml:"max" json:"max"`
	// The default value.
	DefaultValue float32 `xml:"defaultValue" json:"defaultValue"`
}

func init() {
	t["FloatOption"] = reflect.TypeOf((*FloatOption)(nil)).Elem()
}

// This data object type describes a file that is a floppy disk image.
type FloppyImageFileInfo struct {
	FileInfo
}

func init() {
	t["FloppyImageFileInfo"] = reflect.TypeOf((*FloppyImageFileInfo)(nil)).Elem()
}

// This data object type describes the query specification for a floppy disk image.
type FloppyImageFileQuery struct {
	FileQuery
}

func init() {
	t["FloppyImageFileQuery"] = reflect.TypeOf((*FloppyImageFileQuery)(nil)).Elem()
}

type FolderBatchAddHostsToClusterResult struct {
	DynamicData

	// List of hosts that were successfully added to the cluster
	// in the desired state.
	//
	// Refers instances of `HostSystem`.
	HostsAddedToCluster []ManagedObjectReference `xml:"hostsAddedToCluster,omitempty" json:"hostsAddedToCluster,omitempty"`
	// Contains a fault for each host that failed addition to the inventory.
	//
	// A failed host will not be part of hostsAddedToCluster list.
	HostsFailedInventoryAdd []FolderFailedHostResult `xml:"hostsFailedInventoryAdd,omitempty" json:"hostsFailedInventoryAdd,omitempty"`
	// List of hosts that are part of inventory but failed to move to the
	// cluster in the desired state.
	//
	// A failed host will not be part of hostsAddedToCluster list however,
	// a failed host will be part of inventory as it might have been added
	// as a standalone host but failed to move to cluster in the desired
	// state.
	HostsFailedMoveToCluster []FolderFailedHostResult `xml:"hostsFailedMoveToCluster,omitempty" json:"hostsFailedMoveToCluster,omitempty"`
}

func init() {
	t["FolderBatchAddHostsToClusterResult"] = reflect.TypeOf((*FolderBatchAddHostsToClusterResult)(nil)).Elem()
}

type FolderBatchAddStandaloneHostsResult struct {
	DynamicData

	// List of hosts that were successfully added as standalone hosts
	// to the inventory.
	//
	// Refers instances of `HostSystem`.
	AddedHosts []ManagedObjectReference `xml:"addedHosts,omitempty" json:"addedHosts,omitempty"`
	// Contains a fault for each host that failed to add.
	//
	// A failed host
	// will not be part of addedHosts list.
	HostsFailedInventoryAdd []FolderFailedHostResult `xml:"hostsFailedInventoryAdd,omitempty" json:"hostsFailedInventoryAdd,omitempty"`
}

func init() {
	t["FolderBatchAddStandaloneHostsResult"] = reflect.TypeOf((*FolderBatchAddStandaloneHostsResult)(nil)).Elem()
}

// The event argument is a Folder object.
type FolderEventArgument struct {
	EntityEventArgument

	// The Folder object.
	//
	// Refers instance of `Folder`.
	Folder ManagedObjectReference `xml:"folder" json:"folder"`
}

func init() {
	t["FolderEventArgument"] = reflect.TypeOf((*FolderEventArgument)(nil)).Elem()
}

type FolderFailedHostResult struct {
	DynamicData

	// Host name for which fault belongs to.
	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
	// Host for which fault belongs to.
	//
	// Only set when the HostSystem
	// reference is avaibale as a result of Host being part of inventory.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// Message describing context where the failure happened.
	Context LocalizableMessage `xml:"context" json:"context"`
	// Exception encountered while operating on this host.
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["FolderFailedHostResult"] = reflect.TypeOf((*FolderFailedHostResult)(nil)).Elem()
}

// This data object type describes a file that is a folder (directory).
type FolderFileInfo struct {
	FileInfo
}

func init() {
	t["FolderFileInfo"] = reflect.TypeOf((*FolderFileInfo)(nil)).Elem()
}

// This data object type describes the query specification for a folder (directory).
type FolderFileQuery struct {
	FileQuery
}

func init() {
	t["FolderFileQuery"] = reflect.TypeOf((*FolderFileQuery)(nil)).Elem()
}

type FolderNewHostSpec struct {
	DynamicData

	// Connection Spec for new host that needs to be added to the inventory.
	HostCnxSpec HostConnectSpec `xml:"hostCnxSpec" json:"hostCnxSpec"`
	// LicenseKey.
	//
	// See `LicenseManager`. If supplied, new
	// host will be updated with the license.
	EsxLicense string `xml:"esxLicense,omitempty" json:"esxLicense,omitempty"`
}

func init() {
	t["FolderNewHostSpec"] = reflect.TypeOf((*FolderNewHostSpec)(nil)).Elem()
}

type FormatVffs FormatVffsRequestType

func init() {
	t["FormatVffs"] = reflect.TypeOf((*FormatVffs)(nil)).Elem()
}

// The parameters of `HostStorageSystem.FormatVffs`.
type FormatVffsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A data object that describes the VFFS volume
	// creation specification.
	CreateSpec HostVffsSpec `xml:"createSpec" json:"createSpec"`
}

func init() {
	t["FormatVffsRequestType"] = reflect.TypeOf((*FormatVffsRequestType)(nil)).Elem()
}

type FormatVffsResponse struct {
	Returnval HostVffsVolume `xml:"returnval" json:"returnval"`
}

type FormatVmfs FormatVmfsRequestType

func init() {
	t["FormatVmfs"] = reflect.TypeOf((*FormatVmfs)(nil)).Elem()
}

// The parameters of `HostStorageSystem.FormatVmfs`.
type FormatVmfsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A data object that describes the VMware File System
	// (VMFS) creation specification.
	CreateSpec HostVmfsSpec `xml:"createSpec" json:"createSpec"`
}

func init() {
	t["FormatVmfsRequestType"] = reflect.TypeOf((*FormatVmfsRequestType)(nil)).Elem()
}

type FormatVmfsResponse struct {
	Returnval HostVmfsVolume `xml:"returnval" json:"returnval"`
}

// The FtIssuesOnHost fault reports issues that prevent a particular
// host from being used as the register or power on host for a Fault
// Tolerance secondary virtual machine
type FtIssuesOnHost struct {
	VmFaultToleranceIssue

	// The host which has Fault Tolerance issues.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Name for the host which has Fault Tolerance issues.
	HostName string `xml:"hostName" json:"hostName"`
	// Information on the details of the Fault Tolerance issues
	Errors []LocalizedMethodFault `xml:"errors,omitempty" json:"errors,omitempty"`
}

func init() {
	t["FtIssuesOnHost"] = reflect.TypeOf((*FtIssuesOnHost)(nil)).Elem()
}

type FtIssuesOnHostFault FtIssuesOnHost

func init() {
	t["FtIssuesOnHostFault"] = reflect.TypeOf((*FtIssuesOnHostFault)(nil)).Elem()
}

// The virtual machine if powered on or VMotioned, would violate an
// FT VM-Host rule.
type FtVmHostRuleViolation struct {
	VmConfigFault

	// The vm that can not be powered on or VMotioned without violating FT Metro
	// Cluster placement rule.
	VmName string `xml:"vmName" json:"vmName"`
	// The host that the virtual machine can not be powered on without violating
	// FT Metro Cluster placement rule.
	HostName string `xml:"hostName" json:"hostName"`
	// Indicate the Host Group for FT Metro Cluster enabled Virtual Machine.
	HostGroup string `xml:"hostGroup" json:"hostGroup"`
}

func init() {
	t["FtVmHostRuleViolation"] = reflect.TypeOf((*FtVmHostRuleViolation)(nil)).Elem()
	minAPIVersionForType["FtVmHostRuleViolation"] = "8.0.3.0"
}

type FtVmHostRuleViolationFault FtVmHostRuleViolation

func init() {
	t["FtVmHostRuleViolationFault"] = reflect.TypeOf((*FtVmHostRuleViolationFault)(nil)).Elem()
}

// An operation on a powered-on virtual machine requests a simultaneous change
// of storage location and execution host, but the host does not have that
// capability.
type FullStorageVMotionNotSupported struct {
	MigrationFeatureNotSupported
}

func init() {
	t["FullStorageVMotionNotSupported"] = reflect.TypeOf((*FullStorageVMotionNotSupported)(nil)).Elem()
}

type FullStorageVMotionNotSupportedFault FullStorageVMotionNotSupported

func init() {
	t["FullStorageVMotionNotSupportedFault"] = reflect.TypeOf((*FullStorageVMotionNotSupportedFault)(nil)).Elem()
}

// Deprecated not used since vSphere 6.5.
//
// GatewayConnectFault is a base fault type for the faults thrown by a gateway
// server used to connect to a host.
type GatewayConnectFault struct {
	HostConnectFault

	// The type of the gateway used for the connection to the host.
	GatewayType string `xml:"gatewayType" json:"gatewayType"`
	// Identifier of the gateway that is used for the connection to the host.
	GatewayId string `xml:"gatewayId" json:"gatewayId"`
	// Human-readable information about the host gateway server.
	GatewayInfo string `xml:"gatewayInfo" json:"gatewayInfo"`
	// Details of the cause for this fault.
	//
	// This is the way in which Host
	// Gateway servers propagate opaque error messages through vCenter Server.
	Details *LocalizableMessage `xml:"details,omitempty" json:"details,omitempty"`
}

func init() {
	t["GatewayConnectFault"] = reflect.TypeOf((*GatewayConnectFault)(nil)).Elem()
}

type GatewayConnectFaultFault BaseGatewayConnectFault

func init() {
	t["GatewayConnectFaultFault"] = reflect.TypeOf((*GatewayConnectFaultFault)(nil)).Elem()
}

// Deprecated not used since vSphere 6.5.
//
// GatewayHostNotReachable is thrown by the gateway used to connect to a host,
// if an error occurs while establishing a connection to that host.
//
// The fault may provide a more detailed message of what caused the problem.
type GatewayHostNotReachable struct {
	GatewayToHostConnectFault
}

func init() {
	t["GatewayHostNotReachable"] = reflect.TypeOf((*GatewayHostNotReachable)(nil)).Elem()
}

type GatewayHostNotReachableFault GatewayHostNotReachable

func init() {
	t["GatewayHostNotReachableFault"] = reflect.TypeOf((*GatewayHostNotReachableFault)(nil)).Elem()
}

// Deprecated not used since vSphere 6.5.
//
// GatewayNotFound is thrown by vCenter Server, if no host gateway with the
// specified type/id and available resources is known to the vCenter Server.
type GatewayNotFound struct {
	GatewayConnectFault
}

func init() {
	t["GatewayNotFound"] = reflect.TypeOf((*GatewayNotFound)(nil)).Elem()
}

type GatewayNotFoundFault GatewayNotFound

func init() {
	t["GatewayNotFoundFault"] = reflect.TypeOf((*GatewayNotFoundFault)(nil)).Elem()
}

// Deprecated not used since vSphere 6.5.
//
// GatewayNotReachable is thrown by vCenter Server when it fails to establish
// a connection to the host gateway server.
//
// This fault may occur due to
// network connectivity problems or inability to establish secure connection
// between the gateway server and vCenter Server.
type GatewayNotReachable struct {
	GatewayConnectFault
}

func init() {
	t["GatewayNotReachable"] = reflect.TypeOf((*GatewayNotReachable)(nil)).Elem()
}

type GatewayNotReachableFault GatewayNotReachable

func init() {
	t["GatewayNotReachableFault"] = reflect.TypeOf((*GatewayNotReachableFault)(nil)).Elem()
}

// Deprecated not used sine vSphere 6.5.
//
// GatewayOperationRefused is thrown by vCenter Server when a gateway server denies to
// accept more connection due to resource limitation.
//
// The fault may occur due
// to specific configuration of the Gateway server to work with limited
// resources or due to physical limitation to handle more host connections.
type GatewayOperationRefused struct {
	GatewayConnectFault
}

func init() {
	t["GatewayOperationRefused"] = reflect.TypeOf((*GatewayOperationRefused)(nil)).Elem()
}

type GatewayOperationRefusedFault GatewayOperationRefused

func init() {
	t["GatewayOperationRefusedFault"] = reflect.TypeOf((*GatewayOperationRefusedFault)(nil)).Elem()
}

// Deprecated not used since vSphere 6.5.
//
// GatewayToHostAuthFault is thrown by the gateway used to communicate with a
// host, if the gateway cannot authenticate to the host with the provided
// authentication data.
//
// The fault provides information, which of the properties given in the
// authentication data are invalid or if more properties are required.
//
// See also `HostGatewaySpec.hostAuthParams`.
type GatewayToHostAuthFault struct {
	GatewayToHostConnectFault

	// List of properties that have been provided in the authentication data
	// but have wrong values.
	InvalidProperties []string `xml:"invalidProperties" json:"invalidProperties"`
	// List of properties that do not have their values specified in the
	// provided authentication data but are required.
	MissingProperties []string `xml:"missingProperties" json:"missingProperties"`
}

func init() {
	t["GatewayToHostAuthFault"] = reflect.TypeOf((*GatewayToHostAuthFault)(nil)).Elem()
}

type GatewayToHostAuthFaultFault GatewayToHostAuthFault

func init() {
	t["GatewayToHostAuthFaultFault"] = reflect.TypeOf((*GatewayToHostAuthFaultFault)(nil)).Elem()
}

// Deprecated not used since vSphere 6.5.
//
// GatewayToHostConnectFault is thrown by the gateway used to communicate
// with a host, if an error occurs in the communication between the gateway and
// the host.
//
// More details may be provided by a subfault.
type GatewayToHostConnectFault struct {
	GatewayConnectFault

	// Hostname of the host that the gateway is communicating with.
	Hostname string `xml:"hostname" json:"hostname"`
	// Port specified for the connection between the gateway and the host.
	Port int32 `xml:"port,omitempty" json:"port,omitempty"`
}

func init() {
	t["GatewayToHostConnectFault"] = reflect.TypeOf((*GatewayToHostConnectFault)(nil)).Elem()
}

type GatewayToHostConnectFaultFault BaseGatewayToHostConnectFault

func init() {
	t["GatewayToHostConnectFaultFault"] = reflect.TypeOf((*GatewayToHostConnectFaultFault)(nil)).Elem()
}

// Deprecated not used since vSphere 6.5.
//
// GatewayToHostTrustVerifyFault is thrown by the gateway used to communicate
// with a host, if it cannot establish a trusted connection to the host with
// the provided host verification token parameter.
//
// The fault provides a list of opaque &lt;key,value&gt; properties, which the end
// user has to verify in order to trust the host and a verification token,
// which can be used to state that those exact properties are valid.
//
// See also `HostGatewaySpec.trustVerificationToken`.
type GatewayToHostTrustVerifyFault struct {
	GatewayToHostConnectFault

	// A unique verification token, that can be used to state the the listed
	// properties are valid.
	VerificationToken string `xml:"verificationToken" json:"verificationToken"`
	// A key/value list of properties that need user verification in order
	// for the gateway to trust the host to succeed.
	//
	// For instance the user may
	// need to verify an SSL thumbprint or a whole certificate.
	PropertiesToVerify []KeyValue `xml:"propertiesToVerify" json:"propertiesToVerify"`
}

func init() {
	t["GatewayToHostTrustVerifyFault"] = reflect.TypeOf((*GatewayToHostTrustVerifyFault)(nil)).Elem()
}

type GatewayToHostTrustVerifyFaultFault GatewayToHostTrustVerifyFault

func init() {
	t["GatewayToHostTrustVerifyFaultFault"] = reflect.TypeOf((*GatewayToHostTrustVerifyFaultFault)(nil)).Elem()
}

// These are general events.
type GeneralEvent struct {
	Event

	// A short form of the message string, not localized.
	Message string `xml:"message" json:"message"`
}

func init() {
	t["GeneralEvent"] = reflect.TypeOf((*GeneralEvent)(nil)).Elem()
}

// This event is the general error event for a host.
type GeneralHostErrorEvent struct {
	GeneralEvent
}

func init() {
	t["GeneralHostErrorEvent"] = reflect.TypeOf((*GeneralHostErrorEvent)(nil)).Elem()
}

// This event is the general information event for a host.
type GeneralHostInfoEvent struct {
	GeneralEvent
}

func init() {
	t["GeneralHostInfoEvent"] = reflect.TypeOf((*GeneralHostInfoEvent)(nil)).Elem()
}

// This event is the general warning event for a host.
type GeneralHostWarningEvent struct {
	GeneralEvent
}

func init() {
	t["GeneralHostWarningEvent"] = reflect.TypeOf((*GeneralHostWarningEvent)(nil)).Elem()
}

// This event is the general user event type.
type GeneralUserEvent struct {
	GeneralEvent

	// The entity on which the event was logged.
	Entity *ManagedEntityEventArgument `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["GeneralUserEvent"] = reflect.TypeOf((*GeneralUserEvent)(nil)).Elem()
}

// This event is the general error event for a virtual machine.
type GeneralVmErrorEvent struct {
	GeneralEvent
}

func init() {
	t["GeneralVmErrorEvent"] = reflect.TypeOf((*GeneralVmErrorEvent)(nil)).Elem()
}

// This event is the general information event for a virtual machine.
type GeneralVmInfoEvent struct {
	GeneralEvent
}

func init() {
	t["GeneralVmInfoEvent"] = reflect.TypeOf((*GeneralVmInfoEvent)(nil)).Elem()
}

// This event is the general warning event for a virtual machine.
type GeneralVmWarningEvent struct {
	GeneralEvent
}

func init() {
	t["GeneralVmWarningEvent"] = reflect.TypeOf((*GeneralVmWarningEvent)(nil)).Elem()
}

type GenerateCertificateSigningRequest GenerateCertificateSigningRequestRequestType

func init() {
	t["GenerateCertificateSigningRequest"] = reflect.TypeOf((*GenerateCertificateSigningRequest)(nil)).Elem()
}

type GenerateCertificateSigningRequestByDn GenerateCertificateSigningRequestByDnRequestType

func init() {
	t["GenerateCertificateSigningRequestByDn"] = reflect.TypeOf((*GenerateCertificateSigningRequestByDn)(nil)).Elem()
}

// The parameters of `HostCertificateManager.GenerateCertificateSigningRequestByDn`.
type GenerateCertificateSigningRequestByDnRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// DN to be used as subject in CSR.
	DistinguishedName string `xml:"distinguishedName" json:"distinguishedName"`
	// is used to generate CSR for selected certificate kind
	Spec *HostCertificateManagerCertificateSpec `xml:"spec,omitempty" json:"spec,omitempty" vim:"8.0.1.0"`
}

func init() {
	t["GenerateCertificateSigningRequestByDnRequestType"] = reflect.TypeOf((*GenerateCertificateSigningRequestByDnRequestType)(nil)).Elem()
}

type GenerateCertificateSigningRequestByDnResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// The parameters of `HostCertificateManager.GenerateCertificateSigningRequest`.
type GenerateCertificateSigningRequestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// if true, use host's
	// management IP address as CN in the CSR;
	// otherwise use host's FQDN.
	UseIpAddressAsCommonName bool `xml:"useIpAddressAsCommonName" json:"useIpAddressAsCommonName"`
	// is used to generate CSR for selected
	// certificate kind.
	Spec *HostCertificateManagerCertificateSpec `xml:"spec,omitempty" json:"spec,omitempty" vim:"8.0.1.0"`
}

func init() {
	t["GenerateCertificateSigningRequestRequestType"] = reflect.TypeOf((*GenerateCertificateSigningRequestRequestType)(nil)).Elem()
}

type GenerateCertificateSigningRequestResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type GenerateClientCsr GenerateClientCsrRequestType

func init() {
	t["GenerateClientCsr"] = reflect.TypeOf((*GenerateClientCsr)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.GenerateClientCsr`.
type GenerateClientCsrRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP cluster.
	Cluster KeyProviderId `xml:"cluster" json:"cluster"`
	// \[in\] Certificate sign request.
	Request *CryptoManagerKmipCertSignRequest `xml:"request,omitempty" json:"request,omitempty" vim:"8.0.1.0"`
}

func init() {
	t["GenerateClientCsrRequestType"] = reflect.TypeOf((*GenerateClientCsrRequestType)(nil)).Elem()
}

type GenerateClientCsrResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type GenerateConfigTaskList GenerateConfigTaskListRequestType

func init() {
	t["GenerateConfigTaskList"] = reflect.TypeOf((*GenerateConfigTaskList)(nil)).Elem()
}

// The parameters of `HostProfileManager.GenerateConfigTaskList`.
type GenerateConfigTaskListRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// ConfigSpec which was proposed by
	// `HostProfile.ExecuteHostProfile` method.
	ConfigSpec HostConfigSpec `xml:"configSpec" json:"configSpec"`
	// Host on which the HostProfile application needs to be
	// carried out.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["GenerateConfigTaskListRequestType"] = reflect.TypeOf((*GenerateConfigTaskListRequestType)(nil)).Elem()
}

type GenerateConfigTaskListResponse struct {
	Returnval HostProfileManagerConfigTaskList `xml:"returnval" json:"returnval"`
}

// The parameters of `HostProfileManager.GenerateHostConfigTaskSpec_Task`.
type GenerateHostConfigTaskSpecRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of host data for which configuration task list
	// needs to be generated. The
	// `StructuredCustomizations.customizations` value should be
	// provided only if the host customization data for that host is
	// invalid. If this property is not provided, the API will use the
	// host customization data stored in VC and generate task list.
	HostsInfo []StructuredCustomizations `xml:"hostsInfo,omitempty" json:"hostsInfo,omitempty"`
}

func init() {
	t["GenerateHostConfigTaskSpecRequestType"] = reflect.TypeOf((*GenerateHostConfigTaskSpecRequestType)(nil)).Elem()
}

type GenerateHostConfigTaskSpec_Task GenerateHostConfigTaskSpecRequestType

func init() {
	t["GenerateHostConfigTaskSpec_Task"] = reflect.TypeOf((*GenerateHostConfigTaskSpec_Task)(nil)).Elem()
}

type GenerateHostConfigTaskSpec_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostProfileManager.GenerateHostProfileTaskList_Task`.
type GenerateHostProfileTaskListRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// ConfigSpec which was proposed by
	// `HostProfile.ExecuteHostProfile` method.
	ConfigSpec HostConfigSpec `xml:"configSpec" json:"configSpec"`
	// Host on which the HostProfile application needs to be
	// carried out.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["GenerateHostProfileTaskListRequestType"] = reflect.TypeOf((*GenerateHostProfileTaskListRequestType)(nil)).Elem()
}

type GenerateHostProfileTaskList_Task GenerateHostProfileTaskListRequestType

func init() {
	t["GenerateHostProfileTaskList_Task"] = reflect.TypeOf((*GenerateHostProfileTaskList_Task)(nil)).Elem()
}

type GenerateHostProfileTaskList_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type GenerateKey GenerateKeyRequestType

func init() {
	t["GenerateKey"] = reflect.TypeOf((*GenerateKey)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.GenerateKey`.
type GenerateKeyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] Which provider will generate the key.
	// If omitted, will use the default key provider.
	KeyProvider *KeyProviderId `xml:"keyProvider,omitempty" json:"keyProvider,omitempty"`
	// \[in\] The spec that contains custom attributes key/value pairs.
	Spec *CryptoManagerKmipCustomAttributeSpec `xml:"spec,omitempty" json:"spec,omitempty" vim:"8.0.1.0"`
}

func init() {
	t["GenerateKeyRequestType"] = reflect.TypeOf((*GenerateKeyRequestType)(nil)).Elem()
}

type GenerateKeyResponse struct {
	Returnval CryptoKeyResult `xml:"returnval" json:"returnval"`
}

// The parameters of `DiagnosticManager.GenerateLogBundles_Task`.
type GenerateLogBundlesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specifies if the bundle should include the
	// default server. If called on a VirtualCenter
	// server, then this means the VirtualCenter
	// diagnostic files. If called directly on a host,
	// then includeDefault must be set to true.
	IncludeDefault bool `xml:"includeDefault" json:"includeDefault"`
	// Lists hosts that are included. This is only used
	// when called on VirtualCenter. If called directly
	// on a host, then this parameter must be empty.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["GenerateLogBundlesRequestType"] = reflect.TypeOf((*GenerateLogBundlesRequestType)(nil)).Elem()
}

type GenerateLogBundles_Task GenerateLogBundlesRequestType

func init() {
	t["GenerateLogBundles_Task"] = reflect.TypeOf((*GenerateLogBundles_Task)(nil)).Elem()
}

type GenerateLogBundles_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type GenerateSelfSignedClientCert GenerateSelfSignedClientCertRequestType

func init() {
	t["GenerateSelfSignedClientCert"] = reflect.TypeOf((*GenerateSelfSignedClientCert)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.GenerateSelfSignedClientCert`.
type GenerateSelfSignedClientCertRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP cluster.
	Cluster KeyProviderId `xml:"cluster" json:"cluster"`
	// \[in\] Certificate sign request.
	Request *CryptoManagerKmipCertSignRequest `xml:"request,omitempty" json:"request,omitempty" vim:"8.0.1.0"`
}

func init() {
	t["GenerateSelfSignedClientCertRequestType"] = reflect.TypeOf((*GenerateSelfSignedClientCertRequestType)(nil)).Elem()
}

type GenerateSelfSignedClientCertResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// DRS returns more than one faults for each virtual machine, or DRS returns
// `VimFault` because of some internal errors.
type GenericDrsFault struct {
	VimFault

	// This is an optional field to return the detailed information back to
	// the client.
	//
	// This optional array may consist of the exact fault for
	// some hosts in the cluster.
	HostFaults []LocalizedMethodFault `xml:"hostFaults,omitempty" json:"hostFaults,omitempty"`
}

func init() {
	t["GenericDrsFault"] = reflect.TypeOf((*GenericDrsFault)(nil)).Elem()
}

type GenericDrsFaultFault GenericDrsFault

func init() {
	t["GenericDrsFaultFault"] = reflect.TypeOf((*GenericDrsFaultFault)(nil)).Elem()
}

// Thrown when a running virtual machine reports an error.
type GenericVmConfigFault struct {
	VmConfigFault

	// Message from the virtual machine
	Reason string `xml:"reason" json:"reason"`
}

func init() {
	t["GenericVmConfigFault"] = reflect.TypeOf((*GenericVmConfigFault)(nil)).Elem()
}

type GenericVmConfigFaultFault GenericVmConfigFault

func init() {
	t["GenericVmConfigFaultFault"] = reflect.TypeOf((*GenericVmConfigFaultFault)(nil)).Elem()
}

type GetAlarm GetAlarmRequestType

func init() {
	t["GetAlarm"] = reflect.TypeOf((*GetAlarm)(nil)).Elem()
}

// The parameters of `AlarmManager.GetAlarm`.
type GetAlarmRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The entity. If not set, alarms are returned for
	// all visible entities.
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["GetAlarmRequestType"] = reflect.TypeOf((*GetAlarmRequestType)(nil)).Elem()
}

type GetAlarmResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type GetAlarmState GetAlarmStateRequestType

func init() {
	t["GetAlarmState"] = reflect.TypeOf((*GetAlarmState)(nil)).Elem()
}

// The parameters of `AlarmManager.GetAlarmState`.
type GetAlarmStateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The entity.
	//
	// Required privileges: System.Read
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["GetAlarmStateRequestType"] = reflect.TypeOf((*GetAlarmStateRequestType)(nil)).Elem()
}

type GetAlarmStateResponse struct {
	Returnval []AlarmState `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type GetCryptoKeyStatus GetCryptoKeyStatusRequestType

func init() {
	t["GetCryptoKeyStatus"] = reflect.TypeOf((*GetCryptoKeyStatus)(nil)).Elem()
}

// The parameters of `CryptoManagerHost.GetCryptoKeyStatus`.
type GetCryptoKeyStatusRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] Cryptographic keys to query status.
	Keys []CryptoKeyId `xml:"keys,omitempty" json:"keys,omitempty"`
}

func init() {
	t["GetCryptoKeyStatusRequestType"] = reflect.TypeOf((*GetCryptoKeyStatusRequestType)(nil)).Elem()
	minAPIVersionForType["GetCryptoKeyStatusRequestType"] = "8.0.1.0"
}

type GetCryptoKeyStatusResponse struct {
	Returnval []CryptoManagerHostKeyStatus `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type GetCustomizationSpec GetCustomizationSpecRequestType

func init() {
	t["GetCustomizationSpec"] = reflect.TypeOf((*GetCustomizationSpec)(nil)).Elem()
}

// The parameters of `CustomizationSpecManager.GetCustomizationSpec`.
type GetCustomizationSpecRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Unique name identifying the requested customization specification.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["GetCustomizationSpecRequestType"] = reflect.TypeOf((*GetCustomizationSpecRequestType)(nil)).Elem()
}

type GetCustomizationSpecResponse struct {
	Returnval CustomizationSpecItem `xml:"returnval" json:"returnval"`
}

type GetDefaultKmsCluster GetDefaultKmsClusterRequestType

func init() {
	t["GetDefaultKmsCluster"] = reflect.TypeOf((*GetDefaultKmsCluster)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.GetDefaultKmsCluster`.
type GetDefaultKmsClusterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] The entity where the default KMS cluster to get.
	// If omitted, then return global default KMS cluster.
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
	// \[in\] (Optional, default = false) If set to true,
	// then get the default kms cluster follow the
	// entity hierarchy. That means if the entity has
	// no default kms cluster, then try to get from
	// its parent.
	DefaultsToParent *bool `xml:"defaultsToParent" json:"defaultsToParent,omitempty"`
}

func init() {
	t["GetDefaultKmsClusterRequestType"] = reflect.TypeOf((*GetDefaultKmsClusterRequestType)(nil)).Elem()
}

type GetDefaultKmsClusterResponse struct {
	Returnval *KeyProviderId `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type GetPublicKey GetPublicKeyRequestType

func init() {
	t["GetPublicKey"] = reflect.TypeOf((*GetPublicKey)(nil)).Elem()
}

type GetPublicKeyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["GetPublicKeyRequestType"] = reflect.TypeOf((*GetPublicKeyRequestType)(nil)).Elem()
}

type GetPublicKeyResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type GetResourceUsage GetResourceUsageRequestType

func init() {
	t["GetResourceUsage"] = reflect.TypeOf((*GetResourceUsage)(nil)).Elem()
}

type GetResourceUsageRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["GetResourceUsageRequestType"] = reflect.TypeOf((*GetResourceUsageRequestType)(nil)).Elem()
}

type GetResourceUsageResponse struct {
	Returnval ClusterResourceUsageSummary `xml:"returnval" json:"returnval"`
}

type GetSiteInfo GetSiteInfoRequestType

func init() {
	t["GetSiteInfo"] = reflect.TypeOf((*GetSiteInfo)(nil)).Elem()
}

type GetSiteInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["GetSiteInfoRequestType"] = reflect.TypeOf((*GetSiteInfoRequestType)(nil)).Elem()
}

type GetSiteInfoResponse struct {
	Returnval SiteInfo `xml:"returnval" json:"returnval"`
}

type GetSystemVMsRestrictedDatastores GetSystemVMsRestrictedDatastoresRequestType

func init() {
	t["GetSystemVMsRestrictedDatastores"] = reflect.TypeOf((*GetSystemVMsRestrictedDatastores)(nil)).Elem()
}

type GetSystemVMsRestrictedDatastoresRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["GetSystemVMsRestrictedDatastoresRequestType"] = reflect.TypeOf((*GetSystemVMsRestrictedDatastoresRequestType)(nil)).Elem()
}

type GetSystemVMsRestrictedDatastoresResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type GetVchaClusterHealth GetVchaClusterHealthRequestType

func init() {
	t["GetVchaClusterHealth"] = reflect.TypeOf((*GetVchaClusterHealth)(nil)).Elem()
}

type GetVchaClusterHealthRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["GetVchaClusterHealthRequestType"] = reflect.TypeOf((*GetVchaClusterHealthRequestType)(nil)).Elem()
}

type GetVchaClusterHealthResponse struct {
	Returnval VchaClusterHealth `xml:"returnval" json:"returnval"`
}

type GetVsanObjExtAttrs GetVsanObjExtAttrsRequestType

func init() {
	t["GetVsanObjExtAttrs"] = reflect.TypeOf((*GetVsanObjExtAttrs)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.GetVsanObjExtAttrs`.
type GetVsanObjExtAttrsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of object UUIDs.
	Uuids []string `xml:"uuids" json:"uuids"`
}

func init() {
	t["GetVsanObjExtAttrsRequestType"] = reflect.TypeOf((*GetVsanObjExtAttrsRequestType)(nil)).Elem()
}

type GetVsanObjExtAttrsResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// This event records when Virtual Center server found DVS proxy switches
// on the host that don't match any DVS defined in Virtual Center.
type GhostDvsProxySwitchDetectedEvent struct {
	HostEvent

	// The list of ghost DVS proxy switch uuids that were found.
	SwitchUuid []string `xml:"switchUuid" json:"switchUuid"`
}

func init() {
	t["GhostDvsProxySwitchDetectedEvent"] = reflect.TypeOf((*GhostDvsProxySwitchDetectedEvent)(nil)).Elem()
}

// This event records when the ghost DVS proxy switches (a.k.a host
// proxy switches that don't match any DVS defined in Virtual Center)
// were removed on the host.
type GhostDvsProxySwitchRemovedEvent struct {
	HostEvent

	// The list of ghost DVS proxy switch uuid that were removed.
	SwitchUuid []string `xml:"switchUuid" json:"switchUuid"`
}

func init() {
	t["GhostDvsProxySwitchRemovedEvent"] = reflect.TypeOf((*GhostDvsProxySwitchRemovedEvent)(nil)).Elem()
}

// This event records a change to the global message.
type GlobalMessageChangedEvent struct {
	SessionEvent

	// The new message that was set.
	Message string `xml:"message" json:"message"`
	// The previous message that was set.
	PrevMessage string `xml:"prevMessage,omitempty" json:"prevMessage,omitempty"`
}

func init() {
	t["GlobalMessageChangedEvent"] = reflect.TypeOf((*GlobalMessageChangedEvent)(nil)).Elem()
}

// This data object type describes a group of
// actions that occur when the alarm is triggered.
//
// These actions are not
// necessarily executed in order.
type GroupAlarmAction struct {
	AlarmAction

	// The list of alarm actions that occur when the alarm is triggered.
	Action []BaseAlarmAction `xml:"action,typeattr" json:"action"`
}

func init() {
	t["GroupAlarmAction"] = reflect.TypeOf((*GroupAlarmAction)(nil)).Elem()
}

// Describes the representation of an alias and the subjects
// that are trusted from that VMware SSO Server.
type GuestAliases struct {
	DynamicData

	// The associated VMware SSO Server X.509 certificate, in base64
	// encoded DER format.
	Base64Cert string `xml:"base64Cert" json:"base64Cert"`
	// A white list of aliases that the in-guest user account trusts;
	// it can be a subset of the subjects known to the identity
	// provider.
	Aliases []GuestAuthAliasInfo `xml:"aliases" json:"aliases"`
}

func init() {
	t["GuestAliases"] = reflect.TypeOf((*GuestAliases)(nil)).Elem()
}

// Describes a subject associated with an X.509 certificate in the alias
// store.
type GuestAuthAliasInfo struct {
	DynamicData

	// The subject.
	Subject BaseGuestAuthSubject `xml:"subject,typeattr" json:"subject"`
	// User-supplied data to describe the subject.
	Comment string `xml:"comment" json:"comment"`
}

func init() {
	t["GuestAuthAliasInfo"] = reflect.TypeOf((*GuestAuthAliasInfo)(nil)).Elem()
}

// The ANY subject.
//
// When an in-guest user account is configured
// to trust an alias using the ANY subject, any vSphere user
// authenticated by that alias will be allowed to impersonate the
// in-guest user.
type GuestAuthAnySubject struct {
	GuestAuthSubject
}

func init() {
	t["GuestAuthAnySubject"] = reflect.TypeOf((*GuestAuthAnySubject)(nil)).Elem()
}

// A named subject.
//
// Grants access to a specific vSphere user with
// the specified name.
type GuestAuthNamedSubject struct {
	GuestAuthSubject

	// The subject name.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["GuestAuthNamedSubject"] = reflect.TypeOf((*GuestAuthNamedSubject)(nil)).Elem()
}

// A Subject.
type GuestAuthSubject struct {
	DynamicData
}

func init() {
	t["GuestAuthSubject"] = reflect.TypeOf((*GuestAuthSubject)(nil)).Elem()
}

// GuestAuthentication is an abstract base class for authentication
// in the guest.
type GuestAuthentication struct {
	DynamicData

	// This is set to true if the client wants an interactive session
	// in the guest.
	//
	// Setting this is supported only for `NamePasswordAuthentication`.
	InteractiveSession bool `xml:"interactiveSession" json:"interactiveSession"`
}

func init() {
	t["GuestAuthentication"] = reflect.TypeOf((*GuestAuthentication)(nil)).Elem()
}

// Fault is thrown when a call to `GuestAuthManager.AcquireCredentialsInGuest` requires a challenge
// response in order to authenticate in the guest.
//
// The authToken string
// in serverChallenge contains a base64 encoded challenge token.
type GuestAuthenticationChallenge struct {
	GuestOperationsFault

	// Contains the server challenge information
	ServerChallenge BaseGuestAuthentication `xml:"serverChallenge,typeattr" json:"serverChallenge"`
	// Contains a session ID number that associates the server response
	// with the initial request.
	SessionID int64 `xml:"sessionID" json:"sessionID"`
}

func init() {
	t["GuestAuthenticationChallenge"] = reflect.TypeOf((*GuestAuthenticationChallenge)(nil)).Elem()
}

type GuestAuthenticationChallengeFault GuestAuthenticationChallenge

func init() {
	t["GuestAuthenticationChallengeFault"] = reflect.TypeOf((*GuestAuthenticationChallengeFault)(nil)).Elem()
}

// A GuestComponentsOutOfDate exception is thrown when an
// operation fails because the guest operations agent is out of date and lacks
// the functionality to execute the operation.
type GuestComponentsOutOfDate struct {
	GuestOperationsFault
}

func init() {
	t["GuestComponentsOutOfDate"] = reflect.TypeOf((*GuestComponentsOutOfDate)(nil)).Elem()
}

type GuestComponentsOutOfDateFault GuestComponentsOutOfDate

func init() {
	t["GuestComponentsOutOfDateFault"] = reflect.TypeOf((*GuestComponentsOutOfDateFault)(nil)).Elem()
}

// Information about each local virtual disk configured in the
// guest operating system.
type GuestDiskInfo struct {
	DynamicData

	// Name of the virtual disk in the guest operating system.
	//
	// For example: C:\\
	DiskPath string `xml:"diskPath,omitempty" json:"diskPath,omitempty"`
	// Total capacity of the disk, in bytes.
	//
	// This is part of the virtual machine configuration.
	Capacity int64 `xml:"capacity,omitempty" json:"capacity,omitempty"`
	// Free space on the disk, in bytes.
	//
	// This is retrieved by VMware Tools.
	FreeSpace int64 `xml:"freeSpace,omitempty" json:"freeSpace,omitempty"`
	// Filesystem type, if known.
	//
	// For example NTFS or ext3.
	FilesystemType string `xml:"filesystemType,omitempty" json:"filesystemType,omitempty"`
	// VirtualDisks backing the guest partition, if known.
	Mappings []GuestInfoVirtualDiskMapping `xml:"mappings,omitempty" json:"mappings,omitempty"`
}

func init() {
	t["GuestDiskInfo"] = reflect.TypeOf((*GuestDiskInfo)(nil)).Elem()
}

// Different attributes for a guest file.
//   - Check `GuestPosixFileAttributes`
//     for Posix guest files.
//   - Check `GuestWindowsFileAttributes`
//     for Windows guest files.
type GuestFileAttributes struct {
	DynamicData

	// The date and time the file was last modified.
	//
	// If this property is not specified when passing a
	// `GuestFileAttributes` object to
	// `GuestFileManager.InitiateFileTransferToGuest`,
	// the default value will be the time when the file is created inside the
	// guest.
	ModificationTime *time.Time `xml:"modificationTime" json:"modificationTime,omitempty"`
	// The date and time the file was last accessed.
	//
	// If this property is not specified when passing a
	// `GuestFileAttributes` object to
	// `GuestFileManager.InitiateFileTransferToGuest`,
	// the default value will be the time when the file is created inside the
	// guest.
	AccessTime *time.Time `xml:"accessTime" json:"accessTime,omitempty"`
	// The target for the file if it's a symbolic link.
	//
	// This is currently only set for Linux guest operating systems,
	// but may be supported in the
	// future on Windows guest operating systems that support symbolic links.
	// This property gives information about files when returned from
	// `GuestFileManager.ListFilesInGuest` or
	// `GuestFileManager.InitiateFileTransferFromGuest`
	// as part of a `GuestFileAttributes` object.
	// This property will be ignored when passing a
	// `GuestFileAttributes` object to
	// `GuestFileManager.InitiateFileTransferToGuest` or
	// `GuestFileManager.ChangeFileAttributesInGuest`.
	// If the file is a symbolic link, then the attributes of the target
	// are returned, not those of the symbolic link.
	SymlinkTarget string `xml:"symlinkTarget,omitempty" json:"symlinkTarget,omitempty"`
}

func init() {
	t["GuestFileAttributes"] = reflect.TypeOf((*GuestFileAttributes)(nil)).Elem()
}

type GuestFileInfo struct {
	DynamicData

	// The complete path to the file
	Path string `xml:"path" json:"path"`
	// The file type, one of `GuestFileType_enum`
	Type string `xml:"type" json:"type"`
	// The file size in bytes
	Size int64 `xml:"size" json:"size"`
	// Different attributes of a file.
	Attributes BaseGuestFileAttributes `xml:"attributes,typeattr" json:"attributes"`
}

func init() {
	t["GuestFileInfo"] = reflect.TypeOf((*GuestFileInfo)(nil)).Elem()
}

// Information about the guest operating system.
//
// Most of this information is collected by VMware Tools.
// In general, be sure you have VMware Tools installed
// and that the virtual machine is running when you access this information.
type GuestInfo struct {
	DynamicData

	// Deprecated as of vSphere API 4.0 use `GuestInfo.toolsVersionStatus` and
	// `GuestInfo.toolsRunningStatus`.
	//
	// Current status of VMware Tools in the guest operating system, if known.
	ToolsStatus VirtualMachineToolsStatus `xml:"toolsStatus,omitempty" json:"toolsStatus,omitempty"`
	// Deprecated as of vSphere API 5.1 use `GuestInfo.toolsVersionStatus2`.
	//
	// Current version status of VMware Tools in the guest operating system,
	// if known.
	//
	// The set of possible values is described in
	// `VirtualMachineToolsVersionStatus_enum` for vSphere API 5.0.
	ToolsVersionStatus string `xml:"toolsVersionStatus,omitempty" json:"toolsVersionStatus,omitempty"`
	// Current version status of VMware Tools in the guest operating system,
	// if known.
	//
	// The set of possible values is described in
	// `VirtualMachineToolsVersionStatus_enum`
	ToolsVersionStatus2 string `xml:"toolsVersionStatus2,omitempty" json:"toolsVersionStatus2,omitempty"`
	// Current running status of VMware Tools in the guest operating system,
	// if known.
	//
	// The set of possible values is described in
	// `VirtualMachineToolsRunningStatus_enum`
	ToolsRunningStatus string `xml:"toolsRunningStatus,omitempty" json:"toolsRunningStatus,omitempty"`
	// Current version of VMware Tools, if known.
	ToolsVersion string `xml:"toolsVersion,omitempty" json:"toolsVersion,omitempty"`
	// Current installation type of VMware Tools in the guest operating system.
	//
	// The set of possible values is described in
	// `VirtualMachineToolsInstallType_enum`
	ToolsInstallType string `xml:"toolsInstallType,omitempty" json:"toolsInstallType,omitempty"`
	// Guest operating system identifier (short name), if known.
	GuestId string `xml:"guestId,omitempty" json:"guestId,omitempty"`
	// Guest operating system family, if known.
	GuestFamily string `xml:"guestFamily,omitempty" json:"guestFamily,omitempty"`
	// Guest operating system full name, if known.
	GuestFullName string `xml:"guestFullName,omitempty" json:"guestFullName,omitempty"`
	// Guest OS Detailed data.
	//
	// The guest detailed data string is a property list (space separated,
	// name='value' pairs where the value is embedded in single quotes) of
	// metadata provided by the guest OS when sufficiently recent tools are
	// installed. The fields supplied will vary between distributions and
	// distribution versions. The order of these fields is not guaranteed.
	//
	// The guest detailed data string is not available before a virtual machine
	// is first powered on. The guest must first be booted and a supported
	// version of tools must be run to record the data (approximately 30-60
	// seconds after booting). Once the guest detailed data string has been
	// recorded, it will be available whether the virtual machine is powered off
	// or on.
	//
	// Available fields:
	// <table summary="Available fields">
	// <thead>
	// <tr>
	// <th>Name</th>
	// <th>Description</th>
	// <th>Tools version first available</th>
	// </tr>
	// </thead>
	// <tbody>
	// <tr>
	// <td>architecture</td>
	// <td>'Arm' or 'X86'</td>
	// <td>11.2.0</td>
	// </tr>
	// <tr>
	// <td>bitness</td>
	// <td>'32' or '64'</td>
	// <td>11.2.0</td>
	// </tr>
	// <tr>
	// <td>buildNumber</td>
	// <td>OS build number</td>
	// <td>11.2.0</td>
	// </tr>
	// <tr>
	// <td>cpeString</td>
	// <td>NIST Common Platform Enumeration Specification string, a standardized identifier for the OS</td>
	// <td>12.2.0</td>
	// </tr>
	// <tr>
	// <td>distroAddlVersion</td>
	// <td>Longer OS version string that may contain additional info (e.g. version name)</td>
	// <td>12.2.0</td>
	// </tr>
	// <tr>
	// <td>distroName</td>
	// <td>OS distribution name</td>
	// <td>11.2.0</td>
	// </tr>
	// <tr>
	// <td>distroVersion</td>
	// <td>OS version string</td>
	// <td>11.2.0</td>
	// </tr>
	// <tr>
	// <td>familyName</td>
	// <td>OS family name (Windows, Linux, etc.)</td>
	// <td>11.2.0</td>
	// </tr>
	// <tr>
	// <td>kernelVersion</td>
	// <td>Linux kernel version, Windows 10+ patch number, or Windows build number</td>
	// <td>11.2.0</td>
	// </tr>
	// <tr>
	// <td>prettyName</td>
	// <td>Officially specified distro "pretty name"</td>
	// <td>11.2.0</td>
	// </tr>
	// </tbody>
	// </table>
	GuestDetailedData string `xml:"guestDetailedData,omitempty" json:"guestDetailedData,omitempty" vim:"8.0.2.0"`
	// Hostname of the guest operating system, if known.
	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
	// Primary IP address assigned to the guest operating system, if known.
	IpAddress string `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
	// Guest information about network adapters, if known.
	Net []GuestNicInfo `xml:"net,omitempty" json:"net,omitempty"`
	// Guest information about IP networking stack, if known.
	IpStack []GuestStackInfo `xml:"ipStack,omitempty" json:"ipStack,omitempty"`
	// Guest information about disks.
	//
	// You can obtain Linux guest disk information for the following file system
	// types: Ext2, Ext3, Ext4, ReiserFS, XFS, Btrfs, NTFS, VFAT, UFS, PCFS, HFS,
	// and MS-DOS.
	//
	// NOTE: Installing a more recent version of VMware Tools in the guest may help
	// obtain disk information for more file system types. Please refer the VMware Tools
	// User Guide for up-to-date supported file system types.
	Disk []GuestDiskInfo `xml:"disk,omitempty" json:"disk,omitempty"`
	// Guest screen resolution info, if known.
	Screen *GuestScreenInfo `xml:"screen,omitempty" json:"screen,omitempty"`
	// Operation mode of guest operating system.
	//
	// One of:
	//   - "running" - Guest is running normally.
	//   - "shuttingdown" - Guest has a pending shutdown command.
	//   - "resetting" - Guest has a pending reset command.
	//   - "standby" - Guest has a pending standby command.
	//   - "notrunning" - Guest is not running.
	//   - "unknown" - Guest information is not available.
	GuestState string `xml:"guestState" json:"guestState"`
	// Application heartbeat status.
	//
	// Please see `VirtualMachineAppHeartbeatStatusType_enum`
	AppHeartbeatStatus string `xml:"appHeartbeatStatus,omitempty" json:"appHeartbeatStatus,omitempty"`
	// Guest operating system's kernel crash state.
	//
	// If true, the guest operating system's kernel has crashed.
	GuestKernelCrashed *bool `xml:"guestKernelCrashed" json:"guestKernelCrashed,omitempty"`
	// Application state.
	//
	// If vSphere HA is enabled and the vm is configured for Application Monitoring
	// and this field's value is "appStateNeedReset" then HA will attempt immediately reset
	// the vm.
	// There are some system conditions which may delay the immediate reset. The immediate
	// reset will be performed as soon as allowed by vSphere HA and ESX. If during these
	// conditions the value is changed to appStateOk the reset will be cancelled.
	//
	// See also `GuestInfoAppStateType_enum`.
	AppState string `xml:"appState,omitempty" json:"appState,omitempty"`
	// Guest Operations availability.
	//
	// If true, the virtual machine is ready to process guest operations.
	GuestOperationsReady *bool `xml:"guestOperationsReady" json:"guestOperationsReady,omitempty"`
	// Interactive Guest Operations availability.
	//
	// If true, the virtual machine is ready to process guest operations
	// as the user interacting with the guest desktop.
	InteractiveGuestOperationsReady *bool `xml:"interactiveGuestOperationsReady" json:"interactiveGuestOperationsReady,omitempty"`
	// State change support.
	//
	// If true, the virtual machine is ready to process soft power operations.
	GuestStateChangeSupported *bool `xml:"guestStateChangeSupported" json:"guestStateChangeSupported,omitempty"`
	// A list of namespaces and their corresponding generation numbers.
	//
	// Only namespaces with non-zero
	// `VirtualMachineNamespaceManagerCreateSpec.maxSizeEventsFromGuest`
	// are guaranteed to be present here.
	// Use `VirtualMachineNamespaceManager.ListNamespaces` to retrieve list of
	// namespaces.
	GenerationInfo []GuestInfoNamespaceGenerationInfo `xml:"generationInfo,omitempty" json:"generationInfo,omitempty"`
	// The hardware version string for this virtual machine.
	HwVersion string `xml:"hwVersion,omitempty" json:"hwVersion,omitempty"`
	// Guest OS Customization status info.
	CustomizationInfo *GuestInfoCustomizationInfo `xml:"customizationInfo,omitempty" json:"customizationInfo,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["GuestInfo"] = reflect.TypeOf((*GuestInfo)(nil)).Elem()
}

type GuestInfoCustomizationInfo struct {
	DynamicData

	// The customization status for this VM
	//
	// See also `GuestInfoCustomizationStatus_enum`for the list of supported values.
	CustomizationStatus string `xml:"customizationStatus" json:"customizationStatus"`
	// The time when the customization process has started inside the
	// guest OS
	StartTime *time.Time `xml:"startTime" json:"startTime,omitempty"`
	// The time when the customization process has completed inside the
	// guest OS
	EndTime *time.Time `xml:"endTime" json:"endTime,omitempty"`
	// Description of the error if there is error for the customization
	// process inside the guest OS
	ErrorMsg string `xml:"errorMsg,omitempty" json:"errorMsg,omitempty"`
}

func init() {
	t["GuestInfoCustomizationInfo"] = reflect.TypeOf((*GuestInfoCustomizationInfo)(nil)).Elem()
	minAPIVersionForType["GuestInfoCustomizationInfo"] = "7.0.2.0"
}

// A data class for the namespace and its corresponding generation number
// The generation number can be used to track updates to the corresponding
// namespace.
//
// An update to the generation number indicates that the return
// value of `VirtualMachineNamespaceManager.FetchEventsFromGuest` may have
// changed.
type GuestInfoNamespaceGenerationInfo struct {
	DynamicData

	// The namespace name as the unique key.
	Key string `xml:"key" json:"key"`
	// Namespace generation number.
	//
	// Generation number is changed whenever
	// there is new unread event pending from the guest to the VMODL.
	GenerationNo int32 `xml:"generationNo" json:"generationNo"`
}

func init() {
	t["GuestInfoNamespaceGenerationInfo"] = reflect.TypeOf((*GuestInfoNamespaceGenerationInfo)(nil)).Elem()
}

// Describes the virtual disk backing a local guest disk.
type GuestInfoVirtualDiskMapping struct {
	DynamicData

	// The key of the VirtualDevice.
	//
	// `VirtualDevice.key`
	Key int32 `xml:"key" json:"key"`
}

func init() {
	t["GuestInfoVirtualDiskMapping"] = reflect.TypeOf((*GuestInfoVirtualDiskMapping)(nil)).Elem()
}

type GuestListFileInfo struct {
	DynamicData

	// A list of `GuestFileInfo`
	// data objects containing information for all the matching files.
	Files []GuestFileInfo `xml:"files,omitempty" json:"files,omitempty"`
	// The number of files left to be returned.
	//
	// If non-zero,
	// then the next set of files can be returned by calling
	// ListFiles again with the index set to the number of results
	// already returned.
	Remaining int32 `xml:"remaining" json:"remaining"`
}

func init() {
	t["GuestListFileInfo"] = reflect.TypeOf((*GuestListFileInfo)(nil)).Elem()
}

// Represents a mapping between an external subject, as
// authenticated by a given VMware SSO Server, and an in-guest user.
type GuestMappedAliases struct {
	DynamicData

	// The associated VMware SSO Server X.509 certificate, in base64
	// encoded DER format.
	Base64Cert string `xml:"base64Cert" json:"base64Cert"`
	// The in-guest user associated with the mapping.
	Username string `xml:"username" json:"username"`
	// The list of subjects associated with the mapping.
	Subjects []BaseGuestAuthSubject `xml:"subjects,typeattr" json:"subjects"`
}

func init() {
	t["GuestMappedAliases"] = reflect.TypeOf((*GuestMappedAliases)(nil)).Elem()
}

// A GuestMultipleMappings exception is thrown when an
// operation fails because the guest alias store mapping file
// contains multiple conflicting instances of the same certificate
// and username.
type GuestMultipleMappings struct {
	GuestOperationsFault
}

func init() {
	t["GuestMultipleMappings"] = reflect.TypeOf((*GuestMultipleMappings)(nil)).Elem()
}

type GuestMultipleMappingsFault GuestMultipleMappings

func init() {
	t["GuestMultipleMappingsFault"] = reflect.TypeOf((*GuestMultipleMappingsFault)(nil)).Elem()
}

// Information about each virtual network adapter
// configured in the guest operating system.
type GuestNicInfo struct {
	DynamicData

	// Name of the virtual switch portgroup or dvPort connected to this adapter.
	Network string `xml:"network,omitempty" json:"network,omitempty"`
	// Deprecated as of vSphere API 5.0, use ipConfig property.
	//
	// IP addresses of the adapter.
	IpAddress []string `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
	// MAC address of the adapter.
	MacAddress string `xml:"macAddress,omitempty" json:"macAddress,omitempty"`
	// Flag indicating whether or not the virtual device is connected.
	Connected bool `xml:"connected" json:"connected"`
	// Link to the corresponding virtual device.
	DeviceConfigId int32 `xml:"deviceConfigId" json:"deviceConfigId"`
	// DNS configuration of the adapter.
	//
	// This property is set only when Guest OS supports it.
	// See `GuestStackInfo` dnsConfig for system wide
	// settings.
	DnsConfig *NetDnsConfigInfo `xml:"dnsConfig,omitempty" json:"dnsConfig,omitempty"`
	// IP configuration settings of the adapter
	// See `GuestStackInfo` ipStackConfig for system wide
	// settings.
	IpConfig *NetIpConfigInfo `xml:"ipConfig,omitempty" json:"ipConfig,omitempty"`
	// NetBIOS configuration of the adapter
	NetBIOSConfig BaseNetBIOSConfigInfo `xml:"netBIOSConfig,omitempty,typeattr" json:"netBIOSConfig,omitempty"`
}

func init() {
	t["GuestNicInfo"] = reflect.TypeOf((*GuestNicInfo)(nil)).Elem()
}

// The common base type for all guest operations faults.
type GuestOperationsFault struct {
	VimFault
}

func init() {
	t["GuestOperationsFault"] = reflect.TypeOf((*GuestOperationsFault)(nil)).Elem()
}

type GuestOperationsFaultFault BaseGuestOperationsFault

func init() {
	t["GuestOperationsFaultFault"] = reflect.TypeOf((*GuestOperationsFaultFault)(nil)).Elem()
}

// A GuestOperationsUnavailable exception is thrown when an
// operation fails to contact the guest operations agent
// running inside the virtual machine.
type GuestOperationsUnavailable struct {
	GuestOperationsFault
}

func init() {
	t["GuestOperationsUnavailable"] = reflect.TypeOf((*GuestOperationsUnavailable)(nil)).Elem()
}

type GuestOperationsUnavailableFault GuestOperationsUnavailable

func init() {
	t["GuestOperationsUnavailableFault"] = reflect.TypeOf((*GuestOperationsUnavailableFault)(nil)).Elem()
}

// This data object type contains information to describe a
// particular guest operating system.
type GuestOsDescriptor struct {
	DynamicData

	// Identifier (short name) for the guest operating system.
	Id string `xml:"id" json:"id"`
	// Family to which this guest operating system belongs.
	Family string `xml:"family" json:"family"`
	// Full name of the guest operating system.
	//
	// For example, if the value of "id" is "win2000Pro", then
	// the value of "fullName" is "Windows 2000 Professional".
	FullName string `xml:"fullName" json:"fullName"`
	// Maximum number of processors supported for this guest.
	SupportedMaxCPUs int32 `xml:"supportedMaxCPUs" json:"supportedMaxCPUs"`
	// Maximum number of sockets supported for this guest.
	NumSupportedPhysicalSockets int32 `xml:"numSupportedPhysicalSockets,omitempty" json:"numSupportedPhysicalSockets,omitempty"`
	// Maximum number of cores per socket for this guest.
	NumSupportedCoresPerSocket int32 `xml:"numSupportedCoresPerSocket,omitempty" json:"numSupportedCoresPerSocket,omitempty"`
	// Minimum memory requirements supported for this guest, in MB.
	SupportedMinMemMB int32 `xml:"supportedMinMemMB" json:"supportedMinMemMB"`
	// Maximum memory requirements supported for this guest, in MB.
	SupportedMaxMemMB int32 `xml:"supportedMaxMemMB" json:"supportedMaxMemMB"`
	// Recommended default memory size for this guest, in MB.
	RecommendedMemMB int32 `xml:"recommendedMemMB" json:"recommendedMemMB"`
	// Recommended default color depth for this guest.
	RecommendedColorDepth int32 `xml:"recommendedColorDepth" json:"recommendedColorDepth"`
	// List of supported disk controller types for this guest.
	SupportedDiskControllerList []string `xml:"supportedDiskControllerList" json:"supportedDiskControllerList"`
	// Recommended default SCSI controller type for this guest.
	RecommendedSCSIController string `xml:"recommendedSCSIController,omitempty" json:"recommendedSCSIController,omitempty"`
	// Recommended default disk controller type for this guest.
	RecommendedDiskController string `xml:"recommendedDiskController" json:"recommendedDiskController"`
	// Number of disks supported for this guest.
	SupportedNumDisks int32 `xml:"supportedNumDisks" json:"supportedNumDisks"`
	// Recommended default disk size for this guest, in MB.
	RecommendedDiskSizeMB int32 `xml:"recommendedDiskSizeMB" json:"recommendedDiskSizeMB"`
	// Recommended default CD-ROM type for this guest.
	RecommendedCdromController string `xml:"recommendedCdromController,omitempty" json:"recommendedCdromController,omitempty"`
	// List of supported ethernet cards for this guest.
	SupportedEthernetCard []string `xml:"supportedEthernetCard" json:"supportedEthernetCard"`
	// Recommended default ethernet controller type for this guest.
	RecommendedEthernetCard string `xml:"recommendedEthernetCard,omitempty" json:"recommendedEthernetCard,omitempty"`
	// Flag to indicate whether or not this guest can support
	// a disk configured as a slave.
	SupportsSlaveDisk *bool `xml:"supportsSlaveDisk" json:"supportsSlaveDisk,omitempty"`
	// Specifies the CPU feature compatibility masks.
	CpuFeatureMask []HostCpuIdInfo `xml:"cpuFeatureMask,omitempty" json:"cpuFeatureMask,omitempty"`
	// Flag that indicates wether the guest requires an SMC (Apple hardware).
	//
	// This is logically equivalent to GuestOS = Mac OS
	SmcRequired *bool `xml:"smcRequired" json:"smcRequired,omitempty"`
	// Flag to indicate whether or not this guest can support Wake-on-LAN.
	SupportsWakeOnLan bool `xml:"supportsWakeOnLan" json:"supportsWakeOnLan"`
	// Flag indicating whether or not this guest supports the virtual
	// machine interface.
	SupportsVMI *bool `xml:"supportsVMI" json:"supportsVMI,omitempty"`
	// Whether the memory size for this guest can be changed
	// while the virtual machine is running.
	SupportsMemoryHotAdd *bool `xml:"supportsMemoryHotAdd" json:"supportsMemoryHotAdd,omitempty"`
	// Whether virtual CPUs can be added to this guest
	// while the virtual machine is running.
	SupportsCpuHotAdd *bool `xml:"supportsCpuHotAdd" json:"supportsCpuHotAdd,omitempty"`
	// Whether virtual CPUs can be removed from this guest
	// while the virtual machine is running.
	SupportsCpuHotRemove *bool `xml:"supportsCpuHotRemove" json:"supportsCpuHotRemove,omitempty"`
	// Supported firmware types for this guest.
	//
	// Possible values are described in
	// `GuestOsDescriptorFirmwareType_enum`
	SupportedFirmware []string `xml:"supportedFirmware,omitempty" json:"supportedFirmware,omitempty"`
	// Recommended firmware type for this guest.
	//
	// Possible values are described in
	// `GuestOsDescriptorFirmwareType_enum`
	RecommendedFirmware string `xml:"recommendedFirmware,omitempty" json:"recommendedFirmware,omitempty"`
	// List of supported USB controllers for this guest.
	SupportedUSBControllerList []string `xml:"supportedUSBControllerList,omitempty" json:"supportedUSBControllerList,omitempty"`
	// Recommended default USB controller type for this guest.
	RecommendedUSBController string `xml:"recommendedUSBController,omitempty" json:"recommendedUSBController,omitempty"`
	// Whether this guest supports 3D graphics.
	Supports3D *bool `xml:"supports3D" json:"supports3D,omitempty"`
	// Recommended 3D graphics for this guest.
	Recommended3D *bool `xml:"recommended3D" json:"recommended3D,omitempty"`
	// Whether SMC (Apple hardware) is recommended for this guest.
	SmcRecommended *bool `xml:"smcRecommended" json:"smcRecommended,omitempty"`
	// Whether I/O Controller Hub is recommended for this guest.
	Ich7mRecommended *bool `xml:"ich7mRecommended" json:"ich7mRecommended,omitempty"`
	// Whether USB controller is recommended for this guest.
	UsbRecommended *bool `xml:"usbRecommended" json:"usbRecommended,omitempty"`
	// Support level of this Guest
	// Possible values are described in
	// `GuestOsDescriptorSupportLevel_enum`
	SupportLevel string `xml:"supportLevel,omitempty" json:"supportLevel,omitempty"`
	// Whether or not this guest should be allowed for selection
	// during virtual machine creation.
	SupportedForCreate *bool `xml:"supportedForCreate" json:"supportedForCreate,omitempty"`
	// Video RAM size limits supported by this guest, in KB.
	VRAMSizeInKB *IntOption `xml:"vRAMSizeInKB,omitempty" json:"vRAMSizeInKB,omitempty"`
	// Maximum number of floppies supported by this guest.
	NumSupportedFloppyDevices int32 `xml:"numSupportedFloppyDevices,omitempty" json:"numSupportedFloppyDevices,omitempty"`
	// List of NICs supported by this guest that support Wake-On-Lan.
	WakeOnLanEthernetCard []string `xml:"wakeOnLanEthernetCard,omitempty" json:"wakeOnLanEthernetCard,omitempty"`
	// Whether or not this guest can use pvscsi as boot adapter.
	SupportsPvscsiControllerForBoot *bool `xml:"supportsPvscsiControllerForBoot" json:"supportsPvscsiControllerForBoot,omitempty"`
	// Whether or not this guest should have disk uuid enabled by default.
	DiskUuidEnabled *bool `xml:"diskUuidEnabled" json:"diskUuidEnabled,omitempty"`
	// Whether or not this guest supports hot plug of PCI devices.
	SupportsHotPlugPCI *bool `xml:"supportsHotPlugPCI" json:"supportsHotPlugPCI,omitempty"`
	// Whether or not this guest supports Secure Boot.
	//
	// If some of the OS
	// releases that fall under this guest OS descriptor support Secure Boot, it
	// is reasonable to offer the ability to enable Secure Boot. Only
	// meaningful when virtual EFI firmware is in use.
	SupportsSecureBoot *bool `xml:"supportsSecureBoot" json:"supportsSecureBoot,omitempty"`
	// Whether or not Secure Boot should be enabled by default for this
	// guest OS.
	//
	// If all OS releases that fall under this guest OS descriptor
	// support Secure Boot and are known to operate correctly with Secure Boot
	// enabled, it is reasonable to enable it by default. Only meaningful when
	// virtual EFI firmware is in use.
	DefaultSecureBoot *bool `xml:"defaultSecureBoot" json:"defaultSecureBoot,omitempty"`
	// Support of persistent memory (virtual NVDIMM device).
	//
	// See also `VirtualNVDIMM`.
	PersistentMemorySupported *bool `xml:"persistentMemorySupported" json:"persistentMemorySupported,omitempty"`
	// Minimum persistent memory supported for this guest, in MB.
	SupportedMinPersistentMemoryMB int64 `xml:"supportedMinPersistentMemoryMB,omitempty" json:"supportedMinPersistentMemoryMB,omitempty"`
	// Maximum persistent memory supported for this guest, in MB.
	//
	// Total size of all the virtual NVDIMM devices should be less
	// than this value.
	SupportedMaxPersistentMemoryMB int64 `xml:"supportedMaxPersistentMemoryMB,omitempty" json:"supportedMaxPersistentMemoryMB,omitempty"`
	// Recommended default persistent memory size for this guest, in MB.
	RecommendedPersistentMemoryMB int64 `xml:"recommendedPersistentMemoryMB,omitempty" json:"recommendedPersistentMemoryMB,omitempty"`
	// Support of persistent memory hot-add operation.
	PersistentMemoryHotAddSupported *bool `xml:"persistentMemoryHotAddSupported" json:"persistentMemoryHotAddSupported,omitempty"`
	// Support of persistent memory hot-remove operation.
	PersistentMemoryHotRemoveSupported *bool `xml:"persistentMemoryHotRemoveSupported" json:"persistentMemoryHotRemoveSupported,omitempty"`
	// Support of virtual NVDIMM cold-growth operation.
	PersistentMemoryColdGrowthSupported *bool `xml:"persistentMemoryColdGrowthSupported" json:"persistentMemoryColdGrowthSupported,omitempty"`
	// Virtual NVDIMM cold-growth granularity in MB.
	PersistentMemoryColdGrowthGranularityMB int64 `xml:"persistentMemoryColdGrowthGranularityMB,omitempty" json:"persistentMemoryColdGrowthGranularityMB,omitempty"`
	// Support of virtual NVDIMM hot-growth operation.
	PersistentMemoryHotGrowthSupported *bool `xml:"persistentMemoryHotGrowthSupported" json:"persistentMemoryHotGrowthSupported,omitempty"`
	// Virtual NVDIMM hot-growth granularity in MB.
	PersistentMemoryHotGrowthGranularityMB int64 `xml:"persistentMemoryHotGrowthGranularityMB,omitempty" json:"persistentMemoryHotGrowthGranularityMB,omitempty"`
	// Recommended number of sockets for this guest.
	NumRecommendedPhysicalSockets int32 `xml:"numRecommendedPhysicalSockets,omitempty" json:"numRecommendedPhysicalSockets,omitempty"`
	// Recommended number of cores per socket for this guest.
	NumRecommendedCoresPerSocket int32 `xml:"numRecommendedCoresPerSocket,omitempty" json:"numRecommendedCoresPerSocket,omitempty"`
	// Support of Intel Virtualization Technology for Directed I/O.
	VvtdSupported *BoolOption `xml:"vvtdSupported,omitempty" json:"vvtdSupported,omitempty"`
	// Support of Virtualization-based security.
	VbsSupported *BoolOption `xml:"vbsSupported,omitempty" json:"vbsSupported,omitempty"`
	// Support for Intel Software Guard Extensions
	VsgxSupported *BoolOption `xml:"vsgxSupported,omitempty" json:"vsgxSupported,omitempty"`
	// Support for Intel Software Guard Extensions remote attestation.
	VsgxRemoteAttestationSupported *bool `xml:"vsgxRemoteAttestationSupported" json:"vsgxRemoteAttestationSupported,omitempty" vim:"8.0.0.1"`
	// Support for TPM 2.0.
	SupportsTPM20 *bool `xml:"supportsTPM20" json:"supportsTPM20,omitempty"`
	// Support for default vTPM
	RecommendedTPM20 *bool `xml:"recommendedTPM20" json:"recommendedTPM20,omitempty" vim:"8.0.0.1"`
	// Support for Virtual Watchdog Timer.
	VwdtSupported *bool `xml:"vwdtSupported" json:"vwdtSupported,omitempty"`
}

func init() {
	t["GuestOsDescriptor"] = reflect.TypeOf((*GuestOsDescriptor)(nil)).Elem()
}

// A GuestPermissionDenied exception is thrown when an
// operation fails because the authentication used
// is insufficient to perform the operation.
type GuestPermissionDenied struct {
	GuestOperationsFault
}

func init() {
	t["GuestPermissionDenied"] = reflect.TypeOf((*GuestPermissionDenied)(nil)).Elem()
}

type GuestPermissionDeniedFault GuestPermissionDenied

func init() {
	t["GuestPermissionDeniedFault"] = reflect.TypeOf((*GuestPermissionDeniedFault)(nil)).Elem()
}

// Different attributes for Posix guest file.
type GuestPosixFileAttributes struct {
	GuestFileAttributes

	// The owner ID.
	//
	// If this property is not specified when passing a
	// `GuestPosixFileAttributes` object to
	// `GuestFileManager.InitiateFileTransferToGuest`,
	// the default value will be the owner Id of the user who invoked
	// the file transfer operation.
	OwnerId *int32 `xml:"ownerId" json:"ownerId,omitempty"`
	// The group ID.
	//
	// If this property is not specified when passing a
	// `GuestPosixFileAttributes` object to
	// `GuestFileManager.InitiateFileTransferToGuest`,
	// the default value will be the group Id of the user who invoked
	// the file transfer operation.
	GroupId *int32 `xml:"groupId" json:"groupId,omitempty"`
	// The file permissions.
	//
	// When creating a file with
	// `GuestFileManager.InitiateFileTransferToGuest`,
	// these are in chmod(2) format. When reporting on
	// existing files, these are in stat(2) format.
	// If this property is not specified when passing a
	// `GuestPosixFileAttributes` object to
	// `GuestFileManager.InitiateFileTransferToGuest`,
	// the file will be created with 0644 permissions.
	Permissions int64 `xml:"permissions,omitempty" json:"permissions,omitempty"`
}

func init() {
	t["GuestPosixFileAttributes"] = reflect.TypeOf((*GuestPosixFileAttributes)(nil)).Elem()
}

type GuestProcessInfo struct {
	DynamicData

	// The process name
	Name string `xml:"name" json:"name"`
	// The process ID
	Pid int64 `xml:"pid" json:"pid"`
	// The process owner
	Owner string `xml:"owner" json:"owner"`
	// The full command line
	CmdLine string `xml:"cmdLine" json:"cmdLine"`
	// The start time of the process
	StartTime time.Time `xml:"startTime" json:"startTime"`
	// If the process was started using
	// `GuestProcessManager.StartProgramInGuest`
	// then the process completion time will be available if
	// queried within 5 minutes after it completes.
	EndTime *time.Time `xml:"endTime" json:"endTime,omitempty"`
	// If the process was started using
	// `GuestProcessManager.StartProgramInGuest`
	// then the process exit code will be available if
	// queried within 5 minutes after it completes.
	ExitCode int32 `xml:"exitCode,omitempty" json:"exitCode,omitempty"`
}

func init() {
	t["GuestProcessInfo"] = reflect.TypeOf((*GuestProcessInfo)(nil)).Elem()
}

// A GuestProcessNotFound exception is thrown when an
// operation fails because the guest process specified does not exist.
type GuestProcessNotFound struct {
	GuestOperationsFault

	// The process ID that was not found.
	Pid int64 `xml:"pid" json:"pid"`
}

func init() {
	t["GuestProcessNotFound"] = reflect.TypeOf((*GuestProcessNotFound)(nil)).Elem()
}

type GuestProcessNotFoundFault GuestProcessNotFound

func init() {
	t["GuestProcessNotFoundFault"] = reflect.TypeOf((*GuestProcessNotFoundFault)(nil)).Elem()
}

// This describes the arguments to `GuestProcessManager.StartProgramInGuest`.
type GuestProgramSpec struct {
	DynamicData

	// The absolute path to the program to start.
	//
	// For Linux guest operating systems, /bin/bash is used to start the
	// program.
	//
	// For Solaris guest operating systems, /bin/bash is used to start
	// the program if it exists.
	// Otherwise /bin/sh is used. If /bin/sh is used, then the process ID
	// returned by `GuestProcessManager.StartProgramInGuest` will be that of the shell used
	// to start the program, rather than the program itself, due to the
	// differences in how /bin/sh and /bin/bash work. This PID will
	// still be usable for watching the process with
	// `GuestProcessManager.ListProcessesInGuest` to
	// find its exit code and elapsed time.
	ProgramPath string `xml:"programPath" json:"programPath"`
	// The arguments to the program.
	//
	// In Linux and Solaris guest operating
	// systems, the program will be executed by a guest shell.
	// This allows stdio redirection, but may also
	// require that characters which must be escaped to the shell also
	// be escaped on the command line provided.
	//
	// For Windows guest operating systems, prefixing the command with
	// "cmd /c" can provide stdio redirection.
	Arguments string `xml:"arguments" json:"arguments"`
	// The absolute path of the working directory for the program to be
	// run.
	//
	// VMware recommends explicitly setting the working directory
	// for the program to be run. If this value is unset or is an empty
	// string, the behavior depends on the guest operating system.
	// For Linux guest operating systems, if this value is unset or is
	// an empty string, the working directory will be the home directory
	// of the user associated with the guest authentication.
	// For other guest operating systems, if this value is unset, the
	// behavior is unspecified.
	WorkingDirectory string `xml:"workingDirectory,omitempty" json:"workingDirectory,omitempty"`
	// An array of environment variables, specified
	// in the guest OS notation (eg PATH=c:\\bin;c:\\windows\\system32
	// or LD\_LIBRARY\_PATH=/usr/lib:/lib), to be set for the program
	// being run.
	//
	// Note that these are not additions to the default
	// environment variables; they define the complete set available to
	// the program. If none are specified the values are guest dependent.
	EnvVariables []string `xml:"envVariables,omitempty" json:"envVariables,omitempty"`
}

func init() {
	t["GuestProgramSpec"] = reflect.TypeOf((*GuestProgramSpec)(nil)).Elem()
}

// This describes the registry key name.
type GuestRegKeyNameSpec struct {
	DynamicData

	// The full path to a registry key.
	RegistryPath string `xml:"registryPath" json:"registryPath"`
	// The wow bitness, one of `GuestRegKeyWowSpec_enum`.
	WowBitness string `xml:"wowBitness" json:"wowBitness"`
}

func init() {
	t["GuestRegKeyNameSpec"] = reflect.TypeOf((*GuestRegKeyNameSpec)(nil)).Elem()
}

// This describes the registry key record.
type GuestRegKeyRecordSpec struct {
	DynamicData

	// The key.
	Key GuestRegKeySpec `xml:"key" json:"key"`
	// Any error that occurred while trying to access this key.
	//
	// Presence of this fault indicates that a recursive listing failed to
	// open this key to find keys below it in the tree. This could be a
	// result of insufficient user permissions within the guest.
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["GuestRegKeyRecordSpec"] = reflect.TypeOf((*GuestRegKeyRecordSpec)(nil)).Elem()
}

// This describes the registry key.
type GuestRegKeySpec struct {
	DynamicData

	// The key name.
	KeyName GuestRegKeyNameSpec `xml:"keyName" json:"keyName"`
	// The user-defined class type of this key.
	ClassType string `xml:"classType" json:"classType"`
	// Time stamp of last modification.
	LastWritten time.Time `xml:"lastWritten" json:"lastWritten"`
}

func init() {
	t["GuestRegKeySpec"] = reflect.TypeOf((*GuestRegKeySpec)(nil)).Elem()
}

// This describes the registry value binary.
type GuestRegValueBinarySpec struct {
	GuestRegValueDataSpec

	// The data of the registry value.
	//
	// The Windows registry allows this type of value to exist without
	// having any data associated with it.
	Value []byte `xml:"value,omitempty" json:"value,omitempty"`
}

func init() {
	t["GuestRegValueBinarySpec"] = reflect.TypeOf((*GuestRegValueBinarySpec)(nil)).Elem()
}

// This describes the registry value data.
type GuestRegValueDataSpec struct {
	DynamicData
}

func init() {
	t["GuestRegValueDataSpec"] = reflect.TypeOf((*GuestRegValueDataSpec)(nil)).Elem()
}

// This describes the registry value dword.
type GuestRegValueDwordSpec struct {
	GuestRegValueDataSpec

	// The data of the registry value.
	Value int32 `xml:"value" json:"value"`
}

func init() {
	t["GuestRegValueDwordSpec"] = reflect.TypeOf((*GuestRegValueDwordSpec)(nil)).Elem()
}

// This describes the registry value expand string.
type GuestRegValueExpandStringSpec struct {
	GuestRegValueDataSpec

	// The expanded (if applicable) data of the registry value.
	//
	// The Windows registry allows this type of value to exist without
	// having any data associated with it.
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

func init() {
	t["GuestRegValueExpandStringSpec"] = reflect.TypeOf((*GuestRegValueExpandStringSpec)(nil)).Elem()
}

// This describes the registry value multi string.
type GuestRegValueMultiStringSpec struct {
	GuestRegValueDataSpec

	// The data of the registry value.
	//
	// The Windows registry allows this type of value to exist without
	// having any data associated with it.
	Value []string `xml:"value,omitempty" json:"value,omitempty"`
}

func init() {
	t["GuestRegValueMultiStringSpec"] = reflect.TypeOf((*GuestRegValueMultiStringSpec)(nil)).Elem()
}

// This describes the registry value name.
type GuestRegValueNameSpec struct {
	DynamicData

	// The key name that contains this value.
	KeyName GuestRegKeyNameSpec `xml:"keyName" json:"keyName"`
	// The name of the value.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["GuestRegValueNameSpec"] = reflect.TypeOf((*GuestRegValueNameSpec)(nil)).Elem()
}

// This describes the registry value qword.
type GuestRegValueQwordSpec struct {
	GuestRegValueDataSpec

	// The data of the registry value.
	Value int64 `xml:"value" json:"value"`
}

func init() {
	t["GuestRegValueQwordSpec"] = reflect.TypeOf((*GuestRegValueQwordSpec)(nil)).Elem()
}

// This describes the registry value.
type GuestRegValueSpec struct {
	DynamicData

	// The value name.
	Name GuestRegValueNameSpec `xml:"name" json:"name"`
	// The value data.
	//
	// Use one of the extended classes to specify data type:
	// `GuestRegValueDwordSpec`,
	// `GuestRegValueQwordSpec`,
	// `GuestRegValueStringSpec`,
	// `GuestRegValueExpandStringSpec`,
	// `GuestRegValueMultiStringSpec`,
	// `GuestRegValueBinarySpec`.
	Data BaseGuestRegValueDataSpec `xml:"data,typeattr" json:"data"`
}

func init() {
	t["GuestRegValueSpec"] = reflect.TypeOf((*GuestRegValueSpec)(nil)).Elem()
}

// This describes the registry value string.
type GuestRegValueStringSpec struct {
	GuestRegValueDataSpec

	// The data of the registry value.
	//
	// The Windows registry allows this type of value to exist without
	// having any data associated with it.
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

func init() {
	t["GuestRegValueStringSpec"] = reflect.TypeOf((*GuestRegValueStringSpec)(nil)).Elem()
}

// A GuestRegistryFault exception is thrown when an operation fails
// because of some errors in accessing/modifying the guest registry.
type GuestRegistryFault struct {
	GuestOperationsFault

	// The windows system error number from GetLastError().
	WindowsSystemErrorCode int64 `xml:"windowsSystemErrorCode" json:"windowsSystemErrorCode"`
}

func init() {
	t["GuestRegistryFault"] = reflect.TypeOf((*GuestRegistryFault)(nil)).Elem()
}

type GuestRegistryFaultFault BaseGuestRegistryFault

func init() {
	t["GuestRegistryFaultFault"] = reflect.TypeOf((*GuestRegistryFaultFault)(nil)).Elem()
}

// A GuestRegistryKeyAlreadyExists exception is thrown when an operation fails
// because the guest registry key specified already exists.
type GuestRegistryKeyAlreadyExists struct {
	GuestRegistryKeyFault
}

func init() {
	t["GuestRegistryKeyAlreadyExists"] = reflect.TypeOf((*GuestRegistryKeyAlreadyExists)(nil)).Elem()
}

type GuestRegistryKeyAlreadyExistsFault GuestRegistryKeyAlreadyExists

func init() {
	t["GuestRegistryKeyAlreadyExistsFault"] = reflect.TypeOf((*GuestRegistryKeyAlreadyExistsFault)(nil)).Elem()
}

// A GuestRegistryKeyFault exception is thrown when an operation fails
// because of some errors in accessing/modifying a guest registry key.
type GuestRegistryKeyFault struct {
	GuestRegistryFault

	// The full path to the windows registry key.
	KeyName string `xml:"keyName" json:"keyName"`
}

func init() {
	t["GuestRegistryKeyFault"] = reflect.TypeOf((*GuestRegistryKeyFault)(nil)).Elem()
}

type GuestRegistryKeyFaultFault BaseGuestRegistryKeyFault

func init() {
	t["GuestRegistryKeyFaultFault"] = reflect.TypeOf((*GuestRegistryKeyFaultFault)(nil)).Elem()
}

// A GuestRegistryKeyHasSubkeys exception is thrown when an operation fails
// because the guest registry key has subkeys.
//
// If a delete on the key is
// desired, please use the recursive delete option.
type GuestRegistryKeyHasSubkeys struct {
	GuestRegistryKeyFault
}

func init() {
	t["GuestRegistryKeyHasSubkeys"] = reflect.TypeOf((*GuestRegistryKeyHasSubkeys)(nil)).Elem()
}

type GuestRegistryKeyHasSubkeysFault GuestRegistryKeyHasSubkeys

func init() {
	t["GuestRegistryKeyHasSubkeysFault"] = reflect.TypeOf((*GuestRegistryKeyHasSubkeysFault)(nil)).Elem()
}

// A GuestRegistryKeyInvalid exception is thrown when an operation fails
// because the guest registry key specified was not valid (most probably
// due to an invalid HKEY Root in the key path), or does not exist.
type GuestRegistryKeyInvalid struct {
	GuestRegistryKeyFault
}

func init() {
	t["GuestRegistryKeyInvalid"] = reflect.TypeOf((*GuestRegistryKeyInvalid)(nil)).Elem()
}

type GuestRegistryKeyInvalidFault GuestRegistryKeyInvalid

func init() {
	t["GuestRegistryKeyInvalidFault"] = reflect.TypeOf((*GuestRegistryKeyInvalidFault)(nil)).Elem()
}

// A GuestRegistryKeyParentVolatile exception is thrown when trying to create
// a non-volatile registry subkey under a volatile registry parent key.
type GuestRegistryKeyParentVolatile struct {
	GuestRegistryKeyFault
}

func init() {
	t["GuestRegistryKeyParentVolatile"] = reflect.TypeOf((*GuestRegistryKeyParentVolatile)(nil)).Elem()
}

type GuestRegistryKeyParentVolatileFault GuestRegistryKeyParentVolatile

func init() {
	t["GuestRegistryKeyParentVolatileFault"] = reflect.TypeOf((*GuestRegistryKeyParentVolatileFault)(nil)).Elem()
}

// A GuestRegistryValueFault exception is thrown when an operation fails
// because of some errors in accessing/modifying a guest registry value.
type GuestRegistryValueFault struct {
	GuestRegistryFault

	// The full path to the windows registry key containing the value.
	KeyName string `xml:"keyName" json:"keyName"`
	// The name of the value.
	ValueName string `xml:"valueName" json:"valueName"`
}

func init() {
	t["GuestRegistryValueFault"] = reflect.TypeOf((*GuestRegistryValueFault)(nil)).Elem()
}

type GuestRegistryValueFaultFault BaseGuestRegistryValueFault

func init() {
	t["GuestRegistryValueFaultFault"] = reflect.TypeOf((*GuestRegistryValueFaultFault)(nil)).Elem()
}

// A GuestRegistryValueNotFound exception is thrown when an operation fails
// because the guest registry Value specified was not found.
type GuestRegistryValueNotFound struct {
	GuestRegistryValueFault
}

func init() {
	t["GuestRegistryValueNotFound"] = reflect.TypeOf((*GuestRegistryValueNotFound)(nil)).Elem()
}

type GuestRegistryValueNotFoundFault GuestRegistryValueNotFound

func init() {
	t["GuestRegistryValueNotFoundFault"] = reflect.TypeOf((*GuestRegistryValueNotFoundFault)(nil)).Elem()
}

// Screen settings
type GuestScreenInfo struct {
	DynamicData

	// Width of the screen in pixels.
	Width int32 `xml:"width" json:"width"`
	// Height of the screen in pixels.
	Height int32 `xml:"height" json:"height"`
}

func init() {
	t["GuestScreenInfo"] = reflect.TypeOf((*GuestScreenInfo)(nil)).Elem()
}

// Information about the Internet Protocol stack
// as configured in the guest operating system.
type GuestStackInfo struct {
	DynamicData

	// Client DNS configuration.
	//
	// How DNS queries are resolved.
	DnsConfig *NetDnsConfigInfo `xml:"dnsConfig,omitempty" json:"dnsConfig,omitempty"`
	// IP route table configuration.
	IpRouteConfig *NetIpRouteConfigInfo `xml:"ipRouteConfig,omitempty" json:"ipRouteConfig,omitempty"`
	// Report Kernel IP configuration settings.
	//
	// The key part contains a unique number in the report.
	// The value part contains the 'key=value'
	// as provided by the underlying provider.
	// For example on Linux, BSD, the
	// systcl -a output would be reported as:
	// key='5', value='net.ipv4.tcp\_keepalive\_time = 7200'
	IpStackConfig []KeyValue `xml:"ipStackConfig,omitempty" json:"ipStackConfig,omitempty"`
	// Client side DHCP for a given interface.
	//
	// This reports only the system wide dhcp client settings.
	// See NicInfo.IpConfig for per interface settings.
	// For example on Linux, BSD systems:
	// Using the file dhclient.conf output would be reported as:
	// key='1', value='timeout 60;'
	// key='2', value='reboot 10;'
	DhcpConfig *NetDhcpConfigInfo `xml:"dhcpConfig,omitempty" json:"dhcpConfig,omitempty"`
}

func init() {
	t["GuestStackInfo"] = reflect.TypeOf((*GuestStackInfo)(nil)).Elem()
}

// Different attributes for a Windows guest file.
type GuestWindowsFileAttributes struct {
	GuestFileAttributes

	// The file is hidden.
	//
	// If this property is not specified when passing a
	// `GuestWindowsFileAttributes` object to
	// `GuestFileManager.InitiateFileTransferToGuest`,
	// the file will not be set as a hidden file.
	Hidden *bool `xml:"hidden" json:"hidden,omitempty"`
	// The file is read-only.
	//
	// If this property is not specified when passing a
	// `GuestWindowsFileAttributes` object to
	// `GuestFileManager.InitiateFileTransferToGuest`,
	// the file will not be set as a read-only file.
	ReadOnly *bool `xml:"readOnly" json:"readOnly,omitempty"`
	// The date and time the file was created.
	//
	// This property gives information about files when returned from
	// `GuestFileManager.ListFilesInGuest` or
	// `GuestFileManager.InitiateFileTransferFromGuest`
	// as part of a `GuestWindowsFileAttributes`
	// object. This property will be ignored when passing a
	// `GuestWindowsFileAttributes` object to
	// `GuestFileManager.InitiateFileTransferToGuest` or
	// `GuestFileManager.ChangeFileAttributesInGuest`.
	CreateTime *time.Time `xml:"createTime" json:"createTime,omitempty"`
}

func init() {
	t["GuestWindowsFileAttributes"] = reflect.TypeOf((*GuestWindowsFileAttributes)(nil)).Elem()
}

// This describes the arguments to `GuestProcessManager.StartProgramInGuest` that apply
// only for Windows guests.
type GuestWindowsProgramSpec struct {
	GuestProgramSpec

	// Makes any program window start minimized.
	StartMinimized bool `xml:"startMinimized" json:"startMinimized"`
}

func init() {
	t["GuestWindowsProgramSpec"] = reflect.TypeOf((*GuestWindowsProgramSpec)(nil)).Elem()
}

// The destination compute resource is HA-enabled, and HA is not running
// properly.
//
// This will cause the following problems:
// 1\) The VM will not have HA protection.
// 2\) If this is an intracluster VMotion, HA will not be properly
// informed that the migration completed. This can have serious
// consequences to the functioning of HA.
type HAErrorsAtDest struct {
	MigrationFault
}

func init() {
	t["HAErrorsAtDest"] = reflect.TypeOf((*HAErrorsAtDest)(nil)).Elem()
}

type HAErrorsAtDestFault HAErrorsAtDest

func init() {
	t["HAErrorsAtDestFault"] = reflect.TypeOf((*HAErrorsAtDestFault)(nil)).Elem()
}

type HasMonitoredEntity HasMonitoredEntityRequestType

func init() {
	t["HasMonitoredEntity"] = reflect.TypeOf((*HasMonitoredEntity)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.HasMonitoredEntity`.
type HasMonitoredEntityRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The provider id.
	ProviderId string `xml:"providerId" json:"providerId"`
	// An entity of type HostSystem.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["HasMonitoredEntityRequestType"] = reflect.TypeOf((*HasMonitoredEntityRequestType)(nil)).Elem()
}

type HasMonitoredEntityResponse struct {
	Returnval bool `xml:"returnval" json:"returnval"`
}

type HasPrivilegeOnEntities HasPrivilegeOnEntitiesRequestType

func init() {
	t["HasPrivilegeOnEntities"] = reflect.TypeOf((*HasPrivilegeOnEntities)(nil)).Elem()
}

// The parameters of `AuthorizationManager.HasPrivilegeOnEntities`.
type HasPrivilegeOnEntitiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The set of entities on which the privileges are checked.
	//
	// Required privileges: System.Read
	//
	// Refers instances of `ManagedEntity`.
	Entity []ManagedObjectReference `xml:"entity" json:"entity"`
	// The session ID to check privileges for. A sesssion ID can be
	// obtained from `UserSession.key`.
	SessionId string `xml:"sessionId" json:"sessionId"`
	// The array of privilege IDs to check.
	PrivId []string `xml:"privId,omitempty" json:"privId,omitempty"`
}

func init() {
	t["HasPrivilegeOnEntitiesRequestType"] = reflect.TypeOf((*HasPrivilegeOnEntitiesRequestType)(nil)).Elem()
}

type HasPrivilegeOnEntitiesResponse struct {
	Returnval []EntityPrivilege `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type HasPrivilegeOnEntity HasPrivilegeOnEntityRequestType

func init() {
	t["HasPrivilegeOnEntity"] = reflect.TypeOf((*HasPrivilegeOnEntity)(nil)).Elem()
}

// The parameters of `AuthorizationManager.HasPrivilegeOnEntity`.
type HasPrivilegeOnEntityRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The entity on which the privileges are checked.
	//
	// Required privileges: System.Read
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// The session ID to check privileges for. A sesssion ID can be
	// obtained from `UserSession.key`.
	SessionId string `xml:"sessionId" json:"sessionId"`
	// The array of privilege IDs to check.
	PrivId []string `xml:"privId,omitempty" json:"privId,omitempty"`
}

func init() {
	t["HasPrivilegeOnEntityRequestType"] = reflect.TypeOf((*HasPrivilegeOnEntityRequestType)(nil)).Elem()
}

type HasPrivilegeOnEntityResponse struct {
	Returnval []bool `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type HasProvider HasProviderRequestType

func init() {
	t["HasProvider"] = reflect.TypeOf((*HasProvider)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.HasProvider`.
type HasProviderRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The provider id.
	Id string `xml:"id" json:"id"`
}

func init() {
	t["HasProviderRequestType"] = reflect.TypeOf((*HasProviderRequestType)(nil)).Elem()
}

type HasProviderResponse struct {
	Returnval bool `xml:"returnval" json:"returnval"`
}

type HasUserPrivilegeOnEntities HasUserPrivilegeOnEntitiesRequestType

func init() {
	t["HasUserPrivilegeOnEntities"] = reflect.TypeOf((*HasUserPrivilegeOnEntities)(nil)).Elem()
}

// The parameters of `AuthorizationManager.HasUserPrivilegeOnEntities`.
type HasUserPrivilegeOnEntitiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// are the managed objects to check privileges on. If they
	// refer to managed objects that are not managed entities
	// the privilege check will be done on the root folder.
	//
	// Required privileges: System.View
	Entities []ManagedObjectReference `xml:"entities" json:"entities"`
	// is the name of the user to check privileges for. Both
	// UPN and PreWindows2000LogonName user name formats
	// are supported.
	UserName string `xml:"userName" json:"userName"`
	// is the set of privileges to check for
	PrivId []string `xml:"privId,omitempty" json:"privId,omitempty"`
}

func init() {
	t["HasUserPrivilegeOnEntitiesRequestType"] = reflect.TypeOf((*HasUserPrivilegeOnEntitiesRequestType)(nil)).Elem()
}

type HasUserPrivilegeOnEntitiesResponse struct {
	Returnval []EntityPrivilege `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// Describes a single HBR secondary disk migration action.
//
// The storage migration
// action applies either to a single disk or a set of secondary virtual disks.
type HbrDiskMigrationAction struct {
	ClusterAction

	// HMS Service specific collection id
	CollectionId string `xml:"collectionId" json:"collectionId"`
	// HMS specific name of this collection
	CollectionName string `xml:"collectionName" json:"collectionName"`
	// HBR disk ids of secondary disks moved by this action
	DiskIds []string `xml:"diskIds" json:"diskIds"`
	// Source datastore.
	//
	// Refers instance of `Datastore`.
	Source ManagedObjectReference `xml:"source" json:"source"`
	// Destination datastore.
	//
	// Refers instance of `Datastore`.
	Destination ManagedObjectReference `xml:"destination" json:"destination"`
	// The amount of data to be transferred.
	//
	// Unit: KB.
	SizeTransferred int64 `xml:"sizeTransferred" json:"sizeTransferred"`
	// Space utilization on the source datastore before storage migration.
	//
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilSrcBefore float32 `xml:"spaceUtilSrcBefore,omitempty" json:"spaceUtilSrcBefore,omitempty"`
	// Space utilization on the destination datastore before storage migration.
	//
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilDstBefore float32 `xml:"spaceUtilDstBefore,omitempty" json:"spaceUtilDstBefore,omitempty"`
	// Expected space utilization on the source datastore after storage migration.
	//
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilSrcAfter float32 `xml:"spaceUtilSrcAfter,omitempty" json:"spaceUtilSrcAfter,omitempty"`
	// Expected space utilization on the destination datastore after storage migration.
	//
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilDstAfter float32 `xml:"spaceUtilDstAfter,omitempty" json:"spaceUtilDstAfter,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// I/O latency on the source datastore before storage migration.
	//
	// Unit: millisecond.
	// If not set, the value is not available.
	IoLatencySrcBefore float32 `xml:"ioLatencySrcBefore,omitempty" json:"ioLatencySrcBefore,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// I/O latency on the destination datastore before storage migration.
	//
	// Unit: millisecond.
	// If not set, the value is not available.
	IoLatencyDstBefore float32 `xml:"ioLatencyDstBefore,omitempty" json:"ioLatencyDstBefore,omitempty"`
}

func init() {
	t["HbrDiskMigrationAction"] = reflect.TypeOf((*HbrDiskMigrationAction)(nil)).Elem()
}

// This data object represents the essential information about the
// state of a given replicated `VirtualMachine`.
type HbrManagerReplicationVmInfo struct {
	DynamicData

	// A string representing the current `ReplicationVmState_enum` of the virtual machine.
	State string `xml:"state" json:"state"`
	// Progress stats for the current operation.
	//
	// Never present if the state is
	// not "syncing" or "active". If not present while in one of these states,
	// the host is still gathering initial operation statistics (progress can
	// be assumed to be 0).
	ProgressInfo *ReplicationVmProgressInfo `xml:"progressInfo,omitempty" json:"progressInfo,omitempty"`
	// An optional imageId that identifies the instance being created,
	// this is the imagId string that is passed to
	// `HbrManager.HbrCreateInstance_Task` or
	// `HbrManager.HbrStartOfflineInstance_Task`
	ImageId string `xml:"imageId,omitempty" json:"imageId,omitempty"`
	// A MethodFault representing the last replication specific error
	// that the `VirtualMachine` encountered during a create
	// instance operation.
	//
	// The successful creation of an instance
	// will clear any error.
	LastError *LocalizedMethodFault `xml:"lastError,omitempty" json:"lastError,omitempty"`
}

func init() {
	t["HbrManagerReplicationVmInfo"] = reflect.TypeOf((*HbrManagerReplicationVmInfo)(nil)).Elem()
}

// This data object represents the capabilities of a given
// `VirtualMachine`.
type HbrManagerVmReplicationCapability struct {
	DynamicData

	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// A string representing the current `QuiesceMode_enum` of the virtual machine.
	SupportedQuiesceMode string `xml:"supportedQuiesceMode" json:"supportedQuiesceMode"`
	// Flag indicating compression support on the host on which this virtual
	// machine is running.
	CompressionSupported bool `xml:"compressionSupported" json:"compressionSupported"`
	// Maximum disk size supported (in bytes) on the host on which this virtual
	// machine is running.
	MaxSupportedSourceDiskCapacity int64 `xml:"maxSupportedSourceDiskCapacity" json:"maxSupportedSourceDiskCapacity"`
	// Minimum rpo supported (in minutes) on the host on which this virtual
	// machine is running.
	MinRpo int64 `xml:"minRpo,omitempty" json:"minRpo,omitempty"`
	// If we are unable to find the VM, we would set this to NotFound fault.
	//
	// And, if we are unable to find the host for a given VM, then we would
	// set this to HostNotReachable fault.
	// Unset if we are able to fetch the capabilities for the VM.
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["HbrManagerVmReplicationCapability"] = reflect.TypeOf((*HbrManagerVmReplicationCapability)(nil)).Elem()
}

// Event used to report change in health status of VirtualCenter components.
type HealthStatusChangedEvent struct {
	Event

	// Unique ID of the VirtualCenter component.
	ComponentId string `xml:"componentId" json:"componentId"`
	// Previous health status of the component.
	OldStatus string `xml:"oldStatus" json:"oldStatus"`
	// Current health status of the component.
	NewStatus string `xml:"newStatus" json:"newStatus"`
	// Component name.
	ComponentName string `xml:"componentName" json:"componentName"`
	// Service Id of component.
	ServiceId string `xml:"serviceId,omitempty" json:"serviceId,omitempty"`
}

func init() {
	t["HealthStatusChangedEvent"] = reflect.TypeOf((*HealthStatusChangedEvent)(nil)).Elem()
}

// The system health runtime information
type HealthSystemRuntime struct {
	DynamicData

	// Available system health information
	SystemHealthInfo *HostSystemHealthInfo `xml:"systemHealthInfo,omitempty" json:"systemHealthInfo,omitempty"`
	// Available hardware health information
	HardwareStatusInfo *HostHardwareStatusInfo `xml:"hardwareStatusInfo,omitempty" json:"hardwareStatusInfo,omitempty"`
}

func init() {
	t["HealthSystemRuntime"] = reflect.TypeOf((*HealthSystemRuntime)(nil)).Elem()
}

type HealthUpdate struct {
	DynamicData

	// The entity on which the health update occurred.
	//
	// Only host is supported.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// The ID of the corresponding HealthUpdateInfo.
	HealthUpdateInfoId string `xml:"healthUpdateInfoId" json:"healthUpdateInfoId"`
	// The ID of this particular HealthUpdate instance, for cross-reference
	// with HealthUpdateProvider logs.
	Id string `xml:"id" json:"id"`
	// The current health status.
	//
	// Values are of type
	// `Status`.
	Status ManagedEntityStatus `xml:"status" json:"status"`
	// A description of the physical remediation required to resolve this
	// health update.
	//
	// For example, "Replace Fan #3".
	Remediation string `xml:"remediation" json:"remediation"`
}

func init() {
	t["HealthUpdate"] = reflect.TypeOf((*HealthUpdate)(nil)).Elem()
}

type HealthUpdateInfo struct {
	DynamicData

	// The identifier provided by the HealthUpdateProvider.
	//
	// Identifiers are
	// required to be unique per HealthUpdateProvider.
	Id string `xml:"id" json:"id"`
	// The component type.
	//
	// For supported values, see `HealthUpdateInfoComponentType_enum`
	ComponentType string `xml:"componentType" json:"componentType"`
	// A description of the change in health.
	Description string `xml:"description" json:"description"`
}

func init() {
	t["HealthUpdateInfo"] = reflect.TypeOf((*HealthUpdateInfo)(nil)).Elem()
}

// An attempt to enable Enhanced VMotion Compatibility on a cluster has failed
// because the cluster contains CPUs from more than one vendor.
type HeterogenousHostsBlockingEVC struct {
	EVCConfigFault
}

func init() {
	t["HeterogenousHostsBlockingEVC"] = reflect.TypeOf((*HeterogenousHostsBlockingEVC)(nil)).Elem()
}

type HeterogenousHostsBlockingEVCFault HeterogenousHostsBlockingEVC

func init() {
	t["HeterogenousHostsBlockingEVCFault"] = reflect.TypeOf((*HeterogenousHostsBlockingEVCFault)(nil)).Elem()
}

// Data structure describing the access mode for a user or group.
type HostAccessControlEntry struct {
	DynamicData

	// User or group having the described access mode.
	//
	// The format is "login" for local users or "DOMAIN\\login" for users
	// in a Windows domain.
	Principal string `xml:"principal" json:"principal"`
	// True if 'principal' describes a group account, false otherwise.
	Group bool `xml:"group" json:"group"`
	// Access mode for the principal.
	AccessMode HostAccessMode `xml:"accessMode" json:"accessMode"`
}

func init() {
	t["HostAccessControlEntry"] = reflect.TypeOf((*HostAccessControlEntry)(nil)).Elem()
}

// Fault thrown when an attempt is made to adjust resource settings
// directly on a host that is being managed by VC.
//
// VC is currently the
// source of truth for all resource pools on the host.
// Examples of methods affected by this are:
//   - create respool
//   - update respool
//   - change VM resource settings.
type HostAccessRestrictedToManagementServer struct {
	NotSupported

	// Name/IP of the server currently managing this host.
	ManagementServer string `xml:"managementServer" json:"managementServer"`
}

func init() {
	t["HostAccessRestrictedToManagementServer"] = reflect.TypeOf((*HostAccessRestrictedToManagementServer)(nil)).Elem()
}

type HostAccessRestrictedToManagementServerFault HostAccessRestrictedToManagementServer

func init() {
	t["HostAccessRestrictedToManagementServerFault"] = reflect.TypeOf((*HostAccessRestrictedToManagementServerFault)(nil)).Elem()
}

// This data object type contains common parameters
// for local account creation.
//
// The password and description properties
// are not supported for group accounts on POSIX hosts.
type HostAccountSpec struct {
	DynamicData

	// The ID of the specified account.
	Id string `xml:"id" json:"id"`
	// The password for a user or group.
	Password string `xml:"password,omitempty" json:"password,omitempty"`
	// The description of the specified account.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
}

func init() {
	t["HostAccountSpec"] = reflect.TypeOf((*HostAccountSpec)(nil)).Elem()
}

// The `HostActiveDirectory` data object contains
// Active Directory configuration information for an ESX host.
//
// The vSphere API supports Microsoft Active Directory management
// of authentication for ESX hosts. To integrate an ESX host
// into an Active Directory environment, you use an Active Directory
// account that has the authority to add a computer to a domain.
// The ESX Server locates the Active Directory domain controller.
// When you use the host profile to configure authentication
// for an ESX host, you specify the configuration operation (add or remove).
// To add the host to a domain, specify
// the domain, and the authorized Active Directory account user name and password.
// You do not need to specify these parameters to remove the host from a domain
// because the host has the information it needs to perform the operation.
// When you call `HostProfileManager.ApplyHostConfig_Task`
// to apply the configuration, the ESX Server will call the appropriate
// method (`HostActiveDirectoryAuthentication.JoinDomain_Task`
// or `HostActiveDirectoryAuthentication.LeaveCurrentDomain_Task`)
// on your behalf.
//
// Before you call the method to apply the host profile, check to see that the
// `HostAuthenticationManager*.*HostAuthenticationManager.supportedStore`
// array contains a `HostActiveDirectoryAuthentication` object.
// The presence of the Active Directory authentication object indicates
// that a host is capable of joining a domain.
// However, if you try to add a host to a domain when the
// `HostAuthenticationStoreInfo*.*HostAuthenticationStoreInfo.enabled`
// property is <code>True</code>, the join method will throw a fault.
//
// As an alternative to using the host profile to configure Active Directory
// authentication for an ESX host, your vSphere client application can call
// the `HostActiveDirectoryAuthentication` join and leave methods directly
// to add the host to or remove the host from a domain.
//
// To take advantage of ESX host membership in an Active Directory domain,
// grant permissions on the ESX host to users and groups in Active Directory
// who should have direct access to management of the ESX host.
// Use the `UserDirectory*.*UserDirectory.RetrieveUserGroups`
// method to obtain information about Active Directory users and groups.
// After retrieving the Active Directory data, you can use the
// `AuthorizationManager*.*AuthorizationManager.SetEntityPermissions`
// method to set the `Permission.principal` property
// to the appropriate user or group.
//
// By default, the ESX host assigns the Administrator role to the "ESX Admins" group.
// If the group does not exist when the host joins the domain, the host will
// not assign the role. In this case, you must create the "ESX Admins"
// group in the Active Directory. The host will periodically check the domain controller
// for the group and will assign the role when the group exists.
type HostActiveDirectory struct {
	DynamicData

	// Configuration change operation to apply to the host.
	//
	// You can specify
	// the following values:
	//   - `add`:
	//     Add the host to the domain. The ESX Server will use the
	//     `HostActiveDirectorySpec` information
	//     (domain, account user name and password) to call
	//     `HostActiveDirectoryAuthentication.JoinDomain_Task` and optionally
	//     configure smart card authentication by calling
	//     `HostActiveDirectoryAuthentication.DisableSmartCardAuthentication`
	//     and replacing the trust anchors with those provided.
	//   - `remove`:
	//     Remove the host from its current domain.
	//     The ESX Server will call
	//     `HostActiveDirectoryAuthentication.LeaveCurrentDomain_Task`, specifying
	//     <code>True</code> for the <code>force</code> parameter to delete
	//     existing permissions.
	//     `HostActiveDirectoryAuthentication.DisableSmartCardAuthentication`
	//     is also called if smart card authentication is enabled and trust
	//     anchors are removed.
	//
	// See also `HostConfigChangeOperation_enum`.
	ChangeOperation string `xml:"changeOperation" json:"changeOperation"`
	// Active Directory domain access information (domain and account
	// user name and password).
	Spec *HostActiveDirectorySpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["HostActiveDirectory"] = reflect.TypeOf((*HostActiveDirectory)(nil)).Elem()
}

// The `HostActiveDirectoryInfo` data object describes ESX host
// membership in an Active Directory domain.
//
// If the
// `HostAuthenticationStoreInfo*.*HostAuthenticationStoreInfo.enabled`
// property is <code>True</code>, the host is a member of a domain
// and the ESX Server will set the domain information properties.
type HostActiveDirectoryInfo struct {
	HostDirectoryStoreInfo

	// The domain that this host joined.
	JoinedDomain string `xml:"joinedDomain,omitempty" json:"joinedDomain,omitempty"`
	// List of domains with which the <code>joinedDomain</code> has a trust.
	//
	// The <code>joinedDomain</code> is not included in the
	// <code>trustedDomain</code> list.
	TrustedDomain []string `xml:"trustedDomain,omitempty" json:"trustedDomain,omitempty"`
	// Health information about the domain membership.
	//
	// See `HostActiveDirectoryInfoDomainMembershipStatus_enum`.
	DomainMembershipStatus string `xml:"domainMembershipStatus,omitempty" json:"domainMembershipStatus,omitempty"`
	// Deprecated as of vSphere API 8.0U3, and there is no replacement for it.
	//
	// Whether local smart card authentication is enabled.
	SmartCardAuthenticationEnabled *bool `xml:"smartCardAuthenticationEnabled" json:"smartCardAuthenticationEnabled,omitempty"`
}

func init() {
	t["HostActiveDirectoryInfo"] = reflect.TypeOf((*HostActiveDirectoryInfo)(nil)).Elem()
}

// The `HostActiveDirectorySpec` data object defines
// properties for Active Directory domain access.
type HostActiveDirectorySpec struct {
	DynamicData

	// Domain name.
	DomainName string `xml:"domainName,omitempty" json:"domainName,omitempty"`
	// Name of an Active Directory account with the authority
	// to add a host to the domain.
	UserName string `xml:"userName,omitempty" json:"userName,omitempty"`
	// Password for the Active Directory account.
	Password string `xml:"password,omitempty" json:"password,omitempty"`
	// If set, the CAM server will be used to join the domain
	// and the <code>userName</code> and <code>password</code> fields
	// will be ignored.
	CamServer string `xml:"camServer,omitempty" json:"camServer,omitempty"`
	// Thumbprint for the SSL certficate of CAM server
	Thumbprint string `xml:"thumbprint,omitempty" json:"thumbprint,omitempty"`
	// PEM-encoded certificate of the CAM server
	// This field replaces `HostActiveDirectorySpec.thumbprint`.
	//
	// If both `HostActiveDirectorySpec.thumbprint`
	// and `HostActiveDirectorySpec.certificate` fields are set, the `HostActiveDirectorySpec.thumbprint`
	// should match the `HostActiveDirectorySpec.certificate`.
	Certificate string `xml:"certificate,omitempty" json:"certificate,omitempty" vim:"8.0.3.0"`
	// Deprecated as of vSphere API 8.0U3, and there is no replacement for it.
	//
	// Support smart card authentication of local users.
	SmartCardAuthenticationEnabled *bool `xml:"smartCardAuthenticationEnabled" json:"smartCardAuthenticationEnabled,omitempty"`
	// Deprecated as of vSphere API 8.0U3, and there is no replacement for it.
	//
	// Trusted root certificates for smart cards.
	SmartCardTrustAnchors []string `xml:"smartCardTrustAnchors,omitempty" json:"smartCardTrustAnchors,omitempty"`
}

func init() {
	t["HostActiveDirectorySpec"] = reflect.TypeOf((*HostActiveDirectorySpec)(nil)).Elem()
}

// This event records that adding a host failed.
type HostAddFailedEvent struct {
	HostEvent

	Hostname string `xml:"hostname" json:"hostname"`
}

func init() {
	t["HostAddFailedEvent"] = reflect.TypeOf((*HostAddFailedEvent)(nil)).Elem()
}

// This event records the addition of a host to VirtualCenter.
type HostAddedEvent struct {
	HostEvent
}

func init() {
	t["HostAddedEvent"] = reflect.TypeOf((*HostAddedEvent)(nil)).Elem()
}

// This event records that the permission on the host has been changed such
// that only the user account used for VirtualCenter operation will have
// Administrator permission.
type HostAdminDisableEvent struct {
	HostEvent
}

func init() {
	t["HostAdminDisableEvent"] = reflect.TypeOf((*HostAdminDisableEvent)(nil)).Elem()
}

// This event records that the administrator permission has been restored.
type HostAdminEnableEvent struct {
	HostEvent
}

func init() {
	t["HostAdminEnableEvent"] = reflect.TypeOf((*HostAdminEnableEvent)(nil)).Elem()
}

// The `HostApplyProfile` data object provides access to subprofiles
// that contain configuration data for different host capabilities.
//
// The Profile Engine will use any configuration data that you supply
// to overwrite the host configuration. See the `HostProfile.ExecuteHostProfile`
// and `HostProfileManager.ApplyHostConfig_Task` methods.
type HostApplyProfile struct {
	ApplyProfile

	// Memory configuration for the host.
	//
	// This may not be valid for all versions of the host.
	Memory *HostMemoryProfile `xml:"memory,omitempty" json:"memory,omitempty"`
	// Host storage configuration.
	Storage *StorageProfile `xml:"storage,omitempty" json:"storage,omitempty"`
	// Network configuration.
	Network *NetworkProfile `xml:"network,omitempty" json:"network,omitempty"`
	// Date and time configuration.
	Datetime *DateTimeProfile `xml:"datetime,omitempty" json:"datetime,omitempty"`
	// Firewall configuration.
	Firewall *FirewallProfile `xml:"firewall,omitempty" json:"firewall,omitempty"`
	// Security Configuration of the host.
	//
	// The security subprofile can include data such as administrator passwords.
	Security *SecurityProfile `xml:"security,omitempty" json:"security,omitempty"`
	// Host configuration for services.
	//
	// Use the `ServiceProfile.key` property
	// to access a subprofile in the list.
	Service []ServiceProfile `xml:"service,omitempty" json:"service,omitempty"`
	// List of subprofiles representing advanced configuration options.
	//
	// Use the `OptionProfile.key` property to access a subprofile
	// in the list.
	Option []OptionProfile `xml:"option,omitempty" json:"option,omitempty"`
	// List of subprofiles for user accounts to be configured on the host.
	//
	// Use the `UserProfile.key` property to access a subprofile
	// in the list.
	UserAccount []UserProfile `xml:"userAccount,omitempty" json:"userAccount,omitempty"`
	// List of subprofiles for user groups to be configured on the host.
	//
	// Use the `UserGroupProfile.key` property to access a subprofile
	// in the list.
	UsergroupAccount []UserGroupProfile `xml:"usergroupAccount,omitempty" json:"usergroupAccount,omitempty"`
	// Authentication Configuration.
	Authentication *AuthenticationProfile `xml:"authentication,omitempty" json:"authentication,omitempty"`
}

func init() {
	t["HostApplyProfile"] = reflect.TypeOf((*HostApplyProfile)(nil)).Elem()
}

// Data object indicating a device instance has been allocated to a VM.
type HostAssignableHardwareBinding struct {
	DynamicData

	// Instance ID of assigned device.
	InstanceId string `xml:"instanceId" json:"instanceId"`
	// Virtual machine to which the device is assigned.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
}

func init() {
	t["HostAssignableHardwareBinding"] = reflect.TypeOf((*HostAssignableHardwareBinding)(nil)).Elem()
}

// The AssignableHardwareConfig data object describes properties
// of all assignable devices on the host.
type HostAssignableHardwareConfig struct {
	DynamicData

	// List of attribute overrides.
	AttributeOverride []HostAssignableHardwareConfigAttributeOverride `xml:"attributeOverride,omitempty" json:"attributeOverride,omitempty"`
}

func init() {
	t["HostAssignableHardwareConfig"] = reflect.TypeOf((*HostAssignableHardwareConfig)(nil)).Elem()
}

// An AttributeOverride provides a name-value pair that overrides
// for a particular instance node a configurable Attribute defined
// by that device.
type HostAssignableHardwareConfigAttributeOverride struct {
	DynamicData

	// Instance ID of the Assignable Hardware instance node where
	// the attribute specified by name is overridden.
	InstanceId string `xml:"instanceId" json:"instanceId"`
	// Name of attribute to override.
	Name string `xml:"name" json:"name"`
	// When AssignableHardwareConfig is a returned data object:
	// Value returned will always be set.
	//
	// When AssignableHardwareConfig is used as a parameter to
	// an operation updating Assignable Hardware configuration:
	// If value is set, an existing AttributeOverride with matching
	// instanceId and name will have its value updated; if there is
	// no existing AttributeOverride that matches, a new
	// AttributeOverride is created. The type of the value must match
	// the type of the attribute value being overridden.
	// If value is not set, an existing AttributeOverride matching
	// the specified instanceId and name is deleted.
	Value AnyType `xml:"value,typeattr" json:"value"`
}

func init() {
	t["HostAssignableHardwareConfigAttributeOverride"] = reflect.TypeOf((*HostAssignableHardwareConfigAttributeOverride)(nil)).Elem()
}

// The `HostAuthenticationManagerInfo` data object provides
// access to authentication information for the ESX host.
type HostAuthenticationManagerInfo struct {
	DynamicData

	// An array containing entries for local authentication and host
	// Active Directory authentication.
	//   - `HostLocalAuthenticationInfo` - Local authentication is always enabled.
	//   - `HostActiveDirectoryInfo` - Host Active Directory authentication information
	//     includes the name of the domain, membership status,
	//     and a list of other domains trusted by the membership domain.
	AuthConfig []BaseHostAuthenticationStoreInfo `xml:"authConfig,typeattr" json:"authConfig"`
}

func init() {
	t["HostAuthenticationManagerInfo"] = reflect.TypeOf((*HostAuthenticationManagerInfo)(nil)).Elem()
}

// The `HostAuthenticationStoreInfo` base class defines status information
// for local and host Active Directory authentication.
type HostAuthenticationStoreInfo struct {
	DynamicData

	// Indicates whether the authentication store is configured.
	//   - Host Active Directory authentication - <code>enabled</code>
	//     is <code>True</code> if the host is a member of a domain.
	//   - Local authentication - <code>enabled</code> is always <code>True</code>.
	Enabled bool `xml:"enabled" json:"enabled"`
}

func init() {
	t["HostAuthenticationStoreInfo"] = reflect.TypeOf((*HostAuthenticationStoreInfo)(nil)).Elem()
}

// Contains the entire auto-start/auto-stop configuration.
type HostAutoStartManagerConfig struct {
	DynamicData

	// System defaults for auto-start/auto-stop.
	Defaults *AutoStartDefaults `xml:"defaults,omitempty" json:"defaults,omitempty"`
	// Lists the auto-start/auto-stop configuration.
	//
	// If a virtual machine is not
	// mentioned in this array, it does not participate in auto-start/auto-stop
	// operations.
	PowerInfo []AutoStartPowerInfo `xml:"powerInfo,omitempty" json:"powerInfo,omitempty"`
}

func init() {
	t["HostAutoStartManagerConfig"] = reflect.TypeOf((*HostAutoStartManagerConfig)(nil)).Elem()
}

type HostBIOSInfo struct {
	DynamicData

	// The current BIOS version of the physical chassis
	BiosVersion string `xml:"biosVersion,omitempty" json:"biosVersion,omitempty"`
	// The release date for the BIOS.
	ReleaseDate *time.Time `xml:"releaseDate" json:"releaseDate,omitempty"`
	// The vendor for the BIOS.
	Vendor string `xml:"vendor,omitempty" json:"vendor,omitempty"`
	// BIOS Major Release
	MajorRelease int32 `xml:"majorRelease,omitempty" json:"majorRelease,omitempty"`
	// "BIOS Minor Release
	MinorRelease         int32 `xml:"minorRelease,omitempty" json:"minorRelease,omitempty"`
	FirmwareMajorRelease int32 `xml:"firmwareMajorRelease,omitempty" json:"firmwareMajorRelease,omitempty"`
	// Embedded Controller Firmware Minor Release
	FirmwareMinorRelease int32 `xml:"firmwareMinorRelease,omitempty" json:"firmwareMinorRelease,omitempty"`
	// Firmware Type of the host.
	//
	// The set of supported values is described
	// in `HostBIOSInfoFirmwareType_enum`
	FirmwareType string `xml:"firmwareType,omitempty" json:"firmwareType,omitempty" vim:"8.0.2.0"`
}

func init() {
	t["HostBIOSInfo"] = reflect.TypeOf((*HostBIOSInfo)(nil)).Elem()
}

// Block adapter transport information about a SCSI target.
type HostBlockAdapterTargetTransport struct {
	HostTargetTransport
}

func init() {
	t["HostBlockAdapterTargetTransport"] = reflect.TypeOf((*HostBlockAdapterTargetTransport)(nil)).Elem()
}

// This data object type describes the host bus adapter that
// provides block devices.
type HostBlockHba struct {
	HostHostBusAdapter
}

func init() {
	t["HostBlockHba"] = reflect.TypeOf((*HostBlockHba)(nil)).Elem()
}

// The `HostBootDevice` data object represents a boot device on the host system.
type HostBootDevice struct {
	DynamicData

	// The identifier for the boot device.
	Key string `xml:"key" json:"key"`
	// The description of the boot device.
	Description string `xml:"description" json:"description"`
}

func init() {
	t["HostBootDevice"] = reflect.TypeOf((*HostBootDevice)(nil)).Elem()
}

// This data object represents the boot device information of the host.
type HostBootDeviceInfo struct {
	DynamicData

	// The list of boot devices present on the host
	BootDevices []HostBootDevice `xml:"bootDevices,omitempty" json:"bootDevices,omitempty"`
	// The key of the current boot device that the host is configured to
	// boot.
	//
	// This property is unset if the current boot device is disabled.
	CurrentBootDeviceKey string `xml:"currentBootDeviceKey,omitempty" json:"currentBootDeviceKey,omitempty"`
}

func init() {
	t["HostBootDeviceInfo"] = reflect.TypeOf((*HostBootDeviceInfo)(nil)).Elem()
}

// Host solid state drive cache configuration information.
type HostCacheConfigurationInfo struct {
	DynamicData

	// Datastore used for swap performance enhancements.
	//
	// Refers instance of `Datastore`.
	Key ManagedObjectReference `xml:"key" json:"key"`
	// Space allocated on this datastore to implement swap performance
	// enhancements, in MB.
	SwapSize int64 `xml:"swapSize" json:"swapSize"`
}

func init() {
	t["HostCacheConfigurationInfo"] = reflect.TypeOf((*HostCacheConfigurationInfo)(nil)).Elem()
}

// Host cache configuration specification.
type HostCacheConfigurationSpec struct {
	DynamicData

	// Datastore used for swap performance enhancement.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// Space to allocate on this datastore to implement swap performance
	// enhancements, in MB.
	//
	// This value should be less or equal to free space
	// capacity on the datastore `DatastoreSummary.freeSpace`.
	SwapSize int64 `xml:"swapSize" json:"swapSize"`
}

func init() {
	t["HostCacheConfigurationSpec"] = reflect.TypeOf((*HostCacheConfigurationSpec)(nil)).Elem()
}

// Specifies the capabilities of the particular host.
//
// This set of
// capabilities is referenced in other parts of the API specification
// to indicate under what circumstances an API will throw a
// `NotSupported` fault.
type HostCapability struct {
	DynamicData

	RecursiveResourcePoolsSupported bool `xml:"recursiveResourcePoolsSupported" json:"recursiveResourcePoolsSupported"`
	// Flag indicating whether cpu and memory resource configuration is
	// supported.
	//
	// If this is set to false,
	// `ResourcePool.UpdateConfig`,
	// `ResourcePool.UpdateChildResourceConfiguration`
	// cannot be used for changing the cpu/memory resource configurations.
	CpuMemoryResourceConfigurationSupported bool `xml:"cpuMemoryResourceConfigurationSupported" json:"cpuMemoryResourceConfigurationSupported"`
	// Flag indicating whether rebooting the host is supported.
	RebootSupported bool `xml:"rebootSupported" json:"rebootSupported"`
	// Flag indicating whether the host can be powered off
	ShutdownSupported bool `xml:"shutdownSupported" json:"shutdownSupported"`
	// Flag indicating whether you can perform VMotion.
	VmotionSupported bool `xml:"vmotionSupported" json:"vmotionSupported"`
	// Flag indicating whether you can put the host in a power down
	// state, from which it can be powered up automatically.
	StandbySupported bool `xml:"standbySupported" json:"standbySupported"`
	// Flag indicating whether the host supports
	// IPMI (Intelligent Platform Management Interface).
	//
	// XXX - Make ipmiSupported optional until there is a compatible hostagent.
	IpmiSupported *bool `xml:"ipmiSupported" json:"ipmiSupported,omitempty"`
	// The maximum number of virtual machines that can exist on this host.
	//
	// If this capability is not set, the number of virtual machines is
	// unlimited.
	MaxSupportedVMs int32 `xml:"maxSupportedVMs,omitempty" json:"maxSupportedVMs,omitempty"`
	// The maximum number of virtual machines that can be running
	// simultaneously on this host.
	//
	// If this capability is not set, the number of virtual machines
	// running simultaneously is unlimited.
	MaxRunningVMs int32 `xml:"maxRunningVMs,omitempty" json:"maxRunningVMs,omitempty"`
	// The maximum number of virtual CPUs supported per virtual machine.
	//
	// If this capability is not set, the number is unlimited.
	MaxSupportedVcpus int32 `xml:"maxSupportedVcpus,omitempty" json:"maxSupportedVcpus,omitempty"`
	// The maximum number of registered virtual machines supported by
	// the host.
	//
	// If this limit is exceeded, the management agent will be
	// at risk of running out of system resources. `configIssue` will be posted on
	// `HostSystem` in this case.
	//
	// If this capability is not set, the number is unknown.
	MaxRegisteredVMs int32 `xml:"maxRegisteredVMs,omitempty" json:"maxRegisteredVMs,omitempty"`
	// Flag indicating whether datastore principal user
	// is supported on the host.
	DatastorePrincipalSupported bool `xml:"datastorePrincipalSupported" json:"datastorePrincipalSupported"`
	// Flag indicating whether access to SAN devices is supported.
	SanSupported bool `xml:"sanSupported" json:"sanSupported"`
	// Is access to NFS devices supported.
	NfsSupported bool `xml:"nfsSupported" json:"nfsSupported"`
	// Is access to iSCSI devices supported.
	IscsiSupported bool `xml:"iscsiSupported" json:"iscsiSupported"`
	// Is VLAN Tagging supported.
	VlanTaggingSupported bool `xml:"vlanTaggingSupported" json:"vlanTaggingSupported"`
	// Is NIC teaming supported.
	NicTeamingSupported bool `xml:"nicTeamingSupported" json:"nicTeamingSupported"`
	// Is high guest memory supported.
	HighGuestMemSupported bool `xml:"highGuestMemSupported" json:"highGuestMemSupported"`
	// Is maintenance mode supported
	MaintenanceModeSupported bool `xml:"maintenanceModeSupported" json:"maintenanceModeSupported"`
	// Indicates whether this host supports relocation of
	// suspended virtual machines.
	//
	// Must be true on the source
	// and destination hosts for the relocation to work.
	SuspendedRelocateSupported bool `xml:"suspendedRelocateSupported" json:"suspendedRelocateSupported"`
	// Indicates whether this host supports relocation of
	// virtual machines with snapshots.
	//
	// Must be true on the
	// source and destination hosts for the relocation to work.
	// Even if this is true, the following conditions must hold:
	// 1\) All the the vm's files are in one directory prior
	// to the relocate.
	// 2\) All of the vm's files will be in one directory
	// after the relocate.
	// 3\) The source and destination hosts are the same product
	// version.
	RestrictedSnapshotRelocateSupported bool `xml:"restrictedSnapshotRelocateSupported" json:"restrictedSnapshotRelocateSupported"`
	// Flag indicating whether virtual machine execution on this host involves
	// a swapfile for each virtual machine.
	//
	// If true, the swapfile placement
	// for a powered-on virtual machine is advertised in its FileLayout by
	// the `swapFile` property.
	PerVmSwapFiles bool `xml:"perVmSwapFiles" json:"perVmSwapFiles"`
	// Flag indicating whether the host supports selecting a datastore that
	// that may be used to store virtual machine swapfiles.
	LocalSwapDatastoreSupported bool `xml:"localSwapDatastoreSupported" json:"localSwapDatastoreSupported"`
	// Flag indicating whether the host supports participating in a VMotion
	// where the virtual machine swapfile is not visible to the destination.
	UnsharedSwapVMotionSupported bool `xml:"unsharedSwapVMotionSupported" json:"unsharedSwapVMotionSupported"`
	// Flag indicating whether background snapshots are supported on this host.
	BackgroundSnapshotsSupported bool `xml:"backgroundSnapshotsSupported" json:"backgroundSnapshotsSupported"`
	// Flag to indicate whether the server returns unit numbers in a
	// pre-assigned range for devices on the PCI bus.
	//
	// When the server supports this flag, the device unit number namespace is
	// partitioned by device type. Different types of devices will sit in
	// a specific range of unit numbers that may not correspond to physical
	// slots in the pci bus but present a relative ordering of the devices
	// with respect to other devices of the same type.
	// Note that this does not mean that the user can set the relative ordering
	// between device types, but only allows stable orderings between devices
	// of the same type. The unit number will now clearly represent an ordering
	// between devices of the same type.
	// `VirtualDevice.unitNumber`
	// This property is only available for devices on the pci controller.
	PreAssignedPCIUnitNumbersSupported bool `xml:"preAssignedPCIUnitNumbersSupported" json:"preAssignedPCIUnitNumbersSupported"`
	// Indicates whether the screenshot retrival over https is supported for this host's
	// virtual machines.
	//
	// If true, a screenshot can be retrieved at the HTTPS relative path
	// _/screen?id=&lt;managed object ID of virtual machine or snapshot&gt;_.
	// If any of the optional parameters 'top', 'left', 'bottom', and 'right' is
	// specified, the returned image will be cropped from the rectangle with upper left
	// corner (left, top) and bottom right corner (right - 1, bottom - 1). These values
	// default to the top, left, bottom and right edges of the image.
	// The client must use an authenticated session with privilege
	// VirtualMachine.Interact.ConsoleInteract on the requested virtual machine or,
	// in the case of a snapshot, the virtual machine associated with that snapshot.
	ScreenshotSupported bool `xml:"screenshotSupported" json:"screenshotSupported"`
	// Indicates whether scaling is supported for screenshots retrieved over https.
	//
	// If true, screenshot retrieval supports the additional optional
	// parameters 'width' and 'height'. After cropping, the returned image will be scaled
	// to these dimensions. If only one of these parameters is specified, default behavior
	// is to return an image roughly proportional to the source image.
	ScaledScreenshotSupported bool `xml:"scaledScreenshotSupported" json:"scaledScreenshotSupported"`
	// Indicates whether the storage of a powered-on virtual machine may be
	// relocated.
	StorageVMotionSupported *bool `xml:"storageVMotionSupported" json:"storageVMotionSupported,omitempty"`
	// Indicates whether the storage of a powered-on virtual machine may be
	// relocated while simultaneously changing the execution host of the
	// virtual machine.
	VmotionWithStorageVMotionSupported *bool `xml:"vmotionWithStorageVMotionSupported" json:"vmotionWithStorageVMotionSupported,omitempty"`
	// Indicates whether the network of a powered-on virtual machine can be
	// changed while simultaneously changing the execution host of the
	// virtual machine.
	VmotionAcrossNetworkSupported *bool `xml:"vmotionAcrossNetworkSupported" json:"vmotionAcrossNetworkSupported,omitempty"`
	// Maximum number of migrating disks allowed of a migrating VM during SVMotion.
	//
	// If this capability is not set, then the maximum is considered to be 64.
	MaxNumDisksSVMotion int32 `xml:"maxNumDisksSVMotion,omitempty" json:"maxNumDisksSVMotion,omitempty"`
	// Maximum version of vDiskVersion supported by this host.
	//
	// If this capability is not set, then the maximum is considered to be 6.
	MaxVirtualDiskDescVersionSupported int32 `xml:"maxVirtualDiskDescVersionSupported,omitempty" json:"maxVirtualDiskDescVersionSupported,omitempty" vim:"8.0.1.0"`
	// Indicates whether a dedicated nic can be selected for vSphere Replication
	// LWD traffic, i.e., from the primary host to the VR server.
	HbrNicSelectionSupported *bool `xml:"hbrNicSelectionSupported" json:"hbrNicSelectionSupported,omitempty"`
	// Indicates whether a dedicated nic can be selected for vSphere Replication
	// NFC traffic, i.e., from the VR server to the secondary host.
	VrNfcNicSelectionSupported *bool `xml:"vrNfcNicSelectionSupported" json:"vrNfcNicSelectionSupported,omitempty"`
	// Deprecated as of vSphere API 6.0.
	//
	// Indicates whether this host supports record and replay
	RecordReplaySupported *bool `xml:"recordReplaySupported" json:"recordReplaySupported,omitempty"`
	// Deprecated as of vSphere API 6.0.
	//
	// Indicates whether this host supports Fault Tolerance
	// There can be many reasons why a host does not support Fault
	// Tolerance, which includes CPU compatibility, product
	// compatibility as well as other host configuration settings.
	//
	// For specific reasons, look into
	// `HostCapability.replayCompatibilityIssues` and
	// `HostCapability.ftCompatibilityIssues`
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	FtSupported *bool `xml:"ftSupported" json:"ftSupported,omitempty"`
	// Deprecated as of vSphere API 4.1, use
	// `HostCapability.replayCompatibilityIssues`.
	//
	// For a host whose CPU doesn't support replay, indicates the reason
	// for the incompatibility.
	//
	// `HostReplayUnsupportedReason_enum`
	// represents the set of possible values.
	ReplayUnsupportedReason string `xml:"replayUnsupportedReason,omitempty" json:"replayUnsupportedReason,omitempty"`
	// Deprecated as of vSphere API 6.0.
	//
	// For a host which doesn't support replay, indicates all the reasons
	// for the incompatibility.
	//
	// `HostReplayUnsupportedReason_enum`
	// lists the set of possible values.
	ReplayCompatibilityIssues []string `xml:"replayCompatibilityIssues,omitempty" json:"replayCompatibilityIssues,omitempty"`
	// Indicates whether this host supports smp fault tolerance
	SmpFtSupported *bool `xml:"smpFtSupported" json:"smpFtSupported,omitempty"`
	// Deprecated as of vSphere API 6.0.
	//
	// For a host which doesn't support Fault Tolerance, indicates all the reasons
	// for the incompatibility.
	//
	// `HostCapabilityFtUnsupportedReason_enum`
	// lists the set of possible values.
	FtCompatibilityIssues []string `xml:"ftCompatibilityIssues,omitempty" json:"ftCompatibilityIssues,omitempty"`
	// For a host which doesn't support smp fault tolerance, indicates all the
	// reasons for the incompatibility.
	//
	// `HostCapabilityFtUnsupportedReason_enum` lists the set of possible
	// values.
	SmpFtCompatibilityIssues []string `xml:"smpFtCompatibilityIssues,omitempty" json:"smpFtCompatibilityIssues,omitempty"`
	// The maximum number of vCPUs allowed for a fault-tolerant virtual machine.
	MaxVcpusPerFtVm int32 `xml:"maxVcpusPerFtVm,omitempty" json:"maxVcpusPerFtVm,omitempty"`
	// Flag indicating whether this host supports SSL thumbprint authentication
	LoginBySSLThumbprintSupported *bool `xml:"loginBySSLThumbprintSupported" json:"loginBySSLThumbprintSupported,omitempty"`
	// Indicates whether or not cloning a virtual machine from a snapshot
	// point is allowed.
	//
	// This property must be true on the host where the virtual machine
	// is currently residing. This property need not be true on the
	// destination host for the clone.
	//
	// See also `VirtualMachineCloneSpec.snapshot`.
	CloneFromSnapshotSupported *bool `xml:"cloneFromSnapshotSupported" json:"cloneFromSnapshotSupported,omitempty"`
	// Flag indicating whether explicitly creating arbirary configurations of
	// delta disk backings is supported.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time. A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent). After a delta
	// disk backing is added, all writes go to the delta disk backing. All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// If this property is false, then delta disk backings can only be implicitly
	// created through using snapshot operations and two virtual machines cannot
	// safely share a parent disk backing.
	//
	// If this property is true, then delta disk backings can be explicitly created
	// and managed, and two virtual machines may safely share a parent disk backing.
	//
	// In the context above, "safely" means that performing operations on one of the
	// virtual machines will not affect the operation of the other virtual machine.
	//
	// See also `VirtualDiskSparseVer1BackingInfo.parent`, `VirtualDiskSparseVer2BackingInfo.parent`, `VirtualDiskFlatVer1BackingInfo.parent`, `VirtualDiskFlatVer2BackingInfo.parent`, `VirtualDiskRawDiskMappingVer1BackingInfo.parent`, `VirtualMachine.PromoteDisks_Task`, `VirtualMachineRelocateSpec.diskMoveType`, `VirtualMachineRelocateSpecDiskLocator.diskMoveType`.
	DeltaDiskBackingsSupported *bool `xml:"deltaDiskBackingsSupported" json:"deltaDiskBackingsSupported,omitempty"`
	// Indicates whether network traffic shaping on a
	// per virtual machine basis is supported.
	PerVMNetworkTrafficShapingSupported *bool `xml:"perVMNetworkTrafficShapingSupported" json:"perVMNetworkTrafficShapingSupported,omitempty"`
	// Flag indicating whether this host supports the integrity measurement using
	// a TPM device.
	TpmSupported *bool `xml:"tpmSupported" json:"tpmSupported,omitempty"`
	// TPM version if supported by this host.
	TpmVersion string `xml:"tpmVersion,omitempty" json:"tpmVersion,omitempty"`
	// Flag indicating whether Intel TXT is enabled on this host.
	//
	// TPM attestation may be used to definitively determine the Intel TXT
	// Measured Launch Environment (MLE) details.
	TxtEnabled *bool `xml:"txtEnabled" json:"txtEnabled,omitempty"`
	// Deprecated as of vSphere API 6.5 use
	// `featureCapability`.
	//
	// CPU feature set that is supported by the virtualization platform.
	//
	// This
	// feature set may reflect characteristics of the product capabilities and
	// licensing. For any feature marked '-', reference the
	// `cpuFeature` array of the host's
	// HardwareInfo to determine the correct value.
	SupportedCpuFeature []HostCpuIdInfo `xml:"supportedCpuFeature,omitempty" json:"supportedCpuFeature,omitempty"`
	// Indicates whether the host supports configuring hardware
	// virtualization (HV) support for virtual machines.
	VirtualExecUsageSupported *bool `xml:"virtualExecUsageSupported" json:"virtualExecUsageSupported,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Indicates whether the host supports storage I/O resource
	// management.
	StorageIORMSupported *bool `xml:"storageIORMSupported" json:"storageIORMSupported,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
	// there is no replacement.
	//
	// Indicates whether the host supports network passthrough using
	// VMDirectPath Gen 2.
	//
	// Note that this is a general capability for the host
	// and is independent of support by a given physical NIC. If false, the
	// reason(s) for lack of support will be provided in
	// `HostCapability.vmDirectPathGen2UnsupportedReason` and/or in
	// `HostCapability.vmDirectPathGen2UnsupportedReasonExtended`.
	//
	// See also `PhysicalNic.vmDirectPathGen2Supported`.
	VmDirectPathGen2Supported *bool `xml:"vmDirectPathGen2Supported" json:"vmDirectPathGen2Supported,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
	// there is no replacement.
	//
	// If `HostCapability.vmDirectPathGen2Supported` is false, this array will be
	// populated with reasons for the lack of support (chosen from
	// `HostCapabilityVmDirectPathGen2UnsupportedReason_enum`).
	//
	// If there is a reason for
	// the lack of support that cannot be described by the available constants,
	// `HostCapability.vmDirectPathGen2UnsupportedReasonExtended` will be populated
	// with an additional explanation provided by the platform.
	//
	// Note that this list of reasons is not guaranteed to be exhaustive.
	//
	// If the reason "hostNptIncompatibleProduct" is provided, then that will
	// be the only provided reason, as the host software is incapable of
	// providing additional information.
	VmDirectPathGen2UnsupportedReason []string `xml:"vmDirectPathGen2UnsupportedReason,omitempty" json:"vmDirectPathGen2UnsupportedReason,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
	// there is no replacement.
	//
	// If `HostCapability.vmDirectPathGen2Supported` is false, this property may
	// contain an explanation provided by the platform, beyond the reasons (if
	// any) enumerated in `HostCapability.vmDirectPathGen2UnsupportedReason`.
	VmDirectPathGen2UnsupportedReasonExtended string `xml:"vmDirectPathGen2UnsupportedReasonExtended,omitempty" json:"vmDirectPathGen2UnsupportedReasonExtended,omitempty"`
	// List of VMFS major versions supported by the host.
	SupportedVmfsMajorVersion []int32 `xml:"supportedVmfsMajorVersion,omitempty" json:"supportedVmfsMajorVersion,omitempty"`
	// Indicates whether the host supports vStorage Hardware
	// acceleration.
	VStorageCapable *bool `xml:"vStorageCapable" json:"vStorageCapable,omitempty"`
	// Indicates whether this host supports unrestricted relocation of virtual
	// machines with snapshots.
	//
	// Only needs to be true on the destination host for
	// the unrestricted relocation to work. The full snapshot relocation does not
	// restrict the layout of snapshot files or disks of the virtual machine, nor
	// its power state. If the virtual machine is powered on, a storage vmotion
	// will be performed to relocate its snapshots and disks.
	SnapshotRelayoutSupported *bool `xml:"snapshotRelayoutSupported" json:"snapshotRelayoutSupported,omitempty"`
	// Indicates whether this host supports ip address based restrictions in
	// the firewall configuration.
	FirewallIpRulesSupported *bool `xml:"firewallIpRulesSupported" json:"firewallIpRulesSupported,omitempty"`
	// Indicates whether this host supports package information in service
	// configuration.
	ServicePackageInfoSupported *bool `xml:"servicePackageInfoSupported" json:"servicePackageInfoSupported,omitempty"`
	// The maximum number of virtual machines that can be run on the host.
	//
	// An unset value indicates that the value could not be obtained. In contrast
	// to `HostCapability.maxRunningVMs`, this value is the minimum of (i) the maximum
	// number supported by the hardware and (ii) the maximum number permitted by
	// the host license.
	MaxHostRunningVms int32 `xml:"maxHostRunningVms,omitempty" json:"maxHostRunningVms,omitempty"`
	// The maximum number of virtual CPUs that can be run on the host.
	//
	// An unset
	// value indicates that the value could not be obtained. In contrast to
	// `HostCapability.maxSupportedVcpus`, this value is the minimum of (i) the maximum
	// number supported by the hardware and (ii) the maximum number permitted by
	// the host license.
	MaxHostSupportedVcpus int32 `xml:"maxHostSupportedVcpus,omitempty" json:"maxHostSupportedVcpus,omitempty"`
	// Indicates whether the host is capable of mounting/unmounting
	// VMFS datastores.
	VmfsDatastoreMountCapable *bool `xml:"vmfsDatastoreMountCapable" json:"vmfsDatastoreMountCapable,omitempty"`
	// Indicates whether the host is capable of accessing a VMFS disk
	// when there are eight or more hosts accessing the disk already.
	EightPlusHostVmfsSharedAccessSupported *bool `xml:"eightPlusHostVmfsSharedAccessSupported" json:"eightPlusHostVmfsSharedAccessSupported,omitempty"`
	// Indicates whether the host supports nested hardware-assisted virtualization.
	NestedHVSupported *bool `xml:"nestedHVSupported" json:"nestedHVSupported,omitempty"`
	// Indicates whether the host supports virtual CPU performance counters.
	VPMCSupported *bool `xml:"vPMCSupported" json:"vPMCSupported,omitempty"`
	// Indicates whether the host supports VMCI for communication
	// between virtual machines.
	InterVMCommunicationThroughVMCISupported *bool `xml:"interVMCommunicationThroughVMCISupported" json:"interVMCommunicationThroughVMCISupported,omitempty"`
	// Indicates whether the host supports scheduled hardware upgrades.
	//
	// See also `VirtualMachineConfigInfo.scheduledHardwareUpgradeInfo`.
	ScheduledHardwareUpgradeSupported *bool `xml:"scheduledHardwareUpgradeSupported" json:"scheduledHardwareUpgradeSupported,omitempty"`
	// Indicated whether the host supports feature capabilities
	// for EVC mode.
	FeatureCapabilitiesSupported *bool `xml:"featureCapabilitiesSupported" json:"featureCapabilitiesSupported,omitempty"`
	// Indicates whether the host supports latency sensitivity for the
	// virtual machines.
	LatencySensitivitySupported *bool `xml:"latencySensitivitySupported" json:"latencySensitivitySupported,omitempty"`
	// Indicates that host supports Object-based Storage System and
	// Storage-Profile based disk provisioning.
	StoragePolicySupported *bool `xml:"storagePolicySupported" json:"storagePolicySupported,omitempty"`
	// Indicates if 3D hardware acceleration for virtual machines is supported.
	Accel3dSupported *bool `xml:"accel3dSupported" json:"accel3dSupported,omitempty"`
	// Indicates that this host uses a reliable memory aware allocation policy.
	ReliableMemoryAware *bool `xml:"reliableMemoryAware" json:"reliableMemoryAware,omitempty"`
	// Indicates whether the host supports Multiple Instance TCP/IP stack
	MultipleNetworkStackInstanceSupported *bool `xml:"multipleNetworkStackInstanceSupported" json:"multipleNetworkStackInstanceSupported,omitempty"`
	// Indicates whether the message bus proxy is supported
	MessageBusProxySupported *bool `xml:"messageBusProxySupported" json:"messageBusProxySupported,omitempty"`
	// Indicates whether the host supports VSAN functionality.
	//
	// See also `HostVsanSystem`.
	VsanSupported *bool `xml:"vsanSupported" json:"vsanSupported,omitempty"`
	// Indicates whether the host supports vFlash.
	VFlashSupported *bool `xml:"vFlashSupported" json:"vFlashSupported,omitempty"`
	// Whether this host supports HostAccessManager for controlling direct
	// access to the host and for better lockdown mode management.
	HostAccessManagerSupported *bool `xml:"hostAccessManagerSupported" json:"hostAccessManagerSupported,omitempty"`
	// Indicates whether a dedicated nic can be selected for vSphere Provisioning
	// NFC traffic.
	ProvisioningNicSelectionSupported *bool `xml:"provisioningNicSelectionSupported" json:"provisioningNicSelectionSupported,omitempty"`
	// Whether this host supports NFS41 file systems.
	Nfs41Supported *bool `xml:"nfs41Supported" json:"nfs41Supported,omitempty"`
	// Whether this host support NFS41 Kerberos 5\* security type.
	Nfs41Krb5iSupported *bool `xml:"nfs41Krb5iSupported" json:"nfs41Krb5iSupported,omitempty"`
	// Indicates whether turning on/off local disk LED is supported
	// on the host.
	//
	// See also `HostStorageSystem.TurnDiskLocatorLedOn_Task`, `HostStorageSystem.TurnDiskLocatorLedOff_Task`.
	TurnDiskLocatorLedSupported *bool `xml:"turnDiskLocatorLedSupported" json:"turnDiskLocatorLedSupported,omitempty"`
	// Indicates whether this host supports VirtualVolume based Datastore.
	VirtualVolumeDatastoreSupported *bool `xml:"virtualVolumeDatastoreSupported" json:"virtualVolumeDatastoreSupported,omitempty"`
	// Indicates whether mark disk as SSD or Non-SSD is supported
	// on the host.
	//
	// See also `HostStorageSystem.MarkAsSsd_Task`, `HostStorageSystem.MarkAsNonSsd_Task`.
	MarkAsSsdSupported *bool `xml:"markAsSsdSupported" json:"markAsSsdSupported,omitempty"`
	// Indicates whether mark disk as local or remote is supported
	// on the host.
	//
	// See also `HostStorageSystem.MarkAsLocal_Task`, `HostStorageSystem.MarkAsNonLocal_Task`.
	MarkAsLocalSupported *bool `xml:"markAsLocalSupported" json:"markAsLocalSupported,omitempty"`
	// Deprecated as of vSphere API 8.0U3, and there is no replacement for it.
	//
	// Indicates whether this host supports local two-factor user
	// authentication using smart cards.
	//
	// See also `HostActiveDirectoryAuthentication.EnableSmartCardAuthentication`.
	SmartCardAuthenticationSupported *bool `xml:"smartCardAuthenticationSupported" json:"smartCardAuthenticationSupported,omitempty"`
	// Indicates whether this host supports persistent memory.
	//
	// If value is not specified, it should be considered as not supported.
	PMemSupported *bool `xml:"pMemSupported" json:"pMemSupported,omitempty"`
	// Indicates whether this host supports snapshots for VMs with virtual
	// devices backed by persistent memory.
	//
	// If value is not specified, it should be considered as not supported.
	PMemSnapshotSupported *bool `xml:"pMemSnapshotSupported" json:"pMemSnapshotSupported,omitempty"`
	// Flag indicating whether Cryptographer feature is supported.
	CryptoSupported *bool `xml:"cryptoSupported" json:"cryptoSupported,omitempty"`
	// Indicates whether this host supports granular datastore cache update.
	//
	// If value is not specified, it should be considered as not supported.
	OneKVolumeAPIsSupported *bool `xml:"oneKVolumeAPIsSupported" json:"oneKVolumeAPIsSupported,omitempty"`
	// Flag indicating whether default gateway can be configured on a
	// vmkernel nic.
	GatewayOnNicSupported *bool `xml:"gatewayOnNicSupported" json:"gatewayOnNicSupported,omitempty"`
	// Deprecated as of vSphere API 8.0, and there is no replacement for it.
	//
	// Indicate whether this host supports UPIT
	UpitSupported *bool `xml:"upitSupported" json:"upitSupported,omitempty"`
	// Indicates whether this host supports hardware-based MMU virtualization.
	CpuHwMmuSupported *bool `xml:"cpuHwMmuSupported" json:"cpuHwMmuSupported,omitempty"`
	// Indicates whether this host supports encrypted vMotion.
	EncryptedVMotionSupported *bool `xml:"encryptedVMotionSupported" json:"encryptedVMotionSupported,omitempty"`
	// Indicates whether this host supports changing the encryption state
	// of a virtual disk when the disk is being added or removed from a
	// virtual machine configuration.
	EncryptionChangeOnAddRemoveSupported *bool `xml:"encryptionChangeOnAddRemoveSupported" json:"encryptionChangeOnAddRemoveSupported,omitempty"`
	// Indicates whether this host supports changing the encryption state
	// of a virtual machine, or virtual disk, while the virtual machine
	// is powered on.
	EncryptionHotOperationSupported *bool `xml:"encryptionHotOperationSupported" json:"encryptionHotOperationSupported,omitempty"`
	// Indicates whether this host supports changing the encryption state
	// state of a virtual machine, or virtual disk, while the virtual
	// machine has snapshots present.
	EncryptionWithSnapshotsSupported *bool `xml:"encryptionWithSnapshotsSupported" json:"encryptionWithSnapshotsSupported,omitempty"`
	// Indicates whether this host supports enabling Fault Tolerance on
	// encrypted virtual machines.
	EncryptionFaultToleranceSupported *bool `xml:"encryptionFaultToleranceSupported" json:"encryptionFaultToleranceSupported,omitempty"`
	// Indicates whether this host supports suspending, or creating
	// with-memory snapshots, encrypted virtual machines.
	EncryptionMemorySaveSupported *bool `xml:"encryptionMemorySaveSupported" json:"encryptionMemorySaveSupported,omitempty"`
	// Indicates whether this host supports encrypting RDM backed virtual
	// disks.
	EncryptionRDMSupported *bool `xml:"encryptionRDMSupported" json:"encryptionRDMSupported,omitempty"`
	// Indicates whether this host supports encrypting virtual disks with
	// vFlash cache enabled.
	EncryptionVFlashSupported *bool `xml:"encryptionVFlashSupported" json:"encryptionVFlashSupported,omitempty"`
	// Indicates whether this host supports encrypting virtual disks with
	// Content Based Read Cache (digest disks) enabled.
	EncryptionCBRCSupported *bool `xml:"encryptionCBRCSupported" json:"encryptionCBRCSupported,omitempty"`
	// Indicates whether this host supports encrypting virtual disks with
	// Host Based Replication enabled.
	EncryptionHBRSupported *bool `xml:"encryptionHBRSupported" json:"encryptionHBRSupported,omitempty"`
	// Indicates whether this host supports Fault Tolerance VMs that have
	// specified UEFI firmware.
	FtEfiSupported *bool `xml:"ftEfiSupported" json:"ftEfiSupported,omitempty"`
	// Indicates which kind of VMFS unmap method is supported.
	//
	// See
	// `HostCapabilityUnmapMethodSupported_enum`
	UnmapMethodSupported string `xml:"unmapMethodSupported,omitempty" json:"unmapMethodSupported,omitempty"`
	// Indicates maximum memory allowed for Fault Tolerance virtual machine.
	MaxMemMBPerFtVm int32 `xml:"maxMemMBPerFtVm,omitempty" json:"maxMemMBPerFtVm,omitempty"`
	// Indicates that `VirtualMachineFlagInfo.virtualMmuUsage` is
	// ignored by the host, always operating as if "on" was selected.
	VirtualMmuUsageIgnored *bool `xml:"virtualMmuUsageIgnored" json:"virtualMmuUsageIgnored,omitempty"`
	// Indicates that `VirtualMachineFlagInfo.virtualExecUsage` is
	// ignored by the host, always operating as if "hvOn" was selected.
	VirtualExecUsageIgnored *bool `xml:"virtualExecUsageIgnored" json:"virtualExecUsageIgnored,omitempty"`
	// Indicates that createDate feature is supported by the host.
	VmCreateDateSupported *bool `xml:"vmCreateDateSupported" json:"vmCreateDateSupported,omitempty"`
	// Indicates whether this host supports VMFS-3 EOL.
	//
	// If value is not specified, it should be considered as not supported.
	Vmfs3EOLSupported *bool `xml:"vmfs3EOLSupported" json:"vmfs3EOLSupported,omitempty"`
	// Indicates whether this host supports VMCP for Fault Tolerance VMs.
	FtVmcpSupported *bool `xml:"ftVmcpSupported" json:"ftVmcpSupported,omitempty"`
	// Indicates whether this host supports the LoadESX feature
	// which allows faster reboots.
	//
	// See also `HostLoadEsxManager.QueryLoadEsxSupported`.
	QuickBootSupported *bool `xml:"quickBootSupported" json:"quickBootSupported,omitempty"`
	// Indicates whether this host supports encrypted Fault Tolerance.
	EncryptedFtSupported *bool `xml:"encryptedFtSupported" json:"encryptedFtSupported,omitempty" vim:"7.0.2.0"`
	// Indicates whether this host supports Assignable Hardware.
	AssignableHardwareSupported *bool `xml:"assignableHardwareSupported" json:"assignableHardwareSupported,omitempty"`
	// Indicates whether this host supports suspending virtual machines to memory.
	SuspendToMemorySupported *bool `xml:"suspendToMemorySupported" json:"suspendToMemorySupported,omitempty" vim:"7.0.2.0"`
	// Indicates whether this host uses vmFeatures for compatibility checking
	// of old (&leq;8) virtual hardware version VMs.
	UseFeatureReqsForOldHWv *bool `xml:"useFeatureReqsForOldHWv" json:"useFeatureReqsForOldHWv,omitempty"`
	// Indicates whether this host supports marking specified LUN as
	// perennially reserved.
	MarkPerenniallyReservedSupported *bool `xml:"markPerenniallyReservedSupported" json:"markPerenniallyReservedSupported,omitempty"`
	// Indicates whether this host supports HPP path selection policy
	// settings.
	HppPspSupported *bool `xml:"hppPspSupported" json:"hppPspSupported,omitempty"`
	// Indicates whether device rebind without reboot is supported.
	//
	// This is
	// the capability which enables PCI passthrough and SR-IOV configuration
	// without reboot.
	DeviceRebindWithoutRebootSupported *bool `xml:"deviceRebindWithoutRebootSupported" json:"deviceRebindWithoutRebootSupported,omitempty"`
	// Indicates whether this host supports storage policy change.
	StoragePolicyChangeSupported *bool `xml:"storagePolicyChangeSupported" json:"storagePolicyChangeSupported,omitempty"`
	// Indicates whether this host supports date time synchronization over
	// Precision Time Protocol (PTP).
	PrecisionTimeProtocolSupported *bool `xml:"precisionTimeProtocolSupported" json:"precisionTimeProtocolSupported,omitempty"`
	// Indicates whether vMotion of a VM with remote devices attached is
	// supported.
	//
	// This applies to CD-ROM and floppy devices backed by a
	// remote client.
	RemoteDeviceVMotionSupported *bool `xml:"remoteDeviceVMotionSupported" json:"remoteDeviceVMotionSupported,omitempty"`
	// The maximum amount of virtual memory supported per virtual machine.
	//
	// If this capability is not set, the size is limited by hardware version
	// of the virtual machine only.
	MaxSupportedVmMemory int32 `xml:"maxSupportedVmMemory,omitempty" json:"maxSupportedVmMemory,omitempty"`
	// Indicates if the host supports Assignable Hardware device hints.
	AhDeviceHintsSupported *bool `xml:"ahDeviceHintsSupported" json:"ahDeviceHintsSupported,omitempty" vim:"7.0.2.0"`
	// Indicates if access to NVMe over TCP devices is supported.
	NvmeOverTcpSupported *bool `xml:"nvmeOverTcpSupported" json:"nvmeOverTcpSupported,omitempty" vim:"7.0.3.0"`
	// Indicates whether NVMe Storage Fabrics Services (StFS) are supported.
	NvmeStorageFabricServicesSupported *bool `xml:"nvmeStorageFabricServicesSupported" json:"nvmeStorageFabricServicesSupported,omitempty" vim:"7.0.3.0"`
	// Indicates if setting hardwareLabel using PciPassThrough is supported.
	AssignHwPciConfigSupported *bool `xml:"assignHwPciConfigSupported" json:"assignHwPciConfigSupported,omitempty" vim:"7.0.2.0"`
	// Indicates whether advanced timekeeping apis are supported
	TimeConfigSupported *bool `xml:"timeConfigSupported" json:"timeConfigSupported,omitempty" vim:"7.0.3.0"`
	// Indicates whether batch NVMe controller connection/disconnection is supported.
	//
	// See `HostStorageSystem.ConnectNvmeControllerEx_Task` and
	// `HostStorageSystem.DisconnectNvmeControllerEx_Task`.
	NvmeBatchOperationsSupported *bool `xml:"nvmeBatchOperationsSupported" json:"nvmeBatchOperationsSupported,omitempty" vim:"7.0.3.0"`
	// Indicates whether this host supports failover for VMs with virtual
	// devices backed by persistent memory.
	//
	// If value is not specified, it should be considered as not supported.
	PMemFailoverSupported *bool `xml:"pMemFailoverSupported" json:"pMemFailoverSupported,omitempty" vim:"7.0.2.0"`
	// Indicates whether this host supports host configuration encryption.
	HostConfigEncryptionSupported *bool `xml:"hostConfigEncryptionSupported" json:"hostConfigEncryptionSupported,omitempty" vim:"7.0.2.0"`
	// Max supported number of SMT (Simultaneous multithreading) threads.
	//
	// If value is not specified, it should be considered as not supported.
	MaxSupportedSimultaneousThreads int32 `xml:"maxSupportedSimultaneousThreads,omitempty" json:"maxSupportedSimultaneousThreads,omitempty" vim:"8.0.0.1"`
	// Indicates whether this host supports PTP (Precision Time Protocol)
	// service configuration.
	//
	// See `HostPtpConfig`. If value is
	// not specified, it should be considered as not supported.
	PtpConfigSupported *bool `xml:"ptpConfigSupported" json:"ptpConfigSupported,omitempty" vim:"7.0.3.0"`
	// Number of PTP (Precision Time Protocol) ports supported by this
	// host (See `HostPtpConfig`).
	//
	// If this capability is not
	// set, number of PTP ports in the host is 0.
	MaxSupportedPtpPorts int32 `xml:"maxSupportedPtpPorts,omitempty" json:"maxSupportedPtpPorts,omitempty" vim:"7.0.3.0"`
	// Indicates whether this host supports SGX registration.
	SgxRegistrationSupported *bool `xml:"sgxRegistrationSupported" json:"sgxRegistrationSupported,omitempty" vim:"8.0.0.1"`
	// Indicates whether this host supports snapshots of VMs configured
	// with independent vNVDIMMs.
	//
	// If value is not specified, it should be considered as not supported.
	// This support does not depend on `HostCapability.pMemSnapshotSupported`.
	PMemIndependentSnapshotSupported *bool `xml:"pMemIndependentSnapshotSupported" json:"pMemIndependentSnapshotSupported,omitempty" vim:"7.0.3.0"`
	// Indicates whether this host's IOMMUs are capable of tracking pages
	// written by device DMAs using dirty bits in the second-level page
	// tables.
	//
	// If this value is not specified, it should be considered as
	// not capable.
	IommuSLDirtyCapable *bool `xml:"iommuSLDirtyCapable" json:"iommuSLDirtyCapable,omitempty" vim:"8.0.0.1"`
	// Indicates whether vmknic binding is supported over this host.
	VmknicBindingSupported *bool `xml:"vmknicBindingSupported" json:"vmknicBindingSupported,omitempty" vim:"8.0.1.0"`
	// Indicates whether ultralow fixed unmap bandwidth is supported on this host.
	UltralowFixedUnmapSupported *bool `xml:"ultralowFixedUnmapSupported" json:"ultralowFixedUnmapSupported,omitempty" vim:"8.0.0.1"`
	// Indicates whether mounting of NVMe vvol is supported on this host.
	NvmeVvolSupported *bool `xml:"nvmeVvolSupported" json:"nvmeVvolSupported,omitempty" vim:"8.0.0.0"`
	// Indicates whether FPT Hotplug is supported on this host.
	FptHotplugSupported *bool `xml:"fptHotplugSupported" json:"fptHotplugSupported,omitempty" vim:"8.0.1.0"`
	// Indicates whether MCONNECT is supported on this host.
	MconnectSupported *bool `xml:"mconnectSupported" json:"mconnectSupported,omitempty" vim:"8.0.1.0"`
	// Indicates whether vSAN nic types can be managed by VirtualNicManager.
	VsanNicMgmtSupported *bool `xml:"vsanNicMgmtSupported" json:"vsanNicMgmtSupported,omitempty" vim:"8.0.2.0"`
	// Indicates whether vVol NQN is supported on this host.
	VvolNQNSupported *bool `xml:"vvolNQNSupported" json:"vvolNQNSupported,omitempty" vim:"8.0.2.0"`
	// Indicates whether "stretched" vVol Storage Container is supported on this host.
	StretchedSCSupported *bool `xml:"stretchedSCSupported" json:"stretchedSCSupported,omitempty" vim:"8.0.3.0"`
	// Indicates whether vmknic binding is supported on NFSv41 over this host.
	VmknicBindingOnNFSv41 *bool `xml:"vmknicBindingOnNFSv41" json:"vmknicBindingOnNFSv41,omitempty" vim:"8.0.3.0"`
	// Indicates whether VasaProvider Status can be monitored on the host.
	VpStatusCheckSupported *bool `xml:"vpStatusCheckSupported" json:"vpStatusCheckSupported,omitempty" vim:"8.0.3.0"`
	// Indicates whether NFS41 NCONNECT is supported on this host.
	NConnectSupported *bool `xml:"nConnectSupported" json:"nConnectSupported,omitempty" vim:"8.0.3.0"`
	// Indicates whether user-provided private key installation is supported on this host.
	UserKeySupported *bool `xml:"userKeySupported" json:"userKeySupported,omitempty" vim:"8.0.3.0"`
	// Indicates whether non-disruptive certificate management is supported on this host.
	NdcmSupported *bool `xml:"ndcmSupported" json:"ndcmSupported,omitempty" vim:"8.0.3.0"`
	// Flag indicating that the firmware reports the use of UEFI Secure
	// Boot during system boot.
	//
	// TPM attestation may be used to definitively determine the boot
	// time UEFI Secure Boot state and its complete configuration. An
	// out-of-band management channel may also be considered.
	UefiSecureBoot *bool `xml:"uefiSecureBoot" json:"uefiSecureBoot,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["HostCapability"] = reflect.TypeOf((*HostCapability)(nil)).Elem()
}

// This data object is used to encapsulate the X509 certificate metadata.
type HostCertificateManagerCertificateInfo struct {
	DynamicData

	// Certificate kind, if unset the certificate is Machine certificate
	// The list of supported values can be found in `HostCertificateManagerCertificateKind_enum`
	Kind string `xml:"kind,omitempty" json:"kind,omitempty" vim:"8.0.1.0"`
	// The issuer of the certificate.
	Issuer string `xml:"issuer,omitempty" json:"issuer,omitempty"`
	// The validity of the certificate.
	NotBefore *time.Time `xml:"notBefore" json:"notBefore,omitempty"`
	NotAfter  *time.Time `xml:"notAfter" json:"notAfter,omitempty"`
	// The subject of the certificate.
	Subject string `xml:"subject,omitempty" json:"subject,omitempty"`
	// The status of the certificate in vCenter Server.
	//
	// The possible values for status are as
	// described in `HostCertificateManagerCertificateInfoCertificateStatus_enum`.
	// If queried directly from an ESX host, the property is set to
	// `unknown`.
	Status string `xml:"status" json:"status"`
}

func init() {
	t["HostCertificateManagerCertificateInfo"] = reflect.TypeOf((*HostCertificateManagerCertificateInfo)(nil)).Elem()
}

// Represents certificate specification used for
// identifying a specific certificate supported by Host.
type HostCertificateManagerCertificateSpec struct {
	DynamicData

	// The list of supported values can be found in `HostCertificateManagerCertificateKind_enum`
	Kind string `xml:"kind" json:"kind"`
}

func init() {
	t["HostCertificateManagerCertificateSpec"] = reflect.TypeOf((*HostCertificateManagerCertificateSpec)(nil)).Elem()
	minAPIVersionForType["HostCertificateManagerCertificateSpec"] = "8.0.1.0"
}

type HostClearVStorageObjectControlFlags HostClearVStorageObjectControlFlagsRequestType

func init() {
	t["HostClearVStorageObjectControlFlags"] = reflect.TypeOf((*HostClearVStorageObjectControlFlags)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostClearVStorageObjectControlFlags`.
type HostClearVStorageObjectControlFlagsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage
	// object is located.
	//
	// Required privileges: Datastore.FileManagement
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// control flags enum array to be cleared on the
	// VStorageObject. All control flags not included
	// in the array remain intact.
	ControlFlags []string `xml:"controlFlags,omitempty" json:"controlFlags,omitempty"`
}

func init() {
	t["HostClearVStorageObjectControlFlagsRequestType"] = reflect.TypeOf((*HostClearVStorageObjectControlFlagsRequestType)(nil)).Elem()
}

type HostClearVStorageObjectControlFlagsResponse struct {
}

// The parameters of `HostVStorageObjectManager.HostCloneVStorageObject_Task`.
type HostCloneVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage
	// object is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The specification for cloning the virtual storage
	// object.
	Spec VslmCloneSpec `xml:"spec" json:"spec"`
}

func init() {
	t["HostCloneVStorageObjectRequestType"] = reflect.TypeOf((*HostCloneVStorageObjectRequestType)(nil)).Elem()
}

type HostCloneVStorageObject_Task HostCloneVStorageObjectRequestType

func init() {
	t["HostCloneVStorageObject_Task"] = reflect.TypeOf((*HostCloneVStorageObject_Task)(nil)).Elem()
}

type HostCloneVStorageObject_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This event records a failure to connect to a host
// due to a failure to set up a management account.
type HostCnxFailedAccountFailedEvent struct {
	HostEvent
}

func init() {
	t["HostCnxFailedAccountFailedEvent"] = reflect.TypeOf((*HostCnxFailedAccountFailedEvent)(nil)).Elem()
}

// This event records a failure to connect to a host
// due to the host being managed by a different VirtualCenter server.
type HostCnxFailedAlreadyManagedEvent struct {
	HostEvent

	// The name of the VirtualCenter server that manages the host.
	ServerName string `xml:"serverName" json:"serverName"`
}

func init() {
	t["HostCnxFailedAlreadyManagedEvent"] = reflect.TypeOf((*HostCnxFailedAlreadyManagedEvent)(nil)).Elem()
}

// This event records a failure to connect to a host
// due to no response being received from the host agent.
type HostCnxFailedBadCcagentEvent struct {
	HostEvent
}

func init() {
	t["HostCnxFailedBadCcagentEvent"] = reflect.TypeOf((*HostCnxFailedBadCcagentEvent)(nil)).Elem()
}

// This event records a failure to connect to a host
// due to an invalid user name and password combination.
type HostCnxFailedBadUsernameEvent struct {
	HostEvent
}

func init() {
	t["HostCnxFailedBadUsernameEvent"] = reflect.TypeOf((*HostCnxFailedBadUsernameEvent)(nil)).Elem()
}

// This event records a failure to connect to a host
// due to an incompatible client version.
type HostCnxFailedBadVersionEvent struct {
	HostEvent
}

func init() {
	t["HostCnxFailedBadVersionEvent"] = reflect.TypeOf((*HostCnxFailedBadVersionEvent)(nil)).Elem()
}

// This event records a failure to connect to a host
// due to a conflict with an upgrade or installation of the host agent.
type HostCnxFailedCcagentUpgradeEvent struct {
	HostEvent
}

func init() {
	t["HostCnxFailedCcagentUpgradeEvent"] = reflect.TypeOf((*HostCnxFailedCcagentUpgradeEvent)(nil)).Elem()
}

// This event records a failure to connect to a host
// due to an unspecified condition.
type HostCnxFailedEvent struct {
	HostEvent
}

func init() {
	t["HostCnxFailedEvent"] = reflect.TypeOf((*HostCnxFailedEvent)(nil)).Elem()
}

// This event records a failure to connect to a host
// due to a network error.
type HostCnxFailedNetworkErrorEvent struct {
	HostEvent
}

func init() {
	t["HostCnxFailedNetworkErrorEvent"] = reflect.TypeOf((*HostCnxFailedNetworkErrorEvent)(nil)).Elem()
}

// This event records a failure to connect to a host
// due to insufficient account privileges.
type HostCnxFailedNoAccessEvent struct {
	HostEvent
}

func init() {
	t["HostCnxFailedNoAccessEvent"] = reflect.TypeOf((*HostCnxFailedNoAccessEvent)(nil)).Elem()
}

// This event records a failure to connect to a host
// due to a host not being present on the network.
type HostCnxFailedNoConnectionEvent struct {
	HostEvent
}

func init() {
	t["HostCnxFailedNoConnectionEvent"] = reflect.TypeOf((*HostCnxFailedNoConnectionEvent)(nil)).Elem()
}

// This event records a failure to connect to a host
// due to a licensing issue.
type HostCnxFailedNoLicenseEvent struct {
	HostEvent
}

func init() {
	t["HostCnxFailedNoLicenseEvent"] = reflect.TypeOf((*HostCnxFailedNoLicenseEvent)(nil)).Elem()
}

// This event records a failure to connect to a host
// due to a failure to resolve the host name.
type HostCnxFailedNotFoundEvent struct {
	HostEvent
}

func init() {
	t["HostCnxFailedNotFoundEvent"] = reflect.TypeOf((*HostCnxFailedNotFoundEvent)(nil)).Elem()
}

// This event records a failure to connect to a host
// due to a timeout on the connection attempt.
type HostCnxFailedTimeoutEvent struct {
	HostEvent
}

func init() {
	t["HostCnxFailedTimeoutEvent"] = reflect.TypeOf((*HostCnxFailedTimeoutEvent)(nil)).Elem()
}

// A HostCommunication fault is thrown if an error happened
// while communicating to a host.
//
// This would typically be
// due to network connections or server failures.
type HostCommunication struct {
	RuntimeFault
}

func init() {
	t["HostCommunication"] = reflect.TypeOf((*HostCommunication)(nil)).Elem()
}

type HostCommunicationFault BaseHostCommunication

func init() {
	t["HostCommunicationFault"] = reflect.TypeOf((*HostCommunicationFault)(nil)).Elem()
}

// This event records that a compliance check was triggered
// on the host.
type HostComplianceCheckedEvent struct {
	HostEvent

	Profile ProfileEventArgument `xml:"profile" json:"profile"`
}

func init() {
	t["HostComplianceCheckedEvent"] = reflect.TypeOf((*HostComplianceCheckedEvent)(nil)).Elem()
}

// This event records that host is in compliance.
type HostCompliantEvent struct {
	HostEvent
}

func init() {
	t["HostCompliantEvent"] = reflect.TypeOf((*HostCompliantEvent)(nil)).Elem()
}

// This event records that a configuration was applied on a host
type HostConfigAppliedEvent struct {
	HostEvent
}

func init() {
	t["HostConfigAppliedEvent"] = reflect.TypeOf((*HostConfigAppliedEvent)(nil)).Elem()
}

// This data object type describes types and constants related to the
// specification of changes to a host configuration.
type HostConfigChange struct {
	DynamicData
}

func init() {
	t["HostConfigChange"] = reflect.TypeOf((*HostConfigChange)(nil)).Elem()
}

// Fault to indicate configuration of the host failed.
//
// Configuration could have failed because of multiple
// reasons and individual failures will be reported in
// \#failure.
type HostConfigFailed struct {
	HostConfigFault

	Failure []LocalizedMethodFault `xml:"failure" json:"failure"`
}

func init() {
	t["HostConfigFailed"] = reflect.TypeOf((*HostConfigFailed)(nil)).Elem()
}

type HostConfigFailedFault HostConfigFailed

func init() {
	t["HostConfigFailedFault"] = reflect.TypeOf((*HostConfigFailedFault)(nil)).Elem()
}

// Base class for all Host configuration related faults
type HostConfigFault struct {
	VimFault
}

func init() {
	t["HostConfigFault"] = reflect.TypeOf((*HostConfigFault)(nil)).Elem()
}

type HostConfigFaultFault BaseHostConfigFault

func init() {
	t["HostConfigFaultFault"] = reflect.TypeOf((*HostConfigFaultFault)(nil)).Elem()
}

// This data object type encapsulates a typical set of host configuration
// information that is useful for displaying and configuring a host.
//
// VirtualCenter can retrieve this set of information
// very efficiently even for a large set of hosts.
type HostConfigInfo struct {
	DynamicData

	// A reference to a managed object on a host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Information about a product.
	Product AboutInfo `xml:"product" json:"product"`
	// Deployment information about the host.
	DeploymentInfo *HostDeploymentInfo `xml:"deploymentInfo,omitempty" json:"deploymentInfo,omitempty"`
	// If hyperthreading is supported, this is the CPU configuration for
	// optimizing hyperthreading.
	HyperThread *HostHyperThreadScheduleInfo `xml:"hyperThread,omitempty" json:"hyperThread,omitempty"`
	// Information about the CPU scheduler on the host.
	CpuScheduler *HostCpuSchedulerInfo `xml:"cpuScheduler,omitempty" json:"cpuScheduler,omitempty" vim:"8.0.3.0"`
	// Memory configuration.
	ConsoleReservation *ServiceConsoleReservationInfo `xml:"consoleReservation,omitempty" json:"consoleReservation,omitempty"`
	// Virtual machine memory configuration.
	VirtualMachineReservation *VirtualMachineMemoryReservationInfo `xml:"virtualMachineReservation,omitempty" json:"virtualMachineReservation,omitempty"`
	// Storage system information.
	StorageDevice *HostStorageDeviceInfo `xml:"storageDevice,omitempty" json:"storageDevice,omitempty"`
	// Storage multipath state information.
	MultipathState *HostMultipathStateInfo `xml:"multipathState,omitempty" json:"multipathState,omitempty"`
	// Storage system file system volume information.
	FileSystemVolume *HostFileSystemVolumeInfo `xml:"fileSystemVolume,omitempty" json:"fileSystemVolume,omitempty"`
	// Datastore paths of files used by the host system on
	// mounted volumes, for instance, the COS vmdk file of the
	// host.
	//
	// For information on datastore paths, see `Datastore`.
	SystemFile []string `xml:"systemFile,omitempty" json:"systemFile,omitempty"`
	// Network system information.
	Network *HostNetworkInfo `xml:"network,omitempty" json:"network,omitempty"`
	// Deprecated as of VI API 4.0, use `HostConfigInfo.virtualNicManagerInfo`.
	//
	// VMotion system information.
	Vmotion *HostVMotionInfo `xml:"vmotion,omitempty" json:"vmotion,omitempty"`
	// VirtualNic manager information.
	VirtualNicManagerInfo *HostVirtualNicManagerInfo `xml:"virtualNicManagerInfo,omitempty" json:"virtualNicManagerInfo,omitempty"`
	// Capability vector indicating the available network features.
	Capabilities *HostNetCapabilities `xml:"capabilities,omitempty" json:"capabilities,omitempty"`
	// Capability vector indicating available datastore features.
	DatastoreCapabilities *HostDatastoreSystemCapabilities `xml:"datastoreCapabilities,omitempty" json:"datastoreCapabilities,omitempty"`
	// Deprecated as of VI API 4.0, the system defaults will be used.
	//
	// capabilities to offload operations either to the host or to physical
	// hardware when a virtual machine is transmitting on a network
	OffloadCapabilities *HostNetOffloadCapabilities `xml:"offloadCapabilities,omitempty" json:"offloadCapabilities,omitempty"`
	// Host service configuration.
	Service *HostServiceInfo `xml:"service,omitempty" json:"service,omitempty"`
	// Firewall configuration.
	Firewall *HostFirewallInfo `xml:"firewall,omitempty" json:"firewall,omitempty"`
	// AutoStart configuration.
	AutoStart *HostAutoStartManagerConfig `xml:"autoStart,omitempty" json:"autoStart,omitempty"`
	// The diagnostic partition that will be set as the current
	// diagnostic partition on the host.
	ActiveDiagnosticPartition *HostDiagnosticPartition `xml:"activeDiagnosticPartition,omitempty" json:"activeDiagnosticPartition,omitempty"`
	// Host configuration options as defined by the
	// `OptionValue` data object type.
	Option []BaseOptionValue `xml:"option,omitempty,typeattr" json:"option,omitempty"`
	// A list of supported options.
	OptionDef []OptionDef `xml:"optionDef,omitempty" json:"optionDef,omitempty"`
	// Datastore principal user
	DatastorePrincipal string `xml:"datastorePrincipal,omitempty" json:"datastorePrincipal,omitempty"`
	// Datastore visible to this host that may be used to store virtual
	// machine swapfiles, for virtual machines executing on this host.
	//
	// The
	// value of this property is set or unset by invoking
	// `HostDatastoreSystem.UpdateLocalSwapDatastore`.
	// The policy for using this datastore is determined by the compute
	// resource configuration's
	// `vmSwapPlacement`
	// property in concert with each individual virtual machine configuration's
	// `swapPlacement` property.
	//
	// Note: Using a host-specific swap location may degrade VMotion performance.
	//
	// Refers instance of `Datastore`.
	LocalSwapDatastore *ManagedObjectReference `xml:"localSwapDatastore,omitempty" json:"localSwapDatastore,omitempty"`
	// The system swap configuration specifies which options are currently
	// enabled.
	//
	// See also `HostSystemSwapConfiguration`.
	SystemSwapConfiguration *HostSystemSwapConfiguration `xml:"systemSwapConfiguration,omitempty" json:"systemSwapConfiguration,omitempty"`
	// Reference for the system resource hierarchy, used for configuring
	// the set of resources reserved to the system and unavailable to
	// virtual machines.
	SystemResources *HostSystemResourceInfo `xml:"systemResources,omitempty" json:"systemResources,omitempty"`
	// Date/Time related configuration
	DateTimeInfo *HostDateTimeInfo `xml:"dateTimeInfo,omitempty" json:"dateTimeInfo,omitempty"`
	// Additional flags for a host.
	Flags *HostFlagInfo `xml:"flags,omitempty" json:"flags,omitempty"`
	// Deprecated as of vSphere API 6.0, use `HostConfigInfo.lockdownMode`.
	//
	// If the flag is true, the permissions on the host have been modified such
	// that it is only accessible through local console or an authorized
	// centralized management application.
	//
	// This flag is affected by the
	// `HostSystem.EnterLockdownMode` and
	// `HostSystem.ExitLockdownMode` operations.
	//
	// This flag is supported in VirtualCenter only. The value returned from host
	// should be ignored.
	//
	// See also `HostSystem.EnterLockdownMode`, `HostSystem.ExitLockdownMode`.
	AdminDisabled *bool `xml:"adminDisabled" json:"adminDisabled,omitempty"`
	// Indicates the current lockdown mode of the host as reported by
	// `HostAccessManager.lockdownMode`.
	//
	// See also `HostAccessManager.ChangeLockdownMode`.
	LockdownMode HostLockdownMode `xml:"lockdownMode,omitempty" json:"lockdownMode,omitempty"`
	// IPMI (Intelligent Platform Management Interface) info for the host.
	Ipmi *HostIpmiInfo `xml:"ipmi,omitempty" json:"ipmi,omitempty"`
	// Deprecated as of vSphere API 5.0, use `HostConfigInfo.sslThumbprintData` instead.
	//
	// SSL Thumbprint info for hosts registered on this host.
	SslThumbprintInfo *HostSslThumbprintInfo `xml:"sslThumbprintInfo,omitempty" json:"sslThumbprintInfo,omitempty"`
	// SSL Thumbprints registered on this host.
	SslThumbprintData []HostSslThumbprintInfo `xml:"sslThumbprintData,omitempty" json:"sslThumbprintData,omitempty"`
	// Full Host Certificate in PEM format, if known
	Certificate ByteSlice `xml:"certificate,omitempty" json:"certificate,omitempty"`
	// PCI passthrough information.
	PciPassthruInfo []BaseHostPciPassthruInfo `xml:"pciPassthruInfo,omitempty,typeattr" json:"pciPassthruInfo,omitempty"`
	// Current authentication configuration.
	AuthenticationManagerInfo *HostAuthenticationManagerInfo `xml:"authenticationManagerInfo,omitempty" json:"authenticationManagerInfo,omitempty"`
	// List of feature-specific version information.
	//
	// Each element refers
	// to the version information for a specific feature.
	FeatureVersion []HostFeatureVersionInfo `xml:"featureVersion,omitempty" json:"featureVersion,omitempty"`
	// Host power management capability.
	PowerSystemCapability *PowerSystemCapability `xml:"powerSystemCapability,omitempty" json:"powerSystemCapability,omitempty"`
	// Host power management information.
	PowerSystemInfo *PowerSystemInfo `xml:"powerSystemInfo,omitempty" json:"powerSystemInfo,omitempty"`
	// Host solid stats drive cache configuration information.
	CacheConfigurationInfo []HostCacheConfigurationInfo `xml:"cacheConfigurationInfo,omitempty" json:"cacheConfigurationInfo,omitempty"`
	// Indicates if a host is wake on lan capable.
	//
	// A host is deemed wake on lan capable if there exists at least one
	// physical network card that is both backing the vmotion interface and
	// is itself wake on lan capable.
	WakeOnLanCapable *bool `xml:"wakeOnLanCapable" json:"wakeOnLanCapable,omitempty"`
	// Array of host feature capabilities.
	//
	// This is expected to change
	// infrequently. It may change while host is in maintenance mode
	// and between reboots if hardware, firmware, or a device driver
	// is changed or upgraded.
	FeatureCapability []HostFeatureCapability `xml:"featureCapability,omitempty" json:"featureCapability,omitempty"`
	// Array of the feature capabilities that the host has after the
	// mask has been applied.
	MaskedFeatureCapability []HostFeatureCapability `xml:"maskedFeatureCapability,omitempty" json:"maskedFeatureCapability,omitempty"`
	// Host vFlash configuration information
	VFlashConfigInfo *HostVFlashManagerVFlashConfigInfo `xml:"vFlashConfigInfo,omitempty" json:"vFlashConfigInfo,omitempty"`
	// VSAN configuration for a host.
	VsanHostConfig *VsanHostConfigInfo `xml:"vsanHostConfig,omitempty" json:"vsanHostConfig,omitempty"`
	// List of Windows domains available for user searches, if the underlying
	// system supports windows domain membership.
	//
	// See `UserDirectory.domainList`.
	DomainList []string `xml:"domainList,omitempty" json:"domainList,omitempty"`
	// A checksum of overhead computation script.
	//
	// (For VMware internal usage only)
	ScriptCheckSum []byte `xml:"scriptCheckSum,omitempty" json:"scriptCheckSum,omitempty"`
	// A checksum of host configuration option set.
	//
	// (For VMware internal usage only)
	HostConfigCheckSum []byte `xml:"hostConfigCheckSum,omitempty" json:"hostConfigCheckSum,omitempty"`
	// A checksum of the Assignable Hardware Description Tree.
	//
	// (For VMware internal usage only)
	DescriptionTreeCheckSum []byte `xml:"descriptionTreeCheckSum,omitempty" json:"descriptionTreeCheckSum,omitempty"`
	// The list of graphics devices available on this host.
	GraphicsInfo []HostGraphicsInfo `xml:"graphicsInfo,omitempty" json:"graphicsInfo,omitempty"`
	// Array of shared passthru GPU types.
	//
	// These GPU types may be enabled
	// when specific host hardware is present.
	SharedPassthruGpuTypes []string `xml:"sharedPassthruGpuTypes,omitempty" json:"sharedPassthruGpuTypes,omitempty"`
	// Graphics configuration for a host.
	GraphicsConfig *HostGraphicsConfig `xml:"graphicsConfig,omitempty" json:"graphicsConfig,omitempty"`
	// Array of shared passthru GPU capablities.
	//
	// See also `HostSharedGpuCapabilities`.
	SharedGpuCapabilities []HostSharedGpuCapabilities `xml:"sharedGpuCapabilities,omitempty" json:"sharedGpuCapabilities,omitempty"`
	// Information of the IO Filters installed on the host.
	//
	// See `HostIoFilterInfo`.
	IoFilterInfo []HostIoFilterInfo `xml:"ioFilterInfo,omitempty" json:"ioFilterInfo,omitempty"`
	// Information on SRIOV device pools present on host.
	SriovDevicePool []BaseHostSriovDevicePoolInfo `xml:"sriovDevicePool,omitempty,typeattr" json:"sriovDevicePool,omitempty"`
	// Information describing Assignable Hardware device bindings on host.
	//
	// See `HostAssignableHardwareBinding`.
	AssignableHardwareBinding []HostAssignableHardwareBinding `xml:"assignableHardwareBinding,omitempty" json:"assignableHardwareBinding,omitempty"`
	// Configured assignable hardware device attributes.
	AssignableHardwareConfig *HostAssignableHardwareConfig `xml:"assignableHardwareConfig,omitempty" json:"assignableHardwareConfig,omitempty"`
}

func init() {
	t["HostConfigInfo"] = reflect.TypeOf((*HostConfigInfo)(nil)).Elem()
}

// This data object type describes the configuration of a host
// across products and versions.
type HostConfigManager struct {
	DynamicData

	// The CPU scheduler that determines which threads execute on a CPU
	// at any given time.
	//
	// Refers instance of `HostCpuSchedulerSystem`.
	CpuScheduler *ManagedObjectReference `xml:"cpuScheduler,omitempty" json:"cpuScheduler,omitempty"`
	// The datastore manager.
	//
	// Refers instance of `HostDatastoreSystem`.
	DatastoreSystem *ManagedObjectReference `xml:"datastoreSystem,omitempty" json:"datastoreSystem,omitempty"`
	// The memory manager on the host.
	//
	// Refers instance of `HostMemorySystem`.
	MemoryManager *ManagedObjectReference `xml:"memoryManager,omitempty" json:"memoryManager,omitempty"`
	// The storage configuration.
	//
	// Refers instance of `HostStorageSystem`.
	StorageSystem *ManagedObjectReference `xml:"storageSystem,omitempty" json:"storageSystem,omitempty"`
	// The network system configuration.
	//
	// Refers instance of `HostNetworkSystem`.
	NetworkSystem *ManagedObjectReference `xml:"networkSystem,omitempty" json:"networkSystem,omitempty"`
	// Deprecated as of VI API 4.0, use `HostConfigManager.virtualNicManager`
	// to manage the VMotion configuration of the host.
	//
	// The VMotion configuration.
	//
	// Refers instance of `HostVMotionSystem`.
	VmotionSystem *ManagedObjectReference `xml:"vmotionSystem,omitempty" json:"vmotionSystem,omitempty"`
	// The VirtualNic configuration.
	//
	// Refers instance of `HostVirtualNicManager`.
	VirtualNicManager *ManagedObjectReference `xml:"virtualNicManager,omitempty" json:"virtualNicManager,omitempty"`
	// The configuration of the host services (for example,
	// SSH, FTP, and Telnet).
	//
	// Refers instance of `HostServiceSystem`.
	ServiceSystem *ManagedObjectReference `xml:"serviceSystem,omitempty" json:"serviceSystem,omitempty"`
	// The firewall configuration.
	//
	// Refers instance of `HostFirewallSystem`.
	FirewallSystem *ManagedObjectReference `xml:"firewallSystem,omitempty" json:"firewallSystem,omitempty"`
	// Advanced options.
	//
	// Refers instance of `OptionManager`.
	AdvancedOption *ManagedObjectReference `xml:"advancedOption,omitempty" json:"advancedOption,omitempty"`
	// The diagnostic for the ESX Server system.
	//
	// Refers instance of `HostDiagnosticSystem`.
	DiagnosticSystem *ManagedObjectReference `xml:"diagnosticSystem,omitempty" json:"diagnosticSystem,omitempty"`
	// Auto-start and auto-stop configuration.
	//
	// Refers instance of `HostAutoStartManager`.
	AutoStartManager *ManagedObjectReference `xml:"autoStartManager,omitempty" json:"autoStartManager,omitempty"`
	// Snmp configuration
	//
	// Refers instance of `HostSnmpSystem`.
	SnmpSystem *ManagedObjectReference `xml:"snmpSystem,omitempty" json:"snmpSystem,omitempty"`
	// DateTime configuration
	//
	// Refers instance of `HostDateTimeSystem`.
	DateTimeSystem *ManagedObjectReference `xml:"dateTimeSystem,omitempty" json:"dateTimeSystem,omitempty"`
	// Host patch management.
	//
	// Refers instance of `HostPatchManager`.
	PatchManager *ManagedObjectReference `xml:"patchManager,omitempty" json:"patchManager,omitempty"`
	// Host image configuration management.
	//
	// Refers instance of `HostImageConfigManager`.
	ImageConfigManager *ManagedObjectReference `xml:"imageConfigManager,omitempty" json:"imageConfigManager,omitempty"`
	// Boot device order management.
	//
	// Refers instance of `HostBootDeviceSystem`.
	BootDeviceSystem *ManagedObjectReference `xml:"bootDeviceSystem,omitempty" json:"bootDeviceSystem,omitempty"`
	// Firmware management.
	//
	// Refers instance of `HostFirmwareSystem`.
	FirmwareSystem *ManagedObjectReference `xml:"firmwareSystem,omitempty" json:"firmwareSystem,omitempty"`
	// System health status manager.
	//
	// Refers instance of `HostHealthStatusSystem`.
	HealthStatusSystem *ManagedObjectReference `xml:"healthStatusSystem,omitempty" json:"healthStatusSystem,omitempty"`
	// PciDeviceSystem for passthru.
	//
	// Refers instance of `HostPciPassthruSystem`.
	PciPassthruSystem *ManagedObjectReference `xml:"pciPassthruSystem,omitempty" json:"pciPassthruSystem,omitempty"`
	// License manager
	//
	// Refers instance of `LicenseManager`.
	LicenseManager *ManagedObjectReference `xml:"licenseManager,omitempty" json:"licenseManager,omitempty"`
	// Kernel module configuration management.
	//
	// Refers instance of `HostKernelModuleSystem`.
	KernelModuleSystem *ManagedObjectReference `xml:"kernelModuleSystem,omitempty" json:"kernelModuleSystem,omitempty"`
	// Authentication method configuration - for example, for Active Directory membership.
	//
	// Refers instance of `HostAuthenticationManager`.
	AuthenticationManager *ManagedObjectReference `xml:"authenticationManager,omitempty" json:"authenticationManager,omitempty"`
	// Power System manager.
	//
	// Refers instance of `HostPowerSystem`.
	PowerSystem *ManagedObjectReference `xml:"powerSystem,omitempty" json:"powerSystem,omitempty"`
	// Host solid state drive cache configuration manager.
	//
	// Refers instance of `HostCacheConfigurationManager`.
	CacheConfigurationManager *ManagedObjectReference `xml:"cacheConfigurationManager,omitempty" json:"cacheConfigurationManager,omitempty"`
	// Esx Agent resource configuration manager
	//
	// Refers instance of `HostEsxAgentHostManager`.
	EsxAgentHostManager *ManagedObjectReference `xml:"esxAgentHostManager,omitempty" json:"esxAgentHostManager,omitempty"`
	// Iscsi Management Operations managed entity
	//
	// Refers instance of `IscsiManager`.
	IscsiManager *ManagedObjectReference `xml:"iscsiManager,omitempty" json:"iscsiManager,omitempty"`
	// vFlash Manager
	//
	// Refers instance of `HostVFlashManager`.
	VFlashManager *ManagedObjectReference `xml:"vFlashManager,omitempty" json:"vFlashManager,omitempty"`
	// VsanSystem managed entity.
	//
	// Refers instance of `HostVsanSystem`.
	VsanSystem *ManagedObjectReference `xml:"vsanSystem,omitempty" json:"vsanSystem,omitempty"`
	// Common Message Bus proxy service.
	//
	// This API shall always be present in vSphere API 6.0 or later.
	//
	// Refers instance of `MessageBusProxy`.
	MessageBusProxy *ManagedObjectReference `xml:"messageBusProxy,omitempty" json:"messageBusProxy,omitempty"`
	// A user directory managed object.
	//
	// Refers instance of `UserDirectory`.
	UserDirectory *ManagedObjectReference `xml:"userDirectory,omitempty" json:"userDirectory,omitempty"`
	// A manager for host local user accounts.
	//
	// Refers instance of `HostLocalAccountManager`.
	AccountManager *ManagedObjectReference `xml:"accountManager,omitempty" json:"accountManager,omitempty"`
	// Host access manager
	//
	// Refers instance of `HostAccessManager`.
	HostAccessManager *ManagedObjectReference `xml:"hostAccessManager,omitempty" json:"hostAccessManager,omitempty"`
	// Host graphics manager.
	//
	// Refers instance of `HostGraphicsManager`.
	GraphicsManager *ManagedObjectReference `xml:"graphicsManager,omitempty" json:"graphicsManager,omitempty"`
	// VsanInternalSystem managed entity.
	//
	// Refers instance of `HostVsanInternalSystem`.
	VsanInternalSystem *ManagedObjectReference `xml:"vsanInternalSystem,omitempty" json:"vsanInternalSystem,omitempty"`
	// Host CertificateManager.
	//
	// Refers instance of `HostCertificateManager`.
	CertificateManager *ManagedObjectReference `xml:"certificateManager,omitempty" json:"certificateManager,omitempty"`
	// Host CryptoManager.
	//
	// Refers instance of `CryptoManager`.
	CryptoManager *ManagedObjectReference `xml:"cryptoManager,omitempty" json:"cryptoManager,omitempty"`
	// Host Non-Volatile DIMM configuration manager
	//
	// Refers instance of `HostNvdimmSystem`.
	NvdimmSystem *ManagedObjectReference `xml:"nvdimmSystem,omitempty" json:"nvdimmSystem,omitempty"`
	// Assignable Hardware manager.
	//
	// Refers instance of `HostAssignableHardwareManager`.
	AssignableHardwareManager *ManagedObjectReference `xml:"assignableHardwareManager,omitempty" json:"assignableHardwareManager,omitempty"`
}

func init() {
	t["HostConfigManager"] = reflect.TypeOf((*HostConfigManager)(nil)).Elem()
}

// The `HostConfigSpec` data object provides access to data objects
// that specify configuration changes to be applied to an ESX host.
type HostConfigSpec struct {
	DynamicData

	// Configurations to create NAS datastores.
	NasDatastore []HostNasVolumeConfig `xml:"nasDatastore,omitempty" json:"nasDatastore,omitempty"`
	// Network system information.
	Network *HostNetworkConfig `xml:"network,omitempty" json:"network,omitempty"`
	// Type selection for different VirtualNics.
	NicTypeSelection []HostVirtualNicManagerNicTypeSelection `xml:"nicTypeSelection,omitempty" json:"nicTypeSelection,omitempty"`
	// Host service configuration.
	Service []HostServiceConfig `xml:"service,omitempty" json:"service,omitempty"`
	// Firewall configuration.
	Firewall *HostFirewallConfig `xml:"firewall,omitempty" json:"firewall,omitempty"`
	// Host configuration options as defined by the
	// `OptionValue` data object type.
	Option []BaseOptionValue `xml:"option,omitempty,typeattr" json:"option,omitempty"`
	// Datastore principal user.
	DatastorePrincipal string `xml:"datastorePrincipal,omitempty" json:"datastorePrincipal,omitempty"`
	// Password for the datastore principal.
	DatastorePrincipalPasswd string `xml:"datastorePrincipalPasswd,omitempty" json:"datastorePrincipalPasswd,omitempty"`
	// DateTime Configuration.
	Datetime *HostDateTimeConfig `xml:"datetime,omitempty" json:"datetime,omitempty"`
	// Storage system information.
	StorageDevice *HostStorageDeviceInfo `xml:"storageDevice,omitempty" json:"storageDevice,omitempty"`
	// License configuration for the host.
	License *HostLicenseSpec `xml:"license,omitempty" json:"license,omitempty"`
	// Security specification.
	Security *HostSecuritySpec `xml:"security,omitempty" json:"security,omitempty"`
	// List of users to create/update with new password.
	UserAccount []BaseHostAccountSpec `xml:"userAccount,omitempty,typeattr" json:"userAccount,omitempty"`
	// List of users to create/update with new password.
	UsergroupAccount []BaseHostAccountSpec `xml:"usergroupAccount,omitempty,typeattr" json:"usergroupAccount,omitempty"`
	// Memory configuration for the host.
	Memory *HostMemorySpec `xml:"memory,omitempty" json:"memory,omitempty"`
	// Active Directory configuration change.
	ActiveDirectory []HostActiveDirectory `xml:"activeDirectory,omitempty" json:"activeDirectory,omitempty"`
	// Advanced configuration.
	GenericConfig []KeyAnyValue `xml:"genericConfig,omitempty" json:"genericConfig,omitempty"`
	// Graphics configuration for a host.
	GraphicsConfig *HostGraphicsConfig `xml:"graphicsConfig,omitempty" json:"graphicsConfig,omitempty"`
	// Assignable Hardware configuration for the host
	AssignableHardwareConfig *HostAssignableHardwareConfig `xml:"assignableHardwareConfig,omitempty" json:"assignableHardwareConfig,omitempty"`
}

func init() {
	t["HostConfigSpec"] = reflect.TypeOf((*HostConfigSpec)(nil)).Elem()
}

// An overview of the key configuration parameters.
type HostConfigSummary struct {
	DynamicData

	// The name of the host.
	Name string `xml:"name" json:"name"`
	// The port number.
	Port int32 `xml:"port" json:"port"`
	// The SSL thumbprint of the host, if known.
	SslThumbprint string `xml:"sslThumbprint,omitempty" json:"sslThumbprint,omitempty"`
	// Information about the software running on the host, if known.
	//
	// The current supported hosts are ESX Server 2.0.1 (and later) and VMware Server
	// 2.0.0 (and later).
	Product *AboutInfo `xml:"product,omitempty" json:"product,omitempty"`
	// The flag to indicate whether or not VMotion is enabled on this host.
	VmotionEnabled bool `xml:"vmotionEnabled" json:"vmotionEnabled"`
	// The flag to indicate whether or not Fault Tolerance logging is enabled on this host.
	FaultToleranceEnabled *bool `xml:"faultToleranceEnabled" json:"faultToleranceEnabled,omitempty"`
	// List of feature-specific version information.
	//
	// Each element refers
	// to the version information for a specific feature.
	FeatureVersion []HostFeatureVersionInfo `xml:"featureVersion,omitempty" json:"featureVersion,omitempty"`
	// Datastore used to deploy Agent VMs on for this host.
	//
	// Refers instance of `Datastore`.
	AgentVmDatastore *ManagedObjectReference `xml:"agentVmDatastore,omitempty" json:"agentVmDatastore,omitempty"`
	// Management network for Agent VMs.
	//
	// Refers instance of `Network`.
	AgentVmNetwork *ManagedObjectReference `xml:"agentVmNetwork,omitempty" json:"agentVmNetwork,omitempty"`
}

func init() {
	t["HostConfigSummary"] = reflect.TypeOf((*HostConfigSummary)(nil)).Elem()
}

type HostConfigVFlashCache HostConfigVFlashCacheRequestType

func init() {
	t["HostConfigVFlashCache"] = reflect.TypeOf((*HostConfigVFlashCache)(nil)).Elem()
}

// The parameters of `HostVFlashManager.HostConfigVFlashCache`.
type HostConfigVFlashCacheRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specification for host cache configuration.
	Spec HostVFlashManagerVFlashCacheConfigSpec `xml:"spec" json:"spec"`
}

func init() {
	t["HostConfigVFlashCacheRequestType"] = reflect.TypeOf((*HostConfigVFlashCacheRequestType)(nil)).Elem()
}

type HostConfigVFlashCacheResponse struct {
}

type HostConfigureVFlashResource HostConfigureVFlashResourceRequestType

func init() {
	t["HostConfigureVFlashResource"] = reflect.TypeOf((*HostConfigureVFlashResource)(nil)).Elem()
}

// The parameters of `HostVFlashManager.HostConfigureVFlashResource`.
type HostConfigureVFlashResourceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// the vFlash resource specification.
	Spec HostVFlashManagerVFlashResourceConfigSpec `xml:"spec" json:"spec"`
}

func init() {
	t["HostConfigureVFlashResourceRequestType"] = reflect.TypeOf((*HostConfigureVFlashResourceRequestType)(nil)).Elem()
}

type HostConfigureVFlashResourceResponse struct {
}

// A base clase for faults that are related to connecting or
// adding a host to the inventory.
type HostConnectFault struct {
	VimFault
}

func init() {
	t["HostConnectFault"] = reflect.TypeOf((*HostConnectFault)(nil)).Elem()
}

type HostConnectFaultFault BaseHostConnectFault

func init() {
	t["HostConnectFaultFault"] = reflect.TypeOf((*HostConnectFaultFault)(nil)).Elem()
}

// This data object type contains information about a single host that can be used by
// the connection wizard.
//
// This can be returned without adding the host to VirtualCenter.
type HostConnectInfo struct {
	DynamicData

	// The IP address of the VirtualCenter already managing this host, if any.
	ServerIp string `xml:"serverIp,omitempty" json:"serverIp,omitempty"`
	// If the host is already being managed by a vCenter Server, this property
	// reports true if the host is also part of a vSphere HA enabled cluster.
	//
	// If
	// this is the case, remove or disconnect the host
	// from this cluster before adding it to another vCenter Server.
	InDasCluster *bool `xml:"inDasCluster" json:"inDasCluster,omitempty"`
	// Summary information about the host.
	//
	// The status fields and managed object
	// reference is not set when an object of this type is created. These fields and
	// references are typically set later when these objects are associated with a host.
	Host HostListSummary `xml:"host" json:"host"`
	// The list of virtual machines on the host.
	Vm []VirtualMachineSummary `xml:"vm,omitempty" json:"vm,omitempty"`
	// Whether or not the host requires a vimAccountName and password to be set in the
	// ConnectSpec.
	//
	// This is normally only required for VMware Server hosts.
	VimAccountNameRequired *bool `xml:"vimAccountNameRequired" json:"vimAccountNameRequired,omitempty"`
	// Whether or not the host supports clustering capabilities such as HA or DRS and
	// therefore can be added to a cluster.
	//
	// If false, the host must be added as a
	// standalone host.
	ClusterSupported *bool `xml:"clusterSupported" json:"clusterSupported,omitempty"`
	// The list of network information for networks configured on this host.
	Network []BaseHostConnectInfoNetworkInfo `xml:"network,omitempty,typeattr" json:"network,omitempty"`
	// The list of datastores on the host.
	Datastore []BaseHostDatastoreConnectInfo `xml:"datastore,omitempty,typeattr" json:"datastore,omitempty"`
	// License manager information on the host
	License *HostLicenseConnectInfo `xml:"license,omitempty" json:"license,omitempty"`
	// Host capabilities.
	Capability *HostCapability `xml:"capability,omitempty" json:"capability,omitempty"`
}

func init() {
	t["HostConnectInfo"] = reflect.TypeOf((*HostConnectInfo)(nil)).Elem()
}

// The base data object type for information about networks on the host.
type HostConnectInfoNetworkInfo struct {
	DynamicData

	// Basic network information, such as network name.
	//
	// The managed object reference
	// is not set.
	Summary BaseNetworkSummary `xml:"summary,typeattr" json:"summary"`
}

func init() {
	t["HostConnectInfoNetworkInfo"] = reflect.TypeOf((*HostConnectInfoNetworkInfo)(nil)).Elem()
}

// Specifies the parameters needed to add a single host.
//
// This includes
// a small set of optional information about the host configuration.
// This allows the network and datastore configuration of the host to
// be synchronized with the naming conventions of the datacenter, as well
// as the configuration of a vim account (the username/password for the
// virtual machine files that is created on disk).
type HostConnectSpec struct {
	DynamicData

	// The DNS name or IP address of the host.
	//
	// (Required for adding
	// a host.)
	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
	// The port number for the connection.
	//
	// If this is not specified,
	// the default port number is used. For ESX 2.x hosts this is the authd
	// port (902 by default). For ESX 3.x and above and VMware Server hosts
	// this is the https port (443 by default).
	// If this is a reconnect, the port number is unchanged.
	Port int32 `xml:"port,omitempty" json:"port,omitempty"`
	// The thumbprint of the SSL certificate, which the host is
	// expected to have.
	//
	// If this value is set and matches the
	// certificate thumbprint presented by the host, then the host is
	// authenticated. If this value is not set or does not match the
	// certificate thumbprint presented by the host, then the host's
	// certificate is verified by checking whether it was signed by a
	// recognized CA.
	//
	// The thumbprint is always computed using the SHA1 hash and is
	// the string representation of that hash in the format:
	// xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx
	// where, 'x' represents a hexadecimal digit
	SslThumbprint string `xml:"sslThumbprint,omitempty" json:"sslThumbprint,omitempty"`
	// The administration account on the host.
	//
	// (Required for adding
	// a host.)
	UserName string `xml:"userName,omitempty" json:"userName,omitempty"`
	// The password for the administration account.
	//
	// (Required for adding
	// a host.)
	Password string `xml:"password,omitempty" json:"password,omitempty"`
	// The folder in which to store the existing virtual machines on the host.
	//
	// If this folder is not specified, a default folder is chosen
	// (and possibly created) by the VirtualCenter. This folder exists (or
	// is possibly created) on the
	// VirtualCenter server and is called "Discovered VM".
	//
	// Refers instance of `Folder`.
	VmFolder *ManagedObjectReference `xml:"vmFolder,omitempty" json:"vmFolder,omitempty"`
	// If this flag is set to "true", then the connection succeeds even
	// if the host is already being managed by another VirtualCenter server.
	//
	// The original VirtualCenter server loses connection to the host.
	Force bool `xml:"force" json:"force"`
	// The username to be used for accessing the virtual
	// machine files on the disk.
	VimAccountName string `xml:"vimAccountName,omitempty" json:"vimAccountName,omitempty"`
	// The password to be used with the
	// `vimAccountName`
	// property for accessing the virtual
	// machine files on the disk.
	VimAccountPassword string `xml:"vimAccountPassword,omitempty" json:"vimAccountPassword,omitempty"`
	// The IP address of the VirtualCenter server that will manage this host.
	//
	// This field can be used to control which IP address the VirtualCenter agent
	// will send heartbeats to. If it is not set, VirtualCenter will use the local IP
	// address used when communicating with the host. Setting this field is useful
	// when the VirtualCenter server is behind a NAT in which case the external NAT
	// address must be used.
	ManagementIp string `xml:"managementIp,omitempty" json:"managementIp,omitempty"`
	// If this is set then the host will be put in the specified lockdown mode
	// when the host is added and connected.
	//
	// It is used only when calling the APIs
	// `Folder.AddStandaloneHost_Task` with parameter 'addConnected' set to true,
	// or `ClusterComputeResource.AddHost_Task` with parameter 'asConnected'
	// set to true.
	// If the operation to add the host specifies that the host should only be
	// added but not connected, then the host won't be put in lockdown mode.
	//
	// This is equivalent to invoking
	// `HostAccessManager.ChangeLockdownMode`
	// immediately after addition and connection to the host succeeds.
	//
	// If equal to `lockdownDisabled`
	// then it is ignored.
	LockdownMode HostLockdownMode `xml:"lockdownMode,omitempty" json:"lockdownMode,omitempty"`
	// Deprecated not supported since vSphere 6.5.
	//
	// Setting for a gateway for communication to the host.
	//
	// If set all trafic to the
	// host will pass through this gateway.
	HostGateway *HostGatewaySpec `xml:"hostGateway,omitempty" json:"hostGateway,omitempty"`
}

func init() {
	t["HostConnectSpec"] = reflect.TypeOf((*HostConnectSpec)(nil)).Elem()
}

// This event records a successful host connection.
type HostConnectedEvent struct {
	HostEvent
}

func init() {
	t["HostConnectedEvent"] = reflect.TypeOf((*HostConnectedEvent)(nil)).Elem()
}

// This event records the loss of a host connection.
type HostConnectionLostEvent struct {
	HostEvent
}

func init() {
	t["HostConnectionLostEvent"] = reflect.TypeOf((*HostConnectionLostEvent)(nil)).Elem()
}

// The CpuIdInfo data object type is used to represent the CPU features of
// a particular host or product, or to specify what the CPU feature
// requirements are for a particular virtual machine or guest operating
// system.
//
// As of vSphere API 5.1 `FeatureMask` must be
// used for masking all hosts and is the recommended method for masking
// virtual machines with hardware version 9 and above (newer). CpuIdInfo
// should be used only to mask hardware version 8 and lower (older)
// virtual machines. Although CpuIdInfo can mask all virtual machines
// regardless of hardware version, its application is limited and has been
// superceded by FeatureMask.
//
// For each register (eax,ebx,ecx,edx), the string is a bit mask of the form:
//
//	????:????:????:????:????:????:????:????
//
// When used to represent the features of a specific processor package
// (`HostHardwareInfo.cpuPkg`), the features common to all
// processors on a host (`HostHardwareInfo.cpuFeature`), or the
// features supported by a virtualization platform
// (`HostCapability.supportedCpuFeature`), each bit is either '0'
// or '1', or '-' for unknown/unspecified. In these feature vectors, the
// vendor field is never set.
//
// Optional values in these feature vectors default to
// '----:----:----:----:----:----:----:----'.
//
// When specifying the required feature set for a virtual machine or a guest
// operating system, the bits can take on the values as described below, and
// the vendor field may be set. The total feature requirements for a virtual
// machine are composed by using any requirements listed in the virtual
// machine's configuration to override the requirements listed in the
// descriptor for the virtual machine's guest OS.
//
// Bits used for specifying requirements:
//   - `*x*`: Unused by guest software.
//   - `*T*`: Feature that the guest software requires to be enabled.
//   - `*F*`: Feature that the guest software requires to be disabled.
//   - `*1*`: Feature will be reported as enabled if queried by the guest
//     software.
//   - `*0*`: Feature will be reported as disabled if queried by the guest
//     software.
//   - `*R*`: Feature will be reported as disabled if queried by the guest
//     software; however, for VMotion the actual value of this
//     feature is required to be the same on both hosts.
//   - `*H*`: Used by guest software. For VMotion the value of this
//     feature is required to be the same on both hosts.
//   - `*-*`: This bit type is only used in the requirements stored in
//     the virtual machine's configuration. It indicates that, for
//     this bit position, the requirement from the guest OS
//     descriptor should be used instead.
//
// The values 'F' and '1' are rarely used but included for completeness. The
// '0' and '1' values do not promise a faithful virtualization of these
// features; whether the features work when forced to 0 or 1 is highly
// dependent on the guest software.
//
// Optional values in the requirements from the virtual machine's
// configuration default to '----:----:----:----:----:----:----:----'.
// Optional values in the requirements from the guest OS descriptor default
// to 'xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx'.
//
// Once the feature requirements for a virtual machine have been composed
// from the virtual machine's configuration and guest OS descriptor, the bit
// types above are used to identify whether or not the virtual machine
// can be powered on or be migrated with VMotion to a particular host.
// The rules are as follows:
//   - `*Power-on*`: Requirements marked as 'T' or 'F' must match bits
//     '1' or '0', respectively, in the features advertised by the HardwareInfo
//     of the power-on host.
//   - `*VMotion*`: Requirements marked as 'T' or 'F' must match bits
//     '1' or '0', respectively, in the features advertised by the HardwareInfo
//     of the destination host. Also, at the positions where requirements are
//     marked 'H' or 'R', the advertised value of that feature for the source
//     host must match that of the destination host.
type HostCpuIdInfo struct {
	DynamicData

	// Level (EAX input to CPUID).
	Level int32 `xml:"level" json:"level"`
	// Used if this mask is for a particular vendor.
	Vendor string `xml:"vendor,omitempty" json:"vendor,omitempty"`
	// String representing the required EAX bits.
	Eax string `xml:"eax,omitempty" json:"eax,omitempty"`
	// String representing the required EBX bits.
	Ebx string `xml:"ebx,omitempty" json:"ebx,omitempty"`
	// String representing the required ECX bits.
	Ecx string `xml:"ecx,omitempty" json:"ecx,omitempty"`
	// String representing the required EDX bits.
	Edx string `xml:"edx,omitempty" json:"edx,omitempty"`
}

func init() {
	t["HostCpuIdInfo"] = reflect.TypeOf((*HostCpuIdInfo)(nil)).Elem()
}

// Information about the CPUs.
type HostCpuInfo struct {
	DynamicData

	// Number of physical CPU packages on the host.
	NumCpuPackages int16 `xml:"numCpuPackages" json:"numCpuPackages"`
	// Number of physical CPU cores on the host.
	NumCpuCores int16 `xml:"numCpuCores" json:"numCpuCores"`
	// Number of physical CPU threads on the host.
	NumCpuThreads int16 `xml:"numCpuThreads" json:"numCpuThreads"`
	// CPU speed per core.
	//
	// This might be an averaged value if the speed
	// is not uniform across all cores. The total CPU speed of the box is
	// defined as hz \* numCpuCores
	Hz int64 `xml:"hz" json:"hz"`
}

func init() {
	t["HostCpuInfo"] = reflect.TypeOf((*HostCpuInfo)(nil)).Elem()
}

// Information about a physical CPU package.
type HostCpuPackage struct {
	DynamicData

	// Package index, starting from zero.
	Index int16 `xml:"index" json:"index"`
	// CPU vendor name, possible names currently are "Intel", "AMD",
	// "arm", "hygon", or "unknown".
	Vendor string `xml:"vendor" json:"vendor"`
	// CPU speed in HZ.
	Hz int64 `xml:"hz" json:"hz"`
	// Bus speed in HZ.
	BusHz int64 `xml:"busHz" json:"busHz"`
	// String summary description of CPU (for display purposes).
	Description string `xml:"description" json:"description"`
	// The logical CPU threads on this package.
	ThreadId []int16 `xml:"threadId" json:"threadId"`
	// The CPU feature bit on this particular CPU.
	//
	// This is independent of
	// the product and licensing capabilities.
	CpuFeature []HostCpuIdInfo `xml:"cpuFeature,omitempty" json:"cpuFeature,omitempty"`
	// Family ID for the CPU
	Family int16 `xml:"family,omitempty" json:"family,omitempty" vim:"8.0.3.0"`
	// Model number of the CPU
	Model int16 `xml:"model,omitempty" json:"model,omitempty" vim:"8.0.3.0"`
	// Stepping ID of the CPU
	Stepping int16 `xml:"stepping,omitempty" json:"stepping,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["HostCpuPackage"] = reflect.TypeOf((*HostCpuPackage)(nil)).Elem()
}

// The CpuPowerManagementInfo data object type describes supported
// power management and current policy.
type HostCpuPowerManagementInfo struct {
	DynamicData

	// Information about current CPU power management policy.
	CurrentPolicy string `xml:"currentPolicy,omitempty" json:"currentPolicy,omitempty"`
	// Information about supported CPU power management.
	HardwareSupport string `xml:"hardwareSupport,omitempty" json:"hardwareSupport,omitempty"`
}

func init() {
	t["HostCpuPowerManagementInfo"] = reflect.TypeOf((*HostCpuPowerManagementInfo)(nil)).Elem()
}

// This data object describes the information related to the CPU scheduler
// running on the Host.
type HostCpuSchedulerInfo struct {
	DynamicData

	// The `policy` active for CPU Scheduling.
	Policy string `xml:"policy" json:"policy"`
}

func init() {
	t["HostCpuSchedulerInfo"] = reflect.TypeOf((*HostCpuSchedulerInfo)(nil)).Elem()
	minAPIVersionForType["HostCpuSchedulerInfo"] = "8.0.3.0"
}

// The parameters of `HostVStorageObjectManager.HostCreateDisk_Task`.
type HostCreateDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specification of the virtual storage object
	// to be created.
	// 2
	Spec VslmCreateSpec `xml:"spec" json:"spec"`
}

func init() {
	t["HostCreateDiskRequestType"] = reflect.TypeOf((*HostCreateDiskRequestType)(nil)).Elem()
}

type HostCreateDisk_Task HostCreateDiskRequestType

func init() {
	t["HostCreateDisk_Task"] = reflect.TypeOf((*HostCreateDisk_Task)(nil)).Elem()
}

type HostCreateDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This event records when HA has been disabled on a host.
type HostDasDisabledEvent struct {
	HostEvent
}

func init() {
	t["HostDasDisabledEvent"] = reflect.TypeOf((*HostDasDisabledEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, the event is no longer relevant.
//
// This event records when HA is being disabled on a host.
type HostDasDisablingEvent struct {
	HostEvent
}

func init() {
	t["HostDasDisablingEvent"] = reflect.TypeOf((*HostDasDisablingEvent)(nil)).Elem()
}

// This event records when HA has been enabled on a host.
type HostDasEnabledEvent struct {
	HostEvent
}

func init() {
	t["HostDasEnabledEvent"] = reflect.TypeOf((*HostDasEnabledEvent)(nil)).Elem()
}

// This event records when HA is being enabled on a host.
type HostDasEnablingEvent struct {
	HostEvent
}

func init() {
	t["HostDasEnablingEvent"] = reflect.TypeOf((*HostDasEnablingEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, the Server will generate the `EventEx` event
// with the `EventEx.eventTypeId` property set to "com.vmware.vc.HA.HostAgentErrorEvent".
//
// This event records when there is a HA error on a host.
type HostDasErrorEvent struct {
	HostEvent

	Message string `xml:"message,omitempty" json:"message,omitempty"`
	// The reason for the failure.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["HostDasErrorEvent"] = reflect.TypeOf((*HostDasErrorEvent)(nil)).Elem()
}

// Top-level event for host DAS events to extend.
type HostDasEvent struct {
	HostEvent
}

func init() {
	t["HostDasEvent"] = reflect.TypeOf((*HostDasEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, the event is no longer relevant.
//
// This event records when HA on a host returns to normal after an error.
type HostDasOkEvent struct {
	HostEvent
}

func init() {
	t["HostDasOkEvent"] = reflect.TypeOf((*HostDasOkEvent)(nil)).Elem()
}

// DataTransportConnectionInfo contains common information about data transport
// connections on a host.
type HostDataTransportConnectionInfo struct {
	DynamicData

	// Static memory consumption by a connection in bytes like buffer sizes, heap sizes, etc.
	StaticMemoryConsumed int64 `xml:"staticMemoryConsumed" json:"staticMemoryConsumed"`
}

func init() {
	t["HostDataTransportConnectionInfo"] = reflect.TypeOf((*HostDataTransportConnectionInfo)(nil)).Elem()
	minAPIVersionForType["HostDataTransportConnectionInfo"] = "7.0.3.0"
}

// This data object type contains the results of a search method for one datastore.
//
// A
// search method typically returns a set of these objects as an array.
type HostDatastoreBrowserSearchResults struct {
	DynamicData

	// Datastore contains the results.
	//
	// Refers instance of `Datastore`.
	Datastore *ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty"`
	// Relative path to the top-level folder.
	FolderPath string `xml:"folderPath,omitempty" json:"folderPath,omitempty"`
	// Set of matching files, if any.
	File []BaseFileInfo `xml:"file,omitempty,typeattr" json:"file,omitempty"`
}

func init() {
	t["HostDatastoreBrowserSearchResults"] = reflect.TypeOf((*HostDatastoreBrowserSearchResults)(nil)).Elem()
}

// The data object type describes a search for files in one or more datastores.
//
// The
// properties do not include the starting datastore path because that path is a
// separate parameter to the search method.
//
// A SearchSpec contains the query parameters and some global search modifiers.
type HostDatastoreBrowserSearchSpec struct {
	DynamicData

	// The set of file types to match, search criteria specific to the file type, and
	// the amount of detail for a file.
	//
	// These search parameters are specific to a file
	// type, meaning that they can be specified only if the file type to which they
	// are associated is in the set. A file type cannot appear more than once in the
	// set.
	//
	// If this query object is not present, then all files providing only file level
	// details are matched.
	Query []BaseFileQuery `xml:"query,omitempty,typeattr" json:"query,omitempty"`
	// This object comprises a set of booleans that describe what details to return
	// for each file.
	//
	// The file level details apply globally to all matched files.
	Details *FileQueryFlags `xml:"details,omitempty" json:"details,omitempty"`
	// This flag indicates whether or not to search using a case insensitive match on
	// type.
	//
	// In general the algorithm used to match file types relies on file
	// extensions. Although the specific file extensions used are encapsulated by this
	// API, clients are still allowed to modify the filtering behavior.
	//
	// By default, the DatastoreBrowser uses a platform-consistent algorithm to
	// determine if a file is of a type. Specifically on Linux, where case is
	// important, the search is case sensitive. On Windows, case is not important, so
	// the search is case insensitive.
	//
	// In an environment with heterogenous platforms, being platform-consistent may
	// not be desirable. As a result, the default behavior can be overridden by
	// setting this optional flag.
	SearchCaseInsensitive *bool `xml:"searchCaseInsensitive" json:"searchCaseInsensitive,omitempty"`
	// Specifies a list of file patterns that must match for a file to be returned.
	//
	// This search property is a filter that applies globally so that only files
	// matching the specified patterns are returned, regardless of the other search
	// parameters.
	MatchPattern []string `xml:"matchPattern,omitempty" json:"matchPattern,omitempty"`
	// By default, files are sorted in alphabetical order regardless of file type.
	//
	// If
	// this flag is set to "true", folders are placed at the start of the list of
	// results in alphabetical order. The remaining files follow in alphabetical
	// order.
	SortFoldersFirst *bool `xml:"sortFoldersFirst" json:"sortFoldersFirst,omitempty"`
}

func init() {
	t["HostDatastoreBrowserSearchSpec"] = reflect.TypeOf((*HostDatastoreBrowserSearchSpec)(nil)).Elem()
}

// The base data object type for information about datastores on the host.
type HostDatastoreConnectInfo struct {
	DynamicData

	// Basic datastore information.
	//
	// The managed object reference is not set.
	Summary DatastoreSummary `xml:"summary" json:"summary"`
}

func init() {
	t["HostDatastoreConnectInfo"] = reflect.TypeOf((*HostDatastoreConnectInfo)(nil)).Elem()
}

// This data object type describes a datastore on the host that matches an existing
// datastore on VirtualCenter that has a different name.
type HostDatastoreExistsConnectInfo struct {
	HostDatastoreConnectInfo

	// The name of a matching datastore on VirtualCenter.
	//
	// The datastore on the host
	// will be renamed to this name.
	NewDatastoreName string `xml:"newDatastoreName" json:"newDatastoreName"`
}

func init() {
	t["HostDatastoreExistsConnectInfo"] = reflect.TypeOf((*HostDatastoreExistsConnectInfo)(nil)).Elem()
}

// This data object type describes a datastore on the host that has the same name as
// a different datastore on VirtualCenter.
type HostDatastoreNameConflictConnectInfo struct {
	HostDatastoreConnectInfo

	// To resolve a conflict with existing datastores, a suggested new name of the
	// datastore can be provided.
	NewDatastoreName string `xml:"newDatastoreName" json:"newDatastoreName"`
}

func init() {
	t["HostDatastoreNameConflictConnectInfo"] = reflect.TypeOf((*HostDatastoreNameConflictConnectInfo)(nil)).Elem()
}

// Capability vector indicating the available product features.
type HostDatastoreSystemCapabilities struct {
	DynamicData

	// Indicates whether mounting the NFS volume is required to be done as part
	// of NAS datastore creation.
	//
	// If this is set to true, then NAS datastores
	// cannot be created for currently mounted NFS volumes.
	NfsMountCreationRequired bool `xml:"nfsMountCreationRequired" json:"nfsMountCreationRequired"`
	// Indicates whether mounting an NFS volume is supported
	// when a NAS datastore is created.
	//
	// If this option is false,
	// then NAS datastores corresponding to NFS volumes can be created
	// only for already mounted NFS volumes.
	NfsMountCreationSupported bool `xml:"nfsMountCreationSupported" json:"nfsMountCreationSupported"`
	// Indicates whether local datastores are supported.
	LocalDatastoreSupported bool `xml:"localDatastoreSupported" json:"localDatastoreSupported"`
	// Indicates whether vmfs extent expansion is supported.
	VmfsExtentExpansionSupported *bool `xml:"vmfsExtentExpansionSupported" json:"vmfsExtentExpansionSupported,omitempty"`
}

func init() {
	t["HostDatastoreSystemCapabilities"] = reflect.TypeOf((*HostDatastoreSystemCapabilities)(nil)).Elem()
}

// Contains result of remove datastore request.
//
// Used as return value
// by `HostDatastoreSystem.RemoveDatastoreEx_Task`
type HostDatastoreSystemDatastoreResult struct {
	DynamicData

	// Datastore removed
	//
	// Refers instance of `Datastore`.
	Key ManagedObjectReference `xml:"key" json:"key"`
	// Fault if removal fails
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["HostDatastoreSystemDatastoreResult"] = reflect.TypeOf((*HostDatastoreSystemDatastoreResult)(nil)).Elem()
}

// Specification for creating Virtual Volumed based datastore.
type HostDatastoreSystemVvolDatastoreSpec struct {
	DynamicData

	// Name of the datastore.
	Name string `xml:"name" json:"name"`
	// Storage contained Id.
	//
	// This is used to retrieve configuration of the
	// storage container from SMS.
	ScId string `xml:"scId" json:"scId"`
}

func init() {
	t["HostDatastoreSystemVvolDatastoreSpec"] = reflect.TypeOf((*HostDatastoreSystemVvolDatastoreSpec)(nil)).Elem()
}

// This data object represents the dateTime configuration of the host.
type HostDateTimeConfig struct {
	DynamicData

	// The time zone of the host.
	//
	// Must be one of the values of
	// `HostDateTimeSystemTimeZone.key`
	TimeZone string `xml:"timeZone,omitempty" json:"timeZone,omitempty"`
	// The NTP configuration on the host.
	NtpConfig *HostNtpConfig `xml:"ntpConfig,omitempty" json:"ntpConfig,omitempty"`
	// The PTP configuration on the host.
	PtpConfig *HostPtpConfig `xml:"ptpConfig,omitempty" json:"ptpConfig,omitempty" vim:"7.0.3.0"`
	// Specify which network time configuration to discipline vmkernel clock.
	//
	// See `HostDateTimeInfoProtocol_enum` for supported values.
	Protocol string `xml:"protocol,omitempty" json:"protocol,omitempty" vim:"7.0.3.0"`
	// Bring Time services subsystem up or down.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty" vim:"7.0.3.0"`
	// When Network Time service or Precision Time service are enabled
	// any detecteced failures will result in Events being sent to
	// Virtual Center.
	//
	// Use this setting to disable Time Events.
	DisableEvents *bool `xml:"disableEvents" json:"disableEvents,omitempty" vim:"7.0.3.0"`
	// When in PrecisionTimeSync, NTP configuration as set will be
	// running as backup.
	//
	// Use this setting to prevent NTP from becoming
	// the primary time protocol in the event of a PTP service failure.
	DisableFallback *bool `xml:"disableFallback" json:"disableFallback,omitempty" vim:"7.0.3.0"`
	// When this property is present and set true the existing
	// configuration for Time Services will be reset to factory default.
	//
	// The protocol property when set defines the scope of what is reset.
	// If additional configuration beyond protocol is provided host
	// will first perform factory reset followed by applying any configuration
	// present.
	ResetToFactoryDefaults *bool `xml:"resetToFactoryDefaults" json:"resetToFactoryDefaults,omitempty" vim:"7.0.3.0"`
}

func init() {
	t["HostDateTimeConfig"] = reflect.TypeOf((*HostDateTimeConfig)(nil)).Elem()
}

// This data object represents the dateTime configuration of the host.
type HostDateTimeInfo struct {
	DynamicData

	// The time zone of the host.
	TimeZone HostDateTimeSystemTimeZone `xml:"timeZone" json:"timeZone"`
	// The system clock synchronization protocol.
	//
	// See `HostDateTimeInfoProtocol_enum` for possible values.
	SystemClockProtocol string `xml:"systemClockProtocol,omitempty" json:"systemClockProtocol,omitempty"`
	// The NTP configuration on the host.
	NtpConfig *HostNtpConfig `xml:"ntpConfig,omitempty" json:"ntpConfig,omitempty"`
	// The PTP configuration on the host.
	PtpConfig *HostPtpConfig `xml:"ptpConfig,omitempty" json:"ptpConfig,omitempty" vim:"7.0.3.0"`
	// Present state of the time services subsystem.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty" vim:"7.0.3.0"`
	// When not disabled Network Time service or Precision Time service
	// will send events to Virtual Center when service fails or recovers.
	DisableEvents *bool `xml:"disableEvents" json:"disableEvents,omitempty" vim:"7.0.3.0"`
	// When not disabled, if PrecisionTimeSync is configured, then the
	// NTP configuration can run as backup.
	DisableFallback *bool `xml:"disableFallback" json:"disableFallback,omitempty" vim:"7.0.3.0"`
	// Tracks if NTP is providing time to ESXi due to PTP service failure.
	//
	// This is set only if disableFallback is set to false.
	InFallbackState *bool `xml:"inFallbackState" json:"inFallbackState,omitempty" vim:"7.0.3.0"`
	// Report true if time is synchronized with remote time source
	// For PrecisionTimeSync this is obtained from PTP Port Status value.
	//
	// For NetworkTimeProtocol this obtained from Leap Indicator value.
	ServiceSync *bool `xml:"serviceSync" json:"serviceSync,omitempty" vim:"7.0.3.0"`
	// Timestamp when time services were last in sync with remote clock.
	//
	// If not set, time services have never established synchronization.
	LastSyncTime *time.Time `xml:"lastSyncTime" json:"lastSyncTime,omitempty" vim:"7.0.3.0"`
	// Provides the NTP server that the host is synced with from the
	// set of servers configured.
	RemoteNtpServer string `xml:"remoteNtpServer,omitempty" json:"remoteNtpServer,omitempty" vim:"7.0.3.0"`
	// Provides the total seconds ntpd process has been running for.
	NtpRunTime int64 `xml:"ntpRunTime,omitempty" json:"ntpRunTime,omitempty" vim:"7.0.3.0"`
	// Provides the total seconds ptpd process has been running for.
	PtpRunTime int64 `xml:"ptpRunTime,omitempty" json:"ptpRunTime,omitempty" vim:"7.0.3.0"`
	// Provides a duration in simplified, human-readable form
	// for the lifetime of the ntp service.
	NtpDuration string `xml:"ntpDuration,omitempty" json:"ntpDuration,omitempty" vim:"7.0.3.0"`
	// Provides a duration in simplified, human-readable form
	// for the lifetime of the ptp service.
	PtpDuration string `xml:"ptpDuration,omitempty" json:"ptpDuration,omitempty" vim:"7.0.3.0"`
}

func init() {
	t["HostDateTimeInfo"] = reflect.TypeOf((*HostDateTimeInfo)(nil)).Elem()
}

type HostDateTimeSystemServiceTestResult struct {
	DynamicData

	// Value is true if time services are presently working normally.
	WorkingNormally bool `xml:"workingNormally" json:"workingNormally"`
	// Returns details of the checks done to verify time services are working.
	Report []string `xml:"report,omitempty" json:"report,omitempty"`
}

func init() {
	t["HostDateTimeSystemServiceTestResult"] = reflect.TypeOf((*HostDateTimeSystemServiceTestResult)(nil)).Elem()
	minAPIVersionForType["HostDateTimeSystemServiceTestResult"] = "7.0.3.0"
}

type HostDateTimeSystemTimeZone struct {
	DynamicData

	// The identifier for the time zone.
	Key string `xml:"key" json:"key"`
	// The time zone name.
	Name string `xml:"name" json:"name"`
	// Description of the time zone.
	Description string `xml:"description" json:"description"`
	// The GMT offset in seconds that is currently applicable to the timezone
	// (with respect to the current time on the host).
	GmtOffset int32 `xml:"gmtOffset" json:"gmtOffset"`
}

func init() {
	t["HostDateTimeSystemTimeZone"] = reflect.TypeOf((*HostDateTimeSystemTimeZone)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostDeleteVStorageObjectEx_Task`.
type HostDeleteVStorageObjectExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object to be deleted.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual storage object is
	// located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["HostDeleteVStorageObjectExRequestType"] = reflect.TypeOf((*HostDeleteVStorageObjectExRequestType)(nil)).Elem()
	minAPIVersionForType["HostDeleteVStorageObjectExRequestType"] = "7.0.2.0"
}

type HostDeleteVStorageObjectEx_Task HostDeleteVStorageObjectExRequestType

func init() {
	t["HostDeleteVStorageObjectEx_Task"] = reflect.TypeOf((*HostDeleteVStorageObjectEx_Task)(nil)).Elem()
}

type HostDeleteVStorageObjectEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostVStorageObjectManager.HostDeleteVStorageObject_Task`.
type HostDeleteVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object to be deleted.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual storage object is
	// located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["HostDeleteVStorageObjectRequestType"] = reflect.TypeOf((*HostDeleteVStorageObjectRequestType)(nil)).Elem()
}

type HostDeleteVStorageObject_Task HostDeleteVStorageObjectRequestType

func init() {
	t["HostDeleteVStorageObject_Task"] = reflect.TypeOf((*HostDeleteVStorageObject_Task)(nil)).Elem()
}

type HostDeleteVStorageObject_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Data object describing the deployment information for a host.
type HostDeploymentInfo struct {
	DynamicData

	// Flag indicating if the host was booted from stateless cache.
	BootedFromStatelessCache *bool `xml:"bootedFromStatelessCache" json:"bootedFromStatelessCache,omitempty"`
}

func init() {
	t["HostDeploymentInfo"] = reflect.TypeOf((*HostDeploymentInfo)(nil)).Elem()
}

// This data object type defines a device on the host.
type HostDevice struct {
	DynamicData

	// The name of the device on the host.
	//
	// For example,
	// /dev/cdrom or \\\\serverX\\device\_name.
	DeviceName string `xml:"deviceName" json:"deviceName"`
	// Device type when available:
	// floppy, mouse, cdrom, disk, scsi device, or adapter.
	DeviceType string `xml:"deviceType" json:"deviceType"`
}

func init() {
	t["HostDevice"] = reflect.TypeOf((*HostDevice)(nil)).Elem()
}

// A dynamic host control protocol (DHCP) service instance serves IP
// addresses to a single virtual network subnet.
//
// The instances may
// be handled collectively by a single server. This decision can
// be made during implementation.
type HostDhcpService struct {
	DynamicData

	// The instance ID of the DHCP service.
	Key string `xml:"key" json:"key"`
	// Configurable properties for the DHCP service.
	Spec HostDhcpServiceSpec `xml:"spec" json:"spec"`
}

func init() {
	t["HostDhcpService"] = reflect.TypeOf((*HostDhcpService)(nil)).Elem()
}

// This data object type describes the configuration of a DHCP service
// instance representing both the configured properties
// on the instance and identification information.
type HostDhcpServiceConfig struct {
	DynamicData

	// Indicates the change operation to apply on this configuration
	// specification.
	//
	// See also `HostConfigChangeOperation_enum`.
	ChangeOperation string `xml:"changeOperation,omitempty" json:"changeOperation,omitempty"`
	// The instance ID of the DHCP service.
	Key string `xml:"key" json:"key"`
	// Specification of the DHCP service.
	Spec HostDhcpServiceSpec `xml:"spec" json:"spec"`
}

func init() {
	t["HostDhcpServiceConfig"] = reflect.TypeOf((*HostDhcpServiceConfig)(nil)).Elem()
}

type HostDhcpServiceSpec struct {
	DynamicData

	// The name of the virtual switch to which DHCP service is connected.
	VirtualSwitch string `xml:"virtualSwitch" json:"virtualSwitch"`
	// The default DHCP lease duration (minutes).
	DefaultLeaseDuration int32 `xml:"defaultLeaseDuration" json:"defaultLeaseDuration"`
	// The start of the IP address range served by the DHCP service.
	LeaseBeginIp string `xml:"leaseBeginIp" json:"leaseBeginIp"`
	// The end of the IP address range served by the DHCP service.
	LeaseEndIp string `xml:"leaseEndIp" json:"leaseEndIp"`
	// The maximum DHCP lease duration (minutes).
	MaxLeaseDuration int32 `xml:"maxLeaseDuration" json:"maxLeaseDuration"`
	// A flag to indicate whether or not unlimited DHCP lease
	// durations are allowed.
	UnlimitedLease bool `xml:"unlimitedLease" json:"unlimitedLease"`
	// Subnet served by DHCP service.
	IpSubnetAddr string `xml:"ipSubnetAddr" json:"ipSubnetAddr"`
	// Subnet mask of network served by DHCP service.
	IpSubnetMask string `xml:"ipSubnetMask" json:"ipSubnetMask"`
}

func init() {
	t["HostDhcpServiceSpec"] = reflect.TypeOf((*HostDhcpServiceSpec)(nil)).Elem()
}

// This data object type contains information about an available or active
// diagnostic partition.
type HostDiagnosticPartition struct {
	DynamicData

	// Indicates the storage type of the diagnostic partition.
	//
	// See also `DiagnosticPartitionStorageType_enum`.
	StorageType string `xml:"storageType" json:"storageType"`
	// Indicates the type of the diagnostic partition.
	//
	// See also `DiagnosticPartitionType_enum`.
	DiagnosticType string `xml:"diagnosticType" json:"diagnosticType"`
	// The number of slots in the diagnostic partition.
	Slots int32 `xml:"slots" json:"slots"`
	// Diagnostic partition identification information.
	Id HostScsiDiskPartition `xml:"id" json:"id"`
}

func init() {
	t["HostDiagnosticPartition"] = reflect.TypeOf((*HostDiagnosticPartition)(nil)).Elem()
}

// The diagnostic partition create description details what will be done
// to create a new diagnostic partition on a disk.
//
// It contains a CreateSpec
// that can be submitted to create the partition and information that can
// be shown to the user.
type HostDiagnosticPartitionCreateDescription struct {
	DynamicData

	// Layout describing the format of the disk
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	//
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	Layout HostDiskPartitionLayout `xml:"layout" json:"layout"`
	// The UUID of the SCSI disk on which to create the diagnostic partition.
	//
	// This disk UUID will match that found in the identification field of the
	// creation spec.
	//
	// See also `HostScsiDisk`, `ScsiLun.uuid`.
	DiskUuid string `xml:"diskUuid" json:"diskUuid"`
	// Creation specification for diagnostic partition
	Spec HostDiagnosticPartitionCreateSpec `xml:"spec" json:"spec"`
}

func init() {
	t["HostDiagnosticPartitionCreateDescription"] = reflect.TypeOf((*HostDiagnosticPartitionCreateDescription)(nil)).Elem()
}

// This data object describes a disk that can be used to create a
// diagnostic partition.
type HostDiagnosticPartitionCreateOption struct {
	DynamicData

	// Indicates the storage type of diagnostic partition to be created.
	//
	// See also `DiagnosticPartitionStorageType_enum`.
	StorageType string `xml:"storageType" json:"storageType"`
	// Indicates the type of the diagnostic partition to be created.
	//
	// See also `DiagnosticPartitionType_enum`.
	DiagnosticType string `xml:"diagnosticType" json:"diagnosticType"`
	// The disk which has sufficient free space to contain a diagnostic
	// partition.
	Disk HostScsiDisk `xml:"disk" json:"disk"`
}

func init() {
	t["HostDiagnosticPartitionCreateOption"] = reflect.TypeOf((*HostDiagnosticPartitionCreateOption)(nil)).Elem()
}

// The diagnostic create specification is used by the system to create a new
// diagnostic partition on a SCSI disk.
type HostDiagnosticPartitionCreateSpec struct {
	DynamicData

	// Indicates the storage type where the diagnostic partition
	// will be created.
	//
	// See also `DiagnosticPartitionStorageType_enum`.
	StorageType string `xml:"storageType" json:"storageType"`
	// Indicates the type of the diagnostic partition to be created.
	//
	// See also `DiagnosticPartitionType_enum`.
	DiagnosticType string `xml:"diagnosticType" json:"diagnosticType"`
	// Diagnostic partition identification information.
	Id HostScsiDiskPartition `xml:"id" json:"id"`
	// Partitioning specification.
	Partition HostDiskPartitionSpec `xml:"partition" json:"partition"`
	// Indicates if the created diagnostic partition should be made the
	// active diagnostic partition.
	//
	// If not supplied, the system will
	// decide whether or not the created specification is active.
	Active *bool `xml:"active" json:"active,omitempty"`
}

func init() {
	t["HostDiagnosticPartitionCreateSpec"] = reflect.TypeOf((*HostDiagnosticPartitionCreateSpec)(nil)).Elem()
}

// This data object type describes the digest information
type HostDigestInfo struct {
	DynamicData

	// Method in which the digest value is calculated.
	//
	// The set of possible
	// values is described in `HostDigestInfoDigestMethodType_enum`.
	DigestMethod string `xml:"digestMethod" json:"digestMethod"`
	// The variable length byte array containing the digest value calculated by
	// the specified digestMethod.
	DigestValue ByteSlice `xml:"digestValue" json:"digestValue"`
	// The name of the object from which this digest value is calcaulated.
	ObjectName string `xml:"objectName,omitempty" json:"objectName,omitempty"`
}

func init() {
	t["HostDigestInfo"] = reflect.TypeOf((*HostDigestInfo)(nil)).Elem()
}

// `HostDirectoryStoreInfo` is a base class for objects that
// provide information about directory-based authentication stores.
type HostDirectoryStoreInfo struct {
	HostAuthenticationStoreInfo
}

func init() {
	t["HostDirectoryStoreInfo"] = reflect.TypeOf((*HostDirectoryStoreInfo)(nil)).Elem()
}

// This event records a disconnection from a host.
type HostDisconnectedEvent struct {
	HostEvent

	// Reason why the host was disconnected.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["HostDisconnectedEvent"] = reflect.TypeOf((*HostDisconnectedEvent)(nil)).Elem()
}

// Disk configuration result returns success or fault of the
// operation on the disk.
type HostDiskConfigurationResult struct {
	DynamicData

	// The device path.
	//
	// See `ScsiDisk`
	DevicePath string `xml:"devicePath,omitempty" json:"devicePath,omitempty"`
	// Flag to indicate if the operation is successful
	Success *bool `xml:"success" json:"success,omitempty"`
	// 'fault' would be set if the operation was not successful
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["HostDiskConfigurationResult"] = reflect.TypeOf((*HostDiskConfigurationResult)(nil)).Elem()
}

// This data object type describes multiple coordinate systems
// used to refer to a location or size on a disk.
type HostDiskDimensions struct {
	DynamicData
}

func init() {
	t["HostDiskDimensions"] = reflect.TypeOf((*HostDiskDimensions)(nil)).Elem()
}

// This data object type describes dimensions using the cylinder,
// head, sector (CHS) coordinate system.
//
// This coordinate system
// is generally needed for partitioning for legacy reasons. When defining
// partitions, many partitioning utilities do not function correctly when
// certain CHS constraints are not met.
type HostDiskDimensionsChs struct {
	DynamicData

	// The number of cylinders.
	Cylinder int64 `xml:"cylinder" json:"cylinder"`
	// The number of heads per cylinders.
	Head int32 `xml:"head" json:"head"`
	// The number of sectors per head.
	Sector int32 `xml:"sector" json:"sector"`
}

func init() {
	t["HostDiskDimensionsChs"] = reflect.TypeOf((*HostDiskDimensionsChs)(nil)).Elem()
}

// This data object type describes the logical block addressing system
// that uses block numbers and block sizes to refer to a block.
//
// This
// scheme is employed by SCSI. If a SCSI disk is not involved,
// then blockSize is 512 bytes.
type HostDiskDimensionsLba struct {
	DynamicData

	// The size of the blocks.
	BlockSize int32 `xml:"blockSize" json:"blockSize"`
	// The number of blocks.
	Block int64 `xml:"block" json:"block"`
}

func init() {
	t["HostDiskDimensionsLba"] = reflect.TypeOf((*HostDiskDimensionsLba)(nil)).Elem()
}

// The HostDiskMappingInfo data object type describes
// a virtual disk mapping to a host disk.
type HostDiskMappingInfo struct {
	DynamicData

	// The partition used on the host, if not mapping
	// to a full disk device.
	PhysicalPartition *HostDiskMappingPartitionInfo `xml:"physicalPartition,omitempty" json:"physicalPartition,omitempty"`
	// Host resource name.
	Name string `xml:"name" json:"name"`
	// Flag to indicate whether or not the virtual machine has exclusive access
	// to the host device.
	Exclusive *bool `xml:"exclusive" json:"exclusive,omitempty"`
}

func init() {
	t["HostDiskMappingInfo"] = reflect.TypeOf((*HostDiskMappingInfo)(nil)).Elem()
}

// The HostDiskMappingOption data object type describes
// the options for a virtual disk mapping to a host disk.
type HostDiskMappingOption struct {
	DynamicData

	// Array of valid partitions on this physical disk.
	//
	// There is no default for this array.
	PhysicalPartition []HostDiskMappingPartitionOption `xml:"physicalPartition,omitempty" json:"physicalPartition,omitempty"`
	// Host resource name.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["HostDiskMappingOption"] = reflect.TypeOf((*HostDiskMappingOption)(nil)).Elem()
}

// The PhysicalPartitionInfo data class.
type HostDiskMappingPartitionInfo struct {
	DynamicData

	// Partition name.
	Name string `xml:"name" json:"name"`
	// Filesystem, if the partition is formatted.
	FileSystem string `xml:"fileSystem" json:"fileSystem"`
	// Partition capacity, in KB.
	CapacityInKb int64 `xml:"capacityInKb" json:"capacityInKb"`
}

func init() {
	t["HostDiskMappingPartitionInfo"] = reflect.TypeOf((*HostDiskMappingPartitionInfo)(nil)).Elem()
}

// The PhysicalPartitionOption data class contains the options
// for a partition on a physical disk.
type HostDiskMappingPartitionOption struct {
	DynamicData

	// Partition name.
	Name string `xml:"name" json:"name"`
	// File system, if the partition is formatted.
	FileSystem string `xml:"fileSystem" json:"fileSystem"`
	// Partition capacity, in KB.
	CapacityInKb int64 `xml:"capacityInKb" json:"capacityInKb"`
}

func init() {
	t["HostDiskMappingPartitionOption"] = reflect.TypeOf((*HostDiskMappingPartitionOption)(nil)).Elem()
}

// Information about a single disk partition.
//
// A partition is a contiguous
// set of blocks on a disk that is marked for use. The typeId identifies
// the purpose of the data in the partition.
type HostDiskPartitionAttributes struct {
	DynamicData

	// The partition number.
	//
	// Must be a positive integer.
	Partition int32 `xml:"partition" json:"partition"`
	// The start sector.
	StartSector int64 `xml:"startSector" json:"startSector"`
	// The end sector.
	EndSector int64 `xml:"endSector" json:"endSector"`
	// Type of data in the partition.
	//
	// If it is a well-known partition type,
	// it will be one of the defined types. If it is not, then it will be
	// reported as a hexadecimal number. For example, "none", "vmfs", "linux",
	// and "0x20" are all valid values.
	//
	// See also `HostDiskPartitionInfoType_enum`.
	Type string `xml:"type" json:"type"`
	// Globally Unique Identifier of the partition, as defined by the GUID
	// Partition Table (GPT) format.
	//
	// This is available only for GPT formatted
	// disks.
	Guid string `xml:"guid,omitempty" json:"guid,omitempty"`
	// The flag to indicate whether or not the partition is
	// logical.
	//
	// If true, the partition
	// number should be greater than 4.
	Logical bool `xml:"logical" json:"logical"`
	// The attributes on the partition.
	Attributes byte `xml:"attributes" json:"attributes"`
	// Partition alignment in bytes.
	//
	// If unset, partition alignment value is unknown.
	PartitionAlignment int64 `xml:"partitionAlignment,omitempty" json:"partitionAlignment,omitempty"`
}

func init() {
	t["HostDiskPartitionAttributes"] = reflect.TypeOf((*HostDiskPartitionAttributes)(nil)).Elem()
}

// A BlockRange data object type describes a contiguous set of blocks
// on a disk.
//
// A BlockRange may describe either a partition or
// unpartitioned (primordial) blocks on the disk.
type HostDiskPartitionBlockRange struct {
	DynamicData

	// Partition number.
	//
	// This number is a hint from the server indicating
	// what the partition number for this block range is if the range
	// corresponds to a partition. The partition number should correlate to
	// the one in the partition specification. If sent back to the server,
	// this property is ignored.
	Partition int32 `xml:"partition,omitempty" json:"partition,omitempty"`
	// The type of data in the partition.
	//
	// See also `HostDiskPartitionAttributes.type`.
	Type string `xml:"type" json:"type"`
	// The starting block address of the disk range.
	//
	// The block numbers start
	// from zero. The range is inclusive of the end address.
	Start HostDiskDimensionsLba `xml:"start" json:"start"`
	// The end block address of the disk range.
	//
	// The block numbers start
	// from zero. The range is inclusive of the end address.
	End HostDiskDimensionsLba `xml:"end" json:"end"`
}

func init() {
	t["HostDiskPartitionBlockRange"] = reflect.TypeOf((*HostDiskPartitionBlockRange)(nil)).Elem()
}

// Information about the partitions on a disk.
//
// A DiskPartitionInfo object
// provides two different views into the partitions on a disk:
//   - A detailed specification that is used to create the partition
//     table.
//   - A convenient view that shows the allocations
//     of blocks as a contiguous sequence of block ranges.
//
// See also `HostStorageSystem.RetrieveDiskPartitionInfo`, `HostStorageSystem.ComputeDiskPartitionInfo`, `HostStorageSystem.UpdateDiskPartitions`.
type HostDiskPartitionInfo struct {
	DynamicData

	// The device name of the disk to which this partition information
	// corresponds.
	DeviceName string `xml:"deviceName" json:"deviceName"`
	// The detailed disk partition specification.
	//
	// Use this specification for
	// manipulating the file system.
	//
	// See also `HostStorageSystem.RetrieveDiskPartitionInfo`, `HostStorageSystem.UpdateDiskPartitions`.
	Spec HostDiskPartitionSpec `xml:"spec" json:"spec"`
	// A convenient format for describing disk layout.
	//
	// This layout
	// specification can be converted to a Specification object.
	//
	// See also `HostStorageSystem.ComputeDiskPartitionInfo`.
	Layout HostDiskPartitionLayout `xml:"layout" json:"layout"`
}

func init() {
	t["HostDiskPartitionInfo"] = reflect.TypeOf((*HostDiskPartitionInfo)(nil)).Elem()
}

// This data object type describes the disk partition layout
// specified as a list of ordered BlockRanges.
//
// This
// view of the disk partitions shows the data on the disk as a contiguous
// set of BlockRanges.
type HostDiskPartitionLayout struct {
	DynamicData

	// Total number of blocks on a disk.
	Total *HostDiskDimensionsLba `xml:"total,omitempty" json:"total,omitempty"`
	// List of block ranges on the disk.
	Partition []HostDiskPartitionBlockRange `xml:"partition" json:"partition"`
}

func init() {
	t["HostDiskPartitionLayout"] = reflect.TypeOf((*HostDiskPartitionLayout)(nil)).Elem()
}

// This data object type describes the disk partition table
// specification used to configure the partitions on a
// disk.
//
// This data object represents the fundamental data needed to specify
// a partition table.
type HostDiskPartitionSpec struct {
	DynamicData

	// Partition format type on the disk.
	PartitionFormat string `xml:"partitionFormat,omitempty" json:"partitionFormat,omitempty"`
	// Disk dimensions expressed as cylinder, head, sector (CHS)
	// coordinates.
	Chs *HostDiskDimensionsChs `xml:"chs,omitempty" json:"chs,omitempty"`
	// Disk dimensions expressed as a total number of sectors.
	//
	// For sector size, see the `sectorSize` field.
	TotalSectors int64 `xml:"totalSectors,omitempty" json:"totalSectors,omitempty"`
	// List of partitions on the disk.
	Partition []HostDiskPartitionAttributes `xml:"partition,omitempty" json:"partition,omitempty"`
}

func init() {
	t["HostDiskPartitionSpec"] = reflect.TypeOf((*HostDiskPartitionSpec)(nil)).Elem()
}

// This data object type describes the DNS configuration.
//
// All IPv4 addresses, subnet addresses, and netmasks are specified using
// dotted decimal notation. For example, "192.0.2.1".
// IPv6 addresses are 128-bit addresses represented as
// eight fields of up to four hexadecimal digits.
// A colon separates each field (:). For example,
// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
// symbol '::' to represent multiple 16-bit groups of
// contiguous 0's only once in an address as described in RFC 2373.
type HostDnsConfig struct {
	DynamicData

	// The flag to indicate whether or not DHCP (dynamic host control
	// protocol) is used to determine DNS configuration automatically.
	Dhcp bool `xml:"dhcp" json:"dhcp"`
	// If DHCP is enabled, the DHCP DNS of the vmkernel nic will override
	// the system's DNS.
	//
	// This field applies to both IPv4 and IPv6 DNS settings
	// if `ipv6VirtualNicDevice`
	// is unset, otherwise it is applicable only for IPv4 setting.
	// This field is ignored if DHCP is disabled by the
	// `dhcp` property.
	VirtualNicDevice string `xml:"virtualNicDevice,omitempty" json:"virtualNicDevice,omitempty"`
	// If DHCP is enabled, the IPv6 DHCP DNS of the vmkernel nic will override
	// the system's IPv6 DNS.
	//
	// This field is ignored if DHCP is disabled by the
	// `dhcp` property.
	Ipv6VirtualNicDevice string `xml:"ipv6VirtualNicDevice,omitempty" json:"ipv6VirtualNicDevice,omitempty"`
	// The host name portion of DNS name.
	//
	// For example, "esx01".
	//
	// `*Note*`: When DHCP is not enabled, the property can be set
	// explicitly. When DHCP is enabled, the property reflects the current
	// DNS configuration, but cannot be set.
	// The hostName can't have character '.' in it when set explicitly.
	HostName string `xml:"hostName" json:"hostName"`
	// The domain name portion of the DNS name.
	//
	// For example, "vmware.com".
	//
	// `*Note*`: When DHCP is not enabled, the property can be set
	// explicitly. When DHCP is enabled, the property reflects the current
	// DNS configuration, but cannot be set.
	DomainName string `xml:"domainName" json:"domainName"`
	// The IP addresses of the DNS servers, placed in order of preference.
	//
	// `*Note*`: When DHCP is not enabled, the property can be set
	// explicitly. When DHCP is enabled, the property reflects the current
	// DNS configuration, but cannot be set.
	Address []string `xml:"address,omitempty" json:"address,omitempty"`
	// The domain in which to search for hosts, placed in order of preference.
	//
	// `*Note*`: When DHCP is not enabled, the property can be set
	// explicitly. When DHCP is enabled, the property reflects the current
	// DNS configuration, but cannot be set.
	SearchDomain []string `xml:"searchDomain,omitempty" json:"searchDomain,omitempty"`
}

func init() {
	t["HostDnsConfig"] = reflect.TypeOf((*HostDnsConfig)(nil)).Elem()
}

// Dataobject for configuring the DNS settings on the host.
type HostDnsConfigSpec struct {
	HostDnsConfig

	// Choose a Virtual nic based on what it is connected to.
	VirtualNicConnection *HostVirtualNicConnection `xml:"virtualNicConnection,omitempty" json:"virtualNicConnection,omitempty"`
	// Choose an IPv6 Virtual nic based on what it is connected to.
	VirtualNicConnectionV6 *HostVirtualNicConnection `xml:"virtualNicConnectionV6,omitempty" json:"virtualNicConnectionV6,omitempty"`
}

func init() {
	t["HostDnsConfigSpec"] = reflect.TypeOf((*HostDnsConfigSpec)(nil)).Elem()
}

// Provides information about a single Device Virtualization Extensions (DVX)
// device class.
type HostDvxClass struct {
	DynamicData

	// The class name.
	DeviceClass string `xml:"deviceClass" json:"deviceClass"`
	// Indicates whether checkpointing is supported.
	CheckpointSupported bool `xml:"checkpointSupported" json:"checkpointSupported"`
	// Indicates whether software Direct Memory Access (DMA)
	// tracing is supported.
	SwDMATracingSupported bool `xml:"swDMATracingSupported" json:"swDMATracingSupported"`
	// Indicates whether the devices of this class are SR-IOV NICs.
	SriovNic bool `xml:"sriovNic" json:"sriovNic"`
}

func init() {
	t["HostDvxClass"] = reflect.TypeOf((*HostDvxClass)(nil)).Elem()
	minAPIVersionForType["HostDvxClass"] = "8.0.0.1"
}

// This event records the failure to restore some of the administrator's permissions.
type HostEnableAdminFailedEvent struct {
	HostEvent

	Permissions []Permission `xml:"permissions" json:"permissions"`
}

func init() {
	t["HostEnableAdminFailedEvent"] = reflect.TypeOf((*HostEnableAdminFailedEvent)(nil)).Elem()
}

// EnterMaintenanceResult is the result returned to the
// `HostSystem.QueryWhatIfEnterMaintenance` method.
type HostEnterMaintenanceResult struct {
	DynamicData

	// VM specific faults that would prevent host from
	// entering maintenance mode.
	VmFaults []FaultsByVM `xml:"vmFaults,omitempty" json:"vmFaults,omitempty"`
	// Host specific faults that would prevent host from
	// entering maintenance mode.
	HostFaults []FaultsByHost `xml:"hostFaults,omitempty" json:"hostFaults,omitempty"`
}

func init() {
	t["HostEnterMaintenanceResult"] = reflect.TypeOf((*HostEnterMaintenanceResult)(nil)).Elem()
}

type HostEsxAgentHostManagerConfigInfo struct {
	DynamicData

	// Datastore used for deploying Agent VMs on this host.
	//
	// Refers instance of `Datastore`.
	AgentVmDatastore *ManagedObjectReference `xml:"agentVmDatastore,omitempty" json:"agentVmDatastore,omitempty"`
	// Management Network for Agent VMs on this host.
	//
	// Refers instance of `Network`.
	AgentVmNetwork *ManagedObjectReference `xml:"agentVmNetwork,omitempty" json:"agentVmNetwork,omitempty"`
}

func init() {
	t["HostEsxAgentHostManagerConfigInfo"] = reflect.TypeOf((*HostEsxAgentHostManagerConfigInfo)(nil)).Elem()
}

// These are host-related events.
type HostEvent struct {
	Event
}

func init() {
	t["HostEvent"] = reflect.TypeOf((*HostEvent)(nil)).Elem()
}

// The event argument is a Host object.
type HostEventArgument struct {
	EntityEventArgument

	// The host object.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["HostEventArgument"] = reflect.TypeOf((*HostEventArgument)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostExtendDisk_Task`.
type HostExtendDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual disk to be extended.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual disk is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The new capacity of the virtual disk in MB.
	NewCapacityInMB int64 `xml:"newCapacityInMB" json:"newCapacityInMB"`
}

func init() {
	t["HostExtendDiskRequestType"] = reflect.TypeOf((*HostExtendDiskRequestType)(nil)).Elem()
}

type HostExtendDisk_Task HostExtendDiskRequestType

func init() {
	t["HostExtendDisk_Task"] = reflect.TypeOf((*HostExtendDisk_Task)(nil)).Elem()
}

type HostExtendDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Deprecated as of vSphere API 5.0, the event is no longer relevant.
//
// This event records the fact that a host has extra networks not used by
// other hosts for HA communication
type HostExtraNetworksEvent struct {
	HostDasEvent

	// The comma-separated list of extra networks
	Ips string `xml:"ips,omitempty" json:"ips,omitempty"`
}

func init() {
	t["HostExtraNetworksEvent"] = reflect.TypeOf((*HostExtraNetworksEvent)(nil)).Elem()
}

// Data structure for component health information of a virtual machine.
type HostFaultToleranceManagerComponentHealthInfo struct {
	DynamicData

	// Whether the virtual machine can access the datastores configured.
	IsStorageHealthy bool `xml:"isStorageHealthy" json:"isStorageHealthy"`
	// Whether the virtual machine can access the VM network configured.
	IsNetworkHealthy bool `xml:"isNetworkHealthy" json:"isNetworkHealthy"`
}

func init() {
	t["HostFaultToleranceManagerComponentHealthInfo"] = reflect.TypeOf((*HostFaultToleranceManagerComponentHealthInfo)(nil)).Elem()
}

// A feature that the host is able to provide at a particular value.
type HostFeatureCapability struct {
	DynamicData

	// Accessor name to the feature capability.
	Key string `xml:"key" json:"key"`
	// Name of the feature.
	//
	// Identical to the key.
	FeatureName string `xml:"featureName" json:"featureName"`
	// Opaque value that the feature is capable at.
	Value string `xml:"value" json:"value"`
}

func init() {
	t["HostFeatureCapability"] = reflect.TypeOf((*HostFeatureCapability)(nil)).Elem()
}

// A mask that is applied to a host feature capability.
type HostFeatureMask struct {
	DynamicData

	// Accessor name to the feature mask.
	Key string `xml:"key" json:"key"`
	// Name of the feature Identical to the key.
	FeatureName string `xml:"featureName" json:"featureName"`
	// Opaque value to change the host feature capability to.
	//
	// Masking operation is contained in the value.
	Value string `xml:"value" json:"value"`
}

func init() {
	t["HostFeatureMask"] = reflect.TypeOf((*HostFeatureMask)(nil)).Elem()
}

// Feature-specific version information for a host
type HostFeatureVersionInfo struct {
	DynamicData

	// A unique key that identifies a feature, list of possible values are
	// specified in `HostFeatureVersionKey_enum`
	Key string `xml:"key" json:"key"`
	// The version string of this feature
	Value string `xml:"value" json:"value"`
}

func init() {
	t["HostFeatureVersionInfo"] = reflect.TypeOf((*HostFeatureVersionInfo)(nil)).Elem()
}

// This data object type describes the Fibre Channel host bus adapter.
type HostFibreChannelHba struct {
	HostHostBusAdapter

	// The world wide port name for the adapter.
	PortWorldWideName int64 `xml:"portWorldWideName" json:"portWorldWideName"`
	// The world wide node name for the adapter.
	NodeWorldWideName int64 `xml:"nodeWorldWideName" json:"nodeWorldWideName"`
	// The type of the fiber channel port.
	PortType FibreChannelPortType `xml:"portType" json:"portType"`
	// The current operating speed of the adapter in
	// bits per second.
	Speed int64 `xml:"speed" json:"speed"`
}

func init() {
	t["HostFibreChannelHba"] = reflect.TypeOf((*HostFibreChannelHba)(nil)).Elem()
}

// This data object type describes the FCoE host bus adapter
// interface.
//
// Terminology is borrowed from T11's working draft of the Fibre Channel
// Backbone 5 standard (FC-BB-5). The draft can be found at
// http://www.t11.org.
type HostFibreChannelOverEthernetHba struct {
	HostFibreChannelHba

	// The name associated with this FCoE HBA's underlying FcoeNic.
	UnderlyingNic string `xml:"underlyingNic" json:"underlyingNic"`
	// Link information that can be used to uniquely identify this FCoE HBA.
	LinkInfo HostFibreChannelOverEthernetHbaLinkInfo `xml:"linkInfo" json:"linkInfo"`
	// True if this host bus adapter is a software based FCoE initiator.
	IsSoftwareFcoe bool `xml:"isSoftwareFcoe" json:"isSoftwareFcoe"`
	// Deprecated as of vSphere API 8.0. Software FCoE not supported.
	//
	// True if this host bus adapter has been marked for removal.
	MarkedForRemoval *bool `xml:"markedForRemoval" json:"markedForRemoval,omitempty"`
}

func init() {
	t["HostFibreChannelOverEthernetHba"] = reflect.TypeOf((*HostFibreChannelOverEthernetHba)(nil)).Elem()
}

// Represents FCoE link information.
//
// The link information represents a VNPort to VFPort Virtual Link, as
// described in the FC-BB-5 standard, with the addition of the VLAN ID
// over which a link exists.
type HostFibreChannelOverEthernetHbaLinkInfo struct {
	DynamicData

	// VNPort MAC address, as defined by the FC-BB-5 standard.
	//
	// This MAC address should be of the form "xx:xx:xx:xx:xx:xx", where
	// 'x' is a hexadecimal digit. Valid MAC addresses are unicast
	// addresses.
	VnportMac string `xml:"vnportMac" json:"vnportMac"`
	// FCF MAC address, also known as the VFPort MAC address in the FC-BB-5
	// standard.
	//
	// This MAC address should be of the form "xx:xx:xx:xx:xx:xx", where
	// 'x' is a hexadecimal digit. Valid MAC addresses are unicast
	// addresses.
	FcfMac string `xml:"fcfMac" json:"fcfMac"`
	// VLAN ID.
	//
	// This field represents the VLAN on which an FCoE HBA was
	// discovered. Valid numbers fall into the range \[0,4094\].
	VlanId int32 `xml:"vlanId" json:"vlanId"`
}

func init() {
	t["HostFibreChannelOverEthernetHbaLinkInfo"] = reflect.TypeOf((*HostFibreChannelOverEthernetHbaLinkInfo)(nil)).Elem()
}

// Fibre Channel Over Ethernet transport information about a SCSI target.
//
// FCoE transport information is that of: the regular FC World Wide Node
// and Port Names; the VNPort MAC address and FCF MAC address which
// constitute a VN\_Port to VF\_Port Virtual Link; and the VLAN on which
// an FCoE target resides.
// More FCoE information can be found in the working draft of the T11's
// Fibre Channel Backbone 5 standard (FC-BB-5). The draft can be found
// at http://www.t11.org.
type HostFibreChannelOverEthernetTargetTransport struct {
	HostFibreChannelTargetTransport

	// VNPort MAC address.
	//
	// This MAC address should be of the form "xx:xx:xx:xx:xx:xx", where
	// 'x' is a hexadecimal digit. Valid MAC addresses are unicast
	// addresses.
	VnportMac string `xml:"vnportMac" json:"vnportMac"`
	// FCF MAC address.
	//
	// This MAC address should be of the form "xx:xx:xx:xx:xx:xx", where
	// 'x' is a hexadecimal digit. Valid MAC addresses are unicast
	// addresses.
	FcfMac string `xml:"fcfMac" json:"fcfMac"`
	// VLAN ID.
	//
	// Valid VLAN IDs fall within the range \[0,4094\].
	VlanId int32 `xml:"vlanId" json:"vlanId"`
}

func init() {
	t["HostFibreChannelOverEthernetTargetTransport"] = reflect.TypeOf((*HostFibreChannelOverEthernetTargetTransport)(nil)).Elem()
}

// Fibre Channel transport information about a SCSI target.
type HostFibreChannelTargetTransport struct {
	HostTargetTransport

	// The world wide port name of the target.
	PortWorldWideName int64 `xml:"portWorldWideName" json:"portWorldWideName"`
	// The world wide node name of the target.
	NodeWorldWideName int64 `xml:"nodeWorldWideName" json:"nodeWorldWideName"`
}

func init() {
	t["HostFibreChannelTargetTransport"] = reflect.TypeOf((*HostFibreChannelTargetTransport)(nil)).Elem()
}

// This data object type contains a single access control
// entry for a file permissions list.
type HostFileAccess struct {
	DynamicData

	// User or group to which the access applies.
	Who string `xml:"who" json:"who"`
	// Rights given to the user or group.
	What string `xml:"what" json:"what"`
}

func init() {
	t["HostFileAccess"] = reflect.TypeOf((*HostFileAccess)(nil)).Elem()
}

// The `HostFileSystemMountInfo` data object describes
// a host mount point for a file system.
type HostFileSystemMountInfo struct {
	DynamicData

	// Information about the mount point.
	MountInfo HostMountInfo `xml:"mountInfo" json:"mountInfo"`
	// Information about the mounted volume.
	Volume BaseHostFileSystemVolume `xml:"volume,typeattr" json:"volume"`
	// vStorage hardware acceleration support status.
	//
	// This property
	// represents the volume's capability for storage acceleration.
	// See `FileSystemMountInfoVStorageSupportStatus_enum` for valid
	// values.
	//
	// If the ESX Server supports hardware acceleration, the Server
	// can offload specific virtual machine management operations
	// to a storage device with the hardware acceleration feature.
	// With hardware assistance, the host performs storage operations
	// faster and consumes less CPU, memory, and storage fabric bandwidth.
	//
	// For vSphere 4.0 or earlier hosts, this value will be unset.
	VStorageSupport string `xml:"vStorageSupport,omitempty" json:"vStorageSupport,omitempty"`
}

func init() {
	t["HostFileSystemMountInfo"] = reflect.TypeOf((*HostFileSystemMountInfo)(nil)).Elem()
}

// Detailed information about a file system.
//
// This is a base type for derived types
// that have more specific details about specific filesystem types.
//
// # Typically a FileSystem is exposed as a datatore
//
// See also `DatastoreInfo`, `HostVmfsVolume`, `HostNasVolume`, `HostVffsVolume`, `HostLocalFileSystemVolume`
//
// However, a FileSystemVolume need not be exposed a datastore., `HostVfatVolume`.
type HostFileSystemVolume struct {
	DynamicData

	// FileSystemType of this particular file system
	// See `HostFileSystemVolumeFileSystemType_enum`
	Type string `xml:"type" json:"type"`
	// Name of the file system volume.
	Name string `xml:"name" json:"name"`
	// The capacity of the file system volume, in bytes.
	Capacity int64 `xml:"capacity" json:"capacity"`
}

func init() {
	t["HostFileSystemVolume"] = reflect.TypeOf((*HostFileSystemVolume)(nil)).Elem()
}

// The `HostFileSystemVolumeInfo` data object describes the file system volume
// information for the host.
//
// A file system volume refers to a storage abstraction that allows files
// to be created and organized. A host can have multiple file system
// volumes. File system volumes are typically mounted into a file namespace
// that allows all files in mounted file systems to be addressable from the
// host.
//
// A file system volume is backed by disk storage. It could span one or more
// disks but need not use an entire disk.
//
// A file system volume by definition must be mounted on the file system
// in order to exist.
type HostFileSystemVolumeInfo struct {
	DynamicData

	// The list of supported file system volume types.
	VolumeTypeList []string `xml:"volumeTypeList,omitempty" json:"volumeTypeList,omitempty"`
	// The list of file system volumes mounted on the host.
	MountInfo []HostFileSystemMountInfo `xml:"mountInfo,omitempty" json:"mountInfo,omitempty"`
}

func init() {
	t["HostFileSystemVolumeInfo"] = reflect.TypeOf((*HostFileSystemVolumeInfo)(nil)).Elem()
}

// DataObject used for firewall configuration
type HostFirewallConfig struct {
	DynamicData

	// Rules determining firewall settings.
	Rule []HostFirewallConfigRuleSetConfig `xml:"rule,omitempty" json:"rule,omitempty"`
	// Default settings for the firewall,
	// used for ports that are not explicitly opened.
	DefaultBlockingPolicy HostFirewallDefaultPolicy `xml:"defaultBlockingPolicy" json:"defaultBlockingPolicy"`
}

func init() {
	t["HostFirewallConfig"] = reflect.TypeOf((*HostFirewallConfig)(nil)).Elem()
}

type HostFirewallConfigRuleSetConfig struct {
	DynamicData

	// Id of the ruleset.
	RulesetId string `xml:"rulesetId" json:"rulesetId"`
	// Flag indicating if the specified ruleset should be enabled.
	Enabled bool `xml:"enabled" json:"enabled"`
	// The list of allowed ip addresses
	AllowedHosts *HostFirewallRulesetIpList `xml:"allowedHosts,omitempty" json:"allowedHosts,omitempty"`
}

func init() {
	t["HostFirewallConfigRuleSetConfig"] = reflect.TypeOf((*HostFirewallConfigRuleSetConfig)(nil)).Elem()
}

// Default settings for the firewall, used for ports
// that are not explicitly opened.
type HostFirewallDefaultPolicy struct {
	DynamicData

	// Flag indicating whether incoming traffic should be blocked by default.
	IncomingBlocked *bool `xml:"incomingBlocked" json:"incomingBlocked,omitempty"`
	// Flag indicating whether outgoing traffic should be blocked by default.
	OutgoingBlocked *bool `xml:"outgoingBlocked" json:"outgoingBlocked,omitempty"`
}

func init() {
	t["HostFirewallDefaultPolicy"] = reflect.TypeOf((*HostFirewallDefaultPolicy)(nil)).Elem()
}

// Data object describing the firewall configuration.
type HostFirewallInfo struct {
	DynamicData

	// Default firewall policy.
	DefaultPolicy HostFirewallDefaultPolicy `xml:"defaultPolicy" json:"defaultPolicy"`
	// List of configured rulesets.
	Ruleset []HostFirewallRuleset `xml:"ruleset,omitempty" json:"ruleset,omitempty"`
}

func init() {
	t["HostFirewallInfo"] = reflect.TypeOf((*HostFirewallInfo)(nil)).Elem()
}

// This data object type describes a port (or range of ports),
// identified by port number(s), direction and protocol.
//
// It is
// used as a convenient way for users to express what ports they
// want to permit through the firewall.
type HostFirewallRule struct {
	DynamicData

	// The port number.
	Port int32 `xml:"port" json:"port"`
	// For a port range, the ending port number.
	EndPort int32 `xml:"endPort,omitempty" json:"endPort,omitempty"`
	// The port direction.
	Direction HostFirewallRuleDirection `xml:"direction" json:"direction"`
	// The port type.
	PortType HostFirewallRulePortType `xml:"portType,omitempty" json:"portType,omitempty"`
	// The port protocol.
	//
	// Valid values are defined by the
	// `HostFirewallRuleProtocol_enum` enumeration.
	Protocol string `xml:"protocol" json:"protocol"`
}

func init() {
	t["HostFirewallRule"] = reflect.TypeOf((*HostFirewallRule)(nil)).Elem()
}

// Data object that describes a single network ruleset that can be
// allowed or blocked by the firewall using the `HostFirewallSystem` object.
type HostFirewallRuleset struct {
	DynamicData

	// Brief identifier for the ruleset.
	Key string `xml:"key" json:"key"`
	// Display label for the ruleset.
	Label string `xml:"label" json:"label"`
	// Flag indicating whether the ruleset is required and cannot be disabled.
	Required bool `xml:"required" json:"required"`
	// List of rules within the ruleset.
	Rule []HostFirewallRule `xml:"rule" json:"rule"`
	// Managed service (if any) that uses this ruleset.
	//
	// Must be one of
	// the services listed in `HostServiceInfo.service`.
	Service string `xml:"service,omitempty" json:"service,omitempty"`
	// Flag indicating whether the ruleset is enabled.
	//
	// If the
	// ruleset is enabled, all ports specified in the ruleset are
	// opened by the firewall.
	Enabled bool `xml:"enabled" json:"enabled"`
	// List of ipaddress to allow access to the service
	AllowedHosts *HostFirewallRulesetIpList `xml:"allowedHosts,omitempty" json:"allowedHosts,omitempty"`
	// Flag indicating whether user can enable/disable the firewall ruleset.
	UserControllable *bool `xml:"userControllable" json:"userControllable,omitempty" vim:"8.0.2.0"`
	// Flag indicating whether user can modify the allowed IP list of the
	// firewall ruleset.
	IpListUserConfigurable *bool `xml:"ipListUserConfigurable" json:"ipListUserConfigurable,omitempty" vim:"8.0.2.0"`
}

func init() {
	t["HostFirewallRuleset"] = reflect.TypeOf((*HostFirewallRuleset)(nil)).Elem()
}

type HostFirewallRulesetIpList struct {
	DynamicData

	// The list of ipAddresses.
	//
	// All IPv4 addresses are specified as strings using dotted
	// decimal format. For example, "192.0.20.10".
	// IPv6 addresses are 128-bit addresses represented
	// as eight fields of up to four hexadecimal digits. A colon separates each
	// field (:). For example, 2001:DB8:101::230:6eff:fe04:d9ff. The address can
	// also consist of symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	IpAddress []string `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
	// The list of networks
	IpNetwork []HostFirewallRulesetIpNetwork `xml:"ipNetwork,omitempty" json:"ipNetwork,omitempty"`
	// Flag indicating whether the ruleset works for all ip addresses.
	AllIp bool `xml:"allIp" json:"allIp"`
}

func init() {
	t["HostFirewallRulesetIpList"] = reflect.TypeOf((*HostFirewallRulesetIpList)(nil)).Elem()
}

type HostFirewallRulesetIpNetwork struct {
	DynamicData

	// The IPv4 or IPv6 network.
	//
	// All IPv4 subnet addresses are specified as strings using dotted
	// decimal format. For example, "192.0.20.0".
	// IPv6 addresses are 128-bit addresses represented
	// as eight fields of up to four hexadecimal digits. A colon separates each
	// field (:). For example, 2001:DB8:101::230:6eff:fe04:d9ff. The address can
	// also consist of symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	Network string `xml:"network" json:"network"`
	// The prefix length for the network.
	//
	// For example the prefix length for a network 10.20.120/22 is 22
	PrefixLength int32 `xml:"prefixLength" json:"prefixLength"`
}

func init() {
	t["HostFirewallRulesetIpNetwork"] = reflect.TypeOf((*HostFirewallRulesetIpNetwork)(nil)).Elem()
}

// The ruleset update specification.
type HostFirewallRulesetRulesetSpec struct {
	DynamicData

	// The list of allowed ip addresses
	AllowedHosts HostFirewallRulesetIpList `xml:"allowedHosts" json:"allowedHosts"`
}

func init() {
	t["HostFirewallRulesetRulesetSpec"] = reflect.TypeOf((*HostFirewallRulesetRulesetSpec)(nil)).Elem()
}

// The FlagInfo data object type encapsulates the flag settings for a host.
//
// These properties are optional since the same structure is used to change
// the values during an edit or create operation.
type HostFlagInfo struct {
	DynamicData

	// Flag to specify whether background snapshots are enabled.
	BackgroundSnapshotsEnabled *bool `xml:"backgroundSnapshotsEnabled" json:"backgroundSnapshotsEnabled,omitempty"`
}

func init() {
	t["HostFlagInfo"] = reflect.TypeOf((*HostFlagInfo)(nil)).Elem()
}

// When the system detects a copy of a VmfsVolume, it will not be
// auto-mounted on the host and it will be detected as
// 'UnresolvedVmfsVolume'.
//
// If user decides to keep the original Uuid and mount it on the host,
// it will have 'forceMounted' flag and 'forceMountedInfo' set.
// 'ForceMountedInfo' provides additional information specific to
// user-mounted VmfsVolume.
type HostForceMountedInfo struct {
	DynamicData

	// Indicates if the vmfsExtent information persistent across
	// host reboots.
	Persist bool `xml:"persist" json:"persist"`
	// Indicates if the volume is currently mounted on the host
	Mounted bool `xml:"mounted" json:"mounted"`
}

func init() {
	t["HostForceMountedInfo"] = reflect.TypeOf((*HostForceMountedInfo)(nil)).Elem()
}

// Data object representing the hardware vendor identity
// for a given hardware component in the host.
type HostFru struct {
	DynamicData

	// Report the FRU type if available `HostFruFruType_enum`
	Type string `xml:"type" json:"type"`
	// Part Name is used for ordering replacement.
	PartName string `xml:"partName" json:"partName"`
	// Part Number is used for ordering replacement.
	PartNumber string `xml:"partNumber" json:"partNumber"`
	// The name of the manufacturer.
	Manufacturer string `xml:"manufacturer" json:"manufacturer"`
	// The serial number of the part.
	SerialNumber string `xml:"serialNumber,omitempty" json:"serialNumber,omitempty"`
	// The time, if any, when this FRU entry was created by manufacturer.
	MfgTimeStamp *time.Time `xml:"mfgTimeStamp" json:"mfgTimeStamp,omitempty"`
}

func init() {
	t["HostFru"] = reflect.TypeOf((*HostFru)(nil)).Elem()
	minAPIVersionForType["HostFru"] = "8.0.0.1"
}

// Deprecated not supported since vSphere 6.5.
//
// Settings for a gateway used to communicate with a host.
type HostGatewaySpec struct {
	DynamicData

	// The type of the gateway used for the communication to the host.
	GatewayType string `xml:"gatewayType" json:"gatewayType"`
	// Identifier of the gateway to be used for communction to the host.
	//
	// If
	// omitted a random gateway of this type will be selected.
	GatewayId string `xml:"gatewayId,omitempty" json:"gatewayId,omitempty"`
	// An opaque string that the gateway may need to validate that the host
	// it connects to is the correct host.
	TrustVerificationToken string `xml:"trustVerificationToken,omitempty" json:"trustVerificationToken,omitempty"`
	// Additional opaque authentication data that the gateway may need to
	// authenticate to the host.
	HostAuthParams []KeyValue `xml:"hostAuthParams,omitempty" json:"hostAuthParams,omitempty"`
}

func init() {
	t["HostGatewaySpec"] = reflect.TypeOf((*HostGatewaySpec)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, the event is no longer relevant.
//
// This event records that hostname -s failed or returned a name containing '.'.
type HostGetShortNameFailedEvent struct {
	HostEvent
}

func init() {
	t["HostGetShortNameFailedEvent"] = reflect.TypeOf((*HostGetShortNameFailedEvent)(nil)).Elem()
}

type HostGetVFlashModuleDefaultConfig HostGetVFlashModuleDefaultConfigRequestType

func init() {
	t["HostGetVFlashModuleDefaultConfig"] = reflect.TypeOf((*HostGetVFlashModuleDefaultConfig)(nil)).Elem()
}

// The parameters of `HostVFlashManager.HostGetVFlashModuleDefaultConfig`.
type HostGetVFlashModuleDefaultConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Name of the vFlash module
	VFlashModule string `xml:"vFlashModule" json:"vFlashModule"`
}

func init() {
	t["HostGetVFlashModuleDefaultConfigRequestType"] = reflect.TypeOf((*HostGetVFlashModuleDefaultConfigRequestType)(nil)).Elem()
}

type HostGetVFlashModuleDefaultConfigResponse struct {
	Returnval VirtualDiskVFlashCacheConfigInfo `xml:"returnval" json:"returnval"`
}

// Data object used for graphics configuration
type HostGraphicsConfig struct {
	DynamicData

	// The host default graphics type.
	//
	// See `HostGraphicsConfigGraphicsType_enum` for list
	// of supported values. This default value can be overridden by specifying
	// graphics type for an individual device. If host supports a single
	// graphics type, specifying an individual graphics device is optional.
	HostDefaultGraphicsType string `xml:"hostDefaultGraphicsType" json:"hostDefaultGraphicsType"`
	// The policy for assigning shared passthrough VMs to a host graphics
	// device.
	//
	// See `HostGraphicsConfigSharedPassthruAssignmentPolicy_enum` for list of
	// supported values.
	SharedPassthruAssignmentPolicy string `xml:"sharedPassthruAssignmentPolicy" json:"sharedPassthruAssignmentPolicy"`
	// Graphics devices and their associated type.
	DeviceType []HostGraphicsConfigDeviceType `xml:"deviceType,omitempty" json:"deviceType,omitempty"`
}

func init() {
	t["HostGraphicsConfig"] = reflect.TypeOf((*HostGraphicsConfig)(nil)).Elem()
}

// A particular graphics device with its associated type and mode.
type HostGraphicsConfigDeviceType struct {
	DynamicData

	// Graphics device identifier (ex.
	//
	// PCI ID).
	DeviceId string `xml:"deviceId" json:"deviceId"`
	// Graphics type for this device.
	//
	// See `HostGraphicsConfigGraphicsType_enum` for list of
	// supported values.
	GraphicsType string `xml:"graphicsType" json:"graphicsType"`
	// vGPU mode for this device.
	//
	// See `HostGraphicsConfigVgpuMode_enum` for list of supported
	// values. If this value is unset, the mode remains unchanged.
	VgpuMode string `xml:"vgpuMode,omitempty" json:"vgpuMode,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["HostGraphicsConfigDeviceType"] = reflect.TypeOf((*HostGraphicsConfigDeviceType)(nil)).Elem()
}

// This data object type describes information about a single
// graphics device.
type HostGraphicsInfo struct {
	DynamicData

	// The device name.
	DeviceName string `xml:"deviceName" json:"deviceName"`
	// The vendor name.
	VendorName string `xml:"vendorName" json:"vendorName"`
	// PCI ID of this device composed of "bus:slot.function".
	PciId string `xml:"pciId" json:"pciId"`
	// Graphics type for this device.
	//
	// See `HostGraphicsInfoGraphicsType_enum` for list
	// of supported values.
	GraphicsType string `xml:"graphicsType" json:"graphicsType"`
	// vGPU mode for this device.
	//
	// See `HostGraphicsInfoVgpuMode_enum` for list of supported
	// values. If vgpuMode is not set, it is treated as value "none".
	VgpuMode string `xml:"vgpuMode,omitempty" json:"vgpuMode,omitempty" vim:"8.0.3.0"`
	// Memory capacity of graphics device or zero if not available.
	MemorySizeInKB int64 `xml:"memorySizeInKB" json:"memorySizeInKB"`
	// Virtual machines using this graphics device.
	//
	// Refers instances of `VirtualMachine`.
	Vm []ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
}

func init() {
	t["HostGraphicsInfo"] = reflect.TypeOf((*HostGraphicsInfo)(nil)).Elem()
}

// Data object describing the operational status of a physical
// element.
type HostHardwareElementInfo struct {
	DynamicData

	// The name of the physical element
	Name string `xml:"name" json:"name"`
	// The operational status of the physical element.
	//
	// The status is one of
	// the values specified in HostHardwareElementStatus.
	//
	// See also `HostHardwareElementStatus_enum`.
	Status BaseElementDescription `xml:"status,typeattr" json:"status"`
}

func init() {
	t["HostHardwareElementInfo"] = reflect.TypeOf((*HostHardwareElementInfo)(nil)).Elem()
}

// The HardwareInfo data object type describes the hardware
// configuration of the host.
type HostHardwareInfo struct {
	DynamicData

	// Information about the system as a whole.
	SystemInfo             HostSystemInfo              `xml:"systemInfo" json:"systemInfo"`
	CpuPowerManagementInfo *HostCpuPowerManagementInfo `xml:"cpuPowerManagementInfo,omitempty" json:"cpuPowerManagementInfo,omitempty"`
	// Overall CPU information.
	CpuInfo HostCpuInfo `xml:"cpuInfo" json:"cpuInfo"`
	// Information about each of the physical CPU packages on the host.
	CpuPkg []HostCpuPackage `xml:"cpuPkg" json:"cpuPkg"`
	// Total amount of physical memory on the host in bytes.
	MemorySize int64 `xml:"memorySize" json:"memorySize"`
	// Information about the NUMA (non-uniform memory access).
	NumaInfo *HostNumaInfo `xml:"numaInfo,omitempty" json:"numaInfo,omitempty"`
	// Presence of System Management Controller, indicates the host is
	// Apple hardware, and thus capable of running Mac OS guest as VM.
	SmcPresent *bool `xml:"smcPresent" json:"smcPresent,omitempty"`
	// The list of Peripheral Component Interconnect (PCI) devices
	// available on this host.
	PciDevice []HostPciDevice `xml:"pciDevice,omitempty" json:"pciDevice,omitempty"`
	// The list of Device Virtualization Extensions (DVX) classes
	// available on this host.
	DvxClasses []HostDvxClass `xml:"dvxClasses,omitempty" json:"dvxClasses,omitempty" vim:"8.0.0.1"`
	// CPU feature set that is supported by the hardware.
	//
	// This is the
	// intersection of the feature sets supported by the individual CPU
	// packages. This feature set is modified by the
	// `supportedCpuFeature`
	// array in the host capabilities to obtain the feature set supported by
	// the virtualization platform.
	CpuFeature []HostCpuIdInfo `xml:"cpuFeature,omitempty" json:"cpuFeature,omitempty"`
	// Information about the system BIOS
	BiosInfo *HostBIOSInfo `xml:"biosInfo,omitempty" json:"biosInfo,omitempty"`
	// Information about reliable memory.
	ReliableMemoryInfo *HostReliableMemoryInfo `xml:"reliableMemoryInfo,omitempty" json:"reliableMemoryInfo,omitempty"`
	// Persistent memory configuration on this host.
	PersistentMemoryInfo *HostPersistentMemoryInfo `xml:"persistentMemoryInfo,omitempty" json:"persistentMemoryInfo,omitempty"`
	// SGX configuration on this host.
	SgxInfo *HostSgxInfo `xml:"sgxInfo,omitempty" json:"sgxInfo,omitempty"`
	// SEV configuration on this host.
	SevInfo *HostSevInfo `xml:"sevInfo,omitempty" json:"sevInfo,omitempty" vim:"7.0.1.0"`
	// Type of memory tiering configured on this host.
	//
	// See `HostMemoryTieringType_enum` for
	// supported values. This field will be unset for legacy hosts as well as
	// for hosts that don't support memory tiering.
	MemoryTieringType string `xml:"memoryTieringType,omitempty" json:"memoryTieringType,omitempty" vim:"7.0.3.0"`
	// Configuration of each memory tier on this host.
	//
	// The array is populated in the
	// order of tiers (ie, tier 0 at array index 0, tier 1 at array index 1,
	// and so on).
	MemoryTierInfo []HostMemoryTierInfo `xml:"memoryTierInfo,omitempty" json:"memoryTierInfo,omitempty" vim:"7.0.3.0"`
}

func init() {
	t["HostHardwareInfo"] = reflect.TypeOf((*HostHardwareInfo)(nil)).Elem()
}

// Data object representing the status of the
// hardware components of the host.
type HostHardwareStatusInfo struct {
	DynamicData

	// Status of the physical memory
	MemoryStatusInfo []BaseHostHardwareElementInfo `xml:"memoryStatusInfo,omitempty,typeattr" json:"memoryStatusInfo,omitempty"`
	// Status of the CPU packages
	CpuStatusInfo []BaseHostHardwareElementInfo `xml:"cpuStatusInfo,omitempty,typeattr" json:"cpuStatusInfo,omitempty"`
	// Status of the physical storage system
	StorageStatusInfo []HostStorageElementInfo `xml:"storageStatusInfo,omitempty" json:"storageStatusInfo,omitempty"`
	// Status of one or more DPU elements
	DpuStatusInfo []DpuStatusInfo `xml:"dpuStatusInfo,omitempty" json:"dpuStatusInfo,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["HostHardwareStatusInfo"] = reflect.TypeOf((*HostHardwareStatusInfo)(nil)).Elem()
}

// This data object type summarizes hardware used by the host.
type HostHardwareSummary struct {
	DynamicData

	// The hardware vendor identification.
	Vendor string `xml:"vendor" json:"vendor"`
	// The system model identification.
	Model string `xml:"model" json:"model"`
	// The hardware BIOS identification.
	Uuid string `xml:"uuid" json:"uuid"`
	// Other identification information.
	//
	// This information may be vendor
	// specific.
	OtherIdentifyingInfo []HostSystemIdentificationInfo `xml:"otherIdentifyingInfo,omitempty" json:"otherIdentifyingInfo,omitempty"`
	// The physical memory size in bytes.
	MemorySize int64 `xml:"memorySize" json:"memorySize"`
	// The CPU model.
	CpuModel string `xml:"cpuModel" json:"cpuModel"`
	// The speed of the CPU cores.
	//
	// This is an average value if there are multiple
	// speeds. The product of cpuMhz and numCpuCores is approximately equal to the
	// sum of the MHz for all the individual cores on the host.
	CpuMhz int32 `xml:"cpuMhz" json:"cpuMhz"`
	// Number of physical CPU packages on the host.
	//
	// Physical CPU packages are chips
	// that contain one or more processors. Processors contained by a package are
	// also known as CPU cores. For example, one dual-core package is comprised of
	// one chip that contains two CPU cores.
	NumCpuPkgs int16 `xml:"numCpuPkgs" json:"numCpuPkgs"`
	// Number of physical CPU cores on the host.
	//
	// Physical CPU cores are the
	// processors contained by a CPU package.
	NumCpuCores int16 `xml:"numCpuCores" json:"numCpuCores"`
	// Number of physical CPU threads on the host.
	NumCpuThreads int16 `xml:"numCpuThreads" json:"numCpuThreads"`
	// The number of network adapters.
	NumNics int32 `xml:"numNics" json:"numNics"`
	// The number of host bus adapters (HBAs).
	NumHBAs int32 `xml:"numHBAs" json:"numHBAs"`
}

func init() {
	t["HostHardwareSummary"] = reflect.TypeOf((*HostHardwareSummary)(nil)).Elem()
}

// The host has a component failure and thus can cause issues for VMs running or
// to be running on it.
type HostHasComponentFailure struct {
	VimFault

	// The host that has the component failure.
	HostName string `xml:"hostName" json:"hostName"`
	// The type of the component that has failed.
	//
	// Values come from `HostHasComponentFailureHostComponentType_enum`.
	ComponentType string `xml:"componentType" json:"componentType"`
	// The name of the component that has failed.
	ComponentName string `xml:"componentName" json:"componentName"`
}

func init() {
	t["HostHasComponentFailure"] = reflect.TypeOf((*HostHasComponentFailure)(nil)).Elem()
}

type HostHasComponentFailureFault HostHasComponentFailure

func init() {
	t["HostHasComponentFailureFault"] = reflect.TypeOf((*HostHasComponentFailureFault)(nil)).Elem()
}

// A data object which specifies the parameters needed
// to create a software host bus adapter of a specific kind.
type HostHbaCreateSpec struct {
	DynamicData
}

func init() {
	t["HostHbaCreateSpec"] = reflect.TypeOf((*HostHbaCreateSpec)(nil)).Elem()
	minAPIVersionForType["HostHbaCreateSpec"] = "7.0.3.0"
}

// This data object type describes the bus adapter for
// the host.
//
// A host bus adapter (HBA) is a hardware
// or software adapter that connects the host to storage devices.
type HostHostBusAdapter struct {
	DynamicData

	// The linkable identifier.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// The device name of host bus adapter.
	Device string `xml:"device" json:"device"`
	// The host bus number.
	Bus int32 `xml:"bus" json:"bus"`
	// The operational status of the adapter.
	//
	// Valid values include "online",
	// "offline", "unbound", and "unknown".
	Status string `xml:"status" json:"status"`
	// The model name of the host bus adapter.
	Model string `xml:"model" json:"model"`
	// The name of the driver.
	Driver string `xml:"driver,omitempty" json:"driver,omitempty"`
	// The Peripheral Connect Interface (PCI) ID of the device
	// representing the host bus adapter.
	Pci string `xml:"pci,omitempty" json:"pci,omitempty"`
	// The type of protocol supported by the host bus adapter.
	//
	// The list of supported values is described in
	// `HostStorageProtocol_enum`.
	// When unset, a default value of "scsi" is assumed.
	StorageProtocol string `xml:"storageProtocol,omitempty" json:"storageProtocol,omitempty"`
}

func init() {
	t["HostHostBusAdapter"] = reflect.TypeOf((*HostHostBusAdapter)(nil)).Elem()
}

// This data object type describes the CpuSchedulerSystem configuration
// for optimizing hyperthreading.
//
// The primary hyperthreading
// optimization employed by the CpuSchedulerSystem is to utilize
// hyperthreads as additional schedulable resources. Although
// hyperthreads provide limited additional concurrency,
// certain workloads (such as idling) can take advantage of
// these hyperthreads. This is particularly useful for SMP virtual
// machines that use gang scheduling. (Gang scheduling refers to a
// situation in which all of a parallel program's tasks are grouped
// into a "gang" and concurrently scheduled on distinct
// processors of a parallel computer system.)
//
// Changes to the hyperthreading optimization can take effect only
// after a system restart. Therefore, while it is possible to change
// the configuration at any time, the change will take effect only
// on the next boot.
type HostHyperThreadScheduleInfo struct {
	DynamicData

	// The flag to indicate whether or not hyperthreading
	// optimization is available on the system.
	//
	// This property
	// is set by VMware prior to installation.
	Available bool `xml:"available" json:"available"`
	// The flag to indicate whether or not the CPU scheduler is
	// currently treating
	// hyperthreads as schedulable resources.
	//
	// Setting this property
	// involves a successful invocation of either the
	// `enableHyperThreading()` method ("true") or the
	// `disableHyperthreading()` method
	// ("false"). The property is set once the system is rebooted.
	Active bool `xml:"active" json:"active"`
	// The flag to indicate whether or not the CPU scheduler
	// should treat hyperthreads as
	// schedulable resources the next time the CPU scheduler starts.
	//   - This property is set to "true" by successfully invoking the
	//     `enableHyperThreading()` method.
	//   - This property is set to "false" by successfully invoking the
	//     `disableHyperthreading()` method.
	Config bool `xml:"config" json:"config"`
}

func init() {
	t["HostHyperThreadScheduleInfo"] = reflect.TypeOf((*HostHyperThreadScheduleInfo)(nil)).Elem()
}

type HostImageConfigGetAcceptance HostImageConfigGetAcceptanceRequestType

func init() {
	t["HostImageConfigGetAcceptance"] = reflect.TypeOf((*HostImageConfigGetAcceptance)(nil)).Elem()
}

type HostImageConfigGetAcceptanceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["HostImageConfigGetAcceptanceRequestType"] = reflect.TypeOf((*HostImageConfigGetAcceptanceRequestType)(nil)).Elem()
}

type HostImageConfigGetAcceptanceResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type HostImageConfigGetProfile HostImageConfigGetProfileRequestType

func init() {
	t["HostImageConfigGetProfile"] = reflect.TypeOf((*HostImageConfigGetProfile)(nil)).Elem()
}

type HostImageConfigGetProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["HostImageConfigGetProfileRequestType"] = reflect.TypeOf((*HostImageConfigGetProfileRequestType)(nil)).Elem()
}

type HostImageConfigGetProfileResponse struct {
	Returnval HostImageProfileSummary `xml:"returnval" json:"returnval"`
}

// Summary of an image profile
type HostImageProfileSummary struct {
	DynamicData

	// The name of the image profile
	Name string `xml:"name" json:"name"`
	// The organization publishing the image profile.
	Vendor string `xml:"vendor" json:"vendor"`
}

func init() {
	t["HostImageProfileSummary"] = reflect.TypeOf((*HostImageProfileSummary)(nil)).Elem()
}

// Host is booted in audit mode.
type HostInAuditModeEvent struct {
	HostEvent
}

func init() {
	t["HostInAuditModeEvent"] = reflect.TypeOf((*HostInAuditModeEvent)(nil)).Elem()
}

// Fault indicating that an operation cannot be performed while
// the host is part of a Windows domain.
type HostInDomain struct {
	HostConfigFault
}

func init() {
	t["HostInDomain"] = reflect.TypeOf((*HostInDomain)(nil)).Elem()
}

type HostInDomainFault HostInDomain

func init() {
	t["HostInDomainFault"] = reflect.TypeOf((*HostInDomainFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to configure a fault tolerant
// virtual machine on a host that is incompatible.
type HostIncompatibleForFaultTolerance struct {
	VmFaultToleranceIssue

	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
	// The specific reason why the host does not support fault tolerance.
	//
	// Values should come from `HostIncompatibleForFaultToleranceReason_enum`.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["HostIncompatibleForFaultTolerance"] = reflect.TypeOf((*HostIncompatibleForFaultTolerance)(nil)).Elem()
}

type HostIncompatibleForFaultToleranceFault HostIncompatibleForFaultTolerance

func init() {
	t["HostIncompatibleForFaultToleranceFault"] = reflect.TypeOf((*HostIncompatibleForFaultToleranceFault)(nil)).Elem()
}

// Deprecated as of vSphere API 6.0.
//
// This fault is thrown when an attempt is made record or replay
// a virtual machine on a host that is incompatible.
type HostIncompatibleForRecordReplay struct {
	VimFault

	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
	// The specific reason why the host does not support record/replay.
	//
	// Values should come from `HostIncompatibleForRecordReplayReason_enum`.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["HostIncompatibleForRecordReplay"] = reflect.TypeOf((*HostIncompatibleForRecordReplay)(nil)).Elem()
}

type HostIncompatibleForRecordReplayFault HostIncompatibleForRecordReplay

func init() {
	t["HostIncompatibleForRecordReplayFault"] = reflect.TypeOf((*HostIncompatibleForRecordReplayFault)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostInflateDisk_Task`.
type HostInflateDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual disk to be inflated.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual disk is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["HostInflateDiskRequestType"] = reflect.TypeOf((*HostInflateDiskRequestType)(nil)).Elem()
}

type HostInflateDisk_Task HostInflateDiskRequestType

func init() {
	t["HostInflateDisk_Task"] = reflect.TypeOf((*HostInflateDisk_Task)(nil)).Elem()
}

type HostInflateDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This data object type describes the iSCSI host bus adapter
// interface.
type HostInternetScsiHba struct {
	HostHostBusAdapter

	// True if this host bus adapter is a software based initiator
	// utilizing the hosting system's existing TCP/IP network connection
	IsSoftwareBased bool `xml:"isSoftwareBased" json:"isSoftwareBased"`
	// Can this adapter be disabled
	CanBeDisabled *bool `xml:"canBeDisabled" json:"canBeDisabled,omitempty"`
	// Specifies if this iSCSI Adapter requires a bound network
	// interface to function.
	NetworkBindingSupport HostInternetScsiHbaNetworkBindingSupportType `xml:"networkBindingSupport,omitempty" json:"networkBindingSupport,omitempty"`
	// The discovery capabilities for this host bus adapter.
	DiscoveryCapabilities HostInternetScsiHbaDiscoveryCapabilities `xml:"discoveryCapabilities" json:"discoveryCapabilities"`
	// The discovery settings for this host bus adapter.
	DiscoveryProperties HostInternetScsiHbaDiscoveryProperties `xml:"discoveryProperties" json:"discoveryProperties"`
	// The authentication capabilities for this host bus adapter.
	AuthenticationCapabilities HostInternetScsiHbaAuthenticationCapabilities `xml:"authenticationCapabilities" json:"authenticationCapabilities"`
	// The authentication settings for this host bus adapter.
	//
	// All static and discovery targets will inherit the use of these
	// settings unless their authentication settings are explicitly set.
	AuthenticationProperties HostInternetScsiHbaAuthenticationProperties `xml:"authenticationProperties" json:"authenticationProperties"`
	// The authentication capabilities for this host bus adapter.
	DigestCapabilities *HostInternetScsiHbaDigestCapabilities `xml:"digestCapabilities,omitempty" json:"digestCapabilities,omitempty"`
	// The digest settings for this host bus adapter.
	//
	// All static and discovery targets will inherit the use of these
	// properties unless their digest settings are explicitly set.
	DigestProperties *HostInternetScsiHbaDigestProperties `xml:"digestProperties,omitempty" json:"digestProperties,omitempty"`
	// The IP capabilities for this host bus adapter.
	IpCapabilities HostInternetScsiHbaIPCapabilities `xml:"ipCapabilities" json:"ipCapabilities"`
	// The IP settings for this host bus adapter.
	IpProperties HostInternetScsiHbaIPProperties `xml:"ipProperties" json:"ipProperties"`
	// A list of supported key/value pair advanced options for the
	// host bus adapter including their type information.
	SupportedAdvancedOptions []OptionDef `xml:"supportedAdvancedOptions,omitempty" json:"supportedAdvancedOptions,omitempty"`
	// A list of the current options settings for the host bus adapter.
	AdvancedOptions []HostInternetScsiHbaParamValue `xml:"advancedOptions,omitempty" json:"advancedOptions,omitempty"`
	// The iSCSI name of this host bus adapter.
	IScsiName string `xml:"iScsiName" json:"iScsiName"`
	// The iSCSI alias of this host bus adapter.
	IScsiAlias string `xml:"iScsiAlias,omitempty" json:"iScsiAlias,omitempty"`
	// The configured iSCSI send target entries.
	ConfiguredSendTarget []HostInternetScsiHbaSendTarget `xml:"configuredSendTarget,omitempty" json:"configuredSendTarget,omitempty"`
	// The configured iSCSI static target entries.
	ConfiguredStaticTarget []HostInternetScsiHbaStaticTarget `xml:"configuredStaticTarget,omitempty" json:"configuredStaticTarget,omitempty"`
	// The maximum supported link speed of the port in megabits per second.
	MaxSpeedMb int32 `xml:"maxSpeedMb,omitempty" json:"maxSpeedMb,omitempty"`
	// The Current operating link speed of the port in megabits per second.
	CurrentSpeedMb int32 `xml:"currentSpeedMb,omitempty" json:"currentSpeedMb,omitempty"`
}

func init() {
	t["HostInternetScsiHba"] = reflect.TypeOf((*HostInternetScsiHba)(nil)).Elem()
}

// The authentication capabilities for this host bus adapter.
type HostInternetScsiHbaAuthenticationCapabilities struct {
	DynamicData

	// True if this host bus adapter supports changing the configuration
	// state of CHAP authentication.
	//
	// CHAP is mandatory, however some
	// adapter may not allow disabling this authentication method.
	ChapAuthSettable bool `xml:"chapAuthSettable" json:"chapAuthSettable"`
	// Always false in this version of the API.
	Krb5AuthSettable bool `xml:"krb5AuthSettable" json:"krb5AuthSettable"`
	// Always false in this version of the API.
	SrpAuthSettable bool `xml:"srpAuthSettable" json:"srpAuthSettable"`
	// Always false in this version of the API.
	SpkmAuthSettable bool `xml:"spkmAuthSettable" json:"spkmAuthSettable"`
	// When chapAuthSettable is TRUE, this describes if Mutual CHAP
	// configuration is allowed as well.
	MutualChapSettable *bool `xml:"mutualChapSettable" json:"mutualChapSettable,omitempty"`
	// When targetChapSettable is TRUE, this describes if
	// CHAP configuration is allowed on targets associated
	// with the adapter.
	TargetChapSettable *bool `xml:"targetChapSettable" json:"targetChapSettable,omitempty"`
	// When targetMutualChapSettable is TRUE, this describes if
	// Mutual CHAP configuration is allowed on targets associated
	// with the adapter.
	TargetMutualChapSettable *bool `xml:"targetMutualChapSettable" json:"targetMutualChapSettable,omitempty"`
}

func init() {
	t["HostInternetScsiHbaAuthenticationCapabilities"] = reflect.TypeOf((*HostInternetScsiHbaAuthenticationCapabilities)(nil)).Elem()
}

// The authentication settings for this host bus adapter or target.
type HostInternetScsiHbaAuthenticationProperties struct {
	DynamicData

	// True if CHAP is currently enabled
	ChapAuthEnabled bool `xml:"chapAuthEnabled" json:"chapAuthEnabled"`
	// The CHAP user name if enabled
	ChapName string `xml:"chapName,omitempty" json:"chapName,omitempty"`
	// The CHAP secret if enabled
	ChapSecret string `xml:"chapSecret,omitempty" json:"chapSecret,omitempty"`
	// The preference for CHAP or non-CHAP protocol if CHAP is enabled
	ChapAuthenticationType string `xml:"chapAuthenticationType,omitempty" json:"chapAuthenticationType,omitempty"`
	// CHAP settings are inherited
	ChapInherited *bool `xml:"chapInherited" json:"chapInherited,omitempty"`
	// When Mutual-CHAP is enabled, the user name that target needs to
	// use to authenticate with the initiator
	MutualChapName string `xml:"mutualChapName,omitempty" json:"mutualChapName,omitempty"`
	// When Mutual-CHAP is enabled, the secret that target needs to
	// use to authenticate with the initiator
	MutualChapSecret string `xml:"mutualChapSecret,omitempty" json:"mutualChapSecret,omitempty"`
	// The preference for CHAP or non-CHAP protocol if CHAP is enabled
	MutualChapAuthenticationType string `xml:"mutualChapAuthenticationType,omitempty" json:"mutualChapAuthenticationType,omitempty"`
	// Mutual-CHAP settings are inherited
	MutualChapInherited *bool `xml:"mutualChapInherited" json:"mutualChapInherited,omitempty"`
}

func init() {
	t["HostInternetScsiHbaAuthenticationProperties"] = reflect.TypeOf((*HostInternetScsiHbaAuthenticationProperties)(nil)).Elem()
}

// The digest capabilities for this host bus adapter.
type HostInternetScsiHbaDigestCapabilities struct {
	DynamicData

	// True if this host bus adapter supports the configuration
	// of the use of header digest.
	//
	// Defaults to false, in which
	// case no header digests will be used.
	HeaderDigestSettable *bool `xml:"headerDigestSettable" json:"headerDigestSettable,omitempty"`
	// True if this host bus adapter supports the configuration
	// of the use of data digest.
	//
	// Defaults to false, in which
	// case no data digests will be used.
	DataDigestSettable *bool `xml:"dataDigestSettable" json:"dataDigestSettable,omitempty"`
	// True if configuration of the use of header digest is supported
	// on the targets associated with the host bus adapter.
	//
	// Defaults to
	// false, in which case no header digests will be used.
	TargetHeaderDigestSettable *bool `xml:"targetHeaderDigestSettable" json:"targetHeaderDigestSettable,omitempty"`
	// True if configuration of the use of data digest is supported
	// on the targets associated with the host bus adapter.
	//
	// Defaults to
	// false, in which case no data digests will be used.
	TargetDataDigestSettable *bool `xml:"targetDataDigestSettable" json:"targetDataDigestSettable,omitempty"`
}

func init() {
	t["HostInternetScsiHbaDigestCapabilities"] = reflect.TypeOf((*HostInternetScsiHbaDigestCapabilities)(nil)).Elem()
}

// The digest settings for this host bus adapter.
type HostInternetScsiHbaDigestProperties struct {
	DynamicData

	// The header digest preference if header digest is enabled
	HeaderDigestType string `xml:"headerDigestType,omitempty" json:"headerDigestType,omitempty"`
	// Header digest setting is inherited
	HeaderDigestInherited *bool `xml:"headerDigestInherited" json:"headerDigestInherited,omitempty"`
	// The data digest preference if data digest is enabled
	DataDigestType string `xml:"dataDigestType,omitempty" json:"dataDigestType,omitempty"`
	// Data digest setting is inherited
	DataDigestInherited *bool `xml:"dataDigestInherited" json:"dataDigestInherited,omitempty"`
}

func init() {
	t["HostInternetScsiHbaDigestProperties"] = reflect.TypeOf((*HostInternetScsiHbaDigestProperties)(nil)).Elem()
}

// The discovery capabilities for this host bus adapter.
//
// At least one discovery mode must always be active.
// Multiple modes may be active at the same time.
type HostInternetScsiHbaDiscoveryCapabilities struct {
	DynamicData

	// True if this host bus adapter supports iSNS
	ISnsDiscoverySettable bool `xml:"iSnsDiscoverySettable" json:"iSnsDiscoverySettable"`
	// True if this host bus adapter supports SLP
	SlpDiscoverySettable bool `xml:"slpDiscoverySettable" json:"slpDiscoverySettable"`
	// True if this host bus adapter supports static discovery
	StaticTargetDiscoverySettable bool `xml:"staticTargetDiscoverySettable" json:"staticTargetDiscoverySettable"`
	// True if this host bus adapter supports changing the configuration
	// state of send targets discovery.
	//
	// Send targets is mandatory, however
	// some adapters may not allow disabling this discovery method.
	SendTargetsDiscoverySettable bool `xml:"sendTargetsDiscoverySettable" json:"sendTargetsDiscoverySettable"`
}

func init() {
	t["HostInternetScsiHbaDiscoveryCapabilities"] = reflect.TypeOf((*HostInternetScsiHbaDiscoveryCapabilities)(nil)).Elem()
}

// The discovery settings for this host bus adapter.
//
// At least one discovery mode must always be active.
// Multiple modes may be active at the same time.
type HostInternetScsiHbaDiscoveryProperties struct {
	DynamicData

	// True if iSNS is currently enabled
	ISnsDiscoveryEnabled bool `xml:"iSnsDiscoveryEnabled" json:"iSnsDiscoveryEnabled"`
	// The iSNS discovery method in use when iSNS is enabled.
	//
	// Must be one of the values of
	// `InternetScsiSnsDiscoveryMethod_enum`
	ISnsDiscoveryMethod string `xml:"iSnsDiscoveryMethod,omitempty" json:"iSnsDiscoveryMethod,omitempty"`
	// For STATIC iSNS, this is the iSNS server address
	ISnsHost string `xml:"iSnsHost,omitempty" json:"iSnsHost,omitempty"`
	// True if SLP is enabled
	SlpDiscoveryEnabled bool `xml:"slpDiscoveryEnabled" json:"slpDiscoveryEnabled"`
	// The current SLP discovery method when SLP is enabled.
	//
	// Must be one of the values of
	// `SlpDiscoveryMethod_enum`
	SlpDiscoveryMethod string `xml:"slpDiscoveryMethod,omitempty" json:"slpDiscoveryMethod,omitempty"`
	// When the SLP discovery method is set to MANUAL, this property
	// reflects the hostname, and optionally port number of the SLP DA.
	SlpHost string `xml:"slpHost,omitempty" json:"slpHost,omitempty"`
	// True if static target discovery is enabled
	StaticTargetDiscoveryEnabled bool `xml:"staticTargetDiscoveryEnabled" json:"staticTargetDiscoveryEnabled"`
	// True if send targets discovery is enabled
	SendTargetsDiscoveryEnabled bool `xml:"sendTargetsDiscoveryEnabled" json:"sendTargetsDiscoveryEnabled"`
}

func init() {
	t["HostInternetScsiHbaDiscoveryProperties"] = reflect.TypeOf((*HostInternetScsiHbaDiscoveryProperties)(nil)).Elem()
}

// The IP Capabilities for the host bus adapter
type HostInternetScsiHbaIPCapabilities struct {
	DynamicData

	// True if the host bus adapter supports setting its IPv4 address.
	AddressSettable bool `xml:"addressSettable" json:"addressSettable"`
	// True if the host bus adapter supports DHCPv4.
	IpConfigurationMethodSettable bool `xml:"ipConfigurationMethodSettable" json:"ipConfigurationMethodSettable"`
	// True if the host bus adapter supports setting its IPv4 subnet mask.
	SubnetMaskSettable bool `xml:"subnetMaskSettable" json:"subnetMaskSettable"`
	// True if the host bus adapter supports setting its IPv4 gateway.
	DefaultGatewaySettable bool `xml:"defaultGatewaySettable" json:"defaultGatewaySettable"`
	// True if the host bus adapter supports setting its primary DNS.
	PrimaryDnsServerAddressSettable bool `xml:"primaryDnsServerAddressSettable" json:"primaryDnsServerAddressSettable"`
	// True if the host bus adapter supports setting its secondary DNS.
	AlternateDnsServerAddressSettable bool `xml:"alternateDnsServerAddressSettable" json:"alternateDnsServerAddressSettable"`
	// True if the host bus adapter supports the use of IPv6 addresses
	Ipv6Supported *bool `xml:"ipv6Supported" json:"ipv6Supported,omitempty"`
	// True if the host bus adapter supports setting its ARP Redirect value
	ArpRedirectSettable *bool `xml:"arpRedirectSettable" json:"arpRedirectSettable,omitempty"`
	// True if the host bus adapter supports setting its MTU, (for Jumbo
	// Frames, etc)
	MtuSettable *bool `xml:"mtuSettable" json:"mtuSettable,omitempty"`
	// True if the discovery and static targets can be configured with
	// a host name as opposed to an IP address.
	HostNameAsTargetAddress *bool `xml:"hostNameAsTargetAddress" json:"hostNameAsTargetAddress,omitempty"`
	// True if the host bus adapter supports setting its name and alias
	NameAliasSettable *bool `xml:"nameAliasSettable" json:"nameAliasSettable,omitempty"`
	// True if IPv4 addresssing can be enabled or disabled on the host bus adapter.
	Ipv4EnableSettable *bool `xml:"ipv4EnableSettable" json:"ipv4EnableSettable,omitempty"`
	// True if IPv6 addresssing can be enabled or disabled on the host bus adapter.
	Ipv6EnableSettable *bool `xml:"ipv6EnableSettable" json:"ipv6EnableSettable,omitempty"`
	// True if the Host bus adapter supports setting IPv6 Prefix Length.
	Ipv6PrefixLengthSettable *bool `xml:"ipv6PrefixLengthSettable" json:"ipv6PrefixLengthSettable,omitempty"`
	// Provides the value that user should be using if host bus adapter
	// does not support changing of prefix length.
	Ipv6PrefixLength int32 `xml:"ipv6PrefixLength,omitempty" json:"ipv6PrefixLength,omitempty"`
	// True if the Host bus adapter supports DHCPv6 configuration.
	Ipv6DhcpConfigurationSettable *bool `xml:"ipv6DhcpConfigurationSettable" json:"ipv6DhcpConfigurationSettable,omitempty"`
	// True if the Host bus adapter supports setting configuration of its IPv6 link local address
	// User can specify link local static address if link local auto configuration is set to false.
	//
	// link local address usually starts with fe80: and has prefix 64.
	Ipv6LinkLocalAutoConfigurationSettable *bool `xml:"ipv6LinkLocalAutoConfigurationSettable" json:"ipv6LinkLocalAutoConfigurationSettable,omitempty"`
	// True if the Host bus adapter supports router advertisement configuration method.
	//
	// Note: Currently Qlogic adapter does not support plumbing of any user specified
	// static address if router advertisement method is enabled.
	Ipv6RouterAdvertisementConfigurationSettable *bool `xml:"ipv6RouterAdvertisementConfigurationSettable" json:"ipv6RouterAdvertisementConfigurationSettable,omitempty"`
	// True if the Host bus adapter supports setting its IPv6 default gateway.
	Ipv6DefaultGatewaySettable *bool `xml:"ipv6DefaultGatewaySettable" json:"ipv6DefaultGatewaySettable,omitempty"`
	// The maximum number of supported IPv6 static addresses on the
	// host bus adapter that user can set.
	Ipv6MaxStaticAddressesSupported int32 `xml:"ipv6MaxStaticAddressesSupported,omitempty" json:"ipv6MaxStaticAddressesSupported,omitempty"`
}

func init() {
	t["HostInternetScsiHbaIPCapabilities"] = reflect.TypeOf((*HostInternetScsiHbaIPCapabilities)(nil)).Elem()
}

// The IP properties for the host bus adapter
type HostInternetScsiHbaIPProperties struct {
	DynamicData

	// The MAC address.
	Mac string `xml:"mac,omitempty" json:"mac,omitempty"`
	// The current IPv4 address.
	Address string `xml:"address,omitempty" json:"address,omitempty"`
	// True if the host bus adapter fetches its IP using DHCP.
	DhcpConfigurationEnabled bool `xml:"dhcpConfigurationEnabled" json:"dhcpConfigurationEnabled"`
	// The current IPv4 subnet mask.
	SubnetMask string `xml:"subnetMask,omitempty" json:"subnetMask,omitempty"`
	// The current IPv4 gateway.
	DefaultGateway string `xml:"defaultGateway,omitempty" json:"defaultGateway,omitempty"`
	// The current primary DNS address.
	PrimaryDnsServerAddress string `xml:"primaryDnsServerAddress,omitempty" json:"primaryDnsServerAddress,omitempty"`
	// The current secondary DNS address.
	AlternateDnsServerAddress string `xml:"alternateDnsServerAddress,omitempty" json:"alternateDnsServerAddress,omitempty"`
	// Deprecated since vSphere API 5.5 use { @link IPProperties#ipv6properties }.
	//
	// The current IPv6 address.
	Ipv6Address string `xml:"ipv6Address,omitempty" json:"ipv6Address,omitempty"`
	// Deprecated since vSphere API 5.5 use { @link IPProperties#ipv6properties }.
	//
	// The current IPv6 subnet mask.
	Ipv6SubnetMask string `xml:"ipv6SubnetMask,omitempty" json:"ipv6SubnetMask,omitempty"`
	// Deprecated since vSphere API 5.5 use { @link IPProperties#ipv6properties }.
	//
	// The current IPv6 default gateway.
	Ipv6DefaultGateway string `xml:"ipv6DefaultGateway,omitempty" json:"ipv6DefaultGateway,omitempty"`
	// True if ARP Redirect is enabled
	ArpRedirectEnabled *bool `xml:"arpRedirectEnabled" json:"arpRedirectEnabled,omitempty"`
	// True if the host bus adapter supports setting its MTU, (for Jumbo
	// Frames, etc)
	// Setting enableJumboFrames and not a numeric mtu value implies
	// autoselection of appropriate MTU value for Jumbo Frames.
	Mtu                int32 `xml:"mtu,omitempty" json:"mtu,omitempty"`
	JumboFramesEnabled *bool `xml:"jumboFramesEnabled" json:"jumboFramesEnabled,omitempty"`
	// True if IPv4 is enabled.
	//
	// Unset value will keep existing IPv4 enabled state as is.
	Ipv4Enabled *bool `xml:"ipv4Enabled" json:"ipv4Enabled,omitempty"`
	// True if IPv6 is enabled.
	//
	// Unset value will keep existing IPv6 enabled state as is.
	Ipv6Enabled *bool `xml:"ipv6Enabled" json:"ipv6Enabled,omitempty"`
	// IPv6 properties.
	//
	// It is set only if { @link #ipv6Enabled } is true.
	Ipv6properties *HostInternetScsiHbaIPv6Properties `xml:"ipv6properties,omitempty" json:"ipv6properties,omitempty"`
}

func init() {
	t["HostInternetScsiHbaIPProperties"] = reflect.TypeOf((*HostInternetScsiHbaIPProperties)(nil)).Elem()
}

// The IPv6 properties for the host bus adapter.
type HostInternetScsiHbaIPv6Properties struct {
	DynamicData

	// There can be multiple IPv6 addressed plumbed onto the Host Bus Adapter.
	IscsiIpv6Address []HostInternetScsiHbaIscsiIpv6Address `xml:"iscsiIpv6Address,omitempty" json:"iscsiIpv6Address,omitempty"`
	// True if DHCPv6 is enabled on the host bus adapter.
	//
	// User can keep this field unset while changing other IPv6 properties
	// without altering current DHCP configuration.
	Ipv6DhcpConfigurationEnabled *bool `xml:"ipv6DhcpConfigurationEnabled" json:"ipv6DhcpConfigurationEnabled,omitempty"`
	// True if auto configuration of link local address is enabled on the host bus adapter.
	//
	// User can keep this field unset while changing other IPv6 properties
	// without altering current link local auto configuration.
	Ipv6LinkLocalAutoConfigurationEnabled *bool `xml:"ipv6LinkLocalAutoConfigurationEnabled" json:"ipv6LinkLocalAutoConfigurationEnabled,omitempty"`
	// True if the router advertisement configuration is enabled on the host bus adapter.
	//
	// User can keep this field unset while changing other IPv6 properties
	// without altering current router advertisement configuration.
	Ipv6RouterAdvertisementConfigurationEnabled *bool `xml:"ipv6RouterAdvertisementConfigurationEnabled" json:"ipv6RouterAdvertisementConfigurationEnabled,omitempty"`
	// The current IPv6 default gateway.
	//
	// User can keep this field unset while changing other IPv6 properties
	// without altering current default gateway configuration.
	Ipv6DefaultGateway string `xml:"ipv6DefaultGateway,omitempty" json:"ipv6DefaultGateway,omitempty"`
}

func init() {
	t["HostInternetScsiHbaIPv6Properties"] = reflect.TypeOf((*HostInternetScsiHbaIPv6Properties)(nil)).Elem()
}

// The IPv6 address.
type HostInternetScsiHbaIscsiIpv6Address struct {
	DynamicData

	// IPv6 address.
	Address string `xml:"address" json:"address"`
	// IPv6 address prefix length.
	PrefixLength int32 `xml:"prefixLength" json:"prefixLength"`
	// Type of the address.
	//
	// See { @Vim::Host::HostBusAdapter::IscsiIpv6Address::AddressConfigurationType }.
	// Note: While setting IPv6 address, value of origin should be set to static.
	Origin string `xml:"origin" json:"origin"`
	// Operation to be performed with the IP address.
	//
	// See { @Vim::Host::HostBusAdapter::IscsiIpv6Address::IPv6AddressOperation }.
	// Note: This field/operation is used only while setting the IPProperties on host bus adapter.
	// This field would not have any value (Unset) while viewing IPProperties
	// of the host bus adapter.
	Operation string `xml:"operation,omitempty" json:"operation,omitempty"`
}

func init() {
	t["HostInternetScsiHbaIscsiIpv6Address"] = reflect.TypeOf((*HostInternetScsiHbaIscsiIpv6Address)(nil)).Elem()
}

// Describes the the value of an iSCSI parameter, and whether
// the value is being inherited.
type HostInternetScsiHbaParamValue struct {
	OptionValue

	// Indicates if the value is inherited from some other source.
	//
	// If unset, the value is not inheritable.
	// isInherited can be modified only if it has already been set.
	// If value is to being modified, isInherited should be set to true.
	// Setting isInherited to false will result in the value being
	// once again inherited from the source.
	IsInherited *bool `xml:"isInherited" json:"isInherited,omitempty"`
}

func init() {
	t["HostInternetScsiHbaParamValue"] = reflect.TypeOf((*HostInternetScsiHbaParamValue)(nil)).Elem()
}

// The iSCSI send target.
type HostInternetScsiHbaSendTarget struct {
	DynamicData

	// The IP address or hostname of the storage device.
	Address string `xml:"address" json:"address"`
	// The TCP port of the storage device.
	//
	// If not specified, the standard default of 3260 is used.
	Port int32 `xml:"port,omitempty" json:"port,omitempty"`
	// The authentication settings for this discovery target.
	//
	// All static targets discovered via this target will inherit the
	// use of these settings unless the static target's authentication
	// settings are explicitly set.
	AuthenticationProperties *HostInternetScsiHbaAuthenticationProperties `xml:"authenticationProperties,omitempty" json:"authenticationProperties,omitempty"`
	// The digest settings for this discovery target.
	//
	// All static targets discovered via this target will inherit the
	// use of these settings unless the static target's digest
	// settings are explicitly set.
	DigestProperties *HostInternetScsiHbaDigestProperties `xml:"digestProperties,omitempty" json:"digestProperties,omitempty"`
	// A list of supported key/value pair advanced options for the
	// host bus adapter including their type information.
	SupportedAdvancedOptions []OptionDef `xml:"supportedAdvancedOptions,omitempty" json:"supportedAdvancedOptions,omitempty"`
	// A list of the current options settings for the host bus adapter.
	AdvancedOptions []HostInternetScsiHbaParamValue `xml:"advancedOptions,omitempty" json:"advancedOptions,omitempty"`
	// The device name of the host bus adapter from which settings
	// can be inherited.
	Parent string `xml:"parent,omitempty" json:"parent,omitempty"`
}

func init() {
	t["HostInternetScsiHbaSendTarget"] = reflect.TypeOf((*HostInternetScsiHbaSendTarget)(nil)).Elem()
}

// The iSCSI static target.
type HostInternetScsiHbaStaticTarget struct {
	DynamicData

	// The IP address or hostname of the storage device.
	Address string `xml:"address" json:"address"`
	// The TCP port of the storage device.
	//
	// If not specified, the standard default of 3260 is used.
	Port int32 `xml:"port,omitempty" json:"port,omitempty"`
	// The iSCSI name of the storage device.
	IScsiName string `xml:"iScsiName" json:"iScsiName"`
	// Discovery method
	// each static target is discovered by some method
	// define in TargetDiscoveryMethod.
	DiscoveryMethod string `xml:"discoveryMethod,omitempty" json:"discoveryMethod,omitempty"`
	// The authentication settings for this target.
	AuthenticationProperties *HostInternetScsiHbaAuthenticationProperties `xml:"authenticationProperties,omitempty" json:"authenticationProperties,omitempty"`
	// The digest settings for this target.
	DigestProperties *HostInternetScsiHbaDigestProperties `xml:"digestProperties,omitempty" json:"digestProperties,omitempty"`
	// A list of supported key/value pair advanced options for the
	// host bus adapter including their type information.
	SupportedAdvancedOptions []OptionDef `xml:"supportedAdvancedOptions,omitempty" json:"supportedAdvancedOptions,omitempty"`
	// A list of the current options settings for the host bus adapter.
	AdvancedOptions []HostInternetScsiHbaParamValue `xml:"advancedOptions,omitempty" json:"advancedOptions,omitempty"`
	// The parent entity from which settings can be inherited.
	//
	// It can either
	// be unset, or set to the device name of the host bus adapter or the
	// name of the SendTarget.
	Parent string `xml:"parent,omitempty" json:"parent,omitempty"`
}

func init() {
	t["HostInternetScsiHbaStaticTarget"] = reflect.TypeOf((*HostInternetScsiHbaStaticTarget)(nil)).Elem()
}

// A collection of one or more static targets or discovery addresses.
//
// At least one of the arrays must be non-empty.
type HostInternetScsiHbaTargetSet struct {
	DynamicData

	StaticTargets []HostInternetScsiHbaStaticTarget `xml:"staticTargets,omitempty" json:"staticTargets,omitempty"`
	SendTargets   []HostInternetScsiHbaSendTarget   `xml:"sendTargets,omitempty" json:"sendTargets,omitempty"`
}

func init() {
	t["HostInternetScsiHbaTargetSet"] = reflect.TypeOf((*HostInternetScsiHbaTargetSet)(nil)).Elem()
}

// Internet SCSI transport information about a SCSI target.
type HostInternetScsiTargetTransport struct {
	HostTargetTransport

	// The iSCSI name of the target.
	IScsiName string `xml:"iScsiName" json:"iScsiName"`
	// The iSCSI alias of the target.
	IScsiAlias string `xml:"iScsiAlias" json:"iScsiAlias"`
	// The IP addresses through which the target may be reached.
	Address []string `xml:"address,omitempty" json:"address,omitempty"`
}

func init() {
	t["HostInternetScsiTargetTransport"] = reflect.TypeOf((*HostInternetScsiTargetTransport)(nil)).Elem()
}

// A HostInventoryFull is thrown if the inventory has reach the max capacity of hosts.
type HostInventoryFull struct {
	NotEnoughLicenses

	Capacity int32 `xml:"capacity" json:"capacity"`
}

func init() {
	t["HostInventoryFull"] = reflect.TypeOf((*HostInventoryFull)(nil)).Elem()
}

// This event records if the inventory of hosts has reached capacity.
type HostInventoryFullEvent struct {
	LicenseEvent

	Capacity int32 `xml:"capacity" json:"capacity"`
}

func init() {
	t["HostInventoryFullEvent"] = reflect.TypeOf((*HostInventoryFullEvent)(nil)).Elem()
}

type HostInventoryFullFault HostInventoryFull

func init() {
	t["HostInventoryFullFault"] = reflect.TypeOf((*HostInventoryFullFault)(nil)).Elem()
}

// Event indicating that the virtual machine inventory
// file on the host is damaged or unreadable.
type HostInventoryUnreadableEvent struct {
	Event
}

func init() {
	t["HostInventoryUnreadableEvent"] = reflect.TypeOf((*HostInventoryUnreadableEvent)(nil)).Elem()
}

// Information about an IO Filter installed on a host.
type HostIoFilterInfo struct {
	IoFilterInfo

	// Whether or not the filter is available for use.
	Available bool `xml:"available" json:"available"`
}

func init() {
	t["HostIoFilterInfo"] = reflect.TypeOf((*HostIoFilterInfo)(nil)).Elem()
}

// This event records a change in host IP address.
type HostIpChangedEvent struct {
	HostEvent

	// Old IP address of the host.
	OldIP string `xml:"oldIP" json:"oldIP"`
	// New IP address of the host.
	NewIP string `xml:"newIP" json:"newIP"`
}

func init() {
	t["HostIpChangedEvent"] = reflect.TypeOf((*HostIpChangedEvent)(nil)).Elem()
}

// The IP configuration.
type HostIpConfig struct {
	DynamicData

	// The flag to indicate whether or not DHCP (dynamic host
	// control protocol) is enabled.
	//
	// If this property is set to true,
	// the ipAddress and the subnetMask strings cannot be set explicitly.
	Dhcp bool `xml:"dhcp" json:"dhcp"`
	// The IP address currently used by the network adapter.
	//
	// All IP addresses are specified using IPv4 dot notation.
	// For example, "192.168.0.1". Subnet addresses and netmasks are
	// specified using the same notation.
	//
	// `*Note*`: When DHCP is enabled, this property reflects the
	// current IP configuration and cannot be set. When DHCP is not
	// enabled, this property can be set explicitly.
	IpAddress string `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
	// The subnet mask.
	//
	// `*Note*`: When DHCP is not enabled, this property can be
	// set explicitly. When DHCP is enabled, this property reflects the
	// current IP configuration and cannot be set.
	SubnetMask string `xml:"subnetMask,omitempty" json:"subnetMask,omitempty"`
	// The ipv6 configuration
	IpV6Config *HostIpConfigIpV6AddressConfiguration `xml:"ipV6Config,omitempty" json:"ipV6Config,omitempty"`
}

func init() {
	t["HostIpConfig"] = reflect.TypeOf((*HostIpConfig)(nil)).Elem()
}

// The ipv6 address specification
type HostIpConfigIpV6Address struct {
	DynamicData

	// The ipv6 address.
	//
	// When DHCP is enabled, this property
	// reflects the current IP configuration and cannot be set.
	IpAddress string `xml:"ipAddress" json:"ipAddress"`
	// The prefix length.
	//
	// An ipv6 prefixLength is a decimal value that indicates
	// the number of contiguous, higher-order bits of the address that make up the
	// network portion of the address.
	// For example, 10FA:6604:8136:6502::/64 is a possible IPv6 prefix. The prefix
	// length in this case is 64.
	PrefixLength int32 `xml:"prefixLength" json:"prefixLength"`
	// The type of the ipv6 address configuration on the interface.
	//
	// This can be one of the types defined my the enum
	// `HostIpConfigIpV6AddressConfigType_enum`.
	Origin string `xml:"origin,omitempty" json:"origin,omitempty"`
	// The state of this ipAddress.
	//
	// Can be one of
	// `HostIpConfigIpV6AddressStatus_enum`
	DadState string `xml:"dadState,omitempty" json:"dadState,omitempty"`
	// The time when will this address expire.
	//
	// If not set
	// the address lifetime is unlimited.
	Lifetime *time.Time `xml:"lifetime" json:"lifetime,omitempty"`
	// Valid values are "add" and "remove".
	//
	// See `HostConfigChangeOperation_enum`.
	Operation string `xml:"operation,omitempty" json:"operation,omitempty"`
}

func init() {
	t["HostIpConfigIpV6Address"] = reflect.TypeOf((*HostIpConfigIpV6Address)(nil)).Elem()
}

// The ipv6 address configuration
type HostIpConfigIpV6AddressConfiguration struct {
	DynamicData

	// Ipv6 adrresses configured on the interface.
	//
	// The global addresses can be configured
	// through DHCP, stateless or manual configuration. Link local addresses can be
	// only configured with the origin set to
	// `other`.
	IpV6Address []HostIpConfigIpV6Address `xml:"ipV6Address,omitempty" json:"ipV6Address,omitempty"`
	// Specify if IPv6 address and routing information information
	// be enabled or not as per RFC 2462.
	AutoConfigurationEnabled *bool `xml:"autoConfigurationEnabled" json:"autoConfigurationEnabled,omitempty"`
	// The flag to indicate whether or not DHCP (dynamic host
	// control protocol) is enabled to obtain an ipV6 address.
	//
	// If this property is set to true, an ipV6 address is configured through dhcpV6.
	DhcpV6Enabled *bool `xml:"dhcpV6Enabled" json:"dhcpV6Enabled,omitempty"`
}

func init() {
	t["HostIpConfigIpV6AddressConfiguration"] = reflect.TypeOf((*HostIpConfigIpV6AddressConfiguration)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, the event is no longer relevant.
//
// This event records that the IP address resolution returned different
// addresses on the host.
//
// Please check your host's network configuration.
type HostIpInconsistentEvent struct {
	HostEvent

	IpAddress  string `xml:"ipAddress" json:"ipAddress"`
	IpAddress2 string `xml:"ipAddress2" json:"ipAddress2"`
}

func init() {
	t["HostIpInconsistentEvent"] = reflect.TypeOf((*HostIpInconsistentEvent)(nil)).Elem()
}

// IP Route Configuration.
//
// All IPv4 addresses, subnet addresses, and
// netmasks are specified as strings using dotted decimal notation.
// For example, "192.0.2.1".
// IPv6 addresses are 128-bit addresses represented
// as eight fields of up to four hexadecimal digits. A colon separates each
// field (:). For example, 2001:DB8:101::230:6eff:fe04:d9ff. The address can
// also consist of symbol '::' to represent multiple 16-bit groups of
// contiguous 0's only once in an address as described in RFC 2373.
type HostIpRouteConfig struct {
	DynamicData

	// The default gateway address.
	DefaultGateway string `xml:"defaultGateway,omitempty" json:"defaultGateway,omitempty"`
	// The gateway device.
	//
	// This applies to service console gateway only, it
	// is ignored otherwise.
	GatewayDevice string `xml:"gatewayDevice,omitempty" json:"gatewayDevice,omitempty"`
	// The default ipv6 gateway address
	IpV6DefaultGateway string `xml:"ipV6DefaultGateway,omitempty" json:"ipV6DefaultGateway,omitempty"`
	// The ipv6 gateway device.
	//
	// This applies to service console gateway only, it
	IpV6GatewayDevice string `xml:"ipV6GatewayDevice,omitempty" json:"ipV6GatewayDevice,omitempty"`
}

func init() {
	t["HostIpRouteConfig"] = reflect.TypeOf((*HostIpRouteConfig)(nil)).Elem()
}

// Dataobject specifying the configuration for IpRoute
type HostIpRouteConfigSpec struct {
	HostIpRouteConfig

	// Choose a gateway device based on what the VirtualNic is connected to.
	//
	// This applies to service console gateway only, it
	// is ignored otherwise.
	GatewayDeviceConnection *HostVirtualNicConnection `xml:"gatewayDeviceConnection,omitempty" json:"gatewayDeviceConnection,omitempty"`
	// The ipv6 gateway device based on what the VirtualNic is connected to.
	//
	// This applies to service console gateway only, it
	// is ignored otherwise.
	IpV6GatewayDeviceConnection *HostVirtualNicConnection `xml:"ipV6GatewayDeviceConnection,omitempty" json:"ipV6GatewayDeviceConnection,omitempty"`
}

func init() {
	t["HostIpRouteConfigSpec"] = reflect.TypeOf((*HostIpRouteConfigSpec)(nil)).Elem()
}

// IpRouteEntry.
//
// Routing entries are individual static routes which combined
// with the default route form all of the routing rules for a host.
type HostIpRouteEntry struct {
	DynamicData

	// Network of the routing entry
	// Of the format "10.20.120.0" or "2001:db8::1428:57"
	Network string `xml:"network" json:"network"`
	// Prefix length of the network (this is the 22 in 10.20.120.0/22)
	PrefixLength int32 `xml:"prefixLength" json:"prefixLength"`
	// Gateway for the routing entry
	Gateway string `xml:"gateway" json:"gateway"`
	// If available the property indicates the device associated with the
	// routing entry.
	//
	// This property can only be read from the server.
	// It will be ignored if set by the client.
	DeviceName string `xml:"deviceName,omitempty" json:"deviceName,omitempty"`
}

func init() {
	t["HostIpRouteEntry"] = reflect.TypeOf((*HostIpRouteEntry)(nil)).Elem()
}

// Routing Entry Operation.
//
// Routing entries are individual static routes
// which combined with the default route form all of the routing rules for
// a host.
type HostIpRouteOp struct {
	DynamicData

	// This property indicates the change operation to apply on
	// this configuration specification.
	//
	// See also `HostConfigChangeOperation_enum`.
	ChangeOperation string `xml:"changeOperation" json:"changeOperation"`
	// The routing entry itself
	Route HostIpRouteEntry `xml:"route" json:"route"`
}

func init() {
	t["HostIpRouteOp"] = reflect.TypeOf((*HostIpRouteOp)(nil)).Elem()
}

// IpRouteEntry.
//
// Routing entries are individual static routes which combined
// with the default route form all of the routing rules for a host.
type HostIpRouteTableConfig struct {
	DynamicData

	// The array of Routing ops (routes to be added/removed)
	IpRoute   []HostIpRouteOp `xml:"ipRoute,omitempty" json:"ipRoute,omitempty"`
	Ipv6Route []HostIpRouteOp `xml:"ipv6Route,omitempty" json:"ipv6Route,omitempty"`
}

func init() {
	t["HostIpRouteTableConfig"] = reflect.TypeOf((*HostIpRouteTableConfig)(nil)).Elem()
}

// IpRouteTableInfo.
//
// This is the list of all static routes on the host
type HostIpRouteTableInfo struct {
	DynamicData

	// The array of IpRouteEntry
	IpRoute   []HostIpRouteEntry `xml:"ipRoute,omitempty" json:"ipRoute,omitempty"`
	Ipv6Route []HostIpRouteEntry `xml:"ipv6Route,omitempty" json:"ipv6Route,omitempty"`
}

func init() {
	t["HostIpRouteTableInfo"] = reflect.TypeOf((*HostIpRouteTableInfo)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, the event is no longer relevant.
//
// This event records that the host's IP address could not be resolved to a short name.
type HostIpToShortNameFailedEvent struct {
	HostEvent
}

func init() {
	t["HostIpToShortNameFailedEvent"] = reflect.TypeOf((*HostIpToShortNameFailedEvent)(nil)).Elem()
}

// The IpmiInfo data object contains IPMI (Intelligent Platform Management Interface)
// and BMC (Baseboard Management Controller) information for the host.
type HostIpmiInfo struct {
	DynamicData

	// IP address of the BMC on the host.
	//
	// It should be null terminated.
	BmcIpAddress string `xml:"bmcIpAddress,omitempty" json:"bmcIpAddress,omitempty"`
	// MAC address of the BMC on the host.
	//
	// The MAC address should be of the
	// form xx:xx:xx:xx:xx:xx where each x is a hex digit. It should be null
	// terminated.
	BmcMacAddress string `xml:"bmcMacAddress,omitempty" json:"bmcMacAddress,omitempty"`
	// User ID for logging into the BMC.
	//
	// BMC usernames may be up to 16
	// characters and must be null terminated. Hence, a login comprises
	// 17 or fewer characters.
	Login string `xml:"login,omitempty" json:"login,omitempty"`
	// Password for logging into the BMC.
	//
	// Only used for configuration, returned as unset
	// while reading. The password can be up to 16 characters and must be null
	// terminated. Hence, a password comprises 17 or fewer characters.
	Password string `xml:"password,omitempty" json:"password,omitempty"`
}

func init() {
	t["HostIpmiInfo"] = reflect.TypeOf((*HostIpmiInfo)(nil)).Elem()
}

// This event records that the isolation address could not be pinged.
//
// The default isolation address is the service console's default gateway.
type HostIsolationIpPingFailedEvent struct {
	HostDasEvent

	IsolationIp string `xml:"isolationIp" json:"isolationIp"`
}

func init() {
	t["HostIsolationIpPingFailedEvent"] = reflect.TypeOf((*HostIsolationIpPingFailedEvent)(nil)).Elem()
}

// Encapsulates information about all licensable resources on the host.
type HostLicensableResourceInfo struct {
	DynamicData

	// List of currently supported resources.
	//
	// The type of every value is long. The key can be one of `HostLicensableResourceKey_enum`
	// or arbitrary string.
	//
	// NOTE:
	// The values in this property may not be accurate for pre-5.0 hosts when returned by vCenter 5.0
	Resource []KeyAnyValue `xml:"resource" json:"resource"`
}

func init() {
	t["HostLicensableResourceInfo"] = reflect.TypeOf((*HostLicensableResourceInfo)(nil)).Elem()
}

// This data object type describes license information stored on the host.
type HostLicenseConnectInfo struct {
	DynamicData

	// License information.
	License LicenseManagerLicenseInfo `xml:"license" json:"license"`
	// Evaluation information.
	Evaluation LicenseManagerEvaluationInfo `xml:"evaluation" json:"evaluation"`
	// Licensable resources information.
	//
	// NOTE:
	// The values in this property may not be accurate for pre-5.0 hosts when returned by vCenter 5.0
	Resource *HostLicensableResourceInfo `xml:"resource,omitempty" json:"resource,omitempty"`
}

func init() {
	t["HostLicenseConnectInfo"] = reflect.TypeOf((*HostLicenseConnectInfo)(nil)).Elem()
}

// This event records an expired host license.
type HostLicenseExpiredEvent struct {
	LicenseEvent
}

func init() {
	t["HostLicenseExpiredEvent"] = reflect.TypeOf((*HostLicenseExpiredEvent)(nil)).Elem()
}

type HostLicenseSpec struct {
	DynamicData

	// License source to be used
	Source BaseLicenseSource `xml:"source,omitempty,typeattr" json:"source,omitempty"`
	// License edition to use
	EditionKey string `xml:"editionKey,omitempty" json:"editionKey,omitempty"`
	// Disabled features.
	//
	// When an edition is set, all the features in it
	// are enabled by default. The following parameter gives a finer
	// control on which features are disabled.
	DisabledFeatureKey []string `xml:"disabledFeatureKey,omitempty" json:"disabledFeatureKey,omitempty"`
	// Enabled features
	EnabledFeatureKey []string `xml:"enabledFeatureKey,omitempty" json:"enabledFeatureKey,omitempty"`
}

func init() {
	t["HostLicenseSpec"] = reflect.TypeOf((*HostLicenseSpec)(nil)).Elem()
}

// This data object type encapsulates a typical set of host information that is useful
// for list views and summary pages.
//
// VirtualCenter can retrieve this information very efficiently, even for a large set
// of hosts.
type HostListSummary struct {
	DynamicData

	// The reference to the host-managed object.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// Basic hardware information, if known.
	Hardware *HostHardwareSummary `xml:"hardware,omitempty" json:"hardware,omitempty"`
	// Basic runtime information, if known.
	Runtime *HostRuntimeInfo `xml:"runtime,omitempty" json:"runtime,omitempty"`
	// Basic configuration information, if known.
	Config HostConfigSummary `xml:"config" json:"config"`
	// Basic host statistics.
	QuickStats HostListSummaryQuickStats `xml:"quickStats" json:"quickStats"`
	// The overall alarm status of the host.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	OverallStatus ManagedEntityStatus `xml:"overallStatus" json:"overallStatus"`
	// Indicates whether or not the host requires a reboot due to a configuration
	// change.
	RebootRequired bool `xml:"rebootRequired" json:"rebootRequired"`
	// The customized field values.
	CustomValue []BaseCustomFieldValue `xml:"customValue,omitempty,typeattr" json:"customValue,omitempty"`
	// IP address of the VirtualCenter server managing this host, if any.
	ManagementServerIp string `xml:"managementServerIp,omitempty" json:"managementServerIp,omitempty"`
	// The most capable Enhanced VMotion Compatibility mode supported by the
	// host hardware and software; unset if this host cannot participate in
	// any EVC mode.
	//
	// See also `Capability.supportedEVCMode`.
	MaxEVCModeKey string `xml:"maxEVCModeKey,omitempty" json:"maxEVCModeKey,omitempty"`
	// The Enhanced VMotion Compatibility mode that is currently in effect
	// for this host.
	//
	// If the host is in a cluster where EVC is active, this
	// will match the cluster's EVC mode; otherwise this will be unset.
	//
	// See also `Capability.supportedEVCMode`.
	CurrentEVCModeKey string `xml:"currentEVCModeKey,omitempty" json:"currentEVCModeKey,omitempty"`
	// The Enhanced VMotion Compatibility Graphics mode that is currently in
	// effect for this host.
	//
	// If the host is in a cluster where EVC is active,
	// this will match the cluster's EVC Graphics mode; otherwise this will
	// be unset.
	//
	// See also `Capability.supportedEVCGraphicsMode`.
	CurrentEVCGraphicsModeKey string `xml:"currentEVCGraphicsModeKey,omitempty" json:"currentEVCGraphicsModeKey,omitempty" vim:"7.0.1.0"`
	// Gateway configuration, if vCenter server manages the host via a gateway
	Gateway        *HostListSummaryGatewaySummary `xml:"gateway,omitempty" json:"gateway,omitempty"`
	TpmAttestation *HostTpmAttestationInfo        `xml:"tpmAttestation,omitempty" json:"tpmAttestation,omitempty"`
	// The attestation information for the host as retrieved from any Trust
	// Authority attestation services configured in the host's parent compute
	// resource.
	//
	// This field will be set only if there is any Trust Authority
	// attestation service configured for the host's parent compute resource,
	// and unset otherwise.
	TrustAuthorityAttestationInfos []HostTrustAuthorityAttestationInfo `xml:"trustAuthorityAttestationInfos,omitempty" json:"trustAuthorityAttestationInfos,omitempty" vim:"7.0.1.0"`
}

func init() {
	t["HostListSummary"] = reflect.TypeOf((*HostListSummary)(nil)).Elem()
}

// This data object type describes information about a host gateway server
// that is used for the connection between vCenter Server and the host.
//
// Gateway servers are identified by type and id. In order to use
// a gateway server it has to be registered with the respective type and id
// in the vCenter Lookup Service.
type HostListSummaryGatewaySummary struct {
	DynamicData

	// The type of the gateway server used for communication with the host.
	//
	// This is an opaque string that depends on how the gateway server is
	// registered with the vCenter Component Manager Service. There might be
	// several gateway servers for the same type.
	GatewayType string `xml:"gatewayType" json:"gatewayType"`
	// Unique ID of the gateway server used for communication with the host.
	//
	// This ID must be a unique identifier for the gateway server as
	// registered in the vCenter Component Manager Service. There must be
	// only one gateway server with the same ID.
	GatewayId string `xml:"gatewayId" json:"gatewayId"`
}

func init() {
	t["HostListSummaryGatewaySummary"] = reflect.TypeOf((*HostListSummaryGatewaySummary)(nil)).Elem()
}

// Basic host statistics.
//
// Included in the host statistics are fairness scores. Fairness scores are
// represented in units with relative values, meaning they are evaluated relative to
// the scores of other hosts. They should not be thought of as having any particular
// absolute value. Each fairness unit represents an increment of 0.001 in a fairness
// score. The further the fairness score diverges from 1, the less fair the
// allocation. Therefore, a fairness score of 990, representing 0.990, is more fair
// than a fairness score of 1015, which represents 1.015. This is because 1.015 is
// further from 1 than 0.990.
type HostListSummaryQuickStats struct {
	DynamicData

	// Aggregated CPU usage across all cores on the host in MHz.
	//
	// This is only
	// available if the host is connected.
	OverallCpuUsage int32 `xml:"overallCpuUsage,omitempty" json:"overallCpuUsage,omitempty"`
	// Physical memory usage on the host in MB.
	//
	// This is only available if the
	// host is connected.
	OverallMemoryUsage int32 `xml:"overallMemoryUsage,omitempty" json:"overallMemoryUsage,omitempty"`
	// The fairness of distributed CPU resource allocation on the host.
	DistributedCpuFairness int32 `xml:"distributedCpuFairness,omitempty" json:"distributedCpuFairness,omitempty"`
	// The fairness of distributed memory resource allocation on the host.
	DistributedMemoryFairness int32 `xml:"distributedMemoryFairness,omitempty" json:"distributedMemoryFairness,omitempty"`
	// The available capacity in MB.
	AvailablePMemCapacity int32 `xml:"availablePMemCapacity,omitempty" json:"availablePMemCapacity,omitempty"`
	// The system uptime of the host in seconds.
	Uptime int32 `xml:"uptime,omitempty" json:"uptime,omitempty"`
}

func init() {
	t["HostListSummaryQuickStats"] = reflect.TypeOf((*HostListSummaryQuickStats)(nil)).Elem()
}

type HostListVStorageObject HostListVStorageObjectRequestType

func init() {
	t["HostListVStorageObject"] = reflect.TypeOf((*HostListVStorageObject)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostListVStorageObject`.
type HostListVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datastore to query for the virtual storage objects.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["HostListVStorageObjectRequestType"] = reflect.TypeOf((*HostListVStorageObjectRequestType)(nil)).Elem()
}

type HostListVStorageObjectResponse struct {
	Returnval []ID `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The `HostLocalAuthenticationInfo` data object represents
// local authentication on the ESX host.
//
// Local authentication
// is always enabled.
type HostLocalAuthenticationInfo struct {
	HostAuthenticationStoreInfo
}

func init() {
	t["HostLocalAuthenticationInfo"] = reflect.TypeOf((*HostLocalAuthenticationInfo)(nil)).Elem()
}

// Local file system volume.
type HostLocalFileSystemVolume struct {
	HostFileSystemVolume

	// The device of the local file system.
	Device string `xml:"device" json:"device"`
}

func init() {
	t["HostLocalFileSystemVolume"] = reflect.TypeOf((*HostLocalFileSystemVolume)(nil)).Elem()
}

// The specification for creating a new local file system volume.
type HostLocalFileSystemVolumeSpec struct {
	DynamicData

	// The device of the local file system.
	Device string `xml:"device" json:"device"`
	// The file path on the host where the file system is mounted.
	LocalPath string `xml:"localPath" json:"localPath"`
}

func init() {
	t["HostLocalFileSystemVolumeSpec"] = reflect.TypeOf((*HostLocalFileSystemVolumeSpec)(nil)).Elem()
}

// This event records when host local port is created to recover from
// management network connectivity loss.
type HostLocalPortCreatedEvent struct {
	DvsEvent

	// The configuration of the new host local port.
	HostLocalPort DVSHostLocalPortInfo `xml:"hostLocalPort" json:"hostLocalPort"`
}

func init() {
	t["HostLocalPortCreatedEvent"] = reflect.TypeOf((*HostLocalPortCreatedEvent)(nil)).Elem()
}

// File layout spec of a virtual disk.
//
// The disk could be either a base-disk
// or a delta disk.
type HostLowLevelProvisioningManagerDiskLayoutSpec struct {
	DynamicData

	// Disk controller type, e.g.
	//
	// vim.vm.device.VirtualSCSIController or
	// vim.vm.device.VirtualIDEController.
	ControllerType string `xml:"controllerType" json:"controllerType"`
	// Bus number associated with the controller for this disk.
	BusNumber int32 `xml:"busNumber" json:"busNumber"`
	// Unit number of this disk on its controller.
	UnitNumber *int32 `xml:"unitNumber" json:"unitNumber,omitempty"`
	// Source disk filename in datastore path.
	SrcFilename string `xml:"srcFilename" json:"srcFilename"`
	// Destination filename in datastore path.
	DstFilename string `xml:"dstFilename" json:"dstFilename"`
}

func init() {
	t["HostLowLevelProvisioningManagerDiskLayoutSpec"] = reflect.TypeOf((*HostLowLevelProvisioningManagerDiskLayoutSpec)(nil)).Elem()
}

type HostLowLevelProvisioningManagerFileDeleteResult struct {
	DynamicData

	FileName string               `xml:"fileName" json:"fileName"`
	Fault    LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["HostLowLevelProvisioningManagerFileDeleteResult"] = reflect.TypeOf((*HostLowLevelProvisioningManagerFileDeleteResult)(nil)).Elem()
}

type HostLowLevelProvisioningManagerFileDeleteSpec struct {
	DynamicData

	FileName string `xml:"fileName" json:"fileName"`
	FileType string `xml:"fileType" json:"fileType"`
}

func init() {
	t["HostLowLevelProvisioningManagerFileDeleteSpec"] = reflect.TypeOf((*HostLowLevelProvisioningManagerFileDeleteSpec)(nil)).Elem()
}

// A FileReserveResult object describles the information of a file reserved
// by the ReserveFiles method.
//
// This includes the original input ReserveFiles
// method so that the caller can map the input with the reserved file. All
// paths will be the complete local path in the url format.
type HostLowLevelProvisioningManagerFileReserveResult struct {
	DynamicData

	BaseName     string `xml:"baseName" json:"baseName"`
	ParentDir    string `xml:"parentDir" json:"parentDir"`
	ReservedName string `xml:"reservedName" json:"reservedName"`
}

func init() {
	t["HostLowLevelProvisioningManagerFileReserveResult"] = reflect.TypeOf((*HostLowLevelProvisioningManagerFileReserveResult)(nil)).Elem()
}

type HostLowLevelProvisioningManagerFileReserveSpec struct {
	DynamicData

	BaseName       string `xml:"baseName" json:"baseName"`
	ParentDir      string `xml:"parentDir" json:"parentDir"`
	FileType       string `xml:"fileType" json:"fileType"`
	StorageProfile string `xml:"storageProfile" json:"storageProfile"`
}

func init() {
	t["HostLowLevelProvisioningManagerFileReserveSpec"] = reflect.TypeOf((*HostLowLevelProvisioningManagerFileReserveSpec)(nil)).Elem()
}

// File layout spec of a snapshot, including path to the vmsn file of the
// snapshot and the layout of virtual disks when the snapshot was taken.
type HostLowLevelProvisioningManagerSnapshotLayoutSpec struct {
	DynamicData

	// The unique identifier of the snapshot
	Id int32 `xml:"id" json:"id"`
	// Name of the source snapshot file in datastore path.
	SrcFilename string `xml:"srcFilename" json:"srcFilename"`
	// Name of the destination snapshot file in datastore path.
	DstFilename string `xml:"dstFilename" json:"dstFilename"`
	// Layout of each virtual disk of the virtual machine when the
	// snapshot was taken.
	Disk []HostLowLevelProvisioningManagerDiskLayoutSpec `xml:"disk,omitempty" json:"disk,omitempty"`
}

func init() {
	t["HostLowLevelProvisioningManagerSnapshotLayoutSpec"] = reflect.TypeOf((*HostLowLevelProvisioningManagerSnapshotLayoutSpec)(nil)).Elem()
}

// The status of a virtual machine migration operation.
type HostLowLevelProvisioningManagerVmMigrationStatus struct {
	DynamicData

	// Unique identifier for this operation, currently it's unique
	// within one virtual center instance.
	MigrationId int64 `xml:"migrationId" json:"migrationId"`
	// Manner in which the migration process is performed.
	//
	// The set of
	// possible values is described in
	// `HostVMotionManagerVMotionType_enum`.
	Type string `xml:"type" json:"type"`
	// Whether the virtual machine is the source of the migration.
	//
	// For disk only migration, the value is always true.
	Source bool `xml:"source" json:"source"`
	// Whether the operation is considered successful.
	//
	// A migration
	// operation is considered successful if its switch over phase has
	// completed successfully.
	//
	// More specifically, for an in-progress migration, it is considered
	// successful if it has had a sucessful switch over, otherwise it is
	// considered unsuccessful. Likewise, the status of a completed
	// migration operation is also based on the switch over completion
	// status.
	//
	// The difference between a completed vs. in-progress migration with
	// the same consideredSuccessful property is that in the former case
	// the server is able to complete the clean up process thus leaves
	// nothing for the recovery process to clean up.
	ConsideredSuccessful bool `xml:"consideredSuccessful" json:"consideredSuccessful"`
}

func init() {
	t["HostLowLevelProvisioningManagerVmMigrationStatus"] = reflect.TypeOf((*HostLowLevelProvisioningManagerVmMigrationStatus)(nil)).Elem()
}

// Virtual machine information that can be used for recovery, for
// example, to decide whether to register a virtual machine with a
// server if the virtual machine is currently unregistered.
//
// This data
// object does not contain a complete virtual machine configuration,
// but a subset of information available from `VirtualMachineConfigInfo`, all of which are available via virtual machine
// configuration files.
//
// The documentation for each property in this data object describes
// the property in `VirtualMachineConfigInfo` that contains the same
// information if available.
type HostLowLevelProvisioningManagerVmRecoveryInfo struct {
	DynamicData

	// The hardware version of this virtual machine.
	//
	// Same as
	// `VirtualMachineConfigInfo.version`.
	Version string `xml:"version" json:"version"`
	// 128-bit SMBIOS UUID of this virtual machine.
	//
	// Same as
	// `VirtualMachineConfigInfo.uuid`.
	BiosUUID string `xml:"biosUUID" json:"biosUUID"`
	// VirtualCenter-specific 128-bit UUID of this virtual machine.
	//
	// Same
	// as `VirtualMachineConfigInfo.instanceUuid`.
	InstanceUUID string `xml:"instanceUUID" json:"instanceUUID"`
	// Fault Tolerance settings for this virtual machine.
	//
	// Same as
	// `VirtualMachineConfigInfo.ftInfo`. Unset if non FT.
	FtInfo BaseFaultToleranceConfigInfo `xml:"ftInfo,omitempty,typeattr" json:"ftInfo,omitempty"`
}

func init() {
	t["HostLowLevelProvisioningManagerVmRecoveryInfo"] = reflect.TypeOf((*HostLowLevelProvisioningManagerVmRecoveryInfo)(nil)).Elem()
}

// The `HostMaintenanceSpec` data object may be used to specify
// actions to be taken by a host upon entering maintenance mode.
//
// If the `HostMaintenanceSpec` or any of its fields are omitted in a
// call to `HostSystem.EnterMaintenanceMode_Task`, default actions
// will be chosen as documented for each field's type.
//
// See also `HostSystem.EnterMaintenanceMode_Task`, `VsanHostDecommissionMode`.
type HostMaintenanceSpec struct {
	DynamicData

	// The `VsanHostDecommissionMode` for this MaintenanceSpec.
	VsanMode *VsanHostDecommissionMode `xml:"vsanMode,omitempty" json:"vsanMode,omitempty"`
	// Maintenance mode reason code.
	//
	// See `HostMaintenanceSpecPurpose_enum` for valid values.
	Purpose string `xml:"purpose,omitempty" json:"purpose,omitempty"`
}

func init() {
	t["HostMaintenanceSpec"] = reflect.TypeOf((*HostMaintenanceSpec)(nil)).Elem()
}

// This class defines healthcheck result of the vSphere Distributed Switch.
type HostMemberHealthCheckResult struct {
	DynamicData

	// The summary of health check result.
	Summary string `xml:"summary,omitempty" json:"summary,omitempty"`
}

func init() {
	t["HostMemberHealthCheckResult"] = reflect.TypeOf((*HostMemberHealthCheckResult)(nil)).Elem()
}

// The `HostMemberRuntimeInfo` data object
// contains healthcheck and status information about a host
// member of a distributed virtual switch.
type HostMemberRuntimeInfo struct {
	DynamicData

	// The host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Host proxy switch status.
	//
	// See
	// `HostComponentState` for valid values.
	// This property replaces the deprecated
	// `DistributedVirtualSwitchHostMember*.*DistributedVirtualSwitchHostMember.status`.
	Status string `xml:"status,omitempty" json:"status,omitempty"`
	// Additional information regarding the current membership status of the host.
	//
	// This property replaces the deprecated
	// `DistributedVirtualSwitchHostMember*.*DistributedVirtualSwitchHostMember.statusDetail`.
	StatusDetail string `xml:"statusDetail,omitempty" json:"statusDetail,omitempty"`
	// NSX-T component status.
	NsxtStatus string `xml:"nsxtStatus,omitempty" json:"nsxtStatus,omitempty"`
	// Additional information regarding the NSX-T component status.
	NsxtStatusDetail string `xml:"nsxtStatusDetail,omitempty" json:"nsxtStatusDetail,omitempty"`
	// Health check result for the host that joined the distributed virtual switch.
	HealthCheckResult []BaseHostMemberHealthCheckResult `xml:"healthCheckResult,omitempty,typeattr" json:"healthCheckResult,omitempty"`
	// Indicate the runtime state of uplink on the host.
	//
	// It is only applicable when `DistributedVirtualSwitchHostMemberConfigInfo.networkOffloadingEnabled`
	// is true.
	HostUplinkState []DistributedVirtualSwitchHostMemberHostUplinkState `xml:"hostUplinkState,omitempty" json:"hostUplinkState,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["HostMemberRuntimeInfo"] = reflect.TypeOf((*HostMemberRuntimeInfo)(nil)).Elem()
}

// This class defines healthcheck result of a specified Uplink port
// in vSphere Distributed Switch.
type HostMemberUplinkHealthCheckResult struct {
	HostMemberHealthCheckResult

	// The uplink port key.
	UplinkPortKey string `xml:"uplinkPortKey" json:"uplinkPortKey"`
}

func init() {
	t["HostMemberUplinkHealthCheckResult"] = reflect.TypeOf((*HostMemberUplinkHealthCheckResult)(nil)).Elem()
}

// The `HostMemoryProfile` data object represents
// memory configuration for the host.
//
// This may not be valid all versions of the host.
//
// Use the `ApplyProfile.policy` list for access to configuration data
// for the host memory profile. Use the `ApplyProfile.property` list
// for access to subprofile configuration data, if any.
type HostMemoryProfile struct {
	ApplyProfile
}

func init() {
	t["HostMemoryProfile"] = reflect.TypeOf((*HostMemoryProfile)(nil)).Elem()
}

// DataObject used for configuring the memory setting
type HostMemorySpec struct {
	DynamicData

	// Service Console reservation in bytes.
	ServiceConsoleReservation int64 `xml:"serviceConsoleReservation,omitempty" json:"serviceConsoleReservation,omitempty"`
}

func init() {
	t["HostMemorySpec"] = reflect.TypeOf((*HostMemorySpec)(nil)).Elem()
}

// Information about a memory tier on this host.
type HostMemoryTierInfo struct {
	DynamicData

	// Descriptive name for the memory tier.
	Name string `xml:"name" json:"name"`
	// Type of the memory tier.
	//
	// See `HostMemoryTierType_enum` for supported values.
	Type string `xml:"type" json:"type"`
	// Flags pertaining to the memory tier.
	//
	// See `HostMemoryTierFlags_enum` for supported
	// values.
	Flags []string `xml:"flags,omitempty" json:"flags,omitempty"`
	// System internal flags pertaining to the memory tier.
	//
	// See
	// `HostMemoryTierInternalFlags_enum` for supported values.
	InternalFlags []string `xml:"internalFlags,omitempty" json:"internalFlags,omitempty" vim:"8.0.3.0"`
	// Size of the memory tier in bytes.
	Size int64 `xml:"size" json:"size"`
}

func init() {
	t["HostMemoryTierInfo"] = reflect.TypeOf((*HostMemoryTierInfo)(nil)).Elem()
	minAPIVersionForType["HostMemoryTierInfo"] = "7.0.3.0"
}

// Deprecated as of vSphere API 5.0, the event is no longer relevant.
//
// This event records the fact that a host is missing networks that
// other hosts are using for HA communication
type HostMissingNetworksEvent struct {
	HostDasEvent

	Ips string `xml:"ips,omitempty" json:"ips,omitempty"`
}

func init() {
	t["HostMissingNetworksEvent"] = reflect.TypeOf((*HostMissingNetworksEvent)(nil)).Elem()
}

// This event records when host monitoring state has changed.
type HostMonitoringStateChangedEvent struct {
	ClusterEvent

	// The service state in
	// `ClusterDasConfigInfoServiceState_enum`
	State string `xml:"state" json:"state"`
	// The previous service state in
	// `ClusterDasConfigInfoServiceState_enum`
	PrevState string `xml:"prevState,omitempty" json:"prevState,omitempty"`
}

func init() {
	t["HostMonitoringStateChangedEvent"] = reflect.TypeOf((*HostMonitoringStateChangedEvent)(nil)).Elem()
}

// The `HostMountInfo` data object provides information related
// to a configured mount point.
//
// This object does not include information
// about the mounted file system. (See `HostFileSystemMountInfo`.)
type HostMountInfo struct {
	DynamicData

	// Local file path where file system volume is mounted, if applicable.
	//
	// This path identifies the file system volume from the point of view
	// of the host.
	Path string `xml:"path,omitempty" json:"path,omitempty"`
	// Access mode to the underlying file system for this host.
	AccessMode string `xml:"accessMode" json:"accessMode"`
	// The mount state of this mount point.
	//
	// For a discovered
	// volume, which is mounted, this is true. When this value is
	// unset, the default value is true.
	Mounted *bool `xml:"mounted" json:"mounted,omitempty"`
	// Flag that indicates if the datastore is currently accessible from
	// the host.
	//
	// For the case of a standalone host, this property has the same value as
	// `DatastoreSummary*.*DatastoreSummary.accessible`.
	// You can use the `DatastoreSummary` property if the `HostMountInfo`
	// property is not set. The VirtualCenter Server will always make
	// sure the `DatastoreSummary` property is set correctly.
	Accessible *bool `xml:"accessible" json:"accessible,omitempty"`
	// This optional property for inaccessible reason is reported only if
	// a datastore becomes inaccessible as reported by
	// `HostMountInfo.accessible` and
	// `DatastoreSummary*.*DatastoreSummary.accessible`.
	//
	// The values for inaccessible reason are defined in the enum
	// `HostMountInfoInaccessibleReason_enum`
	// This helps to determine host specific reason for datastore inaccessibility.
	// If the datastore becomes accessible following an inaccessible condition,
	// the property `HostMountInfo.inaccessibleReason` will be unset.
	InaccessibleReason string `xml:"inaccessibleReason,omitempty" json:"inaccessibleReason,omitempty"`
	// The name of the vmknic used during mount.
	//
	// Populated by the vmk control layer if the NAS
	// volume is mounted successfully with a vmknic binding.
	VmknicName string `xml:"vmknicName,omitempty" json:"vmknicName,omitempty" vim:"8.0.1.0"`
	// Indicates whether vmknic is active or inactive.
	//
	// This field will be populated by vmk control layer during
	// NAS volume mount, and will be set to true if the
	// vmknic binding is active.
	VmknicActive *bool `xml:"vmknicActive" json:"vmknicActive,omitempty" vim:"8.0.1.0"`
	// The optional property which gives the reason for mount operation
	// failure of NFS datastore.
	//
	// This field is applicable for only those
	// mounts for which retry mount operation is configured.
	// The values for the mount failed reason are defined in the enum
	// `HostMountInfoMountFailedReason_enum`.
	// If mount operation on NFS volume succeeds in the retry, then
	// the property `HostMountInfo.mountFailedReason` will be unset.
	MountFailedReason string `xml:"mountFailedReason,omitempty" json:"mountFailedReason,omitempty" vim:"8.0.0.1"`
	// Maintained for each Host, it indicates the total number of TCP
	// connections for the NAS datastore
	NumTcpConnections int32 `xml:"numTcpConnections,omitempty" json:"numTcpConnections,omitempty" vim:"8.0.1.0"`
}

func init() {
	t["HostMountInfo"] = reflect.TypeOf((*HostMountInfo)(nil)).Elem()
}

// The `HostMultipathInfo` data object describes the multipathing policy
// configuration to determine the storage failover policies
// for a SCSI logical unit.
//
// The multipathing policy configuration operates on
// SCSI logical units and the paths to the logical units.
//
// Multipath policy configuration is only possible on storage devices
// provided by the native multipathing plug-store plugin. Storage devices
// using the native multipathing storage plugin will have an entry
// in this data object. Storage devices provided by a different
// storage plugin will not appear in the inventory represented by
// this data object.
//
// Legacy note: In hosts where `HostMultipathStateInfo` is not
// defined or does not exist on the `HostStorageDeviceInfo` object,
// only native multipathing exists. That means for these hosts, the
// MultipathInfo object contains the complete set of LUNs and paths on the LUNs
// available on the host.
type HostMultipathInfo struct {
	DynamicData

	// List of logical units that can be configured for multipathing.
	Lun []HostMultipathInfoLogicalUnit `xml:"lun,omitempty" json:"lun,omitempty"`
}

func init() {
	t["HostMultipathInfo"] = reflect.TypeOf((*HostMultipathInfo)(nil)).Elem()
}

// The `HostMultipathInfoFixedLogicalUnitPolicy` data object
// describes a multipathing policy for a logical unit which uses
// a preferred path whenever possible.
type HostMultipathInfoFixedLogicalUnitPolicy struct {
	HostMultipathInfoLogicalUnitPolicy

	// Preferred path used for the `*fixed*` policy.
	Prefer string `xml:"prefer" json:"prefer"`
}

func init() {
	t["HostMultipathInfoFixedLogicalUnitPolicy"] = reflect.TypeOf((*HostMultipathInfoFixedLogicalUnitPolicy)(nil)).Elem()
}

// The `HostMultipathInfoHppLogicalUnitPolicy` data object
// describes a multipathing policy for a HPP claimed logical unit and
// its configuration.
type HostMultipathInfoHppLogicalUnitPolicy struct {
	HostMultipathInfoLogicalUnitPolicy

	// Byte count on the paths will be used as criteria to switch path
	// for the device.
	//
	// Allowed values 1 to (100\`1024\`1024)
	// Default Value 10\`1024\`1024
	Bytes int64 `xml:"bytes,omitempty" json:"bytes,omitempty"`
	// IOPS count on the paths will be used as criteria to switch path
	// for the device.
	//
	// Allowed values 1 to 10000
	// Default Value 1000
	Iops int64 `xml:"iops,omitempty" json:"iops,omitempty"`
	// The preferred path for the given device.
	//
	// If no prefered path is specified by the user, algorithem at ESX
	// side will choose the random possible path.
	Path string `xml:"path,omitempty" json:"path,omitempty"`
	// This value can control at what interval (in ms) the latency of
	// paths should be evaluated.
	//
	// Allowed values 10000 to (300 \* 1000) in ms
	// Default Value 30 \* 1000
	LatencyEvalTime int64 `xml:"latencyEvalTime,omitempty" json:"latencyEvalTime,omitempty"`
	// This value will control how many sample IOs should be issued on
	// each path to calculate latency of the path.
	//
	// Allowed values 16 to 160
	// Default Value 16
	SamplingIosPerPath int64 `xml:"samplingIosPerPath,omitempty" json:"samplingIosPerPath,omitempty"`
}

func init() {
	t["HostMultipathInfoHppLogicalUnitPolicy"] = reflect.TypeOf((*HostMultipathInfoHppLogicalUnitPolicy)(nil)).Elem()
}

// The `HostMultipathInfoLogicalUnit` data object
// represents a storage entity that provides disk blocks to a host.
type HostMultipathInfoLogicalUnit struct {
	DynamicData

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
	// Identifier of LogicalUnit.
	//
	// Use this id to configure LogicalUnit multipathing policy using `HostStorageSystem.SetMultipathLunPolicy`.
	Id string `xml:"id" json:"id"`
	// SCSI device corresponding to logical unit.
	Lun string `xml:"lun" json:"lun"`
	// Array of paths available to access this LogicalUnit.
	Path []HostMultipathInfoPath `xml:"path" json:"path"`
	// Policy that the logical unit should use when selecting a path.
	Policy BaseHostMultipathInfoLogicalUnitPolicy `xml:"policy,typeattr" json:"policy"`
	// Policy used to determine how a storage device is accessed.
	//
	// This policy
	// is currently immutable.
	StorageArrayTypePolicy *HostMultipathInfoLogicalUnitStorageArrayTypePolicy `xml:"storageArrayTypePolicy,omitempty" json:"storageArrayTypePolicy,omitempty"`
}

func init() {
	t["HostMultipathInfoLogicalUnit"] = reflect.TypeOf((*HostMultipathInfoLogicalUnit)(nil)).Elem()
}

// The `HostMultipathInfoLogicalUnitPolicy` data object
// describes a path selection policy for a device.
//
// This policy determines
// how paths should be utilized when accessing a device.
type HostMultipathInfoLogicalUnitPolicy struct {
	DynamicData

	// String representing the path selection policy for a device.
	//
	// Use one of the following
	// strings:
	// For NMP plugin
	//   - <code>VMW\_PSP\_FIXED</code> - Use a preferred path whenever possible.
	//   - <code>VMW\_PSP\_RR</code> - Load balance.
	//   - <code>VMW\_PSP\_MRU</code> - Use the most recently used path.
	//
	// For HPP plugin
	//   - <code>FIXED</code> - Use a preferred path whenever possible.
	//   - <code>LB-RR</code> - Load Balance - round robin.
	//   - <code>LB-IOPS</code> - Load Balance - iops.
	//   - <code>LB-BYTES</code> - Load Balance - bytes.
	//   - <code>LB--Latency</code> - Load balance - least latency.
	//
	// You can also use the
	// `HostStorageSystem.QueryPathSelectionPolicyOptions` method
	// to retrieve the set of valid strings.
	// Use the key from the resulting structure
	// `HostPathSelectionPolicyOption`.
	Policy string `xml:"policy" json:"policy"`
}

func init() {
	t["HostMultipathInfoLogicalUnitPolicy"] = reflect.TypeOf((*HostMultipathInfoLogicalUnitPolicy)(nil)).Elem()
}

// The `HostMultipathInfoLogicalUnitStorageArrayTypePolicy`
// data object describes a storage array type policy for
// for a device.
//
// This policy determines how device I/O and management
// is performed.
type HostMultipathInfoLogicalUnitStorageArrayTypePolicy struct {
	DynamicData

	// String indicating the storage array type policy.
	Policy string `xml:"policy" json:"policy"`
}

func init() {
	t["HostMultipathInfoLogicalUnitStorageArrayTypePolicy"] = reflect.TypeOf((*HostMultipathInfoLogicalUnitStorageArrayTypePolicy)(nil)).Elem()
}

// The `HostMultipathInfoPath` data object
// is a storage entity that represents a topological path from a
// host bus adapter to a SCSI logical unit.
//
// Each path is unique although each
// host bus adapter/SCSI logical unit pair can have multiple paths.
//
// Path objects are identified by a key. The specifics of how
// the key is formatted are dependent on the implementation. Example
// implementations include using strings like "vmhba1:0:0:0".
type HostMultipathInfoPath struct {
	DynamicData

	// Identifier of the path.
	Key string `xml:"key" json:"key"`
	// Name of path.
	//
	// Use this name to configure LogicalUnit multipathing policy using `HostStorageSystem.EnableMultipathPath` and `HostStorageSystem.DisableMultipathPath`.
	Name string `xml:"name" json:"name"`
	// Deprecated as of VI API 4.0:
	//   - System reported path states are available in `HostMultipathInfoPath.state`.
	//   - Paths slated for I/O can be found using `HostMultipathInfoPath.isWorkingPath`.
	//
	// State of the path.
	//
	// Must be one of the values of
	// `MultipathState_enum`
	// <dl>
	// <dt>active</dt>
	// <dd>Path can be used for I/O and is currently a working path.</dd>
	// <dt>standby</dt>
	// <dd>Path can be used for I/O but is not a working path or can be
	// used if active paths fail.</dd>
	// <dt>disabled</dt>
	// <dd>Path has been administratively disabled.</dd>
	// <dt>dead</dt>
	// <dd>Path cannot be used for I/O.</dd>
	// <dt>unknown</dt>
	// <dd>Path is in unknown error state.</dd>
	// </dl>
	PathState string `xml:"pathState" json:"pathState"`
	// System-reported state of the path.
	//
	// Must be one of the values of
	// `MultipathState_enum`
	// <dl>
	// <dt>active</dt>
	// <dd>Path can be used for I/O.</dd>
	// <dt>standby</dt>
	// <dd>Path can be used for I/O if active paths fail.</dd>
	// <dt>disabled</dt>
	// <dd>Path has been administratively disabled.</dd>
	// <dt>dead</dt>
	// <dd>Path cannot be used for I/O.</dd>
	// <dt>unknown</dt>
	// <dd>Path is in unknown error state.</dd>
	// </dl>
	State string `xml:"state,omitempty" json:"state,omitempty"`
	// A path, managed by a given path selection policy(psp) plugin, is
	// denoted to be a Working Path if the psp plugin is likely to select the
	// path for performing I/O in the near future.
	IsWorkingPath *bool `xml:"isWorkingPath" json:"isWorkingPath,omitempty"`
	// The host bus adapter at one endpoint of this path.
	Adapter string `xml:"adapter" json:"adapter"`
	// The logical unit at one endpoint of this path.
	Lun string `xml:"lun" json:"lun"`
	// Transport information for the target end of the path.
	Transport BaseHostTargetTransport `xml:"transport,omitempty,typeattr" json:"transport,omitempty"`
}

func init() {
	t["HostMultipathInfoPath"] = reflect.TypeOf((*HostMultipathInfoPath)(nil)).Elem()
}

// This data object type describes the state of storage paths on the host.
//
// All storage paths on the host are enumerated in this data object.
//
// The reason all path state information is encapsulated in this data
// object is because the path may actively change. This data object
// ensures that a request to gather path state changes only needs to
// fetch this data object.
type HostMultipathStateInfo struct {
	DynamicData

	// List of paths on the system and their path states.
	Path []HostMultipathStateInfoPath `xml:"path,omitempty" json:"path,omitempty"`
}

func init() {
	t["HostMultipathStateInfo"] = reflect.TypeOf((*HostMultipathStateInfo)(nil)).Elem()
}

// Data object indicating state of storage path for a named path.
type HostMultipathStateInfoPath struct {
	DynamicData

	// Name of path.
	//
	// Use this name to enable or disable storage paths `HostStorageSystem.EnableMultipathPath` and `HostStorageSystem.DisableMultipathPath`.
	//
	// In addition to being the identifier for the path state
	// operations, the name is used to correlate this object to the
	// corresponding Path object in other contexts.
	//
	// See also `HostPlugStoreTopologyPath.name`.
	Name string `xml:"name" json:"name"`
	// The state of the path.
	//
	// Must be one of the values of
	// `MultipathState_enum`.
	PathState string `xml:"pathState" json:"pathState"`
}

func init() {
	t["HostMultipathStateInfoPath"] = reflect.TypeOf((*HostMultipathStateInfoPath)(nil)).Elem()
}

type HostNasVolume struct {
	HostFileSystemVolume

	// The host that runs the NFS/CIFS server.
	//
	// Clients must plan to use remoteHostNames for both NFS v3
	// as well as NFS v4.1 because this field remoteHost may be
	// deprecated in future.
	RemoteHost string `xml:"remoteHost" json:"remoteHost"`
	// The remote path of NFS/CIFS mount point.
	RemotePath string `xml:"remotePath" json:"remotePath"`
	// In case of CIFS, the user name used while connecting to the server.
	UserName string `xml:"userName,omitempty" json:"userName,omitempty"`
	// This field will hold host names (or ip addresses) of all
	// remote hosts configured for the datastore.
	//
	// In case of NFS v3 it will have one hostname which will be
	// the same value as in remoteHost defined above.
	// In case of NFS v4.1 if the NFS Client detects additional
	// hostnames or ip addresses during its negotiations with the
	// NFS server, those additional host names (connections) will be
	// added to this list after the datastore is created.
	// Addition of hostnames to this list is limited to MDS server host names
	// or the IP addresses. In other words, the Data Server host names IP addresses
	// will not be appended to this list.
	RemoteHostNames []string `xml:"remoteHostNames,omitempty" json:"remoteHostNames,omitempty"`
	// Security type the volume is currently using.
	//
	// See `HostNasVolumeSecurityType_enum`
	SecurityType string `xml:"securityType,omitempty" json:"securityType,omitempty"`
	// Indicates that this NAS volume is protocol endpoint.
	//
	// This
	// property will be populated if and only if host supports
	// VirtualVolume based Datastore. Check the host capability
	// `HostCapability.virtualVolumeDatastoreSupported`.
	// See `HostProtocolEndpoint`.
	ProtocolEndpoint *bool `xml:"protocolEndpoint" json:"protocolEndpoint,omitempty"`
}

func init() {
	t["HostNasVolume"] = reflect.TypeOf((*HostNasVolume)(nil)).Elem()
}

// This describes the NAS Volume configuration containing
// the configurable properties on a NAS Volume
type HostNasVolumeConfig struct {
	DynamicData

	// Indicates the change operation to apply on this configuration
	// specification.
	//
	// See also `HostConfigChangeOperation_enum`.
	ChangeOperation string `xml:"changeOperation,omitempty" json:"changeOperation,omitempty"`
	// The specification volume.
	Spec *HostNasVolumeSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["HostNasVolumeConfig"] = reflect.TypeOf((*HostNasVolumeConfig)(nil)).Elem()
}

// Specification for creating NAS volume.
//
// When mounting a NAS volume on multiple hosts, the same remoteHost and remotePath
// values should be used on every host, otherwise it will be treated as different
// datastores. For example, if one host references the remotePath of a NAS volume
// as "/mnt/mount1" and another references it as "/mnt/mount1/", it will not be
// recognized as the same datastore.
type HostNasVolumeSpec struct {
	DynamicData

	// The host that runs the NFS v3 or CIFS server.
	//
	// For NFS v4.1
	// and beyond use remoteHostNames defined later. The field remotehost
	// may be deprecated in future for NFS, so clients should plan to use the
	// property remoteHostNames to send in the host name(s) for both NFS v3
	// and v4.1
	RemoteHost string `xml:"remoteHost" json:"remoteHost"`
	// The remote path of the NFS mount point.
	RemotePath string `xml:"remotePath" json:"remotePath"`
	// The localPath refers to the name of the NAS datastore to be created
	// using this specification.
	//
	// In the case of ESX Server, the datastore name is a component in the
	// file system path at which the NAS volume can be found. For example,
	// if localPath is set to "nas\_volume" the created NAS datastore will be
	// named "nas\_volume" and it can be accessed via the file system path
	// "/vmfs/volumes/nas\_volume".
	//
	// In the case of VMware Server, the localPath will also be used as the
	// datastore name, but the datastore name may not necessarily be
	// reflected in the file system path where the NAS volume may be
	// accessed.
	LocalPath string `xml:"localPath" json:"localPath"`
	// Access mode for the mount point.
	//
	// Mounting in read-write mode would be successful irregardless on
	// how the mount point is exported or access permissions. For
	// example, mounting a volume that is exported as read-only as
	// readWrite will succeed. Hence, that a readWrite mount succeeds
	// should not be taken as an indication that all files on a mount
	// is writable.
	//
	// If a file system is mounted readOnly, the system cannot create
	// or modify any files on the file system. This is mostly useful
	// for storing ISO images and templates, since a virtual machine
	// cannot be powered on from a readOnly volume.
	//
	// The access mode of a mounted NFS volume can be obtained at
	// `HostMountInfo.accessMode`.
	//
	// See also `HostMountMode_enum`.
	AccessMode string `xml:"accessMode" json:"accessMode"`
	// Specifies the type of the the NAS volume.
	//
	// Supported types are
	// `CIFS`,
	// `NFS`,
	// `NFS41`
	// If not specified, defaults to
	// `NFS`
	Type string `xml:"type,omitempty" json:"type,omitempty"`
	// If type is CIFS, the user name to use when connecting to the
	// CIFS server.
	//
	// If type is NFS, this field will be ignored.
	UserName string `xml:"userName,omitempty" json:"userName,omitempty"`
	// If type is CIFS, the password to use when connecting to the
	// CIFS server.
	//
	// If type is NFS, this field will be ignored.
	Password string `xml:"password,omitempty" json:"password,omitempty"`
	// Hostnames or IP addresses of remote NFS server.
	//
	// In case
	// of NFS v4.1 this may have multiple entries. For NFS v3 the
	// input should be same in both remoteHost and remoteHostNames.
	// In case of NFS v4.1, if vmknic binding is enabled,
	// then input can be in format {hostip1:vmknic1, hostip2:vmknic2}.
	RemoteHostNames []string `xml:"remoteHostNames,omitempty" json:"remoteHostNames,omitempty"`
	// Provided during mount indicating what security type,
	// if any, to use
	// See `HostNasVolumeSecurityType_enum`
	SecurityType string `xml:"securityType,omitempty" json:"securityType,omitempty"`
	// Name of the vmknic to be used by this mount.
	//
	// This field will be updated by a client with vmknic that will be used
	// for NAS volume mount operation for vmknic binding for NFSv3
	VmknicToBind string `xml:"vmknicToBind,omitempty" json:"vmknicToBind,omitempty" vim:"8.0.1.0"`
	// Indicates whether a client wants to bind this mount to vmknic.
	//
	// This field will be set to true by a client if vmknic should bind
	// during NAS volume mount operation for NFSv3
	// else it will be set to false
	VmknicBound *bool `xml:"vmknicBound" json:"vmknicBound,omitempty" vim:"8.0.1.0"`
	// Indicates the number of TCP connections for the particular
	// NFSv3 Server during NAS volume mount operation.
	//
	// If unset or set to 0, it defaults to one connection
	Connections int32 `xml:"connections,omitempty" json:"connections,omitempty" vim:"8.0.1.0"`
}

func init() {
	t["HostNasVolumeSpec"] = reflect.TypeOf((*HostNasVolumeSpec)(nil)).Elem()
}

// NFS user authentication information
type HostNasVolumeUserInfo struct {
	DynamicData

	// User name for authentication.
	User string `xml:"user" json:"user"`
}

func init() {
	t["HostNasVolumeUserInfo"] = reflect.TypeOf((*HostNasVolumeUserInfo)(nil)).Elem()
}

// A network address translation (NAT) service instance provides
// firewall and network address translation services for a virtual
// network.
type HostNatService struct {
	DynamicData

	// The instance ID of the NAT service.
	Key string `xml:"key" json:"key"`
	// The configurable properties for the NatService object.
	Spec HostNatServiceSpec `xml:"spec" json:"spec"`
}

func init() {
	t["HostNatService"] = reflect.TypeOf((*HostNatService)(nil)).Elem()
}

// This data object type describes the network address
// translation (NAT) service configuration
// representing both the configured properties
// on a NAT Service and identification information.
type HostNatServiceConfig struct {
	DynamicData

	// Indicates the change operation to apply on this configuration
	// specification.
	//
	// See also `HostConfigChangeOperation_enum`.
	ChangeOperation string `xml:"changeOperation,omitempty" json:"changeOperation,omitempty"`
	// The instance ID of the NAT service.
	Key string `xml:"key" json:"key"`
	// The specification of the NAT service.
	Spec HostNatServiceSpec `xml:"spec" json:"spec"`
}

func init() {
	t["HostNatServiceConfig"] = reflect.TypeOf((*HostNatServiceConfig)(nil)).Elem()
}

// This data object type specifies the information for the
// name servers.
type HostNatServiceNameServiceSpec struct {
	DynamicData

	// The flag to indicate whether or not the DNS server should
	// be automatically detected or specified explicitly.
	DnsAutoDetect bool `xml:"dnsAutoDetect" json:"dnsAutoDetect"`
	// The policy to use when multiple DNS addresses are available
	// on the host.
	DnsPolicy string `xml:"dnsPolicy" json:"dnsPolicy"`
	// The number of retries before giving up on a DNS request
	// from a virtual network.
	DnsRetries int32 `xml:"dnsRetries" json:"dnsRetries"`
	// The time (in seconds) before retrying a DNS request to an external
	// network.
	DnsTimeout int32 `xml:"dnsTimeout" json:"dnsTimeout"`
	// The list of DNS servers.
	DnsNameServer []string `xml:"dnsNameServer,omitempty" json:"dnsNameServer,omitempty"`
	// The time (in seconds) allotted for queries to the NetBIOS
	// Datagram Server (NBDS).
	NbdsTimeout int32 `xml:"nbdsTimeout" json:"nbdsTimeout"`
	// Number of retries for each query to the NBNS.
	NbnsRetries int32 `xml:"nbnsRetries" json:"nbnsRetries"`
	// The time (in seconds) allotted for queries to the NBNS.
	NbnsTimeout int32 `xml:"nbnsTimeout" json:"nbnsTimeout"`
}

func init() {
	t["HostNatServiceNameServiceSpec"] = reflect.TypeOf((*HostNatServiceNameServiceSpec)(nil)).Elem()
}

// This data object type describes the
// Network Address Translation (NAT) port forwarding specification.
type HostNatServicePortForwardSpec struct {
	DynamicData

	// Either "tcp" or "udp".
	Type string `xml:"type" json:"type"`
	// The user-defined name to identify the service being forwarded.
	//
	// No white spaces are allowed in the string.
	Name string `xml:"name" json:"name"`
	// The port number on the host.
	//
	// Network traffic sent to the host on this
	// TCP/UDP port is forwarded to the guest at the specified IP address
	// and port.
	HostPort int32 `xml:"hostPort" json:"hostPort"`
	// The port number for the guest.
	//
	// Network traffic from the host is
	// forwarded to this port.
	GuestPort int32 `xml:"guestPort" json:"guestPort"`
	// The IP address for the guest.
	//
	// Network traffic from the host is
	// forwarded to this IP address.
	GuestIpAddress string `xml:"guestIpAddress" json:"guestIpAddress"`
}

func init() {
	t["HostNatServicePortForwardSpec"] = reflect.TypeOf((*HostNatServicePortForwardSpec)(nil)).Elem()
}

// This data object type provides the details about the
// Network Address Translation (NAT) service.
type HostNatServiceSpec struct {
	DynamicData

	// The name of the virtual switch to which nat service is connected.
	VirtualSwitch string `xml:"virtualSwitch" json:"virtualSwitch"`
	// The flag to indicate whether or not non-passive mode FTP
	// connections should be allowed.
	ActiveFtp bool `xml:"activeFtp" json:"activeFtp"`
	// The flag to indicate whether or not the NAT
	// Service allows media access control traffic from any
	// Organizational Unique Identifier (OUI)?
	// By default, it does not allow traffic that originated
	// from the host to avoid packet loops.
	AllowAnyOui bool `xml:"allowAnyOui" json:"allowAnyOui"`
	// The flag to indicate whether or not the NAT Service
	// should open a configuration port.
	ConfigPort bool `xml:"configPort" json:"configPort"`
	// The IP address that the NAT Service should use on
	// the virtual network.
	IpGatewayAddress string `xml:"ipGatewayAddress" json:"ipGatewayAddress"`
	// The time allotted for UDP packets.
	UdpTimeout int32 `xml:"udpTimeout" json:"udpTimeout"`
	// The port forwarding specifications to allow network
	// connections to be initiated from outside the firewall.
	PortForward []HostNatServicePortForwardSpec `xml:"portForward,omitempty" json:"portForward,omitempty"`
	// The configuration of naming services.
	//
	// These parameters are
	// specific to Windows.
	NameService *HostNatServiceNameServiceSpec `xml:"nameService,omitempty" json:"nameService,omitempty"`
}

func init() {
	t["HostNatServiceSpec"] = reflect.TypeOf((*HostNatServiceSpec)(nil)).Elem()
}

// Capability vector indicating the available product features.
type HostNetCapabilities struct {
	DynamicData

	// The flag to indicate whether or not a physical network
	// adapter's link speed and duplex settings can be changed through
	// this API.
	//
	// For a hosted product, the host uses its physical network
	// adapters for network connectivity. Configuration of link speed is
	// done through regular host operations. In ESX Server, the configuration
	// can be changed through this API.
	CanSetPhysicalNicLinkSpeed bool `xml:"canSetPhysicalNicLinkSpeed" json:"canSetPhysicalNicLinkSpeed"`
	// The flag to indicate whether or not network adapter teaming is
	// available.
	//
	// Multiple network adapters can be bridged to a
	// virtual switch through a BondBridge. Also, network adapter teaming
	// policies such as failover order and detection are enabled.
	SupportsNicTeaming bool `xml:"supportsNicTeaming" json:"supportsNicTeaming"`
	// The available teaming policies if the platform supports network
	// adapter teaming.
	NicTeamingPolicy []string `xml:"nicTeamingPolicy,omitempty" json:"nicTeamingPolicy,omitempty"`
	// The flag to indicate whether or not VLANs can be configured on
	// PortGroups attached to VirtualSwitch objects.
	//
	// This allows VLANs for virtual machines without requiring special VLAN
	// capable hardware switches.
	SupportsVlan bool `xml:"supportsVlan" json:"supportsVlan"`
	// The flag to indicate whether or not a service
	// console network adapter
	// is used or required.
	//
	// This means that the system
	// software has two TCP/IP stacks. As a result, at least two types of
	// VirtualNics may be created -- the normal VirtualNic and the service
	// console VirtualNic. If this is not set, then only the VirtualNic type is
	// supported.
	UsesServiceConsoleNic bool `xml:"usesServiceConsoleNic" json:"usesServiceConsoleNic"`
	// The flag to indicate whether or not the host is able
	// to support
	// the querying of network hints.
	SupportsNetworkHints bool `xml:"supportsNetworkHints" json:"supportsNetworkHints"`
	// The maximum number of port groups supported per virtual switch.
	//
	// This property will not be set if this value is unlimited.
	MaxPortGroupsPerVswitch int32 `xml:"maxPortGroupsPerVswitch,omitempty" json:"maxPortGroupsPerVswitch,omitempty"`
	// The flag to indicate whether virtual switch configuration is
	// supported.
	//
	// This means that operations to add, remove, update virtual
	// switches are supported.
	VswitchConfigSupported bool `xml:"vswitchConfigSupported" json:"vswitchConfigSupported"`
	// The flag to indicate whether Virtual NIC configuration is supported.
	//
	// This means that operations to add, remove, update virtualNic are
	// supported.
	VnicConfigSupported bool `xml:"vnicConfigSupported" json:"vnicConfigSupported"`
	// The flag to indicate whether ip route configuration for the host
	// is supported.
	IpRouteConfigSupported bool `xml:"ipRouteConfigSupported" json:"ipRouteConfigSupported"`
	// The flag to indicate whether DNS configuration for the host is
	// supported.
	DnsConfigSupported bool `xml:"dnsConfigSupported" json:"dnsConfigSupported"`
	// This flag indicates whether or not the host is able to support
	// dhcp configuration for vnics.
	DhcpOnVnicSupported bool `xml:"dhcpOnVnicSupported" json:"dhcpOnVnicSupported"`
	// The flag to indicate whether the host is capable of communicating
	// using ipv6 protocol
	IpV6Supported *bool `xml:"ipV6Supported" json:"ipV6Supported,omitempty"`
	// The flag to indicate whether the host supports Backup NFC NIOC system
	// traffic, Unset means Backup NFC NIOC system traffic is not supported.
	BackupNfcNiocSupported *bool `xml:"backupNfcNiocSupported" json:"backupNfcNiocSupported,omitempty" vim:"7.0.1.0"`
}

func init() {
	t["HostNetCapabilities"] = reflect.TypeOf((*HostNetCapabilities)(nil)).Elem()
}

// Deprecated as of VI API 4.0, the system defaults will be used.
//
// Offload capabilities are used to optimize virtual machine network
// performance.
//
// When a virtual machine is transmitting on a network,
// some operations can be offloaded either to the host or to physical
// hardware. This data object type defines the set of offload capabilities
// that may be available on a host.
//
// This data object type is used both to publish the list of offload capabilities
// and to contain offload capability policy settings. The network
// policy logic is built on a two-level inheritance scheme which
// requires that all settings be optional. As a result, all properties
// on the NetOffloadCapabilities object must be optional.
//
// See also `HostNetworkPolicy`.
type HostNetOffloadCapabilities struct {
	DynamicData

	// (Optional) The flag to indicate whether or not checksum
	// offloading is supported.
	CsumOffload *bool `xml:"csumOffload" json:"csumOffload,omitempty"`
	// (Optional) The flag to indicate whether or not TCP segmentation
	// offloading (TSO) is supported.
	TcpSegmentation *bool `xml:"tcpSegmentation" json:"tcpSegmentation,omitempty"`
	// (Optional) The flag to indicate whether or not zero copy
	// transmits are supported.
	ZeroCopyXmit *bool `xml:"zeroCopyXmit" json:"zeroCopyXmit,omitempty"`
}

func init() {
	t["HostNetOffloadCapabilities"] = reflect.TypeOf((*HostNetOffloadCapabilities)(nil)).Elem()
}

// This class describes Network Stack Instance configuration
type HostNetStackInstance struct {
	DynamicData

	// Key of instance
	// For instance which created by host, its value should be `HostNetStackInstanceSystemStackKey_enum`.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// The display name
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// DNS configuration
	DnsConfig BaseHostDnsConfig `xml:"dnsConfig,omitempty,typeattr" json:"dnsConfig,omitempty"`
	// IP Route configuration
	IpRouteConfig BaseHostIpRouteConfig `xml:"ipRouteConfig,omitempty,typeattr" json:"ipRouteConfig,omitempty"`
	// The maximum number of socket connection that are requested on this instance
	RequestedMaxNumberOfConnections int32 `xml:"requestedMaxNumberOfConnections,omitempty" json:"requestedMaxNumberOfConnections,omitempty"`
	// The TCP congest control algorithm used by this instance,
	// See `HostNetStackInstanceCongestionControlAlgorithmType_enum` for valid values.
	CongestionControlAlgorithm string `xml:"congestionControlAlgorithm,omitempty" json:"congestionControlAlgorithm,omitempty"`
	// Enable or disable IPv6 protocol on this stack instance.
	//
	// This property is not supported currently.
	IpV6Enabled      *bool                   `xml:"ipV6Enabled" json:"ipV6Enabled,omitempty"`
	RouteTableConfig *HostIpRouteTableConfig `xml:"routeTableConfig,omitempty" json:"routeTableConfig,omitempty"`
}

func init() {
	t["HostNetStackInstance"] = reflect.TypeOf((*HostNetStackInstance)(nil)).Elem()
}

// This data object type describes networking host configuration data objects.
//
// These objects contain only the configuration information for networking.
// The runtime information is available from the
// `NetworkInfo` data object type.
//
// See also `HostNetworkInfo`.
type HostNetworkConfig struct {
	DynamicData

	// Virtual switches configured on the host.
	Vswitch []HostVirtualSwitchConfig `xml:"vswitch,omitempty" json:"vswitch,omitempty"`
	// Host proxy switches configured on the host.
	ProxySwitch []HostProxySwitchConfig `xml:"proxySwitch,omitempty" json:"proxySwitch,omitempty"`
	// Port groups configured on the host.
	Portgroup []HostPortGroupConfig `xml:"portgroup,omitempty" json:"portgroup,omitempty"`
	// Physical network adapters as seen by the primary operating system.
	Pnic []PhysicalNicConfig `xml:"pnic,omitempty" json:"pnic,omitempty"`
	// Virtual network adapters configured for use by the host
	// operating system network adapter.
	Vnic []HostVirtualNicConfig `xml:"vnic,omitempty" json:"vnic,omitempty"`
	// Virtual network adapters configured for use by the Service
	// Console.
	ConsoleVnic []HostVirtualNicConfig `xml:"consoleVnic,omitempty" json:"consoleVnic,omitempty"`
	// Deprecated as of vSphere API 5.5, which is moved to
	// the default NetStackInstance.
	//
	// Client-side DNS configuration for the host.
	//
	// The DNS configuration is
	// global to the entire host.
	DnsConfig BaseHostDnsConfig `xml:"dnsConfig,omitempty,typeattr" json:"dnsConfig,omitempty"`
	// Deprecated as of vSphere API 5.5, which is moved to
	// the default NetStackInstance.
	//
	// IP route configuration of the host.
	IpRouteConfig BaseHostIpRouteConfig `xml:"ipRouteConfig,omitempty,typeattr" json:"ipRouteConfig,omitempty"`
	// IP route configuration of the service console.
	ConsoleIpRouteConfig BaseHostIpRouteConfig `xml:"consoleIpRouteConfig,omitempty,typeattr" json:"consoleIpRouteConfig,omitempty"`
	// Deprecated as of vSphere API 5.5, which is moved to
	// the default NetStackInstance.
	//
	// IP routing table configuration of the host.
	RouteTableConfig *HostIpRouteTableConfig `xml:"routeTableConfig,omitempty" json:"routeTableConfig,omitempty"`
	// Dynamic Host Control Protocol (DHCP) Service instances configured
	// on the host.
	Dhcp []HostDhcpServiceConfig `xml:"dhcp,omitempty" json:"dhcp,omitempty"`
	// Network address translation (NAT) Service instances configured
	// on the host.
	Nat []HostNatServiceConfig `xml:"nat,omitempty" json:"nat,omitempty"`
	// Enable or disable IPv6 protocol on this system.
	//
	// This property must be set by itself, no other property can accompany
	// this change. Following the successful change, the system should be rebooted to
	// have the change take effect.
	IpV6Enabled *bool `xml:"ipV6Enabled" json:"ipV6Enabled,omitempty"`
	// The list of network stack instance spec
	NetStackSpec []HostNetworkConfigNetStackSpec `xml:"netStackSpec,omitempty" json:"netStackSpec,omitempty"`
	// Current status of NVDS to VDS migration.
	//
	// See `HostNetworkConfig*.*HostNetworkConfigMigrationStatus_enum`
	// for supported values.
	MigrationStatus string `xml:"migrationStatus,omitempty" json:"migrationStatus,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["HostNetworkConfig"] = reflect.TypeOf((*HostNetworkConfig)(nil)).Elem()
}

// This data type describes Network Stack Spec
type HostNetworkConfigNetStackSpec struct {
	DynamicData

	// Network stack instance
	NetStackInstance HostNetStackInstance `xml:"netStackInstance" json:"netStackInstance"`
	// Operation type, see
	// `ConfigSpecOperation_enum` for valid values.
	//
	// Only edit operation is supported currently.
	Operation string `xml:"operation,omitempty" json:"operation,omitempty"`
}

func init() {
	t["HostNetworkConfigNetStackSpec"] = reflect.TypeOf((*HostNetworkConfigNetStackSpec)(nil)).Elem()
}

// The result returned by updateNetworkConfig call.
//
// See also `HostNetworkSystem.UpdateNetworkConfig`.
type HostNetworkConfigResult struct {
	DynamicData

	// Virtual network adapter keys.
	VnicDevice []string `xml:"vnicDevice,omitempty" json:"vnicDevice,omitempty"`
	// Service console virtual network adapter keys.
	ConsoleVnicDevice []string `xml:"consoleVnicDevice,omitempty" json:"consoleVnicDevice,omitempty"`
}

func init() {
	t["HostNetworkConfigResult"] = reflect.TypeOf((*HostNetworkConfigResult)(nil)).Elem()
}

// This data object type describes networking host
// configuration data objects.
type HostNetworkInfo struct {
	DynamicData

	// Virtual switches configured on the host.
	Vswitch []HostVirtualSwitch `xml:"vswitch,omitempty" json:"vswitch,omitempty"`
	// Proxy switches configured on the host.
	ProxySwitch []HostProxySwitch `xml:"proxySwitch,omitempty" json:"proxySwitch,omitempty"`
	// Port groups configured on the host.
	Portgroup []HostPortGroup `xml:"portgroup,omitempty" json:"portgroup,omitempty"`
	// Physical network adapters as seen by the primary operating system.
	Pnic []PhysicalNic `xml:"pnic,omitempty" json:"pnic,omitempty"`
	// Remote direct memory access devices, if any are present on the host.
	RdmaDevice []HostRdmaDevice `xml:"rdmaDevice,omitempty" json:"rdmaDevice,omitempty"`
	// Virtual network adapters configured on the host (hosted products)
	// or the vmkernel.
	//
	// In the hosted architecture, these network adapters are used by the
	// host to
	// communicate with the virtual machines running on that host. In the
	// VMkernel architecture, these virtual network adapters provide the
	// ESX Server with
	// external network access through a virtual switch that is bridged to a
	// physical network adapter. The VMkernel uses these network adapters
	// for features such as VMotion, NAS, iSCSI, and remote MKS connections.
	Vnic []HostVirtualNic `xml:"vnic,omitempty" json:"vnic,omitempty"`
	// Virtual network adapters configured for use by the service console.
	//
	// The service
	// console uses this network access for system management and bootstrapping
	// services like network boot.
	// The two sets of virtual network adapters are mutually exclusive.
	// A virtual network adapter
	// in this list cannot be used for things like VMotion. Likewise, a
	// virtual network adapter in the other list cannot be used by the
	// service console.
	ConsoleVnic []HostVirtualNic `xml:"consoleVnic,omitempty" json:"consoleVnic,omitempty"`
	// Deprecated as of vSphere API 5.5, which is moved to
	// each NetStackInstance. For this property in NetworkInfo,
	// Get operation will only return its value of default NetStackInstance.
	//
	// Client-side DNS configuration.
	DnsConfig BaseHostDnsConfig `xml:"dnsConfig,omitempty,typeattr" json:"dnsConfig,omitempty"`
	// Deprecated as of vSphere API 5.5, which is moved to
	// each NetStackInstance. For this property in NetworkInfo,
	// Get operation will only return its value of default NetStackInstance.
	//
	// IP route configuration.
	IpRouteConfig BaseHostIpRouteConfig `xml:"ipRouteConfig,omitempty,typeattr" json:"ipRouteConfig,omitempty"`
	// IP route configuration of the service console.
	ConsoleIpRouteConfig BaseHostIpRouteConfig `xml:"consoleIpRouteConfig,omitempty,typeattr" json:"consoleIpRouteConfig,omitempty"`
	// Deprecated as of vSphere API 5.5, which is moved to
	// each NetStackInstance. For this property in NetworkInfo,
	// Get operation will only return its value of default NetStackInstance.
	//
	// IP routing table
	RouteTableInfo *HostIpRouteTableInfo `xml:"routeTableInfo,omitempty" json:"routeTableInfo,omitempty"`
	// DHCP Service instances configured on the host.
	Dhcp []HostDhcpService `xml:"dhcp,omitempty" json:"dhcp,omitempty"`
	// NAT service instances configured on the host.
	Nat []HostNatService `xml:"nat,omitempty" json:"nat,omitempty"`
	// Enable or disable IPv6 protocol on this system.
	IpV6Enabled *bool `xml:"ipV6Enabled" json:"ipV6Enabled,omitempty"`
	// If true then dual IPv4/IPv6 stack enabled else IPv4 only.
	AtBootIpV6Enabled *bool `xml:"atBootIpV6Enabled" json:"atBootIpV6Enabled,omitempty"`
	// List of NetStackInstances
	NetStackInstance []HostNetStackInstance `xml:"netStackInstance,omitempty" json:"netStackInstance,omitempty"`
	// List of opaque switches configured on the host.
	OpaqueSwitch []HostOpaqueSwitch `xml:"opaqueSwitch,omitempty" json:"opaqueSwitch,omitempty"`
	// List of opaque networks
	OpaqueNetwork []HostOpaqueNetworkInfo `xml:"opaqueNetwork,omitempty" json:"opaqueNetwork,omitempty"`
	// The nsx transport node Id
	NsxTransportNodeId string `xml:"nsxTransportNodeId,omitempty" json:"nsxTransportNodeId,omitempty"`
	// Whether NSX N-VDS to VDS migration is required
	NvdsToVdsMigrationRequired *bool `xml:"nvdsToVdsMigrationRequired" json:"nvdsToVdsMigrationRequired,omitempty" vim:"7.0.2.0"`
	// Current status of NVDS to VDS migration.
	//
	// See `HostNetworkConfig*.*HostNetworkConfigMigrationStatus_enum`
	// for supported values.
	MigrationStatus string `xml:"migrationStatus,omitempty" json:"migrationStatus,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["HostNetworkInfo"] = reflect.TypeOf((*HostNetworkInfo)(nil)).Elem()
}

// This data object type describes network policies that can be configured for
// both virtual switches and port groups.
//
// The policy settings on the
// port group can inherit policy settings from their containing virtual
// switch. These policy settings are inherited if
// the settings on the port group are not set. Since every policy
// setting on a port group is optional, every individual policy setting
// can be inherited.
//
// By contrast, if a host is capable of implementing a policy setting, every
// virtual switch has some value assigned to the policy setting. In this
// case, although all of the policy settings are optional,
// they always have some value either by inheritance or by direct
// setting.
//
// Policy settings are organized into policy groups such as SecurityPolicy.
// Policy groups are optional since it is possible that a host may not implement
// such policies. If a host does not support a policy group, the policy group
// is not set on both the virtual switches and the port groups.
//
// See also `HostNetCapabilities`.
type HostNetworkPolicy struct {
	DynamicData

	// The security policy governing ports on this virtual switch.
	Security *HostNetworkSecurityPolicy `xml:"security,omitempty" json:"security,omitempty"`
	// The network adapter teaming policy.
	//
	// The bridge must be BondBridge
	// for this property to be valid.
	NicTeaming *HostNicTeamingPolicy `xml:"nicTeaming,omitempty" json:"nicTeaming,omitempty"`
	// Deprecated as of VI API 4.0, the system defaults will be used.
	//
	// Offload capabilities are used to optimize virtual machine network
	// performance.
	//
	// When a virtual machine is transmitting on a network,
	// some operations can be offloaded to either the host or the physical
	// hardware. This policy indicates what networking related operations
	// should be offloaded.
	//
	// All virtual machines using this PortGroup are subject to this
	// policy. There is no setting for an individual virtual machine
	// to determine if an operation should be offloaded.
	OffloadPolicy *HostNetOffloadCapabilities `xml:"offloadPolicy,omitempty" json:"offloadPolicy,omitempty"`
	// The traffic shaping policy.
	ShapingPolicy *HostNetworkTrafficShapingPolicy `xml:"shapingPolicy,omitempty" json:"shapingPolicy,omitempty"`
}

func init() {
	t["HostNetworkPolicy"] = reflect.TypeOf((*HostNetworkPolicy)(nil)).Elem()
}

// This data type describes the network resource runtime information
type HostNetworkResourceRuntime struct {
	DynamicData

	// The network resource related information on each
	// physical NIC
	PnicResourceInfo []HostPnicNetworkResourceInfo `xml:"pnicResourceInfo" json:"pnicResourceInfo"`
}

func init() {
	t["HostNetworkResourceRuntime"] = reflect.TypeOf((*HostNetworkResourceRuntime)(nil)).Elem()
}

// This data object type describes security policy governing ports.
type HostNetworkSecurityPolicy struct {
	DynamicData

	// The flag to indicate whether or not all traffic is seen
	// on the port.
	AllowPromiscuous *bool `xml:"allowPromiscuous" json:"allowPromiscuous,omitempty"`
	// The flag to indicate whether or not the Media Access
	// Control (MAC) address can be changed.
	MacChanges *bool `xml:"macChanges" json:"macChanges,omitempty"`
	// The flag to indicate whether or not the virtual network adapter
	// should be allowed to send network traffic with a different MAC
	// address than that of the virtual network adapter.
	ForgedTransmits *bool `xml:"forgedTransmits" json:"forgedTransmits,omitempty"`
}

func init() {
	t["HostNetworkSecurityPolicy"] = reflect.TypeOf((*HostNetworkSecurityPolicy)(nil)).Elem()
}

// This data object type describes traffic shaping policy.
type HostNetworkTrafficShapingPolicy struct {
	DynamicData

	// The flag to indicate whether or not traffic shaper is enabled on
	// the port.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// The average bandwidth in bits per second if shaping is enabled on
	// the port.
	AverageBandwidth int64 `xml:"averageBandwidth,omitempty" json:"averageBandwidth,omitempty"`
	// The peak bandwidth during bursts in bits per second if traffic
	// shaping is enabled on the port.
	PeakBandwidth int64 `xml:"peakBandwidth,omitempty" json:"peakBandwidth,omitempty"`
	// The maximum burst size allowed in bytes if shaping is enabled on
	// the port.
	BurstSize int64 `xml:"burstSize,omitempty" json:"burstSize,omitempty"`
}

func init() {
	t["HostNetworkTrafficShapingPolicy"] = reflect.TypeOf((*HostNetworkTrafficShapingPolicy)(nil)).Elem()
}

// Network information for a network that will be added to VirtualCenter when the
// host is added.
type HostNewNetworkConnectInfo struct {
	HostConnectInfoNetworkInfo
}

func init() {
	t["HostNewNetworkConnectInfo"] = reflect.TypeOf((*HostNewNetworkConnectInfo)(nil)).Elem()
}

// NfcConnectionInfo contains information about an NFC connection on the host.
type HostNfcConnectionInfo struct {
	HostDataTransportConnectionInfo

	// NFC streaming memory used by the connection in bytes.
	StreamingMemoryConsumed int64 `xml:"streamingMemoryConsumed,omitempty" json:"streamingMemoryConsumed,omitempty"`
}

func init() {
	t["HostNfcConnectionInfo"] = reflect.TypeOf((*HostNfcConnectionInfo)(nil)).Elem()
	minAPIVersionForType["HostNfcConnectionInfo"] = "7.0.3.0"
}

// This data object type describes the network adapter failover
// detection algorithm for a network adapter team.
type HostNicFailureCriteria struct {
	DynamicData

	// Deprecated as of VI API 5.1, this property is not supported.
	//
	// To use link speed as the criteria, _checkSpeed_ must be one of
	// the following values:
	//   - `*exact*`: Use exact speed to detect link failure.
	//     `*speed*` is the configured exact speed in megabits per second.
	//   - `*minimum*`: Use minimum speed to detect failure.
	//     `*speed*` is the configured minimum speed in megabits per second.
	//   - **empty string**: Do not use link speed to detect failure.
	//     `*speed*` is unused in this case.
	CheckSpeed string `xml:"checkSpeed,omitempty" json:"checkSpeed,omitempty"`
	// Deprecated as of VI API 5.1, this property is not supported.
	//
	// Speed.
	//
	// See also `HostNicFailureCriteria.checkSpeed`.
	Speed int32 `xml:"speed,omitempty" json:"speed,omitempty"`
	// Deprecated as of VI API 5.1, this property is not supported.
	//
	// The flag to indicate whether or not to use the link duplex reported
	// by the driver as link selection criteria.
	//
	// If `*checkDuplex*` is true, then fullDuplex is the configured
	// duplex mode. The link is considered bad if the link duplex reported
	// by driver is not the same as fullDuplex.
	//
	// If `*checkDuplex*` is false, then fullDuplex is unused, and
	// link duplexity is not used as a detection method.
	CheckDuplex *bool `xml:"checkDuplex" json:"checkDuplex,omitempty"`
	// Deprecated as of VI API 5.1, this property is not supported.
	//
	// Full duplex.
	//
	// See also `HostNicFailureCriteria.checkDuplex`.
	FullDuplex *bool `xml:"fullDuplex" json:"fullDuplex,omitempty"`
	// Deprecated as of VI API 5.1, this property is not supported.
	//
	// The flag to indicate whether or not to use link error percentage
	// to detect failure.
	//
	// If `*checkErrorPercent*` is true, then percentage is the configured
	// error percentage that is tolerated. The link is considered bad
	// if error rate exceeds percentage.
	//
	// If `*checkErrorPercent*` is false, percentage is unused, and
	// error percentage is not used as a detection method.
	CheckErrorPercent *bool `xml:"checkErrorPercent" json:"checkErrorPercent,omitempty"`
	// Deprecated as of VI API 5.1, this property is not supported.
	//
	// Percentage.
	//
	// See also `HostNicFailureCriteria.checkErrorPercent`.
	Percentage int32 `xml:"percentage,omitempty" json:"percentage,omitempty"`
	// The flag to indicate whether or not to enable this property to
	// enable beacon probing as a method to validate
	// the link status of a physical network adapter.
	//
	// `*checkBeacon*` can be enabled only if the VirtualSwitch has been
	// configured to use the beacon. Attempting to set `*checkBeacon*`
	// on a PortGroup or VirtualSwitch that does not have beacon probing
	// configured for the applicable VirtualSwitch results in an error.
	//
	// See also `HostVirtualSwitchBondBridge.beacon`, `HostVirtualSwitchBeaconConfig`.
	CheckBeacon *bool `xml:"checkBeacon" json:"checkBeacon,omitempty"`
}

func init() {
	t["HostNicFailureCriteria"] = reflect.TypeOf((*HostNicFailureCriteria)(nil)).Elem()
}

// This data object type describes network adapter ordering policy for a
// network adapter team.
//
// A physical network adapter can be in the active
// list, the standby list, or neither. It cannot be in both lists.
// For a virtual switch, the NicOrderPolicy property is never null when
// retrieved from the server. When creating a new virtual switch or
// updating an existing virtual switch, the NicOrderPolicy can be null,
// in which case the default NicOrderPolicy from the server will be
// used.
// For a portgroup, a null NicOrderPolicy property means the portgroup
// inherits the policy from its parent. Otherwise, the NicOrderPolicy
// property defined in the portgroup takes precedence.
// In all cases where the NicOrderPolicy property is set, an empty
// activeNic array means there are no active Ethernet adapters in the team. An
// empty standbyNic array means there are no standby Ethernet adapters.
type HostNicOrderPolicy struct {
	DynamicData

	// List of active network adapters used for load balancing.
	ActiveNic []string `xml:"activeNic,omitempty" json:"activeNic,omitempty"`
	// Standby network adapters used for failover.
	StandbyNic []string `xml:"standbyNic,omitempty" json:"standbyNic,omitempty"`
}

func init() {
	t["HostNicOrderPolicy"] = reflect.TypeOf((*HostNicOrderPolicy)(nil)).Elem()
}

// Policy for a network adapter team.
type HostNicTeamingPolicy struct {
	DynamicData

	// Network adapter teaming policy includes failover and load balancing,
	// It can be one of the following:
	//   - `*loadbalance\_ip*`: route based on ip hash.
	//   - `*loadbalance\_srcmac*`: route based on source MAC hash.
	//   - `*loadbalance\_srcid*`: route based on the source of the port ID.
	//   - `*failover\_explicit*`: use explicit failover order.
	//
	// See also `HostNetCapabilities.nicTeamingPolicy`.
	Policy string `xml:"policy,omitempty" json:"policy,omitempty"`
	// Deprecated as of VI API 5.1, the system default (true) will be used.
	//
	// The flag to indicate whether or not the teaming policy is applied
	// to inbound frames as well.
	//
	// For example, if the policy is explicit failover, a broadcast request goes
	// through uplink1 and comes back through uplink2. Then if the
	// reverse policy is set, the frame is dropped when it is
	// received from
	// uplink2. This reverse policy is useful to prevent the virtual machine
	// from getting reflections.
	ReversePolicy *bool `xml:"reversePolicy" json:"reversePolicy,omitempty"`
	// Flag to specify whether or not to notify the physical switch
	// if a link fails.
	//
	// If this property is true, ESX Server will
	// respond to the failure by sending a RARP packet from a different
	// physical adapter, causing the switch to update its cache.
	NotifySwitches *bool `xml:"notifySwitches" json:"notifySwitches,omitempty"`
	// The flag to indicate whether or not to use a rolling policy when
	// restoring links.
	//
	// For example, assume the explicit link order is
	// (vmnic9, vmnic0), therefore vmnic9 goes down, vmnic0 comes
	// up. However, when vmnic9 comes backup, if rollingOrder is set
	// to be true, vmnic0 continues to be used, otherwise, vmnic9
	// is restored as specified in the explicitly order.
	RollingOrder *bool `xml:"rollingOrder" json:"rollingOrder,omitempty"`
	// Failover detection policy for this network adapter team.
	//
	// The bridge must be BondBridge for this property to be valid.
	FailureCriteria *HostNicFailureCriteria `xml:"failureCriteria,omitempty" json:"failureCriteria,omitempty"`
	// Failover order policy for network adapters on this switch.
	//
	// The bridge must be BondBridge for this property to be valid.
	NicOrder *HostNicOrderPolicy `xml:"nicOrder,omitempty" json:"nicOrder,omitempty"`
}

func init() {
	t["HostNicTeamingPolicy"] = reflect.TypeOf((*HostNicTeamingPolicy)(nil)).Elem()
}

// This event records the fact that a host does not have any available networks
// for HA communication
type HostNoAvailableNetworksEvent struct {
	HostDasEvent

	// The comma-separated list of used networks
	Ips string `xml:"ips,omitempty" json:"ips,omitempty"`
}

func init() {
	t["HostNoAvailableNetworksEvent"] = reflect.TypeOf((*HostNoAvailableNetworksEvent)(nil)).Elem()
}

// This event records the fact that a host does not have any HA-enabled port
// groups
type HostNoHAEnabledPortGroupsEvent struct {
	HostDasEvent
}

func init() {
	t["HostNoHAEnabledPortGroupsEvent"] = reflect.TypeOf((*HostNoHAEnabledPortGroupsEvent)(nil)).Elem()
}

// This event records the fact that a host does not have a redundant
// management network.
//
// It is recommended that host management networks
// be configured with redundancy.
type HostNoRedundantManagementNetworkEvent struct {
	HostDasEvent
}

func init() {
	t["HostNoRedundantManagementNetworkEvent"] = reflect.TypeOf((*HostNoRedundantManagementNetworkEvent)(nil)).Elem()
}

// This event records that host went out of compliance.
type HostNonCompliantEvent struct {
	HostEvent
}

func init() {
	t["HostNonCompliantEvent"] = reflect.TypeOf((*HostNonCompliantEvent)(nil)).Elem()
}

// A HostNotConnected fault is thrown if a method needs
// to communicate with a host that has been disconnected in
// VirtualCenter.
type HostNotConnected struct {
	HostCommunication
}

func init() {
	t["HostNotConnected"] = reflect.TypeOf((*HostNotConnected)(nil)).Elem()
}

type HostNotConnectedFault HostNotConnected

func init() {
	t["HostNotConnectedFault"] = reflect.TypeOf((*HostNotConnectedFault)(nil)).Elem()
}

// This event records that the host is not a cluster member.
type HostNotInClusterEvent struct {
	HostDasEvent
}

func init() {
	t["HostNotInClusterEvent"] = reflect.TypeOf((*HostNotInClusterEvent)(nil)).Elem()
}

// A HostNotReachable fault is thrown if the server was unable
// to communicate with the host
type HostNotReachable struct {
	HostCommunication
}

func init() {
	t["HostNotReachable"] = reflect.TypeOf((*HostNotReachable)(nil)).Elem()
}

type HostNotReachableFault HostNotReachable

func init() {
	t["HostNotReachableFault"] = reflect.TypeOf((*HostNotReachableFault)(nil)).Elem()
}

// Configuration information for the NTP (Network Time Protocol) service.
type HostNtpConfig struct {
	DynamicData

	// List of time servers, specified as either IP addresses or
	// fully qualified domain names (FQDNs).
	//
	// Each entry may optionally
	// specify one or more space separated 'server' ntp.conf command options.
	// Any comments appended to an entry after a '#' will not be retained.
	// To reset any previously configured servers, submit an NtpConfig
	// without the server or configFile property set to method
	// `HostDateTimeSystem.UpdateDateTimeConfig`
	Server []string `xml:"server,omitempty" json:"server,omitempty"`
	// Content of ntp.conf host configuration file, split by lines for ntpd version 4.2.8.
	//
	// Comment lines start with comment marker '#' as per ntp.conf are kept.
	// When submitting a new ntp commands to this property via
	// `HostDateTimeSystem.UpdateDateTimeConfig` method, any 'restrict'
	// or 'drift' commands will be ignored as the those are set to fixed defaults.
	ConfigFile []string `xml:"configFile,omitempty" json:"configFile,omitempty"`
}

func init() {
	t["HostNtpConfig"] = reflect.TypeOf((*HostNtpConfig)(nil)).Elem()
}

// Information about NUMA (non-uniform memory access).
type HostNumaInfo struct {
	DynamicData

	// Deprecated as of vSphere API 5.1, this property is always
	// set to "NUMA".
	//
	// The type of NUMA technology.
	Type string `xml:"type" json:"type"`
	// The number of NUMA nodes on the host.
	//
	// The value is 0 if the
	// host is not NUMA-capable.
	NumNodes int32 `xml:"numNodes" json:"numNodes"`
	// Information about each of the NUMA nodes on the host.
	//
	// The array is empty if the host is not NUMA-capable.
	NumaNode []HostNumaNode `xml:"numaNode,omitempty" json:"numaNode,omitempty"`
}

func init() {
	t["HostNumaInfo"] = reflect.TypeOf((*HostNumaInfo)(nil)).Elem()
}

// Information about a single NUMA node.
type HostNumaNode struct {
	DynamicData

	// Zero-based NUMA ID for the node.
	TypeId byte `xml:"typeId" json:"typeId"`
	// Information about each of the CPUs associated with the node.
	CpuID []int16 `xml:"cpuID" json:"cpuID"`
	// The total amount of memory in this NUMA node, in bytes.
	MemorySize int64 `xml:"memorySize,omitempty" json:"memorySize,omitempty" vim:"8.0.0.0"`
	// Deprecated as of vSphere 8.0, this property is always set to
	// zero. The memory of a NUMA node is not necessarily a single
	// physically contiguous range.
	//
	// Beginning memory range for this NUMA node.
	MemoryRangeBegin int64 `xml:"memoryRangeBegin" json:"memoryRangeBegin"`
	// Deprecated as of vSphere 8.0, this property is replaced by
	// `HostNumaNode.memorySize` and is set to the same value. The memory of
	// a NUMA node is not necessarily a single physically contiguous
	// range.
	//
	// Length of the memory range for this node in bytes, that is, the amount
	// of memory on the node.
	MemoryRangeLength int64 `xml:"memoryRangeLength" json:"memoryRangeLength"`
	// Information about each of the pci devices associated with the node.
	//
	// The string is of SBDF format, "Segment:Bus:Device.Function".
	PciId []string `xml:"pciId,omitempty" json:"pciId,omitempty"`
}

func init() {
	t["HostNumaNode"] = reflect.TypeOf((*HostNumaNode)(nil)).Elem()
}

// Base class for numeric sensor information.
type HostNumericSensorInfo struct {
	DynamicData

	// The name of the physical element associated with the sensor
	// It consists of a string of the form:
	// "description --- state/identifer".
	Name string `xml:"name" json:"name"`
	// The health state of the of the element indicated by the sensor.
	//
	// This property is populated only for sensors that support threshold
	// settings and for discrete sensors using control file.
	//
	// See also `HostNumericSensorHealthState_enum`.
	HealthState BaseElementDescription `xml:"healthState,omitempty,typeattr" json:"healthState,omitempty"`
	// The current reading of the element indicated by the sensor.
	//
	// The actual
	// sensor reading is obtained by multiplying the current reading by the
	// scale factor.
	CurrentReading int64 `xml:"currentReading" json:"currentReading"`
	// The unit multiplier for the values returned by the sensor.
	//
	// All values
	// returned by the sensor are current reading \* 10 raised to the power of
	// the UnitModifier. If no unitModifier applies the value returned is 0.
	UnitModifier int32 `xml:"unitModifier" json:"unitModifier"`
	// The base units in which the sensor reading is specified.
	//
	// If rateUnits
	// is set the units of the current reading is further qualified by the
	// rateUnits. Otherwise the value returned is 'unspecified'.
	//
	// See also `HostNumericSensorInfo.rateUnits`.
	BaseUnits string `xml:"baseUnits" json:"baseUnits"`
	// The rate units in which the sensor reading is specified.
	//
	// For example if
	// the baseUnits is Volts and the rateUnits is per second the value
	// returned by the sensor are in Volts/second. If no rate applies
	// the value returned is 'none'.
	RateUnits string `xml:"rateUnits,omitempty" json:"rateUnits,omitempty"`
	// The type of the sensor.
	//
	// If the sensor type is set to Other the sensor
	// name can be used to further identify the type of sensor. The sensor
	// units can also be used to further implicitly determine the type of the
	// sensor.
	//
	// See also `HostNumericSensorType_enum`.
	SensorType string `xml:"sensorType" json:"sensorType"`
	// A unique sensor identifier.
	//
	// A four part value consisting of:
	// BMC device.Entity ID.Instance.SensorNumber
	// Can be used to match a NumericSensorInfo object to
	// esxcli hardware ipmi sdr list
	Id string `xml:"id,omitempty" json:"id,omitempty"`
	// The IPMI Sensor/probe that is reporting this event.
	//
	// Use this value
	// to locate System Event Log (SEL) entries for this Sensor. It is also
	// reported in 'id' in string format. This property is intended to
	// be used with vim.host.SystemEventInfo.sensorNumber
	SensorNumber int64 `xml:"sensorNumber,omitempty" json:"sensorNumber,omitempty" vim:"8.0.0.1"`
	// Reports the ISO 8601 Timestamp when this sensor was last updated by
	// management controller if the this sensor is capable of tracking
	// when it was last updated.
	TimeStamp string `xml:"timeStamp,omitempty" json:"timeStamp,omitempty"`
	// The FRU this sensor monitors if any.
	Fru *HostFru `xml:"fru,omitempty" json:"fru,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["HostNumericSensorInfo"] = reflect.TypeOf((*HostNumericSensorInfo)(nil)).Elem()
}

// Specifies the parameters necessary to connect to a regular NVME over Fabrics
// controller.
//
// Here the transportParameters are used to establish a transport level
// connection to the specified controller. For reference, see:
//   - "NVM Express over Fabrics 1.0", Section 3.3,
//     "Connect command and response"
type HostNvmeConnectSpec struct {
	HostNvmeSpec

	// NVME Qualified Name of the NVM subsystem to connect to.
	//
	// Corresponds to the SUBNQN field in the Connect command as
	// referenced above.
	Subnqn string `xml:"subnqn" json:"subnqn"`
	// ID of the controller to connect to within the NVM subsystem.
	//
	// This field corresponds to CNTLID in the Connect command.
	// Its usage depends on whether the NVM Subsystem supports
	// a static or dynamic controller model.
	// In the static model, a number of controllers
	// may be exposed. A connection to a specific one may be requested
	// by specifying its controller ID (which is unique only within the
	// NVM subsystem). If a value of 0xFFFE (65534 in decimal) is provided,
	// any one of the controllers may be allocated for the connection. In
	// the static model a value of 0xFFFF (65535 in decimal) or above is
	// invalid.
	// In the dynamic model, the NVM Subsystem will dynamically allocate
	// a controller. Any value other than 0xFFFF (65535 in decimal) specified
	// will be consider invalid.
	// If the controllerId is unset, it defaults to 0xFFFF (the value used in
	// the dynamic model).
	// Whether the NVM subsystem supports the dynamic or static model can be
	// determined by examining the corresponding
	// `HostNvmeDiscoveryLogEntry` returned for it.
	ControllerId int32 `xml:"controllerId,omitempty" json:"controllerId,omitempty"`
	// Size of the admin queue which will be created once connection
	// is established.
	//
	// This field corresponds to SQSIZE in the Connect command (see above).
	// If unset, it defaults to a reasonable value which may vary between
	// releases (currently 16).
	AdminQueueSize int32 `xml:"adminQueueSize,omitempty" json:"adminQueueSize,omitempty"`
	// Timeout for the keep alive feature in seconds.
	//
	// This field corresponds to KATO in the Connect command (see above).
	// If unset, it defaults to a reasonable value which may vary between
	// releases (currently 30 seconds).
	// For further information, see:
	//   - "NVM Express 1.3", Section 5.21.1.15, "Keep Alive Timer"
	KeepAliveTimeout int32 `xml:"keepAliveTimeout,omitempty" json:"keepAliveTimeout,omitempty"`
}

func init() {
	t["HostNvmeConnectSpec"] = reflect.TypeOf((*HostNvmeConnectSpec)(nil)).Elem()
}

// This data object represents an NVME controller.
//
// Some terminology is borrowed from the NVM Express over Fabrics
// and the NVM Express 1.3 specifications, which are available
// at the following address:
// https://nvmexpress.org/resources/specifications/
type HostNvmeController struct {
	DynamicData

	// The linkable identifier.
	Key string `xml:"key" json:"key"`
	// The controller number uniquely identifies the NVME Controller
	// within its HostSystem.
	//
	// This should not be confused with Controller ID (see
	// "NVM Express over Fabrics 1.0", Section 4.2, "Controller model"
	// for details), which only serves as an identifier
	// within a particular NVME subsystem.
	ControllerNumber int32 `xml:"controllerNumber" json:"controllerNumber"`
	// The NVME subsystem qualified name.
	//
	// Each NVME controller is associated with an NVME subsystem
	// which can present a collection of controllers to the adapter.
	// For more details, refer to:
	//   - "NVM Express over Fabrics 1.0", Section 1.5.2,
	//     "NVM Subsystem".
	Subnqn string `xml:"subnqn" json:"subnqn"`
	// Name of the controller.
	//
	// Each controller has a name. For NVME over Fabrics controllers,
	// it is generated when the controller is connected to an NVME
	// over Fabrics adapter.
	Name string `xml:"name" json:"name"`
	// Associated NVME over Fabrics host bus adapter.
	//
	// A controller is associated with exactly one host at a time through
	// an NVME over Fabrics host bus adapter.
	AssociatedAdapter string `xml:"associatedAdapter" json:"associatedAdapter"`
	// The transport type supported by the controller.
	//
	// The set of possible values is described in `HostNvmeTransportType_enum`.
	// For details, see:
	//   - "NVM Express over Fabrics 1.0", Section 1.5.1,
	//     "Fabrics and Transports".
	TransportType string `xml:"transportType" json:"transportType"`
	// Indicates whether fused operations are supported by the controller.
	//
	// An NVME controller may support fused operations. This is required
	// to support shared storage, otherwise data corruption may occur.
	// For more details, see:
	//   - "NVM Express 1.3", Section 6.2, "Fused Operations".
	FusedOperationSupported bool `xml:"fusedOperationSupported" json:"fusedOperationSupported"`
	// The number of I/O queues allocated for the controller.
	NumberOfQueues int32 `xml:"numberOfQueues" json:"numberOfQueues"`
	// The size of each of the I/O queues.
	//
	// This will not be greater than the Maximum Queue Entries Supported
	// (mqes) value for the controller. For more information, see:
	//   - "NVM Express 1.3", section 3.1, "Register definition".
	QueueSize int32 `xml:"queueSize" json:"queueSize"`
	// List of NVME namespaces attached to the controller.
	//
	// Namespaces provide access to a non-volatile storage medium
	// which is part of the NVM subsystem. For an overview, see:
	//   - "NVM Express over Fabrics 1.0", Section 1.5.2,
	//     "NVM Subsystem".
	//   - "NVM Express 1.3", section 6.1, "Namespaces".
	AttachedNamespace []HostNvmeNamespace `xml:"attachedNamespace,omitempty" json:"attachedNamespace,omitempty"`
	// The vendor ID of the controller, if available.
	VendorId string `xml:"vendorId,omitempty" json:"vendorId,omitempty"`
	// The model name of the controller, if available.
	Model string `xml:"model,omitempty" json:"model,omitempty"`
	// The serial number of the controller, if available.
	SerialNumber string `xml:"serialNumber,omitempty" json:"serialNumber,omitempty"`
	// The firmware version of the controller, if available.
	FirmwareVersion string `xml:"firmwareVersion,omitempty" json:"firmwareVersion,omitempty"`
}

func init() {
	t["HostNvmeController"] = reflect.TypeOf((*HostNvmeController)(nil)).Elem()
}

// Specifies the parameters necessary to disconnect an NVME controller
// from a given NVME over Fabrics adapter.
type HostNvmeDisconnectSpec struct {
	DynamicData

	// The device name of the NVME over Fabrics host bus adapter.
	HbaName string `xml:"hbaName" json:"hbaName"`
	// NVME Qualified Name of the NVM subsystem to disconnect from.
	//
	// If controllerNumber is not specified, the subsystem qualified
	// name has to be specified and any controllers exposed by that
	// subsystem will be disconnected from the specified adapter. This
	// is particularly convenient for the dynamic controller model, where
	// the mapping subsystemNQN &lt;-&gt; ctrlNumber is expected to be 1:1.
	// If controllerNumber is also specified, this value is ignored.
	Subnqn string `xml:"subnqn,omitempty" json:"subnqn,omitempty"`
	// Controller number of the controller to be disconnected.
	//
	// If this value is set, the subsystemQualifiedName can be left unset
	// and the controller whose controllerNumber field matches this value
	// will be disconnected from the specified adapter.
	// If this value is not set, subsystemQualifiedName must be set.
	ControllerNumber int32 `xml:"controllerNumber,omitempty" json:"controllerNumber,omitempty"`
}

func init() {
	t["HostNvmeDisconnectSpec"] = reflect.TypeOf((*HostNvmeDisconnectSpec)(nil)).Elem()
}

// Specifies the parameters necessary to connect to a Discovery Service and
// retrieve a Discovery Log Page.
//
// Here the transportParameters are used to establish a transport level
// connection to a Discovery Controller. Further details can be found here:
//   - "NVM Express over Fabrics 1.0", Section 5, "Discovery service"
type HostNvmeDiscoverSpec struct {
	HostNvmeSpec

	// Indicates whether the specified adapter should automatically be
	// connected to all the discovered controllers.
	//
	// It is possible to automatically connect to all discovered controllers.
	// This will only be attempted if this flag is set to true. Whether the
	// connection attempt for an entry succeeded can then be determined
	// via the corresponding `HostNvmeDiscoveryLogEntry.connected` field.
	AutoConnect *bool `xml:"autoConnect" json:"autoConnect,omitempty"`
	// If set to true, this flag indicates we are connecting to a root/central
	// discovery controller (RDC/CDC).
	//
	// This will create a persistent connection between the host and the
	// root discovery controller, thus enabling some advanced features.
	RootDiscoveryController *bool `xml:"rootDiscoveryController" json:"rootDiscoveryController,omitempty" vim:"7.0.3.0"`
}

func init() {
	t["HostNvmeDiscoverSpec"] = reflect.TypeOf((*HostNvmeDiscoverSpec)(nil)).Elem()
}

// This data object represents the Discovery Log returned by
// an NVME over Fabrics Discovery controller.
//
// The Discovery Log consists of pages which contain a number
// of entries. It provides an inventory of NVM subsystems with
// which the host may attempt to form an association through
// an NVME over Fabrics adapter. For details, see:
//   - "NVM Express over Fabrics 1.0", Section 5.3,
//     Discovery Log Page
type HostNvmeDiscoveryLog struct {
	DynamicData

	// The list of entries that make up the Discovery Log.
	Entry []HostNvmeDiscoveryLogEntry `xml:"entry,omitempty" json:"entry,omitempty"`
	// Indicates whether the NvmeDiscoveryLog object completely
	// represents the underlying Discovery Log returned by the
	// controller.
	//
	// It is possible some of the entries returned by the Discovery
	// Controller contain unsupported transport types or data that
	// cannot be interpreted - in that case, those entries will be
	// skipped and the log will be marked as incomplete.
	Complete bool `xml:"complete" json:"complete"`
}

func init() {
	t["HostNvmeDiscoveryLog"] = reflect.TypeOf((*HostNvmeDiscoveryLog)(nil)).Elem()
}

// This data object represents a single entry in the Discovery
// Log returned by a Discovery controller.
type HostNvmeDiscoveryLogEntry struct {
	DynamicData

	// NVME Qualified name of the discovered subsystem.
	//
	// Corresponds to the SUBNQN field in the Discovery Log
	// Page Entry as specified by the NVME over Fabrics spec.
	Subnqn string `xml:"subnqn" json:"subnqn"`
	// NVM Subsystem type.
	//
	// Corresponds to the SUBTYPE field in the Discovery Log
	// Page Entry as specified by the NVME over Fabrics spec.
	// The set of supported values is described in
	// `HostNvmeDiscoveryLogSubsystemType_enum`.
	SubsystemType string `xml:"subsystemType" json:"subsystemType"`
	// NVM subsystem port ID.
	//
	// Corresponds to the PORTID field in the Discovery Log
	// Page Entry as specified by the NVME over Fabrics spec.
	// For an overview, see:
	//   - "NVM Express over Fabrics 1.0", Section 1.5.2,
	//     NVM Subsystem
	SubsystemPortId int32 `xml:"subsystemPortId" json:"subsystemPortId"`
	// NVME Controller ID within the NVM subsystem.
	//
	// Corresponds to the CNTLID field in the Discovery Log
	// Page Entry as specified by the NVME over Fabrics spec.
	// In the static controller model, this field may be set
	// to a specific controller ID which can be used to connect
	// to that particular controller. It could also be set
	// to 0xFFFE (65534 in decimal), in which case the controller
	// ID will be allocated when a connection is established.
	// In the dynamic controller model, this field shall be set
	// to 0xFFFF (65535 in decimal).
	// Note that this is different from the controllerNumber
	// `HostNvmeController.controllerNumber`,
	// which is the unique identifier of the NVMe controller
	// within the entire host and is allocated only after a
	// connection is established.
	ControllerId int32 `xml:"controllerId" json:"controllerId"`
	// The maximum size of the Admin Submission Queue.
	//
	// Corresponds to the ASQSZ field in the Discovery Log
	// Page Entry as specified by the NVME over Fabrics spec.
	// This applies to all controllers within the NVM Subsystem.
	// When establishing a connection, the value of
	// `HostNvmeConnectSpec.adminQueueSize` may not exceed
	// this value.
	AdminQueueMaxSize int32 `xml:"adminQueueMaxSize" json:"adminQueueMaxSize"`
	// Transport specific parameters necessary to establish
	// a connection.
	//
	// Different types of fabrics transports and different
	// means to specify a connection target may be supported.
	// The transport specific parameters object is constructed
	// based on the data in the Transport Type (TRTYPE),
	// Address Family (ADRFAM), Transport Service Identifier
	// (TRSVCID), Transport Address (TRADDR) and Transport
	// Specific Address Subtype (TSAS) fields in the Discovery
	// Log Page Entry as specified by the NVME over Fabrics spec.
	// When connecting to the controller represented by this
	// Discovery Log Page Entry, the transport specific
	// parameters can be passed directly as
	// `HostNvmeSpec.transportParameters`.
	TransportParameters BaseHostNvmeTransportParameters `xml:"transportParameters,typeattr" json:"transportParameters"`
	// The requirements for NVME Transport.
	//
	// Corresponds to the TREQ field in the Discovery Log
	// Page Entry as specified by the NVME over Fabrics spec
	// The set of possible values is described in
	// `HostNvmeDiscoveryLogTransportRequirements_enum`
	TransportRequirements string `xml:"transportRequirements" json:"transportRequirements"`
	// Indicates whether the controller represented
	// by this Discovery Log Page Entry is already connected
	// to the adapter through which the discovery is initiated.
	Connected bool `xml:"connected" json:"connected"`
}

func init() {
	t["HostNvmeDiscoveryLogEntry"] = reflect.TypeOf((*HostNvmeDiscoveryLogEntry)(nil)).Elem()
}

// This data object represents an NVM Express Namespace.
//
// In the NVME model, the underlying non-volatile storage medium
// is exposed via namespaces. For further information, see:
//   - "NVM Express over Fabrics 1.0", Section 1.5.2,
//     "NVM Subsystem".
//   - "NVM Express 1.3", section 6.1, "Namespaces".
type HostNvmeNamespace struct {
	DynamicData

	// The linkable identifier.
	//
	// This is a unique identifier of the NVME namespace within
	// the host system.
	Key string `xml:"key" json:"key"`
	// The name of the namespace.
	//
	// The name identifies the underlying storage exposed
	// by the NvmeNamespace. In multipath scenarios, two
	// namespaces can have the same name if they expose the
	// same underlying storage through different NVME controllers.
	Name string `xml:"name" json:"name"`
	// The namespace ID is an identifier used by an NVME controller
	// to provide access to a namespace.
	//
	// The namespace ID is only unique among the namespaces
	// attached to the same controller. For details, see:
	//   - "NVM Express 1.3", section 6.1, "Namespaces".
	Id int32 `xml:"id" json:"id"`
	// Block size of the namespace in bytes.
	//
	// Namespaces are comprised of a number of logical blocks with
	// a fixed size - the smallest units of data that may be
	// read or written by the NVME controller.
	BlockSize int32 `xml:"blockSize" json:"blockSize"`
	// The maximum number of logical blocks that may be allocated
	// in the namespace at any point in time.
	//
	// Corresponds to the NCAP field in the Identify Namespace data
	// structure:
	//   - "NVM Express 1.3", Section 5.15, Figure 114,
	//     "Identify Namespace Data Structure"
	CapacityInBlocks int64 `xml:"capacityInBlocks" json:"capacityInBlocks"`
}

func init() {
	t["HostNvmeNamespace"] = reflect.TypeOf((*HostNvmeNamespace)(nil)).Elem()
}

// This data object represents the raw transport specific parameters
// returned in a Discovery Log Page Entry, when they cannot be
// interpreted as one of the known common types of parameters.
//
// For details, see:
//   - "NVM Express over Fabrics 1.0", Section 5.3,
//     Discovery Log Page
type HostNvmeOpaqueTransportParameters struct {
	HostNvmeTransportParameters

	// The transport type.
	//
	// Corresponds to the TRTYPE field in the Discovery Log Page Entry
	// as specified by the NVME over Fabrics spec.
	// The set of possible values is desribed in `HostNvmeTransportType_enum`.
	Trtype string `xml:"trtype" json:"trtype"`
	// The transport address.
	//
	// Corresponds to the TRADDR field in the Discovery Log Page Entry
	// as specified by the NVME over Fabrics spec.
	Traddr string `xml:"traddr" json:"traddr"`
	// Indicates the address family of the address specified above.
	//
	// Corresponds to the ADRFAM field in the Discovery Log Page Entry
	// as specified by the NVME over Fabrics spec.
	// The set of supported values is described in
	// `HostNvmeTransportParametersNvmeAddressFamily_enum`.
	Adrfam string `xml:"adrfam" json:"adrfam"`
	// Transport service identifier.
	//
	// Corresponds to the TRSVCID field in the Discovery Log Page Entry
	// as specified by the NVME over Fabrics spec.
	// Its interpretation varies depending on the transport type.
	Trsvcid string `xml:"trsvcid" json:"trsvcid"`
	// Transport specific address subtype.
	//
	// Corresponds to the TSAS field in the Discovery Log Page Entry
	// as specified by the NVME over Fabrics spec.
	// Its interpretation varies depending on the transport type.
	Tsas []byte `xml:"tsas" json:"tsas"`
}

func init() {
	t["HostNvmeOpaqueTransportParameters"] = reflect.TypeOf((*HostNvmeOpaqueTransportParameters)(nil)).Elem()
}

// This data object represents the transport specific parameters
// necessary to establish an NVME over Fibre Channel connection.
type HostNvmeOverFibreChannelParameters struct {
	HostNvmeTransportParameters

	// The world wide node name for the connection target.
	NodeWorldWideName int64 `xml:"nodeWorldWideName" json:"nodeWorldWideName"`
	// The world wide port name for the connection target.
	PortWorldWideName int64 `xml:"portWorldWideName" json:"portWorldWideName"`
}

func init() {
	t["HostNvmeOverFibreChannelParameters"] = reflect.TypeOf((*HostNvmeOverFibreChannelParameters)(nil)).Elem()
}

// This data object represents the transport specific parameters
// necessary to establish an NVME over RDMA connection.
type HostNvmeOverRdmaParameters struct {
	HostNvmeTransportParameters

	// The address of the connection target.
	Address string `xml:"address" json:"address"`
	// Indicates the type of the address specified above.
	//
	// If unset, it is assumed to be an IPv4 address. The set of possible
	// values is described in
	// `HostNvmeTransportParametersNvmeAddressFamily_enum`.
	// Note that not all of the address families may be supported for
	// establishing a connection over RDMA.
	AddressFamily string `xml:"addressFamily,omitempty" json:"addressFamily,omitempty"`
	// The port number of the RDMA target port.
	//
	// When IPv4/IPv6 is used as address family above, the port number
	// needs to be specified. If this field is unset, a default
	// value of 4420 is assumed as per the IANA assignment:
	// https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml
	PortNumber int32 `xml:"portNumber,omitempty" json:"portNumber,omitempty"`
}

func init() {
	t["HostNvmeOverRdmaParameters"] = reflect.TypeOf((*HostNvmeOverRdmaParameters)(nil)).Elem()
}

// This data object represents the transport specific parameters
// necessary to establish an NVME over TCP connection.
type HostNvmeOverTcpParameters struct {
	HostNvmeTransportParameters

	// The address of the connection target.
	//
	// It is expected to be an IPv4 or IPv6 address.
	Address string `xml:"address" json:"address"`
	// The port number of the TCP target port.
	//
	// If this field is unset, the default value of 8009
	// is assumed as per the IANA assignment:
	// https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml
	PortNumber int32 `xml:"portNumber,omitempty" json:"portNumber,omitempty"`
	// Digest verification parameter.
	//
	// When used in a discovery or connect spec, this parameter specifies
	// the requested digest verification setting. The list of supported values is
	// described in `HostDigestVerificationSetting_enum`. If unset,
	// a default value of disabled is assumed.
	// For details, see:
	//   - NVM Express Technical Proposal 8000 - NVMe/TCP Transport,
	//     Section 7.4.10.2, "Initialize Connection Request PDU (ICReq)" - DGST field.
	//
	// When part of `HostNvmeDiscoveryLogEntry`, this value is unset.
	DigestVerification string `xml:"digestVerification,omitempty" json:"digestVerification,omitempty"`
}

func init() {
	t["HostNvmeOverTcpParameters"] = reflect.TypeOf((*HostNvmeOverTcpParameters)(nil)).Elem()
	minAPIVersionForType["HostNvmeOverTcpParameters"] = "7.0.3.0"
}

// Specifies the main parameters needed when connecting to
// an NVMe over Fabrics controller or Discovery Service.
type HostNvmeSpec struct {
	DynamicData

	// The device name of the NVME over Fabrics host bus adapter.
	HbaName string `xml:"hbaName" json:"hbaName"`
	// Transport specific information necessary to connect to the controller.
	TransportParameters BaseHostNvmeTransportParameters `xml:"transportParameters,typeattr" json:"transportParameters"`
}

func init() {
	t["HostNvmeSpec"] = reflect.TypeOf((*HostNvmeSpec)(nil)).Elem()
}

// This data object type describes the NVME topology information.
//
// The data objects in this data object type model the NVME storage objects
// from a topological point of view. The NVME topological view organizes
// objects by NVME interface, which contains connected controllers,
// which in turn contain attached namespaces.
//
// Only storage adapters which support the NVME protocol will be represented
// as NVME interfaces in this data object. In particular, an NVME interface
// will be created for each NVME over Fabrics adapter in the system.
//
// Note that it is possible for an adapter to be represented by both
// an NVME interface in the NVME topology and a SCSI interface in the SCSI
// topology. This can happen when an adapter supporting the NVME protocol is
// also presented as a SCSI adapter and SCSI to NVME translation is performed.
type HostNvmeTopology struct {
	DynamicData

	// The list of NVME interfaces (could be empty).
	Adapter []HostNvmeTopologyInterface `xml:"adapter,omitempty" json:"adapter,omitempty"`
}

func init() {
	t["HostNvmeTopology"] = reflect.TypeOf((*HostNvmeTopology)(nil)).Elem()
}

// This data object describes the NVME interface that is
// associated with a list of connected NVME controllers.
type HostNvmeTopologyInterface struct {
	DynamicData

	// The identifier for the NVME interface.
	Key string `xml:"key" json:"key"`
	// The link to data for the NVME interface.
	Adapter string `xml:"adapter" json:"adapter"`
	// The list of connected NVME controllers.
	//
	// This list can be empty if am NVME interface is not connected
	// to any controllers. Each NvmeController object contains
	// a list of its attached NVME namespaces in
	// `HostNvmeController.attachedNamespace`.
	ConnectedController []HostNvmeController `xml:"connectedController,omitempty" json:"connectedController,omitempty"`
}

func init() {
	t["HostNvmeTopologyInterface"] = reflect.TypeOf((*HostNvmeTopologyInterface)(nil)).Elem()
}

// This data object represents the transport specific parameters
// necessary to establish an NVM Express over Fabrics connection.
//
// For some further information, see:
//   - "NVM Express over Fabrics 1.0", Section 1.5.7, "Connection"
type HostNvmeTransportParameters struct {
	DynamicData
}

func init() {
	t["HostNvmeTransportParameters"] = reflect.TypeOf((*HostNvmeTransportParameters)(nil)).Elem()
}

// Information on opaque networks that are available on the host.
type HostOpaqueNetworkInfo struct {
	DynamicData

	// The ID of the opaque network.
	OpaqueNetworkId string `xml:"opaqueNetworkId" json:"opaqueNetworkId"`
	// The name of the opaque network.
	OpaqueNetworkName string `xml:"opaqueNetworkName" json:"opaqueNetworkName"`
	// The type of the opaque network.
	OpaqueNetworkType string `xml:"opaqueNetworkType" json:"opaqueNetworkType"`
	// IDs of networking zones that back the opaque network.
	PnicZone []string `xml:"pnicZone,omitempty" json:"pnicZone,omitempty"`
	// The capability of the opaque network.
	//
	// Refer `OpaqueNetworkCapability`
	Capability *OpaqueNetworkCapability `xml:"capability,omitempty" json:"capability,omitempty"`
	// Extra NSX specific properties for opaque networks.
	ExtraConfig []BaseOptionValue `xml:"extraConfig,omitempty,typeattr" json:"extraConfig,omitempty"`
}

func init() {
	t["HostOpaqueNetworkInfo"] = reflect.TypeOf((*HostOpaqueNetworkInfo)(nil)).Elem()
}

// The OpaqueSwitch contains basic information about virtual switches that are
// managed by a management plane outside of vSphere.
type HostOpaqueSwitch struct {
	DynamicData

	// The opaque switch ID.
	Key string `xml:"key" json:"key"`
	// The opaque switch name.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// The set of physical network adapters associated with this switch.
	Pnic []string `xml:"pnic,omitempty" json:"pnic,omitempty"`
	// The IDs of networking zones associated with this switch.
	PnicZone []HostOpaqueSwitchPhysicalNicZone `xml:"pnicZone,omitempty" json:"pnicZone,omitempty"`
	// Opaque switch status.
	//
	// See
	// `OpaqueSwitchState` for valid values.
	Status string `xml:"status,omitempty" json:"status,omitempty"`
	// List of VTEPs associated with this switch.
	Vtep []HostVirtualNic `xml:"vtep,omitempty" json:"vtep,omitempty"`
	// Extra NSX specific properties for opaque switch.
	ExtraConfig []BaseOptionValue `xml:"extraConfig,omitempty,typeattr" json:"extraConfig,omitempty"`
	// Array of host specific feature capabilities that the switch has.
	FeatureCapability []HostFeatureCapability `xml:"featureCapability,omitempty" json:"featureCapability,omitempty"`
}

func init() {
	t["HostOpaqueSwitch"] = reflect.TypeOf((*HostOpaqueSwitch)(nil)).Elem()
}

type HostOpaqueSwitchPhysicalNicZone struct {
	DynamicData

	// The zone ID
	Key string `xml:"key" json:"key"`
	// Whenever an OpaqueSwitch is associated with a PhysicalNicZone, then by default,
	// the zone will consist of all physical nics that are linked to the switch.
	//
	// However, if this property is set, then the zone will be considered to be
	// consisting of only those physical nics that are listed here.
	PnicDevice []string `xml:"pnicDevice,omitempty" json:"pnicDevice,omitempty"`
}

func init() {
	t["HostOpaqueSwitchPhysicalNicZone"] = reflect.TypeOf((*HostOpaqueSwitchPhysicalNicZone)(nil)).Elem()
}

// This event records when a host's capacity cannot satisfy resource
// configuration constraints.
type HostOvercommittedEvent struct {
	ClusterOvercommittedEvent
}

func init() {
	t["HostOvercommittedEvent"] = reflect.TypeOf((*HostOvercommittedEvent)(nil)).Elem()
}

// The VMFS file system.
type HostPMemVolume struct {
	HostFileSystemVolume

	// The universally unique identifier assigned to PMem volume.
	Uuid string `xml:"uuid" json:"uuid"`
	// Version of the PMem FS
	Version string `xml:"version" json:"version"`
}

func init() {
	t["HostPMemVolume"] = reflect.TypeOf((*HostPMemVolume)(nil)).Elem()
}

// The ParallelScsiHba data object type describes a
// parallel SCSI host bus adapter.
type HostParallelScsiHba struct {
	HostHostBusAdapter
}

func init() {
	t["HostParallelScsiHba"] = reflect.TypeOf((*HostParallelScsiHba)(nil)).Elem()
}

// Parallel SCSI transport information about a SCSI target.
type HostParallelScsiTargetTransport struct {
	HostTargetTransport
}

func init() {
	t["HostParallelScsiTargetTransport"] = reflect.TypeOf((*HostParallelScsiTargetTransport)(nil)).Elem()
}

// This data object contains information about the runtime status of
// a partial maintenance mode.
type HostPartialMaintenanceModeRuntimeInfo struct {
	DynamicData

	// The unique identifier of the partial maintenance mode.
	//
	// The values of the identifiers for the most common kinds of partial
	// maintenance modes are enumerated in `HostPartialMaintenanceModeId_enum`.
	Key string `xml:"key" json:"key"`
	// The current runtime status for the particular partial maintenance mode.
	//
	// The list of supported values is specified in
	// `HostPartialMaintenanceModeStatus_enum`.
	HostStatus string `xml:"hostStatus" json:"hostStatus"`
}

func init() {
	t["HostPartialMaintenanceModeRuntimeInfo"] = reflect.TypeOf((*HostPartialMaintenanceModeRuntimeInfo)(nil)).Elem()
	minAPIVersionForType["HostPartialMaintenanceModeRuntimeInfo"] = "8.0.3.0"
}

type HostPatchManagerLocator struct {
	DynamicData

	// The URL that will be used to access the patch repository.
	Url string `xml:"url" json:"url"`
	// The proxy setting required to access the URL from the host.
	//
	// If unset, a direct URL connection will be attempted.
	Proxy string `xml:"proxy,omitempty" json:"proxy,omitempty"`
}

func init() {
	t["HostPatchManagerLocator"] = reflect.TypeOf((*HostPatchManagerLocator)(nil)).Elem()
}

// Optional parameters for hostd to pass to exupdate.
type HostPatchManagerPatchManagerOperationSpec struct {
	DynamicData

	// The name of the possible proxy for esxupdate to use to connect to a server.
	//
	// The patch and metadata may be cached within the proxy server.
	Proxy string `xml:"proxy,omitempty" json:"proxy,omitempty"`
	// The port of the possible proxy for esxupdate to use to connect to a server.
	//
	// The patch and metadata may be cached within the proxy server.
	Port int32 `xml:"port,omitempty" json:"port,omitempty"`
	// The user name used for the proxy server.
	UserName string `xml:"userName,omitempty" json:"userName,omitempty"`
	// The password used for the proxy server.
	//
	// This is passed with ssl through a
	// trusted channel.
	Password string `xml:"password,omitempty" json:"password,omitempty"`
	// Possible command line options when calling esxupdate.
	CmdOption string `xml:"cmdOption,omitempty" json:"cmdOption,omitempty"`
}

func init() {
	t["HostPatchManagerPatchManagerOperationSpec"] = reflect.TypeOf((*HostPatchManagerPatchManagerOperationSpec)(nil)).Elem()
}

// The result of the operation.
//
// Some of the fields are only valid for
// specific operations.
type HostPatchManagerResult struct {
	DynamicData

	// The version of the scan result schema.
	Version string `xml:"version" json:"version"`
	// The scan results for each patch.
	Status []HostPatchManagerStatus `xml:"status,omitempty" json:"status,omitempty"`
	// The scan results in XML format.
	XmlResult string `xml:"xmlResult,omitempty" json:"xmlResult,omitempty"`
}

func init() {
	t["HostPatchManagerResult"] = reflect.TypeOf((*HostPatchManagerResult)(nil)).Elem()
}

type HostPatchManagerStatus struct {
	DynamicData

	// Unique identifier for this update.
	Id string `xml:"id" json:"id"`
	// Whether or not this update is applicable to this host.
	//
	// An update
	// may not be applicable to the ESX host for many reasons - for
	// example, it is obsolete, it conflicts with other installed
	// patches or libraries, and so on. The `HostPatchManagerStatus.reason` shows some of the reasons
	// why the update is not applicable.
	// An update could be inapplicable with no reason listed. This is
	// because the prerequisite install state is not correct. For example,
	// update A is one of the prerequisites of update B. B not only
	// requires A to be installed, but also requires the host is
	// rebooted after A is installed. When A is installed and the host
	// has not been restarted after the installation, B will not be
	// applicable. In such a case, the scan on both updates A and B
	// would yield a whole picture of the update applicable status.
	Applicable bool `xml:"applicable" json:"applicable"`
	// Possible reasons why an update is not applicable to the ESX host.
	//
	// See also `HostPatchManagerReason_enum`.
	Reason []string `xml:"reason,omitempty" json:"reason,omitempty"`
	// The integrity status of the update's metadata.
	//
	// The value would
	// be unset if the integrity status is unknown to the server.
	//
	// See also `HostPatchManagerIntegrityStatus_enum`.
	Integrity string `xml:"integrity,omitempty" json:"integrity,omitempty"`
	// Whether the update is installed on the server.
	Installed bool `xml:"installed" json:"installed"`
	// The installation state of the update.
	//
	// Unset if the update is not
	// installed on the server.
	//
	// See also `HostPatchManagerInstallState_enum`.
	InstallState []string `xml:"installState,omitempty" json:"installState,omitempty"`
	// Prerequisite update.
	PrerequisitePatch []HostPatchManagerStatusPrerequisitePatch `xml:"prerequisitePatch,omitempty" json:"prerequisitePatch,omitempty"`
	// Whether or not this update requires a host restart to take effect.
	RestartRequired bool `xml:"restartRequired" json:"restartRequired"`
	// Whether or not this update requires caller to reconnect to the
	// host.
	//
	// This is usually because the update is on the agent that
	// running on the host, the agent would thus be restarted when the
	// update is applied. Caller can reconnect (and possibly relogin) to
	// the host after the agent has been restarted.
	ReconnectRequired bool `xml:"reconnectRequired" json:"reconnectRequired"`
	// Whether or not this update requires the host in maintenance mode.
	VmOffRequired bool `xml:"vmOffRequired" json:"vmOffRequired"`
	// Patches that are superseded by this update.
	SupersededPatchIds []string `xml:"supersededPatchIds,omitempty" json:"supersededPatchIds,omitempty"`
}

func init() {
	t["HostPatchManagerStatus"] = reflect.TypeOf((*HostPatchManagerStatus)(nil)).Elem()
}

// Updates that are required to be installed before this update can
// be installed on the server.
//
// In addition to being installed on the server, an update can have
// additional requirement on the server or services running on the
// server pertaining to the prerequisite update.
type HostPatchManagerStatusPrerequisitePatch struct {
	DynamicData

	// Unique identifier of the prerequisite update.
	Id string `xml:"id" json:"id"`
	// The requirement on the server or services running on the
	// server pertaining to the prerequisite update.
	//
	// For example,
	// this update could require the server to be rebooted after the
	// prerequisite update is installed. Unset if there is no
	// additional requirement on the prerequisite update.
	//
	// See also `HostPatchManagerInstallState_enum`.
	InstallState []string `xml:"installState,omitempty" json:"installState,omitempty"`
}

func init() {
	t["HostPatchManagerStatusPrerequisitePatch"] = reflect.TypeOf((*HostPatchManagerStatusPrerequisitePatch)(nil)).Elem()
}

// Description of options associated with a native multipathing
// path selection policy plugin.
type HostPathSelectionPolicyOption struct {
	DynamicData

	// Description of the paths selection policy.
	//
	// Use the key as the
	// identifier.
	Policy BaseElementDescription `xml:"policy,typeattr" json:"policy"`
}

func init() {
	t["HostPathSelectionPolicyOption"] = reflect.TypeOf((*HostPathSelectionPolicyOption)(nil)).Elem()
}

// This data object type describes information about
// a single Peripheral Component Interconnect (PCI) device.
type HostPciDevice struct {
	DynamicData

	// The name ID of this PCI, composed of "bus:slot.function".
	Id string `xml:"id" json:"id"`
	// The class of this PCI.
	ClassId int16 `xml:"classId" json:"classId"`
	// The bus ID of this PCI.
	Bus byte `xml:"bus" json:"bus"`
	// The slot ID of this PCI.
	Slot byte `xml:"slot" json:"slot"`
	// The function ID of this PCI.
	Function byte `xml:"function" json:"function"`
	// The vendor ID of this PCI.
	//
	// The vendor ID might be a negative value. A vSphere Server uses an unsigned
	// short integer to represent a PCI vendor ID. The WSDL representation of the ID
	// is a signed short integer. If the vendor ID is greater than 32767, the Server
	// will convert the ID to its two's complement for the WSDL representation.
	// When you specify a PCI device vendor ID for a virtual machine
	// (`VirtualPCIPassthroughDeviceBackingInfo`.vendorId),
	// you must use the retrieved `HostPciDevice`.deviceId value.
	VendorId int16 `xml:"vendorId" json:"vendorId"`
	// The subvendor ID of this PCI.
	//
	// The subvendor ID might be a negative value. A vSphere Server uses an unsigned
	// short integer to represent a PCI subvendor ID. The WSDL representation of the ID
	// is a signed short integer. If the subvendor ID is greater than 32767, the Server
	// will convert the ID to its two's complement for the WSDL representation.
	SubVendorId int16 `xml:"subVendorId" json:"subVendorId"`
	// The vendor name of this PCI.
	VendorName string `xml:"vendorName" json:"vendorName"`
	// The device ID of this PCI.
	//
	// The device ID might be a negative value. A vSphere Server uses an unsigned
	// short integer to represent a PCI device ID. The WSDL representation of the ID
	// is a signed short integer. If the PCI ID is greater than 32767, the Server
	// will convert the ID to its two's complement for the WSDL representation.
	// When you specify a PCI device ID for a virtual machine
	// (`VirtualPCIPassthroughDeviceBackingInfo`.deviceId),
	// you must use the `HostPciDevice`.deviceId value as retrieved
	// and convert it to a string.
	DeviceId int16 `xml:"deviceId" json:"deviceId"`
	// The subdevice ID of this PCI.
	//
	// The subdevice ID might be a negative value. A vSphere Server uses an unsigned
	// short integer to represent a PCI subdevice ID. The WSDL representation of the ID
	// is a signed short integer. If the subdevice ID is greater than 32767, the Server
	// will convert the ID to its two's complement for the WSDL representation.
	SubDeviceId int16 `xml:"subDeviceId" json:"subDeviceId"`
	// The parent bridge of this PCI.
	ParentBridge string `xml:"parentBridge,omitempty" json:"parentBridge,omitempty"`
	// The device name of this PCI.
	DeviceName string `xml:"deviceName" json:"deviceName"`
	// The name for the PCI device class representing this PCI.
	//
	// For example: "Host bridge", "iSCSI device", "Fibre channel HBA".
	DeviceClassName string `xml:"deviceClassName,omitempty" json:"deviceClassName,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["HostPciDevice"] = reflect.TypeOf((*HostPciDevice)(nil)).Elem()
}

// This data object provides information about the state of PciPassthru
// for all pci devices.
type HostPciPassthruConfig struct {
	DynamicData

	// The name ID of this PCI, composed of "bus:slot.function".
	Id string `xml:"id" json:"id"`
	// Whether passThru has been configured for this device
	PassthruEnabled bool `xml:"passthruEnabled" json:"passthruEnabled"`
	// Whether the passThru config should take effect without rebooting ESX.
	//
	// When unset, the behavior will be determined automatically
	// based on `HostCapability.deviceRebindWithoutRebootSupported`.
	// If the configuration can be applied immediately, it
	// will be, otherwise the changes will take effect after reboot.
	ApplyNow *bool `xml:"applyNow" json:"applyNow,omitempty"`
	// The hardware label of the this PCI device.
	HardwareLabel string `xml:"hardwareLabel,omitempty" json:"hardwareLabel,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["HostPciPassthruConfig"] = reflect.TypeOf((*HostPciPassthruConfig)(nil)).Elem()
}

// This data object provides information about the state of PciPassthru
// for all pci devices.
type HostPciPassthruInfo struct {
	DynamicData

	// The name ID of this PCI, composed of "bus:slot.function".
	Id string `xml:"id" json:"id"`
	// Device which needs to be unclaimed by vmkernel (may be bridge)
	DependentDevice string `xml:"dependentDevice" json:"dependentDevice"`
	// Whether passThru has been configured by the user
	PassthruEnabled bool `xml:"passthruEnabled" json:"passthruEnabled"`
	// Whether passThru is even possible for this device (decided by vmkctl)
	PassthruCapable bool `xml:"passthruCapable" json:"passthruCapable"`
	// Whether passThru is active for this device (meaning enabled + rebooted)
	PassthruActive bool `xml:"passthruActive" json:"passthruActive"`
	// The hardware label of this PCI device.
	HardwareLabel string `xml:"hardwareLabel,omitempty" json:"hardwareLabel,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["HostPciPassthruInfo"] = reflect.TypeOf((*HostPciPassthruInfo)(nil)).Elem()
}

// This data object describes the Peripheral Component Interconnect Express
// (PCIe) host bus adapter interface.
type HostPcieHba struct {
	HostHostBusAdapter
}

func init() {
	t["HostPcieHba"] = reflect.TypeOf((*HostPcieHba)(nil)).Elem()
}

// Peripheral Component Interconnect Express (PCIe)
// transport information about a target.
type HostPcieTargetTransport struct {
	HostTargetTransport
}

func init() {
	t["HostPcieTargetTransport"] = reflect.TypeOf((*HostPcieTargetTransport)(nil)).Elem()
}

// Host Hardware information about configured and available
// persistent memory on a host.
type HostPersistentMemoryInfo struct {
	DynamicData

	// Amount of configured persistent memory available on a host in MB.
	CapacityInMB int64 `xml:"capacityInMB,omitempty" json:"capacityInMB,omitempty"`
	// Unique persistent memory host indentifier.
	VolumeUUID string `xml:"volumeUUID,omitempty" json:"volumeUUID,omitempty"`
}

func init() {
	t["HostPersistentMemoryInfo"] = reflect.TypeOf((*HostPersistentMemoryInfo)(nil)).Elem()
}

// This data type describes the Virtual Machine and
// Virtual NIC to identify virtual adapters placed
// on a physical NIC
type HostPlacedVirtualNicIdentifier struct {
	DynamicData

	// The Virtual Machine
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The virtual NIC key
	VnicKey string `xml:"vnicKey" json:"vnicKey"`
	// The virtual NIC reservation
	Reservation *int32 `xml:"reservation" json:"reservation,omitempty"`
}

func init() {
	t["HostPlacedVirtualNicIdentifier"] = reflect.TypeOf((*HostPlacedVirtualNicIdentifier)(nil)).Elem()
}

// This data object represents the plug-store topology on a host
// system.
//
// Through this data object, the storage structure of a system
// that utilizes the plug-store architecture can be presented.
//
// The object entity-relationship diagram is modeled below:
//
//	------------------------------------------------------------
//	|             0..N             0..N      0..N              |
//	|   Plugin ----->  Device  ------>  Path  <------  Adapter |
//	|                          <------   |    ------>          |
//	|                          0,1       |          1          |
//	|                                    |                     |
//	|                                    | 0,1                 |
//	|                                   \|/                    |
//	|                                  Target                  |
//	------------------------------------------------------------
//
// Description and reasoning behind the relationships:
//
// When a storage device driver is loaded, it claims a PCI device as a
// host bus adapter. This host bus adapter is represented as an Adapter.
// The PCI device identifier is a property on the HostBusAdapter in the
// Adapter.
//
// Once the host bus adapter is on the system, the hardware bus is scanned.
// If a storage Device is found on the bus, the communication path to the
// Device from the the host bus adapter is represented by a Path. A Device
// may have more than one Path. How those Paths are composed to create a
// Device is determined by a storage Plugin.
//
// When a storage Plugin is loaded, it claims a set of Paths. It groups these
// Paths into a set of Devices. Devices are hence associated with a set of
// Paths that might be used to provide a single logical device such as in the
// case of multipathing. Devices may be also composed of zero Paths meaning
// that they do not directly use a host bus adapter for communication with
// underlying storage.
//
// The purpose of this data object is to represent the topology of storage
// as seen by the base plug-store system. There is some overlap
// with information in other objects such as ScsiTopology which is only
// applicable when a particular "native multipathing" plugin is used. This
// data object provides the complete inventory of Devices and Paths. Hence
// it provides a superset of Device mappings over data object such as
// ScsiTopology and Multipa
//
// The use cases that this data object accommodates includes the following
// non-exhaustive list:
//   - Enumerate paths on a host bus adapter.
//   - Enumerate paths on a storage device.
//   - Conveniently access the devices a host bus adapter is
//     associated with by traversing the path.
//   - Determine which plugin a device belongs.
//   - Determine which paths are claimed by a plugin by
//     accumulating the paths of all device of the plugin.
//   - Determine which plugin a path belongs to by accessing its
//     device and finding that device in the Plugin list.
type HostPlugStoreTopology struct {
	DynamicData

	// List of host bus adapters in the plug store inventory.
	Adapter []HostPlugStoreTopologyAdapter `xml:"adapter,omitempty" json:"adapter,omitempty"`
	// List of paths in the plug store inventory.
	Path []HostPlugStoreTopologyPath `xml:"path,omitempty" json:"path,omitempty"`
	// Partial list of targets as seen by the host.
	//
	// The list of targets
	// may not be exhaustive on the host.
	Target []HostPlugStoreTopologyTarget `xml:"target,omitempty" json:"target,omitempty"`
	// List of devices in the plug store inventory.
	Device []HostPlugStoreTopologyDevice `xml:"device,omitempty" json:"device,omitempty"`
	// List of plugins in the plug store inventory.
	Plugin []HostPlugStoreTopologyPlugin `xml:"plugin,omitempty" json:"plugin,omitempty"`
}

func init() {
	t["HostPlugStoreTopology"] = reflect.TypeOf((*HostPlugStoreTopology)(nil)).Elem()
}

// This data object type is an association class that describes a host bus
// adapter and its associated storage Paths.
//
// The set of Paths on all the
// host bus adapters is the complete set of Paths in the system.
type HostPlugStoreTopologyAdapter struct {
	DynamicData

	// The identifier for the host bus adapter.
	Key string `xml:"key" json:"key"`
	// The link to the host bus adapter for this inebtrface.
	Adapter string `xml:"adapter" json:"adapter"`
	// The list of paths to which the host bus adapter is associated.
	Path []string `xml:"path,omitempty" json:"path,omitempty"`
}

func init() {
	t["HostPlugStoreTopologyAdapter"] = reflect.TypeOf((*HostPlugStoreTopologyAdapter)(nil)).Elem()
}

// This data object type is an association class that describes a ScsiLun
// and its associated Path objects.
//
// The ScsiLun is a Device that is formed
// from a set of Paths.
type HostPlugStoreTopologyDevice struct {
	DynamicData

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
	// The SCSI device corresponding to logical unit.
	Lun string `xml:"lun" json:"lun"`
	// The array of paths available to access this LogicalUnit.
	Path []string `xml:"path,omitempty" json:"path,omitempty"`
}

func init() {
	t["HostPlugStoreTopologyDevice"] = reflect.TypeOf((*HostPlugStoreTopologyDevice)(nil)).Elem()
}

// This data object type is an association class that describes a Path and
// its associated Device.
//
// A Path may be claimed by at most one Device.
type HostPlugStoreTopologyPath struct {
	DynamicData

	// The identifier for the Path.
	Key string `xml:"key" json:"key"`
	// Name of path.
	//
	// Use this property to correlate this path object to other
	// path objects.
	//
	// The state of the Path can be retrieved from the data object (@link
	// vim.host.MultipathStateInfo.Path} on the `HostMultipathStateInfo` data object.
	//
	// Use this name to configure LogicalUnit multipathing policy using `HostStorageSystem.EnableMultipathPath` and `HostStorageSystem.DisableMultipathPath`.
	Name string `xml:"name" json:"name"`
	// The channel number for a path if applicable.
	ChannelNumber int32 `xml:"channelNumber,omitempty" json:"channelNumber,omitempty"`
	// The target number for a path if applicable.
	//
	// The target number is not
	// guaranteed to be consistent across reboots or rescans of the adapter.
	TargetNumber int32 `xml:"targetNumber,omitempty" json:"targetNumber,omitempty"`
	// The LUN number for a path if applicable.
	LunNumber int32 `xml:"lunNumber,omitempty" json:"lunNumber,omitempty"`
	// The adapter that provided the Path.
	Adapter string `xml:"adapter,omitempty" json:"adapter,omitempty"`
	// The target of the Path if any.
	Target string `xml:"target,omitempty" json:"target,omitempty"`
	// The device that claimed the Path if any.
	Device string `xml:"device,omitempty" json:"device,omitempty"`
}

func init() {
	t["HostPlugStoreTopologyPath"] = reflect.TypeOf((*HostPlugStoreTopologyPath)(nil)).Elem()
}

// This data object type represents a Plugin in the plug store architecture.
//
// A Plugin claims a set of paths and groups them into Devices.
type HostPlugStoreTopologyPlugin struct {
	DynamicData

	// The identifier of the plugin.
	Key string `xml:"key" json:"key"`
	// The name of the plugin.
	Name string `xml:"name" json:"name"`
	// The set of devices formed by this plugin.
	Device []string `xml:"device,omitempty" json:"device,omitempty"`
	// The set of paths claimed by this plugin.
	//
	// Not every claimed path
	// will necessarily appear as part of a Device. Claimed paths will
	// only appear under Devices if the device identifier of the path
	// matches up with the device identifier exposed by the Device.
	ClaimedPath []string `xml:"claimedPath,omitempty" json:"claimedPath,omitempty"`
}

func init() {
	t["HostPlugStoreTopologyPlugin"] = reflect.TypeOf((*HostPlugStoreTopologyPlugin)(nil)).Elem()
}

// This data object represents target information.
type HostPlugStoreTopologyTarget struct {
	DynamicData

	// The identifier of the target.
	//
	// This will be a string representing the
	// transport information of the target.
	Key string `xml:"key" json:"key"`
	// Detailed, transport-specific information about the target of a path.
	Transport BaseHostTargetTransport `xml:"transport,omitempty,typeattr" json:"transport,omitempty"`
}

func init() {
	t["HostPlugStoreTopologyTarget"] = reflect.TypeOf((*HostPlugStoreTopologyTarget)(nil)).Elem()
}

// This data type describes the avaialable capacity
// for VM traffic on a physical NIC
type HostPnicNetworkResourceInfo struct {
	DynamicData

	// The physical NIC device
	PnicDevice string `xml:"pnicDevice" json:"pnicDevice"`
	// The total bandwidth available for VM traffic
	AvailableBandwidthForVMTraffic int64 `xml:"availableBandwidthForVMTraffic,omitempty" json:"availableBandwidthForVMTraffic,omitempty"`
	// The unused bandwidth for VM traffic
	UnusedBandwidthForVMTraffic int64 `xml:"unusedBandwidthForVMTraffic,omitempty" json:"unusedBandwidthForVMTraffic,omitempty"`
	// The connected virtual NICs of powered on Virtual Machines
	// that are placed on this physical NIC
	PlacedVirtualNics []HostPlacedVirtualNicIdentifier `xml:"placedVirtualNics,omitempty" json:"placedVirtualNics,omitempty"`
}

func init() {
	t["HostPnicNetworkResourceInfo"] = reflect.TypeOf((*HostPnicNetworkResourceInfo)(nil)).Elem()
}

// This data object type is used to describe port groups.
//
// Port groups are used to group virtual network adapters on a virtual switch,
// associating them with networks and network policies.
type HostPortGroup struct {
	DynamicData

	// The linkable identifier.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// The ports that currently exist and are used on this port group.
	Port []HostPortGroupPort `xml:"port,omitempty" json:"port,omitempty"`
	// The virtual switch that contains this port group.
	Vswitch string `xml:"vswitch,omitempty" json:"vswitch,omitempty"`
	// Computed network policies that are applicable for a port group.
	//
	// The
	// inheritance scheme for PortGroup requires knowledge about the
	// NetworkPolicy for a port group and its parent virtual switch as well as
	// the logic for computing the results. This information is provided as
	// a convenience so that callers need not duplicate the inheritance logic
	// to determine the proper values for a network policy.
	//
	// See the description of the
	// `NetworkPolicy` data object type
	// for more information.
	ComputedPolicy HostNetworkPolicy `xml:"computedPolicy" json:"computedPolicy"`
	// The specification of a port group.
	Spec HostPortGroupSpec `xml:"spec" json:"spec"`
}

func init() {
	t["HostPortGroup"] = reflect.TypeOf((*HostPortGroup)(nil)).Elem()
}

// This describes the port group configuration containing both
// the configurable properties on a port group and the associated
// virtual switch.
type HostPortGroupConfig struct {
	DynamicData

	// Indicates the change operation to apply on this configuration
	// specification.
	//
	// See also `HostConfigChangeOperation_enum`.
	ChangeOperation string `xml:"changeOperation,omitempty" json:"changeOperation,omitempty"`
	// The specification of the port group.
	Spec *HostPortGroupSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["HostPortGroupConfig"] = reflect.TypeOf((*HostPortGroupConfig)(nil)).Elem()
}

// A Port data object type is a runtime representation of network
// connectivity between a network service or virtual machine and a
// virtual switch.
//
// This is different from a port group in that
// the port group represents the configuration aspects of the
// network connection. The Port object provides runtime statistics.
type HostPortGroupPort struct {
	DynamicData

	// The linkable identifier.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// The Media Access Control (MAC) address of network service of
	// the virtual machine connected on this port.
	Mac []string `xml:"mac,omitempty" json:"mac,omitempty"`
	// The type of component connected on this port.
	//
	// Must be one of the
	// values of `PortGroupConnecteeType_enum`.
	Type string `xml:"type" json:"type"`
}

func init() {
	t["HostPortGroupPort"] = reflect.TypeOf((*HostPortGroupPort)(nil)).Elem()
}

// The `HostPortGroupProfile` data object represents the subprofile
// for a port group that will be used by the ESX host.
//
// If a profile plug-in defines policies or subprofiles, use the
// `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the additional configuration data.
type HostPortGroupProfile struct {
	PortGroupProfile

	// IP address configuration for the Host network.
	IpConfig IpAddressProfile `xml:"ipConfig" json:"ipConfig"`
}

func init() {
	t["HostPortGroupProfile"] = reflect.TypeOf((*HostPortGroupProfile)(nil)).Elem()
}

// This data object type describes the PortGroup specification
// representing the properties on a PortGroup that
// can be configured.
type HostPortGroupSpec struct {
	DynamicData

	// The name of the port group.
	Name string `xml:"name" json:"name"`
	// The VLAN ID for ports using this port group.
	//
	// Possible values:
	//   - A value of 0 specifies that you do not want the port group associated
	//     with a VLAN.
	//   - A value from 1 to 4094 specifies a VLAN ID for the port group.
	//   - A value of 4095 specifies that the port group should use trunk mode,
	//     which allows the guest operating system to manage its own VLAN tags.
	VlanId int32 `xml:"vlanId" json:"vlanId"`
	// The identifier of the virtual switch on which
	// this port group is located.
	VswitchName string `xml:"vswitchName" json:"vswitchName"`
	// Policies on the port group take precedence over the ones specified
	// on the virtual switch.
	Policy HostNetworkPolicy `xml:"policy" json:"policy"`
}

func init() {
	t["HostPortGroupSpec"] = reflect.TypeOf((*HostPortGroupSpec)(nil)).Elem()
}

// This data object type contains a POSIX-specific parameter
// for local account creation.
type HostPosixAccountSpec struct {
	HostAccountSpec

	// Deprecated as of vSphere API 5.1, this property is deprecated and
	// is ignored.
	//
	// The user ID or group ID of a specified account.
	PosixId int32 `xml:"posixId,omitempty" json:"posixId,omitempty"`
	// Grants shell access.
	//
	// As of vSphere API 5.1, this property is deprecated and
	// is ignored. `HostLocalAccountManager.CreateUser` will always set this to true, and
	// `HostLocalAccountManager.UpdateUser` will set it to true if it is already false.
	// Also shell access is granted only to users with
	// Administrator role on the root folder and no other non-Admin role on
	// any other inventory object.
	//
	// As of vSphere API 7.0.3.2, this property is no longer ignored and it must
	// be true if a user with administrator permissions needs shell access.
	// It can be set to true for other users only by administrators
	// who themselves have this shell access.
	// Administrators without shell access cannot change the passwords of
	// users with shell access.
	// Setting this property to false for user 'root' has no effect.
	//
	// If this property is not specified when creating a new user account
	// then the default value depends on the following factors:
	// if the calling user does not have shell access then it defaults to
	// false; if the calling user has shell access then it defaults to true,
	// unless overridden by host configuration settings.
	ShellAccess *bool `xml:"shellAccess" json:"shellAccess,omitempty"`
}

func init() {
	t["HostPosixAccountSpec"] = reflect.TypeOf((*HostPosixAccountSpec)(nil)).Elem()
}

// This fault is thrown when a host power operation fails.
type HostPowerOpFailed struct {
	VimFault
}

func init() {
	t["HostPowerOpFailed"] = reflect.TypeOf((*HostPowerOpFailed)(nil)).Elem()
}

type HostPowerOpFailedFault BaseHostPowerOpFailed

func init() {
	t["HostPowerOpFailedFault"] = reflect.TypeOf((*HostPowerOpFailedFault)(nil)).Elem()
}

// Power Management Policy data object.
//
// Used to retrieve and specify current host power management policy.
type HostPowerPolicy struct {
	DynamicData

	// Power Policy Key.
	//
	// Internally generated key which uniquely identifies power management
	// policy on a host.
	Key int32 `xml:"key" json:"key"`
	// Power Policy Name.
	Name string `xml:"name" json:"name"`
	// Power Policy Short Name.
	//
	// This is not localizable property which can be used to identify specific
	// power managing policies like "custom" power policy. Custom power policy
	// has short name set to "custom".
	ShortName string `xml:"shortName" json:"shortName"`
	// Power Policy Description.
	Description string `xml:"description" json:"description"`
}

func init() {
	t["HostPowerPolicy"] = reflect.TypeOf((*HostPowerPolicy)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, the event is no longer relevant.
//
// This event records that the primary agent specified is not a short name.
//
// The name of the primary agent is usually stored as a short name. You should
// not normally see this error. Please check the network configurations of your
// hosts.
type HostPrimaryAgentNotShortNameEvent struct {
	HostDasEvent

	PrimaryAgent string `xml:"primaryAgent" json:"primaryAgent"`
}

func init() {
	t["HostPrimaryAgentNotShortNameEvent"] = reflect.TypeOf((*HostPrimaryAgentNotShortNameEvent)(nil)).Elem()
}

// This event records that a Profile application was done
// on the host
type HostProfileAppliedEvent struct {
	HostEvent

	// Link to the profile which was applied
	Profile ProfileEventArgument `xml:"profile" json:"profile"`
}

func init() {
	t["HostProfileAppliedEvent"] = reflect.TypeOf((*HostProfileAppliedEvent)(nil)).Elem()
}

// The `HostProfileCompleteConfigSpec` data object
// specifies the complete configuration for a host profile.
type HostProfileCompleteConfigSpec struct {
	HostProfileConfigSpec

	// Profile that contains configuration data for the host.
	ApplyProfile *HostApplyProfile `xml:"applyProfile,omitempty" json:"applyProfile,omitempty"`
	// User defined compliance profile.
	//
	// Reserved for future use.
	CustomComplyProfile *ComplianceProfile `xml:"customComplyProfile,omitempty" json:"customComplyProfile,omitempty"`
	// Flag indicating if this configuration specification contains changes
	// in the `HostProfileCompleteConfigSpec.disabledExpressionList`.
	//
	// If False, the Profile Engine ignores the contents of the disabled expression list.
	DisabledExpressionListChanged bool `xml:"disabledExpressionListChanged" json:"disabledExpressionListChanged"`
	// List of expressions to be disabled.
	//
	// Each entry in the list specifies
	// a `ProfileExpression*.*ProfileExpression.id`.
	// All expressions are enabled by default.
	//
	// If you set `HostProfileCompleteConfigSpec.disabledExpressionListChanged`
	// to True, the Profile Engine uses the contents of this list to replace the contents
	// of the `HostProfile*.*Profile.config*.*HostProfileConfigInfo.disabledExpressionList`.
	//
	// The expression list is contained in the
	// `HostProfileConfigInfo.defaultComplyProfile`.
	// The Profile Engine automatically generates the default compliance profile
	// when you create a host profile.
	DisabledExpressionList []string `xml:"disabledExpressionList,omitempty" json:"disabledExpressionList,omitempty"`
	// Host for profile validation.
	//
	// This can be a host on which the profile
	// is intended to be used. If you do not specify a validator host,
	// the Profile Engine uses the `HostProfile*.*HostProfile.referenceHost`
	// to validate the profile.
	//
	// Refers instance of `HostSystem`.
	ValidatorHost *ManagedObjectReference `xml:"validatorHost,omitempty" json:"validatorHost,omitempty"`
	// If "false", then the host profile will be saved without being validated.
	//
	// The default if not specified is "true".
	// This option should be used with caution, since the resulting host profile
	// will not be checked for errors.
	Validating *bool `xml:"validating" json:"validating,omitempty"`
	// Host profile configuration data and compliance information.
	//
	// If `HostProfileCompleteConfigSpec.hostConfig` is set,
	// then the HostApplyProfile
	// `HostProfileCompleteConfigSpec.applyProfile` and
	// ComplianceProfile
	// `HostProfileCompleteConfigSpec.customComplyProfile`
	// should not be set in CompleteConfigSpec.
	HostConfig *HostProfileConfigInfo `xml:"hostConfig,omitempty" json:"hostConfig,omitempty"`
}

func init() {
	t["HostProfileCompleteConfigSpec"] = reflect.TypeOf((*HostProfileCompleteConfigSpec)(nil)).Elem()
}

// The `HostProfileConfigInfo` data object
// contains host profile data and information about profile compliance.
type HostProfileConfigInfo struct {
	ProfileConfigInfo

	// Profile data for host configuration.
	ApplyProfile *HostApplyProfile `xml:"applyProfile,omitempty" json:"applyProfile,omitempty"`
	// Default compliance profile.
	//
	// The ESX Server uses the <code>applyProfile</code>
	// (`HostProfile*.*Profile.config*.*HostProfileConfigInfo.applyProfile`)
	// to generate the default compliance profile when you create a host profile.
	// When the <code>applyProfile</code> is modified, the Server automatically
	// updates the compliance profile to match it.
	DefaultComplyProfile *ComplianceProfile `xml:"defaultComplyProfile,omitempty" json:"defaultComplyProfile,omitempty"`
	// List of compliance locators.
	//
	// Each locator specifies an association between
	// the <code>applyProfile</code> and the <code>defaultComplyProfile</code>.
	// The association identifies a component profile and the expression generated
	// by the profile. vSphere clients can use this data to provide contextual
	// information to the user.
	DefaultComplyLocator []ComplianceLocator `xml:"defaultComplyLocator,omitempty" json:"defaultComplyLocator,omitempty"`
	// User defined compliance profile.
	//
	// Reserved for future use.
	CustomComplyProfile *ComplianceProfile `xml:"customComplyProfile,omitempty" json:"customComplyProfile,omitempty"`
	// Disabled expressions in the default compliance profile
	// (<code>DefaultComplyProfile</code>).
	//
	// Use this property to specify which expressions are disabled.
	// All expressions are enabled by default.
	DisabledExpressionList []string `xml:"disabledExpressionList,omitempty" json:"disabledExpressionList,omitempty"`
	// Localized description of the profile.
	Description *ProfileDescription `xml:"description,omitempty" json:"description,omitempty"`
}

func init() {
	t["HostProfileConfigInfo"] = reflect.TypeOf((*HostProfileConfigInfo)(nil)).Elem()
}

// `HostProfileConfigSpec` is the base data object
// for all `HostProfile` configuration specifications.
type HostProfileConfigSpec struct {
	ProfileCreateSpec
}

func init() {
	t["HostProfileConfigSpec"] = reflect.TypeOf((*HostProfileConfigSpec)(nil)).Elem()
}

// The `HostProfileHostBasedConfigSpec` data object
// specifies the host from which configuration data is to be extracted
// and the profile(s) to be created or updated.
type HostProfileHostBasedConfigSpec struct {
	HostProfileConfigSpec

	// ESX host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Flag indicating if the Profile Engine should use the profile
	// plug-ins present on the host to create the profile.
	//
	// If <code>true</code>, the host Profile Engine uses the vSphere 5.0
	// (or later) profile plug-ins. The resulting profile is not compatible
	// with legacy hosts (pre 5.0). If <code>false</code> or not specified,
	// the Profile Engine creates a legacy host profile.
	UseHostProfileEngine *bool `xml:"useHostProfileEngine" json:"useHostProfileEngine,omitempty"`
}

func init() {
	t["HostProfileHostBasedConfigSpec"] = reflect.TypeOf((*HostProfileHostBasedConfigSpec)(nil)).Elem()
}

// The data class for host profile composition result.
type HostProfileManagerCompositionResult struct {
	DynamicData

	// The composition errors for all targets, for example, the source
	// profile doesn't exist.
	Errors []LocalizableMessage `xml:"errors,omitempty" json:"errors,omitempty"`
	// The array of
	// `HostProfileManagerCompositionResultResultElement`
	// for all the target host profiles.
	Results []HostProfileManagerCompositionResultResultElement `xml:"results,omitempty" json:"results,omitempty"`
}

func init() {
	t["HostProfileManagerCompositionResult"] = reflect.TypeOf((*HostProfileManagerCompositionResult)(nil)).Elem()
}

// Composition result for a specific target host profile.
type HostProfileManagerCompositionResultResultElement struct {
	DynamicData

	// The target host profile.
	//
	// Refers instance of `Profile`.
	Target ManagedObjectReference `xml:"target" json:"target"`
	// The composition status.
	//
	// See `HostProfileManagerCompositionResultResultElementStatus_enum`
	// for details of supported values.
	Status string `xml:"status" json:"status"`
	// The composition errors.
	Errors []LocalizableMessage `xml:"errors,omitempty" json:"errors,omitempty"`
}

func init() {
	t["HostProfileManagerCompositionResultResultElement"] = reflect.TypeOf((*HostProfileManagerCompositionResultResultElement)(nil)).Elem()
}

// The data class for the host profile composition validation
// results.
type HostProfileManagerCompositionValidationResult struct {
	DynamicData

	// The array of
	// `HostProfileManagerCompositionValidationResultResultElement`
	// for all the target host profiles.
	Results []HostProfileManagerCompositionValidationResultResultElement `xml:"results,omitempty" json:"results,omitempty"`
	// The common error happened at validation.
	Errors []LocalizableMessage `xml:"errors,omitempty" json:"errors,omitempty"`
}

func init() {
	t["HostProfileManagerCompositionValidationResult"] = reflect.TypeOf((*HostProfileManagerCompositionValidationResult)(nil)).Elem()
}

// The host profile composition validation result for a specific target
// host profile.
type HostProfileManagerCompositionValidationResultResultElement struct {
	DynamicData

	// The target host profile.
	//
	// Refers instance of `Profile`.
	Target ManagedObjectReference `xml:"target" json:"target"`
	// The composition validation status.
	//
	// See `HostProfileManagerCompositionValidationResultResultElementStatus_enum`
	// for details of supported values.
	Status string `xml:"status" json:"status"`
	// The composition validation errors.
	Errors []LocalizableMessage `xml:"errors,omitempty" json:"errors,omitempty"`
	// When a selected sub profile for composition exists in both the
	// source and target host profile, this member will contain the
	// source side difference for the selected sub profiles.
	SourceDiffForToBeMerged *HostApplyProfile `xml:"sourceDiffForToBeMerged,omitempty" json:"sourceDiffForToBeMerged,omitempty"`
	// Similar to the member <code>sourceDiffForToBeMerged</code> above
	// but contains the target side difference.
	//
	// Comparing the same
	// configurations in these two variables will show the changes for
	// the configurations that exist in both source and target host
	// profile.
	TargetDiffForToBeMerged *HostApplyProfile `xml:"targetDiffForToBeMerged,omitempty" json:"targetDiffForToBeMerged,omitempty"`
	// The sub profiles doesn't exist in the target and will be added to
	// the target at host profile composition.
	ToBeAdded *HostApplyProfile `xml:"toBeAdded,omitempty" json:"toBeAdded,omitempty"`
	// The sub profiles exists in the target but not in the source and will
	// be deleted from the target at host profile composition.
	ToBeDeleted *HostApplyProfile `xml:"toBeDeleted,omitempty" json:"toBeDeleted,omitempty"`
	// The sub profiles to be disabled in the target host profiles.
	ToBeDisabled *HostApplyProfile `xml:"toBeDisabled,omitempty" json:"toBeDisabled,omitempty"`
	// The sub profiles to be enabled in the target host profiles.
	ToBeEnabled *HostApplyProfile `xml:"toBeEnabled,omitempty" json:"toBeEnabled,omitempty"`
	// The sub profile to be unset ignoring compliance check
	// in the target host profile.
	ToBeReenableCC *HostApplyProfile `xml:"toBeReenableCC,omitempty" json:"toBeReenableCC,omitempty"`
}

func init() {
	t["HostProfileManagerCompositionValidationResultResultElement"] = reflect.TypeOf((*HostProfileManagerCompositionValidationResultResultElement)(nil)).Elem()
}

// The `HostProfileManagerConfigTaskList` data object
// represents a set of tasks to be performed on a host during host profile application.
type HostProfileManagerConfigTaskList struct {
	DynamicData

	// Set of configuration changes to be applied to the host.
	ConfigSpec *HostConfigSpec `xml:"configSpec,omitempty" json:"configSpec,omitempty"`
	// Description of tasks that will be performed on the host
	// to carry out HostProfile application.
	TaskDescription []LocalizableMessage `xml:"taskDescription,omitempty" json:"taskDescription,omitempty"`
	// A set of requirements whose actions must be fulfilled before and/or
	// after the task list is applied on an ESXi host, e.g.
	//
	// whether the ESXi
	// host must be in maintenance mode prior to applying the <code>configSpec</code>,
	// or whether the host will need to be rebooted after applying the <code>configSpec</code>.
	// See `HostProfileManagerTaskListRequirement_enum` for
	// details of supported values.
	TaskListRequirement []string `xml:"taskListRequirement,omitempty" json:"taskListRequirement,omitempty"`
}

func init() {
	t["HostProfileManagerConfigTaskList"] = reflect.TypeOf((*HostProfileManagerConfigTaskList)(nil)).Elem()
}

// Data class for <code>HostSystem</code>-<code>AnswerFileCreateSpec</code>
// mapping.
type HostProfileManagerHostToConfigSpecMap struct {
	DynamicData

	// The host
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The corresponding <code>AnswerFileCreateSpec</code>.
	ConfigSpec BaseAnswerFileCreateSpec `xml:"configSpec,typeattr" json:"configSpec"`
}

func init() {
	t["HostProfileManagerHostToConfigSpecMap"] = reflect.TypeOf((*HostProfileManagerHostToConfigSpecMap)(nil)).Elem()
}

type HostProfileResetValidationState HostProfileResetValidationStateRequestType

func init() {
	t["HostProfileResetValidationState"] = reflect.TypeOf((*HostProfileResetValidationState)(nil)).Elem()
}

type HostProfileResetValidationStateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["HostProfileResetValidationStateRequestType"] = reflect.TypeOf((*HostProfileResetValidationStateRequestType)(nil)).Elem()
}

type HostProfileResetValidationStateResponse struct {
}

// The `HostProfileSerializedHostProfileSpec` data object
// contains a string representation of a host profile.
//
// Use this object when you
// create a host profile from a file.
type HostProfileSerializedHostProfileSpec struct {
	ProfileSerializedCreateSpec

	// Host for profile validation.
	//
	// This can be a host on which
	// the profile is intended to be used.
	//
	// Refers instance of `HostSystem`.
	ValidatorHost *ManagedObjectReference `xml:"validatorHost,omitempty" json:"validatorHost,omitempty"`
	// If "false", then the host profile will be saved without being validated.
	//
	// The default if not specified is "true".
	// This option should be used with caution, since the resulting host profile
	// will not be checked for errors.
	Validating *bool `xml:"validating" json:"validating,omitempty"`
}

func init() {
	t["HostProfileSerializedHostProfileSpec"] = reflect.TypeOf((*HostProfileSerializedHostProfileSpec)(nil)).Elem()
}

// This defines the validation result for the host profile.
type HostProfileValidationFailureInfo struct {
	DynamicData

	// The name of host profile to be validated.
	Name string `xml:"name" json:"name"`
	// Host profile annotation at update.
	Annotation string `xml:"annotation" json:"annotation"`
	// Host profile update type.
	//
	// See the enumerate class
	// <code>UpdateType</code> above for the valid values.
	UpdateType string `xml:"updateType" json:"updateType"`
	// The host where the host profile is updated from.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The host configuration after validation.
	ApplyProfile *HostApplyProfile `xml:"applyProfile,omitempty" json:"applyProfile,omitempty"`
	// List of failures in the host profile configuration.
	Failures []ProfileUpdateFailedUpdateFailure `xml:"failures,omitempty" json:"failures,omitempty"`
	// The <code>MethodFault</code>s happened at validation.
	Faults []LocalizedMethodFault `xml:"faults,omitempty" json:"faults,omitempty"`
}

func init() {
	t["HostProfileValidationFailureInfo"] = reflect.TypeOf((*HostProfileValidationFailureInfo)(nil)).Elem()
}

// Data type used to contain a representation of host or cluster customization
// data in a `HostProfilesCustomizationData` object.
//
// Subclasses of this must be defined to provide host or cluster customization
// data in specific formats.
type HostProfilesEntityCustomizations struct {
	DynamicData
}

func init() {
	t["HostProfilesEntityCustomizations"] = reflect.TypeOf((*HostProfilesEntityCustomizations)(nil)).Elem()
}

// ProtocolEndpoint is configured LUN or NFS directory
// This is used for io path to actual virtual disks (VVols)
type HostProtocolEndpoint struct {
	DynamicData

	// Deprecated from all vmodl version above @released("6.0")
	// Use type instead.
	//
	// Type of ProtocolEndpoint
	// See `HostProtocolEndpointPEType_enum`
	PeType string `xml:"peType" json:"peType"`
	// Type of ProtocolEndpoint
	// See `HostProtocolEndpointProtocolEndpointType_enum`
	Type string `xml:"type,omitempty" json:"type,omitempty"`
	// Identifier for PE assigned by VASA Provider
	Uuid string `xml:"uuid" json:"uuid"`
	// Set of ESX hosts which can see the same PE
	//
	// Refers instances of `HostSystem`.
	HostKey []ManagedObjectReference `xml:"hostKey,omitempty" json:"hostKey,omitempty"`
	// Associated Storage Array
	StorageArray string `xml:"storageArray,omitempty" json:"storageArray,omitempty"`
	// NFSv3 and NFSv4x PE will contain information about NFS Server
	// For NFSv4x this field may contain comma separated list of IP addresses
	// which are associated with the NFS Server
	NfsServer string `xml:"nfsServer,omitempty" json:"nfsServer,omitempty"`
	// NFSv3 and NFSv4x PE will contain information about NFS directory
	NfsDir string `xml:"nfsDir,omitempty" json:"nfsDir,omitempty"`
	// NFSv4x PE will contain information about NFSv4x Server Scope
	NfsServerScope string `xml:"nfsServerScope,omitempty" json:"nfsServerScope,omitempty"`
	// NFSv4x PE will contain information about NFSv4x Server Major
	NfsServerMajor string `xml:"nfsServerMajor,omitempty" json:"nfsServerMajor,omitempty"`
	// NFSv4x PE will contain information about NFSv4x Server Auth-type
	NfsServerAuthType string `xml:"nfsServerAuthType,omitempty" json:"nfsServerAuthType,omitempty"`
	// NFSv4x PE will contain information about NFSv4x Server User
	NfsServerUser string `xml:"nfsServerUser,omitempty" json:"nfsServerUser,omitempty"`
	// SCSI PE will contain information about SCSI device ID
	DeviceId string `xml:"deviceId,omitempty" json:"deviceId,omitempty"`
	// Indicates whether the PE is being used to access a stretch-capable container
	UsedByStretchedContainer *bool `xml:"usedByStretchedContainer" json:"usedByStretchedContainer,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["HostProtocolEndpoint"] = reflect.TypeOf((*HostProtocolEndpoint)(nil)).Elem()
}

// The HostProxySwitch is a software entity which represents the component
// of a DistributedVirtualSwitch on a particular host.
type HostProxySwitch struct {
	DynamicData

	// The uuid of the DistributedVirtualSwitch that the HostProxySwitch
	// is a part of.
	DvsUuid string `xml:"dvsUuid" json:"dvsUuid"`
	// The name of the DistributedVirtualSwitch that the HostProxySwitch
	// is part of.
	DvsName string `xml:"dvsName" json:"dvsName"`
	// The proxy switch key.
	Key string `xml:"key" json:"key"`
	// The number of ports that this switch currently has.
	NumPorts int32 `xml:"numPorts" json:"numPorts"`
	// The configured number of ports that this switch has.
	//
	// If configured number of ports is changed,
	// a host reboot is required for the new value to take effect.
	ConfigNumPorts int32 `xml:"configNumPorts,omitempty" json:"configNumPorts,omitempty"`
	// The number of ports that are available on this virtual switch.
	NumPortsAvailable int32 `xml:"numPortsAvailable" json:"numPortsAvailable"`
	// The list of ports that can be potentially used by physical nics.
	//
	// This property contains the keys and names of such ports.
	UplinkPort []KeyValue `xml:"uplinkPort,omitempty" json:"uplinkPort,omitempty"`
	// The maximum transmission unit (MTU) associated with this switch
	// in bytes.
	Mtu int32 `xml:"mtu,omitempty" json:"mtu,omitempty"`
	// The set of physical network adapters associated with this switch.
	Pnic []string `xml:"pnic,omitempty" json:"pnic,omitempty"`
	// The specification of the switch.
	Spec HostProxySwitchSpec `xml:"spec" json:"spec"`
	// The Link Aggregation Control Protocol group and
	// Uplink ports in the group.
	HostLag []HostProxySwitchHostLagConfig `xml:"hostLag,omitempty" json:"hostLag,omitempty"`
	// Indicates whether network reservation is supported on this switch
	NetworkReservationSupported *bool `xml:"networkReservationSupported" json:"networkReservationSupported,omitempty"`
	// Indicate whether NSX-T is enabled on this switch
	NsxtEnabled *bool `xml:"nsxtEnabled" json:"nsxtEnabled,omitempty"`
	// Is ENS enabled on this switch
	EnsEnabled *bool `xml:"ensEnabled" json:"ensEnabled,omitempty"`
	// Is ENS interrupt mode enabled on this switch
	EnsInterruptEnabled *bool `xml:"ensInterruptEnabled" json:"ensInterruptEnabled,omitempty"`
	// Transport Zones this switch joined
	TransportZones []DistributedVirtualSwitchHostMemberTransportZoneInfo `xml:"transportZones,omitempty" json:"transportZones,omitempty"`
	// Uplink port names used by NSX-T
	NsxUsedUplinkPort []string `xml:"nsxUsedUplinkPort,omitempty" json:"nsxUsedUplinkPort,omitempty"`
	// NSX-T proxy switch status
	NsxtStatus string `xml:"nsxtStatus,omitempty" json:"nsxtStatus,omitempty"`
	// Additional information regarding the NSX-T proxy switch status
	NsxtStatusDetail string `xml:"nsxtStatusDetail,omitempty" json:"nsxtStatusDetail,omitempty"`
	// ENS Status From VmKernal.
	EnsInfo *HostProxySwitchEnsInfo `xml:"ensInfo,omitempty" json:"ensInfo,omitempty" vim:"8.0.0.1"`
	// Indicate if network offloading is enabled on the proxy switch of
	// this host.
	//
	// Unset implies that network offloading is disabled.
	NetworkOffloadingEnabled *bool `xml:"networkOffloadingEnabled" json:"networkOffloadingEnabled,omitempty" vim:"8.0.0.1"`
	// Indicates the runtime state of uplinks on the host.
	//
	// Only set when `HostProxySwitch.networkOffloadingEnabled`
	// is true.
	HostUplinkState []DistributedVirtualSwitchHostMemberHostUplinkState `xml:"hostUplinkState,omitempty" json:"hostUplinkState,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["HostProxySwitch"] = reflect.TypeOf((*HostProxySwitch)(nil)).Elem()
}

// This data object type describes the HostProxySwitch configuration
// containing both the configurable
// properties on a HostProxySwitch and identification information.
type HostProxySwitchConfig struct {
	DynamicData

	// This property indicates the change operation to apply on
	// this configuration specification.
	//
	// Valid values are:
	//   - `edit`
	//   - `remove`
	//
	// See also `HostConfigChangeOperation_enum`.
	ChangeOperation string `xml:"changeOperation,omitempty" json:"changeOperation,omitempty"`
	// The uuid of the DistributedVirtualSwitch that the HostProxySwitch
	// is a part of.
	Uuid string `xml:"uuid" json:"uuid"`
	// The specification of the HostProxySwitch.
	Spec *HostProxySwitchSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["HostProxySwitchConfig"] = reflect.TypeOf((*HostProxySwitchConfig)(nil)).Elem()
}

// This data object type describes
// the Ens status from VmKernal.
type HostProxySwitchEnsInfo struct {
	DynamicData

	// ENS ops version
	OpsVersion int64 `xml:"opsVersion" json:"opsVersion"`
	// Number of ENS portset operations
	NumPSOps int64 `xml:"numPSOps" json:"numPSOps"`
	// Number of ENS Lcore operations
	NumLcoreOps int64 `xml:"numLcoreOps" json:"numLcoreOps"`
	// Error status of the last ENS portset operation
	ErrorStatus int64 `xml:"errorStatus" json:"errorStatus"`
	// Error status of the last Lcore operation
	LcoreStatus int64 `xml:"lcoreStatus" json:"lcoreStatus"`
}

func init() {
	t["HostProxySwitchEnsInfo"] = reflect.TypeOf((*HostProxySwitchEnsInfo)(nil)).Elem()
	minAPIVersionForType["HostProxySwitchEnsInfo"] = "8.0.0.1"
}

// This data object type describes the set of Uplink Ports in
// Link Aggregation Control Protocol group.
type HostProxySwitchHostLagConfig struct {
	DynamicData

	LagKey  string `xml:"lagKey" json:"lagKey"`
	LagName string `xml:"lagName,omitempty" json:"lagName,omitempty"`
	// The list of Uplink Ports in the Link Aggregation Control Protocol group.
	//
	// This property contains the keys and names of such ports.
	UplinkPort []KeyValue `xml:"uplinkPort,omitempty" json:"uplinkPort,omitempty"`
}

func init() {
	t["HostProxySwitchHostLagConfig"] = reflect.TypeOf((*HostProxySwitchHostLagConfig)(nil)).Elem()
}

// This data object type describes the HostProxySwitch specification
// representing the properties on a HostProxySwitch that can be
// configured once the object exists.
type HostProxySwitchSpec struct {
	DynamicData

	// The specification describes how physical network adapters
	// are bridged to the switch.
	Backing BaseDistributedVirtualSwitchHostMemberBacking `xml:"backing,omitempty,typeattr" json:"backing,omitempty"`
}

func init() {
	t["HostProxySwitchSpec"] = reflect.TypeOf((*HostProxySwitchSpec)(nil)).Elem()
}

// Configuration information for the host PTP (Precision Time
// Protocol) service.
type HostPtpConfig struct {
	DynamicData

	// PTP domain number as defined in the IEEE 1588 standard.
	//
	// Supported
	// values are in the range 0-255.
	Domain int32 `xml:"domain,omitempty" json:"domain,omitempty"`
	// List of PTP port configurations.
	//
	// See `HostPtpConfigPtpPort`.
	Port []HostPtpConfigPtpPort `xml:"port,omitempty" json:"port,omitempty"`
}

func init() {
	t["HostPtpConfig"] = reflect.TypeOf((*HostPtpConfig)(nil)).Elem()
	minAPIVersionForType["HostPtpConfig"] = "7.0.3.0"
}

// Configuration of a PTP port, a logical entity providing an
// interface to the network for sending and receiving PTP messages
// with timestamping.
type HostPtpConfigPtpPort struct {
	DynamicData

	// Index into the list of PTP ports.
	//
	// Supported values are in the
	// range 0 through `HostCapability.maxSupportedPtpPorts`-1.
	Index int32 `xml:"index" json:"index"`
	// Type of network device to be used with this port.
	//
	// See `HostPtpConfigDeviceType_enum` for supported values. A device type
	// of `none` indicates that this port is
	// inactive.
	DeviceType string `xml:"deviceType,omitempty" json:"deviceType,omitempty"`
	// Name of PTP capable network device to be used with this port.
	//
	// Supported values depend on the type of network device used.
	// For `virtualNic` this field is the name of
	// a valid virtual NIC. See `HostVirtualNic`.
	// For `pciPassthruNic` this field is a valid
	// PCI device ID composed of "bus:slot.function", enabled for
	// PCI passthru. See `HostPciPassthruInfo`.
	// For `none` this field is ignored.
	Device string `xml:"device,omitempty" json:"device,omitempty"`
	// IP configuration of this port.
	//
	// For `pciPassthruNic`, this field reflects
	// current IP configuration, and it can be set.
	// For `virtualNic`, this field reflects current
	// IP configuration, but it cannot be set. To configure IP settings
	// of a virtual NIC, see `HostVirtualNic`.
	// For `none`, this field is ignored.
	IpConfig *HostIpConfig `xml:"ipConfig,omitempty" json:"ipConfig,omitempty"`
}

func init() {
	t["HostPtpConfigPtpPort"] = reflect.TypeOf((*HostPtpConfigPtpPort)(nil)).Elem()
	minAPIVersionForType["HostPtpConfigPtpPort"] = "7.0.3.0"
}

// This data object describes a qualified name of the host used to
// identify it in a particular context.
type HostQualifiedName struct {
	DynamicData

	// The qualified name.
	Value string `xml:"value" json:"value"`
	// The type of the qualified name.
	//
	// The list of supported values is specified in `HostQualifiedNameType_enum`.
	Type string `xml:"type" json:"type"`
}

func init() {
	t["HostQualifiedName"] = reflect.TypeOf((*HostQualifiedName)(nil)).Elem()
	minAPIVersionForType["HostQualifiedName"] = "7.0.3.0"
}

type HostQueryVirtualDiskUuid HostQueryVirtualDiskUuidRequestType

func init() {
	t["HostQueryVirtualDiskUuid"] = reflect.TypeOf((*HostQueryVirtualDiskUuid)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostQueryVirtualDiskUuid`.
type HostQueryVirtualDiskUuidRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk whose uuid for the DDB entry needs to be queried.
	// A URL has the form
	// > _scheme_://_authority_/folder/_path_?dsName=_dsName_
	//
	// where
	//   - _scheme_ is <code>http</code> or <code>https</code>.
	//   - _authority_ specifies the hostname or IP address of the VirtualCenter or
	//     ESX server and optionally the port.
	//   - _dsName_ is the name of the Datastore.
	//   - _path_ is a slash-delimited path from the root of the datastore.
	//
	// A datastore path has the form
	// > \[_datastore_\] _path_
	//
	// where
	//   - _datastore_ is the datastore name.
	//   - _path_ is a slash-delimited path from the root of the datastore.
	//
	// An example datastore path is "\[storage\] path/to/file.extension".
	Name string `xml:"name" json:"name"`
}

func init() {
	t["HostQueryVirtualDiskUuidRequestType"] = reflect.TypeOf((*HostQueryVirtualDiskUuidRequestType)(nil)).Elem()
	minAPIVersionForType["HostQueryVirtualDiskUuidRequestType"] = "8.0.3.0"
}

type HostQueryVirtualDiskUuidResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// This data object represents a Remote Direct Memory Access
// device as seen by the primary operating system.
type HostRdmaDevice struct {
	DynamicData

	// The linkable identifier.
	Key string `xml:"key" json:"key"`
	// The device name of the RDMA device.
	Device string `xml:"device" json:"device"`
	// The short string name of the device driver, if available.
	Driver string `xml:"driver,omitempty" json:"driver,omitempty"`
	// Device description, if available.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// If set, represents the physical backing for the RDMA device.
	//
	// Not all RDMA devices are required to have a physical backing.
	Backing BaseHostRdmaDeviceBacking `xml:"backing,omitempty,typeattr" json:"backing,omitempty"`
	// Current device connection state.
	ConnectionInfo HostRdmaDeviceConnectionInfo `xml:"connectionInfo" json:"connectionInfo"`
	// Supported capabilies of the RDMA device.
	Capability HostRdmaDeviceCapability `xml:"capability" json:"capability"`
}

func init() {
	t["HostRdmaDevice"] = reflect.TypeOf((*HostRdmaDevice)(nil)).Elem()
}

// This data object represents the physical
// backing of an RDMA device.
type HostRdmaDeviceBacking struct {
	DynamicData
}

func init() {
	t["HostRdmaDeviceBacking"] = reflect.TypeOf((*HostRdmaDeviceBacking)(nil)).Elem()
}

// Represents device capabilies, e.g.
//
// supported protocols.
type HostRdmaDeviceCapability struct {
	DynamicData

	// Indicates whether ROCEv1 is supported by the device.
	RoceV1Capable bool `xml:"roceV1Capable" json:"roceV1Capable"`
	// Indicates whether ROCEv2 is supported by the device.
	RoceV2Capable bool `xml:"roceV2Capable" json:"roceV2Capable"`
	// Indicates whether iWARP is supported by the device.
	IWarpCapable bool `xml:"iWarpCapable" json:"iWarpCapable"`
}

func init() {
	t["HostRdmaDeviceCapability"] = reflect.TypeOf((*HostRdmaDeviceCapability)(nil)).Elem()
}

// Represents connection information for the RDMA device.
type HostRdmaDeviceConnectionInfo struct {
	DynamicData

	// RDMA device connection state.
	//
	// The set of possible values
	// is described in `HostRdmaDeviceConnectionState_enum`.
	State string `xml:"state" json:"state"`
	// Maximum Transmission Unit in bytes.
	Mtu int32 `xml:"mtu" json:"mtu"`
	// Bit rate in Mbps.
	SpeedInMbps int32 `xml:"speedInMbps" json:"speedInMbps"`
}

func init() {
	t["HostRdmaDeviceConnectionInfo"] = reflect.TypeOf((*HostRdmaDeviceConnectionInfo)(nil)).Elem()
}

// This data object represents a physical NIC backing
// for an RDMA device.
//
// When an RDMA device is backed by a physical NIC, it
// can be associated with the virtual NICs
// connected to a virtual switch which has the
// backing physical NIC as an uplink. The actual bindings
// are created and destroyed dynamically based on application
// usage of the RDMA device.
type HostRdmaDevicePnicBacking struct {
	HostRdmaDeviceBacking

	// The associated physical NIC
	PairedUplink string `xml:"pairedUplink" json:"pairedUplink"`
}

func init() {
	t["HostRdmaDevicePnicBacking"] = reflect.TypeOf((*HostRdmaDevicePnicBacking)(nil)).Elem()
}

// This data object describes the Remote Direct Memory Access
// (RDMA) host bus adapter interface.
type HostRdmaHba struct {
	HostHostBusAdapter

	// Device name of the associated RDMA device, if any.
	//
	// Should match the `HostRdmaDevice.device` property
	// of the corresponding RDMA device.
	AssociatedRdmaDevice string `xml:"associatedRdmaDevice,omitempty" json:"associatedRdmaDevice,omitempty"`
}

func init() {
	t["HostRdmaHba"] = reflect.TypeOf((*HostRdmaHba)(nil)).Elem()
}

// Remote Direct Memory Access (RDMA) transport
// information about a target.
type HostRdmaTargetTransport struct {
	HostTargetTransport
}

func init() {
	t["HostRdmaTargetTransport"] = reflect.TypeOf((*HostRdmaTargetTransport)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostReconcileDatastoreInventory_Task`.
type HostReconcileDatastoreInventoryRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datastore that needs to be reconciled.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["HostReconcileDatastoreInventoryRequestType"] = reflect.TypeOf((*HostReconcileDatastoreInventoryRequestType)(nil)).Elem()
}

type HostReconcileDatastoreInventory_Task HostReconcileDatastoreInventoryRequestType

func init() {
	t["HostReconcileDatastoreInventory_Task"] = reflect.TypeOf((*HostReconcileDatastoreInventory_Task)(nil)).Elem()
}

type HostReconcileDatastoreInventory_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This event records a failed attempt to re-establish a host connection.
type HostReconnectionFailedEvent struct {
	HostEvent
}

func init() {
	t["HostReconnectionFailedEvent"] = reflect.TypeOf((*HostReconnectionFailedEvent)(nil)).Elem()
}

type HostRegisterDisk HostRegisterDiskRequestType

func init() {
	t["HostRegisterDisk"] = reflect.TypeOf((*HostRegisterDisk)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostRegisterDisk`.
type HostRegisterDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// URL or datastore path to the virtual disk.
	Path string `xml:"path" json:"path"`
	// The descriptive name of the disk object. If
	// unset the name will be automatically determined
	// from the path. @see vim.vslm.BaseConfigInfo#name
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// Optional Parameter describing if the control Flags should be changed to default values
	ModifyControlFlags *bool `xml:"modifyControlFlags" json:"modifyControlFlags,omitempty" vim:"8.0.2.0"`
}

func init() {
	t["HostRegisterDiskRequestType"] = reflect.TypeOf((*HostRegisterDiskRequestType)(nil)).Elem()
}

type HostRegisterDiskResponse struct {
	Returnval VStorageObject `xml:"returnval" json:"returnval"`
}

// Information about reliable memory installed on this host.
type HostReliableMemoryInfo struct {
	DynamicData

	MemorySize int64 `xml:"memorySize" json:"memorySize"`
}

func init() {
	t["HostReliableMemoryInfo"] = reflect.TypeOf((*HostReliableMemoryInfo)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostRelocateVStorageObject_Task`.
type HostRelocateVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage
	// object is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The specification for relocation of the virtual
	// storage object.
	Spec VslmRelocateSpec `xml:"spec" json:"spec"`
}

func init() {
	t["HostRelocateVStorageObjectRequestType"] = reflect.TypeOf((*HostRelocateVStorageObjectRequestType)(nil)).Elem()
}

type HostRelocateVStorageObject_Task HostRelocateVStorageObjectRequestType

func init() {
	t["HostRelocateVStorageObject_Task"] = reflect.TypeOf((*HostRelocateVStorageObject_Task)(nil)).Elem()
}

type HostRelocateVStorageObject_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type HostRemoveVFlashResource HostRemoveVFlashResourceRequestType

func init() {
	t["HostRemoveVFlashResource"] = reflect.TypeOf((*HostRemoveVFlashResource)(nil)).Elem()
}

type HostRemoveVFlashResourceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["HostRemoveVFlashResourceRequestType"] = reflect.TypeOf((*HostRemoveVFlashResourceRequestType)(nil)).Elem()
}

type HostRemoveVFlashResourceResponse struct {
}

// This event records the removal of a host from VirtualCenter.
type HostRemovedEvent struct {
	HostEvent
}

func init() {
	t["HostRemovedEvent"] = reflect.TypeOf((*HostRemovedEvent)(nil)).Elem()
}

type HostRenameVStorageObject HostRenameVStorageObjectRequestType

func init() {
	t["HostRenameVStorageObject"] = reflect.TypeOf((*HostRenameVStorageObject)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostRenameVStorageObject`.
type HostRenameVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object to be renamed.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual storage object is
	// located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The new name for the virtual storage object.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["HostRenameVStorageObjectRequestType"] = reflect.TypeOf((*HostRenameVStorageObjectRequestType)(nil)).Elem()
}

type HostRenameVStorageObjectResponse struct {
}

// The `HostResignatureRescanResult` data object
// identifies the newly created volume that is the result of a
// resignature operation.
//
// This data object is contained in the
// task object returned by the
// `HostDatastoreSystem.ResignatureUnresolvedVmfsVolume_Task`
// method.
//
// When a client calls the resignature method, the Server
// resignatures the volume, rescans the specified list of hosts,
// and auto-mounts the volume on the other hosts that share the same
// underlying storage LUNs.
type HostResignatureRescanResult struct {
	DynamicData

	// Deprecated as of vSphere API 5.1, the results of the operation
	// are available when the task completes. That is, for shared volumes,
	// the new volume is mounted on all of the connected hosts.
	//
	// List of VMFS Rescan operation results.
	Rescan []HostVmfsRescanResult `xml:"rescan,omitempty" json:"rescan,omitempty"`
	// When an UnresolvedVmfsVolume has been resignatured, we want to return the
	// newly created VMFS Datastore.
	//
	// Refers instance of `Datastore`.
	Result ManagedObjectReference `xml:"result" json:"result"`
}

func init() {
	t["HostResignatureRescanResult"] = reflect.TypeOf((*HostResignatureRescanResult)(nil)).Elem()
}

type HostRetrieveVStorageInfrastructureObjectPolicy HostRetrieveVStorageInfrastructureObjectPolicyRequestType

func init() {
	t["HostRetrieveVStorageInfrastructureObjectPolicy"] = reflect.TypeOf((*HostRetrieveVStorageInfrastructureObjectPolicy)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostRetrieveVStorageInfrastructureObjectPolicy`.
type HostRetrieveVStorageInfrastructureObjectPolicyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Datastore on which policy needs to be retrieved.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["HostRetrieveVStorageInfrastructureObjectPolicyRequestType"] = reflect.TypeOf((*HostRetrieveVStorageInfrastructureObjectPolicyRequestType)(nil)).Elem()
}

type HostRetrieveVStorageInfrastructureObjectPolicyResponse struct {
	Returnval []VslmInfrastructureObjectPolicy `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type HostRetrieveVStorageObject HostRetrieveVStorageObjectRequestType

func init() {
	t["HostRetrieveVStorageObject"] = reflect.TypeOf((*HostRetrieveVStorageObject)(nil)).Elem()
}

type HostRetrieveVStorageObjectMetadata HostRetrieveVStorageObjectMetadataRequestType

func init() {
	t["HostRetrieveVStorageObjectMetadata"] = reflect.TypeOf((*HostRetrieveVStorageObjectMetadata)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostRetrieveVStorageObjectMetadata`.
type HostRetrieveVStorageObjectMetadataRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore to query for the virtual storage objects.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The ID of the snapshot of virtual storage object.
	SnapshotId *ID `xml:"snapshotId,omitempty" json:"snapshotId,omitempty"`
	// The prefix of the metadata key that needs to be retrieved
	Prefix string `xml:"prefix,omitempty" json:"prefix,omitempty"`
}

func init() {
	t["HostRetrieveVStorageObjectMetadataRequestType"] = reflect.TypeOf((*HostRetrieveVStorageObjectMetadataRequestType)(nil)).Elem()
}

type HostRetrieveVStorageObjectMetadataResponse struct {
	Returnval []KeyValue `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type HostRetrieveVStorageObjectMetadataValue HostRetrieveVStorageObjectMetadataValueRequestType

func init() {
	t["HostRetrieveVStorageObjectMetadataValue"] = reflect.TypeOf((*HostRetrieveVStorageObjectMetadataValue)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostRetrieveVStorageObjectMetadataValue`.
type HostRetrieveVStorageObjectMetadataValueRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore to query for the virtual storage objects.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The ID of the snapshot of virtual storage object.
	SnapshotId *ID `xml:"snapshotId,omitempty" json:"snapshotId,omitempty"`
	// The key for the the virtual storage object
	Key string `xml:"key" json:"key"`
}

func init() {
	t["HostRetrieveVStorageObjectMetadataValueRequestType"] = reflect.TypeOf((*HostRetrieveVStorageObjectMetadataValueRequestType)(nil)).Elem()
}

type HostRetrieveVStorageObjectMetadataValueResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// The parameters of `HostVStorageObjectManager.HostRetrieveVStorageObject`.
type HostRetrieveVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object to be retrieved.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual storage object is
	// located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// Flags indicating the FCD information to be
	// retrieved. If diskInfoFlags is unset, then all FCD
	// information will be retrieved. See
	// `vslmDiskInfoFlag_enum` for the list of
	// supported values.
	DiskInfoFlags []string `xml:"diskInfoFlags,omitempty" json:"diskInfoFlags,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["HostRetrieveVStorageObjectRequestType"] = reflect.TypeOf((*HostRetrieveVStorageObjectRequestType)(nil)).Elem()
}

type HostRetrieveVStorageObjectResponse struct {
	Returnval VStorageObject `xml:"returnval" json:"returnval"`
}

type HostRetrieveVStorageObjectState HostRetrieveVStorageObjectStateRequestType

func init() {
	t["HostRetrieveVStorageObjectState"] = reflect.TypeOf((*HostRetrieveVStorageObjectState)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostRetrieveVStorageObjectState`.
type HostRetrieveVStorageObjectStateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object the state to be retrieved.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual storage object is
	// located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["HostRetrieveVStorageObjectStateRequestType"] = reflect.TypeOf((*HostRetrieveVStorageObjectStateRequestType)(nil)).Elem()
}

type HostRetrieveVStorageObjectStateResponse struct {
	Returnval VStorageObjectStateInfo `xml:"returnval" json:"returnval"`
}

// This data object type describes the runtime state of a host.
type HostRuntimeInfo struct {
	DynamicData

	// The host connection state.
	//
	// See the description in the enums for the
	// `ConnectionState` data object type.
	ConnectionState HostSystemConnectionState `xml:"connectionState" json:"connectionState"`
	// The host power state.
	//
	// See the description in the enums for the
	// `PowerState` data object type.
	PowerState HostSystemPowerState `xml:"powerState" json:"powerState"`
	// The host's standby mode.
	//
	// For valid values see
	// `HostStandbyMode_enum`. The property is only populated by
	// vCenter server. If queried directly from a ESX host, the property is
	// is unset.
	StandbyMode string `xml:"standbyMode,omitempty" json:"standbyMode,omitempty"`
	// The flag to indicate whether or not the host is in maintenance mode.
	//
	// This
	// flag is set when the host has entered the maintenance mode. It is not set
	// during the entering phase of maintenance mode.
	//
	// See also `HostSystem.EnterMaintenanceMode_Task`, `HostSystem.ExitMaintenanceMode_Task`.
	InMaintenanceMode bool `xml:"inMaintenanceMode" json:"inMaintenanceMode"`
	// The flag to indicate whether or not the host is in quarantine mode.
	//
	// InfraUpdateHa will recommend to set this flag based on the HealthUpdates
	// received by the HealthUpdateProviders configured for the cluster. A
	// host that is reported as degraded will be recommended to enter quarantine
	// mode, while a host that is reported as healthy will be recommended to
	// exit quarantine mode. Execution of these recommended actions will set
	// this flag. Hosts in quarantine mode will be avoided by vSphere DRS as
	// long as the increased consolidation in the cluster does not negatively
	// affect VM performance.
	//
	// See also `HealthUpdateManager`, `ClusterInfraUpdateHaConfigInfo`, `ClusterHostInfraUpdateHaModeAction`.
	InQuarantineMode *bool `xml:"inQuarantineMode" json:"inQuarantineMode,omitempty"`
	// The time when the host was booted.
	BootTime *time.Time `xml:"bootTime" json:"bootTime,omitempty"`
	// Available system health status
	HealthSystemRuntime *HealthSystemRuntime `xml:"healthSystemRuntime,omitempty" json:"healthSystemRuntime,omitempty"`
	// The availability state of an active host in a vSphere HA enabled
	// cluster.
	//
	// A host is inactive if it is in maintenance or standby mode, or
	// it has been disconnected from vCenter Server. The active hosts in a cluster
	// form a vSphere HA fault domain.
	//
	// The property is unset if vSphere HA is disabled, the host is
	// in maintenance or standby mode, or the host is disconnected from
	// vCenter Server. The property is set to hostDown if the host has crashed.
	DasHostState *ClusterDasFdmHostState `xml:"dasHostState,omitempty" json:"dasHostState,omitempty"`
	// Deprecated as of @released("5.1") this information should be
	// considered to be neither complete nor reliable.
	//
	// The array of PCR digest values stored in the TPM device since the last
	// host boot time.
	TpmPcrValues []HostTpmDigestInfo `xml:"tpmPcrValues,omitempty" json:"tpmPcrValues,omitempty"`
	// Host Runtime information related to the VSAN service.
	//
	// See also `VsanHostRuntimeInfo`.
	VsanRuntimeInfo *VsanHostRuntimeInfo `xml:"vsanRuntimeInfo,omitempty" json:"vsanRuntimeInfo,omitempty"`
	// This property is for getting network related runtime info
	NetworkRuntimeInfo *HostRuntimeInfoNetworkRuntimeInfo `xml:"networkRuntimeInfo,omitempty" json:"networkRuntimeInfo,omitempty"`
	// Runtime information of vFlash resource of the host.
	VFlashResourceRuntimeInfo *HostVFlashManagerVFlashResourceRunTimeInfo `xml:"vFlashResourceRuntimeInfo,omitempty" json:"vFlashResourceRuntimeInfo,omitempty"`
	// The maximum theoretical virtual disk capacity supported by this host
	HostMaxVirtualDiskCapacity int64 `xml:"hostMaxVirtualDiskCapacity,omitempty" json:"hostMaxVirtualDiskCapacity,omitempty"`
	// Encryption state of the host.
	//
	// Valid values are enumerated by the
	// `CryptoState` type.
	CryptoState string `xml:"cryptoState,omitempty" json:"cryptoState,omitempty"`
	// Crypto Key used for coredump encryption
	CryptoKeyId *CryptoKeyId `xml:"cryptoKeyId,omitempty" json:"cryptoKeyId,omitempty"`
	// Indicating the host is ready for NVDS to VDS migration.
	//
	// See `HostRuntimeInfoStatelessNvdsMigrationState_enum` for supported values.
	StatelessNvdsMigrationReady string `xml:"statelessNvdsMigrationReady,omitempty" json:"statelessNvdsMigrationReady,omitempty" vim:"7.0.2.0"`
	// The following list contains the runtime status for all the partial
	// maintenance modes currently supported on the host.
	PartialMaintenanceMode []HostPartialMaintenanceModeRuntimeInfo `xml:"partialMaintenanceMode,omitempty" json:"partialMaintenanceMode,omitempty" vim:"8.0.3.0"`
	// Host persistent state encryption information.
	StateEncryption *HostRuntimeInfoStateEncryptionInfo `xml:"stateEncryption,omitempty" json:"stateEncryption,omitempty" vim:"7.0.3.0"`
}

func init() {
	t["HostRuntimeInfo"] = reflect.TypeOf((*HostRuntimeInfo)(nil)).Elem()
}

// This data type describes network stack instance runtime info
type HostRuntimeInfoNetStackInstanceRuntimeInfo struct {
	DynamicData

	// Key of the instance
	NetStackInstanceKey string `xml:"netStackInstanceKey" json:"netStackInstanceKey"`
	// State of the instance
	// See `HostRuntimeInfoNetStackInstanceRuntimeInfoState_enum` for valid values.
	State string `xml:"state,omitempty" json:"state,omitempty"`
	// The keys of vmknics that are using this stack
	VmknicKeys []string `xml:"vmknicKeys,omitempty" json:"vmknicKeys,omitempty"`
	// The maximum number of socket connections can be worked on this
	// instance currently after booting up.
	MaxNumberOfConnections int32 `xml:"maxNumberOfConnections,omitempty" json:"maxNumberOfConnections,omitempty"`
	// If true then dual IPv4/IPv6 stack enabled else IPv4 only.
	CurrentIpV6Enabled *bool `xml:"currentIpV6Enabled" json:"currentIpV6Enabled,omitempty"`
}

func init() {
	t["HostRuntimeInfoNetStackInstanceRuntimeInfo"] = reflect.TypeOf((*HostRuntimeInfoNetStackInstanceRuntimeInfo)(nil)).Elem()
}

// This data type describes network related runtime info
type HostRuntimeInfoNetworkRuntimeInfo struct {
	DynamicData

	// The list of network stack runtime info
	NetStackInstanceRuntimeInfo []HostRuntimeInfoNetStackInstanceRuntimeInfo `xml:"netStackInstanceRuntimeInfo,omitempty" json:"netStackInstanceRuntimeInfo,omitempty"`
	// The network resource runtime information
	NetworkResourceRuntime *HostNetworkResourceRuntime `xml:"networkResourceRuntime,omitempty" json:"networkResourceRuntime,omitempty"`
}

func init() {
	t["HostRuntimeInfoNetworkRuntimeInfo"] = reflect.TypeOf((*HostRuntimeInfoNetworkRuntimeInfo)(nil)).Elem()
}

// This data type describes the host's persistent state encryption.
type HostRuntimeInfoStateEncryptionInfo struct {
	DynamicData

	// The state encryption key protection mode.
	//
	// The host state is encrypted with a key that is protected using
	// one of the modes specified by `HostRuntimeInfoStateEncryptionInfoProtectionMode_enum`.
	ProtectionMode string `xml:"protectionMode" json:"protectionMode"`
	// Indicates if UEFI Secure Boot must be enabled in order for the
	// state encryption key to be accessible.
	RequireSecureBoot *bool `xml:"requireSecureBoot" json:"requireSecureBoot,omitempty"`
	// Indicates if the "execInstalledOnly" enforcement must be active
	// for the state encryption key to be accessible.
	RequireExecInstalledOnly *bool `xml:"requireExecInstalledOnly" json:"requireExecInstalledOnly,omitempty"`
}

func init() {
	t["HostRuntimeInfoStateEncryptionInfo"] = reflect.TypeOf((*HostRuntimeInfoStateEncryptionInfo)(nil)).Elem()
	minAPIVersionForType["HostRuntimeInfoStateEncryptionInfo"] = "7.0.3.0"
}

type HostScheduleReconcileDatastoreInventory HostScheduleReconcileDatastoreInventoryRequestType

func init() {
	t["HostScheduleReconcileDatastoreInventory"] = reflect.TypeOf((*HostScheduleReconcileDatastoreInventory)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostScheduleReconcileDatastoreInventory`.
type HostScheduleReconcileDatastoreInventoryRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datastore that needs to be reconciled.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["HostScheduleReconcileDatastoreInventoryRequestType"] = reflect.TypeOf((*HostScheduleReconcileDatastoreInventoryRequestType)(nil)).Elem()
}

type HostScheduleReconcileDatastoreInventoryResponse struct {
}

// This data object type describes a SCSI disk.
//
// A SCSI disk contains a
// partition table which can be changed.
// To change a SCSI disk, use the device name and the partition specification.
//
// See also `HostStorageSystem.RetrieveDiskPartitionInfo`, `HostStorageSystem.UpdateDiskPartitions`.
type HostScsiDisk struct {
	ScsiLun

	// The size of SCSI disk using the Logical Block Addressing scheme.
	Capacity HostDiskDimensionsLba `xml:"capacity" json:"capacity"`
	// The device path of the ScsiDisk.
	//
	// This device path is a file path
	// that can be opened to create partitions on the disk.
	//
	// See also `HostStorageSystem.RetrieveDiskPartitionInfo`, `HostStorageSystem.UpdateDiskPartitions`.
	DevicePath string `xml:"devicePath" json:"devicePath"`
	// Indicates whether the ScsiDisk is SSD backed.
	//
	// If unset, the information whether the ScsiDisk is SSD backed
	// is unknown.
	Ssd *bool `xml:"ssd" json:"ssd,omitempty"`
	// Indicates whether the ScsiDisk is local.
	//
	// If unset, the information whether the ScsiDisk is local is unknown.
	LocalDisk *bool `xml:"localDisk" json:"localDisk,omitempty"`
	// The physical location of the ScsiDisk if can be determined, otherwise
	// unset.
	//
	// If the ScsiDisk is a logical drive, it should be the
	// location of all constituent physical drives of the logical drive.
	// If the ScsiDisk is a physical drive, it's an array of one element.
	PhysicalLocation []string `xml:"physicalLocation,omitempty" json:"physicalLocation,omitempty"`
	// Indicates whether the ScsiDisk has emulated Data Integrity Extension
	// (DIX) / Data Integrity Field (DIF) enabled.
	//
	// If unset, the default value is false.
	EmulatedDIXDIFEnabled *bool `xml:"emulatedDIXDIFEnabled" json:"emulatedDIXDIFEnabled,omitempty"`
	// Indicates the additional VSAN information
	// if this disk is used by VSAN.
	VsanDiskInfo *VsanHostVsanDiskInfo `xml:"vsanDiskInfo,omitempty" json:"vsanDiskInfo,omitempty"`
	// The type of disk drives.
	//
	// See `ScsiDiskType_enum`
	// for definitions of supported types.
	ScsiDiskType string `xml:"scsiDiskType,omitempty" json:"scsiDiskType,omitempty"`
	// Indicate whether the disk is used for
	// memory tiering or not.
	//
	// If unset, the default value is false.
	UsedByMemoryTiering *bool `xml:"usedByMemoryTiering" json:"usedByMemoryTiering,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["HostScsiDisk"] = reflect.TypeOf((*HostScsiDisk)(nil)).Elem()
}

// This data object type describes the specification of a Disk partition.
type HostScsiDiskPartition struct {
	DynamicData

	// The SCSI disk device on which a VMware File System (VMFS)
	// extent resides.
	//
	// See also `HostScsiDisk`, `ScsiLun.canonicalName`.
	DiskName string `xml:"diskName" json:"diskName"`
	// The partition number of the partition on the ScsiDisk.
	Partition int32 `xml:"partition" json:"partition"`
}

func init() {
	t["HostScsiDiskPartition"] = reflect.TypeOf((*HostScsiDiskPartition)(nil)).Elem()
}

// This data object type describes the SCSI topology information.
//
// The
// data objects in this data object type model the
// SCSI storage objects from a topological point of view. The SCSI topological
// view organizes objects by SCSI interface, which contain targets, which in
// turn contain logical units.
//
// SCSI Topology information is not guaranteed to exhaustively enumerate all
// storage devices on the system. It only shows storage devices that are
// actually enumerable from a host bus adapter. This means that only storage
// devices that are composed from one or more paths, which are in turn provided
// by a host bus adapter, will appear in this inventory.
//
// Storage devices provided by the native multipathing plugin (NMP) will always
// be represented in this inventory since NMP uses a simple policy to create
// devices out of the paths it claims.
//
// Examples of storage devices that will not appear in this inventory are
// logical devices that are not formed from directly claiming paths. Specific
// examples of devices that will not appear in this inventory include a device
// backed by a ramdisk or formed from a software RAID plugin.
//
// Legacy note: In hosts where `HostPlugStoreTopology` is not
// defined or does not exist on the `HostStorageDeviceInfo` object,
// only native multipathing exists. That means for these hosts, the
// ScsiTopology object contains the complete set of LUNs and targets
// available on the host.
type HostScsiTopology struct {
	DynamicData

	// The list of SCSI interfaces.
	Adapter []HostScsiTopologyInterface `xml:"adapter,omitempty" json:"adapter,omitempty"`
}

func init() {
	t["HostScsiTopology"] = reflect.TypeOf((*HostScsiTopology)(nil)).Elem()
}

// This data object type describes the SCSI interface that is associated
// with a list of targets.
type HostScsiTopologyInterface struct {
	DynamicData

	// The identifier for the SCSI interface
	Key string `xml:"key" json:"key"`
	// The link to data for this SCSI interface.
	Adapter string `xml:"adapter" json:"adapter"`
	// The list of targets to which the SCSI interface is associated.
	Target []HostScsiTopologyTarget `xml:"target,omitempty" json:"target,omitempty"`
}

func init() {
	t["HostScsiTopologyInterface"] = reflect.TypeOf((*HostScsiTopologyInterface)(nil)).Elem()
}

// This data object type describes the SCSI logical unit.
type HostScsiTopologyLun struct {
	DynamicData

	// The identifier for the SCSI Lun
	Key string `xml:"key" json:"key"`
	// The logical unit number of the SCSI logical unit.
	Lun int32 `xml:"lun" json:"lun"`
	// The link to data for this SCSI logical unit.
	ScsiLun string `xml:"scsiLun" json:"scsiLun"`
}

func init() {
	t["HostScsiTopologyLun"] = reflect.TypeOf((*HostScsiTopologyLun)(nil)).Elem()
}

// This data object type describes the SCSI target that is associated
// with a list of logical units.
type HostScsiTopologyTarget struct {
	DynamicData

	// The identifier for the SCSI target
	Key string `xml:"key" json:"key"`
	// The target identifier.
	Target int32 `xml:"target" json:"target"`
	// The list of SCSI logical units with which a target is associated.
	Lun []HostScsiTopologyLun `xml:"lun,omitempty" json:"lun,omitempty"`
	// SCSI Transport information about the target.
	Transport BaseHostTargetTransport `xml:"transport,omitempty,typeattr" json:"transport,omitempty"`
}

func init() {
	t["HostScsiTopologyTarget"] = reflect.TypeOf((*HostScsiTopologyTarget)(nil)).Elem()
}

// DataObject used for configuring the Security settings
type HostSecuritySpec struct {
	DynamicData

	// Administrator password to configure
	AdminPassword string `xml:"adminPassword,omitempty" json:"adminPassword,omitempty"`
	// Permissions to remove
	RemovePermission []Permission `xml:"removePermission,omitempty" json:"removePermission,omitempty"`
	// Permissions to add
	AddPermission []Permission `xml:"addPermission,omitempty" json:"addPermission,omitempty"`
}

func init() {
	t["HostSecuritySpec"] = reflect.TypeOf((*HostSecuritySpec)(nil)).Elem()
}

// The data object type describes the
// Serial Attached Scsi(SAS) interface.
type HostSerialAttachedHba struct {
	HostHostBusAdapter

	// The world wide node name for the adapter.
	NodeWorldWideName string `xml:"nodeWorldWideName" json:"nodeWorldWideName"`
}

func init() {
	t["HostSerialAttachedHba"] = reflect.TypeOf((*HostSerialAttachedHba)(nil)).Elem()
}

// Serial attached adapter transport information about a SCSI target.
type HostSerialAttachedTargetTransport struct {
	HostTargetTransport
}

func init() {
	t["HostSerialAttachedTargetTransport"] = reflect.TypeOf((*HostSerialAttachedTargetTransport)(nil)).Elem()
}

// Data object that describes a single service that runs on the host.
type HostService struct {
	DynamicData

	// Brief identifier for the service.
	Key string `xml:"key" json:"key"`
	// Display label for the service.
	Label string `xml:"label" json:"label"`
	// Flag indicating whether the service is required and cannot be disabled.
	Required bool `xml:"required" json:"required"`
	// Deprecated this flag is unimplemented and will always be set to false.
	//
	// Flag indicating whether the service can be uninstalled.
	Uninstallable bool `xml:"uninstallable" json:"uninstallable"`
	// Flag indicating whether the service is currently running.
	Running bool `xml:"running" json:"running"`
	// List of firewall rulesets used by this service.
	//
	// Must come from the
	// list of rulesets in `HostFirewallInfo.ruleset`.
	Ruleset []string `xml:"ruleset,omitempty" json:"ruleset,omitempty"`
	// Service activation policy.
	//
	// See also `HostServicePolicy_enum`.
	Policy string `xml:"policy" json:"policy"`
	// The source package associated with the service
	SourcePackage *HostServiceSourcePackage `xml:"sourcePackage,omitempty" json:"sourcePackage,omitempty"`
}

func init() {
	t["HostService"] = reflect.TypeOf((*HostService)(nil)).Elem()
}

// DataObject representing configuration for a particular
// service.
type HostServiceConfig struct {
	DynamicData

	// Key of the service to configure.
	ServiceId string `xml:"serviceId" json:"serviceId"`
	// Startup policy which defines how the service be configured.
	//
	// See @link Service.Policy for possible values.
	StartupPolicy string `xml:"startupPolicy" json:"startupPolicy"`
}

func init() {
	t["HostServiceConfig"] = reflect.TypeOf((*HostServiceConfig)(nil)).Elem()
}

// Data object describing the host service configuration.
type HostServiceInfo struct {
	DynamicData

	// List of configured services.
	Service []HostService `xml:"service,omitempty" json:"service,omitempty"`
}

func init() {
	t["HostServiceInfo"] = reflect.TypeOf((*HostServiceInfo)(nil)).Elem()
}

type HostServiceSourcePackage struct {
	DynamicData

	// The name of the source package
	SourcePackageName string `xml:"sourcePackageName" json:"sourcePackageName"`
	// The description of the source package
	Description string `xml:"description" json:"description"`
}

func init() {
	t["HostServiceSourcePackage"] = reflect.TypeOf((*HostServiceSourcePackage)(nil)).Elem()
}

// Return value for ticketable host services.
//
// The server has the option to
// provide a hostname and port for a future ticket-authenticated connection to
// a service on a host. If the service provider does not return a host the
// client must connect to the same host it used to request the ticket. In case
// the service provider does not return a port, except in the case of connecting
// to CIM interfaces, the client must connect using the same port it used to
// request the ticket. In the case of connecting to a CIM interface the
// standard well known port number for the particular service will be used for
// the connection.
//
// For example, when a client requests a ticket from an ESX Server, the returned ticket
// may omit the optional host and port. In such a case, the client establishes an
// out-of-band ticketed connection to the same server host and on the same port on
// which it made the connection to request the ticket. If this request is
// made to the VirtualCenter server, but the server does not provide the required
// service directly, then the server provides a hostname and port for a server that
// accepts the ticketed connection and provides the service.
type HostServiceTicket struct {
	DynamicData

	// The name of the host providing the service for which the ticket applies.
	//
	// If
	// omitted, then the client uses the host name for the server that issued the ticket.
	Host string `xml:"host,omitempty" json:"host,omitempty"`
	// Access to some services is made possible by connecting to a port on a
	// server.
	//
	// If the service for which a ticket is issued is available on a
	// particular port, that port number is specified with this property. If
	// omitted, except in the case of connecting to CIM interfaces, the port
	// number for the service that issued the ticket is used. In the case of
	// connecting to a CIM interface the standard well known port for the
	// particular service will be used for the connection.
	Port int32 `xml:"port,omitempty" json:"port,omitempty"`
	// The expected thumbprint of the SSL cert of the host to which
	// we are connecting.
	SslThumbprint string `xml:"sslThumbprint,omitempty" json:"sslThumbprint,omitempty"`
	// The name of the service to which to connect.
	Service string `xml:"service" json:"service"`
	// A dot-separated string identifying the service protocol version.
	//
	// For example, 1.0
	// is used for NFC hosted by vpxa on ESX 2.5, and 1.1 is used for
	// NFC hosted by hostd on ESX 3.0.
	ServiceVersion string `xml:"serviceVersion" json:"serviceVersion"`
	// An identifying string for the session created for the ticketed connection.
	//
	// This
	// is used by the host service to identify the operations permitted within the
	// session.
	SessionId string `xml:"sessionId" json:"sessionId"`
}

func init() {
	t["HostServiceTicket"] = reflect.TypeOf((*HostServiceTicket)(nil)).Elem()
}

type HostSetVStorageObjectControlFlags HostSetVStorageObjectControlFlagsRequestType

func init() {
	t["HostSetVStorageObjectControlFlags"] = reflect.TypeOf((*HostSetVStorageObjectControlFlags)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostSetVStorageObjectControlFlags`.
type HostSetVStorageObjectControlFlagsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage
	// object is located.
	//
	// Required privileges: Datastore.FileManagement
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// control flags enum array to be set on the
	// VStorageObject. All control flags not included
	// in the array remain intact.
	ControlFlags []string `xml:"controlFlags,omitempty" json:"controlFlags,omitempty"`
}

func init() {
	t["HostSetVStorageObjectControlFlagsRequestType"] = reflect.TypeOf((*HostSetVStorageObjectControlFlagsRequestType)(nil)).Elem()
}

type HostSetVStorageObjectControlFlagsResponse struct {
}

// The parameters of `HostVStorageObjectManager.HostSetVirtualDiskUuid_Task`.
type HostSetVirtualDiskUuidRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk whose uuid for the DDB entry needs to be set.
	// A URL has the form
	// > _scheme_://_authority_/folder/_path_?dsName=_dsName_
	//
	// where
	//   - _scheme_ is <code>http</code> or <code>https</code>.
	//   - _authority_ specifies the hostname or IP address of the VirtualCenter or
	//     ESX server and optionally the port.
	//   - _dsName_ is the name of the Datastore.
	//   - _path_ is a slash-delimited path from the root of the datastore.
	//
	// A datastore path has the form
	// > \[_datastore_\] _path_
	//
	// where
	//   - _datastore_ is the datastore name.
	//   - _path_ is a slash-delimited path from the root of the datastore.
	//
	// An example datastore path is "\[storage\] path/to/file.extension".
	Name string `xml:"name" json:"name"`
	// The hex representation of the unique ID for this virtual disk. If uuid is not set or missing,
	// a random UUID is generated and assigned.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
}

func init() {
	t["HostSetVirtualDiskUuidRequestType"] = reflect.TypeOf((*HostSetVirtualDiskUuidRequestType)(nil)).Elem()
	minAPIVersionForType["HostSetVirtualDiskUuidRequestType"] = "8.0.3.0"
}

type HostSetVirtualDiskUuid_Task HostSetVirtualDiskUuidRequestType

func init() {
	t["HostSetVirtualDiskUuid_Task"] = reflect.TypeOf((*HostSetVirtualDiskUuid_Task)(nil)).Elem()
}

type HostSetVirtualDiskUuid_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type HostSevInfo struct {
	DynamicData

	// State of SEV on the host.
	//
	// The set of supported values are described
	// in `HostSevInfoSevState_enum`.
	SevState string `xml:"sevState" json:"sevState"`
	// The maximum number of SEV-ES and SEV-SNP guests supported on this host.
	MaxSevEsGuests int64 `xml:"maxSevEsGuests" json:"maxSevEsGuests"`
}

func init() {
	t["HostSevInfo"] = reflect.TypeOf((*HostSevInfo)(nil)).Elem()
	minAPIVersionForType["HostSevInfo"] = "7.0.1.0"
}

// Data object describing the Software Guard Extension (SGX)
// configuration on the ESXi host.
type HostSgxInfo struct {
	DynamicData

	// SGX state of the host.
	//
	// The set of supported values are described
	// in `HostSgxInfoSgxStates_enum`.
	SgxState string `xml:"sgxState" json:"sgxState"`
	// Size of physical EPC in bytes.
	TotalEpcMemory int64 `xml:"totalEpcMemory" json:"totalEpcMemory"`
	// FLC mode of the host.
	//
	// The set of supported values are
	// described in `HostSgxInfoFlcModes_enum`.
	FlcMode string `xml:"flcMode" json:"flcMode"`
	// Public key hash of the provider launch enclave.
	//
	// This is the SHA256
	// digest of the SIGSTRUCT.MODULUS(MR\_SIGNER) of the provider launch
	// enclave. This attribute is set only if attribute flcMode is
	// locked.
	LePubKeyHash     string                   `xml:"lePubKeyHash,omitempty" json:"lePubKeyHash,omitempty"`
	RegistrationInfo *HostSgxRegistrationInfo `xml:"registrationInfo,omitempty" json:"registrationInfo,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["HostSgxInfo"] = reflect.TypeOf((*HostSgxInfo)(nil)).Elem()
}

// Data object describing SGX host registration information.
type HostSgxRegistrationInfo struct {
	DynamicData

	// SGX host registration status.
	//
	// Valid values come from `HostSgxRegistrationInfoRegistrationStatus_enum` enum.
	// Set, except in case of an internal error.
	Status string `xml:"status,omitempty" json:"status,omitempty"`
	// BIOS error related to SGX host registration.
	//
	// Set only if SGX registration status is incomplete.
	BiosError int32 `xml:"biosError,omitempty" json:"biosError,omitempty"`
	// SGX host registration URL.
	//
	// Unset if SGX registration status is not applicable
	// or in case of an internal error.
	RegistrationUrl string `xml:"registrationUrl,omitempty" json:"registrationUrl,omitempty"`
	// SGX host registration type.
	//
	// Valid values come from `HostSgxRegistrationInfoRegistrationType_enum` enum.
	// Unset if SGX registration status is not applicable,
	// complete, or in case of an internal error.
	Type string `xml:"type,omitempty" json:"type,omitempty"`
	// Platform Provisioning ID (PPID).
	//
	// Hex-encoded representation of the the PPID
	// (Platform Provisioning ID), returned as the response
	// to a successful registration request. This field
	// is populated only on the vCenter through which
	// the host has been registered.
	Ppid string `xml:"ppid,omitempty" json:"ppid,omitempty"`
	// Timestamp of last successful registration
	// from this vCenter.
	LastRegisteredTime *time.Time `xml:"lastRegisteredTime" json:"lastRegisteredTime,omitempty"`
}

func init() {
	t["HostSgxRegistrationInfo"] = reflect.TypeOf((*HostSgxRegistrationInfo)(nil)).Elem()
	minAPIVersionForType["HostSgxRegistrationInfo"] = "8.0.0.1"
}

// Capability vector indicating the available shared graphics features.
type HostSharedGpuCapabilities struct {
	DynamicData

	// Name of a particular VGPU available as a shared GPU device.
	//
	// See also `VirtualMachinePciSharedGpuPassthroughInfo`.
	Vgpu string `xml:"vgpu" json:"vgpu"`
	// Indicates whether the GPU plugin on this host is capable of
	// disk-only snapshots when VM is not powered off.
	//
	// Disk Snaphosts
	// on powered off VM are always supported.
	DiskSnapshotSupported bool `xml:"diskSnapshotSupported" json:"diskSnapshotSupported"`
	// Indicates whether the GPU plugin on this host is capable of
	// memory snapshots.
	MemorySnapshotSupported bool `xml:"memorySnapshotSupported" json:"memorySnapshotSupported"`
	// Indicates whether the GPU plugin on this host is capable of
	// suspend-resume.
	SuspendSupported bool `xml:"suspendSupported" json:"suspendSupported"`
	// Indicates whether the GPU plugin on this host is capable of
	// migration.
	MigrateSupported bool `xml:"migrateSupported" json:"migrateSupported"`
}

func init() {
	t["HostSharedGpuCapabilities"] = reflect.TypeOf((*HostSharedGpuCapabilities)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, the event is no longer relevant.
//
// This event records that host name resolution returned different names on
// the host.
//
// Please check your host's network configuration and your DNS
// configuration. There may be duplicate entries.
type HostShortNameInconsistentEvent struct {
	HostDasEvent

	ShortName  string `xml:"shortName" json:"shortName"`
	ShortName2 string `xml:"shortName2" json:"shortName2"`
}

func init() {
	t["HostShortNameInconsistentEvent"] = reflect.TypeOf((*HostShortNameInconsistentEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, the event is no longer relevant.
//
// This event records that the host's short name could not be resolved to an IP address.
type HostShortNameToIpFailedEvent struct {
	HostEvent

	ShortName string `xml:"shortName" json:"shortName"`
}

func init() {
	t["HostShortNameToIpFailedEvent"] = reflect.TypeOf((*HostShortNameToIpFailedEvent)(nil)).Elem()
}

// This event records the shutdown of a host.
type HostShutdownEvent struct {
	HostEvent

	// The reason for the host shutdown.
	Reason string `xml:"reason" json:"reason"`
}

func init() {
	t["HostShutdownEvent"] = reflect.TypeOf((*HostShutdownEvent)(nil)).Elem()
}

type HostSnmpConfigSpec struct {
	DynamicData

	Enabled             *bool                 `xml:"enabled" json:"enabled,omitempty"`
	Port                int32                 `xml:"port,omitempty" json:"port,omitempty"`
	ReadOnlyCommunities []string              `xml:"readOnlyCommunities,omitempty" json:"readOnlyCommunities,omitempty"`
	TrapTargets         []HostSnmpDestination `xml:"trapTargets,omitempty" json:"trapTargets,omitempty"`
	Option              []KeyValue            `xml:"option,omitempty" json:"option,omitempty"`
}

func init() {
	t["HostSnmpConfigSpec"] = reflect.TypeOf((*HostSnmpConfigSpec)(nil)).Elem()
}

// Defines a receiver for SNMP Notifications
type HostSnmpDestination struct {
	DynamicData

	// A system listening for SNMP notifications.
	//
	// These must be a IPv4 unicast address or resolvable dns name.
	HostName string `xml:"hostName" json:"hostName"`
	// UDP port to Notification receiver is listening on.
	//
	// udp/162 is
	// the reserved port
	Port      int32  `xml:"port" json:"port"`
	Community string `xml:"community" json:"community"`
}

func init() {
	t["HostSnmpDestination"] = reflect.TypeOf((*HostSnmpDestination)(nil)).Elem()
}

type HostSnmpSystemAgentLimits struct {
	DynamicData

	// number of allowed communities
	MaxReadOnlyCommunities int32 `xml:"maxReadOnlyCommunities" json:"maxReadOnlyCommunities"`
	// number of allowed destinations for notifications
	MaxTrapDestinations int32 `xml:"maxTrapDestinations" json:"maxTrapDestinations"`
	// Max length of community
	MaxCommunityLength int32 `xml:"maxCommunityLength" json:"maxCommunityLength"`
	// SNMP input buffer size
	MaxBufferSize int32 `xml:"maxBufferSize" json:"maxBufferSize"`
	// Supported Capability for this agent
	Capability HostSnmpAgentCapability `xml:"capability,omitempty" json:"capability,omitempty"`
}

func init() {
	t["HostSnmpSystemAgentLimits"] = reflect.TypeOf((*HostSnmpSystemAgentLimits)(nil)).Elem()
}

type HostSpecGetUpdatedHosts HostSpecGetUpdatedHostsRequestType

func init() {
	t["HostSpecGetUpdatedHosts"] = reflect.TypeOf((*HostSpecGetUpdatedHosts)(nil)).Elem()
}

// The parameters of `HostSpecificationManager.HostSpecGetUpdatedHosts`.
type HostSpecGetUpdatedHostsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The beginning of the time period.
	StartChangeID string `xml:"startChangeID,omitempty" json:"startChangeID,omitempty"`
	// The ending of the time period.
	EndChangeID string `xml:"endChangeID,omitempty" json:"endChangeID,omitempty"`
}

func init() {
	t["HostSpecGetUpdatedHostsRequestType"] = reflect.TypeOf((*HostSpecGetUpdatedHostsRequestType)(nil)).Elem()
}

type HostSpecGetUpdatedHostsResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The host specification data are those needed at host boot time to create and
// configure virtual devices and host services.
//
// The `HostSpecification` data object contains a collection of host sub
// specification data.
// For host sub specification data, see
// `HostSubSpecification`
// for details.
type HostSpecification struct {
	DynamicData

	// Time at which the host specification was created.
	CreatedTime time.Time `xml:"createdTime" json:"createdTime"`
	// Time at which the host specification was last modified.
	//
	// If it isn't set,
	// it is the same as <code>createdTime</code>.
	LastModified *time.Time `xml:"lastModified" json:"lastModified,omitempty"`
	// The host that the spec data belongs to.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The collection of the host sub specifications.
	//
	// It is optional.
	SubSpecs []HostSubSpecification `xml:"subSpecs,omitempty" json:"subSpecs,omitempty"`
	// The change ID for querying the host specification data updated in a
	// time period.
	//
	// It has a format of timestamp:change\_number, where
	// timestamp is the decimal string of a start time, and change\_number is
	// the decimal string of an auto incremented variable counting from the
	// start time.
	ChangeID string `xml:"changeID,omitempty" json:"changeID,omitempty"`
}

func init() {
	t["HostSpecification"] = reflect.TypeOf((*HostSpecification)(nil)).Elem()
}

// This event records that the host specification was changed.
type HostSpecificationChangedEvent struct {
	HostEvent
}

func init() {
	t["HostSpecificationChangedEvent"] = reflect.TypeOf((*HostSpecificationChangedEvent)(nil)).Elem()
}

// Fault thrown when an operation, on host specification or host sub
// specification for a host, failed.
type HostSpecificationOperationFailed struct {
	VimFault

	// The host on which host specification operation failed.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["HostSpecificationOperationFailed"] = reflect.TypeOf((*HostSpecificationOperationFailed)(nil)).Elem()
}

type HostSpecificationOperationFailedFault HostSpecificationOperationFailed

func init() {
	t["HostSpecificationOperationFailedFault"] = reflect.TypeOf((*HostSpecificationOperationFailedFault)(nil)).Elem()
}

// This event is issued to that the host specification should be updated.
type HostSpecificationRequireEvent struct {
	HostEvent
}

func init() {
	t["HostSpecificationRequireEvent"] = reflect.TypeOf((*HostSpecificationRequireEvent)(nil)).Elem()
}

// This event suggests that update the host specification with the
// encapsulated copy.
type HostSpecificationUpdateEvent struct {
	HostEvent

	HostSpec HostSpecification `xml:"hostSpec" json:"hostSpec"`
}

func init() {
	t["HostSpecificationUpdateEvent"] = reflect.TypeOf((*HostSpecificationUpdateEvent)(nil)).Elem()
}

// This data object allows configuration of SR-IOV device.
type HostSriovConfig struct {
	HostPciPassthruConfig

	// enable SR-IOV for this device
	SriovEnabled bool `xml:"sriovEnabled" json:"sriovEnabled"`
	// Number of SR-IOV virtual functions to enable on this device
	NumVirtualFunction int32 `xml:"numVirtualFunction" json:"numVirtualFunction"`
}

func init() {
	t["HostSriovConfig"] = reflect.TypeOf((*HostSriovConfig)(nil)).Elem()
}

type HostSriovDevicePoolInfo struct {
	DynamicData

	Key string `xml:"key" json:"key"`
}

func init() {
	t["HostSriovDevicePoolInfo"] = reflect.TypeOf((*HostSriovDevicePoolInfo)(nil)).Elem()
}

// This data object provides information about the state of SR-IOV device.
type HostSriovInfo struct {
	HostPciPassthruInfo

	// Whether SRIOV has been enabled by the user
	SriovEnabled bool `xml:"sriovEnabled" json:"sriovEnabled"`
	// Whether SRIOV is possible for this device
	SriovCapable bool `xml:"sriovCapable" json:"sriovCapable"`
	// Whether SRIOV is active for this device (meaning enabled + rebooted)
	SriovActive bool `xml:"sriovActive" json:"sriovActive"`
	// Number of SRIOV virtual functions requested for this device
	NumVirtualFunctionRequested int32 `xml:"numVirtualFunctionRequested" json:"numVirtualFunctionRequested"`
	// Number of SRIOV virtual functions present on this device
	NumVirtualFunction int32 `xml:"numVirtualFunction" json:"numVirtualFunction"`
	// Maximum number of SRIOV virtual functions supported on this device
	MaxVirtualFunctionSupported int32 `xml:"maxVirtualFunctionSupported" json:"maxVirtualFunctionSupported"`
}

func init() {
	t["HostSriovInfo"] = reflect.TypeOf((*HostSriovInfo)(nil)).Elem()
}

// Information on networking specific SR-IOV device pools
type HostSriovNetworkDevicePoolInfo struct {
	HostSriovDevicePoolInfo

	// vSwitch key
	SwitchKey string `xml:"switchKey,omitempty" json:"switchKey,omitempty"`
	// DVS Uuid
	SwitchUuid string `xml:"switchUuid,omitempty" json:"switchUuid,omitempty"`
	// List of SR-IOV enabled physical nics that are backing the portgroup
	// identified by above key
	Pnic []PhysicalNic `xml:"pnic,omitempty" json:"pnic,omitempty"`
}

func init() {
	t["HostSriovNetworkDevicePoolInfo"] = reflect.TypeOf((*HostSriovNetworkDevicePoolInfo)(nil)).Elem()
}

// The SSL thumbprint information for a host managed by a vCenter Server
// or a vCenter extension to login into other hosts without
// username/password authentication.
type HostSslThumbprintInfo struct {
	DynamicData

	// The principal used for the login session
	Principal string `xml:"principal" json:"principal"`
	// The tag associated with this registration.
	//
	// Owner tags allow
	// multiple entities to register the same thumbprint without
	// interfering with each other on the life cycle of the thumbprint with
	// their unique tags.
	// Each solution should use a unique tag to identify itself.
	OwnerTag string `xml:"ownerTag,omitempty" json:"ownerTag,omitempty"`
	// Specify the SSL thumbprints to register on the host.
	SslThumbprints []string `xml:"sslThumbprints,omitempty" json:"sslThumbprints,omitempty"`
}

func init() {
	t["HostSslThumbprintInfo"] = reflect.TypeOf((*HostSslThumbprintInfo)(nil)).Elem()
}

// This event records when a host's overall status changed.
type HostStatusChangedEvent struct {
	ClusterStatusChangedEvent
}

func init() {
	t["HostStatusChangedEvent"] = reflect.TypeOf((*HostStatusChangedEvent)(nil)).Elem()
}

// Description of options associated with a native multipathing
// storage array type plugin.
type HostStorageArrayTypePolicyOption struct {
	DynamicData

	// Description of the paths selection policy.
	//
	// Use the key as the
	// identifier.
	Policy BaseElementDescription `xml:"policy,typeattr" json:"policy"`
}

func init() {
	t["HostStorageArrayTypePolicyOption"] = reflect.TypeOf((*HostStorageArrayTypePolicyOption)(nil)).Elem()
}

// This data object type describes the storage subsystem configuration.
type HostStorageDeviceInfo struct {
	DynamicData

	// The list of host bus adapters available on the host.
	HostBusAdapter []BaseHostHostBusAdapter `xml:"hostBusAdapter,omitempty,typeattr" json:"hostBusAdapter,omitempty"`
	// The list of SCSI logical units available on the host.
	ScsiLun []BaseScsiLun `xml:"scsiLun,omitempty,typeattr" json:"scsiLun,omitempty"`
	// Storage topology view of SCSI storage devices.
	//
	// This data object
	// exists only if storage topology information is available. See the
	// `ScsiTopology` data object type for
	// more information.
	ScsiTopology *HostScsiTopology `xml:"scsiTopology,omitempty" json:"scsiTopology,omitempty"`
	// Topology view of NVME storage devices.
	//
	// This data object exists
	// only if storage topology information is available. See the
	// `HostNvmeTopology` data object type for more information.
	NvmeTopology *HostNvmeTopology `xml:"nvmeTopology,omitempty" json:"nvmeTopology,omitempty"`
	// The multipath configuration that controls multipath policy for ScsiLuns.
	//
	// This data object exists only if path information is available and is
	// configurable.
	MultipathInfo *HostMultipathInfo `xml:"multipathInfo,omitempty" json:"multipathInfo,omitempty"`
	// The plug-store topology on the host system.
	//
	// This data object exists only if
	// the plug-store system is available and configurable.
	PlugStoreTopology *HostPlugStoreTopology `xml:"plugStoreTopology,omitempty" json:"plugStoreTopology,omitempty"`
	// Indicates if the software iSCSI initiator is enabled on this system
	SoftwareInternetScsiEnabled bool `xml:"softwareInternetScsiEnabled" json:"softwareInternetScsiEnabled"`
}

func init() {
	t["HostStorageDeviceInfo"] = reflect.TypeOf((*HostStorageDeviceInfo)(nil)).Elem()
}

// Data object describing the operational status of various storage
// elements.
type HostStorageElementInfo struct {
	HostHardwareElementInfo

	// Other information regarding the operational state of the
	// storage element.
	OperationalInfo []HostStorageOperationalInfo `xml:"operationalInfo,omitempty" json:"operationalInfo,omitempty"`
}

func init() {
	t["HostStorageElementInfo"] = reflect.TypeOf((*HostStorageElementInfo)(nil)).Elem()
}

// Data class describing operational information of a storage element
type HostStorageOperationalInfo struct {
	DynamicData

	// The property of interest for the storage element
	Property string `xml:"property" json:"property"`
	// The property value for the storage element
	Value string `xml:"value" json:"value"`
}

func init() {
	t["HostStorageOperationalInfo"] = reflect.TypeOf((*HostStorageOperationalInfo)(nil)).Elem()
}

// Contains the result of turn Disk Locator Led On/Off request.
//
// Used as return value
// by `HostStorageSystem.TurnDiskLocatorLedOn_Task` and
// `HostStorageSystem.TurnDiskLocatorLedOff_Task`.
type HostStorageSystemDiskLocatorLedResult struct {
	DynamicData

	// UUID of LUN that has failed to turn on/off disk locator LED.
	Key string `xml:"key" json:"key"`
	// The reason why the operation did not succeed.
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["HostStorageSystemDiskLocatorLedResult"] = reflect.TypeOf((*HostStorageSystemDiskLocatorLedResult)(nil)).Elem()
}

// Contains the result of SCSI LUN operation requests.
//
// Used as return value
// by `HostStorageSystem.AttachScsiLunEx_Task`,
// `HostStorageSystem.DetachScsiLunEx_Task` and
// `HostStorageSystem.MarkPerenniallyReservedEx_Task`
type HostStorageSystemScsiLunResult struct {
	DynamicData

	// UUID of LUN on which the LUN operation was requested.
	Key string `xml:"key" json:"key"`
	// Fault if operation fails
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["HostStorageSystemScsiLunResult"] = reflect.TypeOf((*HostStorageSystemScsiLunResult)(nil)).Elem()
}

// Contains the result of the operation performed on a VMFS volume.
type HostStorageSystemVmfsVolumeResult struct {
	DynamicData

	// UUID of VMFS volume
	Key string `xml:"key" json:"key"`
	// Fault if volume operation fails, unset if operation succeeds
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["HostStorageSystemVmfsVolumeResult"] = reflect.TypeOf((*HostStorageSystemVmfsVolumeResult)(nil)).Elem()
}

// Host sub specification data are the data used when create a virtual
// device, and/or configure the virtual device and its related
// host services.
//
// A typical example of host sub specification data is the DVS host view
// specification, which is used when create DVS host view on an ESXi
// host and configure the virtual switch on the host.
// The introduction of this type of data is for improving the
// availability of the ESXi host management. For example, when
// the VirtualCenter server is not available, an ESXi host will
// have enough information to reconfigure DVS host view properly
// when the ESXi host is booted from stateless or stateless caching.
// Host sub specification data are data for VMware internal data
// structure used in virtual device creation and configuration.
// They are different to `AnswerFile`
// which are from public knowledge domain or the public API
// of VMware ESXi host services.
// When the host sub specification data for a single feature
// are stored in multiple host sub specification data objects,
// it is the responsibility of the host specification source
// in this feature to guarantee the completeness and consistency
// of these host sub specification objects.
type HostSubSpecification struct {
	DynamicData

	// The full name of the host sub specification.
	//
	// The format of this member
	// variable is:
	// CompanyName\_ProductName\_SubSpecName.
	// Thus, name conflict is avoided by containing the
	// <code>company name</code>, <code>product name</code>, and <code> sub
	// specification name</code> in this full name.
	Name string `xml:"name" json:"name"`
	// Time at which the host sub specification was created.
	CreatedTime time.Time `xml:"createdTime" json:"createdTime"`
	// The host sub specification data
	Data ByteSlice `xml:"data,omitempty" json:"data,omitempty"`
	// The host sub specification data in Binary for wire efficiency.
	BinaryData []byte `xml:"binaryData,omitempty" json:"binaryData,omitempty"`
}

func init() {
	t["HostSubSpecification"] = reflect.TypeOf((*HostSubSpecification)(nil)).Elem()
}

// This event suggests that delete the host sub specification specified by
// name.
type HostSubSpecificationDeleteEvent struct {
	HostEvent

	SubSpecName string `xml:"subSpecName" json:"subSpecName"`
}

func init() {
	t["HostSubSpecificationDeleteEvent"] = reflect.TypeOf((*HostSubSpecificationDeleteEvent)(nil)).Elem()
}

// This event suggests that update the host sub specification with the
// encapsulated copy.
type HostSubSpecificationUpdateEvent struct {
	HostEvent

	HostSubSpec HostSubSpecification `xml:"hostSubSpec" json:"hostSubSpec"`
}

func init() {
	t["HostSubSpecificationUpdateEvent"] = reflect.TypeOf((*HostSubSpecificationUpdateEvent)(nil)).Elem()
}

// This event records a failure to sync up with the VirtualCenter agent on the host
type HostSyncFailedEvent struct {
	HostEvent

	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["HostSyncFailedEvent"] = reflect.TypeOf((*HostSyncFailedEvent)(nil)).Elem()
}

// The host profile compliance check state.
type HostSystemComplianceCheckState struct {
	DynamicData

	// The compliance check operation state.
	//
	// See
	// `ComplianceResultStatus_enum` for the valid values.
	State string `xml:"state" json:"state"`
	// The compliance check starting time for running state; compliance
	// check finish time for others.
	CheckTime time.Time `xml:"checkTime" json:"checkTime"`
}

func init() {
	t["HostSystemComplianceCheckState"] = reflect.TypeOf((*HostSystemComplianceCheckState)(nil)).Elem()
}

// This data object provides information about the health of the phyical
// system.
//
// The data is retrieved from numeric sensor probes.
type HostSystemHealthInfo struct {
	DynamicData

	// Health information provided by the power probes.
	NumericSensorInfo []HostNumericSensorInfo `xml:"numericSensorInfo,omitempty" json:"numericSensorInfo,omitempty"`
}

func init() {
	t["HostSystemHealthInfo"] = reflect.TypeOf((*HostSystemHealthInfo)(nil)).Elem()
}

// This data object describes system identifying information of the host.
//
// This
// information may be vendor specific.
type HostSystemIdentificationInfo struct {
	DynamicData

	// The system identification information
	IdentifierValue string `xml:"identifierValue" json:"identifierValue"`
	// The description of the identifying information.
	//
	// See also `HostSystemIdentificationInfoIdentifier_enum`.
	IdentifierType BaseElementDescription `xml:"identifierType,typeattr" json:"identifierType"`
}

func init() {
	t["HostSystemIdentificationInfo"] = reflect.TypeOf((*HostSystemIdentificationInfo)(nil)).Elem()
}

// Information about the system as a whole.
type HostSystemInfo struct {
	DynamicData

	// Hardware vendor identification.
	Vendor string `xml:"vendor" json:"vendor"`
	// System model identification.
	Model string `xml:"model" json:"model"`
	// Hardware BIOS identification.
	Uuid string `xml:"uuid" json:"uuid"`
	// Other System identification information.
	//
	// This information may be vendor
	// specific
	OtherIdentifyingInfo []HostSystemIdentificationInfo `xml:"otherIdentifyingInfo,omitempty" json:"otherIdentifyingInfo,omitempty"`
	SerialNumber         string                         `xml:"serialNumber,omitempty" json:"serialNumber,omitempty"`
	// List of qualified names used to identify the host in a specific context.
	//
	// Unlike the other types of system identification information, these can
	// potentially change as a result of configuration.
	QualifiedName []HostQualifiedName `xml:"qualifiedName,omitempty" json:"qualifiedName,omitempty" vim:"7.0.3.0"`
	// NVMe qualified name used by Vvol.
	//
	// A unique name, assigned to each host used by Vvol.
	// Obtained through vmkctl storage control path while fetching the NVMe info.
	VvolHostNQN *HostQualifiedName `xml:"vvolHostNQN,omitempty" json:"vvolHostNQN,omitempty" vim:"8.0.0.0"`
	// Host id used by Vvol.
	//
	// The hostd id, obtained through vmkctl storage control path while
	// fetching the NVMe info.
	VvolHostId string `xml:"vvolHostId,omitempty" json:"vvolHostId,omitempty" vim:"8.0.0.0"`
	// Command line string to identify different boot options used for host.
	//
	// Example of different boot options are:
	//   - "runweasel": "System is booted for weasel installation"
	//   - "ks": "System is booted for kickstart installation"
	BootCommandLine string `xml:"bootCommandLine,omitempty" json:"bootCommandLine,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["HostSystemInfo"] = reflect.TypeOf((*HostSystemInfo)(nil)).Elem()
}

// Specifies the parameters needed to merge vCenter Server settings
// and host settings on reconnect.
type HostSystemReconnectSpec struct {
	DynamicData

	// This flag should be set if on a host reconnect, state such as virtual
	// machine state in vCenter Server e.g.
	//
	// the virtual machine inventory
	// and autostart rules, has to be propogated to the host. Any virtual
	// machines that may have been unregistered or orphaned will be
	// reregistered according to the vCenter Server inventory. Any autostart
	// rules that may have changed on the host will be similarly restored.
	// This flag is primarily intended for stateless hosts to enable vCenter
	// Server to resync these hosts after a reboot.
	SyncState *bool `xml:"syncState" json:"syncState,omitempty"`
}

func init() {
	t["HostSystemReconnectSpec"] = reflect.TypeOf((*HostSystemReconnectSpec)(nil)).Elem()
}

// The valid remediation states.
//
// Host profile apply has two stages:
// precheck remediation and remediation. Precheck remediation generates
// task list and task requirement: apply may fail when task requirements
// are not satisfied. Remediation stage can be started only when precheck
// remediation succeeded.
type HostSystemRemediationState struct {
	DynamicData

	// The remediation or precheck remediation operation state.
	//
	// See
	// `HostSystemRemediationStateState_enum` for the valid
	// values.
	State string `xml:"state" json:"state"`
	// For any "running" state, this is the starting time; for others, this
	// is the completion time.
	OperationTime time.Time `xml:"operationTime" json:"operationTime"`
}

func init() {
	t["HostSystemRemediationState"] = reflect.TypeOf((*HostSystemRemediationState)(nil)).Elem()
}

// The SystemResourceInfo data object describes the configuration of
// a single system resource group.
//
// System resource groups are analogous
// to `ResourcePool` objects for virtual machines; however,
// their structure is fixed and groups may not be created nor destroyed,
// only configured.
type HostSystemResourceInfo struct {
	DynamicData

	// ID of the system resource group.
	Key string `xml:"key" json:"key"`
	// Configuration of this system resource group.
	Config *ResourceConfigSpec `xml:"config,omitempty" json:"config,omitempty"`
	// List of child resource groups.
	Child []HostSystemResourceInfo `xml:"child,omitempty" json:"child,omitempty"`
}

func init() {
	t["HostSystemResourceInfo"] = reflect.TypeOf((*HostSystemResourceInfo)(nil)).Elem()
}

// Information and specification for control of the system swap configuration
// on the current host.
type HostSystemSwapConfiguration struct {
	DynamicData

	// The currently enabled options.
	//
	// When this property contains only one value and this value is `HostSystemSwapConfigurationDisabledOption`,
	// this indicates that the system swap is disabled.
	// If the `HostSystemSwapConfigurationDisabledOption` option is
	// used together with some other option in call to `HostSystem.UpdateSystemSwapConfiguration`, a
	// `InvalidArgument` is thrown.
	// It is not allowed to have duplicate values in this array. If so a
	// `InvalidArgument` is thrown.
	Option []BaseHostSystemSwapConfigurationSystemSwapOption `xml:"option,omitempty,typeattr" json:"option,omitempty"`
}

func init() {
	t["HostSystemSwapConfiguration"] = reflect.TypeOf((*HostSystemSwapConfiguration)(nil)).Elem()
}

// Use option to indicate that a user specified datastore may be used for
// system swap.
type HostSystemSwapConfigurationDatastoreOption struct {
	HostSystemSwapConfigurationSystemSwapOption

	// The datastore to be used with this swap option.
	//
	// This value should be always set when the encapsulating option is used,
	// otherwise a call to `HostSystem.UpdateSystemSwapConfiguration` will
	// result in a `InvalidArgument` fault.
	Datastore string `xml:"datastore" json:"datastore"`
}

func init() {
	t["HostSystemSwapConfigurationDatastoreOption"] = reflect.TypeOf((*HostSystemSwapConfigurationDatastoreOption)(nil)).Elem()
}

// Indicates that the system swap on the host is currently disabled.
//
// This value is used with the
// `HostSystem.UpdateSystemSwapConfiguration` managed method to
// disable system swap. Presence of this value in `HostSystemSwapConfiguration.option` excludes appearance of any other
// options. Specifying additional options will result in a `InvalidArgument` fault being thrown from the `HostSystem.UpdateSystemSwapConfiguration` method.
type HostSystemSwapConfigurationDisabledOption struct {
	HostSystemSwapConfigurationSystemSwapOption
}

func init() {
	t["HostSystemSwapConfigurationDisabledOption"] = reflect.TypeOf((*HostSystemSwapConfigurationDisabledOption)(nil)).Elem()
}

// Use option to indicate that the host cache may be used for system
// swap.
//
// See also `HostCacheConfigurationManager`for more details..
type HostSystemSwapConfigurationHostCacheOption struct {
	HostSystemSwapConfigurationSystemSwapOption
}

func init() {
	t["HostSystemSwapConfigurationHostCacheOption"] = reflect.TypeOf((*HostSystemSwapConfigurationHostCacheOption)(nil)).Elem()
}

// Use option to indicate that the datastore configured for host local swap
// may be used for system swap.
type HostSystemSwapConfigurationHostLocalSwapOption struct {
	HostSystemSwapConfigurationSystemSwapOption
}

func init() {
	t["HostSystemSwapConfigurationHostLocalSwapOption"] = reflect.TypeOf((*HostSystemSwapConfigurationHostLocalSwapOption)(nil)).Elem()
}

// Base class for all system swap options.
//
// This class is not supposed to be used directly.
// These values are to be used in a `SystemSwapConfiguration.option`
// array.
type HostSystemSwapConfigurationSystemSwapOption struct {
	DynamicData

	// Specifies the order the options are preferred among each other.
	//
	// The lower the value the more important.
	Key int32 `xml:"key" json:"key"`
}

func init() {
	t["HostSystemSwapConfigurationSystemSwapOption"] = reflect.TypeOf((*HostSystemSwapConfigurationSystemSwapOption)(nil)).Elem()
}

// Transport information about a SCSI target.
type HostTargetTransport struct {
	DynamicData
}

func init() {
	t["HostTargetTransport"] = reflect.TypeOf((*HostTargetTransport)(nil)).Elem()
}

// This data object describes the Transmission Control Protocol
// (TCP) host bus adapter interface.
type HostTcpHba struct {
	HostHostBusAdapter

	// Device name of the associated physical NIC, if any.
	//
	// Should match the `PhysicalNic.device` property
	// of the corresponding physical NIC.
	AssociatedPnic string `xml:"associatedPnic,omitempty" json:"associatedPnic,omitempty"`
}

func init() {
	t["HostTcpHba"] = reflect.TypeOf((*HostTcpHba)(nil)).Elem()
	minAPIVersionForType["HostTcpHba"] = "7.0.3.0"
}

// A data object which specifies the parameters needed
// to create an NVME over TCP host bus adapter.
type HostTcpHbaCreateSpec struct {
	HostHbaCreateSpec

	// Device name of the associated physical NIC.
	//
	// Should match the `PhysicalNic.device` property
	// of the corresponding physical NIC.
	Pnic string `xml:"pnic" json:"pnic"`
}

func init() {
	t["HostTcpHbaCreateSpec"] = reflect.TypeOf((*HostTcpHbaCreateSpec)(nil)).Elem()
	minAPIVersionForType["HostTcpHbaCreateSpec"] = "7.0.3.0"
}

// Transmission Control Protocol (TCP) transport
// information about a target.
type HostTcpTargetTransport struct {
	HostTargetTransport
}

func init() {
	t["HostTcpTargetTransport"] = reflect.TypeOf((*HostTcpTargetTransport)(nil)).Elem()
	minAPIVersionForType["HostTcpTargetTransport"] = "7.0.3.0"
}

// This data object type represents result of TPM attestation.
type HostTpmAttestationInfo struct {
	DynamicData

	// Time of TPM attestation.
	Time time.Time `xml:"time" json:"time"`
	// Attestation status.
	//
	// Valid values are enumerated by the
	// `HostTpmAttestationInfoAcceptanceStatus_enum` type.
	Status HostTpmAttestationInfoAcceptanceStatus `xml:"status" json:"status"`
	// Message explaining TPM attestation failure.
	Message *LocalizableMessage `xml:"message,omitempty" json:"message,omitempty"`
}

func init() {
	t["HostTpmAttestationInfo"] = reflect.TypeOf((*HostTpmAttestationInfo)(nil)).Elem()
}

// This class is used to report Trusted Platform Module (TPM) attestation
// information - values of the Platform Configuration Registers (PCRs) and
// the TPM event log to the external clients.
//
// This information can be used to determine the integrity of the software
// stack running as reported by the platform.
//
// The TPM stores digests (hashes) of the software stack components running on
// the host. Both binary modules and configuration information can be hashed.
// The calculated hash values are stored in special-purpose hardware registers
// called PCRs. Each PCR is defined to hold cumulative digest(s) of specific
// part(s) of the software stack.
//
// Due to the limited amount of PCRs available a hash-chaining scheme is implemented.
// When adding new information to a PCR the new value of hash is computed according
// to the following formula:
// NewHash = hash\_function(OldHash + hash\_function(NewData))
// This scheme allows storing measurements of an unlimited amount of components.
//
// The TPM event log provides an exact sequence of the events that contributed
// to the value of a PCR. It contains information about the type of the event
// and event-specific information. The presence of the log allows verification of
// both the final PCR state and the entire attestation path that formed it.
//
// It is possible for this report to be unreliable. This could be due to missing package
// information in the host database, errors in creation of the events. Only first 1000
// events are recorded by the kernel. Further events will not be recorded in the log and
// will cause the log to be marked as incomplete.
type HostTpmAttestationReport struct {
	DynamicData

	// The array of PCR digest values stored in the TPM device since the last
	// host boot time.
	TpmPcrValues []HostTpmDigestInfo `xml:"tpmPcrValues" json:"tpmPcrValues"`
	// Log of TPM software stack attestation events.
	TpmEvents []HostTpmEventLogEntry `xml:"tpmEvents" json:"tpmEvents"`
	// This flag indicates whether the provided TPM events are a complete and reliable
	// information about host boot status.
	//
	// TPM event log may be incomplete (and therfore unreliable) if certain modules have
	// inappropriate origin or if the package information is incomplete. Only first 1000
	// events are recorded by the kernel. Further events will not be recorded in the log
	// and will cause the log to be marked as unreliable.
	TpmLogReliable bool `xml:"tpmLogReliable" json:"tpmLogReliable"`
}

func init() {
	t["HostTpmAttestationReport"] = reflect.TypeOf((*HostTpmAttestationReport)(nil)).Elem()
}

// Details of a Trusted Platform Module (TPM) event recording the
// measurement of boot complete event.
//
// The event digest is hash of
// the string "Boot Complete" including the nul character.
type HostTpmBootCompleteEventDetails struct {
	HostTpmEventDetails
}

func init() {
	t["HostTpmBootCompleteEventDetails"] = reflect.TypeOf((*HostTpmBootCompleteEventDetails)(nil)).Elem()
	minAPIVersionForType["HostTpmBootCompleteEventDetails"] = "8.0.1.0"
}

// Details of a Trusted Platform Module (TPM) event recording kernel security
// option passed at boot time and currently in effect.
//
// This event type exists to simplify parsing of the security-related information
// by internal and third-party solutions. Each boot option may be passed to kernel
// multiple times and/or in different forms. Replicating the parsing logic of the
// kernel would be neither convinient, nor secure for the client applications.
//
// Each instance of this event reports details of a single security-related
// boot option, as set in the kernel.
type HostTpmBootSecurityOptionEventDetails struct {
	HostTpmEventDetails

	// Security-related options string, reflecting the state of an option set
	// in the kernel.
	//
	// This string is in the form of a KEY=VALUE pair.
	BootSecurityOption string `xml:"bootSecurityOption" json:"bootSecurityOption"`
}

func init() {
	t["HostTpmBootSecurityOptionEventDetails"] = reflect.TypeOf((*HostTpmBootSecurityOptionEventDetails)(nil)).Elem()
}

// Details of an Trusted Platform Module (TPM) event recording options entered
// manually on the command line prompt at boot time.
type HostTpmCommandEventDetails struct {
	HostTpmEventDetails

	// Boot options as entered on the command line prompt at boot time.
	CommandLine string `xml:"commandLine" json:"commandLine"`
}

func init() {
	t["HostTpmCommandEventDetails"] = reflect.TypeOf((*HostTpmCommandEventDetails)(nil)).Elem()
}

// This data object type describes the digest values in the Platform
// Configuration Register (PCR) of a Trusted Platform Module (TPM) device.
type HostTpmDigestInfo struct {
	HostDigestInfo

	// Index of the PCR that stores the TPM digest value.
	PcrNumber int32 `xml:"pcrNumber" json:"pcrNumber"`
}

func init() {
	t["HostTpmDigestInfo"] = reflect.TypeOf((*HostTpmDigestInfo)(nil)).Elem()
}

// This is a base data object for describing an event generated by
// Trusted Platform Module (TPM).
//
// It contains parameters common to
// all TPM event types.
type HostTpmEventDetails struct {
	DynamicData

	// Value of the Platform Configuration Register (PCR) for this event.
	DataHash ByteSlice `xml:"dataHash" json:"dataHash"`
	// Method in which the digest hash is calculated.
	//
	// The set of possible
	// values is described in `HostDigestInfoDigestMethodType_enum`.
	DataHashMethod string `xml:"dataHashMethod,omitempty" json:"dataHashMethod,omitempty"`
}

func init() {
	t["HostTpmEventDetails"] = reflect.TypeOf((*HostTpmEventDetails)(nil)).Elem()
}

// This data object represents a single entry of an event log created by
// Trusted Platform Module (TPM).
//
// An TPM event log entry represents a single change to the value of
// a Platform Configuration Register (PCR). It contains detailed information
// about the reason of PCR value change, and the specifics of the event.
//
// Multiple objects of this type form an TPM event log. This log allows for
// verification of the both the software stack running on a host and the attestation
// process itself.
type HostTpmEventLogEntry struct {
	DynamicData

	// Index of the PCR that was affected by the event.
	PcrIndex int32 `xml:"pcrIndex" json:"pcrIndex"`
	// The details of the event.
	EventDetails BaseHostTpmEventDetails `xml:"eventDetails,typeattr" json:"eventDetails"`
}

func init() {
	t["HostTpmEventLogEntry"] = reflect.TypeOf((*HostTpmEventLogEntry)(nil)).Elem()
}

// Details of an Trusted Platform Module (TPM) event recording TPM NVRAM tag.
type HostTpmNvTagEventDetails struct {
	HostTpmBootSecurityOptionEventDetails
}

func init() {
	t["HostTpmNvTagEventDetails"] = reflect.TypeOf((*HostTpmNvTagEventDetails)(nil)).Elem()
	minAPIVersionForType["HostTpmNvTagEventDetails"] = "7.0.2.0"
}

// Details of a Trusted Platform Module (TPM) event recording boot-time options.
//
// The boot-time options set on the system are packaged into a file that is supplied
// to the kernel at boot time. The boot options may be a string of key=value pairs
// (possibly separated by a new line) or a blob of arbitrary data.
type HostTpmOptionEventDetails struct {
	HostTpmEventDetails

	// Name of the file containing the boot options.
	OptionsFileName string `xml:"optionsFileName" json:"optionsFileName"`
	// Options set by the boot option package.
	//
	// This array exposes the raw contents of the settings file (or files) that were
	// passed to kernel during the boot up process, and, therefore, should be treated
	// accordingly.
	BootOptions ByteSlice `xml:"bootOptions,omitempty" json:"bootOptions,omitempty"`
}

func init() {
	t["HostTpmOptionEventDetails"] = reflect.TypeOf((*HostTpmOptionEventDetails)(nil)).Elem()
}

// Details of a Trusted Platform Module (TPM) event recording the measurement
// of a signing key.
type HostTpmSignerEventDetails struct {
	HostTpmBootSecurityOptionEventDetails
}

func init() {
	t["HostTpmSignerEventDetails"] = reflect.TypeOf((*HostTpmSignerEventDetails)(nil)).Elem()
	minAPIVersionForType["HostTpmSignerEventDetails"] = "8.0.0.1"
}

// Details of a Trusted Platform Module (TPM) event recording a software component
// related event.
//
// This event is created when measuring a software component installed on the system.
// A software component may be a tardisk, a kernel module or any other type supported
// by the package system.
//
// Some software components are not packaged as VIBs (currently the package database
// and persistent state information of ESXi). For these components the VIB fields
// will contain empty strings.
type HostTpmSoftwareComponentEventDetails struct {
	HostTpmEventDetails

	// Name of the software component that caused this TPM event.
	ComponentName string `xml:"componentName" json:"componentName"`
	// Name of the VIB containing the software component.
	VibName string `xml:"vibName" json:"vibName"`
	// Version of the VIB containing the software component.
	VibVersion string `xml:"vibVersion" json:"vibVersion"`
	// Vendor of the VIB containing the software component.
	VibVendor string `xml:"vibVendor" json:"vibVendor"`
}

func init() {
	t["HostTpmSoftwareComponentEventDetails"] = reflect.TypeOf((*HostTpmSoftwareComponentEventDetails)(nil)).Elem()
}

// Details of a Trusted Platform Module (TPM) event recording the
// measurement of a module version.
type HostTpmVersionEventDetails struct {
	HostTpmEventDetails

	// A packed structure containing the module version.
	Version []byte `xml:"version" json:"version"`
}

func init() {
	t["HostTpmVersionEventDetails"] = reflect.TypeOf((*HostTpmVersionEventDetails)(nil)).Elem()
	minAPIVersionForType["HostTpmVersionEventDetails"] = "8.0.0.1"
}

// This data object type represents result of the attestation done by
// Trust Authority attestation service.
type HostTrustAuthorityAttestationInfo struct {
	DynamicData

	// Status of the attestation.
	//
	// See `HostTrustAuthorityAttestationInfoAttestationStatus_enum` for the
	// supported values.
	AttestationStatus string `xml:"attestationStatus" json:"attestationStatus"`
	// ID of the attestation service in case of attestation success.
	//
	// Unset when
	// not attested.
	ServiceId string `xml:"serviceId,omitempty" json:"serviceId,omitempty"`
	// Time of attestation.
	AttestedAt *time.Time `xml:"attestedAt" json:"attestedAt,omitempty"`
	// Time until attestation is valid.
	AttestedUntil *time.Time `xml:"attestedUntil" json:"attestedUntil,omitempty"`
	// Messages explaining attestation failure or attestation status
	// retrieval errors, if any.
	Messages []LocalizableMessage `xml:"messages,omitempty" json:"messages,omitempty"`
}

func init() {
	t["HostTrustAuthorityAttestationInfo"] = reflect.TypeOf((*HostTrustAuthorityAttestationInfo)(nil)).Elem()
	minAPIVersionForType["HostTrustAuthorityAttestationInfo"] = "7.0.1.0"
}

// Information about an unresolved VMFS volume extent
// An unresolved VMFS volume extent is a device partition which is
// detected to have copy of an extent of a VMFS volume.
//
// Such a copy can be created via replication or snapshots, for example.
//
// See also `HostUnresolvedVmfsVolume`.
type HostUnresolvedVmfsExtent struct {
	DynamicData

	// The device information
	Device HostScsiDiskPartition `xml:"device" json:"device"`
	// The device path of an VMFS extent
	DevicePath string `xml:"devicePath" json:"devicePath"`
	// The UUID of the VMFS volume read from to the partition.
	VmfsUuid string `xml:"vmfsUuid" json:"vmfsUuid"`
	// Is this a copy of the head extent of the VMFS volume?
	IsHeadExtent bool `xml:"isHeadExtent" json:"isHeadExtent"`
	// A number indicating the order of an extent in a volume.
	//
	// An extent with
	// a lower ordinal value than another extent provides a range of blocks to
	// a volume at an earlier block address range. Extents with the same
	// ordinal provide the same range of blocks to a volume. A zero ordinal
	// indicates that the extent is a head extent.
	//
	// In the case each extent in the `HostUnresolvedVmfsVolume` is
	// represented in the list of `HostUnresolvedVmfsExtent` data objects,
	// the ordinal will refer to the absolute index of the extent in the
	// volume. For example, ordinal "1" refers to the second extent;
	// ordinal "2" refers to the third extent.
	//
	// In the case that some extents of the volume are not represented in
	// the `HostUnresolvedVmfsExtent` list, the ordinal will not precisely
	// describe the position in the list of extents. A number will be skipped
	// to indicate holes in the extent order. For example, given a volume with
	// five extents with the second and third extents missing, the ordinal
	// values in use will be {0, 2, 3}. The missing second and third extent
	// are represented by the missing ordinal value "1" while the fourth and
	// fifth extents will be assigned an ordinal of "2" and "3" respectively.
	//
	// The reason the ordinals are not reliable in the case of missing extents
	// is because the extents are identified by their start and end blocks.
	// The ordinals are just a hint used to help indicate extents that
	// correspond to the same start and end blocks.
	Ordinal int32 `xml:"ordinal" json:"ordinal"`
	// Index of the first block that this extent provides.
	StartBlock int32 `xml:"startBlock" json:"startBlock"`
	// Index of the last block that this extent provides.
	EndBlock int32 `xml:"endBlock" json:"endBlock"`
	// Reason as to why the partition is marked as copy
	// of a VMFS volume's extent.
	//
	// Possible reasons are the disk id is not matching with what
	// the scsi inq is saying or disk uuid is not matching
	//
	// See also `HostUnresolvedVmfsExtentUnresolvedReason_enum`.
	Reason string `xml:"reason" json:"reason"`
}

func init() {
	t["HostUnresolvedVmfsExtent"] = reflect.TypeOf((*HostUnresolvedVmfsExtent)(nil)).Elem()
}

// Specification to resignature an Unresolved VMFS volume.
type HostUnresolvedVmfsResignatureSpec struct {
	DynamicData

	// List of device path each specifying VMFS extents.
	ExtentDevicePath []string `xml:"extentDevicePath" json:"extentDevicePath"`
}

func init() {
	t["HostUnresolvedVmfsResignatureSpec"] = reflect.TypeOf((*HostUnresolvedVmfsResignatureSpec)(nil)).Elem()
}

// When an UnresolvedVmfsVolume has been resignatured or forceMounted, we want to
// return the original spec information along with newly created VMFS volume.
type HostUnresolvedVmfsResolutionResult struct {
	DynamicData

	// The original UnresolvedVmfsResolutionSpec which user had specified
	Spec HostUnresolvedVmfsResolutionSpec `xml:"spec" json:"spec"`
	// Newly created VmfsVolume
	Vmfs *HostVmfsVolume `xml:"vmfs,omitempty" json:"vmfs,omitempty"`
	// 'fault' would be set if the operation was not successful
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["HostUnresolvedVmfsResolutionResult"] = reflect.TypeOf((*HostUnresolvedVmfsResolutionResult)(nil)).Elem()
}

// An unresolved VMFS volume is reported when one or more device partitions
// of volume are detected to have copies of extents of the volume.
//
// Such copies can be created via replication or snapshots, for example.
// This data object type describes how to resolve an unbound VMFS volume.
// The SCSI device path for each of the VMFS volume extent should be
// specified.
// For the current release, only head-extent needs to be specified.
// In future releases, we will allow user to specify explicitly all the
// extents which makes up a new Vmfs Volume.
type HostUnresolvedVmfsResolutionSpec struct {
	DynamicData

	// List of device paths each specifying a VMFS extent.
	//
	// One extent must be specified. This property is represented as a
	// list to enable future enhancements to the interface.
	ExtentDevicePath []string `xml:"extentDevicePath" json:"extentDevicePath"`
	// When set to Resignature, new Uuid is assigned to the VMFS
	// volume.
	//
	// When set to 'forceMount', existing uuid is assigned
	// to the Vmfs volume and Vmfs volumes metadata doesn't change.
	//
	// See also `HostUnresolvedVmfsResolutionSpecVmfsUuidResolution_enum`.
	UuidResolution string `xml:"uuidResolution" json:"uuidResolution"`
}

func init() {
	t["HostUnresolvedVmfsResolutionSpec"] = reflect.TypeOf((*HostUnresolvedVmfsResolutionSpec)(nil)).Elem()
}

// Information about detected unbound, unresolved VMFS volume.
//
// An unresolved VMFS volume is reported when one or more device
// partitions of volume are detected to have copies of extents
// of the volume. Such copies can be created via replication or
// snapshots.
//
// UnresolvedVmfsVolume are not mounted on the host where they
// are detected. User may choose to resignature the volume in
// which case a new Uuid is assigned to the volume and contents
// of the VMFS volume is kept intact.
//
// User may choose to keep the original Uuid and mount the VMFS
// volume as it is on the given host. In this case, user has
// chosen to mount the copy of the VMFS volume on that host with
// no change to the original Uuid. This may fail with
// VmfsVolumeAlreadyMounted exception if there is an existing
// VMFS volume with the same Uuid mounted somewhere in the same
// datacenter.
//
// Simple diagram representing the possible operations on UnresolvedVmfsVolume
//
//	---------------------------------------------------------------------------
//	|                resignature                 forceMount                   |
//	|  VmfsVolume <---------------  Unresolved ------------>  VmfsVolume with |
//	| forceMountedInfo              Vmfs Volume              forceMountedInfo |
//	|  not set                                                  will be set   |
//	---------------------------------------------------------------------------
//
// See also `HostStorageSystem`.
type HostUnresolvedVmfsVolume struct {
	DynamicData

	// List of detected copies of VMFS extents.
	Extent []HostUnresolvedVmfsExtent `xml:"extent" json:"extent"`
	// The detected VMFS label name
	VmfsLabel string `xml:"vmfsLabel" json:"vmfsLabel"`
	// The detected VMFS UUID
	VmfsUuid string `xml:"vmfsUuid" json:"vmfsUuid"`
	// Total number of blocks in this volume.
	TotalBlocks int32 `xml:"totalBlocks" json:"totalBlocks"`
	// Information related to how the volume might be resolved.
	ResolveStatus HostUnresolvedVmfsVolumeResolveStatus `xml:"resolveStatus" json:"resolveStatus"`
}

func init() {
	t["HostUnresolvedVmfsVolume"] = reflect.TypeOf((*HostUnresolvedVmfsVolume)(nil)).Elem()
}

// Data object that describes the resolvability of a volume.
type HostUnresolvedVmfsVolumeResolveStatus struct {
	DynamicData

	// Can this volume be resolved? There may be other reasons a volume cannot
	// be resolved other than the fact that it is incomplete.
	//
	// This boolean will
	// authoritatively indicate if the server can resolve this volume.
	Resolvable bool `xml:"resolvable" json:"resolvable"`
	// Is the list of extents for the volume a partial list? A volume can only
	// be resignatured if all extents composing that volume are available.
	//
	// Hence, a volume with a partial extent list cannot be resignatured.
	//
	// In cases where this information is not known for a volume, this
	// property will be unset.
	IncompleteExtents *bool `xml:"incompleteExtents" json:"incompleteExtents,omitempty"`
	// Are there multiple copies of extents for this volume? If any extent of
	// the volume has multiple copies then the extents to be resolved must be
	// explicitly specified when resolving this volume.
	//
	// In cases where this information is not known for a volume, this
	// property will be unset.
	MultipleCopies *bool `xml:"multipleCopies" json:"multipleCopies,omitempty"`
}

func init() {
	t["HostUnresolvedVmfsVolumeResolveStatus"] = reflect.TypeOf((*HostUnresolvedVmfsVolumeResolveStatus)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostUpdateVStorageObjectMetadataEx_Task`.
type HostUpdateVStorageObjectMetadataExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore to query for the virtual storage objects.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// array of key/value strings. (keys must be unique
	// within the list)
	Metadata []KeyValue `xml:"metadata,omitempty" json:"metadata,omitempty"`
	// array of keys need to be deleted
	DeleteKeys []string `xml:"deleteKeys,omitempty" json:"deleteKeys,omitempty"`
}

func init() {
	t["HostUpdateVStorageObjectMetadataExRequestType"] = reflect.TypeOf((*HostUpdateVStorageObjectMetadataExRequestType)(nil)).Elem()
	minAPIVersionForType["HostUpdateVStorageObjectMetadataExRequestType"] = "7.0.2.0"
}

type HostUpdateVStorageObjectMetadataEx_Task HostUpdateVStorageObjectMetadataExRequestType

func init() {
	t["HostUpdateVStorageObjectMetadataEx_Task"] = reflect.TypeOf((*HostUpdateVStorageObjectMetadataEx_Task)(nil)).Elem()
}

type HostUpdateVStorageObjectMetadataEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostVStorageObjectManager.HostUpdateVStorageObjectMetadata_Task`.
type HostUpdateVStorageObjectMetadataRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore to query for the virtual storage objects.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// array of key/value strings. (keys must be unique
	// within the list)
	Metadata []KeyValue `xml:"metadata,omitempty" json:"metadata,omitempty"`
	// array of keys need to be deleted
	DeleteKeys []string `xml:"deleteKeys,omitempty" json:"deleteKeys,omitempty"`
}

func init() {
	t["HostUpdateVStorageObjectMetadataRequestType"] = reflect.TypeOf((*HostUpdateVStorageObjectMetadataRequestType)(nil)).Elem()
}

type HostUpdateVStorageObjectMetadata_Task HostUpdateVStorageObjectMetadataRequestType

func init() {
	t["HostUpdateVStorageObjectMetadata_Task"] = reflect.TypeOf((*HostUpdateVStorageObjectMetadata_Task)(nil)).Elem()
}

type HostUpdateVStorageObjectMetadata_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This event records a failure to connect to a host
// due to an installation or upgrade issue.
type HostUpgradeFailedEvent struct {
	HostEvent
}

func init() {
	t["HostUpgradeFailedEvent"] = reflect.TypeOf((*HostUpgradeFailedEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, the event is no longer relevant.
//
// This event records that the userworld swap is not enabled on the host.
//
// HA
// needs userworld swap to be configured on embedded ESX hosts to function.
type HostUserWorldSwapNotEnabledEvent struct {
	HostEvent
}

func init() {
	t["HostUserWorldSwapNotEnabledEvent"] = reflect.TypeOf((*HostUserWorldSwapNotEnabledEvent)(nil)).Elem()
}

// Data object describes host vFlash cache configuration information.
type HostVFlashManagerVFlashCacheConfigInfo struct {
	DynamicData

	// Cache configuration options for the supported vFlash modules.
	VFlashModuleConfigOption []HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption `xml:"vFlashModuleConfigOption,omitempty" json:"vFlashModuleConfigOption,omitempty"`
	// Name of the default vFlash module for the read-write cache associated
	// with the VMs of this host.
	//
	// This setting can be overridden by
	// `VirtualDiskVFlashCacheConfigInfo.vFlashModule`
	// per VMDK.
	DefaultVFlashModule string `xml:"defaultVFlashModule,omitempty" json:"defaultVFlashModule,omitempty"`
	// Amount of vFlash resource is allocated to the host swap cache.
	//
	// As long as set,
	// reservation will be permanent and retain regardless of host power state. The host
	// swap cache will be disabled if reservation is set to zero.
	SwapCacheReservationInGB int64 `xml:"swapCacheReservationInGB,omitempty" json:"swapCacheReservationInGB,omitempty"`
}

func init() {
	t["HostVFlashManagerVFlashCacheConfigInfo"] = reflect.TypeOf((*HostVFlashManagerVFlashCacheConfigInfo)(nil)).Elem()
}

type HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption struct {
	DynamicData

	// Name of the vFlash module
	VFlashModule string `xml:"vFlashModule" json:"vFlashModule"`
	// Version of the vFlash module
	VFlashModuleVersion string `xml:"vFlashModuleVersion" json:"vFlashModuleVersion"`
	// Minimum supported version
	MinSupportedModuleVersion string `xml:"minSupportedModuleVersion" json:"minSupportedModuleVersion"`
	// Cache data consistency types.
	//
	// See `VirtualDiskVFlashCacheConfigInfoCacheConsistencyType_enum`
	CacheConsistencyType ChoiceOption `xml:"cacheConsistencyType" json:"cacheConsistencyType"`
	// Cache modes.
	//
	// See `VirtualDiskVFlashCacheConfigInfoCacheMode_enum`
	CacheMode ChoiceOption `xml:"cacheMode" json:"cacheMode"`
	// blockSizeInKBOption defines a range of virtual disk cache block size.
	BlockSizeInKBOption LongOption `xml:"blockSizeInKBOption" json:"blockSizeInKBOption"`
	// reservationInMBOption defines a range of virtual disk cache size.
	ReservationInMBOption LongOption `xml:"reservationInMBOption" json:"reservationInMBOption"`
	// Maximal size of virtual disk supported in kilobytes.
	MaxDiskSizeInKB int64 `xml:"maxDiskSizeInKB" json:"maxDiskSizeInKB"`
}

func init() {
	t["HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption"] = reflect.TypeOf((*HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption)(nil)).Elem()
}

// Specification to configure vFlash cache on the host.
type HostVFlashManagerVFlashCacheConfigSpec struct {
	DynamicData

	// Name of the default vFlash module for the read-write caches associated
	// with the VMs of this host.
	//
	// This setting can be overridden by
	// `VirtualDiskVFlashCacheConfigInfo.vFlashModule`
	// per VMDK.
	DefaultVFlashModule string `xml:"defaultVFlashModule" json:"defaultVFlashModule"`
	// Amount of vFlash resource is allocated to the host swap cache.
	//
	// As long as set,
	// reservation will be permanent and retain regardless of host power state. The host
	// swap cache will be disabled if the reservation is set to zero.
	SwapCacheReservationInGB int64 `xml:"swapCacheReservationInGB" json:"swapCacheReservationInGB"`
}

func init() {
	t["HostVFlashManagerVFlashCacheConfigSpec"] = reflect.TypeOf((*HostVFlashManagerVFlashCacheConfigSpec)(nil)).Elem()
}

// vFlash configuration Information.
type HostVFlashManagerVFlashConfigInfo struct {
	DynamicData

	// vFlash resource configuration information
	VFlashResourceConfigInfo *HostVFlashManagerVFlashResourceConfigInfo `xml:"vFlashResourceConfigInfo,omitempty" json:"vFlashResourceConfigInfo,omitempty"`
	// vFlash cache configuration information
	VFlashCacheConfigInfo *HostVFlashManagerVFlashCacheConfigInfo `xml:"vFlashCacheConfigInfo,omitempty" json:"vFlashCacheConfigInfo,omitempty"`
}

func init() {
	t["HostVFlashManagerVFlashConfigInfo"] = reflect.TypeOf((*HostVFlashManagerVFlashConfigInfo)(nil)).Elem()
}

// vFlash resource configuration Information.
type HostVFlashManagerVFlashResourceConfigInfo struct {
	DynamicData

	// The contained VFFS volume
	Vffs *HostVffsVolume `xml:"vffs,omitempty" json:"vffs,omitempty"`
	// Capacity of the vFlash resource.
	//
	// It is the capacity
	// of the contained VFFS volume.
	Capacity int64 `xml:"capacity" json:"capacity"`
}

func init() {
	t["HostVFlashManagerVFlashResourceConfigInfo"] = reflect.TypeOf((*HostVFlashManagerVFlashResourceConfigInfo)(nil)).Elem()
}

// vFlash resource configuration specification.
type HostVFlashManagerVFlashResourceConfigSpec struct {
	DynamicData

	// The contained VFFS volume uuid.
	VffsUuid string `xml:"vffsUuid" json:"vffsUuid"`
}

func init() {
	t["HostVFlashManagerVFlashResourceConfigSpec"] = reflect.TypeOf((*HostVFlashManagerVFlashResourceConfigSpec)(nil)).Elem()
}

// Data object provides vFlash resource runtime usage.
type HostVFlashManagerVFlashResourceRunTimeInfo struct {
	DynamicData

	// Overall usage of vFlash resource, in bytes.
	Usage int64 `xml:"usage" json:"usage"`
	// Overall capacity of vFlash resource, in bytes.
	Capacity int64 `xml:"capacity" json:"capacity"`
	// True if all the included the VFFS volumes are accessible.
	//
	// False if one or
	// multiple included VFFS volumes are inaccessible.
	Accessible bool `xml:"accessible" json:"accessible"`
	// vFlash resource capacity can be allocated for VM caches
	CapacityForVmCache int64 `xml:"capacityForVmCache" json:"capacityForVmCache"`
	// Free vFlash resource can be allocated for VM caches
	FreeForVmCache int64 `xml:"freeForVmCache" json:"freeForVmCache"`
}

func init() {
	t["HostVFlashManagerVFlashResourceRunTimeInfo"] = reflect.TypeOf((*HostVFlashManagerVFlashResourceRunTimeInfo)(nil)).Elem()
}

// vFlash resource configuration result returns the newly-configured backend
// VFFS volume and operation result for each passed-in SSD device.
type HostVFlashResourceConfigurationResult struct {
	DynamicData

	// The original array of device path which user had specified
	DevicePath []string `xml:"devicePath,omitempty" json:"devicePath,omitempty"`
	// Newly configured VffsVolume
	Vffs *HostVffsVolume `xml:"vffs,omitempty" json:"vffs,omitempty"`
	// Array of device operation results.
	DiskConfigurationResult []HostDiskConfigurationResult `xml:"diskConfigurationResult,omitempty" json:"diskConfigurationResult,omitempty"`
}

func init() {
	t["HostVFlashResourceConfigurationResult"] = reflect.TypeOf((*HostVFlashResourceConfigurationResult)(nil)).Elem()
}

// The object type for the array returned by queryVMotionCompatibility;
// specifies the VMotion compatibility types for a host.
type HostVMotionCompatibility struct {
	DynamicData

	// The prospective host for the virtual machine.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Ways in which the host is compatible with the designated virtual
	// machine that is a candidate for VMotion.
	//
	// This array will be
	// a subset of the set of VMotionCompatibilityType strings that
	// were input to queryVMotionCompatibility.
	Compatibility []string `xml:"compatibility,omitempty" json:"compatibility,omitempty"`
}

func init() {
	t["HostVMotionCompatibility"] = reflect.TypeOf((*HostVMotionCompatibility)(nil)).Elem()
}

// This data object configuring VMotion on the host.
//
// The runtime information is available from the
// `VMotionInfo` data object type.
type HostVMotionConfig struct {
	DynamicData

	// Key of the VirtualNic used for VMotion.
	VmotionNicKey string `xml:"vmotionNicKey,omitempty" json:"vmotionNicKey,omitempty"`
	// Flag to indicate whether or not VMotion is enabled.
	Enabled bool `xml:"enabled" json:"enabled"`
}

func init() {
	t["HostVMotionConfig"] = reflect.TypeOf((*HostVMotionConfig)(nil)).Elem()
}

// Deprecated as of VI API 4.0, use `HostVirtualNicManagerInfo`.
//
// This data object type describes VMotion host
// configuration data objects.
type HostVMotionInfo struct {
	DynamicData

	// VMotion network configuration.
	NetConfig *HostVMotionNetConfig `xml:"netConfig,omitempty" json:"netConfig,omitempty"`
	// IP configuration of the VMotion VirtualNic.
	IpConfig *HostIpConfig `xml:"ipConfig,omitempty" json:"ipConfig,omitempty"`
}

func init() {
	t["HostVMotionInfo"] = reflect.TypeOf((*HostVMotionInfo)(nil)).Elem()
}

// The result of an InstantClone task.
//
// Contains the dest VM id and timestamp
// values at the time of different operations.
type HostVMotionManagerDstInstantCloneResult struct {
	DynamicData

	// The destination VM ID of the InstantCloned VM.
	DstVmId int32 `xml:"dstVmId,omitempty" json:"dstVmId,omitempty"`
	// Time stamp at the start of the InstantClone operation at the dest
	// VM.
	StartTime int64 `xml:"startTime,omitempty" json:"startTime,omitempty"`
	// Time stamp when the destination VM starts cpt load.
	CptLoadTime int64 `xml:"cptLoadTime,omitempty" json:"cptLoadTime,omitempty"`
	// Time stamp when the destination VM completes cpt load.
	CptLoadDoneTime int64 `xml:"cptLoadDoneTime,omitempty" json:"cptLoadDoneTime,omitempty"`
	// Time stamp when the destination VM completes replicating memory.
	ReplicateMemDoneTime int64 `xml:"replicateMemDoneTime,omitempty" json:"replicateMemDoneTime,omitempty"`
	// Time stamp when the migration completes on the destination VM.
	EndTime int64 `xml:"endTime,omitempty" json:"endTime,omitempty"`
	// Device checkpoint stream time.
	CptXferTime int64 `xml:"cptXferTime,omitempty" json:"cptXferTime,omitempty"`
	// Checkpoint cache size used.
	CptCacheUsed int64 `xml:"cptCacheUsed,omitempty" json:"cptCacheUsed,omitempty"`
	// Device checkpoint stream size.
	DevCptStreamSize int64 `xml:"devCptStreamSize,omitempty" json:"devCptStreamSize,omitempty"`
	// Device checkpoint stream time.
	DevCptStreamTime int64 `xml:"devCptStreamTime,omitempty" json:"devCptStreamTime,omitempty"`
}

func init() {
	t["HostVMotionManagerDstInstantCloneResult"] = reflect.TypeOf((*HostVMotionManagerDstInstantCloneResult)(nil)).Elem()
}

// The result of an InstantClone InitiateSource task.
//
// Contains the timestamp
// value at the time of different operations.
type HostVMotionManagerSrcInstantCloneResult struct {
	DynamicData

	// Time stamp at the start of the InstantClone operation at the
	// source VM.
	StartTime int64 `xml:"startTime,omitempty" json:"startTime,omitempty"`
	// Time stamp when the source VM enters quiesce state.
	QuiesceTime int64 `xml:"quiesceTime,omitempty" json:"quiesceTime,omitempty"`
	// Time stamp when the source VM successfully quiesces.
	QuiesceDoneTime int64 `xml:"quiesceDoneTime,omitempty" json:"quiesceDoneTime,omitempty"`
	// Time stamp when the source VM completes resuming.
	ResumeDoneTime int64 `xml:"resumeDoneTime,omitempty" json:"resumeDoneTime,omitempty"`
	// Time stamp when the migration completes on the source VM.
	EndTime int64 `xml:"endTime,omitempty" json:"endTime,omitempty"`
}

func init() {
	t["HostVMotionManagerSrcInstantCloneResult"] = reflect.TypeOf((*HostVMotionManagerSrcInstantCloneResult)(nil)).Elem()
}

// The NetConfig data object type contains the networking
// configuration for VMotion operations.
type HostVMotionNetConfig struct {
	DynamicData

	// List of VirtualNic objects that may be used for VMotion.
	//
	// This will be a subset of the list of VirtualNics in
	// `HostNetworkInfo.vnic`.
	CandidateVnic []HostVirtualNic `xml:"candidateVnic,omitempty" json:"candidateVnic,omitempty"`
	// VirtualNic that is selected for use in VMotion operations.
	SelectedVnic string `xml:"selectedVnic,omitempty" json:"selectedVnic,omitempty"`
}

func init() {
	t["HostVMotionNetConfig"] = reflect.TypeOf((*HostVMotionNetConfig)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostVStorageObjectCreateDiskFromSnapshot_Task`.
type HostVStorageObjectCreateDiskFromSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The ID of the snapshot of the virtual storage object.
	SnapshotId ID `xml:"snapshotId" json:"snapshotId"`
	// A user friendly name to be associated with the new disk.
	Name string `xml:"name" json:"name"`
	// SPBM Profile requirement on the new virtual storage object.
	// If not specified datastore default policy would be
	// assigned.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
	// Crypto information of the new disk.
	Crypto BaseCryptoSpec `xml:"crypto,omitempty,typeattr" json:"crypto,omitempty"`
	// Relative location in the specified datastore where disk needs
	// to be created. If not specified disk gets created at defualt
	// VStorageObject location on the specified datastore.
	Path string `xml:"path,omitempty" json:"path,omitempty"`
	// Provisioining type of the disk as specified in above
	// mentioned profile. The list of supported values can be found in
	// `BaseConfigInfoDiskFileBackingInfoProvisioningType_enum`
	ProvisioningType string `xml:"provisioningType,omitempty" json:"provisioningType,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["HostVStorageObjectCreateDiskFromSnapshotRequestType"] = reflect.TypeOf((*HostVStorageObjectCreateDiskFromSnapshotRequestType)(nil)).Elem()
}

type HostVStorageObjectCreateDiskFromSnapshot_Task HostVStorageObjectCreateDiskFromSnapshotRequestType

func init() {
	t["HostVStorageObjectCreateDiskFromSnapshot_Task"] = reflect.TypeOf((*HostVStorageObjectCreateDiskFromSnapshot_Task)(nil)).Elem()
}

type HostVStorageObjectCreateDiskFromSnapshot_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostVStorageObjectManager.HostVStorageObjectCreateSnapshot_Task`.
type HostVStorageObjectCreateSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// A short description to be associated with the snapshot.
	Description string `xml:"description" json:"description"`
}

func init() {
	t["HostVStorageObjectCreateSnapshotRequestType"] = reflect.TypeOf((*HostVStorageObjectCreateSnapshotRequestType)(nil)).Elem()
}

type HostVStorageObjectCreateSnapshot_Task HostVStorageObjectCreateSnapshotRequestType

func init() {
	t["HostVStorageObjectCreateSnapshot_Task"] = reflect.TypeOf((*HostVStorageObjectCreateSnapshot_Task)(nil)).Elem()
}

type HostVStorageObjectCreateSnapshot_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostVStorageObjectManager.HostVStorageObjectDeleteSnapshot_Task`.
type HostVStorageObjectDeleteSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The ID of the snapshot of a virtual storage object.
	SnapshotId ID `xml:"snapshotId" json:"snapshotId"`
}

func init() {
	t["HostVStorageObjectDeleteSnapshotRequestType"] = reflect.TypeOf((*HostVStorageObjectDeleteSnapshotRequestType)(nil)).Elem()
}

type HostVStorageObjectDeleteSnapshot_Task HostVStorageObjectDeleteSnapshotRequestType

func init() {
	t["HostVStorageObjectDeleteSnapshot_Task"] = reflect.TypeOf((*HostVStorageObjectDeleteSnapshot_Task)(nil)).Elem()
}

type HostVStorageObjectDeleteSnapshot_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type HostVStorageObjectRetrieveSnapshotInfo HostVStorageObjectRetrieveSnapshotInfoRequestType

func init() {
	t["HostVStorageObjectRetrieveSnapshotInfo"] = reflect.TypeOf((*HostVStorageObjectRetrieveSnapshotInfo)(nil)).Elem()
}

// The parameters of `HostVStorageObjectManager.HostVStorageObjectRetrieveSnapshotInfo`.
type HostVStorageObjectRetrieveSnapshotInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["HostVStorageObjectRetrieveSnapshotInfoRequestType"] = reflect.TypeOf((*HostVStorageObjectRetrieveSnapshotInfoRequestType)(nil)).Elem()
}

type HostVStorageObjectRetrieveSnapshotInfoResponse struct {
	Returnval VStorageObjectSnapshotInfo `xml:"returnval" json:"returnval"`
}

// The parameters of `HostVStorageObjectManager.HostVStorageObjectRevert_Task`.
type HostVStorageObjectRevertRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The ID of the snapshot of a virtual storage object.
	SnapshotId ID `xml:"snapshotId" json:"snapshotId"`
}

func init() {
	t["HostVStorageObjectRevertRequestType"] = reflect.TypeOf((*HostVStorageObjectRevertRequestType)(nil)).Elem()
}

type HostVStorageObjectRevert_Task HostVStorageObjectRevertRequestType

func init() {
	t["HostVStorageObjectRevert_Task"] = reflect.TypeOf((*HostVStorageObjectRevert_Task)(nil)).Elem()
}

type HostVStorageObjectRevert_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// VFAT file system volume.
type HostVfatVolume struct {
	HostFileSystemVolume
}

func init() {
	t["HostVfatVolume"] = reflect.TypeOf((*HostVfatVolume)(nil)).Elem()
}

// This data object type describes the VFFS
// creation specification.
type HostVffsSpec struct {
	DynamicData

	// The device path of the SSD disk.
	//
	// See also `HostScsiDisk.devicePath`.
	DevicePath string `xml:"devicePath" json:"devicePath"`
	// Partition specification of the SSD disk.
	//
	// If this property
	// is not provided, partition information will be computed
	// and generated.
	Partition *HostDiskPartitionSpec `xml:"partition,omitempty" json:"partition,omitempty"`
	// Major version number of VFFS.
	//
	// This can be changed if the VFFS is
	// upgraded, but this is an irreversible change.
	MajorVersion int32 `xml:"majorVersion" json:"majorVersion"`
	// Volume name of VFFS.
	VolumeName string `xml:"volumeName" json:"volumeName"`
}

func init() {
	t["HostVffsSpec"] = reflect.TypeOf((*HostVffsSpec)(nil)).Elem()
}

// vFlash File System Volume.
type HostVffsVolume struct {
	HostFileSystemVolume

	// Major version number of VFFS.
	MajorVersion int32 `xml:"majorVersion" json:"majorVersion"`
	// Version string.
	//
	// Contains major and minor version numbers.
	Version string `xml:"version" json:"version"`
	// The universally unique identifier assigned to VFFS.
	Uuid string `xml:"uuid" json:"uuid"`
	// The list of partition names that comprise this disk's
	// VFFS extents.
	Extent []HostScsiDiskPartition `xml:"extent" json:"extent"`
}

func init() {
	t["HostVffsVolume"] = reflect.TypeOf((*HostVffsVolume)(nil)).Elem()
}

// The `HostVirtualNic` data object describes a virtual network adapter
// that connects to a virtual switch.
//
// A host virtual NIC differs from a physical NIC:
//   - A host virtual NIC is a virtual device that is connected to a virtual switch.
//   - A physical NIC (`HostNetworkInfo.pnic`) corresponds to a physical
//     device that is connected to the physical network.
//
// A host virtual NIC provides access to the external network through a virtual switch
// that is bridged through a Physical NIC to a physical network.
type HostVirtualNic struct {
	DynamicData

	// Device name.
	Device string `xml:"device" json:"device"`
	// Linkable identifier.
	Key string `xml:"key" json:"key"`
	// If the Virtual NIC is connecting to a vSwitch, this property is the name of
	// portgroup connected.
	//
	// If the Virtual NIC is connecting to a
	// DistributedVirtualSwitch or opaque network, this property is an empty string.
	Portgroup string `xml:"portgroup" json:"portgroup"`
	// Configurable properties for the virtual network adapter object.
	Spec HostVirtualNicSpec `xml:"spec" json:"spec"`
	// Port(`HostPortGroup.port`) on the port group that the virtual
	// NIC is using when it is enabled.
	//
	// If the Virtual NIC is connected to
	// DistributedVirtualSwitch or opaque network, this property is unset.
	Port string `xml:"port,omitempty" json:"port,omitempty"`
}

func init() {
	t["HostVirtualNic"] = reflect.TypeOf((*HostVirtualNic)(nil)).Elem()
}

// The `HostVirtualNicConfig` data object describes the virtual
// NIC configuration.
//
// It represents both the configured properties on a
// `HostVirtualNic` and identification information.
type HostVirtualNicConfig struct {
	DynamicData

	// Change operation to apply on this configuration specification.
	//
	// See also `HostConfigChangeOperation_enum`.
	ChangeOperation string `xml:"changeOperation,omitempty" json:"changeOperation,omitempty"`
	// Virtual NIC device (`HostVirtualNic.device`) to which
	// configuration applies.
	Device string `xml:"device,omitempty" json:"device,omitempty"`
	// If the Virtual NIC is connecting to a vSwitch, this property is the name of
	// portgroup connected.
	//
	// If the Virtual NIC is connecting to a
	// `DistributedVirtualSwitch` or `HostOpaqueNetworkInfo`,
	// this property is ignored.
	Portgroup string `xml:"portgroup" json:"portgroup"`
	// Specification of the virtual network adapter.
	Spec *HostVirtualNicSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["HostVirtualNicConfig"] = reflect.TypeOf((*HostVirtualNicConfig)(nil)).Elem()
}

// DataObject which provides a level of indirection when
// identifying VirtualNics during configuration.
//
// This dataObject lets users specify a VirtualNic in terms of
// the portgroup/Dv Port the Virtual NIC is connected to.
// This is useful in cases where VirtualNic will be created as part of
// a configuration operation and the created VirtualNic is referred to
// in some other part of configuration. e.g: for configuring VMotion
type HostVirtualNicConnection struct {
	DynamicData

	// Name of the portgroup to which the virtual nic is connected to.
	//
	// If this parameter is set, use a virtual nic connected to
	// a legacy portgroup.
	Portgroup string `xml:"portgroup,omitempty" json:"portgroup,omitempty"`
	// Identifier for the DistributedVirtualPort.
	//
	// If the virtual nic is to be connected to a DVS,
	// \#dvPort will be set instead of #portgroup
	DvPort *DistributedVirtualSwitchPortConnection `xml:"dvPort,omitempty" json:"dvPort,omitempty"`
	// Identifier for the opaqueNetworkSpec virtual nic connected to.
	//
	// If the virtual nic is to be connected to a logicSwitch,
	// \#opNetwork will be set instead of #portgroup and #dvPort
	OpNetwork *HostVirtualNicOpaqueNetworkSpec `xml:"opNetwork,omitempty" json:"opNetwork,omitempty"`
}

func init() {
	t["HostVirtualNicConnection"] = reflect.TypeOf((*HostVirtualNicConnection)(nil)).Elem()
}

// The `HostVirtualNicIpRouteSpec` data object describes the
// IpRoute configuration used by virtual NIC.
type HostVirtualNicIpRouteSpec struct {
	DynamicData

	// By default, a host virtual NIC uses default gateway configuration
	// from it's `HostNetStackInstance`.
	//
	// A custom IPv4 and IPv6
	// default gateway can be configured by specifying valid
	// `HostIpRouteConfig.defaultGateway` and
	// `HostIpRouteConfig.ipV6DefaultGateway` properties.
	// A user defined IPv4 and IPv6 default gateway can be removed by
	// unsetting corresponding gateway property from ipRouteConfig.
	IpRouteConfig BaseHostIpRouteConfig `xml:"ipRouteConfig,omitempty,typeattr" json:"ipRouteConfig,omitempty"`
}

func init() {
	t["HostVirtualNicIpRouteSpec"] = reflect.TypeOf((*HostVirtualNicIpRouteSpec)(nil)).Elem()
}

// This data object type describes VirtualNic host
// configuration data objects.
type HostVirtualNicManagerInfo struct {
	DynamicData

	// List of VirtualNicManager network configuration.
	//
	// See also `VirtualNicManagerNetConfig`This contains the network
	// configuration for each NicType..
	NetConfig []VirtualNicManagerNetConfig `xml:"netConfig,omitempty" json:"netConfig,omitempty"`
}

func init() {
	t["HostVirtualNicManagerInfo"] = reflect.TypeOf((*HostVirtualNicManagerInfo)(nil)).Elem()
}

// DataObject which lets a VirtualNic be marked for
// use as a `HostVirtualNicManagerNicType_enum`.
type HostVirtualNicManagerNicTypeSelection struct {
	DynamicData

	// VirtualNic for the selection is being made
	Vnic    HostVirtualNicConnection `xml:"vnic" json:"vnic"`
	NicType []string                 `xml:"nicType,omitempty" json:"nicType,omitempty"`
}

func init() {
	t["HostVirtualNicManagerNicTypeSelection"] = reflect.TypeOf((*HostVirtualNicManagerNicTypeSelection)(nil)).Elem()
}

// The `HostVirtualNicOpaqueNetworkSpec` data object
// describes the opaque network(`HostOpaqueNetworkInfo`)
// configuration used by virtual NIC.
type HostVirtualNicOpaqueNetworkSpec struct {
	DynamicData

	// ID of the Opaque network to which the virtual NIC is connected.
	OpaqueNetworkId string `xml:"opaqueNetworkId" json:"opaqueNetworkId"`
	// Type of the Opaque network to which the virtual NIC is connected.
	OpaqueNetworkType string `xml:"opaqueNetworkType" json:"opaqueNetworkType"`
}

func init() {
	t["HostVirtualNicOpaqueNetworkSpec"] = reflect.TypeOf((*HostVirtualNicOpaqueNetworkSpec)(nil)).Elem()
}

// The `HostVirtualNicSpec` data object describes the
// `HostVirtualNic` configuration containing both the configured
// properties on a virtual NIC and identification information.
type HostVirtualNicSpec struct {
	DynamicData

	// IP configuration on the virtual network adapter.
	Ip *HostIpConfig `xml:"ip,omitempty" json:"ip,omitempty"`
	// Media access control (MAC) address of the virtual network adapter.
	Mac string `xml:"mac,omitempty" json:"mac,omitempty"`
	// `DistributedVirtualPort` or `DistributedVirtualPortgroup`
	// connection.
	//
	// To specify a port connection, set
	// `DistributedVirtualSwitchPortConnection.switchUuid` and `DistributedVirtualSwitchPortConnection.portKey`
	// properties. To specify a portgroup connection, set
	// `DistributedVirtualSwitchPortConnection.switchUuid` and `DistributedVirtualSwitchPortConnection.portgroupKey`
	// properties.
	//
	// When reconfiguring a virtual NIC, this property indicates the new portgroup
	// to which the virtual NIC should connect. You can specify this property
	// only if you do not specify `HostVirtualNicSpec.distributedVirtualPort` and
	// `HostVirtualNicSpec.opaqueNetwork`
	DistributedVirtualPort *DistributedVirtualSwitchPortConnection `xml:"distributedVirtualPort,omitempty" json:"distributedVirtualPort,omitempty"`
	// Portgroup (`HostPortGroup`) to which the virtual NIC is connected.
	//
	// When reconfiguring a virtual NIC, this property indicates the new portgroup
	// to which the virtual NIC should connect. You can specify this property
	// only if you do not specify `HostVirtualNicSpec.distributedVirtualPort` and
	// `HostVirtualNicSpec.opaqueNetwork`
	Portgroup string `xml:"portgroup,omitempty" json:"portgroup,omitempty"`
	// Maximum transmission unit for packets size in bytes for the virtual
	// NIC.
	//
	// If not specified, the Server will use the system default value.
	Mtu int32 `xml:"mtu,omitempty" json:"mtu,omitempty"`
	// Flag enabling or disabling TCP segmentation offset for a virtual NIC.
	//
	// If not specified, a default value of true will be used.
	TsoEnabled *bool `xml:"tsoEnabled" json:"tsoEnabled,omitempty"`
	// The NetStackInstance that the virtual NIC uses, the value of this property
	// is default to be `defaultTcpipStack`
	NetStackInstanceKey string `xml:"netStackInstanceKey,omitempty" json:"netStackInstanceKey,omitempty"`
	// Opaque network (`HostOpaqueNetworkInfo`) to which the
	// virtual NIC is connected.
	//
	// When reconfiguring a virtual NIC, this property indicates the specification
	// of opaque network to which the virtual NIC should connect. You can specify
	// this property only if you do not specify `HostVirtualNicSpec.distributedVirtualPort`
	// and `HostVirtualNicSpec.portgroup`.
	OpaqueNetwork *HostVirtualNicOpaqueNetworkSpec `xml:"opaqueNetwork,omitempty" json:"opaqueNetwork,omitempty"`
	// An ID assigned to the vmkernel adapter by external management plane.
	//
	// The value and format of this property is determined by external management
	// plane, and vSphere doesn't do any validation. It's also up to external
	// management plane to set, unset or maintain this property.
	//
	// This property is applicable only when `HostVirtualNicSpec.opaqueNetwork` property is set,
	// otherwise it's value is ignored.
	ExternalId string `xml:"externalId,omitempty" json:"externalId,omitempty"`
	// The physical nic to which the vmkernel adapter is pinned.
	//
	// Setting this value
	// ensures that the virtual NIC will access external network only via the
	// the specified physical NIC.
	//
	// This property is applicable only when `HostVirtualNicSpec.opaqueNetwork` property is set.
	// If the vmkernel adapter is connected to a portgroup or dvPort, then such
	// pinning can be achieved by configuring correct teaming policy on the portgroup
	// or dvPort or dvPortgroup that is connected to virtual NIC.
	PinnedPnic string `xml:"pinnedPnic,omitempty" json:"pinnedPnic,omitempty"`
	// The ip route configuration used by the vmkernel adapter.
	//
	// This attribute
	// allows the vmkernel adapter to specify its own default gateway.
	IpRouteSpec *HostVirtualNicIpRouteSpec `xml:"ipRouteSpec,omitempty" json:"ipRouteSpec,omitempty"`
	// Set to true when the vmkernel adapter is configured by
	// other system indirectly other than by the user directly.
	SystemOwned *bool `xml:"systemOwned" json:"systemOwned,omitempty"`
	// The identifier of the DPU hosting the vmknic.
	//
	// If vmknic is on ESX host, dpuId will be unset.
	DpuId string `xml:"dpuId,omitempty" json:"dpuId,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["HostVirtualNicSpec"] = reflect.TypeOf((*HostVirtualNicSpec)(nil)).Elem()
}

// The virtual switch is a software entity to which multiple virtual network
// adapters can connect to create a virtual network.
//
// It can also be
// bridged to a physical network.
type HostVirtualSwitch struct {
	DynamicData

	// The name of the virtual switch.
	//
	// Maximum length is 32 characters.
	Name string `xml:"name" json:"name"`
	// The virtual switch key.
	Key string `xml:"key" json:"key"`
	// The number of ports that this virtual switch currently has.
	NumPorts int32 `xml:"numPorts" json:"numPorts"`
	// The number of ports that are available on this virtual switch.
	//
	// There
	// are a number of networking services that utilize a port on the virtual
	// switch and are not accounted for in the Port array of a PortGroup. For
	// example, each physical NIC attached to a virtual switch consumes one
	// port. This property should be used when attempting to implement
	// admission control for new services attaching to virtual switches.
	NumPortsAvailable int32 `xml:"numPortsAvailable" json:"numPortsAvailable"`
	// The maximum transmission unit (MTU) associated with this virtual switch
	// in bytes.
	Mtu int32 `xml:"mtu,omitempty" json:"mtu,omitempty"`
	// The list of port groups configured for this virtual switch.
	Portgroup []string `xml:"portgroup,omitempty" json:"portgroup,omitempty"`
	// The set of physical network adapters associated with this bridge.
	Pnic []string `xml:"pnic,omitempty" json:"pnic,omitempty"`
	// The specification of this virtual switch.
	Spec HostVirtualSwitchSpec `xml:"spec" json:"spec"`
}

func init() {
	t["HostVirtualSwitch"] = reflect.TypeOf((*HostVirtualSwitch)(nil)).Elem()
}

// This data type describes a bridge that automatically selects
// a particular physical network adapter on the host
// according to some predetermined policy.
//
// Used primarily to support mobility
// scenarios.
type HostVirtualSwitchAutoBridge struct {
	HostVirtualSwitchBridge

	// List of physical network adapters that have been excluded from
	// participating in the AutoBridge
	ExcludedNicDevice []string `xml:"excludedNicDevice,omitempty" json:"excludedNicDevice,omitempty"`
}

func init() {
	t["HostVirtualSwitchAutoBridge"] = reflect.TypeOf((*HostVirtualSwitchAutoBridge)(nil)).Elem()
}

// This data object type describes the configuration of the beacon
// to probe connectivity of physical network adapters.
//
// A
// beacon is sent out of one network adapter and should arrive on another
// network adapter in the team. The successful roundtrip indicates
// that the network adapters are working.
//
// Define this data object to enable beacon probing as a method to validate
// the link status of a physical network adapter. Beacon probing must
// be configured in order to use the beacon status as a criteria to
// determine if a physical network adapter failed.
//
// See also `HostNicFailureCriteria.checkBeacon`.
type HostVirtualSwitchBeaconConfig struct {
	DynamicData

	// Determines how often, in seconds, a beacon should be sent.
	Interval int32 `xml:"interval" json:"interval"`
}

func init() {
	t["HostVirtualSwitchBeaconConfig"] = reflect.TypeOf((*HostVirtualSwitchBeaconConfig)(nil)).Elem()
}

// This data object type describes a bridge that provides
// network adapter teaming capabilities.
type HostVirtualSwitchBondBridge struct {
	HostVirtualSwitchBridge

	// The list of keys of the physical network adapters to be bridged.
	NicDevice []string `xml:"nicDevice" json:"nicDevice"`
	// The beacon configuration to probe for the validity of a link.
	//
	// If this is set, beacon probing is configured and will be used.
	// If this is not set, beacon probing is disabled.
	Beacon *HostVirtualSwitchBeaconConfig `xml:"beacon,omitempty" json:"beacon,omitempty"`
	// The link discovery protocol configuration for the virtual switch.
	//
	// See also `LinkDiscoveryProtocolConfig`.
	LinkDiscoveryProtocolConfig *LinkDiscoveryProtocolConfig `xml:"linkDiscoveryProtocolConfig,omitempty" json:"linkDiscoveryProtocolConfig,omitempty"`
}

func init() {
	t["HostVirtualSwitchBondBridge"] = reflect.TypeOf((*HostVirtualSwitchBondBridge)(nil)).Elem()
}

// A bridge connects a virtual switch to a physical network adapter.
//
// There are multiple types of bridges.
type HostVirtualSwitchBridge struct {
	DynamicData
}

func init() {
	t["HostVirtualSwitchBridge"] = reflect.TypeOf((*HostVirtualSwitchBridge)(nil)).Elem()
}

// This data object type describes the VirtualSwitch configuration
// containing both the configurable
// properties on a VirtualSwitch and identification information.
type HostVirtualSwitchConfig struct {
	DynamicData

	// This property indicates the change operation to apply on
	// this configuration specification.
	//
	// See also `HostConfigChangeOperation_enum`.
	ChangeOperation string `xml:"changeOperation,omitempty" json:"changeOperation,omitempty"`
	// The name of the virtual switch.
	//
	// Maximum length is 32 characters.
	Name string `xml:"name" json:"name"`
	// The specification of the VirtualSwitch.
	Spec *HostVirtualSwitchSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["HostVirtualSwitchConfig"] = reflect.TypeOf((*HostVirtualSwitchConfig)(nil)).Elem()
}

// A bridge that is statically bound to a single physical network adapter.
type HostVirtualSwitchSimpleBridge struct {
	HostVirtualSwitchBridge

	// The key of the physical network adapter to be bridged.
	NicDevice string `xml:"nicDevice" json:"nicDevice"`
}

func init() {
	t["HostVirtualSwitchSimpleBridge"] = reflect.TypeOf((*HostVirtualSwitchSimpleBridge)(nil)).Elem()
}

// This data object type describes the VirtualSwitch specification
// representing the properties on a VirtualSwitch that can be
// configured once the object exists.
type HostVirtualSwitchSpec struct {
	DynamicData

	// The number of ports that this virtual switch is configured to use.
	//
	// Changing this setting does not take effect until the next reboot. The maximum
	// value is 1024, although other constraints, such as memory limits, may establish
	// a lower effective limit.
	NumPorts int32 `xml:"numPorts" json:"numPorts"`
	// The bridge specification describes how physical network adapters
	// can be bridged to a virtual switch.
	Bridge BaseHostVirtualSwitchBridge `xml:"bridge,omitempty,typeattr" json:"bridge,omitempty"`
	// The virtual switch policy specification.
	//
	// This has a lower
	// precedence than PortGroup. If the policy property is not set
	// and you are creating a virtual switch, then a default
	// policy property setting is used. If the policy property is not
	// set and you are updating a virtual switch, then the policy will
	// be unchanged.
	Policy *HostNetworkPolicy `xml:"policy,omitempty" json:"policy,omitempty"`
	// The maximum transmission unit (MTU) of the virtual switch in bytes.
	Mtu int32 `xml:"mtu,omitempty" json:"mtu,omitempty"`
}

func init() {
	t["HostVirtualSwitchSpec"] = reflect.TypeOf((*HostVirtualSwitchSpec)(nil)).Elem()
}

// The AccessSpec data object declares an update to the service
// access granted to a VM.
//
// The given list of services will either
// be granted in addition to existing services, replace the
// existing service or be revoked depending on the mode
// specified. In case of a revoke, an empty or non-existing service
// list indicates that all granted services should be revoked.
type HostVmciAccessManagerAccessSpec struct {
	DynamicData

	// Refers instance of `VirtualMachine`.
	Vm       ManagedObjectReference `xml:"vm" json:"vm"`
	Services []string               `xml:"services,omitempty" json:"services,omitempty"`
	Mode     string                 `xml:"mode" json:"mode"`
}

func init() {
	t["HostVmciAccessManagerAccessSpec"] = reflect.TypeOf((*HostVmciAccessManagerAccessSpec)(nil)).Elem()
}

// When a user resignatures an UnresolvedVmfsVolume through DatastoreSystem API,
// we resignature and auto-mount on the other hosts which share the
// same underlying storage luns.
//
// As part of the operation, we rescan host.
// This data object describes the outcome of rescan operation on a host
type HostVmfsRescanResult struct {
	DynamicData

	// Host name on which rescan was performed
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// 'fault' would be set if the operation was not successful
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["HostVmfsRescanResult"] = reflect.TypeOf((*HostVmfsRescanResult)(nil)).Elem()
}

// This data object type describes the VMware File System (VMFS)
// creation specification.
//
// Once created, these properties for the most
// part cannot be changed. There are a few exceptions.
type HostVmfsSpec struct {
	DynamicData

	// Head extent of VMFS.
	//
	// The head extent identifies the VMFS. However,
	// the head extent should not be used to identify the VMFS across host
	// reboots. The actual identifier is specified in "vmhbaI:T:L" format
	// which is not guaranteed to be stable across reboots. Define a volume
	// name that is unique to the host and use it to refer to the VMFS.
	// Alternatively, the immutable UUID of the VMFS can be used after it
	// is created.
	Extent HostScsiDiskPartition `xml:"extent" json:"extent"`
	// Deprecated as of vSphere API 6.5, use
	// `HostVmfsSpec.blockSize` instead.
	//
	// The block size of VMFS in megabytes (MB).
	//
	// Determines the maximum file
	// size. If this optional property is not set, the maximum
	// file size defaults to the maximum file size for the platform.
	//
	// In VMFS2, the valid block sizes 1MB, 2MB, 4MB, 8MB, 16MB, 32MB, 64MB,
	// 128MB, and 256MB.
	// In VMFS3, the valid block sizes are 1MB, 2MB, 4MB, and 8MB.
	// In VMFS5, the only valid block size is 1MB.
	BlockSizeMb int32 `xml:"blockSizeMb,omitempty" json:"blockSizeMb,omitempty"`
	// Major version number of VMFS.
	//
	// This can be changed if the VMFS is
	// upgraded, but this is an irreversible change.
	MajorVersion int32 `xml:"majorVersion" json:"majorVersion"`
	// Volume name of VMFS.
	VolumeName string `xml:"volumeName" json:"volumeName"`
	// The block size of VMFS in kilotypes (KB).
	//
	// Determines the maximum file
	// size. If this optional property is not set, the maximum
	// file size defaults to the maximum file size for the platform.
	//
	// In VMFS3, the valid block sizes are 1MB, 2MB, 4MB, and 8MB.
	// In VMFS5, the only valid block size is 1MB.
	// In VMFS6, the valid block sizes are 64KB and 1MB.
	BlockSize int32 `xml:"blockSize,omitempty" json:"blockSize,omitempty"`
	// The granularity of VMFS unmap operations.
	//
	// VMFS unmap reclaims
	// unused storage space.
	// The unit is KB. The minimum unmap granularity is 8KB. The maximum
	// unmap granularity is determined by the block size of VMFS
	// `HostVmfsVolume.blockSize`.
	UnmapGranularity int32 `xml:"unmapGranularity,omitempty" json:"unmapGranularity,omitempty"`
	// VMFS unmap priority.
	//
	// VMFS unmap reclaims unused storage space. This
	// determines the processing rate of unmaps.
	// See `HostVmfsVolumeUnmapPriority_enum` for supported values.
	UnmapPriority string `xml:"unmapPriority,omitempty" json:"unmapPriority,omitempty"`
	// VMFS unmap bandwidth related specification.
	//
	// See
	// `VmfsUnmapBandwidthSpec` for detail.
	UnmapBandwidthSpec *VmfsUnmapBandwidthSpec `xml:"unmapBandwidthSpec,omitempty" json:"unmapBandwidthSpec,omitempty"`
}

func init() {
	t["HostVmfsSpec"] = reflect.TypeOf((*HostVmfsSpec)(nil)).Elem()
}

// The VMFS file system.
type HostVmfsVolume struct {
	HostFileSystemVolume

	// Deprecated as of vSphere API 6.5, use
	// `HostVmfsVolume.blockSize` instead.
	//
	// Block size of VMFS.
	//
	// Determines maximum file size. The maximum number
	// of blocks is typically fixed with each specific version of VMFS. To
	// increase the maximum size of a VMFS file, increase the block size.
	//
	// The minimum block size is 1MB.
	BlockSizeMb int32 `xml:"blockSizeMb" json:"blockSizeMb"`
	// Block size of VMFS in KB.
	//
	// Determines maximum file size. The maximum
	// number of blocks is typically fixed with each specific version of VMFS.
	// To increase the maximum size of a VMFS file, increase the block size.
	//
	// The minimum block size is 1MB.
	BlockSize int32 `xml:"blockSize,omitempty" json:"blockSize,omitempty"`
	// VMFS unmap reclaims unused storage space.
	//
	// This property
	// determines the granularity of unmap operations.
	// The unit is KB. If not specified, the default value is the same as
	// the block size of VMFS `HostVmfsVolume.blockSize`.
	// This property cannot be changed after a VMFS volume is created.
	UnmapGranularity int32 `xml:"unmapGranularity,omitempty" json:"unmapGranularity,omitempty"`
	// VMFS unmap reclaims unused storage space.
	//
	// This property
	// determines the processing rate of unmaps.
	// See `HostVmfsVolumeUnmapPriority_enum` for supported values.
	// If not specified, the default value is
	// `low`, which means
	// unmap is processed at low rate. This property can be updated by
	// calling `HostStorageSystem.UpdateVmfsUnmapPriority`.
	UnmapPriority string `xml:"unmapPriority,omitempty" json:"unmapPriority,omitempty"`
	// VMFS unmap bandwidth related specification.
	//
	// See
	// `VmfsUnmapBandwidthSpec` for detail.
	UnmapBandwidthSpec *VmfsUnmapBandwidthSpec `xml:"unmapBandwidthSpec,omitempty" json:"unmapBandwidthSpec,omitempty"`
	// Maximum number of blocks.
	//
	// Determines maximum file size along
	// with blockSize. See information about the blockSize.
	MaxBlocks int32 `xml:"maxBlocks" json:"maxBlocks"`
	// Major version number of VMFS.
	MajorVersion int32 `xml:"majorVersion" json:"majorVersion"`
	// Version string.
	//
	// Contains major and minor version numbers.
	Version string `xml:"version" json:"version"`
	// The universally unique identifier assigned to VMFS.
	Uuid string `xml:"uuid" json:"uuid"`
	// The list of partition names that comprise this disk's
	// VMFS extents.
	//
	// This property can be accessed via various enclosing objects.
	// In VirtualCenter, where it can be accessed from multiple
	// hosts, the value of this property may differ according to the context
	// in which it is accessed. When accessed from the
	// `VmfsDatastoreInfo` object, in VirtualCenter, this
	// property reflects the extent information of any one of the hosts visible
	// to the datastore.
	//
	// For a VirtualCenter system which manages ESX Server 2.x and
	// ESX Server 3.x hosts, this extent information is only correlatable
	// across hosts if the extents are exposed on the same adapter on all hosts
	// which can access them. To find the extent names for a specific host,
	// this same property should be accessed via the host's
	// `HostFileSystemVolume` object, by correlating the uuid of
	// the VMFS datastore in the VmfsDatastoreInfo object to the uuid in the
	// FileSystemVolume object.
	//
	// For a Virtual Center system which manages only ESX Server hosts with
	// versions 4.0 onwards , this extent information is correlatable across
	// hosts, irrespective of the adapters the extents are exposed on.
	Extent []HostScsiDiskPartition `xml:"extent" json:"extent"`
	// Can the filesystem be upgraded to a newer version.
	//
	// See also `HostStorageSystem.UpgradeVmfs`.
	VmfsUpgradable bool `xml:"vmfsUpgradable" json:"vmfsUpgradable"`
	// Information about 'forceMounted' VmfsVolume.
	//
	// When the system detects a copy of a VmfsVolume, it will not be
	// auto-mounted on the host and it will be detected as
	// 'UnresolvedVmfsVolume'. If user decides to 'forceMount' the
	// VmfsVolume on the host, forceMountedInfo will be populated.
	// It will not be set for automounted VMFS volumes.
	ForceMountedInfo *HostForceMountedInfo `xml:"forceMountedInfo,omitempty" json:"forceMountedInfo,omitempty"`
	// Indicates whether the volume is SSD backed.
	//
	// If unset, the information whether the volume is SSD backed is unknown.
	Ssd *bool `xml:"ssd" json:"ssd,omitempty"`
	// Indicates whether the volume is backed by local disk.
	//
	// If unset, the information of the volume is local-disk backed is unknown.
	Local *bool `xml:"local" json:"local,omitempty"`
	// The type of disk drives.
	//
	// See `ScsiDiskType_enum`
	// for supported types.
	// If unset, the default disk drive type is
	// `native512`.
	ScsiDiskType string `xml:"scsiDiskType,omitempty" json:"scsiDiskType,omitempty"`
}

func init() {
	t["HostVmfsVolume"] = reflect.TypeOf((*HostVmfsVolume)(nil)).Elem()
}

// This event records when some host Virtual NICs were reconfigured to use
// DVPorts with port level configuration, which might be different
// from the DVportgroup.
type HostVnicConnectedToCustomizedDVPortEvent struct {
	HostEvent

	// Information about the Virtual NIC that is using the DVport.
	Vnic VnicPortArgument `xml:"vnic" json:"vnic"`
	// Information about the previous Virtual NIC that is using the DVport.
	PrevPortKey string `xml:"prevPortKey,omitempty" json:"prevPortKey,omitempty"`
}

func init() {
	t["HostVnicConnectedToCustomizedDVPortEvent"] = reflect.TypeOf((*HostVnicConnectedToCustomizedDVPortEvent)(nil)).Elem()
}

// All fields in the CMMDS Query spec are optional, but at least one needs
// specified to make a valid query.
type HostVsanInternalSystemCmmdsQuery struct {
	DynamicData

	// CMMDS type, e.g.
	//
	// DOM\_OBJECT, LSOM\_OBJECT, POLICY, DISK etc.
	Type string `xml:"type,omitempty" json:"type,omitempty"`
	// UUID of the entry.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// UUID of the owning node.
	Owner string `xml:"owner,omitempty" json:"owner,omitempty"`
}

func init() {
	t["HostVsanInternalSystemCmmdsQuery"] = reflect.TypeOf((*HostVsanInternalSystemCmmdsQuery)(nil)).Elem()
}

// Result of DeleteVsanObjects.
type HostVsanInternalSystemDeleteVsanObjectsResult struct {
	DynamicData

	// UUID of the VSAN object.
	Uuid string `xml:"uuid" json:"uuid"`
	// Indicates success or failure of object deletion.
	Success bool `xml:"success" json:"success"`
	// List of LocalizableMessages with the failure vobs.
	//
	// This is unset if delete is successful.
	FailureReason []LocalizableMessage `xml:"failureReason,omitempty" json:"failureReason,omitempty"`
}

func init() {
	t["HostVsanInternalSystemDeleteVsanObjectsResult"] = reflect.TypeOf((*HostVsanInternalSystemDeleteVsanObjectsResult)(nil)).Elem()
}

// Operation result for a VSAN object upon failure.
type HostVsanInternalSystemVsanObjectOperationResult struct {
	DynamicData

	// The UUID of the in question VSAN object.
	Uuid string `xml:"uuid" json:"uuid"`
	// List of LocalizableMessages with the failure vobs.
	FailureReason []LocalizableMessage `xml:"failureReason,omitempty" json:"failureReason,omitempty"`
}

func init() {
	t["HostVsanInternalSystemVsanObjectOperationResult"] = reflect.TypeOf((*HostVsanInternalSystemVsanObjectOperationResult)(nil)).Elem()
}

// Result structure for a VSAN Physical Disk Diagnostics run.
//
// Specifies the
// result of a single disk.
type HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult struct {
	DynamicData

	// VSAN Disk UUID of the checked disk.
	DiskUuid string `xml:"diskUuid" json:"diskUuid"`
	// Indicates success or failure of object creation on the disk.
	Success bool `xml:"success" json:"success"`
	// A failure reason type, in case of failure.
	FailureReason string `xml:"failureReason,omitempty" json:"failureReason,omitempty"`
}

func init() {
	t["HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult"] = reflect.TypeOf((*HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult)(nil)).Elem()
}

type HostVvolNQN struct {
	DynamicData

	TargetNQN    string `xml:"targetNQN" json:"targetNQN"`
	StorageArray string `xml:"storageArray" json:"storageArray"`
	Online       bool   `xml:"online" json:"online"`
}

func init() {
	t["HostVvolNQN"] = reflect.TypeOf((*HostVvolNQN)(nil)).Elem()
	minAPIVersionForType["HostVvolNQN"] = "8.0.2.0"
}

type HostVvolVolume struct {
	HostFileSystemVolume

	// The universally unique identifier assigned to vvolDS.
	ScId   string       `xml:"scId" json:"scId"`
	HostPE []VVolHostPE `xml:"hostPE,omitempty" json:"hostPE,omitempty"`
	// Virtual Protocol endpoints for this volume
	HostVvolNQN []HostVvolVolumeHostVvolNQN `xml:"hostVvolNQN,omitempty" json:"hostVvolNQN,omitempty" vim:"8.0.2.0"`
	// VASA Providers that manage this volume
	VasaProviderInfo []VimVasaProviderInfo `xml:"vasaProviderInfo,omitempty" json:"vasaProviderInfo,omitempty"`
	// List of storage array serving this VVol based storage container
	StorageArray []VASAStorageArray `xml:"storageArray,omitempty" json:"storageArray,omitempty"`
	// Backing protocol of the datastore
	ProtocolEndpointType string `xml:"protocolEndpointType,omitempty" json:"protocolEndpointType,omitempty" vim:"8.0.0.0"`
	// vVol NQN field availability
	VvolNQNFieldsAvailable *bool `xml:"vvolNQNFieldsAvailable" json:"vvolNQNFieldsAvailable,omitempty" vim:"8.0.2.0"`
	// if set to true, indicates a stretched container
	Stretched *bool `xml:"stretched" json:"stretched,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["HostVvolVolume"] = reflect.TypeOf((*HostVvolVolume)(nil)).Elem()
}

type HostVvolVolumeHostVvolNQN struct {
	DynamicData

	// The host associated with this volume.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// Host-specific information about the virtual ProtocolEndpoint.
	VvolNQN []HostVvolNQN `xml:"vvolNQN,omitempty" json:"vvolNQN,omitempty"`
}

func init() {
	t["HostVvolVolumeHostVvolNQN"] = reflect.TypeOf((*HostVvolVolumeHostVvolNQN)(nil)).Elem()
	minAPIVersionForType["HostVvolVolumeHostVvolNQN"] = "8.0.2.0"
}

type HostVvolVolumeSpecification struct {
	DynamicData

	// Maximum size of the container
	MaxSizeInMB int64 `xml:"maxSizeInMB" json:"maxSizeInMB"`
	// Container name.
	VolumeName string `xml:"volumeName" json:"volumeName"`
	// VASA Providers that manage this volume
	VasaProviderInfo []VimVasaProviderInfo `xml:"vasaProviderInfo,omitempty" json:"vasaProviderInfo,omitempty"`
	// Storage Array
	StorageArray []VASAStorageArray `xml:"storageArray,omitempty" json:"storageArray,omitempty"`
	// Vendor specified storage-container ID
	Uuid string `xml:"uuid" json:"uuid"`
	// if set to true, indicates a stretched container
	Stretched *bool `xml:"stretched" json:"stretched,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["HostVvolVolumeSpecification"] = reflect.TypeOf((*HostVvolVolumeSpecification)(nil)).Elem()
}

// This event records a change in a host's WWN (World Wide Name).
type HostWwnChangedEvent struct {
	HostEvent

	// The old node WWN.
	OldNodeWwns []int64 `xml:"oldNodeWwns,omitempty" json:"oldNodeWwns,omitempty"`
	// The old port WWN.
	OldPortWwns []int64 `xml:"oldPortWwns,omitempty" json:"oldPortWwns,omitempty"`
	// The new node WWN.
	NewNodeWwns []int64 `xml:"newNodeWwns,omitempty" json:"newNodeWwns,omitempty"`
	// The new port WWN.
	NewPortWwns []int64 `xml:"newPortWwns,omitempty" json:"newPortWwns,omitempty"`
}

func init() {
	t["HostWwnChangedEvent"] = reflect.TypeOf((*HostWwnChangedEvent)(nil)).Elem()
}

// This event records a conflict of host WWNs (World Wide Name).
type HostWwnConflictEvent struct {
	HostEvent

	// The virtual machine whose WWN conflicts with the
	// current host's WWN.
	ConflictedVms []VmEventArgument `xml:"conflictedVms,omitempty" json:"conflictedVms,omitempty"`
	// The host whose physical WWN conflicts with the
	// current host's WWN.
	ConflictedHosts []HostEventArgument `xml:"conflictedHosts,omitempty" json:"conflictedHosts,omitempty"`
	// The WWN in conflict.
	Wwn int64 `xml:"wwn" json:"wwn"`
}

func init() {
	t["HostWwnConflictEvent"] = reflect.TypeOf((*HostWwnConflictEvent)(nil)).Elem()
}

// An attempt is being made to move a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host because the virtual machine is currently powered on.
type HotSnapshotMoveNotSupported struct {
	SnapshotCopyNotSupported
}

func init() {
	t["HotSnapshotMoveNotSupported"] = reflect.TypeOf((*HotSnapshotMoveNotSupported)(nil)).Elem()
}

type HotSnapshotMoveNotSupportedFault HotSnapshotMoveNotSupported

func init() {
	t["HotSnapshotMoveNotSupportedFault"] = reflect.TypeOf((*HotSnapshotMoveNotSupportedFault)(nil)).Elem()
}

// The `HourlyTaskScheduler` data object sets the time for hourly
// task execution.
//
// By default, the scheduled task will run once every hour,
// at the specified minute.
//
// If you set the interval to a value greater than 1, the task will
// execute at the specified hourly interval. (For example, an interval
// of 2 will cause the task to execute at the specified minute every 2 hours.)
type HourlyTaskScheduler struct {
	RecurrentTaskScheduler

	// The minute at which the `RecurrentTaskScheduler` runs
	// the task.
	//
	// Specify the minute value as a UTC (Coordinated Universal Time)
	// value in the range 0 to 59.
	//
	// For vCenter 2.x and prior releases, use the server's local time.
	// For example, use Australia Northern Territory (UTC +9:30) or Indian (UTC +5:30)
	// time values, rather than a UTC value.
	Minute int32 `xml:"minute" json:"minute"`
}

func init() {
	t["HourlyTaskScheduler"] = reflect.TypeOf((*HourlyTaskScheduler)(nil)).Elem()
}

// Generic base class for outbound HTTP communication errors.
type HttpFault struct {
	VimFault

	// HTTP status code received from external web-server.
	StatusCode int32 `xml:"statusCode" json:"statusCode"`
	// HTTP status message received from external web-server.
	StatusMessage string `xml:"statusMessage" json:"statusMessage"`
}

func init() {
	t["HttpFault"] = reflect.TypeOf((*HttpFault)(nil)).Elem()
}

type HttpFaultFault HttpFault

func init() {
	t["HttpFaultFault"] = reflect.TypeOf((*HttpFaultFault)(nil)).Elem()
}

type HttpNfcLeaseAbort HttpNfcLeaseAbortRequestType

func init() {
	t["HttpNfcLeaseAbort"] = reflect.TypeOf((*HttpNfcLeaseAbort)(nil)).Elem()
}

// The parameters of `HttpNfcLease.HttpNfcLeaseAbort`.
type HttpNfcLeaseAbortRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] The fault that caused the abort, if any.
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["HttpNfcLeaseAbortRequestType"] = reflect.TypeOf((*HttpNfcLeaseAbortRequestType)(nil)).Elem()
}

type HttpNfcLeaseAbortResponse struct {
}

// Descriptor of the lease capabilities.
type HttpNfcLeaseCapabilities struct {
	DynamicData

	// True if overall this lease can be upgraded to pull mode and
	// all hosts in this lease support pull mode.
	//
	// Prerequisite before calling pullFromUrls.
	PullModeSupported bool `xml:"pullModeSupported" json:"pullModeSupported"`
	// True if all hosts in the lease support HTTP CORS.
	CorsSupported bool `xml:"corsSupported" json:"corsSupported"`
}

func init() {
	t["HttpNfcLeaseCapabilities"] = reflect.TypeOf((*HttpNfcLeaseCapabilities)(nil)).Elem()
}

type HttpNfcLeaseComplete HttpNfcLeaseCompleteRequestType

func init() {
	t["HttpNfcLeaseComplete"] = reflect.TypeOf((*HttpNfcLeaseComplete)(nil)).Elem()
}

type HttpNfcLeaseCompleteRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["HttpNfcLeaseCompleteRequestType"] = reflect.TypeOf((*HttpNfcLeaseCompleteRequestType)(nil)).Elem()
}

type HttpNfcLeaseCompleteResponse struct {
}

// For a given datastore, represented by datastoreKey, contains a list of leased
// multi-POST-capable hosts connected to it.
type HttpNfcLeaseDatastoreLeaseInfo struct {
	DynamicData

	// Datastore key.
	DatastoreKey string `xml:"datastoreKey" json:"datastoreKey"`
	// List of hosts connected to this datastore and covered by this lease.
	//
	// The
	// hosts in this list are multi-POST-capable, and any one of them can be used
	// to transfer disks on this datastore.
	Hosts []HttpNfcLeaseHostInfo `xml:"hosts" json:"hosts"`
}

func init() {
	t["HttpNfcLeaseDatastoreLeaseInfo"] = reflect.TypeOf((*HttpNfcLeaseDatastoreLeaseInfo)(nil)).Elem()
}

// Provides a mapping from logical device IDs to upload/download
// URLs.
//
// For export, a single device id is returned based on the object
// identifiers for the objects.
//
// For import, two device ids are returned. One based on the object
// names used in the ImportSpec, and one based on the object
// identifiers for the created objects. This is immutable and would
// match the id if an ExportLease is latter created.
type HttpNfcLeaseDeviceUrl struct {
	DynamicData

	// The immutable identifier for the device.
	//
	// This is set for both import/export
	// leases.
	Key string `xml:"key" json:"key"`
	// Identifies the device based on the names in an ImportSpec.
	//
	// This is only
	// set for import leases.
	ImportKey string `xml:"importKey" json:"importKey"`
	// The URL to use to upload/download the device content.
	//
	// The returned url contains either an IP address, a hostname or a "\*". If a
	// "\*" is returned the client must substitutes the "\*" with the hostname
	// or IP address used when connecting to the server.
	// For example if the client connected to "someHost" and the device
	// url returned is:
	//
	//	http:// *:somePort/somePath
	//
	// the client must substitute the "\*" with "someHost" before use. The resulting
	// url would be:
	//
	//	http://someHost:somePort/somePath
	//
	// The server cannot return a valid hostname or IP address when the client
	// connects via a NAT, a proxy, or when the server is multihomed.
	Url string `xml:"url" json:"url"`
	// SSL thumbprint for the host the URL refers to.
	//
	// Empty if no SSL thumbprint
	// is available or needed.
	SslThumbprint string `xml:"sslThumbprint" json:"sslThumbprint"`
	// Optional value to specify if the attached file is a disk in
	// vmdk format.
	Disk *bool `xml:"disk" json:"disk,omitempty"`
	// Id for this target.
	//
	// This only used for multi-POSTing, where a single HTTP
	// POST is applied to multiple targets.
	TargetId string `xml:"targetId,omitempty" json:"targetId,omitempty"`
	// Key for the datastore this disk is on.
	//
	// This is used to look up hosts
	// which can be used to multi-POST disk contents, in the host map of the
	// lease.
	DatastoreKey string `xml:"datastoreKey,omitempty" json:"datastoreKey,omitempty"`
	// Specifies the size of the file backing for this device.
	//
	// This property
	// is only set for non-disk file backings.
	FileSize int64 `xml:"fileSize,omitempty" json:"fileSize,omitempty"`
}

func init() {
	t["HttpNfcLeaseDeviceUrl"] = reflect.TypeOf((*HttpNfcLeaseDeviceUrl)(nil)).Elem()
}

type HttpNfcLeaseGetManifest HttpNfcLeaseGetManifestRequestType

func init() {
	t["HttpNfcLeaseGetManifest"] = reflect.TypeOf((*HttpNfcLeaseGetManifest)(nil)).Elem()
}

type HttpNfcLeaseGetManifestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["HttpNfcLeaseGetManifestRequestType"] = reflect.TypeOf((*HttpNfcLeaseGetManifestRequestType)(nil)).Elem()
}

type HttpNfcLeaseGetManifestResponse struct {
	Returnval []HttpNfcLeaseManifestEntry `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// Contains information about how to connect to a given host.
type HttpNfcLeaseHostInfo struct {
	DynamicData

	// The host url will be of the form
	//
	//	https://hostname/nfc/ticket id/
	//
	// The url can be used for both POST requests to a single device and for
	// multi-POST requests to multiple devices. A single-POST URL is formed
	// by adding the target id to the hostUrl:
	//
	//	https://hostname/nfc/ticket id/target id
	//
	// a multi-POST URL looks like
	//
	//	https://hostname/nfc/ticket id/multi?targets=id1,id2,id3,...
	Url string `xml:"url" json:"url"`
	// SSL thumbprint for the host the URL refers to.
	//
	// Empty if no SSL thumbprint
	// is available or needed.
	SslThumbprint string `xml:"sslThumbprint" json:"sslThumbprint"`
}

func init() {
	t["HttpNfcLeaseHostInfo"] = reflect.TypeOf((*HttpNfcLeaseHostInfo)(nil)).Elem()
}

// This class holds information about the lease, such as the entity covered by the
// lease, and HTTP URLs for up/downloading file backings.
type HttpNfcLeaseInfo struct {
	DynamicData

	// The `HttpNfcLease` object this information belongs to.
	//
	// Refers instance of `HttpNfcLease`.
	Lease ManagedObjectReference `xml:"lease" json:"lease"`
	// The `VirtualMachine` or `VirtualApp` this
	// lease covers.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// The deviceUrl property contains a mapping from logical device keys
	// to URLs.
	DeviceUrl []HttpNfcLeaseDeviceUrl `xml:"deviceUrl,omitempty" json:"deviceUrl,omitempty"`
	// Total capacity in kilobytes of all disks in all Virtual Machines
	// covered by this lease.
	//
	// This can be used to track progress when
	// transferring disks.
	TotalDiskCapacityInKB int64 `xml:"totalDiskCapacityInKB" json:"totalDiskCapacityInKB"`
	// Number of seconds before the lease times out.
	//
	// The client extends
	// the lease by calling `HttpNfcLease.HttpNfcLeaseProgress` before
	// the timeout has expired.
	LeaseTimeout int32 `xml:"leaseTimeout" json:"leaseTimeout"`
	// Map of URLs for leased hosts for a given datastore.
	//
	// This is used to
	// look up multi-POST-capable hosts for a datastore.
	HostMap []HttpNfcLeaseDatastoreLeaseInfo `xml:"hostMap,omitempty" json:"hostMap,omitempty"`
}

func init() {
	t["HttpNfcLeaseInfo"] = reflect.TypeOf((*HttpNfcLeaseInfo)(nil)).Elem()
}

// Provides a manifest for downloaded (exported) files and disks.
type HttpNfcLeaseManifestEntry struct {
	DynamicData

	// Key used to match this entry with the corresponding `HttpNfcLeaseDeviceUrl`
	// entry in `HttpNfcLease.info`.
	Key string `xml:"key" json:"key"`
	// SHA-1 checksum of the data stream sent from the server.
	//
	// This can be used
	// to verify that the bytes received by the client match those sent by the
	// HttpNfc server.
	Sha1 string `xml:"sha1" json:"sha1"`
	// Checksum of the data stream sent/recieved by host.
	//
	// See `HttpNfcLeaseManifestEntryChecksumType_enum` for used algoritm.
	Checksum string `xml:"checksum,omitempty" json:"checksum,omitempty"`
	// Algorithm used to produce checksum in respective property.
	//
	// See `HttpNfcLeaseManifestEntryChecksumType_enum` for supported algorithms.
	ChecksumType string `xml:"checksumType,omitempty" json:"checksumType,omitempty"`
	// Size of the downloaded file.
	Size int64 `xml:"size" json:"size"`
	// True if the downloaded file is a virtual disk backing.
	Disk bool `xml:"disk" json:"disk"`
	// The capacity of the disk, if the file is a virtual disk backing.
	Capacity int64 `xml:"capacity,omitempty" json:"capacity,omitempty"`
	// The populated size of the disk, if the file is a virtual disk backing.
	PopulatedSize int64 `xml:"populatedSize,omitempty" json:"populatedSize,omitempty"`
}

func init() {
	t["HttpNfcLeaseManifestEntry"] = reflect.TypeOf((*HttpNfcLeaseManifestEntry)(nil)).Elem()
}

// Descriptor of ProbeResult
type HttpNfcLeaseProbeResult struct {
	DynamicData

	// True if target host can access the web server.
	ServerAccessible bool `xml:"serverAccessible" json:"serverAccessible"`
}

func init() {
	t["HttpNfcLeaseProbeResult"] = reflect.TypeOf((*HttpNfcLeaseProbeResult)(nil)).Elem()
	minAPIVersionForType["HttpNfcLeaseProbeResult"] = "7.0.2.0"
}

type HttpNfcLeaseProbeUrls HttpNfcLeaseProbeUrlsRequestType

func init() {
	t["HttpNfcLeaseProbeUrls"] = reflect.TypeOf((*HttpNfcLeaseProbeUrls)(nil)).Elem()
}

// The parameters of `HttpNfcLease.HttpNfcLeaseProbeUrls`.
type HttpNfcLeaseProbeUrlsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] List of remote source file descriptors
	// There should be the same number of `HttpNfcLeaseSourceFile`
	// as `HttpNfcLeaseDeviceUrl` provided by this lease.
	Files []HttpNfcLeaseSourceFile `xml:"files,omitempty" json:"files,omitempty"`
	// \[in\] time in seconds for each url validation.
	// Maximum timeout is 60.
	Timeout int32 `xml:"timeout,omitempty" json:"timeout,omitempty"`
}

func init() {
	t["HttpNfcLeaseProbeUrlsRequestType"] = reflect.TypeOf((*HttpNfcLeaseProbeUrlsRequestType)(nil)).Elem()
	minAPIVersionForType["HttpNfcLeaseProbeUrlsRequestType"] = "7.0.2.0"
}

type HttpNfcLeaseProbeUrlsResponse struct {
	Returnval []HttpNfcLeaseProbeResult `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type HttpNfcLeaseProgress HttpNfcLeaseProgressRequestType

func init() {
	t["HttpNfcLeaseProgress"] = reflect.TypeOf((*HttpNfcLeaseProgress)(nil)).Elem()
}

// The parameters of `HttpNfcLease.HttpNfcLeaseProgress`.
type HttpNfcLeaseProgressRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] Completion status represented as an integer
	// in the 0-100 range.
	Percent int32 `xml:"percent" json:"percent"`
}

func init() {
	t["HttpNfcLeaseProgressRequestType"] = reflect.TypeOf((*HttpNfcLeaseProgressRequestType)(nil)).Elem()
}

type HttpNfcLeaseProgressResponse struct {
}

// The parameters of `HttpNfcLease.HttpNfcLeasePullFromUrls_Task`.
type HttpNfcLeasePullFromUrlsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] List of remote source file descriptors
	// There should be the same number of `HttpNfcLeaseSourceFile`
	// as `HttpNfcLeaseDeviceUrl` provided by this lease.
	// Privilege VApp.PullFromUrls is required.
	Files []HttpNfcLeaseSourceFile `xml:"files,omitempty" json:"files,omitempty"`
}

func init() {
	t["HttpNfcLeasePullFromUrlsRequestType"] = reflect.TypeOf((*HttpNfcLeasePullFromUrlsRequestType)(nil)).Elem()
}

type HttpNfcLeasePullFromUrls_Task HttpNfcLeasePullFromUrlsRequestType

func init() {
	t["HttpNfcLeasePullFromUrls_Task"] = reflect.TypeOf((*HttpNfcLeasePullFromUrls_Task)(nil)).Elem()
}

type HttpNfcLeasePullFromUrls_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type HttpNfcLeaseSetManifestChecksumType HttpNfcLeaseSetManifestChecksumTypeRequestType

func init() {
	t["HttpNfcLeaseSetManifestChecksumType"] = reflect.TypeOf((*HttpNfcLeaseSetManifestChecksumType)(nil)).Elem()
}

// The parameters of `HttpNfcLease.HttpNfcLeaseSetManifestChecksumType`.
type HttpNfcLeaseSetManifestChecksumTypeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] Should contain key value pairs:
	// where key is `HttpNfcLeaseDeviceUrl.key` returned in this lease info and value
	// is desired algorithm from `HttpNfcLeaseManifestEntryChecksumType_enum`.
	DeviceUrlsToChecksumTypes []KeyValue `xml:"deviceUrlsToChecksumTypes,omitempty" json:"deviceUrlsToChecksumTypes,omitempty"`
}

func init() {
	t["HttpNfcLeaseSetManifestChecksumTypeRequestType"] = reflect.TypeOf((*HttpNfcLeaseSetManifestChecksumTypeRequestType)(nil)).Elem()
}

type HttpNfcLeaseSetManifestChecksumTypeResponse struct {
}

// Descriptor of the remote source file used in pull scenario.
type HttpNfcLeaseSourceFile struct {
	DynamicData

	// Target device id that will be used to store remote file.
	//
	// Uniquely identifies host, vm and device.
	// Given by this lease in `HttpNfcLeaseDeviceUrl.importKey`.
	TargetDeviceId string `xml:"targetDeviceId" json:"targetDeviceId"`
	// Full url of the source file, for example https://server/path/disk-1.vmdk.
	//
	// Or url to OVA, in that case `HttpNfcLeaseSourceFile.memberName` should be specified.
	Url string `xml:"url" json:"url"`
	// Used only when OVA is specified in `HttpNfcLeaseSourceFile.url`.
	//
	// Should contain file name to extract from OVA.
	MemberName string `xml:"memberName,omitempty" json:"memberName,omitempty"`
	// True if PUT should be used for upload, otherwise POST.
	//
	// Same as `OvfFileItem.create`
	Create bool `xml:"create" json:"create"`
	// Esx has no CA database for checking arbitrary certificates.
	//
	// Client should verify the server certificate and provide
	// certificate thumbprint here.
	SslThumbprint string `xml:"sslThumbprint,omitempty" json:"sslThumbprint,omitempty"`
	// For the case when remote server requires authentication or any other
	// type of custom HTTP headers be provided with the request.
	HttpHeaders []KeyValue `xml:"httpHeaders,omitempty" json:"httpHeaders,omitempty"`
	// Size of the file, if known.
	//
	// Otherwise it will be determined by a HEAD
	// request. Not used for OVA members.
	Size int64 `xml:"size,omitempty" json:"size,omitempty"`
}

func init() {
	t["HttpNfcLeaseSourceFile"] = reflect.TypeOf((*HttpNfcLeaseSourceFile)(nil)).Elem()
}

// This data object type describes an identifier class which
// is globally unique to identify the associated object.
type ID struct {
	DynamicData

	// Id string which is globally unique to identify
	// an object.
	Id string `xml:"id" json:"id"`
}

func init() {
	t["ID"] = reflect.TypeOf((*ID)(nil)).Elem()
}

// Deprecated as of VI API 2.5, use `DeviceControllerNotSupported`.
//
// The virtual machine uses a virtual disk with an IDE controller, but this
// is not supported on the host.
type IDEDiskNotSupported struct {
	DiskNotSupported
}

func init() {
	t["IDEDiskNotSupported"] = reflect.TypeOf((*IDEDiskNotSupported)(nil)).Elem()
}

type IDEDiskNotSupportedFault IDEDiskNotSupported

func init() {
	t["IDEDiskNotSupportedFault"] = reflect.TypeOf((*IDEDiskNotSupportedFault)(nil)).Elem()
}

// A IORMNotSupportedHostOnDatastore fault occurs when the datastore is connected
// to one or more hosts that do not support storage I/O resource management.
type IORMNotSupportedHostOnDatastore struct {
	VimFault

	// The datastore.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The name of the datastore.
	DatastoreName string `xml:"datastoreName" json:"datastoreName"`
	// The list of hosts that do not support storage I/O
	// resource management.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["IORMNotSupportedHostOnDatastore"] = reflect.TypeOf((*IORMNotSupportedHostOnDatastore)(nil)).Elem()
}

type IORMNotSupportedHostOnDatastoreFault IORMNotSupportedHostOnDatastore

func init() {
	t["IORMNotSupportedHostOnDatastoreFault"] = reflect.TypeOf((*IORMNotSupportedHostOnDatastoreFault)(nil)).Elem()
}

// Could not boot from iScsi.
type IScsiBootFailureEvent struct {
	HostEvent
}

func init() {
	t["IScsiBootFailureEvent"] = reflect.TypeOf((*IScsiBootFailureEvent)(nil)).Elem()
}

type ImpersonateUser ImpersonateUserRequestType

func init() {
	t["ImpersonateUser"] = reflect.TypeOf((*ImpersonateUser)(nil)).Elem()
}

// The parameters of `SessionManager.ImpersonateUser`.
type ImpersonateUserRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The user or extension key to impersonate.
	UserName string `xml:"userName" json:"userName"`
	// A two-character ISO-639 language ID (like "en")
	// optionally followed by an
	// underscore and a two-character ISO 3166 country ID (like "US").
	//
	// Examples are "de", "fr\_CA", "zh", "zh\_CN", and "zh\_TW".
	// Note: The method uses the server default locale when
	// a locale is not provided. This default can be configured in the
	// server configuration file. If unspecified, it defaults to the
	// locale of the server environment or English ("en") if unsupported.
	Locale string `xml:"locale,omitempty" json:"locale,omitempty"`
}

func init() {
	t["ImpersonateUserRequestType"] = reflect.TypeOf((*ImpersonateUserRequestType)(nil)).Elem()
}

type ImpersonateUserResponse struct {
	Returnval UserSession `xml:"returnval" json:"returnval"`
}

// The parameters of `HostActiveDirectoryAuthentication.ImportCertificateForCAM_Task`.
type ImportCertificateForCAMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// full path of the certificate on ESXi
	CertPath string `xml:"certPath" json:"certPath"`
	// IP of server providing the CAM service.
	CamServer string `xml:"camServer" json:"camServer"`
}

func init() {
	t["ImportCertificateForCAMRequestType"] = reflect.TypeOf((*ImportCertificateForCAMRequestType)(nil)).Elem()
}

type ImportCertificateForCAM_Task ImportCertificateForCAMRequestType

func init() {
	t["ImportCertificateForCAM_Task"] = reflect.TypeOf((*ImportCertificateForCAM_Task)(nil)).Elem()
}

type ImportCertificateForCAM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Thrown if failure occurs while adding host to DVS during import operation
type ImportHostAddFailure struct {
	DvsFault

	// Hosts on which import operation failed
	HostIp []string `xml:"hostIp" json:"hostIp"`
}

func init() {
	t["ImportHostAddFailure"] = reflect.TypeOf((*ImportHostAddFailure)(nil)).Elem()
}

type ImportHostAddFailureFault ImportHostAddFailure

func init() {
	t["ImportHostAddFailureFault"] = reflect.TypeOf((*ImportHostAddFailureFault)(nil)).Elem()
}

// Thrown if a Import operation fails
type ImportOperationBulkFault struct {
	DvsFault

	// Faults occurred during the import operation
	ImportFaults []ImportOperationBulkFaultFaultOnImport `xml:"importFaults" json:"importFaults"`
}

func init() {
	t["ImportOperationBulkFault"] = reflect.TypeOf((*ImportOperationBulkFault)(nil)).Elem()
}

type ImportOperationBulkFaultFault ImportOperationBulkFault

func init() {
	t["ImportOperationBulkFaultFault"] = reflect.TypeOf((*ImportOperationBulkFaultFault)(nil)).Elem()
}

// The fault occurred on the entity during an import operation.
type ImportOperationBulkFaultFaultOnImport struct {
	DynamicData

	// The entity type on which import failed.
	//
	// See `EntityType_enum`
	// for valid values
	EntityType string `xml:"entityType,omitempty" json:"entityType,omitempty"`
	// The key on which import failed
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// The fault that occurred.
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["ImportOperationBulkFaultFaultOnImport"] = reflect.TypeOf((*ImportOperationBulkFaultFaultOnImport)(nil)).Elem()
}

// An ImportSpec is used when importing VMs or vApps.
//
// It can be built from scratch, or it can be generated from an OVF descriptor using the
// service interface `OvfManager`.
//
// This class is the abstract base for `VirtualMachineImportSpec` and
// `VirtualAppImportSpec`. These three classes form a composite structure
// that allows us to contain arbitrarily complex entitites in a single ImportSpec.
type ImportSpec struct {
	DynamicData

	// Configuration of sub-entities (virtual machine or vApp).
	//
	// This is used for
	// sub-entities of a vApp that could be a virtual machine or a vApp.
	EntityConfig *VAppEntityConfigInfo `xml:"entityConfig,omitempty" json:"entityConfig,omitempty"`
	// The instantiation OST (see `OvfConsumer` ) to be consumed by OVF
	// consumers.
	InstantiationOst *OvfConsumerOstNode `xml:"instantiationOst,omitempty" json:"instantiationOst,omitempty"`
}

func init() {
	t["ImportSpec"] = reflect.TypeOf((*ImportSpec)(nil)).Elem()
}

type ImportUnmanagedSnapshot ImportUnmanagedSnapshotRequestType

func init() {
	t["ImportUnmanagedSnapshot"] = reflect.TypeOf((*ImportUnmanagedSnapshot)(nil)).Elem()
}

// The parameters of `VirtualDiskManager.ImportUnmanagedSnapshot`.
type ImportUnmanagedSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \- The name of the disk to import, either a datastore path or a URL
	// referring to the virtual disk from which to get geometry information.
	Vdisk string `xml:"vdisk" json:"vdisk"`
	// If <code>vdisk</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>vdisk</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// \- unmanaged snapshot identifier
	VvolId string `xml:"vvolId" json:"vvolId"`
}

func init() {
	t["ImportUnmanagedSnapshotRequestType"] = reflect.TypeOf((*ImportUnmanagedSnapshotRequestType)(nil)).Elem()
}

type ImportUnmanagedSnapshotResponse struct {
}

type ImportVApp ImportVAppRequestType

func init() {
	t["ImportVApp"] = reflect.TypeOf((*ImportVApp)(nil)).Elem()
}

// The parameters of `ResourcePool.ImportVApp`.
type ImportVAppRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// An `ImportSpec` describing what to import.
	Spec BaseImportSpec `xml:"spec,typeattr" json:"spec"`
	// The folder to which the entity will be attached.
	//
	// Required privileges: VApp.Import
	//
	// Refers instance of `Folder`.
	Folder *ManagedObjectReference `xml:"folder,omitempty" json:"folder,omitempty"`
	// The target host on which the entity will run. This must
	// specify a host that is a member of the ComputeResource indirectly
	// specified by the pool. For a stand-alone host or a cluster with DRS,
	// host can be omitted, and the system selects a default.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["ImportVAppRequestType"] = reflect.TypeOf((*ImportVAppRequestType)(nil)).Elem()
}

type ImportVAppResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// A InUseFeatureManipulationDisallowed fault is thrown if an Vim.LicenseAssignmentManager.SetFeatureInUse or Vim.LicenseAssignmentManager.ResetFeatureInUse call can not complete because a feature is not available or the manipulation is not allowed.
type InUseFeatureManipulationDisallowed struct {
	NotEnoughLicenses
}

func init() {
	t["InUseFeatureManipulationDisallowed"] = reflect.TypeOf((*InUseFeatureManipulationDisallowed)(nil)).Elem()
}

type InUseFeatureManipulationDisallowedFault InUseFeatureManipulationDisallowed

func init() {
	t["InUseFeatureManipulationDisallowedFault"] = reflect.TypeOf((*InUseFeatureManipulationDisallowedFault)(nil)).Elem()
}

// An InaccessibleDatastore exception is thrown if the datastore corresponding to the
// given datastore path isn't currently accessible.
type InaccessibleDatastore struct {
	InvalidDatastore

	Detail string `xml:"detail,omitempty" json:"detail,omitempty"`
}

func init() {
	t["InaccessibleDatastore"] = reflect.TypeOf((*InaccessibleDatastore)(nil)).Elem()
}

type InaccessibleDatastoreFault BaseInaccessibleDatastore

func init() {
	t["InaccessibleDatastoreFault"] = reflect.TypeOf((*InaccessibleDatastoreFault)(nil)).Elem()
}

// An InaccessibleFTMetadataDatastore exception is thrown if the datastore
// corresponding to the specified FT Metadata Datastore path isn't currently
// accessible.
type InaccessibleFTMetadataDatastore struct {
	InaccessibleDatastore
}

func init() {
	t["InaccessibleFTMetadataDatastore"] = reflect.TypeOf((*InaccessibleFTMetadataDatastore)(nil)).Elem()
}

type InaccessibleFTMetadataDatastoreFault InaccessibleFTMetadataDatastore

func init() {
	t["InaccessibleFTMetadataDatastoreFault"] = reflect.TypeOf((*InaccessibleFTMetadataDatastoreFault)(nil)).Elem()
}

// An InaccessibleVFlashSource exception is thrown when
// an attempt is made to access the vFlash resource on
// the host, such as creating vFlash cache file for the
// virtual disk.
type InaccessibleVFlashSource struct {
	VimFault

	// Name of the host which has the vFlash resource
	HostName string `xml:"hostName" json:"hostName"`
}

func init() {
	t["InaccessibleVFlashSource"] = reflect.TypeOf((*InaccessibleVFlashSource)(nil)).Elem()
}

type InaccessibleVFlashSourceFault InaccessibleVFlashSource

func init() {
	t["InaccessibleVFlashSourceFault"] = reflect.TypeOf((*InaccessibleVFlashSourceFault)(nil)).Elem()
}

// A default device (see `VirtualMachineConfigOption.defaultDevice` for a
// definition) which the virtual machine is using is incompatible with
// the corresponding default device which will be created on the target host.
//
// This is an issue with powered-on or suspended migration under some
// circumstances. The problem is that in cases where the virtual machine
// must be recreated, it will have the default device created with default
// settings that are appropriate for the target host. If those are not
// compatible with the settings for that device that the virtual machine is currently
// using, then resuming the virtual machine on the target host might fail.
//
// This might happen if the device in question were reconfigured or the default
// is different between the source and the destination host. An example of
// a default device and associated setting which might cause this is
// `VirtualMachineVideoCard.videoRamSizeInKB`.
// This is an error.
type IncompatibleDefaultDevice struct {
	MigrationFault

	// The label of the device.
	Device string `xml:"device" json:"device"`
}

func init() {
	t["IncompatibleDefaultDevice"] = reflect.TypeOf((*IncompatibleDefaultDevice)(nil)).Elem()
}

type IncompatibleDefaultDeviceFault IncompatibleDefaultDevice

func init() {
	t["IncompatibleDefaultDeviceFault"] = reflect.TypeOf((*IncompatibleDefaultDeviceFault)(nil)).Elem()
}

// The IncompatibleHostForFtSecondary fault is thrown when an invalid
// host has been specified when calling `VirtualMachine.CreateSecondaryVM_Task`
// or `VirtualMachine.EnableSecondaryVM_Task`.
type IncompatibleHostForFtSecondary struct {
	VmFaultToleranceIssue

	// The host that is not compatible with the secondary virtual machine.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Information on why the host that was specified could not be used for
	// the FaultTolerance Secondary VirtualMachine.
	Error []LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
}

func init() {
	t["IncompatibleHostForFtSecondary"] = reflect.TypeOf((*IncompatibleHostForFtSecondary)(nil)).Elem()
}

type IncompatibleHostForFtSecondaryFault IncompatibleHostForFtSecondary

func init() {
	t["IncompatibleHostForFtSecondaryFault"] = reflect.TypeOf((*IncompatibleHostForFtSecondaryFault)(nil)).Elem()
}

// A IncompatibleHostForVmReplication is thrown when a VM is powered
// on or migrated to a host which does not support the replication
// configuration of the VM.
type IncompatibleHostForVmReplication struct {
	ReplicationFault

	// The VM which has replication configured
	VmName string `xml:"vmName" json:"vmName"`
	// The host which is incompatible for VM replication
	HostName string `xml:"hostName" json:"hostName"`
	// The reason why the host is incompatible
	Reason string `xml:"reason" json:"reason"`
}

func init() {
	t["IncompatibleHostForVmReplication"] = reflect.TypeOf((*IncompatibleHostForVmReplication)(nil)).Elem()
}

type IncompatibleHostForVmReplicationFault IncompatibleHostForVmReplication

func init() {
	t["IncompatibleHostForVmReplicationFault"] = reflect.TypeOf((*IncompatibleHostForVmReplicationFault)(nil)).Elem()
}

// Thrown when two parameters in the customization settings conflict with each other.
//
// For example, a client may not specify both a Workgroup and a DomainName.
type IncompatibleSetting struct {
	InvalidArgument

	// The name of the setting that is conflicting.
	ConflictingProperty string `xml:"conflictingProperty" json:"conflictingProperty"`
}

func init() {
	t["IncompatibleSetting"] = reflect.TypeOf((*IncompatibleSetting)(nil)).Elem()
}

type IncompatibleSettingFault IncompatibleSetting

func init() {
	t["IncompatibleSettingFault"] = reflect.TypeOf((*IncompatibleSettingFault)(nil)).Elem()
}

// Thrown when an operation fails because the files do not match a
// specified file type.
type IncorrectFileType struct {
	FileFault
}

func init() {
	t["IncorrectFileType"] = reflect.TypeOf((*IncorrectFileType)(nil)).Elem()
}

type IncorrectFileTypeFault IncorrectFileType

func init() {
	t["IncorrectFileTypeFault"] = reflect.TypeOf((*IncorrectFileTypeFault)(nil)).Elem()
}

// A IncorrectHostInformation is thrown if the host does not provide the information
// needed to acquire the correct set of licenses.
type IncorrectHostInformation struct {
	NotEnoughLicenses
}

func init() {
	t["IncorrectHostInformation"] = reflect.TypeOf((*IncorrectHostInformation)(nil)).Elem()
}

// This event records if the host did not provide the information needed
// to acquire the correct set of licenses.
type IncorrectHostInformationEvent struct {
	LicenseEvent
}

func init() {
	t["IncorrectHostInformationEvent"] = reflect.TypeOf((*IncorrectHostInformationEvent)(nil)).Elem()
}

type IncorrectHostInformationFault IncorrectHostInformation

func init() {
	t["IncorrectHostInformationFault"] = reflect.TypeOf((*IncorrectHostInformationFault)(nil)).Elem()
}

type IncreaseDirectorySize IncreaseDirectorySizeRequestType

func init() {
	t["IncreaseDirectorySize"] = reflect.TypeOf((*IncreaseDirectorySize)(nil)).Elem()
}

// The parameters of `DatastoreNamespaceManager.IncreaseDirectorySize`.
type IncreaseDirectorySizeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// the datacenter of the namespace path. Needs to be set
	// when making the call to VC; ignored when the call is
	// made to ESX.
	//
	// Required privileges: System.View
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// stable vmfs path of the top-level directory
	StableName string `xml:"stableName" json:"stableName"`
	// the desired final size in MB of the directory, not a diff
	// from the current size; should be more than current size
	Size int64 `xml:"size" json:"size"`
}

func init() {
	t["IncreaseDirectorySizeRequestType"] = reflect.TypeOf((*IncreaseDirectorySizeRequestType)(nil)).Elem()
	minAPIVersionForType["IncreaseDirectorySizeRequestType"] = "8.0.1.0"
}

type IncreaseDirectorySizeResponse struct {
}

// An operation on a powered-on virtual machine requests that the virtual
// machine's disks be moved without choosing a new home datastore for the
// virtual machine, but the host does not have that capability.
type IndependentDiskVMotionNotSupported struct {
	MigrationFeatureNotSupported
}

func init() {
	t["IndependentDiskVMotionNotSupported"] = reflect.TypeOf((*IndependentDiskVMotionNotSupported)(nil)).Elem()
}

type IndependentDiskVMotionNotSupportedFault IndependentDiskVMotionNotSupported

func init() {
	t["IndependentDiskVMotionNotSupportedFault"] = reflect.TypeOf((*IndependentDiskVMotionNotSupportedFault)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.InflateDisk_Task`.
type InflateDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual disk to be inflated.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual disk is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["InflateDiskRequestType"] = reflect.TypeOf((*InflateDiskRequestType)(nil)).Elem()
}

type InflateDisk_Task InflateDiskRequestType

func init() {
	t["InflateDisk_Task"] = reflect.TypeOf((*InflateDisk_Task)(nil)).Elem()
}

type InflateDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualDiskManager.InflateVirtualDisk_Task`.
type InflateVirtualDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk that should be inflated.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
}

func init() {
	t["InflateVirtualDiskRequestType"] = reflect.TypeOf((*InflateVirtualDiskRequestType)(nil)).Elem()
}

type InflateVirtualDisk_Task InflateVirtualDiskRequestType

func init() {
	t["InflateVirtualDisk_Task"] = reflect.TypeOf((*InflateVirtualDisk_Task)(nil)).Elem()
}

type InflateVirtualDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This event is a general information event from upgrade.
type InfoUpgradeEvent struct {
	UpgradeEvent
}

func init() {
	t["InfoUpgradeEvent"] = reflect.TypeOf((*InfoUpgradeEvent)(nil)).Elem()
}

// The base class for any type of setting or configuration that may get a
// inherited value.
//
// When used in a reconfigure operation specification, if `InheritablePolicy.inherited` is true,
// it specifies the intention to change the values of subclass's properties to the
// inherited values from the level above. In this case, users don't need to specify
// the values and any set property in the subclass will be ignored.
// if `InheritablePolicy.inherited` is false, it specifies the intention to explicitly set
// subclass's properties to user specified values. Users should set the properties in
// the subclass with the desired values.
//
// When used in a configuration information object, The values of the properties in
// the subclass are the effective values. if `InheritablePolicy.inherited` is true, the object
// is getting the effective values from upper level. If false, the values are
// explicitly set by a user.
type InheritablePolicy struct {
	DynamicData

	// Whether the configuration is set to inherited value.
	Inherited bool `xml:"inherited" json:"inherited"`
}

func init() {
	t["InheritablePolicy"] = reflect.TypeOf((*InheritablePolicy)(nil)).Elem()
}

// The parameters of `HostVsanSystem.InitializeDisks_Task`.
type InitializeDisksRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// list of disk mappings to initialize
	Mapping []VsanHostDiskMapping `xml:"mapping" json:"mapping"`
}

func init() {
	t["InitializeDisksRequestType"] = reflect.TypeOf((*InitializeDisksRequestType)(nil)).Elem()
}

type InitializeDisks_Task InitializeDisksRequestType

func init() {
	t["InitializeDisks_Task"] = reflect.TypeOf((*InitializeDisks_Task)(nil)).Elem()
}

type InitializeDisks_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type InitiateFileTransferFromGuest InitiateFileTransferFromGuestRequestType

func init() {
	t["InitiateFileTransferFromGuest"] = reflect.TypeOf((*InitiateFileTransferFromGuest)(nil)).Elem()
}

// The parameters of `GuestFileManager.InitiateFileTransferFromGuest`.
type InitiateFileTransferFromGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual Machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Query
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The complete path to the file inside the guest
	// that has to be transferred to the client. It cannot be a path to
	// a directory or a symbolic link.
	GuestFilePath string `xml:"guestFilePath" json:"guestFilePath"`
}

func init() {
	t["InitiateFileTransferFromGuestRequestType"] = reflect.TypeOf((*InitiateFileTransferFromGuestRequestType)(nil)).Elem()
}

type InitiateFileTransferFromGuestResponse struct {
	Returnval FileTransferInformation `xml:"returnval" json:"returnval"`
}

type InitiateFileTransferToGuest InitiateFileTransferToGuestRequestType

func init() {
	t["InitiateFileTransferToGuest"] = reflect.TypeOf((*InitiateFileTransferToGuest)(nil)).Elem()
}

// The parameters of `GuestFileManager.InitiateFileTransferToGuest`.
type InitiateFileTransferToGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual Machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Modify
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The complete destination path in the guest to
	// transfer the file from the client. It cannot be a path to
	// a directory or a symbolic link.
	GuestFilePath string `xml:"guestFilePath" json:"guestFilePath"`
	// File attributes of the file that has to be
	// created in the guest. See `GuestFileAttributes`.
	// If any file attribute is not specified, then the default value
	// of that property will be set for the file.
	FileAttributes BaseGuestFileAttributes `xml:"fileAttributes,typeattr" json:"fileAttributes"`
	// Size of the file to transfer to the guest in bytes.
	FileSize int64 `xml:"fileSize" json:"fileSize"`
	// If set, the destination file is clobbered.
	Overwrite bool `xml:"overwrite" json:"overwrite"`
}

func init() {
	t["InitiateFileTransferToGuestRequestType"] = reflect.TypeOf((*InitiateFileTransferToGuestRequestType)(nil)).Elem()
}

type InitiateFileTransferToGuestResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// The parameters of `HostPatchManager.InstallHostPatch_Task`.
type InstallHostPatchRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Location of the repository that contains the
	// bulletin depot. The depot must be organized as a flat
	// collection of bulletins with each one being a folder named
	// after the bulletin ID. Each folder must contain both
	// update metadata and required binaries.
	Repository HostPatchManagerLocator `xml:"repository" json:"repository"`
	// The update to be installed on the host.
	UpdateID string `xml:"updateID" json:"updateID"`
	// Specify whether to force reinstall an update.
	// By default, installing an already-installed update would fail
	// with the `PatchAlreadyInstalled` fault. If
	// force is set to true, the update will be forcefully reinstalled,
	// thus overwriting the already installed update.
	Force *bool `xml:"force" json:"force,omitempty"`
}

func init() {
	t["InstallHostPatchRequestType"] = reflect.TypeOf((*InstallHostPatchRequestType)(nil)).Elem()
}

// The parameters of `HostPatchManager.InstallHostPatchV2_Task`.
type InstallHostPatchV2RequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A list of urls pointing to metadata.zip.
	MetaUrls []string `xml:"metaUrls,omitempty" json:"metaUrls,omitempty"`
	// a list of urls pointing to an "offline" bundle. It is not supported in 5.0 or later.
	BundleUrls []string `xml:"bundleUrls,omitempty" json:"bundleUrls,omitempty"`
	// The urls of update binary files to be installed.
	VibUrls []string                                   `xml:"vibUrls,omitempty" json:"vibUrls,omitempty"`
	Spec    *HostPatchManagerPatchManagerOperationSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["InstallHostPatchV2RequestType"] = reflect.TypeOf((*InstallHostPatchV2RequestType)(nil)).Elem()
}

type InstallHostPatchV2_Task InstallHostPatchV2RequestType

func init() {
	t["InstallHostPatchV2_Task"] = reflect.TypeOf((*InstallHostPatchV2_Task)(nil)).Elem()
}

type InstallHostPatchV2_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type InstallHostPatch_Task InstallHostPatchRequestType

func init() {
	t["InstallHostPatch_Task"] = reflect.TypeOf((*InstallHostPatch_Task)(nil)).Elem()
}

type InstallHostPatch_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `IoFilterManager.InstallIoFilter_Task`.
type InstallIoFilterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The URL that points to the IO Filter VIB package.
	VibUrl string `xml:"vibUrl" json:"vibUrl"`
	// The compute resource to install the IO Filter on.
	// "compRes" must be a cluster.
	//
	// Refers instance of `ComputeResource`.
	CompRes ManagedObjectReference `xml:"compRes" json:"compRes"`
	// This specifies SSL trust policy `IoFilterManagerSslTrust`
	// for the given VIB URL. If unset, the server certificate is
	// validated against the trusted root certificates.
	VibSslTrust BaseIoFilterManagerSslTrust `xml:"vibSslTrust,omitempty,typeattr" json:"vibSslTrust,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["InstallIoFilterRequestType"] = reflect.TypeOf((*InstallIoFilterRequestType)(nil)).Elem()
}

type InstallIoFilter_Task InstallIoFilterRequestType

func init() {
	t["InstallIoFilter_Task"] = reflect.TypeOf((*InstallIoFilter_Task)(nil)).Elem()
}

type InstallIoFilter_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type InstallServerCertificate InstallServerCertificateRequestType

func init() {
	t["InstallServerCertificate"] = reflect.TypeOf((*InstallServerCertificate)(nil)).Elem()
}

// The parameters of `HostCertificateManager.InstallServerCertificate`.
type InstallServerCertificateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// SSL certificate in PEM format
	Cert string `xml:"cert" json:"cert"`
}

func init() {
	t["InstallServerCertificateRequestType"] = reflect.TypeOf((*InstallServerCertificateRequestType)(nil)).Elem()
}

type InstallServerCertificateResponse struct {
}

type InstallSmartCardTrustAnchor InstallSmartCardTrustAnchorRequestType

func init() {
	t["InstallSmartCardTrustAnchor"] = reflect.TypeOf((*InstallSmartCardTrustAnchor)(nil)).Elem()
}

// The parameters of `HostActiveDirectoryAuthentication.InstallSmartCardTrustAnchor`.
type InstallSmartCardTrustAnchorRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// SSL certificate in PEM format
	Cert string `xml:"cert" json:"cert"`
}

func init() {
	t["InstallSmartCardTrustAnchorRequestType"] = reflect.TypeOf((*InstallSmartCardTrustAnchorRequestType)(nil)).Elem()
}

type InstallSmartCardTrustAnchorResponse struct {
}

// The parameters of `VirtualMachine.InstantClone_Task`.
type InstantCloneRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Is a `VirtualMachineInstantCloneSpec`. It specifies the
	// cloned virtual machine's configuration.
	Spec VirtualMachineInstantCloneSpec `xml:"spec" json:"spec"`
}

func init() {
	t["InstantCloneRequestType"] = reflect.TypeOf((*InstantCloneRequestType)(nil)).Elem()
}

type InstantClone_Task InstantCloneRequestType

func init() {
	t["InstantClone_Task"] = reflect.TypeOf((*InstantClone_Task)(nil)).Elem()
}

type InstantClone_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This fault is returned when the required number of deployed agent virtual
// machines is not currently deployed on a host and hence the host cannot be
// used to run client virtual machines.
type InsufficientAgentVmsDeployed struct {
	InsufficientResourcesFault

	HostName string `xml:"hostName" json:"hostName"`
	// The number of agent virtual machines required to be deployed on the host.
	RequiredNumAgentVms int32 `xml:"requiredNumAgentVms" json:"requiredNumAgentVms"`
	// The number of agent virtual machines currently deployed on the host.
	CurrentNumAgentVms int32 `xml:"currentNumAgentVms" json:"currentNumAgentVms"`
}

func init() {
	t["InsufficientAgentVmsDeployed"] = reflect.TypeOf((*InsufficientAgentVmsDeployed)(nil)).Elem()
}

type InsufficientAgentVmsDeployedFault InsufficientAgentVmsDeployed

func init() {
	t["InsufficientAgentVmsDeployedFault"] = reflect.TypeOf((*InsufficientAgentVmsDeployedFault)(nil)).Elem()
}

// CPU resources admission control failed
type InsufficientCpuResourcesFault struct {
	InsufficientResourcesFault

	// The CPU available in the resource pool requested in MHz.
	Unreserved int64 `xml:"unreserved" json:"unreserved"`
	// The CPU resource amount requested in the failed operation in MHz.
	Requested int64 `xml:"requested" json:"requested"`
}

func init() {
	t["InsufficientCpuResourcesFault"] = reflect.TypeOf((*InsufficientCpuResourcesFault)(nil)).Elem()
}

type InsufficientCpuResourcesFaultFault InsufficientCpuResourcesFault

func init() {
	t["InsufficientCpuResourcesFaultFault"] = reflect.TypeOf((*InsufficientCpuResourcesFaultFault)(nil)).Elem()
}

// Fault used to denote an insufficient group of disks for a given operation.
//
// See also `HostVsanSystem.AddDisks_Task`, `HostVsanSystem.InitializeDisks_Task`.
type InsufficientDisks struct {
	VsanDiskFault
}

func init() {
	t["InsufficientDisks"] = reflect.TypeOf((*InsufficientDisks)(nil)).Elem()
}

type InsufficientDisksFault InsufficientDisks

func init() {
	t["InsufficientDisksFault"] = reflect.TypeOf((*InsufficientDisksFault)(nil)).Elem()
}

// This event records that the cluster resources are insufficient
// to satisfy the configured HA failover level.
type InsufficientFailoverResourcesEvent struct {
	ClusterEvent
}

func init() {
	t["InsufficientFailoverResourcesEvent"] = reflect.TypeOf((*InsufficientFailoverResourcesEvent)(nil)).Elem()
}

// This is thrown if an operation would violate the configured failover level of a HA
// cluster.
//
// In a HA cluster, virtual machines provide high availability by moving among physical
// machines in the event of a failure. HA Admission Control ensures that the total
// resource requirements for the set of virtual machines in a HA cluster does not exceed
// the resources that would be available in the worst-case scenario failure. If HA
// Admission Control is not used, physical machines may have insufficient resources to
// provide the expected level of service.
//
// This fault indicates that the virtual machine operation you attempted would have
// created a situation where the remaining physical machines would not meet the needs of
// the virtual machines in the event of a failure.
type InsufficientFailoverResourcesFault struct {
	InsufficientResourcesFault
}

func init() {
	t["InsufficientFailoverResourcesFault"] = reflect.TypeOf((*InsufficientFailoverResourcesFault)(nil)).Elem()
}

type InsufficientFailoverResourcesFaultFault InsufficientFailoverResourcesFault

func init() {
	t["InsufficientFailoverResourcesFaultFault"] = reflect.TypeOf((*InsufficientFailoverResourcesFaultFault)(nil)).Elem()
}

// Graphics resources admission control failed
type InsufficientGraphicsResourcesFault struct {
	InsufficientResourcesFault
}

func init() {
	t["InsufficientGraphicsResourcesFault"] = reflect.TypeOf((*InsufficientGraphicsResourcesFault)(nil)).Elem()
}

type InsufficientGraphicsResourcesFaultFault InsufficientGraphicsResourcesFault

func init() {
	t["InsufficientGraphicsResourcesFaultFault"] = reflect.TypeOf((*InsufficientGraphicsResourcesFaultFault)(nil)).Elem()
}

// The host does not have enough capacity for running the virtual machine.
type InsufficientHostCapacityFault struct {
	InsufficientResourcesFault

	// The host which does not have the enough capacity.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["InsufficientHostCapacityFault"] = reflect.TypeOf((*InsufficientHostCapacityFault)(nil)).Elem()
}

type InsufficientHostCapacityFaultFault BaseInsufficientHostCapacityFault

func init() {
	t["InsufficientHostCapacityFaultFault"] = reflect.TypeOf((*InsufficientHostCapacityFaultFault)(nil)).Elem()
}

// The host does not have enough CPU capacity for running the virtual machine.
type InsufficientHostCpuCapacityFault struct {
	InsufficientHostCapacityFault

	// The CPU available on the host in MHz.
	Unreserved int64 `xml:"unreserved" json:"unreserved"`
	// The CPU resource amount requested in the failed operation in MHz.
	Requested int64 `xml:"requested" json:"requested"`
}

func init() {
	t["InsufficientHostCpuCapacityFault"] = reflect.TypeOf((*InsufficientHostCpuCapacityFault)(nil)).Elem()
}

type InsufficientHostCpuCapacityFaultFault InsufficientHostCpuCapacityFault

func init() {
	t["InsufficientHostCpuCapacityFaultFault"] = reflect.TypeOf((*InsufficientHostCpuCapacityFaultFault)(nil)).Elem()
}

// The host does not have enough memory capacity for running the virtual machine.
type InsufficientHostMemoryCapacityFault struct {
	InsufficientHostCapacityFault

	// The memory available on the host in bytes.
	Unreserved int64 `xml:"unreserved" json:"unreserved"`
	// The memory resource amount requested in the failed operation in bytes.
	Requested int64 `xml:"requested" json:"requested"`
}

func init() {
	t["InsufficientHostMemoryCapacityFault"] = reflect.TypeOf((*InsufficientHostMemoryCapacityFault)(nil)).Elem()
}

type InsufficientHostMemoryCapacityFaultFault InsufficientHostMemoryCapacityFault

func init() {
	t["InsufficientHostMemoryCapacityFaultFault"] = reflect.TypeOf((*InsufficientHostMemoryCapacityFaultFault)(nil)).Elem()
}

// Memory resource admission control failed
type InsufficientMemoryResourcesFault struct {
	InsufficientResourcesFault

	// The memory available in the resource pool requested in bytes.
	Unreserved int64 `xml:"unreserved" json:"unreserved"`
	// The memory resource amount requested in the failed operation in bytes.
	Requested int64 `xml:"requested" json:"requested"`
}

func init() {
	t["InsufficientMemoryResourcesFault"] = reflect.TypeOf((*InsufficientMemoryResourcesFault)(nil)).Elem()
}

type InsufficientMemoryResourcesFaultFault InsufficientMemoryResourcesFault

func init() {
	t["InsufficientMemoryResourcesFaultFault"] = reflect.TypeOf((*InsufficientMemoryResourcesFaultFault)(nil)).Elem()
}

// The host does not have enough network capacity for running the virtual machine.
type InsufficientNetworkCapacity struct {
	InsufficientResourcesFault
}

func init() {
	t["InsufficientNetworkCapacity"] = reflect.TypeOf((*InsufficientNetworkCapacity)(nil)).Elem()
}

type InsufficientNetworkCapacityFault InsufficientNetworkCapacity

func init() {
	t["InsufficientNetworkCapacityFault"] = reflect.TypeOf((*InsufficientNetworkCapacityFault)(nil)).Elem()
}

// Insufficient network resource pool bandwidth
type InsufficientNetworkResourcePoolCapacity struct {
	InsufficientResourcesFault

	// Distributed Virtual Switch containing the resource pool
	// having unsufficient network bandwitdh.
	DvsName string `xml:"dvsName" json:"dvsName"`
	// UUID of the distributed Virtual Switch containing the resource pool
	// having unsufficient network bandwitdh.
	DvsUuid string `xml:"dvsUuid" json:"dvsUuid"`
	// Key of the resource pool on which network bandwidth is requested.
	ResourcePoolKey string `xml:"resourcePoolKey" json:"resourcePoolKey"`
	// Network bandwidth available (in MBs) in the requested resource pool.
	Available int64 `xml:"available" json:"available"`
	// Network bandwidth amount requested (in MBs).
	Requested int64 `xml:"requested" json:"requested"`
	// List of network devices that are requesting or already have requested
	// bandwidth on the network resource pool.
	Device []string `xml:"device" json:"device"`
}

func init() {
	t["InsufficientNetworkResourcePoolCapacity"] = reflect.TypeOf((*InsufficientNetworkResourcePoolCapacity)(nil)).Elem()
}

type InsufficientNetworkResourcePoolCapacityFault InsufficientNetworkResourcePoolCapacity

func init() {
	t["InsufficientNetworkResourcePoolCapacityFault"] = reflect.TypeOf((*InsufficientNetworkResourcePoolCapacityFault)(nil)).Elem()
}

// The host does not have enough per CPU capacity.
type InsufficientPerCpuCapacity struct {
	InsufficientHostCapacityFault
}

func init() {
	t["InsufficientPerCpuCapacity"] = reflect.TypeOf((*InsufficientPerCpuCapacity)(nil)).Elem()
}

type InsufficientPerCpuCapacityFault InsufficientPerCpuCapacity

func init() {
	t["InsufficientPerCpuCapacityFault"] = reflect.TypeOf((*InsufficientPerCpuCapacityFault)(nil)).Elem()
}

// Base fault that occurs when an operation conflicts with a resource configuration
// policy.
//
// For example, this fault occurs if a power-on operation reserves more memory
// than is allocated to a resource pool.
type InsufficientResourcesFault struct {
	VimFault
}

func init() {
	t["InsufficientResourcesFault"] = reflect.TypeOf((*InsufficientResourcesFault)(nil)).Elem()
}

type InsufficientResourcesFaultFault BaseInsufficientResourcesFault

func init() {
	t["InsufficientResourcesFaultFault"] = reflect.TypeOf((*InsufficientResourcesFaultFault)(nil)).Elem()
}

// This fault is thrown when Distributed Power Management cannot perform
// a given opeartion because there is insufficient CPU resource
// on standby hosts (if any) to meet the requirements of the operation.
type InsufficientStandbyCpuResource struct {
	InsufficientStandbyResource

	// The total amount of CPU resource available (in MHz) on all the usable hosts
	// in the cluster (including powered on and standby hosts).
	Available int64 `xml:"available" json:"available"`
	// The additional amount of CPU resource (other than that on the hosts included
	// in "available") needed (in MHz).
	Requested int64 `xml:"requested" json:"requested"`
}

func init() {
	t["InsufficientStandbyCpuResource"] = reflect.TypeOf((*InsufficientStandbyCpuResource)(nil)).Elem()
}

type InsufficientStandbyCpuResourceFault InsufficientStandbyCpuResource

func init() {
	t["InsufficientStandbyCpuResourceFault"] = reflect.TypeOf((*InsufficientStandbyCpuResourceFault)(nil)).Elem()
}

// This fault is thrown by Distributed Power Management algorithm.
//
// It indicates
// that there are insufficient memory resources on standby hosts (if any)
// to meet the requirements of a given operation.
type InsufficientStandbyMemoryResource struct {
	InsufficientStandbyResource

	// The total amount of memory resource available (in bytes) on all the usable hosts
	// in the cluster (including powered on and standby hosts).
	Available int64 `xml:"available" json:"available"`
	// The additional amount of memory resource (other than that on the hosts included
	// in "available") needed (in bytes).
	Requested int64 `xml:"requested" json:"requested"`
}

func init() {
	t["InsufficientStandbyMemoryResource"] = reflect.TypeOf((*InsufficientStandbyMemoryResource)(nil)).Elem()
}

type InsufficientStandbyMemoryResourceFault InsufficientStandbyMemoryResource

func init() {
	t["InsufficientStandbyMemoryResourceFault"] = reflect.TypeOf((*InsufficientStandbyMemoryResourceFault)(nil)).Elem()
}

// This fault is thrown when Distributed Power Management cannot perform
// a given opeartion because there are insufficient CPU/memory resources
// on standby hosts (if any) to meet the requirements of the operation.
type InsufficientStandbyResource struct {
	InsufficientResourcesFault
}

func init() {
	t["InsufficientStandbyResource"] = reflect.TypeOf((*InsufficientStandbyResource)(nil)).Elem()
}

type InsufficientStandbyResourceFault BaseInsufficientStandbyResource

func init() {
	t["InsufficientStandbyResourceFault"] = reflect.TypeOf((*InsufficientStandbyResourceFault)(nil)).Elem()
}

// The datastore does not have enough IOPs capacity for running the virtual machine.
type InsufficientStorageIops struct {
	VimFault

	// The IOPs available on the datastore
	UnreservedIops int64 `xml:"unreservedIops" json:"unreservedIops"`
	// The IOPs resource amount requested in the failed operation
	RequestedIops int64 `xml:"requestedIops" json:"requestedIops"`
	// Name of the datastore with insufficient capacity
	DatastoreName string `xml:"datastoreName" json:"datastoreName"`
}

func init() {
	t["InsufficientStorageIops"] = reflect.TypeOf((*InsufficientStorageIops)(nil)).Elem()
}

type InsufficientStorageIopsFault InsufficientStorageIops

func init() {
	t["InsufficientStorageIopsFault"] = reflect.TypeOf((*InsufficientStorageIopsFault)(nil)).Elem()
}

// The fault occurs when Storage DRS cannot perform a given operation (e.g., fix the
// out of space condition, or place a virtual disk) because there is insufficient
// storage space in the given storage pod to meet the requirements of the operation.
type InsufficientStorageSpace struct {
	InsufficientResourcesFault
}

func init() {
	t["InsufficientStorageSpace"] = reflect.TypeOf((*InsufficientStorageSpace)(nil)).Elem()
}

type InsufficientStorageSpaceFault InsufficientStorageSpace

func init() {
	t["InsufficientStorageSpaceFault"] = reflect.TypeOf((*InsufficientStorageSpaceFault)(nil)).Elem()
}

// Insufficient vFlash resource to consume
type InsufficientVFlashResourcesFault struct {
	InsufficientResourcesFault

	// The vFlash resource available capacity in MB.
	FreeSpaceInMB int64 `xml:"freeSpaceInMB,omitempty" json:"freeSpaceInMB,omitempty"`
	// The vFlash resource available capacity in bytes.
	FreeSpace int64 `xml:"freeSpace" json:"freeSpace"`
	// The vFlash resource amount requested in MB.
	RequestedSpaceInMB int64 `xml:"requestedSpaceInMB,omitempty" json:"requestedSpaceInMB,omitempty"`
	// The vFlash resource amount requested in bytes.
	RequestedSpace int64 `xml:"requestedSpace" json:"requestedSpace"`
}

func init() {
	t["InsufficientVFlashResourcesFault"] = reflect.TypeOf((*InsufficientVFlashResourcesFault)(nil)).Elem()
}

type InsufficientVFlashResourcesFaultFault InsufficientVFlashResourcesFault

func init() {
	t["InsufficientVFlashResourcesFaultFault"] = reflect.TypeOf((*InsufficientVFlashResourcesFaultFault)(nil)).Elem()
}

// The integer type of setting or configuration that may get a
// negated value.
type IntExpression struct {
	NegatableExpression

	// The integer value that is either negated or used as it is
	Value int32 `xml:"value,omitempty" json:"value,omitempty"`
}

func init() {
	t["IntExpression"] = reflect.TypeOf((*IntExpression)(nil)).Elem()
}

// The IntOption data object type is used to define the minimum, maximum,
// and default values for an integer option.
type IntOption struct {
	OptionType

	// The minimum value.
	Min int32 `xml:"min" json:"min"`
	// The maximum value.
	Max int32 `xml:"max" json:"max"`
	// The default value.
	DefaultValue int32 `xml:"defaultValue" json:"defaultValue"`
}

func init() {
	t["IntOption"] = reflect.TypeOf((*IntOption)(nil)).Elem()
}

// The integer type of setting or configuration that may get an
// inherited value.
type IntPolicy struct {
	InheritablePolicy

	// The integer value that is either set or inherited.
	Value int32 `xml:"value,omitempty" json:"value,omitempty"`
}

func init() {
	t["IntPolicy"] = reflect.TypeOf((*IntPolicy)(nil)).Elem()
}

// An InvalidAffinitySettingsFault is thrown if an invalid affinity setting is
// specified for a virtual machine.
type InvalidAffinitySettingFault struct {
	VimFault
}

func init() {
	t["InvalidAffinitySettingFault"] = reflect.TypeOf((*InvalidAffinitySettingFault)(nil)).Elem()
}

type InvalidAffinitySettingFaultFault InvalidAffinitySettingFault

func init() {
	t["InvalidAffinitySettingFaultFault"] = reflect.TypeOf((*InvalidAffinitySettingFaultFault)(nil)).Elem()
}

// An InvalidArgument exception is thrown if the
// set of arguments passed to the function is not
// specified correctly.
type InvalidArgument struct {
	RuntimeFault

	// Optional name of the invalid property.
	InvalidProperty string `xml:"invalidProperty,omitempty" json:"invalidProperty,omitempty"`
}

func init() {
	t["InvalidArgument"] = reflect.TypeOf((*InvalidArgument)(nil)).Elem()
}

type InvalidArgumentFault BaseInvalidArgument

func init() {
	t["InvalidArgumentFault"] = reflect.TypeOf((*InvalidArgumentFault)(nil)).Elem()
}

// An InvalidBmcRole fault is thrown when a BMC user doesn't have the necessary
// privileges.
//
// BMC (Board Management Controller) is a piece of hardware required for
// IPMI.
type InvalidBmcRole struct {
	VimFault
}

func init() {
	t["InvalidBmcRole"] = reflect.TypeOf((*InvalidBmcRole)(nil)).Elem()
}

type InvalidBmcRoleFault InvalidBmcRole

func init() {
	t["InvalidBmcRoleFault"] = reflect.TypeOf((*InvalidBmcRoleFault)(nil)).Elem()
}

// An Invalid Bundle fault is thrown if an operation fails because of a
// problem with the supplied bundle.
type InvalidBundle struct {
	PlatformConfigFault
}

func init() {
	t["InvalidBundle"] = reflect.TypeOf((*InvalidBundle)(nil)).Elem()
}

type InvalidBundleFault InvalidBundle

func init() {
	t["InvalidBundleFault"] = reflect.TypeOf((*InvalidBundleFault)(nil)).Elem()
}

// Fault indicating that the CAM server's certificate
// cannot be verified.
type InvalidCAMCertificate struct {
	InvalidCAMServer
}

func init() {
	t["InvalidCAMCertificate"] = reflect.TypeOf((*InvalidCAMCertificate)(nil)).Elem()
}

type InvalidCAMCertificateFault InvalidCAMCertificate

func init() {
	t["InvalidCAMCertificateFault"] = reflect.TypeOf((*InvalidCAMCertificateFault)(nil)).Elem()
}

// Fault indicating that the CAM server
// for camServer cannot be reached,
// or is not a valid IP address.
type InvalidCAMServer struct {
	ActiveDirectoryFault

	// The address of the CAM server.
	CamServer string `xml:"camServer" json:"camServer"`
}

func init() {
	t["InvalidCAMServer"] = reflect.TypeOf((*InvalidCAMServer)(nil)).Elem()
}

type InvalidCAMServerFault BaseInvalidCAMServer

func init() {
	t["InvalidCAMServerFault"] = reflect.TypeOf((*InvalidCAMServerFault)(nil)).Elem()
}

// This exception is thrown when a client has provided a
// certificate that fails certificate validation at the server.
type InvalidClientCertificate struct {
	InvalidLogin
}

func init() {
	t["InvalidClientCertificate"] = reflect.TypeOf((*InvalidClientCertificate)(nil)).Elem()
}

type InvalidClientCertificateFault InvalidClientCertificate

func init() {
	t["InvalidClientCertificateFault"] = reflect.TypeOf((*InvalidClientCertificateFault)(nil)).Elem()
}

// InvalidCollectorVersion is thrown when a collector version is out
// of date or invalid.
type InvalidCollectorVersion struct {
	MethodFault
}

func init() {
	t["InvalidCollectorVersion"] = reflect.TypeOf((*InvalidCollectorVersion)(nil)).Elem()
}

type InvalidCollectorVersionFault InvalidCollectorVersion

func init() {
	t["InvalidCollectorVersionFault"] = reflect.TypeOf((*InvalidCollectorVersionFault)(nil)).Elem()
}

// An InvalidController exception is thrown if
// a device refers to a controller that cannot be found.
//
// For example, an exception might be thrown if the client
// incorrectly passes a controller key,
// or if the client did not specify a controller where one is
// required (such as for disks or CD-ROMs).
type InvalidController struct {
	InvalidDeviceSpec

	ControllerKey int32 `xml:"controllerKey" json:"controllerKey"`
}

func init() {
	t["InvalidController"] = reflect.TypeOf((*InvalidController)(nil)).Elem()
}

type InvalidControllerFault InvalidController

func init() {
	t["InvalidControllerFault"] = reflect.TypeOf((*InvalidControllerFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to configure an HA cluster with
// invalid argument.
type InvalidDasConfigArgument struct {
	InvalidArgument

	// The entry for the invalid argument
	Entry string `xml:"entry,omitempty" json:"entry,omitempty"`
	// Name of the cluster to be configured
	ClusterName string `xml:"clusterName,omitempty" json:"clusterName,omitempty"`
}

func init() {
	t["InvalidDasConfigArgument"] = reflect.TypeOf((*InvalidDasConfigArgument)(nil)).Elem()
}

type InvalidDasConfigArgumentFault InvalidDasConfigArgument

func init() {
	t["InvalidDasConfigArgumentFault"] = reflect.TypeOf((*InvalidDasConfigArgumentFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to set the DAS restart
// priority of a FT VM to disabled.
type InvalidDasRestartPriorityForFtVm struct {
	InvalidArgument

	// The virtual machine
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The name of the virtual machine
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["InvalidDasRestartPriorityForFtVm"] = reflect.TypeOf((*InvalidDasRestartPriorityForFtVm)(nil)).Elem()
}

type InvalidDasRestartPriorityForFtVmFault InvalidDasRestartPriorityForFtVm

func init() {
	t["InvalidDasRestartPriorityForFtVmFault"] = reflect.TypeOf((*InvalidDasRestartPriorityForFtVmFault)(nil)).Elem()
}

// An InvalidDatastore exception is thrown if an operation fails because of a
// problem with the specified datastore.
//
// Typically, a subclass of this
// exception is thrown, indicating a problem such as an inaccessible datastore
// or an invalid datastore path.
type InvalidDatastore struct {
	VimFault

	// The datastore that is invalid.
	//
	// Refers instance of `Datastore`.
	Datastore *ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty"`
	// The name of the datastore that is invalid.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
}

func init() {
	t["InvalidDatastore"] = reflect.TypeOf((*InvalidDatastore)(nil)).Elem()
}

type InvalidDatastoreFault BaseInvalidDatastore

func init() {
	t["InvalidDatastoreFault"] = reflect.TypeOf((*InvalidDatastoreFault)(nil)).Elem()
}

// An InvalidDatastorePath exception is thrown if a datastore path violates
// the expected format.
//
// The expected format is "\[dsName\] path", e.g.
// "\[storage1\] folder/Vm1.vmdk". This exception is also thrown if a datastore
// corresponding to the given datastore path is not found.
type InvalidDatastorePath struct {
	InvalidDatastore

	// The invalid datastore path name, if one was provided.
	DatastorePath string `xml:"datastorePath" json:"datastorePath"`
}

func init() {
	t["InvalidDatastorePath"] = reflect.TypeOf((*InvalidDatastorePath)(nil)).Elem()
}

type InvalidDatastorePathFault InvalidDatastorePath

func init() {
	t["InvalidDatastorePathFault"] = reflect.TypeOf((*InvalidDatastorePathFault)(nil)).Elem()
}

// The datastore is in an invalid state (e.g., maintenance mode)
// for a given operation.
type InvalidDatastoreState struct {
	InvalidState

	// The name of the datastore.
	DatastoreName string `xml:"datastoreName,omitempty" json:"datastoreName,omitempty"`
}

func init() {
	t["InvalidDatastoreState"] = reflect.TypeOf((*InvalidDatastoreState)(nil)).Elem()
}

type InvalidDatastoreStateFault InvalidDatastoreState

func init() {
	t["InvalidDatastoreStateFault"] = reflect.TypeOf((*InvalidDatastoreStateFault)(nil)).Elem()
}

// An InvalidDeviceBacking exception is thrown if
// a device with an incompatible
// device backing is added or edited.
type InvalidDeviceBacking struct {
	InvalidDeviceSpec
}

func init() {
	t["InvalidDeviceBacking"] = reflect.TypeOf((*InvalidDeviceBacking)(nil)).Elem()
}

type InvalidDeviceBackingFault InvalidDeviceBacking

func init() {
	t["InvalidDeviceBackingFault"] = reflect.TypeOf((*InvalidDeviceBackingFault)(nil)).Elem()
}

// An InvalidDeviceOperation exception is thrown if
// virtual machine creation or configuration fails because an invalid
// operation is attempted on the given device.
type InvalidDeviceOperation struct {
	InvalidDeviceSpec

	// The invalid operation attempted.
	BadOp VirtualDeviceConfigSpecOperation `xml:"badOp,omitempty" json:"badOp,omitempty"`
	// The invalid file operation attempted.
	BadFileOp VirtualDeviceConfigSpecFileOperation `xml:"badFileOp,omitempty" json:"badFileOp,omitempty"`
}

func init() {
	t["InvalidDeviceOperation"] = reflect.TypeOf((*InvalidDeviceOperation)(nil)).Elem()
}

type InvalidDeviceOperationFault InvalidDeviceOperation

func init() {
	t["InvalidDeviceOperationFault"] = reflect.TypeOf((*InvalidDeviceOperationFault)(nil)).Elem()
}

// An InvalidDeviceSpec exception is thrown if
// a virtual machine creation or configuration fails because a device
// specification contains an invalid value.
type InvalidDeviceSpec struct {
	InvalidVmConfig

	// Index of the device in the configuration specification that has the invalid value.
	DeviceIndex int32 `xml:"deviceIndex" json:"deviceIndex"`
}

func init() {
	t["InvalidDeviceSpec"] = reflect.TypeOf((*InvalidDeviceSpec)(nil)).Elem()
}

type InvalidDeviceSpecFault BaseInvalidDeviceSpec

func init() {
	t["InvalidDeviceSpecFault"] = reflect.TypeOf((*InvalidDeviceSpecFault)(nil)).Elem()
}

// The disk format is either corrupted or not supported.
type InvalidDiskFormat struct {
	InvalidFormat
}

func init() {
	t["InvalidDiskFormat"] = reflect.TypeOf((*InvalidDiskFormat)(nil)).Elem()
}

type InvalidDiskFormatFault InvalidDiskFormat

func init() {
	t["InvalidDiskFormatFault"] = reflect.TypeOf((*InvalidDiskFormatFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to set the DRS behavior
// of an FT VM to an unsupported value.
//
// Currently, the only supported
// behavior is **DRS Disabled**.
type InvalidDrsBehaviorForFtVm struct {
	InvalidArgument

	// The virtual machine
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The name of the virtual machine
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["InvalidDrsBehaviorForFtVm"] = reflect.TypeOf((*InvalidDrsBehaviorForFtVm)(nil)).Elem()
}

type InvalidDrsBehaviorForFtVmFault InvalidDrsBehaviorForFtVm

func init() {
	t["InvalidDrsBehaviorForFtVmFault"] = reflect.TypeOf((*InvalidDrsBehaviorForFtVmFault)(nil)).Elem()
}

// This event records if the edition is set to an invalid value.
type InvalidEditionEvent struct {
	LicenseEvent

	Feature string `xml:"feature" json:"feature"`
}

func init() {
	t["InvalidEditionEvent"] = reflect.TypeOf((*InvalidEditionEvent)(nil)).Elem()
}

// An ExpiredEditionLicense fault is thrown if an attempt to acquire an Edition license
// 'feature failed for count 'count'.
type InvalidEditionLicense struct {
	NotEnoughLicenses

	Feature string `xml:"feature" json:"feature"`
}

func init() {
	t["InvalidEditionLicense"] = reflect.TypeOf((*InvalidEditionLicense)(nil)).Elem()
}

type InvalidEditionLicenseFault InvalidEditionLicense

func init() {
	t["InvalidEditionLicenseFault"] = reflect.TypeOf((*InvalidEditionLicenseFault)(nil)).Elem()
}

// A InvalidEvent fault is thrown when the event
// is malformed.
type InvalidEvent struct {
	VimFault
}

func init() {
	t["InvalidEvent"] = reflect.TypeOf((*InvalidEvent)(nil)).Elem()
}

type InvalidEventFault InvalidEvent

func init() {
	t["InvalidEventFault"] = reflect.TypeOf((*InvalidEventFault)(nil)).Elem()
}

// An InvalidFolderFault exception is thrown when a
// node is moved to an invalid place in the hierarchy.
//
// This can be because it is a child of the current node,
// or a wrong kind of container.
type InvalidFolder struct {
	VimFault

	// Reference to invalid target.
	//
	// Refers instance of `ManagedEntity`.
	Target ManagedObjectReference `xml:"target" json:"target"`
}

func init() {
	t["InvalidFolder"] = reflect.TypeOf((*InvalidFolder)(nil)).Elem()
}

type InvalidFolderFault BaseInvalidFolder

func init() {
	t["InvalidFolderFault"] = reflect.TypeOf((*InvalidFolderFault)(nil)).Elem()
}

// Throws when an invalid format is detected.
//
// For example, when
// a virtual machine is registered and the system is unable to parse
// the files as a virtual machine.
type InvalidFormat struct {
	VmConfigFault
}

func init() {
	t["InvalidFormat"] = reflect.TypeOf((*InvalidFormat)(nil)).Elem()
}

type InvalidFormatFault BaseInvalidFormat

func init() {
	t["InvalidFormatFault"] = reflect.TypeOf((*InvalidFormatFault)(nil)).Elem()
}

// An InvalidGuestLogin exception is thrown when an operation fails because
// authentication information used to authenticate with the guest was not
// accepted.
type InvalidGuestLogin struct {
	GuestOperationsFault
}

func init() {
	t["InvalidGuestLogin"] = reflect.TypeOf((*InvalidGuestLogin)(nil)).Elem()
}

type InvalidGuestLoginFault InvalidGuestLogin

func init() {
	t["InvalidGuestLoginFault"] = reflect.TypeOf((*InvalidGuestLoginFault)(nil)).Elem()
}

// The host has an invalid connection state.
type InvalidHostConnectionState struct {
	InvalidHostState
}

func init() {
	t["InvalidHostConnectionState"] = reflect.TypeOf((*InvalidHostConnectionState)(nil)).Elem()
}

type InvalidHostConnectionStateFault InvalidHostConnectionState

func init() {
	t["InvalidHostConnectionStateFault"] = reflect.TypeOf((*InvalidHostConnectionStateFault)(nil)).Elem()
}

// The attempted operation requires that the host has a suitable FQDN.
type InvalidHostName struct {
	HostConfigFault
}

func init() {
	t["InvalidHostName"] = reflect.TypeOf((*InvalidHostName)(nil)).Elem()
}

type InvalidHostNameFault InvalidHostName

func init() {
	t["InvalidHostNameFault"] = reflect.TypeOf((*InvalidHostNameFault)(nil)).Elem()
}

// The host has an invalid state.
type InvalidHostState struct {
	InvalidState

	// The host that has an invalid state.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["InvalidHostState"] = reflect.TypeOf((*InvalidHostState)(nil)).Elem()
}

type InvalidHostStateFault BaseInvalidHostState

func init() {
	t["InvalidHostStateFault"] = reflect.TypeOf((*InvalidHostStateFault)(nil)).Elem()
}

// An InvalidIndexArgument exception is thrown if the
// index was not found
type InvalidIndexArgument struct {
	InvalidArgument

	// Value of index that was not found
	Key string `xml:"key" json:"key"`
}

func init() {
	t["InvalidIndexArgument"] = reflect.TypeOf((*InvalidIndexArgument)(nil)).Elem()
}

type InvalidIndexArgumentFault InvalidIndexArgument

func init() {
	t["InvalidIndexArgumentFault"] = reflect.TypeOf((*InvalidIndexArgumentFault)(nil)).Elem()
}

// Illegal value specified for a property of the switch's IpfixConfig.
type InvalidIpfixConfig struct {
	DvsFault

	// Path of the property in IpfixConfig that has an invalid value.
	Property string `xml:"property,omitempty" json:"property,omitempty"`
}

func init() {
	t["InvalidIpfixConfig"] = reflect.TypeOf((*InvalidIpfixConfig)(nil)).Elem()
}

type InvalidIpfixConfigFault InvalidIpfixConfig

func init() {
	t["InvalidIpfixConfigFault"] = reflect.TypeOf((*InvalidIpfixConfigFault)(nil)).Elem()
}

// A InvalidIpmiLoginInfo fault is thrown when the IPMI user name and/or password is
// invalid.
type InvalidIpmiLoginInfo struct {
	VimFault
}

func init() {
	t["InvalidIpmiLoginInfo"] = reflect.TypeOf((*InvalidIpmiLoginInfo)(nil)).Elem()
}

type InvalidIpmiLoginInfoFault InvalidIpmiLoginInfo

func init() {
	t["InvalidIpmiLoginInfoFault"] = reflect.TypeOf((*InvalidIpmiLoginInfoFault)(nil)).Elem()
}

// A InvalidIpmiMacAddress fault is thrown when the IPMI mac address provided by the
// user doesn't match with the observed mac address on the host.
type InvalidIpmiMacAddress struct {
	VimFault

	UserProvidedMacAddress string `xml:"userProvidedMacAddress" json:"userProvidedMacAddress"`
	ObservedMacAddress     string `xml:"observedMacAddress" json:"observedMacAddress"`
}

func init() {
	t["InvalidIpmiMacAddress"] = reflect.TypeOf((*InvalidIpmiMacAddress)(nil)).Elem()
}

type InvalidIpmiMacAddressFault InvalidIpmiMacAddress

func init() {
	t["InvalidIpmiMacAddressFault"] = reflect.TypeOf((*InvalidIpmiMacAddressFault)(nil)).Elem()
}

// Thrown when
// an attempt is made to upload license content
// that is invalid.
type InvalidLicense struct {
	VimFault

	// The content of the license being reported as invalid.
	LicenseContent string `xml:"licenseContent" json:"licenseContent"`
}

func init() {
	t["InvalidLicense"] = reflect.TypeOf((*InvalidLicense)(nil)).Elem()
}

type InvalidLicenseFault InvalidLicense

func init() {
	t["InvalidLicenseFault"] = reflect.TypeOf((*InvalidLicenseFault)(nil)).Elem()
}

// Thrown when a locale name is unknown or invalid.
type InvalidLocale struct {
	VimFault
}

func init() {
	t["InvalidLocale"] = reflect.TypeOf((*InvalidLocale)(nil)).Elem()
}

type InvalidLocaleFault InvalidLocale

func init() {
	t["InvalidLocaleFault"] = reflect.TypeOf((*InvalidLocaleFault)(nil)).Elem()
}

// Thrown when a server logon fails due to a bad user name or
// password.
type InvalidLogin struct {
	VimFault
}

func init() {
	t["InvalidLogin"] = reflect.TypeOf((*InvalidLogin)(nil)).Elem()
}

type InvalidLoginFault BaseInvalidLogin

func init() {
	t["InvalidLoginFault"] = reflect.TypeOf((*InvalidLoginFault)(nil)).Elem()
}

// A InvalidName fault is thrown when the name
// contains an invalid character or format.
type InvalidName struct {
	VimFault

	// The invalid name.
	Name string `xml:"name" json:"name"`
	// Entity, if any, that has an invalid name.
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["InvalidName"] = reflect.TypeOf((*InvalidName)(nil)).Elem()
}

type InvalidNameFault InvalidName

func init() {
	t["InvalidNameFault"] = reflect.TypeOf((*InvalidNameFault)(nil)).Elem()
}

// This fault is thrown when an operation to configure a CIFS volume
// fails because the credentials specified in the
// `spec` are incorrect.
type InvalidNasCredentials struct {
	NasConfigFault

	// The username associated with the CIFS connection.
	UserName string `xml:"userName" json:"userName"`
}

func init() {
	t["InvalidNasCredentials"] = reflect.TypeOf((*InvalidNasCredentials)(nil)).Elem()
}

type InvalidNasCredentialsFault InvalidNasCredentials

func init() {
	t["InvalidNasCredentialsFault"] = reflect.TypeOf((*InvalidNasCredentialsFault)(nil)).Elem()
}

// The network specified in the property does not exists.
type InvalidNetworkInType struct {
	VAppPropertyFault
}

func init() {
	t["InvalidNetworkInType"] = reflect.TypeOf((*InvalidNetworkInType)(nil)).Elem()
}

type InvalidNetworkInTypeFault InvalidNetworkInType

func init() {
	t["InvalidNetworkInTypeFault"] = reflect.TypeOf((*InvalidNetworkInTypeFault)(nil)).Elem()
}

// This fault is thrown when an operation to configure a NAS volume fails
// because the network resource specified is invalid.
type InvalidNetworkResource struct {
	NasConfigFault

	// The host that runs the CIFS or NFS server.
	RemoteHost string `xml:"remoteHost" json:"remoteHost"`
	// The remote share.
	RemotePath string `xml:"remotePath" json:"remotePath"`
}

func init() {
	t["InvalidNetworkResource"] = reflect.TypeOf((*InvalidNetworkResource)(nil)).Elem()
}

type InvalidNetworkResourceFault InvalidNetworkResource

func init() {
	t["InvalidNetworkResourceFault"] = reflect.TypeOf((*InvalidNetworkResourceFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to invoke an operation on
// a secondary virtual machine that is only supported on the primary virtual
// machine of the fault tolerant group.
type InvalidOperationOnSecondaryVm struct {
	VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string `xml:"instanceUuid" json:"instanceUuid"`
}

func init() {
	t["InvalidOperationOnSecondaryVm"] = reflect.TypeOf((*InvalidOperationOnSecondaryVm)(nil)).Elem()
}

type InvalidOperationOnSecondaryVmFault InvalidOperationOnSecondaryVm

func init() {
	t["InvalidOperationOnSecondaryVmFault"] = reflect.TypeOf((*InvalidOperationOnSecondaryVmFault)(nil)).Elem()
}

// This exception is thrown if the
// power operation attempted could not be performed given
// the current power state of the virtual machine.
type InvalidPowerState struct {
	InvalidState

	// Power state of the virtual machine required to
	// allow the operation to succeed.
	RequestedState VirtualMachinePowerState `xml:"requestedState,omitempty" json:"requestedState,omitempty"`
	// Power state of the virtual machine that
	// prevented the operation from succeeding.
	ExistingState VirtualMachinePowerState `xml:"existingState" json:"existingState"`
}

func init() {
	t["InvalidPowerState"] = reflect.TypeOf((*InvalidPowerState)(nil)).Elem()
}

type InvalidPowerStateFault InvalidPowerState

func init() {
	t["InvalidPowerStateFault"] = reflect.TypeOf((*InvalidPowerStateFault)(nil)).Elem()
}

// A InvalidPrivilege fault is thrown when the privilege
// does not exist.
type InvalidPrivilege struct {
	VimFault

	// The invalid privilege.
	Privilege string `xml:"privilege" json:"privilege"`
}

func init() {
	t["InvalidPrivilege"] = reflect.TypeOf((*InvalidPrivilege)(nil)).Elem()
}

type InvalidPrivilegeFault InvalidPrivilege

func init() {
	t["InvalidPrivilegeFault"] = reflect.TypeOf((*InvalidPrivilegeFault)(nil)).Elem()
}

// A InvalidProfileReferenceHost fault is thrown when a valid host is not
// associated with a profile in the Virtual Center inventory.
//
// This could
// be because there is no host assciated with the profile or because the
// associated host is incompatible with the profile.
type InvalidProfileReferenceHost struct {
	RuntimeFault

	// The reason for the invalid reference host if known.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
	// The incompatible host if associated with the profile.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The profile with the invalid or missing reference host.
	//
	// Refers instance of `Profile`.
	Profile *ManagedObjectReference `xml:"profile,omitempty" json:"profile,omitempty"`
	// The profile name: the replacement of the member above.
	ProfileName string `xml:"profileName,omitempty" json:"profileName,omitempty"`
}

func init() {
	t["InvalidProfileReferenceHost"] = reflect.TypeOf((*InvalidProfileReferenceHost)(nil)).Elem()
}

type InvalidProfileReferenceHostFault InvalidProfileReferenceHost

func init() {
	t["InvalidProfileReferenceHostFault"] = reflect.TypeOf((*InvalidProfileReferenceHostFault)(nil)).Elem()
}

// Thrown when an invalid property path has been referenced.
type InvalidProperty struct {
	MethodFault

	// The property name that generated the error.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["InvalidProperty"] = reflect.TypeOf((*InvalidProperty)(nil)).Elem()
}

type InvalidPropertyFault InvalidProperty

func init() {
	t["InvalidPropertyFault"] = reflect.TypeOf((*InvalidPropertyFault)(nil)).Elem()
}

// The type specification in the property in invalid.
type InvalidPropertyType struct {
	VAppPropertyFault
}

func init() {
	t["InvalidPropertyType"] = reflect.TypeOf((*InvalidPropertyType)(nil)).Elem()
}

type InvalidPropertyTypeFault InvalidPropertyType

func init() {
	t["InvalidPropertyTypeFault"] = reflect.TypeOf((*InvalidPropertyTypeFault)(nil)).Elem()
}

// The value of the property is not valid given the type of the property.
type InvalidPropertyValue struct {
	VAppPropertyFault
}

func init() {
	t["InvalidPropertyValue"] = reflect.TypeOf((*InvalidPropertyValue)(nil)).Elem()
}

type InvalidPropertyValueFault BaseInvalidPropertyValue

func init() {
	t["InvalidPropertyValueFault"] = reflect.TypeOf((*InvalidPropertyValueFault)(nil)).Elem()
}

// An InvalidRequest fault is thrown in response to a malformed
// request to the server that fails in the transport layer, e.g.,
// the SOAP XML request was invalid.
//
// Sub-types of this fault,
// provides more specific transport errors, such as a using a
// reference to an unknown managed object type or method.
type InvalidRequest struct {
	RuntimeFault
}

func init() {
	t["InvalidRequest"] = reflect.TypeOf((*InvalidRequest)(nil)).Elem()
}

type InvalidRequestFault BaseInvalidRequest

func init() {
	t["InvalidRequestFault"] = reflect.TypeOf((*InvalidRequestFault)(nil)).Elem()
}

// This fault is thrown when an operation will cause the structure of a resource
// pool hiearchy to exceed its limit.
//
// The limits are typically imposed by the total
// number of nodes, maximum fan-out, and total depth of the hierarchy.
type InvalidResourcePoolStructureFault struct {
	InsufficientResourcesFault
}

func init() {
	t["InvalidResourcePoolStructureFault"] = reflect.TypeOf((*InvalidResourcePoolStructureFault)(nil)).Elem()
}

type InvalidResourcePoolStructureFaultFault InvalidResourcePoolStructureFault

func init() {
	t["InvalidResourcePoolStructureFaultFault"] = reflect.TypeOf((*InvalidResourcePoolStructureFaultFault)(nil)).Elem()
}

// This exception is thrown when an unauthorized
// user runs a scheduled task.
type InvalidScheduledTask struct {
	RuntimeFault
}

func init() {
	t["InvalidScheduledTask"] = reflect.TypeOf((*InvalidScheduledTask)(nil)).Elem()
	minAPIVersionForType["InvalidScheduledTask"] = "8.0.2.0"
}

type InvalidScheduledTaskFault InvalidScheduledTask

func init() {
	t["InvalidScheduledTaskFault"] = reflect.TypeOf((*InvalidScheduledTaskFault)(nil)).Elem()
}

// Thrown when an invalid snapshot configuration is detected.
//
// For
// example, when a virtual machine's snapshot tree includes
// snapshots that are no longer present.
type InvalidSnapshotFormat struct {
	InvalidFormat
}

func init() {
	t["InvalidSnapshotFormat"] = reflect.TypeOf((*InvalidSnapshotFormat)(nil)).Elem()
}

type InvalidSnapshotFormatFault InvalidSnapshotFormat

func init() {
	t["InvalidSnapshotFormatFault"] = reflect.TypeOf((*InvalidSnapshotFormatFault)(nil)).Elem()
}

// An InvalidState fault is thrown if the
// operation failed due to the current state of the system.
type InvalidState struct {
	VimFault
}

func init() {
	t["InvalidState"] = reflect.TypeOf((*InvalidState)(nil)).Elem()
}

type InvalidStateFault BaseInvalidState

func init() {
	t["InvalidStateFault"] = reflect.TypeOf((*InvalidStateFault)(nil)).Elem()
}

// InvalidType is thrown when a managed object request refers to
// an unexpected or unknown type.
type InvalidType struct {
	InvalidRequest

	// Name of the argument that was malformed.
	Argument string `xml:"argument,omitempty" json:"argument,omitempty"`
}

func init() {
	t["InvalidType"] = reflect.TypeOf((*InvalidType)(nil)).Elem()
}

type InvalidTypeFault InvalidType

func init() {
	t["InvalidTypeFault"] = reflect.TypeOf((*InvalidTypeFault)(nil)).Elem()
}

// Thrown when virtual machine creation or configuration fails.
//
// This is
// a base type for all virtual machine configuration errors.
type InvalidVmConfig struct {
	VmConfigFault

	// Path of the property in configSpec that has an invalid value.
	Property string `xml:"property,omitempty" json:"property,omitempty"`
}

func init() {
	t["InvalidVmConfig"] = reflect.TypeOf((*InvalidVmConfig)(nil)).Elem()
}

type InvalidVmConfigFault BaseInvalidVmConfig

func init() {
	t["InvalidVmConfigFault"] = reflect.TypeOf((*InvalidVmConfigFault)(nil)).Elem()
}

// The VM has an invalid state.
type InvalidVmState struct {
	InvalidState

	// The VM that has an invalid state.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
}

func init() {
	t["InvalidVmState"] = reflect.TypeOf((*InvalidVmState)(nil)).Elem()
}

type InvalidVmStateFault InvalidVmState

func init() {
	t["InvalidVmStateFault"] = reflect.TypeOf((*InvalidVmStateFault)(nil)).Elem()
}

// Data object to capture all information needed to
// describe a sample inventory.
type InventoryDescription struct {
	DynamicData

	// The number of hosts.
	NumHosts int32 `xml:"numHosts" json:"numHosts"`
	// The number of virtual machines.
	NumVirtualMachines int32 `xml:"numVirtualMachines" json:"numVirtualMachines"`
	// The number of resource pools.
	//
	// Default value is equal to numHosts
	NumResourcePools int32 `xml:"numResourcePools,omitempty" json:"numResourcePools,omitempty"`
	// The number of clusters.
	//
	// Default value is equal to numHosts/5.
	NumClusters int32 `xml:"numClusters,omitempty" json:"numClusters,omitempty"`
	// The number cpu devices per host.
	//
	// Default value is 4.
	NumCpuDev int32 `xml:"numCpuDev,omitempty" json:"numCpuDev,omitempty"`
	// The number network devices per host.
	//
	// Default value is 2.
	NumNetDev int32 `xml:"numNetDev,omitempty" json:"numNetDev,omitempty"`
	// The number disk devices per host.
	//
	// Default value is 10.
	NumDiskDev int32 `xml:"numDiskDev,omitempty" json:"numDiskDev,omitempty"`
	// The number cpu devices per vm.
	//
	// Default value is 2.
	NumvCpuDev int32 `xml:"numvCpuDev,omitempty" json:"numvCpuDev,omitempty"`
	// The number network devices per vm.
	//
	// Default value is 1.
	NumvNetDev int32 `xml:"numvNetDev,omitempty" json:"numvNetDev,omitempty"`
	// The number disk devices per vm.
	//
	// Default value is 4.
	NumvDiskDev int32 `xml:"numvDiskDev,omitempty" json:"numvDiskDev,omitempty"`
}

func init() {
	t["InventoryDescription"] = reflect.TypeOf((*InventoryDescription)(nil)).Elem()
}

// A InventoryHasStandardAloneHosts fault is thrown if an assignment operation tries to downgrade a license that does have allow hosts licensed with StandardAlone license in the inventory.
type InventoryHasStandardAloneHosts struct {
	NotEnoughLicenses

	Hosts []string `xml:"hosts" json:"hosts"`
}

func init() {
	t["InventoryHasStandardAloneHosts"] = reflect.TypeOf((*InventoryHasStandardAloneHosts)(nil)).Elem()
}

type InventoryHasStandardAloneHostsFault InventoryHasStandardAloneHosts

func init() {
	t["InventoryHasStandardAloneHostsFault"] = reflect.TypeOf((*InventoryHasStandardAloneHostsFault)(nil)).Elem()
}

// The issues on a host.
type IoFilterHostIssue struct {
	DynamicData

	// Host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The issues.
	Issue []LocalizedMethodFault `xml:"issue" json:"issue"`
}

func init() {
	t["IoFilterHostIssue"] = reflect.TypeOf((*IoFilterHostIssue)(nil)).Elem()
}

// Information about an IO Filter.
type IoFilterInfo struct {
	DynamicData

	// IO Filter identifier.
	Id string `xml:"id" json:"id"`
	// Name of the IO Filter.
	Name string `xml:"name" json:"name"`
	// Vendor of the IO Filter.
	Vendor string `xml:"vendor" json:"vendor"`
	// Version of the IO Filter.
	Version string `xml:"version" json:"version"`
	// Type of the IO Filter.
	//
	// The set of possible values are listed in
	// `IoFilterType_enum`.
	// The property is unset if the information is not available.
	Type string `xml:"type,omitempty" json:"type,omitempty"`
	// Short description of the IO Filter.
	//
	// The property is unset if the information is not available.
	Summary string `xml:"summary,omitempty" json:"summary,omitempty"`
	// Release date of the IO Filter.
	//
	// The property is unset if the information is not available.
	ReleaseDate string `xml:"releaseDate,omitempty" json:"releaseDate,omitempty"`
}

func init() {
	t["IoFilterInfo"] = reflect.TypeOf((*IoFilterInfo)(nil)).Elem()
}

// Specifies an SSL trust policy.
type IoFilterManagerSslTrust struct {
	DynamicData
}

func init() {
	t["IoFilterManagerSslTrust"] = reflect.TypeOf((*IoFilterManagerSslTrust)(nil)).Elem()
	minAPIVersionForType["IoFilterManagerSslTrust"] = "8.0.3.0"
}

// Result for `IoFilterManager.QueryIoFilterIssues`.
type IoFilterQueryIssueResult struct {
	DynamicData

	// The type of the operation performed on the IO Filter.
	//
	// The set of possible values are defined in
	// `IoFilterOperation_enum`.
	OpType string `xml:"opType" json:"opType"`
	// The issues on hosts.
	HostIssue []IoFilterHostIssue `xml:"hostIssue,omitempty" json:"hostIssue,omitempty"`
}

func init() {
	t["IoFilterQueryIssueResult"] = reflect.TypeOf((*IoFilterQueryIssueResult)(nil)).Elem()
}

// This is the abstract base class for IP address.
type IpAddress struct {
	NegatableExpression
}

func init() {
	t["IpAddress"] = reflect.TypeOf((*IpAddress)(nil)).Elem()
}

// The `IpAddressProfile` represents the Virtual NIC IP address.
//
// The `ApplyProfile.policy` property contains
// the configuration data values for the IP address.
type IpAddressProfile struct {
	ApplyProfile
}

func init() {
	t["IpAddressProfile"] = reflect.TypeOf((*IpAddressProfile)(nil)).Elem()
}

// An error occurred while running the IP/hostname generator application
type IpHostnameGeneratorError struct {
	CustomizationFault
}

func init() {
	t["IpHostnameGeneratorError"] = reflect.TypeOf((*IpHostnameGeneratorError)(nil)).Elem()
}

type IpHostnameGeneratorErrorFault IpHostnameGeneratorError

func init() {
	t["IpHostnameGeneratorErrorFault"] = reflect.TypeOf((*IpHostnameGeneratorErrorFault)(nil)).Elem()
}

// Specifications of the network configuration to be used on a
// network.
//
// This is used to generate IP addresses and for self-customization
// of vApps.
type IpPool struct {
	DynamicData

	// Unique ID, generated by the server.
	//
	// This is used to identify the pool in
	// subsequent lookups or updates. The generated value is also returned by the `IpPoolManager.CreateIpPool` method.
	Id int32 `xml:"id,omitempty" json:"id,omitempty"`
	// Pool name.
	//
	// The pool name must be unique within the datacenter.
	//
	// Any / (slash), \\ (backslash), character used in this
	// name element is escaped. Similarly, any % (percent) character used in
	// this name element is escaped, unless it is used to start an escape
	// sequence. A slash is escaped as %2F or %2f. A backslash is escaped as %5C or
	// %5c, and a percent is escaped as %25.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// IPv4 configuration.
	//
	// This configuration is always present on the pool. To disable allocation, set the
	// ipPoolEnabled flag of the config to false.
	Ipv4Config *IpPoolIpPoolConfigInfo `xml:"ipv4Config,omitempty" json:"ipv4Config,omitempty"`
	// IPv6 configuration.
	//
	// This configuration is always present on the pool. To disable allocation, set the
	// ipPoolEnabled flag of the config to false.
	Ipv6Config *IpPoolIpPoolConfigInfo `xml:"ipv6Config,omitempty" json:"ipv6Config,omitempty"`
	// DNS Domain.
	//
	// For example, vmware.com. This can be an empty string if no
	// domain is configured.
	DnsDomain string `xml:"dnsDomain,omitempty" json:"dnsDomain,omitempty"`
	// DNS Search Path.
	//
	// For example, eng.vmware.com;vmware.com
	DnsSearchPath string `xml:"dnsSearchPath,omitempty" json:"dnsSearchPath,omitempty"`
	// Prefix for hostnames.
	HostPrefix string `xml:"hostPrefix,omitempty" json:"hostPrefix,omitempty"`
	// The HTTP proxy to use on this network, e.g., &lt;host&gt;:&lt;port&gt;
	HttpProxy string `xml:"httpProxy,omitempty" json:"httpProxy,omitempty"`
	// The networks that are associated with this IP pool
	NetworkAssociation []IpPoolAssociation `xml:"networkAssociation,omitempty" json:"networkAssociation,omitempty"`
	// The number of IPv4 addresses available for allocation.
	AvailableIpv4Addresses int32 `xml:"availableIpv4Addresses,omitempty" json:"availableIpv4Addresses,omitempty"`
	// The number of IPv6 addresses available for allocation.
	AvailableIpv6Addresses int32 `xml:"availableIpv6Addresses,omitempty" json:"availableIpv6Addresses,omitempty"`
	// The number of allocated IPv4 addresses.
	AllocatedIpv4Addresses int32 `xml:"allocatedIpv4Addresses,omitempty" json:"allocatedIpv4Addresses,omitempty"`
	// The number of allocated IPv6 addresses.
	AllocatedIpv6Addresses int32 `xml:"allocatedIpv6Addresses,omitempty" json:"allocatedIpv6Addresses,omitempty"`
}

func init() {
	t["IpPool"] = reflect.TypeOf((*IpPool)(nil)).Elem()
}

// Information about a network or portgroup that is associated to an IP pool.
type IpPoolAssociation struct {
	DynamicData

	// The network object
	//
	// Refers instance of `Network`.
	Network *ManagedObjectReference `xml:"network,omitempty" json:"network,omitempty"`
	// The name of the network or portgroup
	//
	// This field is only used when querying existing IP pools. It is ignored when
	// creating or updating pools.
	NetworkName string `xml:"networkName" json:"networkName"`
}

func init() {
	t["IpPoolAssociation"] = reflect.TypeOf((*IpPoolAssociation)(nil)).Elem()
}

// Specifications of either IPv4 or IPv6 configuration to be used
// on this network.
//
// This is a part of network configuration.
//
// IPv4 addresses are in dot-decimal notation, e.g.: 192.0.2.235
//
// IPv6 addresses are in colon-hexadecimal notation,
// e.g.: 2001:0db8:85a3::0370:7334
type IpPoolIpPoolConfigInfo struct {
	DynamicData

	// Address of the subnet.
	//
	// For example:
	//   - IPv4: 192.168.5.0
	//   - IPv6: 2001:0db8:85a3::
	SubnetAddress string `xml:"subnetAddress,omitempty" json:"subnetAddress,omitempty"`
	// Netmask
	//
	// For example:
	//   - IPv4: 255.255.255.0
	//   - IPv6: ffff:ffff:ffff::
	Netmask string `xml:"netmask,omitempty" json:"netmask,omitempty"`
	// Gateway.
	//
	// This can be an empty string - if no gateway is configured.
	//
	// Examples:
	//   - IPv4: 192.168.5.1
	//   - IPv6: 2001:0db8:85a3::1
	Gateway string `xml:"gateway,omitempty" json:"gateway,omitempty"`
	// IP range.
	//
	// This is specified as a set of ranges separated with commas.
	// One range is given by a start address, a hash (#), and the length
	// of the range.
	//
	// For example:
	//   - 192.0.2.235 # 20 is the IPv4 range from 192.0.2.235 to 192.0.2.254
	//   - 2001::7334 # 20 is the IPv6 range from 2001::7334 to 2001::7347
	Range string `xml:"range,omitempty" json:"range,omitempty"`
	// DNS servers
	//
	// For example:
	//   - IPv4: \["10.20.0.1", "10.20.0.2"\]
	//   - IPv6: \["2001:0db8:85a3::0370:7334", "2001:0db8:85a3::0370:7335"\]
	//
	// If an empty list is passed, the existing value remains unchanged. To clear this
	// list, pass an array containing the empty string as it's only element.
	Dns []string `xml:"dns,omitempty" json:"dns,omitempty"`
	// Whether a DHCP server is available on this network.
	DhcpServerAvailable *bool `xml:"dhcpServerAvailable" json:"dhcpServerAvailable,omitempty"`
	// IP addresses can only be allocated from the range if the IP pool is
	// enabled.
	IpPoolEnabled *bool `xml:"ipPoolEnabled" json:"ipPoolEnabled,omitempty"`
}

func init() {
	t["IpPoolIpPoolConfigInfo"] = reflect.TypeOf((*IpPoolIpPoolConfigInfo)(nil)).Elem()
}

// Describes an IP allocation.
type IpPoolManagerIpAllocation struct {
	DynamicData

	// IP address
	IpAddress string `xml:"ipAddress" json:"ipAddress"`
	// The allocation ID
	AllocationId string `xml:"allocationId" json:"allocationId"`
}

func init() {
	t["IpPoolManagerIpAllocation"] = reflect.TypeOf((*IpPoolManagerIpAllocation)(nil)).Elem()
}

// This class specifies a range of IP addresses by using prefix.
//
// Usage: 128.20.20.10/24. Here 128.20.20.10 is IP address
// and 24 is prefix length.
type IpRange struct {
	IpAddress

	// IP address prefix.
	AddressPrefix string `xml:"addressPrefix" json:"addressPrefix"`
	// Prefix length with max value of 32 for IPv4 and 128 for IPv6.
	PrefixLength int32 `xml:"prefixLength,omitempty" json:"prefixLength,omitempty"`
}

func init() {
	t["IpRange"] = reflect.TypeOf((*IpRange)(nil)).Elem()
}

// The `IpRouteProfile` data object represents the host IP route configuration.
//
// If a profile plug-in defines policies or subprofiles, use the
// `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the additional configuration data.
type IpRouteProfile struct {
	ApplyProfile

	// List of static routes to be configured.
	StaticRoute []StaticRouteProfile `xml:"staticRoute,omitempty" json:"staticRoute,omitempty"`
}

func init() {
	t["IpRouteProfile"] = reflect.TypeOf((*IpRouteProfile)(nil)).Elem()
}

type IsClusteredVmdkEnabled IsClusteredVmdkEnabledRequestType

func init() {
	t["IsClusteredVmdkEnabled"] = reflect.TypeOf((*IsClusteredVmdkEnabled)(nil)).Elem()
}

type IsClusteredVmdkEnabledRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["IsClusteredVmdkEnabledRequestType"] = reflect.TypeOf((*IsClusteredVmdkEnabledRequestType)(nil)).Elem()
}

type IsClusteredVmdkEnabledResponse struct {
	Returnval bool `xml:"returnval" json:"returnval"`
}

type IsKmsClusterActive IsKmsClusterActiveRequestType

func init() {
	t["IsKmsClusterActive"] = reflect.TypeOf((*IsKmsClusterActive)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.IsKmsClusterActive`.
type IsKmsClusterActiveRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP cluster.
	// Will use default cluster if omitted.
	Cluster *KeyProviderId `xml:"cluster,omitempty" json:"cluster,omitempty"`
}

func init() {
	t["IsKmsClusterActiveRequestType"] = reflect.TypeOf((*IsKmsClusterActiveRequestType)(nil)).Elem()
}

type IsKmsClusterActiveResponse struct {
	Returnval bool `xml:"returnval" json:"returnval"`
}

type IsSharedGraphicsActive IsSharedGraphicsActiveRequestType

func init() {
	t["IsSharedGraphicsActive"] = reflect.TypeOf((*IsSharedGraphicsActive)(nil)).Elem()
}

type IsSharedGraphicsActiveRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["IsSharedGraphicsActiveRequestType"] = reflect.TypeOf((*IsSharedGraphicsActiveRequestType)(nil)).Elem()
}

type IsSharedGraphicsActiveResponse struct {
	Returnval bool `xml:"returnval" json:"returnval"`
}

// Defines a dependency entity.
//
// Contains the affected Virtual NIC device name and iSCSI HBA name
// (if Virtual NIC is associated with the HBA).
// See `IscsiMigrationDependency`
type IscsiDependencyEntity struct {
	DynamicData

	// The affected Physical NIC device
	PnicDevice string `xml:"pnicDevice" json:"pnicDevice"`
	// The affected Virtual NIC device
	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
	// The iSCSI HBA that the Virtual NIC is associated with, if any.
	VmhbaName string `xml:"vmhbaName" json:"vmhbaName"`
}

func init() {
	t["IscsiDependencyEntity"] = reflect.TypeOf((*IscsiDependencyEntity)(nil)).Elem()
}

// Base class for faults that can be thrown while invoking iSCSI management operations.
type IscsiFault struct {
	VimFault
}

func init() {
	t["IscsiFault"] = reflect.TypeOf((*IscsiFault)(nil)).Elem()
}

type IscsiFaultFault BaseIscsiFault

func init() {
	t["IscsiFaultFault"] = reflect.TypeOf((*IscsiFaultFault)(nil)).Elem()
}

// This fault indicates an attempt is made to bind a Virtual NIC to an iSCSI adapter
// where the Virtual NIC has no association with the adapter.
//
// For ex: The uplink for
// the given Virtual NIC is not valid for the iSCSI HBA.
type IscsiFaultInvalidVnic struct {
	IscsiFault

	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
}

func init() {
	t["IscsiFaultInvalidVnic"] = reflect.TypeOf((*IscsiFaultInvalidVnic)(nil)).Elem()
}

type IscsiFaultInvalidVnicFault IscsiFaultInvalidVnic

func init() {
	t["IscsiFaultInvalidVnicFault"] = reflect.TypeOf((*IscsiFaultInvalidVnicFault)(nil)).Elem()
}

// This fault indicates the given Physical NIC is being used by iSCSI HBA.
type IscsiFaultPnicInUse struct {
	IscsiFault

	PnicDevice string `xml:"pnicDevice" json:"pnicDevice"`
}

func init() {
	t["IscsiFaultPnicInUse"] = reflect.TypeOf((*IscsiFaultPnicInUse)(nil)).Elem()
}

type IscsiFaultPnicInUseFault IscsiFaultPnicInUse

func init() {
	t["IscsiFaultPnicInUseFault"] = reflect.TypeOf((*IscsiFaultPnicInUseFault)(nil)).Elem()
}

// This fault indicates that the given Virtual NIC is already bound to the iSCSI HBA.
type IscsiFaultVnicAlreadyBound struct {
	IscsiFault

	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
}

func init() {
	t["IscsiFaultVnicAlreadyBound"] = reflect.TypeOf((*IscsiFaultVnicAlreadyBound)(nil)).Elem()
}

type IscsiFaultVnicAlreadyBoundFault IscsiFaultVnicAlreadyBound

func init() {
	t["IscsiFaultVnicAlreadyBoundFault"] = reflect.TypeOf((*IscsiFaultVnicAlreadyBoundFault)(nil)).Elem()
}

// This fault indicates the given Virtual NIC has active storage paths associated with it.
type IscsiFaultVnicHasActivePaths struct {
	IscsiFault

	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
}

func init() {
	t["IscsiFaultVnicHasActivePaths"] = reflect.TypeOf((*IscsiFaultVnicHasActivePaths)(nil)).Elem()
}

type IscsiFaultVnicHasActivePathsFault IscsiFaultVnicHasActivePaths

func init() {
	t["IscsiFaultVnicHasActivePathsFault"] = reflect.TypeOf((*IscsiFaultVnicHasActivePathsFault)(nil)).Elem()
}

// This fault indicates that the Virtual NIC has multiple uplinks and not suitable for iSCSI
// multi-pathing and can not be bound to iSCSI HBA.
type IscsiFaultVnicHasMultipleUplinks struct {
	IscsiFault

	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
}

func init() {
	t["IscsiFaultVnicHasMultipleUplinks"] = reflect.TypeOf((*IscsiFaultVnicHasMultipleUplinks)(nil)).Elem()
}

type IscsiFaultVnicHasMultipleUplinksFault IscsiFaultVnicHasMultipleUplinks

func init() {
	t["IscsiFaultVnicHasMultipleUplinksFault"] = reflect.TypeOf((*IscsiFaultVnicHasMultipleUplinksFault)(nil)).Elem()
}

// This fault indicates the given Virtual NIC has no uplinks and not suitable for iSCSI
// multi-pathing configuration.
type IscsiFaultVnicHasNoUplinks struct {
	IscsiFault

	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
}

func init() {
	t["IscsiFaultVnicHasNoUplinks"] = reflect.TypeOf((*IscsiFaultVnicHasNoUplinks)(nil)).Elem()
}

type IscsiFaultVnicHasNoUplinksFault IscsiFaultVnicHasNoUplinks

func init() {
	t["IscsiFaultVnicHasNoUplinksFault"] = reflect.TypeOf((*IscsiFaultVnicHasNoUplinksFault)(nil)).Elem()
}

// This fault indicates the given Virtual NIC has the wrong Physical uplink
// for iSCSI multi-pathing configuration.
//
// The Physical uplink is not associated
// with the iSCSI Host Bus Adapter.
type IscsiFaultVnicHasWrongUplink struct {
	IscsiFault

	// Contains the VMkernel virtual NIC device name.
	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
}

func init() {
	t["IscsiFaultVnicHasWrongUplink"] = reflect.TypeOf((*IscsiFaultVnicHasWrongUplink)(nil)).Elem()
}

type IscsiFaultVnicHasWrongUplinkFault IscsiFaultVnicHasWrongUplink

func init() {
	t["IscsiFaultVnicHasWrongUplinkFault"] = reflect.TypeOf((*IscsiFaultVnicHasWrongUplinkFault)(nil)).Elem()
}

// This fault indicates the given Virtual NIC is being used by iSCSI and the requested operation can't be completed.
type IscsiFaultVnicInUse struct {
	IscsiFault

	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
}

func init() {
	t["IscsiFaultVnicInUse"] = reflect.TypeOf((*IscsiFaultVnicInUse)(nil)).Elem()
}

type IscsiFaultVnicInUseFault IscsiFaultVnicInUse

func init() {
	t["IscsiFaultVnicInUseFault"] = reflect.TypeOf((*IscsiFaultVnicInUseFault)(nil)).Elem()
}

// This fault indicates that the given Virtual NIC is associated with the only path to the storage.
//
// Any attempt to unbind this
// from iSCSI HBA would result in storage being inaccessible.
type IscsiFaultVnicIsLastPath struct {
	IscsiFault

	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
}

func init() {
	t["IscsiFaultVnicIsLastPath"] = reflect.TypeOf((*IscsiFaultVnicIsLastPath)(nil)).Elem()
}

type IscsiFaultVnicIsLastPathFault IscsiFaultVnicIsLastPath

func init() {
	t["IscsiFaultVnicIsLastPathFault"] = reflect.TypeOf((*IscsiFaultVnicIsLastPathFault)(nil)).Elem()
}

// This fault indicates an attempt was made to remove a Virtual NIC from an iSCSI HBA while
// Virtual NIC is not associated with the adapter.
type IscsiFaultVnicNotBound struct {
	IscsiFault

	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
}

func init() {
	t["IscsiFaultVnicNotBound"] = reflect.TypeOf((*IscsiFaultVnicNotBound)(nil)).Elem()
}

type IscsiFaultVnicNotBoundFault IscsiFaultVnicNotBound

func init() {
	t["IscsiFaultVnicNotBoundFault"] = reflect.TypeOf((*IscsiFaultVnicNotBoundFault)(nil)).Elem()
}

// This fault indicates an attempt was made to add a non-existent Virtual NIC adapter.
type IscsiFaultVnicNotFound struct {
	IscsiFault

	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
}

func init() {
	t["IscsiFaultVnicNotFound"] = reflect.TypeOf((*IscsiFaultVnicNotFound)(nil)).Elem()
}

type IscsiFaultVnicNotFoundFault IscsiFaultVnicNotFound

func init() {
	t["IscsiFaultVnicNotFoundFault"] = reflect.TypeOf((*IscsiFaultVnicNotFoundFault)(nil)).Elem()
}

// Provides migration dependency information for a given Physical NIC.
//
// Lists all the iSCSI and networking resources impacted if
// migration of a given Physical NIC is to take place.
type IscsiMigrationDependency struct {
	DynamicData

	// Indicates whether migration can be safely performed
	// If migrationAllowed is False, the disallowReason will
	// contain the specific condition that makes the migration
	// attempt unsafe.
	MigrationAllowed bool `xml:"migrationAllowed" json:"migrationAllowed"`
	// Reasons for not allowing migration.
	//
	// Unset if migrationAllowed is true.
	DisallowReason *IscsiStatus `xml:"disallowReason,omitempty" json:"disallowReason,omitempty"`
	// Details of all the resources affected by migration.
	Dependency []IscsiDependencyEntity `xml:"dependency,omitempty" json:"dependency,omitempty"`
}

func init() {
	t["IscsiMigrationDependency"] = reflect.TypeOf((*IscsiMigrationDependency)(nil)).Elem()
}

// The `IscsiPortInfo` data object describes the
// Virtual NIC that are bound to an iSCSI adapter and
// also it describes the candidate Virtual NICs that
// can be bound to a given iSCSI adapter.
type IscsiPortInfo struct {
	DynamicData

	// Virtual NIC Name.
	//
	// Contains the name of the Virtual NIC device. This may be
	// unset in case where the bound Virtual NIC doesn't have the system object or
	// where a candidate Physical NIC isn't associated with any Virtual NIC.
	VnicDevice string `xml:"vnicDevice,omitempty" json:"vnicDevice,omitempty"`
	// Virtual NIC Object corresponding to the vnicDevice.
	//
	// May be unset if Virtual NIC object corresponding to vnicDevice doesn't
	// exist in the system.
	Vnic *HostVirtualNic `xml:"vnic,omitempty" json:"vnic,omitempty"`
	// Physical NIC Name.
	PnicDevice string `xml:"pnicDevice,omitempty" json:"pnicDevice,omitempty"`
	// Physical NIC Object corresponding to the pnicDevice.
	//
	// May be unset if Physical NIC object corresponding to pnicDevice doesn't
	// exist in the system or the vnicDevice doesn't have any Physical NIC
	// associated with it.
	Pnic *PhysicalNic `xml:"pnic,omitempty" json:"pnic,omitempty"`
	// Name of the virtual switch this Physical/Virtual NIC belongs.
	//
	// May be unset if the vnicDevice and/or pnicDevice do not have a
	// virtual switch associated with them.
	SwitchName string `xml:"switchName,omitempty" json:"switchName,omitempty"`
	// UUID of the virtual switch this Physical/Virtual NIC belongs.
	//
	// May be unset if the vnicDevice and/or pnicDevice do not have a
	// virtual switch associated with them or the associated switch is not VDS.
	SwitchUuid string `xml:"switchUuid,omitempty" json:"switchUuid,omitempty"`
	// Name of the portgroup to which this Virtual NIC belongs.
	//
	// May be unset if the vnicDevice and/or pnicDevice do not have a
	// Portgroup associated with them.
	PortgroupName string `xml:"portgroupName,omitempty" json:"portgroupName,omitempty"`
	// Portgroup key to which this Virtual NIC belongs.
	//
	// May be unset if the vnicDevice and/or pnicDevice do not have a
	// Portgroup associated with them or the associated portgroup does
	// is not of VDS type.
	PortgroupKey string `xml:"portgroupKey,omitempty" json:"portgroupKey,omitempty"`
	// portkey to which this Virtual NIC belongs.
	//
	// May be unset if the vnicDevice is not assigned to a specific port or
	// the switch is not VDS.
	PortKey string `xml:"portKey,omitempty" json:"portKey,omitempty"`
	// ID of the Opaque network to which the virtual NIC is connected.
	//
	// This property is set only when vnicDevice is associated with an
	// opaque network.
	OpaqueNetworkId string `xml:"opaqueNetworkId,omitempty" json:"opaqueNetworkId,omitempty"`
	// Type of the Opaque network to which the virtual NIC is connected.
	//
	// This property is set only when vnicDevice is associated with an
	// opaque network.
	OpaqueNetworkType string `xml:"opaqueNetworkType,omitempty" json:"opaqueNetworkType,omitempty"`
	// Name of the Opaque network to which the virtual NIC is connected.
	//
	// This property is set only when vnicDevice is associated with an
	// opaque network.
	OpaqueNetworkName string `xml:"opaqueNetworkName,omitempty" json:"opaqueNetworkName,omitempty"`
	// An ID assigned to the vmkernel adapter by external management plane
	// or controller.
	//
	// This property is set only when vnicDevice is associated with an
	// opaque network.
	ExternalId string `xml:"externalId,omitempty" json:"externalId,omitempty"`
	// Status indicating whether the Virtual NIC is compliant with the
	// network policy that is required by iSCSI port binding.
	//
	// May be unset in the candidate NIC list.
	ComplianceStatus *IscsiStatus `xml:"complianceStatus,omitempty" json:"complianceStatus,omitempty"`
	// A status, as defined in `IscsiPortInfoPathStatus_enum`, indicating the
	// existing storage paths dependency level on a given Virtual NIC.
	//
	// May be unset in the candidate NIC list.
	PathStatus string `xml:"pathStatus,omitempty" json:"pathStatus,omitempty"`
}

func init() {
	t["IscsiPortInfo"] = reflect.TypeOf((*IscsiPortInfo)(nil)).Elem()
}

// The `IscsiStatus` data object describes the
// status of an operation.
type IscsiStatus struct {
	DynamicData

	// List of failure reason and associated remedy.
	//
	// An array of fault codes associated with the failure. The fault itself
	// will provide an indication of the actual failure code and
	// `MethodFault.faultMessage` will indicate the remedy that
	// needs to be taken to correct the failure.
	Reason []LocalizedMethodFault `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["IscsiStatus"] = reflect.TypeOf((*IscsiStatus)(nil)).Elem()
}

// This data object type describes a file that is an ISO CD-ROM image.
type IsoImageFileInfo struct {
	FileInfo
}

func init() {
	t["IsoImageFileInfo"] = reflect.TypeOf((*IsoImageFileInfo)(nil)).Elem()
}

// This data object type describes the query specification for an ISO CD-ROM image.
type IsoImageFileQuery struct {
	FileQuery
}

func init() {
	t["IsoImageFileQuery"] = reflect.TypeOf((*IsoImageFileQuery)(nil)).Elem()
}

// The parameters of `HostActiveDirectoryAuthentication.JoinDomain_Task`.
type JoinDomainRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Name of the domain to be joined.
	DomainName string `xml:"domainName" json:"domainName"`
	// Name for an Active Directory account
	// that has the authority to add hosts to the domain.
	UserName string `xml:"userName" json:"userName"`
	// Password for the <code>userName</code> account.
	Password string `xml:"password" json:"password"`
}

func init() {
	t["JoinDomainRequestType"] = reflect.TypeOf((*JoinDomainRequestType)(nil)).Elem()
}

// The parameters of `HostActiveDirectoryAuthentication.JoinDomainWithCAM_Task`.
type JoinDomainWithCAMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Name of the domain to be joined.
	DomainName string `xml:"domainName" json:"domainName"`
	// Name of server providing the CAM service.
	CamServer string `xml:"camServer" json:"camServer"`
}

func init() {
	t["JoinDomainWithCAMRequestType"] = reflect.TypeOf((*JoinDomainWithCAMRequestType)(nil)).Elem()
}

type JoinDomainWithCAM_Task JoinDomainWithCAMRequestType

func init() {
	t["JoinDomainWithCAM_Task"] = reflect.TypeOf((*JoinDomainWithCAM_Task)(nil)).Elem()
}

type JoinDomainWithCAM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type JoinDomain_Task JoinDomainRequestType

func init() {
	t["JoinDomain_Task"] = reflect.TypeOf((*JoinDomain_Task)(nil)).Elem()
}

type JoinDomain_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Information about a kernel module.
type KernelModuleInfo struct {
	DynamicData

	// Module ID.
	Id int32 `xml:"id" json:"id"`
	// Module name.
	Name string `xml:"name" json:"name"`
	// Version string.
	Version string `xml:"version" json:"version"`
	// Module filename, without the path.
	Filename string `xml:"filename" json:"filename"`
	// Option string configured to be passed to the kernel module when loaded.
	//
	// Note that this is not necessarily the option string currently in use by
	// the kernel module.
	OptionString string `xml:"optionString" json:"optionString"`
	// Is the module loaded?
	Loaded bool `xml:"loaded" json:"loaded"`
	// Is the module enabled?
	Enabled bool `xml:"enabled" json:"enabled"`
	// Number of references to this module.
	UseCount int32 `xml:"useCount" json:"useCount"`
	// Read-only section information.
	ReadOnlySection KernelModuleSectionInfo `xml:"readOnlySection" json:"readOnlySection"`
	// Writable section information.
	WritableSection KernelModuleSectionInfo `xml:"writableSection" json:"writableSection"`
	// Text section information.
	TextSection KernelModuleSectionInfo `xml:"textSection" json:"textSection"`
	// Data section information.
	DataSection KernelModuleSectionInfo `xml:"dataSection" json:"dataSection"`
	// BSS section information.
	BssSection KernelModuleSectionInfo `xml:"bssSection" json:"bssSection"`
}

func init() {
	t["KernelModuleInfo"] = reflect.TypeOf((*KernelModuleInfo)(nil)).Elem()
}

// Information about a module section.
type KernelModuleSectionInfo struct {
	DynamicData

	// Base address of section.
	Address int64 `xml:"address" json:"address"`
	// Section length.
	Length int32 `xml:"length,omitempty" json:"length,omitempty"`
}

func init() {
	t["KernelModuleSectionInfo"] = reflect.TypeOf((*KernelModuleSectionInfo)(nil)).Elem()
}

// Non-localized key/value pair in which the
// the value can be of any type.
type KeyAnyValue struct {
	DynamicData

	// the key
	Key string `xml:"key" json:"key"`
	// the value
	Value AnyType `xml:"value,typeattr" json:"value"`
}

func init() {
	t["KeyAnyValue"] = reflect.TypeOf((*KeyAnyValue)(nil)).Elem()
}

// An KeyNotFound fault is returned when the key does not exist among
// key value pairs.
type KeyNotFound struct {
	VimFault

	// The non existing key.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["KeyNotFound"] = reflect.TypeOf((*KeyNotFound)(nil)).Elem()
}

type KeyNotFoundFault KeyNotFound

func init() {
	t["KeyNotFoundFault"] = reflect.TypeOf((*KeyNotFoundFault)(nil)).Elem()
}

// Data Object representing a crypto key provider's unique identifier.
type KeyProviderId struct {
	DynamicData

	// Globally unique ID for the crypto key provider.
	//
	// Servers with the same ID must provide the same keys.
	// Cannot be empty.
	Id string `xml:"id" json:"id"`
}

func init() {
	t["KeyProviderId"] = reflect.TypeOf((*KeyProviderId)(nil)).Elem()
}

// Non-localized key/value pair
type KeyValue struct {
	DynamicData

	// Key.
	Key string `xml:"key" json:"key"`
	// Value.
	Value string `xml:"value" json:"value"`
}

func init() {
	t["KeyValue"] = reflect.TypeOf((*KeyValue)(nil)).Elem()
}

// Data Object representing a cluster of KMIP servers.
//
// All servers in a cluster must provide the same keys.
type KmipClusterInfo struct {
	DynamicData

	// Globally unique ID for the servers providing the same keys.
	//
	// All KMIP servers with the same clusterId are in a cluster and all must
	// provide the same keys for redundancy.
	ClusterId KeyProviderId `xml:"clusterId" json:"clusterId"`
	// Servers in this cluster.
	Servers []KmipServerInfo `xml:"servers,omitempty" json:"servers,omitempty"`
	// Use this cluster as default for system wide,
	// when the optional CryptoKeyId.providerId is not set.
	UseAsDefault bool `xml:"useAsDefault" json:"useAsDefault"`
	// Key provider management type.
	//
	// See `KmipClusterInfoKmsManagementType_enum` for valid values.
	ManagementType string `xml:"managementType,omitempty" json:"managementType,omitempty"`
	// Use this cluster as default for the managed entities,
	// when the optional CryptoKeyId.providerId is not set.
	//
	// See `CryptoManagerKmip.SetDefaultKmsCluster` for
	// supported managed entity type.
	//
	// Refers instances of `ManagedEntity`.
	UseAsEntityDefault []ManagedObjectReference `xml:"useAsEntityDefault,omitempty" json:"useAsEntityDefault,omitempty"`
	HasBackup          *bool                    `xml:"hasBackup" json:"hasBackup,omitempty" vim:"7.0.2.0"`
	TpmRequired        *bool                    `xml:"tpmRequired" json:"tpmRequired,omitempty" vim:"7.0.2.0"`
	KeyId              string                   `xml:"keyId,omitempty" json:"keyId,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["KmipClusterInfo"] = reflect.TypeOf((*KmipClusterInfo)(nil)).Elem()
}

// Data Object representing a KMIP server connection information.
type KmipServerInfo struct {
	DynamicData

	// Name for the KMIP server.
	Name string `xml:"name" json:"name"`
	// Address of the KMIP server.
	Address string `xml:"address" json:"address"`
	// Port of the KMIP server.
	Port int32 `xml:"port" json:"port"`
	// Address of the proxy server.
	//
	// Set value to empty string to delete the entry.
	ProxyAddress string `xml:"proxyAddress,omitempty" json:"proxyAddress,omitempty"`
	// Port of the proxy server.
	//
	// Set value "-1" to delete the entry.
	ProxyPort int32 `xml:"proxyPort,omitempty" json:"proxyPort,omitempty"`
	// Should auto-reconnect be done.
	//
	// Set value "-1" to delete the entry.
	Reconnect int32 `xml:"reconnect,omitempty" json:"reconnect,omitempty"`
	// KMIP library protocol handler, e.g.
	//
	// KMIP1.
	// Set value to empty string to delete the entry.
	Protocol string `xml:"protocol,omitempty" json:"protocol,omitempty"`
	// Non-blocking I/O required.
	//
	// Set value "-1" to delete the entry.
	Nbio int32 `xml:"nbio,omitempty" json:"nbio,omitempty"`
	// I/O timeout in seconds (-1=none,0=infinite).
	//
	// Set value "-1" to delete the entry.
	Timeout int32 `xml:"timeout,omitempty" json:"timeout,omitempty"`
	// Username to authenticate to the KMIP server.
	//
	// Set value to empty string to delete the entry.
	UserName string `xml:"userName,omitempty" json:"userName,omitempty"`
}

func init() {
	t["KmipServerInfo"] = reflect.TypeOf((*KmipServerInfo)(nil)).Elem()
}

// Data Object representing a KMIP server connection spec.
type KmipServerSpec struct {
	DynamicData

	// The ID of the KMIP cluster.
	//
	// KMIP servers with the same clusterId are in
	// one cluster and provide the same keys for redundancy.
	ClusterId KeyProviderId `xml:"clusterId" json:"clusterId"`
	// Connection information for the KMIP server.
	Info KmipServerInfo `xml:"info" json:"info"`
	// Password to authenticate to the KMIP server.
	//
	// Set value to empty string to delete the entry.
	Password string `xml:"password,omitempty" json:"password,omitempty"`
}

func init() {
	t["KmipServerSpec"] = reflect.TypeOf((*KmipServerSpec)(nil)).Elem()
}

// Data Object representing a KMIP server status.
type KmipServerStatus struct {
	DynamicData

	// The ID of the KMIP cluster.
	ClusterId KeyProviderId `xml:"clusterId" json:"clusterId"`
	// Name for the KMIP server.
	Name string `xml:"name" json:"name"`
	// KMIP server status.
	Status ManagedEntityStatus `xml:"status" json:"status"`
	// KMIP server status description.
	Description string `xml:"description" json:"description"`
}

func init() {
	t["KmipServerStatus"] = reflect.TypeOf((*KmipServerStatus)(nil)).Elem()
}

// The virtual machine is using a 2TB+ RDM device and operation is
// unable to convert the disk to a different type.
type LargeRDMConversionNotSupported struct {
	MigrationFault

	// The name of the disk device using the RDM.
	Device string `xml:"device" json:"device"`
}

func init() {
	t["LargeRDMConversionNotSupported"] = reflect.TypeOf((*LargeRDMConversionNotSupported)(nil)).Elem()
}

type LargeRDMConversionNotSupportedFault LargeRDMConversionNotSupported

func init() {
	t["LargeRDMConversionNotSupportedFault"] = reflect.TypeOf((*LargeRDMConversionNotSupportedFault)(nil)).Elem()
}

// The virtual machine is configured with a 2TB+ Raw Disk Mapping.
//
// This is not
// supported on the datastore.
type LargeRDMNotSupportedOnDatastore struct {
	VmConfigFault

	// The label of the 2TB+ RDM device that would have its backing placed on
	// the datastore.
	//
	// This is not guaranteed to be the only such device.
	Device string `xml:"device" json:"device"`
	// The datastore.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The name of the datastore.
	DatastoreName string `xml:"datastoreName" json:"datastoreName"`
}

func init() {
	t["LargeRDMNotSupportedOnDatastore"] = reflect.TypeOf((*LargeRDMNotSupportedOnDatastore)(nil)).Elem()
}

type LargeRDMNotSupportedOnDatastoreFault LargeRDMNotSupportedOnDatastore

func init() {
	t["LargeRDMNotSupportedOnDatastoreFault"] = reflect.TypeOf((*LargeRDMNotSupportedOnDatastoreFault)(nil)).Elem()
}

// Specification of the latency-sensitivity information.
//
// The latency-sensitivity is used to request from the kernel a constraint
// on the scheduling delay of the virtual CPUs or other resources. This allows
// latency-sensitive applications(e.g. VOIP, audio/video streaming, etc.) to run
// in a virtual machine which is configured to use specific scheduling
// latencies and to be scheduled with low latency.
//
// The kernel does not provide any guarantee that it will meet the
// latency-sensitivity requirement of a virtual machine CPU or other resources
// but it will always accept the latency-sensitivity value provided.
type LatencySensitivity struct {
	DynamicData

	// The nominal latency-sensitive level of the application.
	Level LatencySensitivitySensitivityLevel `xml:"level" json:"level"`
	// Deprecated as of vSphere version 5.5, this field is deprecated.
	//
	// The custom absolute latency-sensitivity value of the application.
	//
	// This value will be used only when the latency-sensitivity
	// `LatencySensitivity.level` property is is set to
	// <code>custom</code>. It is ignored in all other cases.
	//
	// The unit of this value is micro-seconds and the application is more
	// latency sensitive when this value is smaller. For example, if the
	// absolute latency-sensitivity is 2000us, the kernel will
	// try to schedule the virtual machine in a way so that its scheduling
	// latency is not more than 2ms.
	Sensitivity int32 `xml:"sensitivity,omitempty" json:"sensitivity,omitempty"`
}

func init() {
	t["LatencySensitivity"] = reflect.TypeOf((*LatencySensitivity)(nil)).Elem()
}

// The parameters of `HostActiveDirectoryAuthentication.LeaveCurrentDomain_Task`.
type LeaveCurrentDomainRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If <code>True</code>, any existing permissions on managed entities for
	// Active Directory users will be deleted. If <code>False</code> and such
	// permissions exist, the operation will fail.
	Force bool `xml:"force" json:"force"`
}

func init() {
	t["LeaveCurrentDomainRequestType"] = reflect.TypeOf((*LeaveCurrentDomainRequestType)(nil)).Elem()
}

type LeaveCurrentDomain_Task LeaveCurrentDomainRequestType

func init() {
	t["LeaveCurrentDomain_Task"] = reflect.TypeOf((*LeaveCurrentDomain_Task)(nil)).Elem()
}

type LeaveCurrentDomain_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// A virtual machine's network connectivity cannot be determined
// because it uses a legacy network interface.
//
// If returned as part of migration checks,
// this is an error if the virtual machine is currently connected to the legacy
// interface, and a warning otherwise.
type LegacyNetworkInterfaceInUse struct {
	CannotAccessNetwork
}

func init() {
	t["LegacyNetworkInterfaceInUse"] = reflect.TypeOf((*LegacyNetworkInterfaceInUse)(nil)).Elem()
}

type LegacyNetworkInterfaceInUseFault LegacyNetworkInterfaceInUse

func init() {
	t["LegacyNetworkInterfaceInUseFault"] = reflect.TypeOf((*LegacyNetworkInterfaceInUseFault)(nil)).Elem()
}

// A LicenseAssignmentFailed fault is thrown when VirtualCenter
// fails to assign a license to an entity.
type LicenseAssignmentFailed struct {
	RuntimeFault

	// The reason why the assignment failed, if known.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["LicenseAssignmentFailed"] = reflect.TypeOf((*LicenseAssignmentFailed)(nil)).Elem()
}

type LicenseAssignmentFailedFault LicenseAssignmentFailed

func init() {
	t["LicenseAssignmentFailedFault"] = reflect.TypeOf((*LicenseAssignmentFailedFault)(nil)).Elem()
}

type LicenseAssignmentManagerLicenseAssignment struct {
	DynamicData

	// Id for the entity
	EntityId string `xml:"entityId" json:"entityId"`
	// Scope of the entityId
	Scope string `xml:"scope,omitempty" json:"scope,omitempty"`
	// Display name of the entity
	EntityDisplayName string `xml:"entityDisplayName,omitempty" json:"entityDisplayName,omitempty"`
	// License assigned to the entity
	AssignedLicense LicenseManagerLicenseInfo `xml:"assignedLicense" json:"assignedLicense"`
	// Additional properties associated with this assignment
	// Some of the properties are:
	// "inUseFeatures" -- Features in the license key that are being used by the entity
	// "ProductName" -- Name of the entity.
	//
	// Should match the product name of the assigned license.
	// "ProductVersion" -- Version of the entity. Should match the product version of the assigned license.
	// "Evaluation" -- EvaluationInfo object representing the evaluation left for the entity.
	Properties []KeyAnyValue `xml:"properties,omitempty" json:"properties,omitempty"`
}

func init() {
	t["LicenseAssignmentManagerLicenseAssignment"] = reflect.TypeOf((*LicenseAssignmentManagerLicenseAssignment)(nil)).Elem()
}

// Deprecated as of vSphere API 4.0, this is not used by the system.
//
// Describes how many licenses of a particular feature is provided by the licensing
// source.
type LicenseAvailabilityInfo struct {
	DynamicData

	// Describes the feature.
	Feature LicenseFeatureInfo `xml:"feature" json:"feature"`
	// Total number of licenses for this given type that are installed on the source.
	Total int32 `xml:"total" json:"total"`
	// The number of licenses that have not yet been reserved on the source.
	Available int32 `xml:"available" json:"available"`
}

func init() {
	t["LicenseAvailabilityInfo"] = reflect.TypeOf((*LicenseAvailabilityInfo)(nil)).Elem()
}

// Deprecated as of vSphere API 4.0, this is not used by the system.
//
// This data object type provides summary status and diagnostic information for
// `LicenseManager`.
//
// Counters in this property can be reset to zero. The
// property specified as a discontinuity is used to determine when this last
// occurred.
type LicenseDiagnostics struct {
	DynamicData

	// A timestamp of when sourceAvailable last changed state, expressed in UTC.
	SourceLastChanged time.Time `xml:"sourceLastChanged" json:"sourceLastChanged"`
	// Counter to track number of times connection to source was lost.
	//
	// This value starts at zero and wraps at 2^32-1 to zero.
	// Discontinuity: sourceLastChanged.
	SourceLost string `xml:"sourceLost" json:"sourceLost"`
	// Exponentially decaying average of the transaction time for license
	// acquisition and routine communications with LicenseSource.
	//
	// Units: milliseconds.
	SourceLatency float32 `xml:"sourceLatency" json:"sourceLatency"`
	// Counter to track total number of licenses requested.
	//
	// This value starts at zero and wraps at 2^32-1 to zero.
	// Discontinuity: sourceLastChanged.
	LicenseRequests string `xml:"licenseRequests" json:"licenseRequests"`
	// Counter to track Total number of licenses requests that were
	// not fulfilled (denied, timeout, or other).
	//
	// This value starts at zero and wraps at 2^32-1 to zero.
	// Discontinuity: sourceLastChanged.
	LicenseRequestFailures string `xml:"licenseRequestFailures" json:"licenseRequestFailures"`
	// Counter to track Total number of license features parsed from
	// License source that are not recognized.
	//
	// This value starts at zero and wraps at 2^32-1 to zero.
	// Discontinuity: sourceLastChanged.
	LicenseFeatureUnknowns string `xml:"licenseFeatureUnknowns" json:"licenseFeatureUnknowns"`
	// The general state of the license subsystem.
	OpState LicenseManagerState `xml:"opState" json:"opState"`
	// A timestamp of when opState was last updated.
	LastStatusUpdate time.Time `xml:"lastStatusUpdate" json:"lastStatusUpdate"`
	// A human readable reason when optState reports Fault condition.
	OpFailureMessage string `xml:"opFailureMessage" json:"opFailureMessage"`
}

func init() {
	t["LicenseDiagnostics"] = reflect.TypeOf((*LicenseDiagnostics)(nil)).Elem()
}

// A LicenseDowngradeDisallowed fault is thrown if an assignment operation tries to downgrade a license that does have certain licensed features which are in use.
type LicenseDowngradeDisallowed struct {
	NotEnoughLicenses

	Edition  string `xml:"edition" json:"edition"`
	EntityId string `xml:"entityId" json:"entityId"`
	// List of conflicting features that prevent
	// downgrade
	Features []KeyAnyValue `xml:"features" json:"features"`
}

func init() {
	t["LicenseDowngradeDisallowed"] = reflect.TypeOf((*LicenseDowngradeDisallowed)(nil)).Elem()
}

type LicenseDowngradeDisallowedFault LicenseDowngradeDisallowed

func init() {
	t["LicenseDowngradeDisallowedFault"] = reflect.TypeOf((*LicenseDowngradeDisallowedFault)(nil)).Elem()
}

// An LicenseEntityNotFound fault is thrown when an attempt is
// do any operation on an entity/licensed asset that does not exist.
//
// Example, remove an entity that does not exist.
type LicenseEntityNotFound struct {
	VimFault

	EntityId string `xml:"entityId" json:"entityId"`
}

func init() {
	t["LicenseEntityNotFound"] = reflect.TypeOf((*LicenseEntityNotFound)(nil)).Elem()
}

type LicenseEntityNotFoundFault LicenseEntityNotFound

func init() {
	t["LicenseEntityNotFoundFault"] = reflect.TypeOf((*LicenseEntityNotFoundFault)(nil)).Elem()
}

// This is a base licensing event to group all license events.
type LicenseEvent struct {
	Event
}

func init() {
	t["LicenseEvent"] = reflect.TypeOf((*LicenseEvent)(nil)).Elem()
}

// A LicenseExpired fault is thrown if it an operation is unsuccessful because the license used for the operation has expired.
type LicenseExpired struct {
	NotEnoughLicenses

	// License key that has expired
	LicenseKey string `xml:"licenseKey" json:"licenseKey"`
}

func init() {
	t["LicenseExpired"] = reflect.TypeOf((*LicenseExpired)(nil)).Elem()
}

// This event records the expiration of a license.
type LicenseExpiredEvent struct {
	Event

	Feature LicenseFeatureInfo `xml:"feature" json:"feature"`
}

func init() {
	t["LicenseExpiredEvent"] = reflect.TypeOf((*LicenseExpiredEvent)(nil)).Elem()
}

type LicenseExpiredFault LicenseExpired

func init() {
	t["LicenseExpiredFault"] = reflect.TypeOf((*LicenseExpiredFault)(nil)).Elem()
}

// Deprecated as of vSphere API 4.0, this is not used by the system.
//
// A single feature that can be licensed.
//
// This information is immutable.
type LicenseFeatureInfo struct {
	DynamicData

	// Unique identifier for license as defined in License source data.
	//
	// Max length of this string is 64 characters of ASCII/ISO Latin-1
	// character set.
	Key string `xml:"key" json:"key"`
	// The display string for the feature name.
	FeatureName string `xml:"featureName" json:"featureName"`
	// A human readable description of what function this feature enables.
	FeatureDescription string `xml:"featureDescription,omitempty" json:"featureDescription,omitempty"`
	// Describes the state of the feature based on the current edition license.
	//
	// This
	// property is unset for an edition license.
	State LicenseFeatureInfoState `xml:"state,omitempty" json:"state,omitempty"`
	// Each license has a cost associated with it and the value of costUnit
	// specifies the applicable unit.
	//
	// See also `LicenseFeatureInfoUnit_enum`.
	CostUnit string `xml:"costUnit" json:"costUnit"`
	// Describe any restriction on the source of a license for this feature.
	//
	// See also `LicenseFeatureInfoSourceRestriction_enum`.
	SourceRestriction string `xml:"sourceRestriction,omitempty" json:"sourceRestriction,omitempty"`
	// Report List of feature keys used by this edition.
	DependentKey []string `xml:"dependentKey,omitempty" json:"dependentKey,omitempty"`
	// Flag to indicate whether the feature is an edition.
	Edition *bool `xml:"edition" json:"edition,omitempty"`
	// Date representing the expiration date
	ExpiresOn *time.Time `xml:"expiresOn" json:"expiresOn,omitempty"`
}

func init() {
	t["LicenseFeatureInfo"] = reflect.TypeOf((*LicenseFeatureInfo)(nil)).Elem()
}

// A LicenseKeyEntityMismatch fault is thrown if an assignment operation tries to assign a license that does not apply to an entity.
//
// For example assigning a host license to VirtualCenter.
type LicenseKeyEntityMismatch struct {
	NotEnoughLicenses
}

func init() {
	t["LicenseKeyEntityMismatch"] = reflect.TypeOf((*LicenseKeyEntityMismatch)(nil)).Elem()
}

type LicenseKeyEntityMismatchFault LicenseKeyEntityMismatch

func init() {
	t["LicenseKeyEntityMismatchFault"] = reflect.TypeOf((*LicenseKeyEntityMismatchFault)(nil)).Elem()
}

// Encapsulates product evaluation information
type LicenseManagerEvaluationInfo struct {
	DynamicData

	// Evaluation properties
	Properties []KeyAnyValue `xml:"properties" json:"properties"`
}

func init() {
	t["LicenseManagerEvaluationInfo"] = reflect.TypeOf((*LicenseManagerEvaluationInfo)(nil)).Elem()
}

// Encapsulates information about a license
type LicenseManagerLicenseInfo struct {
	DynamicData

	// Key for the license.
	//
	// E.g. serial number.
	LicenseKey string `xml:"licenseKey" json:"licenseKey"`
	// Edition key.
	EditionKey string `xml:"editionKey" json:"editionKey"`
	// Display name for the license
	Name string `xml:"name" json:"name"`
	// Total number of units contain in the license
	Total int32 `xml:"total" json:"total"`
	// Number of units used from this license
	Used int32 `xml:"used,omitempty" json:"used,omitempty"`
	// The cost unit for this license
	CostUnit string `xml:"costUnit" json:"costUnit"`
	// Additional properties associated with this license
	Properties []KeyAnyValue `xml:"properties,omitempty" json:"properties,omitempty"`
	// Key-value lables for this license
	Labels []KeyValue `xml:"labels,omitempty" json:"labels,omitempty"`
}

func init() {
	t["LicenseManagerLicenseInfo"] = reflect.TypeOf((*LicenseManagerLicenseInfo)(nil)).Elem()
}

// This event records that the inventory is not license compliant.
type LicenseNonComplianceEvent struct {
	LicenseEvent

	// Gives the url at which more details about non-compliance
	// can be found.
	Url string `xml:"url" json:"url"`
}

func init() {
	t["LicenseNonComplianceEvent"] = reflect.TypeOf((*LicenseNonComplianceEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 4.0, this is not used by the system.
//
// A reservation describes how many licenses of a particular feature are being used
// by a particular feature.
type LicenseReservationInfo struct {
	DynamicData

	// Key of the License Feature.
	//
	// See also `LicenseFeatureInfo.key`.
	Key string `xml:"key" json:"key"`
	// Describes the reservation state of a license.
	State LicenseReservationInfoState `xml:"state" json:"state"`
	// Contains the required number of licenses of the particular type that the
	// product needs in its current configuration.
	//
	// Licenses are normally allocated at the same time as they are needed, so the
	// value of required is set at the time the license is needed. For example,
	// in the case of the number of licenses based on virtual machines, the required
	// count is set at the time a virtual machine is powered on, just before the
	// license is checked out.
	Required int32 `xml:"required" json:"required"`
}

func init() {
	t["LicenseReservationInfo"] = reflect.TypeOf((*LicenseReservationInfo)(nil)).Elem()
}

// This fault is thrown if the required licenses were unable to be checked
// out due to a restriction in the option file of the license server.
type LicenseRestricted struct {
	NotEnoughLicenses
}

func init() {
	t["LicenseRestricted"] = reflect.TypeOf((*LicenseRestricted)(nil)).Elem()
}

// This event records if the required licenses could not be reserved because
// of a restriction in the option file.
type LicenseRestrictedEvent struct {
	LicenseEvent
}

func init() {
	t["LicenseRestrictedEvent"] = reflect.TypeOf((*LicenseRestrictedEvent)(nil)).Elem()
}

type LicenseRestrictedFault LicenseRestricted

func init() {
	t["LicenseRestrictedFault"] = reflect.TypeOf((*LicenseRestrictedFault)(nil)).Elem()
}

// This event is reported if the LicenseServer was previously unreachable
// and is now reachable.
type LicenseServerAvailableEvent struct {
	LicenseEvent

	LicenseServer string `xml:"licenseServer" json:"licenseServer"`
}

func init() {
	t["LicenseServerAvailableEvent"] = reflect.TypeOf((*LicenseServerAvailableEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 4.0, this is not used by the system.
//
// Specify a license server reachable via IPv4 network.
type LicenseServerSource struct {
	LicenseSource

	// This property defines the server to establish a TCP session to
	// obtain license data.
	//
	// Format of string is host:port
	// Port is optional unsigned 16 bit integer license
	// server is listening on. A trailing colon ':' without a port number
	// is a valid expression.
	// Host can either be an IPv4 address in dotted quad
	// format or a resolvable DNS name &leq;254 characters. See RFC 3696.
	LicenseServer string `xml:"licenseServer" json:"licenseServer"`
}

func init() {
	t["LicenseServerSource"] = reflect.TypeOf((*LicenseServerSource)(nil)).Elem()
}

// This fault is thrown when the License Server
// is unavailable during an attempt to change license state.
type LicenseServerUnavailable struct {
	VimFault

	// The name of the unavailable license server.
	LicenseServer string `xml:"licenseServer" json:"licenseServer"`
}

func init() {
	t["LicenseServerUnavailable"] = reflect.TypeOf((*LicenseServerUnavailable)(nil)).Elem()
}

// This event is reported if the LicenseServer becomes unreachable.
type LicenseServerUnavailableEvent struct {
	LicenseEvent

	LicenseServer string `xml:"licenseServer" json:"licenseServer"`
}

func init() {
	t["LicenseServerUnavailableEvent"] = reflect.TypeOf((*LicenseServerUnavailableEvent)(nil)).Elem()
}

type LicenseServerUnavailableFault LicenseServerUnavailable

func init() {
	t["LicenseServerUnavailableFault"] = reflect.TypeOf((*LicenseServerUnavailableFault)(nil)).Elem()
}

// Deprecated as of vSphere API 4.0, this is not used by the system.
//
// This data object type is used to communicate configuration about
// where to find licenses to use for this system.
type LicenseSource struct {
	DynamicData
}

func init() {
	t["LicenseSource"] = reflect.TypeOf((*LicenseSource)(nil)).Elem()
}

// A LicenseSourceUnavailable is thrown if it is unable to check out a license because
// the license source is unavailable.
type LicenseSourceUnavailable struct {
	NotEnoughLicenses

	// License source
	LicenseSource BaseLicenseSource `xml:"licenseSource,typeattr" json:"licenseSource"`
}

func init() {
	t["LicenseSourceUnavailable"] = reflect.TypeOf((*LicenseSourceUnavailable)(nil)).Elem()
}

type LicenseSourceUnavailableFault LicenseSourceUnavailable

func init() {
	t["LicenseSourceUnavailableFault"] = reflect.TypeOf((*LicenseSourceUnavailableFault)(nil)).Elem()
}

// Deprecated as of vSphere API 4.0, this is not used by the system.
//
// Contains source information, licensed features, and usage.
type LicenseUsageInfo struct {
	DynamicData

	// The source from which licensing data is acquired.
	//
	// See also `LicenseSource`.
	Source BaseLicenseSource `xml:"source,typeattr" json:"source"`
	// Returns whether or not the source is currently available.
	//
	// See also `LicenseManager.sourceAvailable`.
	SourceAvailable bool `xml:"sourceAvailable" json:"sourceAvailable"`
	// A list of feature reservations.
	ReservationInfo []LicenseReservationInfo `xml:"reservationInfo,omitempty" json:"reservationInfo,omitempty"`
	// Includes all the features that are referenced in the reservation array.
	FeatureInfo []LicenseFeatureInfo `xml:"featureInfo,omitempty" json:"featureInfo,omitempty"`
}

func init() {
	t["LicenseUsageInfo"] = reflect.TypeOf((*LicenseUsageInfo)(nil)).Elem()
}

// This exception is thrown if one of the arguments passed to the function exceeds
// a limit.
type LimitExceeded struct {
	VimFault

	// The name of the property that exceeds the limit.
	Property string `xml:"property,omitempty" json:"property,omitempty"`
	// The limit value.
	Limit *int32 `xml:"limit" json:"limit,omitempty"`
}

func init() {
	t["LimitExceeded"] = reflect.TypeOf((*LimitExceeded)(nil)).Elem()
}

type LimitExceededFault LimitExceeded

func init() {
	t["LimitExceededFault"] = reflect.TypeOf((*LimitExceededFault)(nil)).Elem()
}

// Dataobject representing the link discovery protocol configuration for a
// virtual or distributed virtual switch.
type LinkDiscoveryProtocolConfig struct {
	DynamicData

	// The discovery protocol type.
	//
	// For valid values
	// see `LinkDiscoveryProtocolConfigProtocolType_enum`.
	Protocol string `xml:"protocol" json:"protocol"`
	// Whether to advertise or listen.
	//
	// For valid values see
	// `LinkDiscoveryProtocolConfigOperationType_enum`.
	Operation string `xml:"operation" json:"operation"`
}

func init() {
	t["LinkDiscoveryProtocolConfig"] = reflect.TypeOf((*LinkDiscoveryProtocolConfig)(nil)).Elem()
}

// The Link Layer Discovery Protocol information.
type LinkLayerDiscoveryProtocolInfo struct {
	DynamicData

	// ChassisId represents the chassis identification for the device that
	// transmitted the LLDP frame.
	//
	// The receiving LLDP agent combines the
	// Chassis ID and portId to represent the entity connected to the port
	// where the frame was received.
	ChassisId string `xml:"chassisId" json:"chassisId"`
	// This property identifies the specific port that transmitted the LLDP
	// frame.
	//
	// The receiving LLDP agent combines the Chassis ID and Port to
	// represent the entity connected to the port where the frame was received.
	PortId string `xml:"portId" json:"portId"`
	// It is the duration of time in seconds for which information contained
	// in the received LLDP frame shall be valid.
	//
	// If a value of zero is sent
	// it can also identify a device that has shut down or is no longer
	// transmitting, prompting deletion of the record from the local database.
	TimeToLive int32 `xml:"timeToLive" json:"timeToLive"`
	// LLDP parameters
	Parameter []KeyAnyValue `xml:"parameter,omitempty" json:"parameter,omitempty"`
}

func init() {
	t["LinkLayerDiscoveryProtocolInfo"] = reflect.TypeOf((*LinkLayerDiscoveryProtocolInfo)(nil)).Elem()
}

// The LinkProfile data object represents a subprofile
// for links connected to virtual switch.
type LinkProfile struct {
	ApplyProfile
}

func init() {
	t["LinkProfile"] = reflect.TypeOf((*LinkProfile)(nil)).Elem()
}

// Customization operation is performed on a linux source vm that
// was not shut down properly.
//
// If the filesystem has significant
// fsck errors on it, customization process cannot make changes
// to it.
type LinuxVolumeNotClean struct {
	CustomizationFault
}

func init() {
	t["LinuxVolumeNotClean"] = reflect.TypeOf((*LinuxVolumeNotClean)(nil)).Elem()
}

type LinuxVolumeNotCleanFault LinuxVolumeNotClean

func init() {
	t["LinuxVolumeNotCleanFault"] = reflect.TypeOf((*LinuxVolumeNotCleanFault)(nil)).Elem()
}

type ListCACertificateRevocationLists ListCACertificateRevocationListsRequestType

func init() {
	t["ListCACertificateRevocationLists"] = reflect.TypeOf((*ListCACertificateRevocationLists)(nil)).Elem()
}

type ListCACertificateRevocationListsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ListCACertificateRevocationListsRequestType"] = reflect.TypeOf((*ListCACertificateRevocationListsRequestType)(nil)).Elem()
}

type ListCACertificateRevocationListsResponse struct {
	Returnval []string `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ListCACertificates ListCACertificatesRequestType

func init() {
	t["ListCACertificates"] = reflect.TypeOf((*ListCACertificates)(nil)).Elem()
}

type ListCACertificatesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ListCACertificatesRequestType"] = reflect.TypeOf((*ListCACertificatesRequestType)(nil)).Elem()
}

type ListCACertificatesResponse struct {
	Returnval []string `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ListFilesInGuest ListFilesInGuestRequestType

func init() {
	t["ListFilesInGuest"] = reflect.TypeOf((*ListFilesInGuest)(nil)).Elem()
}

// The parameters of `GuestFileManager.ListFilesInGuest`.
type ListFilesInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual Machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Query
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The complete path to the directory or file to query.
	FilePath string `xml:"filePath" json:"filePath"`
	// Which result to start the list with. The default is 0.
	Index int32 `xml:"index,omitempty" json:"index,omitempty"`
	// The maximum number of results to return. The default
	// is 50.
	MaxResults int32 `xml:"maxResults,omitempty" json:"maxResults,omitempty"`
	// A filter for the return values.
	// Match patterns are specified using perl-compatible regular
	// expressions.
	// If matchPattern is unset, then the pattern '.\*' is used.
	MatchPattern string `xml:"matchPattern,omitempty" json:"matchPattern,omitempty"`
}

func init() {
	t["ListFilesInGuestRequestType"] = reflect.TypeOf((*ListFilesInGuestRequestType)(nil)).Elem()
}

type ListFilesInGuestResponse struct {
	Returnval GuestListFileInfo `xml:"returnval" json:"returnval"`
}

type ListGuestAliases ListGuestAliasesRequestType

func init() {
	t["ListGuestAliases"] = reflect.TypeOf((*ListGuestAliases)(nil)).Elem()
}

// The parameters of `GuestAliasManager.ListGuestAliases`.
type ListGuestAliasesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.QueryAliases
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data for this operation. See
	// `GuestAuthentication`. These credentials must satisfy
	// authentication requirements
	// for a guest account on the specified virtual machine.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The guest user whose Alias store is being queried.
	Username string `xml:"username" json:"username"`
}

func init() {
	t["ListGuestAliasesRequestType"] = reflect.TypeOf((*ListGuestAliasesRequestType)(nil)).Elem()
}

type ListGuestAliasesResponse struct {
	Returnval []GuestAliases `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ListGuestMappedAliases ListGuestMappedAliasesRequestType

func init() {
	t["ListGuestMappedAliases"] = reflect.TypeOf((*ListGuestMappedAliases)(nil)).Elem()
}

// The parameters of `GuestAliasManager.ListGuestMappedAliases`.
type ListGuestMappedAliasesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.QueryAliases
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data for this operation. See
	// `GuestAuthentication`. These credentials must satisfy
	// authentication requirements
	// for a guest account on the specified virtual machine.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
}

func init() {
	t["ListGuestMappedAliasesRequestType"] = reflect.TypeOf((*ListGuestMappedAliasesRequestType)(nil)).Elem()
}

type ListGuestMappedAliasesResponse struct {
	Returnval []GuestMappedAliases `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ListKeys ListKeysRequestType

func init() {
	t["ListKeys"] = reflect.TypeOf((*ListKeys)(nil)).Elem()
}

// The parameters of `CryptoManager.ListKeys`.
type ListKeysRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] maximum keys to return.
	Limit *int32 `xml:"limit" json:"limit,omitempty"`
}

func init() {
	t["ListKeysRequestType"] = reflect.TypeOf((*ListKeysRequestType)(nil)).Elem()
}

type ListKeysResponse struct {
	Returnval []CryptoKeyId `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ListKmipServers ListKmipServersRequestType

func init() {
	t["ListKmipServers"] = reflect.TypeOf((*ListKmipServers)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.ListKmipServers`.
type ListKmipServersRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] maximum clusters to return.
	Limit *int32 `xml:"limit" json:"limit,omitempty"`
}

func init() {
	t["ListKmipServersRequestType"] = reflect.TypeOf((*ListKmipServersRequestType)(nil)).Elem()
}

type ListKmipServersResponse struct {
	Returnval []KmipClusterInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ListKmsClusters ListKmsClustersRequestType

func init() {
	t["ListKmsClusters"] = reflect.TypeOf((*ListKmsClusters)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.ListKmsClusters`.
type ListKmsClustersRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] Whether to list KMS servers information
	// in the cluster.
	// By default will not include the KMS servers
	// information.
	IncludeKmsServers *bool `xml:"includeKmsServers" json:"includeKmsServers,omitempty"`
	// \[in\] The KMS cluster management type filter.
	// Bit map values:
	// 0x01 - Return VC managed Key Providers
	// registered in the CryptoManager.
	// 0x02 - Return Trusted Key Providers
	// registered in the CryptoManager.
	// 0x04 - Return Trusted Key Providers which are
	// not registered with the CryptoManager.
	// 0x08 - Return Native Key Providers.
	// others - reserved, will be ignored
	// If omitted or -1, then all kinds of Key Providers
	// will be returned.
	ManagementTypeFilter int32 `xml:"managementTypeFilter,omitempty" json:"managementTypeFilter,omitempty"`
	// \[in\] The Key Provider status filter.
	// Bit map values:
	// 0x01 - Return active Key Providers.
	// 0x02 - Return inactive Key Providers.
	// others - reserved, will be ignored
	// If omitted or -1, then all status of Key Providers
	// will be returned.
	StatusFilter int32 `xml:"statusFilter,omitempty" json:"statusFilter,omitempty"`
}

func init() {
	t["ListKmsClustersRequestType"] = reflect.TypeOf((*ListKmsClustersRequestType)(nil)).Elem()
}

type ListKmsClustersResponse struct {
	Returnval []KmipClusterInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ListProcessesInGuest ListProcessesInGuestRequestType

func init() {
	t["ListProcessesInGuest"] = reflect.TypeOf((*ListProcessesInGuest)(nil)).Elem()
}

// The parameters of `GuestProcessManager.ListProcessesInGuest`.
type ListProcessesInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Query
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// If set, only return information about the specified processes.
	// Otherwise, information about all processes are returned.
	// If a specified processes does not exist, nothing will
	// be returned for that process.
	Pids []int64 `xml:"pids,omitempty" json:"pids,omitempty"`
}

func init() {
	t["ListProcessesInGuestRequestType"] = reflect.TypeOf((*ListProcessesInGuestRequestType)(nil)).Elem()
}

type ListProcessesInGuestResponse struct {
	Returnval []GuestProcessInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ListRegistryKeysInGuest ListRegistryKeysInGuestRequestType

func init() {
	t["ListRegistryKeysInGuest"] = reflect.TypeOf((*ListRegistryKeysInGuest)(nil)).Elem()
}

// The parameters of `GuestWindowsRegistryManager.ListRegistryKeysInGuest`.
type ListRegistryKeysInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Query
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The path to the registry key for which all subkeys are to
	// be listed.
	KeyName GuestRegKeyNameSpec `xml:"keyName" json:"keyName"`
	// If true, all subkeys are listed recursively.
	Recursive bool `xml:"recursive" json:"recursive"`
	// A filter for the key names returned, specified using
	// perl-compatible regular expressions. If matchPattern
	// is unset, then the pattern '.\*' is used, which returns
	// all key names found, otherwise only those key names
	// that match the input pattern shall be returned.
	MatchPattern string `xml:"matchPattern,omitempty" json:"matchPattern,omitempty"`
}

func init() {
	t["ListRegistryKeysInGuestRequestType"] = reflect.TypeOf((*ListRegistryKeysInGuestRequestType)(nil)).Elem()
}

type ListRegistryKeysInGuestResponse struct {
	Returnval []GuestRegKeyRecordSpec `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ListRegistryValuesInGuest ListRegistryValuesInGuestRequestType

func init() {
	t["ListRegistryValuesInGuest"] = reflect.TypeOf((*ListRegistryValuesInGuest)(nil)).Elem()
}

// The parameters of `GuestWindowsRegistryManager.ListRegistryValuesInGuest`.
type ListRegistryValuesInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Query
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The path to the registry key for which all values are to be
	// listed.
	KeyName GuestRegKeyNameSpec `xml:"keyName" json:"keyName"`
	// If true, all values that have expandable data such
	// as environment variable names, shall get expanded in
	// the result.
	ExpandStrings bool `xml:"expandStrings" json:"expandStrings"`
	// A filter for the value names returned, specified using
	// perl-compatible regular expressions. If matchPattern
	// is unset, then the pattern '.\*' is used, which returns
	// all value names found, otherwise only those value
	// names that match the input pattern shall be returned.
	MatchPattern string `xml:"matchPattern,omitempty" json:"matchPattern,omitempty"`
}

func init() {
	t["ListRegistryValuesInGuestRequestType"] = reflect.TypeOf((*ListRegistryValuesInGuestRequestType)(nil)).Elem()
}

type ListRegistryValuesInGuestResponse struct {
	Returnval []GuestRegValueSpec `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ListSmartCardTrustAnchors ListSmartCardTrustAnchorsRequestType

func init() {
	t["ListSmartCardTrustAnchors"] = reflect.TypeOf((*ListSmartCardTrustAnchors)(nil)).Elem()
}

type ListSmartCardTrustAnchorsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ListSmartCardTrustAnchorsRequestType"] = reflect.TypeOf((*ListSmartCardTrustAnchorsRequestType)(nil)).Elem()
}

type ListSmartCardTrustAnchorsResponse struct {
	Returnval []string `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ListTagsAttachedToVStorageObject ListTagsAttachedToVStorageObjectRequestType

func init() {
	t["ListTagsAttachedToVStorageObject"] = reflect.TypeOf((*ListTagsAttachedToVStorageObject)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.ListTagsAttachedToVStorageObject`.
type ListTagsAttachedToVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
}

func init() {
	t["ListTagsAttachedToVStorageObjectRequestType"] = reflect.TypeOf((*ListTagsAttachedToVStorageObjectRequestType)(nil)).Elem()
}

type ListTagsAttachedToVStorageObjectResponse struct {
	Returnval []VslmTagEntry `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ListVStorageObject ListVStorageObjectRequestType

func init() {
	t["ListVStorageObject"] = reflect.TypeOf((*ListVStorageObject)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.ListVStorageObject`.
type ListVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datastore to query for the virtual storage objects.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["ListVStorageObjectRequestType"] = reflect.TypeOf((*ListVStorageObjectRequestType)(nil)).Elem()
}

type ListVStorageObjectResponse struct {
	Returnval []ID `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ListVStorageObjectsAttachedToTag ListVStorageObjectsAttachedToTagRequestType

func init() {
	t["ListVStorageObjectsAttachedToTag"] = reflect.TypeOf((*ListVStorageObjectsAttachedToTag)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.ListVStorageObjectsAttachedToTag`.
type ListVStorageObjectsAttachedToTagRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The category to which the tag belongs.
	Category string `xml:"category" json:"category"`
	// The tag to be queried.
	Tag string `xml:"tag" json:"tag"`
}

func init() {
	t["ListVStorageObjectsAttachedToTagRequestType"] = reflect.TypeOf((*ListVStorageObjectsAttachedToTagRequestType)(nil)).Elem()
}

type ListVStorageObjectsAttachedToTagResponse struct {
	Returnval []ID `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// This event records when a local datastore is created.
type LocalDatastoreCreatedEvent struct {
	HostEvent

	// The associated datastore.
	Datastore DatastoreEventArgument `xml:"datastore" json:"datastore"`
	// Url of the associated datastore.
	DatastoreUrl string `xml:"datastoreUrl,omitempty" json:"datastoreUrl,omitempty"`
}

func init() {
	t["LocalDatastoreCreatedEvent"] = reflect.TypeOf((*LocalDatastoreCreatedEvent)(nil)).Elem()
}

// The information details about a datastore that is local to a host.
type LocalDatastoreInfo struct {
	DatastoreInfo

	// The local path on a host.
	//
	// May not
	// be available when the datastore is not accessible.
	Path string `xml:"path,omitempty" json:"path,omitempty"`
}

func init() {
	t["LocalDatastoreInfo"] = reflect.TypeOf((*LocalDatastoreInfo)(nil)).Elem()
}

// Deprecated as of vSphere API 4.0, this is not used by the system.
//
// Specify license key data to store locally.
type LocalLicenseSource struct {
	LicenseSource

	// The size of this string is implementation dependent.
	//
	// It must contain ASCII or ISO Latin-1 characters only.
	LicenseKeys string `xml:"licenseKeys" json:"licenseKeys"`
}

func init() {
	t["LocalLicenseSource"] = reflect.TypeOf((*LocalLicenseSource)(nil)).Elem()
}

// Local Tech Support Mode for the host has been enabled.
type LocalTSMEnabledEvent struct {
	HostEvent
}

func init() {
	t["LocalTSMEnabledEvent"] = reflect.TypeOf((*LocalTSMEnabledEvent)(nil)).Elem()
}

// Message data which is intended to be displayed according
// to the locale of a client.
//
// A `LocalizableMessage` contains both a formatted, localized
// version of the text and the data needed to perform localization in
// conjunction with localization catalogs.
//
// Clients of the VIM API may use vim.SessionManager.setLocale()
// to cause the server to emit a localized `LocalizableMessage.message`, or may perform
// client-side localization based on message catalogs provided by the
// server.
//   - If the substition variable is a string, no further lookup is required.
//   - `LocalizableMessage.arg` = \[("address" = "127.0.0.1")\]
//   - CATALOG(locmsg, `LocalizableMessage.key`) = "IP address is {address}"
//   - \==&gt; `LocalizableMessage.message` = "IP address is 127.0.0.1"
//   - If the substitution variable is an integer, value is a lookup key.
//   - `LocalizableMessage.arg` = \[("1" = "button.cancel"), ("2" = "msg.revert")\]
//   - CATALOG(locmsg, `LocalizableMessage.key`) = "Select '{1}' to {2}"
//   - CATALOG(locmsg, button.cancel) = "Cancel"
//   - CATALOG(locmsg, msg.revert) = "revert"
//   - \==&gt; `LocalizableMessage.message` = "Select 'Cancel' to revert"
//   - If the variable contains '@', value is a label lookup in another
//     catalog, where {name.@CATALOG.prefix} looks up prefix.`LocalizableMessage.arg`\[name\].label
//     in CATALOG.
//   - `LocalizableMessage.arg` = \[("field" = "queued")\]
//   - CATALOG(locmsg, `LocalizableMessage.key`) = "State is {field.@enum.TaskInfo.State}"
//   - CATALOG(enum, TaskInfo.State.queued.label) is "Queued"
//   - \==&gt; `LocalizableMessage.message` = "State is Queued"
type LocalizableMessage struct {
	DynamicData

	// Unique key identifying the message in the localized message catalog.
	Key string `xml:"key" json:"key"`
	// Substitution arguments for variables in the localized message.
	Arg []KeyAnyValue `xml:"arg,omitempty" json:"arg,omitempty"`
	// Message in session locale.
	//
	// Use vim.SessionManager.setLocale() to change the session locale.
	Message string `xml:"message,omitempty" json:"message,omitempty"`
}

func init() {
	t["LocalizableMessage"] = reflect.TypeOf((*LocalizableMessage)(nil)).Elem()
}

// Description of an available message catalog
type LocalizationManagerMessageCatalog struct {
	DynamicData

	// The module or extension that publishes this catalog.
	//
	// The moduleName will be empty for the core catalogs for the
	// VirtualCenter server itself.
	ModuleName string `xml:"moduleName" json:"moduleName"`
	// The name of the catalog.
	CatalogName string `xml:"catalogName" json:"catalogName"`
	// The locale for the catalog.
	Locale string `xml:"locale" json:"locale"`
	// The URI (relative to the connection URL for the VirtualCenter server
	// itself) from which the catalog can be downloaded.
	//
	// The caller will need to augment this with a scheme and authority (host
	// and port) to make a complete URL.
	CatalogUri string `xml:"catalogUri" json:"catalogUri"`
	// The last-modified time of the catalog file, if available
	LastModified *time.Time `xml:"lastModified" json:"lastModified,omitempty"`
	// The checksum of the catalog file, if available
	Md5sum string `xml:"md5sum,omitempty" json:"md5sum,omitempty"`
	// The version of the catalog file, if available
	// The format is dot-separated version string, e.g.
	//
	// "1.2.3".
	Version string `xml:"version,omitempty" json:"version,omitempty"`
}

func init() {
	t["LocalizationManagerMessageCatalog"] = reflect.TypeOf((*LocalizationManagerMessageCatalog)(nil)).Elem()
}

// A wrapper class used to pass MethodFault data objects over the wire
// along with a localized display message for the fault.
type LocalizedMethodFault struct {
	DynamicData

	Fault BaseMethodFault `xml:"fault,typeattr" json:"fault"`
	// The localized message that would be sent in the faultstring element
	// of the SOAP Fault.
	//
	// It is optional so that clients are not required
	// to send a localized message to the server, but servers are required
	// to send the localized message to clients.
	LocalizedMessage string `xml:"localizedMessage,omitempty" json:"localizedMessage,omitempty"`
}

func init() {
	t["LocalizedMethodFault"] = reflect.TypeOf((*LocalizedMethodFault)(nil)).Elem()
}

// Locker has not been configured properly.
//
// This event is fired when the datastore configured to back the locker
// does not exist or when connectivity to the datastore is lost.
type LockerMisconfiguredEvent struct {
	Event

	// The datastore that has been configured to back the locker
	Datastore DatastoreEventArgument `xml:"datastore" json:"datastore"`
}

func init() {
	t["LockerMisconfiguredEvent"] = reflect.TypeOf((*LockerMisconfiguredEvent)(nil)).Elem()
}

// Locker was reconfigured to a new location.
type LockerReconfiguredEvent struct {
	Event

	// The datastore that was previously backing the locker.
	//
	// This field is not
	// set if a datastore was not backing the locker previously.
	OldDatastore *DatastoreEventArgument `xml:"oldDatastore,omitempty" json:"oldDatastore,omitempty"`
	// The datastore that is now used to back the locker.
	//
	// This field is not set if no datastore is currently backing the locker.
	NewDatastore *DatastoreEventArgument `xml:"newDatastore,omitempty" json:"newDatastore,omitempty"`
}

func init() {
	t["LockerReconfiguredEvent"] = reflect.TypeOf((*LockerReconfiguredEvent)(nil)).Elem()
}

// A LogBundlingFailed exception is thrown when generation of a diagnostic
// data bundle fails.
type LogBundlingFailed struct {
	VimFault
}

func init() {
	t["LogBundlingFailed"] = reflect.TypeOf((*LogBundlingFailed)(nil)).Elem()
}

type LogBundlingFailedFault LogBundlingFailed

func init() {
	t["LogBundlingFailedFault"] = reflect.TypeOf((*LogBundlingFailedFault)(nil)).Elem()
}

type LogUserEvent LogUserEventRequestType

func init() {
	t["LogUserEvent"] = reflect.TypeOf((*LogUserEvent)(nil)).Elem()
}

// The parameters of `EventManager.LogUserEvent`.
type LogUserEventRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The entity against which the event is logged. The entity must be
	// the root folder, a DataCenter, a VirtualMachine, a HostSystem,
	// or a ComputeResource.
	//
	// Required privileges: Global.LogEvent
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// The message to be logged.
	Msg string `xml:"msg" json:"msg"`
}

func init() {
	t["LogUserEventRequestType"] = reflect.TypeOf((*LogUserEventRequestType)(nil)).Elem()
}

type LogUserEventResponse struct {
}

type Login LoginRequestType

func init() {
	t["Login"] = reflect.TypeOf((*Login)(nil)).Elem()
}

type LoginBySSPI LoginBySSPIRequestType

func init() {
	t["LoginBySSPI"] = reflect.TypeOf((*LoginBySSPI)(nil)).Elem()
}

// The parameters of `SessionManager.LoginBySSPI`.
type LoginBySSPIRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The partially formed context returned from
	// InitializeSecurityContext().
	Base64Token string `xml:"base64Token" json:"base64Token"`
	// A two-character ISO-639 language ID (like "en")
	// optionally followed by an
	// underscore and a two-character ISO 3166 country ID (like "US").
	//
	// Examples are "de", "fr\_CA", "zh", "zh\_CN", and "zh\_TW".
	// Note: The method uses the server default locale when
	// a locale is not provided. This default can be configured in the
	// server configuration file. If unspecified, it defaults to the
	// locale of the server environment or English ("en") if unsupported.
	Locale string `xml:"locale,omitempty" json:"locale,omitempty"`
}

func init() {
	t["LoginBySSPIRequestType"] = reflect.TypeOf((*LoginBySSPIRequestType)(nil)).Elem()
}

type LoginBySSPIResponse struct {
	Returnval UserSession `xml:"returnval" json:"returnval"`
}

type LoginByToken LoginByTokenRequestType

func init() {
	t["LoginByToken"] = reflect.TypeOf((*LoginByToken)(nil)).Elem()
}

// The parameters of `SessionManager.LoginByToken`.
type LoginByTokenRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A two-character ISO-639 language ID (like "en")
	// optionally followed by an
	// underscore and a two-character ISO 3166 country ID (like "US").
	//
	// Examples are "de", "fr\_CA", "zh", "zh\_CN", and "zh\_TW".
	// Note: The method uses the server default locale when
	// a locale is not provided. This default can be configured in the
	// server configuration file. If unspecified, it defaults to the
	// locale of the server environment or English ("en") if unsupported.
	Locale string `xml:"locale,omitempty" json:"locale,omitempty"`
}

func init() {
	t["LoginByTokenRequestType"] = reflect.TypeOf((*LoginByTokenRequestType)(nil)).Elem()
}

type LoginByTokenResponse struct {
	Returnval UserSession `xml:"returnval" json:"returnval"`
}

type LoginExtensionByCertificate LoginExtensionByCertificateRequestType

func init() {
	t["LoginExtensionByCertificate"] = reflect.TypeOf((*LoginExtensionByCertificate)(nil)).Elem()
}

// The parameters of `SessionManager.LoginExtensionByCertificate`.
type LoginExtensionByCertificateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Key of extension that is logging in.
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
	// A two-character ISO-639 language ID (like "en")
	// optionally followed by an
	// underscore and a two-character ISO 3166 country ID (like "US").
	//
	// Examples are "de", "fr\_CA", "zh", "zh\_CN", and "zh\_TW".
	// Note: The method uses the server default locale when
	// a locale is not provided. This default can be configured in the
	// server configuration file. If unspecified, it defaults to the
	// locale of the server environment or English ("en") if unsupported.
	Locale string `xml:"locale,omitempty" json:"locale,omitempty"`
}

func init() {
	t["LoginExtensionByCertificateRequestType"] = reflect.TypeOf((*LoginExtensionByCertificateRequestType)(nil)).Elem()
}

type LoginExtensionByCertificateResponse struct {
	Returnval UserSession `xml:"returnval" json:"returnval"`
}

type LoginExtensionBySubjectName LoginExtensionBySubjectNameRequestType

func init() {
	t["LoginExtensionBySubjectName"] = reflect.TypeOf((*LoginExtensionBySubjectName)(nil)).Elem()
}

// The parameters of `SessionManager.LoginExtensionBySubjectName`.
type LoginExtensionBySubjectNameRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Key of extension that is logging in.
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
	// A two-character ISO-639 language ID (like "en")
	// optionally followed by an
	// underscore and a two-character ISO 3166 country ID (like "US").
	//
	// Examples are "de", "fr\_CA", "zh", "zh\_CN", and "zh\_TW".
	// Note: The method uses the server default locale when
	// a locale is not provided. This default can be configured in the
	// server configuration file. If unspecified, it defaults to the
	// locale of the server environment or English ("en") if unsupported.
	Locale string `xml:"locale,omitempty" json:"locale,omitempty"`
}

func init() {
	t["LoginExtensionBySubjectNameRequestType"] = reflect.TypeOf((*LoginExtensionBySubjectNameRequestType)(nil)).Elem()
}

type LoginExtensionBySubjectNameResponse struct {
	Returnval UserSession `xml:"returnval" json:"returnval"`
}

// The parameters of `SessionManager.Login`.
type LoginRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The `ID`
	// of the user who is logging on to the server.
	UserName string `xml:"userName" json:"userName"`
	// The `HostAccountSpec.password`
	// of the user who is logging on to the server.
	Password string `xml:"password" json:"password"`
	// A two-character ISO-639 language ID (like "en")
	// optionally followed by an
	// underscore and a two-character ISO 3166 country ID (like "US").
	//
	// Examples are "de", "fr\_CA", "zh", "zh\_CN", and "zh\_TW".
	// Note: The method uses the server default locale when
	// a locale is not provided. This default can be configured in the
	// server configuration file. If unspecified, it defaults to the
	// locale of the server environment or English ("en") if unsupported.
	Locale string `xml:"locale,omitempty" json:"locale,omitempty"`
}

func init() {
	t["LoginRequestType"] = reflect.TypeOf((*LoginRequestType)(nil)).Elem()
}

type LoginResponse struct {
	Returnval UserSession `xml:"returnval" json:"returnval"`
}

type Logout LogoutRequestType

func init() {
	t["Logout"] = reflect.TypeOf((*Logout)(nil)).Elem()
}

type LogoutRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["LogoutRequestType"] = reflect.TypeOf((*LogoutRequestType)(nil)).Elem()
}

type LogoutResponse struct {
}

// The LongOption data object type is used to define the minimum, maximum,
// and default values for a 64-bit long option.
type LongOption struct {
	OptionType

	// The minimum value.
	Min int64 `xml:"min" json:"min"`
	// The maximum value.
	Max int64 `xml:"max" json:"max"`
	// The default value.
	DefaultValue int64 `xml:"defaultValue" json:"defaultValue"`
}

func init() {
	t["LongOption"] = reflect.TypeOf((*LongOption)(nil)).Elem()
}

// The long integer type of setting or configuration that may get an
// inherited value.
type LongPolicy struct {
	InheritablePolicy

	// The boolean value that is either set or inherited.
	Value int64 `xml:"value,omitempty" json:"value,omitempty"`
}

func init() {
	t["LongPolicy"] = reflect.TypeOf((*LongPolicy)(nil)).Elem()
}

type LookupDvPortGroup LookupDvPortGroupRequestType

func init() {
	t["LookupDvPortGroup"] = reflect.TypeOf((*LookupDvPortGroup)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.LookupDvPortGroup`.
type LookupDvPortGroupRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The key that identifies a portgroup of this VDS.
	PortgroupKey string `xml:"portgroupKey" json:"portgroupKey"`
}

func init() {
	t["LookupDvPortGroupRequestType"] = reflect.TypeOf((*LookupDvPortGroupRequestType)(nil)).Elem()
}

type LookupDvPortGroupResponse struct {
	Returnval *ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type LookupVmOverheadMemory LookupVmOverheadMemoryRequestType

func init() {
	t["LookupVmOverheadMemory"] = reflect.TypeOf((*LookupVmOverheadMemory)(nil)).Elem()
}

// The parameters of `OverheadMemoryManager.LookupVmOverheadMemory`.
type LookupVmOverheadMemoryRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The Virtual Machine managed object reference.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The Host managed object reference.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["LookupVmOverheadMemoryRequestType"] = reflect.TypeOf((*LookupVmOverheadMemoryRequestType)(nil)).Elem()
}

type LookupVmOverheadMemoryResponse struct {
	Returnval int64 `xml:"returnval" json:"returnval"`
}

// Base class for specifying MAC addresses.
type MacAddress struct {
	NegatableExpression
}

func init() {
	t["MacAddress"] = reflect.TypeOf((*MacAddress)(nil)).Elem()
}

// This class defines a range of MAC address.
type MacRange struct {
	MacAddress

	// MAC address.
	Address string `xml:"address" json:"address"`
	// Mask that is used in matching the MAC address.
	//
	// A MAC address is
	// considered matched if the "and" operation of the mask on the
	// MAC address and `MacRange.address` yields the same result.
	// For example, a MAC of "00:A0:FF:14:FF:29" is considered matched
	// for a `MacRange.address` of "00:A0:C9:14:C8:29" and a
	// `MacRange.mask` of "FF:FF:00:FF:00:FF".
	Mask string `xml:"mask" json:"mask"`
}

func init() {
	t["MacRange"] = reflect.TypeOf((*MacRange)(nil)).Elem()
}

// Migration of the virtual machine to the target host will need a move of
// virtual machine files, like configuration file or virtual disks, which is
// not permitted if the source host is in maintenance mode.
type MaintenanceModeFileMove struct {
	MigrationFault
}

func init() {
	t["MaintenanceModeFileMove"] = reflect.TypeOf((*MaintenanceModeFileMove)(nil)).Elem()
}

type MaintenanceModeFileMoveFault MaintenanceModeFileMove

func init() {
	t["MaintenanceModeFileMoveFault"] = reflect.TypeOf((*MaintenanceModeFileMoveFault)(nil)).Elem()
}

type MakeDirectory MakeDirectoryRequestType

func init() {
	t["MakeDirectory"] = reflect.TypeOf((*MakeDirectory)(nil)).Elem()
}

type MakeDirectoryInGuest MakeDirectoryInGuestRequestType

func init() {
	t["MakeDirectoryInGuest"] = reflect.TypeOf((*MakeDirectoryInGuest)(nil)).Elem()
}

// The parameters of `GuestFileManager.MakeDirectoryInGuest`.
type MakeDirectoryInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual Machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Modify
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The complete path to the directory to be created.
	DirectoryPath string `xml:"directoryPath" json:"directoryPath"`
	// Whether any parent directories
	// are to be created.
	CreateParentDirectories bool `xml:"createParentDirectories" json:"createParentDirectories"`
}

func init() {
	t["MakeDirectoryInGuestRequestType"] = reflect.TypeOf((*MakeDirectoryInGuestRequestType)(nil)).Elem()
}

type MakeDirectoryInGuestResponse struct {
}

// The parameters of `FileManager.MakeDirectory`.
type MakeDirectoryRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the folder, either a URL or a datastore path
	// referring to the folder to be created.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Required privileges: System.View
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// If true, any non-existent intermediate level
	// folders will be created. If not specified,
	// it is assumed to be false.
	CreateParentDirectories *bool `xml:"createParentDirectories" json:"createParentDirectories,omitempty"`
}

func init() {
	t["MakeDirectoryRequestType"] = reflect.TypeOf((*MakeDirectoryRequestType)(nil)).Elem()
}

type MakeDirectoryResponse struct {
}

// The parameters of `VirtualMachine.MakePrimaryVM_Task`.
type MakePrimaryVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The secondary virtual machine specified will be made the primary
	// virtual machine.
	// This field must specify a secondary virtual machine that is part of the fault
	// tolerant group that this virtual machine is currently associated with. It can
	// only be invoked from the primary virtual machine in the group.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
}

func init() {
	t["MakePrimaryVMRequestType"] = reflect.TypeOf((*MakePrimaryVMRequestType)(nil)).Elem()
}

type MakePrimaryVM_Task MakePrimaryVMRequestType

func init() {
	t["MakePrimaryVM_Task"] = reflect.TypeOf((*MakePrimaryVM_Task)(nil)).Elem()
}

type MakePrimaryVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The ManagedByInfo data object contains information about the extension
// responsible for the life-cycle of the entity.
type ManagedByInfo struct {
	DynamicData

	// Key of the extension managing the entity.
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
	// Managed entity type, as defined by the extension managing the entity.
	//
	// An extension can manage different types of entities - different kinds
	// of virtual machines, vApps, etc. - and this property is used to find
	// the corresponding `managedEntityInfo`
	// entry from the extension.
	Type string `xml:"type" json:"type"`
}

func init() {
	t["ManagedByInfo"] = reflect.TypeOf((*ManagedByInfo)(nil)).Elem()
}

// The general event argument for a managed entity.
type ManagedEntityEventArgument struct {
	EntityEventArgument

	// The managed entity.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["ManagedEntityEventArgument"] = reflect.TypeOf((*ManagedEntityEventArgument)(nil)).Elem()
}

// A ManagedObjectNotFound exception is thrown when a request refers to
// a managed object that no longer exists or has never existed.
type ManagedObjectNotFound struct {
	RuntimeFault

	// The managed object reference that generated the error.
	Obj ManagedObjectReference `xml:"obj" json:"obj"`
}

func init() {
	t["ManagedObjectNotFound"] = reflect.TypeOf((*ManagedObjectNotFound)(nil)).Elem()
}

type ManagedObjectNotFoundFault ManagedObjectNotFound

func init() {
	t["ManagedObjectNotFoundFault"] = reflect.TypeOf((*ManagedObjectNotFoundFault)(nil)).Elem()
}

// The ManagedObjectReference data object type is a special-purpose data object. Commonly referred to as simply a "reference", "MoRef", "MOR", or other variations of this theme, instances of managed object references contain data that identifies specific server-side managed objects. Managed object references are typically one of the return types from a method invocation.
//
// Managed object references are client application references to server-side managed objects. The client application uses ManagedObjectReference objects when it invokes operations on a server. A ManagedObjectReference is guaranteed to be unique and persistent during an object's lifetime. The reference persists after an object has moved within the inventory, across sessions, and across server restarts. If you remove an object, for example, a virtual machine, from the inventory, and then put it back, the reference changes.
type ManagedObjectReference struct {
	Type       string `xml:"type,attr" json:"type"`
	Value      string `xml:",chardata" json:"value"`
	ServerGUID string `xml:"serverGuid,attr,omitempty" json:"serverGuid,omitempty"`
}

func init() {
	t["ManagedObjectReference"] = reflect.TypeOf((*ManagedObjectReference)(nil)).Elem()
}

// The parameters of `HostStorageSystem.MarkAsLocal_Task`.
type MarkAsLocalRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The SCSI disk UUID.
	ScsiDiskUuid string `xml:"scsiDiskUuid" json:"scsiDiskUuid"`
}

func init() {
	t["MarkAsLocalRequestType"] = reflect.TypeOf((*MarkAsLocalRequestType)(nil)).Elem()
}

type MarkAsLocal_Task MarkAsLocalRequestType

func init() {
	t["MarkAsLocal_Task"] = reflect.TypeOf((*MarkAsLocal_Task)(nil)).Elem()
}

type MarkAsLocal_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostStorageSystem.MarkAsNonLocal_Task`.
type MarkAsNonLocalRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The SCSI disk UUID.
	ScsiDiskUuid string `xml:"scsiDiskUuid" json:"scsiDiskUuid"`
}

func init() {
	t["MarkAsNonLocalRequestType"] = reflect.TypeOf((*MarkAsNonLocalRequestType)(nil)).Elem()
}

type MarkAsNonLocal_Task MarkAsNonLocalRequestType

func init() {
	t["MarkAsNonLocal_Task"] = reflect.TypeOf((*MarkAsNonLocal_Task)(nil)).Elem()
}

type MarkAsNonLocal_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostStorageSystem.MarkAsNonSsd_Task`.
type MarkAsNonSsdRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The SCSI disk UUID.
	ScsiDiskUuid string `xml:"scsiDiskUuid" json:"scsiDiskUuid"`
}

func init() {
	t["MarkAsNonSsdRequestType"] = reflect.TypeOf((*MarkAsNonSsdRequestType)(nil)).Elem()
}

type MarkAsNonSsd_Task MarkAsNonSsdRequestType

func init() {
	t["MarkAsNonSsd_Task"] = reflect.TypeOf((*MarkAsNonSsd_Task)(nil)).Elem()
}

type MarkAsNonSsd_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostStorageSystem.MarkAsSsd_Task`.
type MarkAsSsdRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The SCSI disk UUID.
	ScsiDiskUuid string `xml:"scsiDiskUuid" json:"scsiDiskUuid"`
}

func init() {
	t["MarkAsSsdRequestType"] = reflect.TypeOf((*MarkAsSsdRequestType)(nil)).Elem()
}

type MarkAsSsd_Task MarkAsSsdRequestType

func init() {
	t["MarkAsSsd_Task"] = reflect.TypeOf((*MarkAsSsd_Task)(nil)).Elem()
}

type MarkAsSsd_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type MarkAsTemplate MarkAsTemplateRequestType

func init() {
	t["MarkAsTemplate"] = reflect.TypeOf((*MarkAsTemplate)(nil)).Elem()
}

type MarkAsTemplateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["MarkAsTemplateRequestType"] = reflect.TypeOf((*MarkAsTemplateRequestType)(nil)).Elem()
}

type MarkAsTemplateResponse struct {
}

type MarkAsVirtualMachine MarkAsVirtualMachineRequestType

func init() {
	t["MarkAsVirtualMachine"] = reflect.TypeOf((*MarkAsVirtualMachine)(nil)).Elem()
}

// The parameters of `VirtualMachine.MarkAsVirtualMachine`.
type MarkAsVirtualMachineRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Resource pool to associate with the virtual machine.
	//
	// Required privileges: Resource.AssignVMToPool
	//
	// Refers instance of `ResourcePool`.
	Pool ManagedObjectReference `xml:"pool" json:"pool"`
	// The target host on which the virtual machine is intended to run. The
	// host
	// parameter must specify a host that is a member of the ComputeResource
	// indirectly specified by the pool. For a stand-alone host or a cluster with
	// DRS, it can be omitted and the system selects a default.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["MarkAsVirtualMachineRequestType"] = reflect.TypeOf((*MarkAsVirtualMachineRequestType)(nil)).Elem()
}

type MarkAsVirtualMachineResponse struct {
}

type MarkDefault MarkDefaultRequestType

func init() {
	t["MarkDefault"] = reflect.TypeOf((*MarkDefault)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.MarkDefault`.
type MarkDefaultRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP cluster ID to become default.
	ClusterId KeyProviderId `xml:"clusterId" json:"clusterId"`
}

func init() {
	t["MarkDefaultRequestType"] = reflect.TypeOf((*MarkDefaultRequestType)(nil)).Elem()
}

type MarkDefaultResponse struct {
}

type MarkForRemoval MarkForRemovalRequestType

func init() {
	t["MarkForRemoval"] = reflect.TypeOf((*MarkForRemoval)(nil)).Elem()
}

type MarkForRemovalRequestType struct {
	This    ManagedObjectReference `xml:"_this" json:"-"`
	HbaName string                 `xml:"hbaName" json:"hbaName"`
	Remove  bool                   `xml:"remove" json:"remove"`
}

func init() {
	t["MarkForRemovalRequestType"] = reflect.TypeOf((*MarkForRemovalRequestType)(nil)).Elem()
}

type MarkForRemovalResponse struct {
}

type MarkPerenniallyReserved MarkPerenniallyReservedRequestType

func init() {
	t["MarkPerenniallyReserved"] = reflect.TypeOf((*MarkPerenniallyReserved)(nil)).Elem()
}

// The parameters of `HostStorageSystem.MarkPerenniallyReservedEx_Task`.
type MarkPerenniallyReservedExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The UUIDs of the ScsiLun devices that need a change in
	// the perennially reserved flag state.
	LunUuid []string `xml:"lunUuid,omitempty" json:"lunUuid,omitempty"`
	// State of the ScsiLun perennially reserved flag to be set.
	State bool `xml:"state" json:"state"`
}

func init() {
	t["MarkPerenniallyReservedExRequestType"] = reflect.TypeOf((*MarkPerenniallyReservedExRequestType)(nil)).Elem()
}

type MarkPerenniallyReservedEx_Task MarkPerenniallyReservedExRequestType

func init() {
	t["MarkPerenniallyReservedEx_Task"] = reflect.TypeOf((*MarkPerenniallyReservedEx_Task)(nil)).Elem()
}

type MarkPerenniallyReservedEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostStorageSystem.MarkPerenniallyReserved`.
type MarkPerenniallyReservedRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The UUID of the ScsiLun device to be marked as perennially
	// reserved.
	LunUuid string `xml:"lunUuid" json:"lunUuid"`
	// State of the ScsiLun perennially reserved flag to be set.
	State bool `xml:"state" json:"state"`
}

func init() {
	t["MarkPerenniallyReservedRequestType"] = reflect.TypeOf((*MarkPerenniallyReservedRequestType)(nil)).Elem()
}

type MarkPerenniallyReservedResponse struct {
}

type MarkServiceProviderEntities MarkServiceProviderEntitiesRequestType

func init() {
	t["MarkServiceProviderEntities"] = reflect.TypeOf((*MarkServiceProviderEntities)(nil)).Elem()
}

// The parameters of `TenantTenantManager.MarkServiceProviderEntities`.
type MarkServiceProviderEntitiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// an array of management entities.
	//
	// Required privileges: TenantManager.Update
	//
	// Refers instances of `ManagedEntity`.
	Entity []ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["MarkServiceProviderEntitiesRequestType"] = reflect.TypeOf((*MarkServiceProviderEntitiesRequestType)(nil)).Elem()
}

type MarkServiceProviderEntitiesResponse struct {
}

// Virtual memory file format is not supported on the datastore.
type MemoryFileFormatNotSupportedByDatastore struct {
	UnsupportedDatastore

	// The name of the Datastore.
	DatastoreName string `xml:"datastoreName" json:"datastoreName"`
	// Datastore file system volume type.
	//
	// See `DatastoreSummary.type`
	Type string `xml:"type" json:"type"`
}

func init() {
	t["MemoryFileFormatNotSupportedByDatastore"] = reflect.TypeOf((*MemoryFileFormatNotSupportedByDatastore)(nil)).Elem()
}

type MemoryFileFormatNotSupportedByDatastoreFault MemoryFileFormatNotSupportedByDatastore

func init() {
	t["MemoryFileFormatNotSupportedByDatastoreFault"] = reflect.TypeOf((*MemoryFileFormatNotSupportedByDatastoreFault)(nil)).Elem()
}

// Thrown when memory cannot be hot-added or hot-removed from the virtual machine.
type MemoryHotPlugNotSupported struct {
	VmConfigFault
}

func init() {
	t["MemoryHotPlugNotSupported"] = reflect.TypeOf((*MemoryHotPlugNotSupported)(nil)).Elem()
}

type MemoryHotPlugNotSupportedFault MemoryHotPlugNotSupported

func init() {
	t["MemoryHotPlugNotSupportedFault"] = reflect.TypeOf((*MemoryHotPlugNotSupportedFault)(nil)).Elem()
}

// The memory amount of the virtual machine is not within the recommended
// memory bounds for the virtual machine's guest OS.
type MemorySizeNotRecommended struct {
	VirtualHardwareCompatibilityIssue

	// The configured memory size of the virtual machine.
	MemorySizeMB int32 `xml:"memorySizeMB" json:"memorySizeMB"`
	// The minimum recommended memory size.
	MinMemorySizeMB int32 `xml:"minMemorySizeMB" json:"minMemorySizeMB"`
	// The maximum recommended memory size.
	MaxMemorySizeMB int32 `xml:"maxMemorySizeMB" json:"maxMemorySizeMB"`
}

func init() {
	t["MemorySizeNotRecommended"] = reflect.TypeOf((*MemorySizeNotRecommended)(nil)).Elem()
}

type MemorySizeNotRecommendedFault MemorySizeNotRecommended

func init() {
	t["MemorySizeNotRecommendedFault"] = reflect.TypeOf((*MemorySizeNotRecommendedFault)(nil)).Elem()
}

// The memory amount of the virtual machine is not within the acceptable
// guest memory bounds supported by the virtual machine's host.
type MemorySizeNotSupported struct {
	VirtualHardwareCompatibilityIssue

	// The configured memory size of the virtual machine.
	MemorySizeMB int32 `xml:"memorySizeMB" json:"memorySizeMB"`
	// The minimum acceptable memory size.
	MinMemorySizeMB int32 `xml:"minMemorySizeMB" json:"minMemorySizeMB"`
	// The maximum acceptable memory size.
	MaxMemorySizeMB int32 `xml:"maxMemorySizeMB" json:"maxMemorySizeMB"`
}

func init() {
	t["MemorySizeNotSupported"] = reflect.TypeOf((*MemorySizeNotSupported)(nil)).Elem()
}

// The memory amount of the virtual machine is not within the acceptable
// guest memory bounds supported by the virtual machine's datastore.
type MemorySizeNotSupportedByDatastore struct {
	VirtualHardwareCompatibilityIssue

	// The datastore which does not support the requested memory size.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The configured memory size of the virtual machine.
	MemorySizeMB int32 `xml:"memorySizeMB" json:"memorySizeMB"`
	// The maximum acceptable memory size supported by the datastore.
	MaxMemorySizeMB int32 `xml:"maxMemorySizeMB" json:"maxMemorySizeMB"`
}

func init() {
	t["MemorySizeNotSupportedByDatastore"] = reflect.TypeOf((*MemorySizeNotSupportedByDatastore)(nil)).Elem()
}

type MemorySizeNotSupportedByDatastoreFault MemorySizeNotSupportedByDatastore

func init() {
	t["MemorySizeNotSupportedByDatastoreFault"] = reflect.TypeOf((*MemorySizeNotSupportedByDatastoreFault)(nil)).Elem()
}

type MemorySizeNotSupportedFault MemorySizeNotSupported

func init() {
	t["MemorySizeNotSupportedFault"] = reflect.TypeOf((*MemorySizeNotSupportedFault)(nil)).Elem()
}

// Thrown if a request to take a memory snapshot is issued
// on a virtual machine with an independent disk.
type MemorySnapshotOnIndependentDisk struct {
	SnapshotFault
}

func init() {
	t["MemorySnapshotOnIndependentDisk"] = reflect.TypeOf((*MemorySnapshotOnIndependentDisk)(nil)).Elem()
}

type MemorySnapshotOnIndependentDiskFault MemorySnapshotOnIndependentDisk

func init() {
	t["MemorySnapshotOnIndependentDiskFault"] = reflect.TypeOf((*MemorySnapshotOnIndependentDiskFault)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.MergeDvs_Task`.
type MergeDvsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The switch (source) to be merged
	//
	// Required privileges: DVSwitch.Delete
	//
	// Refers instance of `DistributedVirtualSwitch`.
	Dvs ManagedObjectReference `xml:"dvs" json:"dvs"`
}

func init() {
	t["MergeDvsRequestType"] = reflect.TypeOf((*MergeDvsRequestType)(nil)).Elem()
}

type MergeDvs_Task MergeDvsRequestType

func init() {
	t["MergeDvs_Task"] = reflect.TypeOf((*MergeDvs_Task)(nil)).Elem()
}

type MergeDvs_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type MergePermissions MergePermissionsRequestType

func init() {
	t["MergePermissions"] = reflect.TypeOf((*MergePermissions)(nil)).Elem()
}

// The parameters of `AuthorizationManager.MergePermissions`.
type MergePermissionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the source role providing the permissions
	// which are changing.
	SrcRoleId int32 `xml:"srcRoleId" json:"srcRoleId"`
	// The ID of the destination role to which the
	// permissions are reassigned.
	DstRoleId int32 `xml:"dstRoleId" json:"dstRoleId"`
}

func init() {
	t["MergePermissionsRequestType"] = reflect.TypeOf((*MergePermissionsRequestType)(nil)).Elem()
}

type MergePermissionsResponse struct {
}

// This data object type defines an operation and its arguments, invoked
// on a particular entity.
type MethodAction struct {
	Action

	// Name of the operation.
	Name string `xml:"name" json:"name"`
	// An array consisting of the arguments for the operation.
	Argument []MethodActionArgument `xml:"argument,omitempty" json:"argument,omitempty"`
}

func init() {
	t["MethodAction"] = reflect.TypeOf((*MethodAction)(nil)).Elem()
}

// This data object type defines a named argument for an operation.
type MethodActionArgument struct {
	DynamicData

	// The value of the argument.
	Value AnyType `xml:"value,typeattr" json:"value"`
}

func init() {
	t["MethodActionArgument"] = reflect.TypeOf((*MethodActionArgument)(nil)).Elem()
}

// A MethodAlreadyDisabledFault fault is thrown when an attempt
// is made to disable a method that is already disabled.
type MethodAlreadyDisabledFault struct {
	RuntimeFault

	SourceId string `xml:"sourceId" json:"sourceId"`
}

func init() {
	t["MethodAlreadyDisabledFault"] = reflect.TypeOf((*MethodAlreadyDisabledFault)(nil)).Elem()
}

type MethodAlreadyDisabledFaultFault MethodAlreadyDisabledFault

func init() {
	t["MethodAlreadyDisabledFaultFault"] = reflect.TypeOf((*MethodAlreadyDisabledFaultFault)(nil)).Elem()
}

// Static strings used for describing an object model method.
type MethodDescription struct {
	Description

	// Method being described.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["MethodDescription"] = reflect.TypeOf((*MethodDescription)(nil)).Elem()
}

// A MethodDisabled fault is thrown if a disabled method
// is invoked by the client.
//
// The method denote an invalid state
// operation or may have been explicitly disabled.
type MethodDisabled struct {
	RuntimeFault

	Source string `xml:"source,omitempty" json:"source,omitempty"`
}

func init() {
	t["MethodDisabled"] = reflect.TypeOf((*MethodDisabled)(nil)).Elem()
}

type MethodDisabledFault MethodDisabled

func init() {
	t["MethodDisabledFault"] = reflect.TypeOf((*MethodDisabledFault)(nil)).Elem()
}

// The base data object type for all the object model faults
// that an application might handle.
type MethodFault struct {
	// Fault which is the cause of this fault.
	FaultCause *LocalizedMethodFault `xml:"faultCause,omitempty" json:"faultCause,omitempty"`
	// Message which has details about the error
	// Message can also contain a key to message catalog which
	// can be used to generate better localized messages.
	FaultMessage []LocalizableMessage `xml:"faultMessage,omitempty" json:"faultMessage,omitempty"`
}

func init() {
	t["MethodFault"] = reflect.TypeOf((*MethodFault)(nil)).Elem()
}

type MethodFaultFault BaseMethodFault

func init() {
	t["MethodFaultFault"] = reflect.TypeOf((*MethodFaultFault)(nil)).Elem()
}

// MethodNotFound is thrown to indicate that a method called on a managed
// object does not exist.
type MethodNotFound struct {
	InvalidRequest

	// The receiver of the call
	Receiver ManagedObjectReference `xml:"receiver" json:"receiver"`
	// The method called.
	Method string `xml:"method" json:"method"`
}

func init() {
	t["MethodNotFound"] = reflect.TypeOf((*MethodNotFound)(nil)).Elem()
}

type MethodNotFoundFault MethodNotFound

func init() {
	t["MethodNotFoundFault"] = reflect.TypeOf((*MethodNotFoundFault)(nil)).Elem()
}

// An alarm expression that uses a metric as the condition that triggers an
// alarm.
//
// Base type.
//
// There are two alarm operands: yellow and red. At least one of them
// must be set. The value of the alarm expression is determined as follows:
//   - If the host is not connected, the host metric expression is gray.
//   - If the vm is not connected, the vm metric expression is gray.
//   - If red is set but yellow is not, the expression is red when
//     the metric is over (isAbove operator) or under (isBelow operator)
//     the red value. Otherwise, the expression is green.
//   - If yellow is set but red is not, the expression is yellow when
//     the metric is over (isAbove) or under (isBelow)
//     the yellow value. Otherwise, the expression is green.
//   - If both yellow and red are set, the value of the expression is red
//     when the metric is over (isAbove) or under (isBelow) the red value.
//     Otherwise, the expression is yellow when the metric is over (isAbove)
//     or under (isBelow) the yellow value. Otherwise, the expression is green.
type MetricAlarmExpression struct {
	AlarmExpression

	// The operation to be tested on the metric.
	Operator MetricAlarmOperator `xml:"operator" json:"operator"`
	// Name of the object type containing the property.
	Type string `xml:"type" json:"type"`
	// The instance of the metric.
	Metric PerfMetricId `xml:"metric" json:"metric"`
	// Whether or not to test for a yellow condition.
	//
	// If not set, do not calculate yellow status.
	// If set, it contains the threshold value that triggers yellow status.
	Yellow int32 `xml:"yellow,omitempty" json:"yellow,omitempty"`
	// Time interval in seconds for which the yellow condition must be true
	// before the yellow status is triggered.
	//
	// If unset, the yellow status is
	// triggered immediately when the yellow condition becomes true.
	YellowInterval int32 `xml:"yellowInterval,omitempty" json:"yellowInterval,omitempty"`
	// Whether or not to test for a red condition.
	//
	// If not set, do not calculate red status.
	// If set, it contains the threshold value that triggers red status.
	Red int32 `xml:"red,omitempty" json:"red,omitempty"`
	// Time interval in seconds for which the red condition must be true
	// before the red status is triggered.
	//
	// If unset, the red status is
	// triggered immediately when the red condition becomes true.
	RedInterval int32 `xml:"redInterval,omitempty" json:"redInterval,omitempty"`
}

func init() {
	t["MetricAlarmExpression"] = reflect.TypeOf((*MetricAlarmExpression)(nil)).Elem()
}

// The parameters of `VirtualMachine.MigrateVM_Task`.
type MigrateVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The target resource pool for the virtual machine. If the pool
	// parameter is left unset, the virtual machine's current pool is used
	// as the target pool.
	//
	// Required privileges: Resource.AssignVMToPool
	//
	// Refers instance of `ResourcePool`.
	Pool *ManagedObjectReference `xml:"pool,omitempty" json:"pool,omitempty"`
	// The target host to which the virtual machine is intended to migrate.
	// The host parameter
	// may be left unset if the compute resource associated with the
	// target pool represents a stand-alone host or a DRS-enabled cluster.
	// In the former case the stand-alone host is used as the target host.
	// In the latter case, the DRS system selects an appropriate
	// target host from the cluster.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The task priority (@see vim.VirtualMachine.MovePriority).
	Priority VirtualMachineMovePriority `xml:"priority" json:"priority"`
	// If specified, the virtual machine migrates only if
	// its state matches the specified state.
	State VirtualMachinePowerState `xml:"state,omitempty" json:"state,omitempty"`
}

func init() {
	t["MigrateVMRequestType"] = reflect.TypeOf((*MigrateVMRequestType)(nil)).Elem()
}

type MigrateVM_Task MigrateVMRequestType

func init() {
	t["MigrateVM_Task"] = reflect.TypeOf((*MigrateVM_Task)(nil)).Elem()
}

type MigrateVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// An MigrationDisabled fault is thrown if the
// migration failed due to disabled migration
type MigrationDisabled struct {
	MigrationFault
}

func init() {
	t["MigrationDisabled"] = reflect.TypeOf((*MigrationDisabled)(nil)).Elem()
}

type MigrationDisabledFault MigrationDisabled

func init() {
	t["MigrationDisabledFault"] = reflect.TypeOf((*MigrationDisabledFault)(nil)).Elem()
}

// A migration error.
type MigrationErrorEvent struct {
	MigrationEvent
}

func init() {
	t["MigrationErrorEvent"] = reflect.TypeOf((*MigrationErrorEvent)(nil)).Elem()
}

// These are events used to describe migration warning and errors
type MigrationEvent struct {
	VmEvent

	// The fault that describes the migration issue.
	//
	// This is typically either a
	// MigrationFault or a VmConfigFault.
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["MigrationEvent"] = reflect.TypeOf((*MigrationEvent)(nil)).Elem()
}

// Base object type for issues that can occur when reassigning the execution
// host of a virtual machine using migrate or relocate.
//
// These issues are typically
// used as argument in the MigrationEvent. When a MigrationFault is used as a value
// in a MigrationEvent, the type of MigrationEvent determines if the issue is a
// warning or an error (for example, MigrationHostWarningEvent or
// MigrationHostErrorEvent). When thrown as an exception, the fault is an error.
//
// Issues are categorized as errors or warnings according to the following
// criteria:
//
// If the virtual machine is powered on:
//  1. Error for fatal problems with the VMotion interfaces or licensing.
//  2. Error if VMotion would fail.
//  3. Error if VMotion would in any way interrupt the continuous and consistent
//     operation of the virtual machine.
//  4. Warning for potential performance or connectivity problems between the
//     source and destination VMotion interfaces.
//  5. Warning if the virtual machine's currently disconnected devices may not
//     be connectable after VMotion.
//
// If the virtual machine is powered off or suspended:
//  1. Error if the destination host cannot access all the files that comprise
//     the virtual machine (including virtual disks).
//  2. Error if aspects of the virtual machine are not supported by the
//     destination host's hardware or software.
//  3. Warning if problems would occur when powering on or resuming the
//     virtual machine, if the usage/configuration of the destination
//     host were to remain in its current state.
type MigrationFault struct {
	VimFault
}

func init() {
	t["MigrationFault"] = reflect.TypeOf((*MigrationFault)(nil)).Elem()
}

type MigrationFaultFault BaseMigrationFault

func init() {
	t["MigrationFaultFault"] = reflect.TypeOf((*MigrationFaultFault)(nil)).Elem()
}

// A migration operation that requires feature support on source and
// destination hosts is lacking support on the host.
type MigrationFeatureNotSupported struct {
	MigrationFault

	// Whether this error is for the source host.
	AtSourceHost bool `xml:"atSourceHost" json:"atSourceHost"`
	// The name of the host.
	FailedHostName string `xml:"failedHostName" json:"failedHostName"`
	// The host.
	//
	// Refers instance of `HostSystem`.
	FailedHost ManagedObjectReference `xml:"failedHost" json:"failedHost"`
}

func init() {
	t["MigrationFeatureNotSupported"] = reflect.TypeOf((*MigrationFeatureNotSupported)(nil)).Elem()
}

type MigrationFeatureNotSupportedFault BaseMigrationFeatureNotSupported

func init() {
	t["MigrationFeatureNotSupportedFault"] = reflect.TypeOf((*MigrationFeatureNotSupportedFault)(nil)).Elem()
}

// A migration error that includes the destination host.
type MigrationHostErrorEvent struct {
	MigrationEvent

	// The name of the destination host.
	DstHost HostEventArgument `xml:"dstHost" json:"dstHost"`
}

func init() {
	t["MigrationHostErrorEvent"] = reflect.TypeOf((*MigrationHostErrorEvent)(nil)).Elem()
}

// A migration warning that includes the destination host.
type MigrationHostWarningEvent struct {
	MigrationEvent

	// The name of the destination host.
	DstHost HostEventArgument `xml:"dstHost" json:"dstHost"`
}

func init() {
	t["MigrationHostWarningEvent"] = reflect.TypeOf((*MigrationHostWarningEvent)(nil)).Elem()
}

// The VM to be migrated is not ready for the migration operation.
//
// This might
// because the VM is still in the progress of powering on or resuming from a
// suspended state.
type MigrationNotReady struct {
	MigrationFault

	Reason string `xml:"reason" json:"reason"`
}

func init() {
	t["MigrationNotReady"] = reflect.TypeOf((*MigrationNotReady)(nil)).Elem()
}

type MigrationNotReadyFault MigrationNotReady

func init() {
	t["MigrationNotReadyFault"] = reflect.TypeOf((*MigrationNotReadyFault)(nil)).Elem()
}

// A migration error that includes both the destination host and resource pool.
type MigrationResourceErrorEvent struct {
	MigrationEvent

	// The name of the destination resource pool.
	DstPool ResourcePoolEventArgument `xml:"dstPool" json:"dstPool"`
	// The name of the destination host.
	DstHost HostEventArgument `xml:"dstHost" json:"dstHost"`
}

func init() {
	t["MigrationResourceErrorEvent"] = reflect.TypeOf((*MigrationResourceErrorEvent)(nil)).Elem()
}

// A migration warning that includes both the destination host and resource pool.
type MigrationResourceWarningEvent struct {
	MigrationEvent

	// The name of the destination resource pool.
	DstPool ResourcePoolEventArgument `xml:"dstPool" json:"dstPool"`
	// The name of the destination host.
	DstHost HostEventArgument `xml:"dstHost" json:"dstHost"`
}

func init() {
	t["MigrationResourceWarningEvent"] = reflect.TypeOf((*MigrationResourceWarningEvent)(nil)).Elem()
}

// A migration warning.
type MigrationWarningEvent struct {
	MigrationEvent
}

func init() {
	t["MigrationWarningEvent"] = reflect.TypeOf((*MigrationWarningEvent)(nil)).Elem()
}

// A MismatchedBundle fault is thrown when the bundle supplied for
// `HostFirmwareSystem.RestoreFirmwareConfiguration` does not match the
// specifications of the host
type MismatchedBundle struct {
	VimFault

	// The uuid of the host that the bundle was generated for
	BundleUuid string `xml:"bundleUuid" json:"bundleUuid"`
	// The uuid of the host
	HostUuid string `xml:"hostUuid" json:"hostUuid"`
	// The build number of the host that the bundle was generated for
	BundleBuildNumber int32 `xml:"bundleBuildNumber" json:"bundleBuildNumber"`
	// The build number of the host
	HostBuildNumber int32 `xml:"hostBuildNumber" json:"hostBuildNumber"`
}

func init() {
	t["MismatchedBundle"] = reflect.TypeOf((*MismatchedBundle)(nil)).Elem()
}

type MismatchedBundleFault MismatchedBundle

func init() {
	t["MismatchedBundleFault"] = reflect.TypeOf((*MismatchedBundleFault)(nil)).Elem()
}

// Deprecated as of vSphere API 5.5, use `CannotUseNetwork` with
// a correct reason for the fault.
//
// The virtual machine network uses different offload or security
// policies on the destination host than on the source host.
//
// This is an error
// if the virtual machine is currently connected to the network, and a warning
// otherwise.
type MismatchedNetworkPolicies struct {
	MigrationFault

	// The label of the interface device.
	Device string `xml:"device" json:"device"`
	// The name of the network.
	Backing string `xml:"backing" json:"backing"`
	// The connected/disconnected state of the device.
	Connected bool `xml:"connected" json:"connected"`
}

func init() {
	t["MismatchedNetworkPolicies"] = reflect.TypeOf((*MismatchedNetworkPolicies)(nil)).Elem()
}

type MismatchedNetworkPoliciesFault MismatchedNetworkPolicies

func init() {
	t["MismatchedNetworkPoliciesFault"] = reflect.TypeOf((*MismatchedNetworkPoliciesFault)(nil)).Elem()
}

// The source and destination hosts do not use the same network name for
// their VMotion interfaces.
//
// This is a warning for migrating powered-on virtual
// machines.
type MismatchedVMotionNetworkNames struct {
	MigrationFault

	// The name of the network used by the source host VMotion interface.
	SourceNetwork string `xml:"sourceNetwork" json:"sourceNetwork"`
	// The name of the network used by the destination host VMotion interface.
	DestNetwork string `xml:"destNetwork" json:"destNetwork"`
}

func init() {
	t["MismatchedVMotionNetworkNames"] = reflect.TypeOf((*MismatchedVMotionNetworkNames)(nil)).Elem()
}

type MismatchedVMotionNetworkNamesFault MismatchedVMotionNetworkNames

func init() {
	t["MismatchedVMotionNetworkNamesFault"] = reflect.TypeOf((*MismatchedVMotionNetworkNamesFault)(nil)).Elem()
}

// A MissingBmcSuppport fault is thrown when a host's BMC doesn't support IPMI.
//
// BMC (Board Management Controller) is a piece of hardware required for IPMI.
type MissingBmcSupport struct {
	VimFault
}

func init() {
	t["MissingBmcSupport"] = reflect.TypeOf((*MissingBmcSupport)(nil)).Elem()
}

type MissingBmcSupportFault MissingBmcSupport

func init() {
	t["MissingBmcSupportFault"] = reflect.TypeOf((*MissingBmcSupportFault)(nil)).Elem()
}

// A controller key has not been specified for a new device
// that requires a controller, such as a disk or CD-ROM device.
type MissingController struct {
	InvalidDeviceSpec
}

func init() {
	t["MissingController"] = reflect.TypeOf((*MissingController)(nil)).Elem()
}

type MissingControllerFault MissingController

func init() {
	t["MissingControllerFault"] = reflect.TypeOf((*MissingControllerFault)(nil)).Elem()
}

// No IP pool is associated with a network.
type MissingIpPool struct {
	VAppPropertyFault
}

func init() {
	t["MissingIpPool"] = reflect.TypeOf((*MissingIpPool)(nil)).Elem()
}

type MissingIpPoolFault MissingIpPool

func init() {
	t["MissingIpPoolFault"] = reflect.TypeOf((*MissingIpPoolFault)(nil)).Elem()
}

// Usable open source components required for Linux customization were not found
// on the server.
type MissingLinuxCustResources struct {
	CustomizationFault
}

func init() {
	t["MissingLinuxCustResources"] = reflect.TypeOf((*MissingLinuxCustResources)(nil)).Elem()
}

type MissingLinuxCustResourcesFault MissingLinuxCustResources

func init() {
	t["MissingLinuxCustResourcesFault"] = reflect.TypeOf((*MissingLinuxCustResourcesFault)(nil)).Elem()
}

// No IP configuration exists for network.
type MissingNetworkIpConfig struct {
	VAppPropertyFault
}

func init() {
	t["MissingNetworkIpConfig"] = reflect.TypeOf((*MissingNetworkIpConfig)(nil)).Elem()
}

type MissingNetworkIpConfigFault MissingNetworkIpConfig

func init() {
	t["MissingNetworkIpConfigFault"] = reflect.TypeOf((*MissingNetworkIpConfigFault)(nil)).Elem()
}

// Used for reporting missing objects that were explicitly referenced by a
// filter spec.
//
// In other words, any of the objects referenced in `PropertyFilterSpec.objectSet`
type MissingObject struct {
	DynamicData

	// The object that is being reported missing
	Obj ManagedObjectReference `xml:"obj" json:"obj"`
	// Fault describing the failure to lookup this object
	//
	// The possible faults for missing objects are:
	//   - `SystemError` if there was some unknown problem
	//     looking up the object
	//   - `ManagedObjectNotFound` if the object is no
	//     longer available
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["MissingObject"] = reflect.TypeOf((*MissingObject)(nil)).Elem()
}

// Attempting to power-off a vApp for which no virtual machines has been
// configured to power off.
type MissingPowerOffConfiguration struct {
	VAppConfigFault
}

func init() {
	t["MissingPowerOffConfiguration"] = reflect.TypeOf((*MissingPowerOffConfiguration)(nil)).Elem()
}

type MissingPowerOffConfigurationFault MissingPowerOffConfiguration

func init() {
	t["MissingPowerOffConfigurationFault"] = reflect.TypeOf((*MissingPowerOffConfigurationFault)(nil)).Elem()
}

// Attempting to power-on a vApp service for which no virtual machines has been
// configured to power on.
type MissingPowerOnConfiguration struct {
	VAppConfigFault
}

func init() {
	t["MissingPowerOnConfiguration"] = reflect.TypeOf((*MissingPowerOnConfiguration)(nil)).Elem()
}

type MissingPowerOnConfigurationFault MissingPowerOnConfiguration

func init() {
	t["MissingPowerOnConfigurationFault"] = reflect.TypeOf((*MissingPowerOnConfigurationFault)(nil)).Elem()
}

// Used for reporting properties for which values could not be retrieved.
type MissingProperty struct {
	DynamicData

	// Property for which a value could not be retrieved
	Path string `xml:"path" json:"path"`
	// Fault describing the failure to retrieve the property value.
	//
	// The possible faults for missing properties are:
	//   - `SystemError` if there was some unknown problem
	//     reading the value
	//   - `SecurityError` if the logged in session did
	//     not have permission to read the value
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["MissingProperty"] = reflect.TypeOf((*MissingProperty)(nil)).Elem()
}

// A usable sysprep file was not found on the server.
type MissingWindowsCustResources struct {
	CustomizationFault
}

func init() {
	t["MissingWindowsCustResources"] = reflect.TypeOf((*MissingWindowsCustResources)(nil)).Elem()
}

type MissingWindowsCustResourcesFault MissingWindowsCustResources

func init() {
	t["MissingWindowsCustResourcesFault"] = reflect.TypeOf((*MissingWindowsCustResourcesFault)(nil)).Elem()
}

// Thrown when a mouse-keyboard-screen connection ticket to a virtual machine
// cannot be granted because the configured connection limit has been reached.
type MksConnectionLimitReached struct {
	InvalidState

	// MKS connection limit for the virtual machine.
	ConnectionLimit int32 `xml:"connectionLimit" json:"connectionLimit"`
}

func init() {
	t["MksConnectionLimitReached"] = reflect.TypeOf((*MksConnectionLimitReached)(nil)).Elem()
}

type MksConnectionLimitReachedFault MksConnectionLimitReached

func init() {
	t["MksConnectionLimitReachedFault"] = reflect.TypeOf((*MksConnectionLimitReachedFault)(nil)).Elem()
}

// The FileAccess.Modes data object type defines the known access modes
// for a datastore.
//
// The property values specify how to interpret
// the "what" property for a FileAccess object.
type ModeInfo struct {
	DynamicData

	// Can see the existence of a file.
	Browse string `xml:"browse,omitempty" json:"browse,omitempty"`
	// Can read a file.
	Read string `xml:"read" json:"read"`
	// Can read and write a file.
	Modify string `xml:"modify" json:"modify"`
	// Can execute or operate a file or look inside a directory.
	Use string `xml:"use" json:"use"`
	// Can change permissions for a file.
	Admin string `xml:"admin,omitempty" json:"admin,omitempty"`
	// Can do anything to a file, including change permissions.
	Full string `xml:"full" json:"full"`
}

func init() {
	t["ModeInfo"] = reflect.TypeOf((*ModeInfo)(nil)).Elem()
}

type ModifyListView ModifyListViewRequestType

func init() {
	t["ModifyListView"] = reflect.TypeOf((*ModifyListView)(nil)).Elem()
}

// The parameters of `ListView.ModifyListView`.
type ModifyListViewRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Optional list of objects to add to the view.
	//
	// Required privileges: System.View
	Add []ManagedObjectReference `xml:"add,omitempty" json:"add,omitempty"`
	// Optional list of objects to remove from the view.
	//
	// Required privileges: System.View
	Remove []ManagedObjectReference `xml:"remove,omitempty" json:"remove,omitempty"`
}

func init() {
	t["ModifyListViewRequestType"] = reflect.TypeOf((*ModifyListViewRequestType)(nil)).Elem()
}

type ModifyListViewResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The `MonthlyByDayTaskScheduler` data object sets the time for monthly
// task execution.
//
// You can set the schedule for task execution
// on one day during the month, and you complete the schedule by
// setting the inherited properties for the hour and minute.
//
// By default the scheduler executes the task on the specified day
// every month. If you set the interval to a value greater than 1,
// the task will execute at the specified monthly interval.
// (For example, an interval of 2 will cause the task to execute
// on the specified day, hour, and minute every 2 months.)
type MonthlyByDayTaskScheduler struct {
	MonthlyTaskScheduler

	// The day in every month to run the scheduled task.
	//
	// Valid values are 1 to 31.
	//
	// In any month where the value of "day" exceeds the total number of days
	// in the month, the scheduled task will run on the last day of the month.
	Day int32 `xml:"day" json:"day"`
}

func init() {
	t["MonthlyByDayTaskScheduler"] = reflect.TypeOf((*MonthlyByDayTaskScheduler)(nil)).Elem()
}

// The `MonthlyByWeekdayTaskScheduler` data object sets the time for
// monthly task execution.
//
// You identify a single day for task execution
// by specifying the week of the month and day of the week, and you
// complete the schedule by setting the inherited properties for the
// hour and minute.
//
// By default, the scheduler executes the task on the specified day
// every month. If you set the interval to a value greater than 1,
// the task will execute at the specified monthly interval. (For example,
// an interval of 2 will cause the task to execute on the specified
// day, hour, and minute every 2 months.)
type MonthlyByWeekdayTaskScheduler struct {
	MonthlyTaskScheduler

	// The week in the month during which the scheduled task is to run.
	Offset WeekOfMonth `xml:"offset" json:"offset"`
	// The day in the week when the scheduled task is to run.
	Weekday DayOfWeek `xml:"weekday" json:"weekday"`
}

func init() {
	t["MonthlyByWeekdayTaskScheduler"] = reflect.TypeOf((*MonthlyByWeekdayTaskScheduler)(nil)).Elem()
}

// The `MonthlyTaskScheduler` data object is the base type for
// the monthly schedulers (`MonthlyByDayTaskScheduler` and
// `MonthlyByWeekdayTaskScheduler`).
type MonthlyTaskScheduler struct {
	DailyTaskScheduler
}

func init() {
	t["MonthlyTaskScheduler"] = reflect.TypeOf((*MonthlyTaskScheduler)(nil)).Elem()
}

// Customization failed because the customization process was unable to mount a remote
// virtual disk file.
type MountError struct {
	CustomizationFault

	// The virtual machine to be customized.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Index into the virtual machine's device list,
	// representing the key value that identifies the virtual device
	// that is the presumed boot disk.
	DiskIndex int32 `xml:"diskIndex" json:"diskIndex"`
}

func init() {
	t["MountError"] = reflect.TypeOf((*MountError)(nil)).Elem()
}

type MountErrorFault MountError

func init() {
	t["MountErrorFault"] = reflect.TypeOf((*MountErrorFault)(nil)).Elem()
}

type MountToolsInstaller MountToolsInstallerRequestType

func init() {
	t["MountToolsInstaller"] = reflect.TypeOf((*MountToolsInstaller)(nil)).Elem()
}

type MountToolsInstallerRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["MountToolsInstallerRequestType"] = reflect.TypeOf((*MountToolsInstallerRequestType)(nil)).Elem()
}

type MountToolsInstallerResponse struct {
}

type MountVffsVolume MountVffsVolumeRequestType

func init() {
	t["MountVffsVolume"] = reflect.TypeOf((*MountVffsVolume)(nil)).Elem()
}

// The parameters of `HostStorageSystem.MountVffsVolume`.
type MountVffsVolumeRequestType struct {
	This     ManagedObjectReference `xml:"_this" json:"-"`
	VffsUuid string                 `xml:"vffsUuid" json:"vffsUuid"`
}

func init() {
	t["MountVffsVolumeRequestType"] = reflect.TypeOf((*MountVffsVolumeRequestType)(nil)).Elem()
}

type MountVffsVolumeResponse struct {
}

type MountVmfsVolume MountVmfsVolumeRequestType

func init() {
	t["MountVmfsVolume"] = reflect.TypeOf((*MountVmfsVolume)(nil)).Elem()
}

// The parameters of `HostStorageSystem.MountVmfsVolumeEx_Task`.
type MountVmfsVolumeExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// each element specifies the UUID of a VMFS volume to be unmounted.
	VmfsUuid []string `xml:"vmfsUuid" json:"vmfsUuid"`
}

func init() {
	t["MountVmfsVolumeExRequestType"] = reflect.TypeOf((*MountVmfsVolumeExRequestType)(nil)).Elem()
}

type MountVmfsVolumeEx_Task MountVmfsVolumeExRequestType

func init() {
	t["MountVmfsVolumeEx_Task"] = reflect.TypeOf((*MountVmfsVolumeEx_Task)(nil)).Elem()
}

type MountVmfsVolumeEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostStorageSystem.MountVmfsVolume`.
type MountVmfsVolumeRequestType struct {
	This     ManagedObjectReference `xml:"_this" json:"-"`
	VmfsUuid string                 `xml:"vmfsUuid" json:"vmfsUuid"`
}

func init() {
	t["MountVmfsVolumeRequestType"] = reflect.TypeOf((*MountVmfsVolumeRequestType)(nil)).Elem()
}

type MountVmfsVolumeResponse struct {
}

// The parameters of `DistributedVirtualSwitch.MoveDVPort_Task`.
type MoveDVPortRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The keys of the ports to be moved into the portgroup.
	PortKey []string `xml:"portKey" json:"portKey"`
	// The key of the portgroup to be moved into.
	// If unset, the port will be moved under the switch.
	DestinationPortgroupKey string `xml:"destinationPortgroupKey,omitempty" json:"destinationPortgroupKey,omitempty"`
}

func init() {
	t["MoveDVPortRequestType"] = reflect.TypeOf((*MoveDVPortRequestType)(nil)).Elem()
}

type MoveDVPort_Task MoveDVPortRequestType

func init() {
	t["MoveDVPort_Task"] = reflect.TypeOf((*MoveDVPort_Task)(nil)).Elem()
}

type MoveDVPort_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `FileManager.MoveDatastoreFile_Task`.
type MoveDatastoreFileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the source, either a URL or a datastore path
	// referring to the file or folder to be moved.
	SourceName string `xml:"sourceName" json:"sourceName"`
	// If <code>sourceName</code> is a datastore path, the
	// datacenter for that datastore path.
	// Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>sourceName</code> must be a URL.
	//
	// Required privileges: System.View
	//
	// Refers instance of `Datacenter`.
	SourceDatacenter *ManagedObjectReference `xml:"sourceDatacenter,omitempty" json:"sourceDatacenter,omitempty"`
	// The name of the destination, either a URL or a
	// datastore path referring to the destination file or folder.
	DestinationName string `xml:"destinationName" json:"destinationName"`
	// If <code>destinationName</code> is a datastore
	// path, the datacenter for that datastore path.
	// Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter, it is assumed that
	// the destination path belongs to the source datacenter.
	//
	// Required privileges: System.View
	//
	// Refers instance of `Datacenter`.
	DestinationDatacenter *ManagedObjectReference `xml:"destinationDatacenter,omitempty" json:"destinationDatacenter,omitempty"`
	// If true, overwrite any identically named file
	// at the destination. If not specified, it is assumed to be false.
	Force *bool `xml:"force" json:"force,omitempty"`
}

func init() {
	t["MoveDatastoreFileRequestType"] = reflect.TypeOf((*MoveDatastoreFileRequestType)(nil)).Elem()
}

type MoveDatastoreFile_Task MoveDatastoreFileRequestType

func init() {
	t["MoveDatastoreFile_Task"] = reflect.TypeOf((*MoveDatastoreFile_Task)(nil)).Elem()
}

type MoveDatastoreFile_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type MoveDirectoryInGuest MoveDirectoryInGuestRequestType

func init() {
	t["MoveDirectoryInGuest"] = reflect.TypeOf((*MoveDirectoryInGuest)(nil)).Elem()
}

// The parameters of `GuestFileManager.MoveDirectoryInGuest`.
type MoveDirectoryInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual Machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Modify
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The complete path to the directory to be moved.
	SrcDirectoryPath string `xml:"srcDirectoryPath" json:"srcDirectoryPath"`
	// The complete path to the where the directory is
	// moved or its new name. It cannot be a path to an existing directory
	// or an existing file.
	DstDirectoryPath string `xml:"dstDirectoryPath" json:"dstDirectoryPath"`
}

func init() {
	t["MoveDirectoryInGuestRequestType"] = reflect.TypeOf((*MoveDirectoryInGuestRequestType)(nil)).Elem()
}

type MoveDirectoryInGuestResponse struct {
}

type MoveFileInGuest MoveFileInGuestRequestType

func init() {
	t["MoveFileInGuest"] = reflect.TypeOf((*MoveFileInGuest)(nil)).Elem()
}

// The parameters of `GuestFileManager.MoveFileInGuest`.
type MoveFileInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual Machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Modify
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The complete path to the original file or
	// symbolic link to be moved.
	SrcFilePath string `xml:"srcFilePath" json:"srcFilePath"`
	// The complete path to the where the file is renamed.
	// It cannot be a path to an existing directory.
	DstFilePath string `xml:"dstFilePath" json:"dstFilePath"`
	// If set, the destination file is clobbered.
	Overwrite bool `xml:"overwrite" json:"overwrite"`
}

func init() {
	t["MoveFileInGuestRequestType"] = reflect.TypeOf((*MoveFileInGuestRequestType)(nil)).Elem()
}

type MoveFileInGuestResponse struct {
}

// The parameters of `ClusterComputeResource.MoveHostInto_Task`.
type MoveHostIntoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The list of hosts to move into the cluster.
	//
	// Required privileges: Host.Inventory.MoveHost
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The resource pool to match the root resource pool of
	// stand-alone hosts. This argument has no effect if the host is part of a
	// cluster.
	//
	// Refers instance of `ResourcePool`.
	ResourcePool *ManagedObjectReference `xml:"resourcePool,omitempty" json:"resourcePool,omitempty"`
}

func init() {
	t["MoveHostIntoRequestType"] = reflect.TypeOf((*MoveHostIntoRequestType)(nil)).Elem()
}

type MoveHostInto_Task MoveHostIntoRequestType

func init() {
	t["MoveHostInto_Task"] = reflect.TypeOf((*MoveHostInto_Task)(nil)).Elem()
}

type MoveHostInto_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `Folder.MoveIntoFolder_Task`.
type MoveIntoFolderRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The list of objects to be moved into the folder.
	//
	// Refers instances of `ManagedEntity`.
	List []ManagedObjectReference `xml:"list" json:"list"`
}

func init() {
	t["MoveIntoFolderRequestType"] = reflect.TypeOf((*MoveIntoFolderRequestType)(nil)).Elem()
}

type MoveIntoFolder_Task MoveIntoFolderRequestType

func init() {
	t["MoveIntoFolder_Task"] = reflect.TypeOf((*MoveIntoFolder_Task)(nil)).Elem()
}

type MoveIntoFolder_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `ClusterComputeResource.MoveInto_Task`.
type MoveIntoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The list of hosts to move into the cluster.
	//
	// Required privileges: Host.Inventory.MoveHost
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["MoveIntoRequestType"] = reflect.TypeOf((*MoveIntoRequestType)(nil)).Elem()
}

type MoveIntoResourcePool MoveIntoResourcePoolRequestType

func init() {
	t["MoveIntoResourcePool"] = reflect.TypeOf((*MoveIntoResourcePool)(nil)).Elem()
}

// The parameters of `ResourcePool.MoveIntoResourcePool`.
type MoveIntoResourcePoolRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A list of ResourcePool and VirtualMachine objects.
	//
	// Refers instances of `ManagedEntity`.
	List []ManagedObjectReference `xml:"list" json:"list"`
}

func init() {
	t["MoveIntoResourcePoolRequestType"] = reflect.TypeOf((*MoveIntoResourcePoolRequestType)(nil)).Elem()
}

type MoveIntoResourcePoolResponse struct {
}

type MoveInto_Task MoveIntoRequestType

func init() {
	t["MoveInto_Task"] = reflect.TypeOf((*MoveInto_Task)(nil)).Elem()
}

type MoveInto_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualDiskManager.MoveVirtualDisk_Task`.
type MoveVirtualDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the source, either a datastore path
	// or a URL referring to the virtual disk to be moved.
	SourceName string `xml:"sourceName" json:"sourceName"`
	// If <code>sourceName</code> is a datastore path, the
	// datacenter for that datastore path.
	// Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>sourceName</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	SourceDatacenter *ManagedObjectReference `xml:"sourceDatacenter,omitempty" json:"sourceDatacenter,omitempty"`
	// The name of the destination, either a datastore path
	// or a URL referring to the destination virtual disk.
	DestName string `xml:"destName" json:"destName"`
	// If <code>destName</code> is a datastore
	// path, the datacenter for that datastore path.
	// Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter, it is assumed that
	// the destination path belongs to the source datacenter.
	//
	// Refers instance of `Datacenter`.
	DestDatacenter *ManagedObjectReference `xml:"destDatacenter,omitempty" json:"destDatacenter,omitempty"`
	// If true, overwrite any indentically named disk at the destination.
	// If not specified, it is assumed to be false
	Force *bool `xml:"force" json:"force,omitempty"`
	// User can specify new set of profile when moving virtual disk.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
}

func init() {
	t["MoveVirtualDiskRequestType"] = reflect.TypeOf((*MoveVirtualDiskRequestType)(nil)).Elem()
}

type MoveVirtualDisk_Task MoveVirtualDiskRequestType

func init() {
	t["MoveVirtualDisk_Task"] = reflect.TypeOf((*MoveVirtualDisk_Task)(nil)).Elem()
}

type MoveVirtualDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The value of MTU configured in the vSphere Distributed Switch
// matches physical switch.
type MtuMatchEvent struct {
	DvsHealthStatusChangeEvent
}

func init() {
	t["MtuMatchEvent"] = reflect.TypeOf((*MtuMatchEvent)(nil)).Elem()
}

// The value of MTU configured in the vSphere Distributed Switch
// mismatches physical switch.
type MtuMismatchEvent struct {
	DvsHealthStatusChangeEvent
}

func init() {
	t["MtuMismatchEvent"] = reflect.TypeOf((*MtuMismatchEvent)(nil)).Elem()
}

// The multi-writer sharing of the specified virtual disk is not supported.
//
// Typically, this fault is returned as part of a parent fault like
// `VmConfigIncompatibleForFaultTolerance`, indicating that the
// virtual disk's multi-writer sharing needs to be changed before fault
// tolerance can be enabled on the associated virtual machine.
type MultiWriterNotSupported struct {
	DeviceNotSupported
}

func init() {
	t["MultiWriterNotSupported"] = reflect.TypeOf((*MultiWriterNotSupported)(nil)).Elem()
}

type MultiWriterNotSupportedFault MultiWriterNotSupported

func init() {
	t["MultiWriterNotSupportedFault"] = reflect.TypeOf((*MultiWriterNotSupportedFault)(nil)).Elem()
}

// MultipleCertificatesVerifyFault is thrown by the host connect method
// `HostSystem.ReconnectHost_Task` as well as the methods to add a host to
// VirtualCenter (`Folder.AddStandaloneHost_Task` and
// `ClusterComputeResource.AddHost_Task`) if VirtualCenter detects that the
// host has different SSL certificates for different management ports.
//
// This
// can occur, for example, if an ESX 2.x host has different SSL certificates
// for the authd service (port 902) and the Management UI port (port 443).
// VirtualCenter is not able to manage such hosts. To fix this issue, the user
// should modify the host to ensure there is only one certificate for
// all services. Alternatively, different certificates are allowed as long as each
// certificate is verifiable (trusted) by the VirtualCenter server.
type MultipleCertificatesVerifyFault struct {
	HostConnectFault

	// The thumbprints (and associated ports) used by the services on the host.
	ThumbprintData []MultipleCertificatesVerifyFaultThumbprintData `xml:"thumbprintData" json:"thumbprintData"`
}

func init() {
	t["MultipleCertificatesVerifyFault"] = reflect.TypeOf((*MultipleCertificatesVerifyFault)(nil)).Elem()
}

type MultipleCertificatesVerifyFaultFault MultipleCertificatesVerifyFault

func init() {
	t["MultipleCertificatesVerifyFaultFault"] = reflect.TypeOf((*MultipleCertificatesVerifyFaultFault)(nil)).Elem()
}

type MultipleCertificatesVerifyFaultThumbprintData struct {
	DynamicData

	// The port used by the service.
	Port int32 `xml:"port" json:"port"`
	// The SSL thumbprint of the host's certificate used by the service.
	Thumbprint string `xml:"thumbprint" json:"thumbprint"`
}

func init() {
	t["MultipleCertificatesVerifyFaultThumbprintData"] = reflect.TypeOf((*MultipleCertificatesVerifyFaultThumbprintData)(nil)).Elem()
}

// Fault thrown when an attempt is made to create a second snapshot on a VM that only
// supports a single snapshot at a time.
type MultipleSnapshotsNotSupported struct {
	SnapshotFault
}

func init() {
	t["MultipleSnapshotsNotSupported"] = reflect.TypeOf((*MultipleSnapshotsNotSupported)(nil)).Elem()
}

type MultipleSnapshotsNotSupportedFault MultipleSnapshotsNotSupported

func init() {
	t["MultipleSnapshotsNotSupportedFault"] = reflect.TypeOf((*MultipleSnapshotsNotSupportedFault)(nil)).Elem()
}

// This event records when a NAS datastore is created.
type NASDatastoreCreatedEvent struct {
	HostEvent

	// The associated datastore.
	Datastore DatastoreEventArgument `xml:"datastore" json:"datastore"`
	// Url of the associated datastore.
	DatastoreUrl string `xml:"datastoreUrl,omitempty" json:"datastoreUrl,omitempty"`
}

func init() {
	t["NASDatastoreCreatedEvent"] = reflect.TypeOf((*NASDatastoreCreatedEvent)(nil)).Elem()
}

// NamePasswordAuthentication contains the information necessary to authenticate
// within a guest using a name and password.
//
// This is the typical method for
// authentication within a guest and the one currently used by VIX.
// This method of authentication is stateless.
//
// To use NamePasswordAuthentication, populate username and password with the
// appropriate login information. You should not use `GuestAuthManager.AcquireCredentialsInGuest`
// or `GuestAuthManager.ReleaseCredentialsInGuest` for NamePasswordAuthentication.
//
// Once populated, you can use NamePasswordAuthentication in any guest operations function call.
type NamePasswordAuthentication struct {
	GuestAuthentication

	// The user name for Name-Password authentication.
	Username string `xml:"username" json:"username"`
	// The password for Name-Password authentication.
	Password string `xml:"password" json:"password"`
}

func init() {
	t["NamePasswordAuthentication"] = reflect.TypeOf((*NamePasswordAuthentication)(nil)).Elem()
}

// A NamespaceFull fault is thrown when an operation
// on namespace requires more space to complete.
type NamespaceFull struct {
	VimFault

	// The namespace in question.
	Name string `xml:"name" json:"name"`
	// Current maximum size.
	CurrentMaxSize int64 `xml:"currentMaxSize" json:"currentMaxSize"`
	// Size necessary to complete operation.
	//
	// If not present,
	// system was not able to determine how much space would
	// be necessary to complete operation.
	RequiredSize int64 `xml:"requiredSize,omitempty" json:"requiredSize,omitempty"`
}

func init() {
	t["NamespaceFull"] = reflect.TypeOf((*NamespaceFull)(nil)).Elem()
}

type NamespaceFullFault NamespaceFull

func init() {
	t["NamespaceFullFault"] = reflect.TypeOf((*NamespaceFullFault)(nil)).Elem()
}

// A NamespaceLimitReached fault is thrown when the maximum allowed
// namespaces for a virtual machine will be exceeded.
type NamespaceLimitReached struct {
	VimFault

	// Allowed maximum number of namespaces per virtual machine.
	Limit *int32 `xml:"limit" json:"limit,omitempty"`
}

func init() {
	t["NamespaceLimitReached"] = reflect.TypeOf((*NamespaceLimitReached)(nil)).Elem()
}

type NamespaceLimitReachedFault NamespaceLimitReached

func init() {
	t["NamespaceLimitReachedFault"] = reflect.TypeOf((*NamespaceLimitReachedFault)(nil)).Elem()
}

// A NamespaceWriteProtected fault is thrown when an operation
// on namespace fails because namespace is write-protected.
type NamespaceWriteProtected struct {
	VimFault

	// The namespace in question.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["NamespaceWriteProtected"] = reflect.TypeOf((*NamespaceWriteProtected)(nil)).Elem()
}

type NamespaceWriteProtectedFault NamespaceWriteProtected

func init() {
	t["NamespaceWriteProtectedFault"] = reflect.TypeOf((*NamespaceWriteProtectedFault)(nil)).Elem()
}

// Base class for all network-attached storage configuration faults.
type NasConfigFault struct {
	HostConfigFault

	// Name of the Nas datastore being configured.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["NasConfigFault"] = reflect.TypeOf((*NasConfigFault)(nil)).Elem()
}

type NasConfigFaultFault BaseNasConfigFault

func init() {
	t["NasConfigFaultFault"] = reflect.TypeOf((*NasConfigFaultFault)(nil)).Elem()
}

// This fault is thrown when an operation to configure a CIFS volume fails
// because the request exceeds the maximum allowed connections on this host
// for the specified remote path.
type NasConnectionLimitReached struct {
	NasConfigFault

	// The host that runs the NFS server.
	RemoteHost string `xml:"remoteHost" json:"remoteHost"`
	// The remote share.
	RemotePath string `xml:"remotePath" json:"remotePath"`
}

func init() {
	t["NasConnectionLimitReached"] = reflect.TypeOf((*NasConnectionLimitReached)(nil)).Elem()
}

type NasConnectionLimitReachedFault NasConnectionLimitReached

func init() {
	t["NasConnectionLimitReachedFault"] = reflect.TypeOf((*NasConnectionLimitReachedFault)(nil)).Elem()
}

// Information details about a network-attached storage
// (NAS) datastore.
type NasDatastoreInfo struct {
	DatastoreInfo

	// The NFS mount information for the datastore.
	//
	// May not
	// be available when the datastore is not accessible.
	Nas *HostNasVolume `xml:"nas,omitempty" json:"nas,omitempty"`
}

func init() {
	t["NasDatastoreInfo"] = reflect.TypeOf((*NasDatastoreInfo)(nil)).Elem()
}

// This fault is thrown when an operation to configure a CIFS volume fails
// when attempting to log on more than once with the same user name.
type NasSessionCredentialConflict struct {
	NasConfigFault

	// The host that runs the NFS server.
	RemoteHost string `xml:"remoteHost" json:"remoteHost"`
	// The remote share.
	RemotePath string `xml:"remotePath" json:"remotePath"`
	UserName   string `xml:"userName" json:"userName"`
}

func init() {
	t["NasSessionCredentialConflict"] = reflect.TypeOf((*NasSessionCredentialConflict)(nil)).Elem()
}

type NasSessionCredentialConflictFault NasSessionCredentialConflict

func init() {
	t["NasSessionCredentialConflictFault"] = reflect.TypeOf((*NasSessionCredentialConflictFault)(nil)).Elem()
}

// The `NasStorageProfile` data object represents one NAS datastore configuration.
//
// Use the `ApplyProfile.policy` list for access to configuration data
// for the NAS storage profile. Use the `ApplyProfile.property` list
// for access to subprofile configuration data, if any.
type NasStorageProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["NasStorageProfile"] = reflect.TypeOf((*NasStorageProfile)(nil)).Elem()
}

// This fault is thrown when an operation to configure a NAS datastore
// fails because the specified NFS volume is not mounted.
type NasVolumeNotMounted struct {
	NasConfigFault

	// The host that runs the NFS server.
	RemoteHost string `xml:"remoteHost" json:"remoteHost"`
	// The remote share.
	RemotePath string `xml:"remotePath" json:"remotePath"`
}

func init() {
	t["NasVolumeNotMounted"] = reflect.TypeOf((*NasVolumeNotMounted)(nil)).Elem()
}

type NasVolumeNotMountedFault NasVolumeNotMounted

func init() {
	t["NasVolumeNotMountedFault"] = reflect.TypeOf((*NasVolumeNotMountedFault)(nil)).Elem()
}

// The base class for any type of setting or configuration to which negation
// can be applied.
//
// When used in a configuration information object:
// if `NegatableExpression.negate` is true, then ~(objectValue) will be used for the
// configuration. If false, then objectValue will be used as it is.
type NegatableExpression struct {
	DynamicData

	// Whether the configuration needs to be negated or not.
	Negate *bool `xml:"negate" json:"negate,omitempty"`
}

func init() {
	t["NegatableExpression"] = reflect.TypeOf((*NegatableExpression)(nil)).Elem()
}

// This data object type describes the NetBIOS configuration of
// an operating system.
type NetBIOSConfigInfo struct {
	DynamicData

	// NetBIOS configuration mode.
	//
	// The supported values are described by
	// `NetBIOSConfigInfoMode_enum`.
	Mode string `xml:"mode" json:"mode"`
}

func init() {
	t["NetBIOSConfigInfo"] = reflect.TypeOf((*NetBIOSConfigInfo)(nil)).Elem()
}

// Dynamic Host Configuration Protocol reporting for IP version 4 and version 6.
type NetDhcpConfigInfo struct {
	DynamicData

	// IPv6 DHCP client settings.
	Ipv6 *NetDhcpConfigInfoDhcpOptions `xml:"ipv6,omitempty" json:"ipv6,omitempty"`
	// IPv4 DHCP client settings.
	Ipv4 *NetDhcpConfigInfoDhcpOptions `xml:"ipv4,omitempty" json:"ipv4,omitempty"`
}

func init() {
	t["NetDhcpConfigInfo"] = reflect.TypeOf((*NetDhcpConfigInfo)(nil)).Elem()
}

// Provides for reporting of DHCP client.
//
// This data object may be used
// at a per interface or per system scope.
type NetDhcpConfigInfoDhcpOptions struct {
	DynamicData

	// Report state of dhcp client services.
	Enable bool `xml:"enable" json:"enable"`
	// Platform specific settings for DHCP Client.
	//
	// The key part is a unique number, the value part
	// is the platform specific configuration command.
	// For example on Linux, BSD systems using the file dhclient.conf
	// output would be reported at system scope:
	// key='1', value='timeout 60;'
	// key='2', value='reboot 10;'
	// output reported at per interface scope:
	// key='1', value='prepend domain-name-servers 192.0.2.1;'
	// key='2', value='equire subnet-mask, domain-name-servers;'
	Config []KeyValue `xml:"config,omitempty" json:"config,omitempty"`
}

func init() {
	t["NetDhcpConfigInfoDhcpOptions"] = reflect.TypeOf((*NetDhcpConfigInfoDhcpOptions)(nil)).Elem()
}

// Dynamic Host Configuration Protocol Configuration for IP version 4 and version 6.
type NetDhcpConfigSpec struct {
	DynamicData

	// Configure IPv6 DHCP client settings.
	Ipv6 *NetDhcpConfigSpecDhcpOptionsSpec `xml:"ipv6,omitempty" json:"ipv6,omitempty"`
	// Configure IPv4 DHCP client settings.
	Ipv4 *NetDhcpConfigSpecDhcpOptionsSpec `xml:"ipv4,omitempty" json:"ipv4,omitempty"`
}

func init() {
	t["NetDhcpConfigSpec"] = reflect.TypeOf((*NetDhcpConfigSpec)(nil)).Elem()
}

// Provides for configuration of IPv6
type NetDhcpConfigSpecDhcpOptionsSpec struct {
	DynamicData

	// Enable or disable dhcp for IPv4.
	Enable *bool `xml:"enable" json:"enable,omitempty"`
	// Platform specific settings for DHCP Client.
	//
	// The key part is a unique number, the value part
	// is the platform specific configuration command.
	// See `NetDhcpConfigInfo` for value formatting.
	Config []KeyValue `xml:"config" json:"config"`
	// Requires one of the values from `HostConfigChangeOperation_enum`.
	Operation string `xml:"operation" json:"operation"`
}

func init() {
	t["NetDhcpConfigSpecDhcpOptionsSpec"] = reflect.TypeOf((*NetDhcpConfigSpecDhcpOptionsSpec)(nil)).Elem()
}

// Domain Name Server (DNS) Configuration Specification -
// a data object for reporting the configuration of RFC 1034 client side DNS settings.
type NetDnsConfigInfo struct {
	DynamicData

	// Indicates whether or not dynamic host control
	// protocol (DHCP) is used to configure DNS configuration.
	Dhcp bool `xml:"dhcp" json:"dhcp"`
	// The host name portion of DNS name.
	//
	// For example, "esx01" part of
	// esx01.example.com.
	HostName string `xml:"hostName" json:"hostName"`
	// The domain name portion of the DNS name.
	//
	// "example.com" part of
	// esx01.example.com.
	DomainName string `xml:"domainName" json:"domainName"`
	// The IP addresses of the DNS servers in order of use.
	//
	// IPv4 addresses are specified using
	// dotted decimal notation. For example, "192.0.2.1".
	// IPv6 addresses are 128-bit addresses represented as
	// eight fields of up to four hexadecimal digits.
	// A colon separates each field (:). For example,
	// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
	// symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	IpAddress []string `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
	// The domain in which to search for hosts, placed in order of preference.
	SearchDomain []string `xml:"searchDomain,omitempty" json:"searchDomain,omitempty"`
}

func init() {
	t["NetDnsConfigInfo"] = reflect.TypeOf((*NetDnsConfigInfo)(nil)).Elem()
}

// Domain Name Server (DNS) Configuration Specification -
// a data object for configuring the RFC 1034 client side DNS settings.
//
// TBD: remove this section, only for discussing what goes into this object.
// Place properties here that are specific to the RFC/common to all systems.
// Properties that are platform specific should go into a separate config spec.
// http://technet.microsoft.com/en-us/library/cc778792.aspx
// http://en.wikipedia.org/wiki/Microsoft\_DNS
type NetDnsConfigSpec struct {
	DynamicData

	// The flag to indicate whether or not dynamic host control
	// protocol (DHCP) will be used to set DNS configuration automatically.
	//
	// See vim.net.DhcpConfigSpec
	Dhcp *bool `xml:"dhcp" json:"dhcp,omitempty"`
	// The host name portion of DNS name.
	//
	// For example,
	// "esx01" part of esx01.example.com. The rules for forming a hostname
	// are specified in RFC 1034.
	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
	// The domain name portion of the DNS name.
	//
	// This would be the
	// "example.com" part of esx01.example.com. The rules for forming
	// a domain name are defined in RFC 1034.
	DomainName string `xml:"domainName,omitempty" json:"domainName,omitempty"`
	// Unicast IP address(s) of one or more DNS servers in order of use.
	//
	// IPv4 addresses are specified using
	// dotted decimal notation. For example, "192.0.2.1".
	// IPv6 addresses are 128-bit addresses represented as
	// eight fields of up to four hexadecimal digits.
	// A colon separates each field (:). For example,
	// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
	// symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	IpAddress []string `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
	// The domain in which to search for hosts in order of preference.
	SearchDomain []string `xml:"searchDomain,omitempty" json:"searchDomain,omitempty"`
}

func init() {
	t["NetDnsConfigSpec"] = reflect.TypeOf((*NetDnsConfigSpec)(nil)).Elem()
}

// Protocol version independent address reporting data object for network
// interfaces.
type NetIpConfigInfo struct {
	DynamicData

	// Zero, one or more manual (static) assigned IP addresses to be configured
	// on a given interface.
	IpAddress []NetIpConfigInfoIpAddress `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
	// Client side DHCP for a given interface.
	Dhcp *NetDhcpConfigInfo `xml:"dhcp,omitempty" json:"dhcp,omitempty"`
	// Enable or disable ICMPv6 router solictitation requests from a given interface
	// to acquire an IPv6 address and default gateway route from zero, one or more
	// routers on the connected network.
	//
	// If not set then ICMPv6 is not available on this system,
	// See vim.host.Network.Capabilities
	AutoConfigurationEnabled *bool `xml:"autoConfigurationEnabled" json:"autoConfigurationEnabled,omitempty"`
}

func init() {
	t["NetIpConfigInfo"] = reflect.TypeOf((*NetIpConfigInfo)(nil)).Elem()
}

// Information about a specific IP Address.
type NetIpConfigInfoIpAddress struct {
	DynamicData

	// IPv4 address is specified using dotted decimal notation.
	//
	// For example, "192.0.2.1".
	// IPv6 addresses are 128-bit addresses represented as eight fields
	// of up to four hexadecimal digits.
	// A colon separates each field (:). For example,
	// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
	// symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	IpAddress string `xml:"ipAddress" json:"ipAddress"`
	// Denotes the length of a generic Internet network address
	// prefix.
	//
	// The prefix length for IPv4 the value range is 0-32.
	// For IPv6 prefixLength is a decimal value range 0-128.
	// A value of n corresponds to an IP address mask
	// that has n contiguous 1-bits from the most significant
	// bit (MSB), with all other bits set to 0.
	// A value of zero is valid only if the calling context defines
	// it.
	PrefixLength int32 `xml:"prefixLength" json:"prefixLength"`
	// How this address was configured.
	//
	// This can be
	// one of the values from the enum IpAddressOrigin
	// See `NetIpConfigInfoIpAddressOrigin_enum` for values.
	Origin string `xml:"origin,omitempty" json:"origin,omitempty"`
	// The state of this ipAddress.
	//
	// Can be one of `NetIpConfigInfoIpAddressStatus_enum`.
	State string `xml:"state,omitempty" json:"state,omitempty"`
	// The time when will this address expire.
	//
	// Durning this time
	// `state` may change states but is still visible
	// from the network.
	Lifetime *time.Time `xml:"lifetime" json:"lifetime,omitempty"`
}

func init() {
	t["NetIpConfigInfoIpAddress"] = reflect.TypeOf((*NetIpConfigInfoIpAddress)(nil)).Elem()
}

// Internet Protocol Address Configuration for version 4 and version 6.
type NetIpConfigSpec struct {
	DynamicData

	// A set of manual (static) IP addresses to be configured on a given interface.
	IpAddress []NetIpConfigSpecIpAddressSpec `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
	// Configure client side DHCP for a given interface.
	Dhcp *NetDhcpConfigSpec `xml:"dhcp,omitempty" json:"dhcp,omitempty"`
	// Enable or disable ICMPv6 router solictitation requests from a given interface
	// to acquire an IPv6 address and default gateway route from zero, one or more
	// routers on the connected network.
	AutoConfigurationEnabled *bool `xml:"autoConfigurationEnabled" json:"autoConfigurationEnabled,omitempty"`
}

func init() {
	t["NetIpConfigSpec"] = reflect.TypeOf((*NetIpConfigSpec)(nil)).Elem()
}

// Provides for configuration of IP Addresses.
type NetIpConfigSpecIpAddressSpec struct {
	DynamicData

	// IPv4 address is specified using
	// dotted decimal notation.
	//
	// For example, "192.0.2.1".
	// IPv6 addresses are 128-bit addresses specified as
	// eight fields of up to four hexadecimal digits.
	// A colon separates each field (:). For example,
	// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
	// symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	IpAddress string `xml:"ipAddress" json:"ipAddress"`
	// Denotes the length of a generic Internet network address
	// prefix.
	//
	// The prefix length for IPv4 the value range is 0-32.
	// For IPv6 prefixLength is a decimal value range 0-128.
	// A value of n corresponds to an IP address mask
	// that has n contiguous 1-bits from the most significant
	// bit (MSB), with all other bits set to 0.
	// A value of zero is valid only if the calling context defines
	// it.
	PrefixLength int32 `xml:"prefixLength" json:"prefixLength"`
	// Requires one of: "add" and "remove" or "change"
	// See `HostConfigChangeOperation_enum`.
	Operation string `xml:"operation" json:"operation"`
}

func init() {
	t["NetIpConfigSpecIpAddressSpec"] = reflect.TypeOf((*NetIpConfigSpecIpAddressSpec)(nil)).Elem()
}

// This data object reports the IP Route Table.
type NetIpRouteConfigInfo struct {
	DynamicData

	// IP routing table for all address families.
	IpRoute []NetIpRouteConfigInfoIpRoute `xml:"ipRoute,omitempty" json:"ipRoute,omitempty"`
}

func init() {
	t["NetIpRouteConfigInfo"] = reflect.TypeOf((*NetIpRouteConfigInfo)(nil)).Elem()
}

// Next hop Gateway for a given route.
type NetIpRouteConfigInfoGateway struct {
	DynamicData

	IpAddress string `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
	Device    string `xml:"device,omitempty" json:"device,omitempty"`
}

func init() {
	t["NetIpRouteConfigInfoGateway"] = reflect.TypeOf((*NetIpRouteConfigInfoGateway)(nil)).Elem()
}

// IpRoute report an individual host, network or default destination network
// reachable through a given gateway.
type NetIpRouteConfigInfoIpRoute struct {
	DynamicData

	// IP Address of the destination IP network.
	//
	// IPv6 addresses are 128-bit addresses represented
	// as eight fields of up to four hexadecimal digits. A colon separates each
	// field (:). For example, 2001:DB8:101::230:6eff:fe04:d9ff. The address can
	// also consist of symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	Network string `xml:"network" json:"network"`
	// The prefix length.
	//
	// For IPv4 the value range is 0-31.
	// For IPv6 prefixLength is a decimal value range 0-127. The property
	// represents the number of contiguous, higher-order bits of the address that make
	// up the network portion of the IP address.
	PrefixLength int32 `xml:"prefixLength" json:"prefixLength"`
	// Where to send the packets for this route.
	Gateway NetIpRouteConfigInfoGateway `xml:"gateway" json:"gateway"`
}

func init() {
	t["NetIpRouteConfigInfoIpRoute"] = reflect.TypeOf((*NetIpRouteConfigInfoIpRoute)(nil)).Elem()
}

// Address family independent IP Route Table Configuration data object.
type NetIpRouteConfigSpec struct {
	DynamicData

	// The set of updates to apply to the routing table.
	IpRoute []NetIpRouteConfigSpecIpRouteSpec `xml:"ipRoute,omitempty" json:"ipRoute,omitempty"`
}

func init() {
	t["NetIpRouteConfigSpec"] = reflect.TypeOf((*NetIpRouteConfigSpec)(nil)).Elem()
}

// IpRoute report an individual host, network or default destination network
// reachable through a given gateway.
type NetIpRouteConfigSpecGatewaySpec struct {
	DynamicData

	IpAddress string `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
	Device    string `xml:"device,omitempty" json:"device,omitempty"`
}

func init() {
	t["NetIpRouteConfigSpecGatewaySpec"] = reflect.TypeOf((*NetIpRouteConfigSpecGatewaySpec)(nil)).Elem()
}

// Specify an individual host, network or default destination network
// reachable through a given gateway.
type NetIpRouteConfigSpecIpRouteSpec struct {
	DynamicData

	// IP Address of the destination IP network.
	//
	// IPv6 addresses are 128-bit addresses represented
	// as eight fields of up to four hexadecimal digits. A colon separates each
	// field (:). For example, 2001:DB8:101::230:6eff:fe04:d9ff. The address can
	// also consist of symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	// To Specify a default network use the value: 0 with prefixLenth 0.
	Network string `xml:"network" json:"network"`
	// The prefix length.
	//
	// For IPv4 the value range is 0-31.
	// For IPv6 prefixLength is a decimal value range 0-127. The property
	// represents the number of contiguous, higher-order bits of the address that make
	// up the network portion of the IP address.
	PrefixLength int32 `xml:"prefixLength" json:"prefixLength"`
	// Where to send the packets for this route.
	Gateway NetIpRouteConfigSpecGatewaySpec `xml:"gateway" json:"gateway"`
	// Requires one of the values from `HostConfigChangeOperation_enum`.
	Operation string `xml:"operation" json:"operation"`
}

func init() {
	t["NetIpRouteConfigSpecIpRouteSpec"] = reflect.TypeOf((*NetIpRouteConfigSpecIpRouteSpec)(nil)).Elem()
}

// Protocol version independent reporting data object for IP stack.
type NetIpStackInfo struct {
	DynamicData

	// Zero, one or more entries of neighbors discovered using ARP or NDP.
	//
	// This information is used to help diagnose connectivity or performance
	// issues. This property maps to RFC 4293 ipNetToPhysicalTable.
	Neighbor []NetIpStackInfoNetToMedia `xml:"neighbor,omitempty" json:"neighbor,omitempty"`
	// Zero one or more entries of discovered IP routers that are directly
	// reachable from a an interface on this system.
	//
	// This property maps to RFC 4293 ipDefaultRouterTable.
	DefaultRouter []NetIpStackInfoDefaultRouter `xml:"defaultRouter,omitempty" json:"defaultRouter,omitempty"`
}

func init() {
	t["NetIpStackInfo"] = reflect.TypeOf((*NetIpStackInfo)(nil)).Elem()
}

type NetIpStackInfoDefaultRouter struct {
	DynamicData

	// Unicast IP address of a next-hop router.
	IpAddress string `xml:"ipAddress" json:"ipAddress"`
	// This value will contain the name of the interface as reported by the
	// operationg system.
	Device string `xml:"device" json:"device"`
	// When this entry will no longer valid.
	//
	// For IPv6 this value
	// see For IPv6 RFC 2462 sections 4.2 and 6.3.4.
	Lifetime time.Time `xml:"lifetime" json:"lifetime"`
	// Value of this entry compared to others that this IP stack uses
	// when making selection to route traffic on the default
	// route when there are multiple default routers.
	//
	// Value must be one of
	// `NetIpStackInfoPreference_enum`
	Preference string `xml:"preference" json:"preference"`
}

func init() {
	t["NetIpStackInfoDefaultRouter"] = reflect.TypeOf((*NetIpStackInfoDefaultRouter)(nil)).Elem()
}

// Information from an IP stack about known mappings betwwen an IP address
// and the underlying physical address it maps to as learned by:
// IPv4: Address Resolution Protocol (ARP) RFC 826
// IPv6: Neighbor Discovery Protocol (NDP) RFC 4861
type NetIpStackInfoNetToMedia struct {
	DynamicData

	// A Unicast IP address of another system directly reachable w/o routing.
	//
	// IPv4 address is specified using dotted decimal notation.
	// For example, "192.0.2.1".
	// IPv6 addresses are 128-bit addresses represented as eight fields
	// of up to four hexadecimal digits.
	// A colon separates each field (:). For example,
	// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
	// symbol '::' to represent multiple 16-bit groups of
	// contiguous 0's only once in an address as described in RFC 2373.
	IpAddress string `xml:"ipAddress" json:"ipAddress"`
	// The media-dependent of the address or empty string if not yet learned.
	//
	// For Ethernet interfaces this is a MAC address reported in the format:
	// XX:XX:XX:XX:XX:XX where XX are hexadecimal numbers.
	PhysicalAddress string `xml:"physicalAddress" json:"physicalAddress"`
	// The value will be the name of the interface as reported by the
	// operating system.
	Device string `xml:"device" json:"device"`
	// The type/state of this entry as reported by the IP stack.
	//
	// See `NetIpStackInfoEntryType_enum` for values.
	Type string `xml:"type" json:"type"`
}

func init() {
	t["NetIpStackInfoNetToMedia"] = reflect.TypeOf((*NetIpStackInfoNetToMedia)(nil)).Elem()
}

// The `NetStackInstanceProfile` data object represents a subprofile
// for a netStackInstance.
type NetStackInstanceProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
	// DnsConfig SubProfile for this instance of the stack.
	DnsConfig NetworkProfileDnsConfigProfile `xml:"dnsConfig" json:"dnsConfig"`
	// IpRoute SubProfile for this instance of the stack.
	IpRouteConfig IpRouteProfile `xml:"ipRouteConfig" json:"ipRouteConfig"`
}

func init() {
	t["NetStackInstanceProfile"] = reflect.TypeOf((*NetStackInstanceProfile)(nil)).Elem()
}

// A network copy of the file failed.
type NetworkCopyFault struct {
	FileFault
}

func init() {
	t["NetworkCopyFault"] = reflect.TypeOf((*NetworkCopyFault)(nil)).Elem()
}

type NetworkCopyFaultFault NetworkCopyFault

func init() {
	t["NetworkCopyFaultFault"] = reflect.TypeOf((*NetworkCopyFaultFault)(nil)).Elem()
}

// Thrown if network configuration change disconnected the host from vCenter server
// and has been rolled back.
type NetworkDisruptedAndConfigRolledBack struct {
	VimFault

	// The name of host on which the network configuration was rolled back.
	Host string `xml:"host" json:"host"`
}

func init() {
	t["NetworkDisruptedAndConfigRolledBack"] = reflect.TypeOf((*NetworkDisruptedAndConfigRolledBack)(nil)).Elem()
}

type NetworkDisruptedAndConfigRolledBackFault NetworkDisruptedAndConfigRolledBack

func init() {
	t["NetworkDisruptedAndConfigRolledBackFault"] = reflect.TypeOf((*NetworkDisruptedAndConfigRolledBackFault)(nil)).Elem()
}

// The event argument is a Network object.
type NetworkEventArgument struct {
	EntityEventArgument

	// The Network object.
	//
	// Refers instance of `Network`.
	Network ManagedObjectReference `xml:"network" json:"network"`
}

func init() {
	t["NetworkEventArgument"] = reflect.TypeOf((*NetworkEventArgument)(nil)).Elem()
}

// This fault is thrown when an operation to configure a NAS volume fails
// because network access is unavailable.
type NetworkInaccessible struct {
	NasConfigFault
}

func init() {
	t["NetworkInaccessible"] = reflect.TypeOf((*NetworkInaccessible)(nil)).Elem()
}

type NetworkInaccessibleFault NetworkInaccessible

func init() {
	t["NetworkInaccessibleFault"] = reflect.TypeOf((*NetworkInaccessibleFault)(nil)).Elem()
}

// The `NetworkPolicyProfile` data object represents a
// network policy.
//
// The `ApplyProfile.policy` property
// contains network configuration data values.
type NetworkPolicyProfile struct {
	ApplyProfile
}

func init() {
	t["NetworkPolicyProfile"] = reflect.TypeOf((*NetworkPolicyProfile)(nil)).Elem()
}

// The `NetworkProfile` data object contains a set of subprofiles for
// network configuration.
type NetworkProfile struct {
	ApplyProfile

	// List of virtual switch subprofiles.
	//
	// Use the `VirtualSwitchProfile.key` property to access
	// a subprofile in the list.
	Vswitch []VirtualSwitchProfile `xml:"vswitch,omitempty" json:"vswitch,omitempty"`
	// List of port groups for use by virtual machines.
	//
	// Use the `VmPortGroupProfile*.*PortGroupProfile.key`
	// property to access a port group in the list.
	VmPortGroup []VmPortGroupProfile `xml:"vmPortGroup,omitempty" json:"vmPortGroup,omitempty"`
	// List of port groups for use by the host.
	//
	// Use the `HostPortGroupProfile*.*PortGroupProfile.key` property
	// to access port groups in the list.
	HostPortGroup []HostPortGroupProfile `xml:"hostPortGroup,omitempty" json:"hostPortGroup,omitempty"`
	// List of port groups for use by the service console.
	//
	// The Profile Engine uses this field only when applying a profile
	// to a host that has a service console.
	ServiceConsolePortGroup []ServiceConsolePortGroupProfile `xml:"serviceConsolePortGroup,omitempty" json:"serviceConsolePortGroup,omitempty"`
	// DNS (Domain Name System) configuration subprofile.
	DnsConfig *NetworkProfileDnsConfigProfile `xml:"dnsConfig,omitempty" json:"dnsConfig,omitempty"`
	// Subprofile that describes the IP Route
	// configuration for the VMKernel gateway.
	IpRouteConfig *IpRouteProfile `xml:"ipRouteConfig,omitempty" json:"ipRouteConfig,omitempty"`
	// Subprofile that describes the IP Route configuration
	// for the Service Console gateway.
	ConsoleIpRouteConfig *IpRouteProfile `xml:"consoleIpRouteConfig,omitempty" json:"consoleIpRouteConfig,omitempty"`
	// List of subprofiles that represent physical NIC configuration.
	//
	// Use the `PhysicalNicProfile.key` property to access a
	// subprofile in the list.
	Pnic []PhysicalNicProfile `xml:"pnic,omitempty" json:"pnic,omitempty"`
	// List of subprofiles for distributed virtual switches to which this host is connected.
	//
	// Use the `DvsProfile.key` property to access a subprofile in the list.
	Dvswitch []DvsProfile `xml:"dvswitch,omitempty" json:"dvswitch,omitempty"`
	// List of subprofiles for service console Virtual NICs connected to a distributed virtual switch.
	//
	// Use the `DvsServiceConsoleVNicProfile*.*DvsVNicProfile.key` property
	// to access a subprofile in the list.
	DvsServiceConsoleNic []DvsServiceConsoleVNicProfile `xml:"dvsServiceConsoleNic,omitempty" json:"dvsServiceConsoleNic,omitempty"`
	// List of subprofiles for host Virtual NICs connected to a distributed virtual switch.
	//
	// Use the `DvsHostVNicProfile*.*DvsVNicProfile.key` property
	// to access a subprofile in the list.
	DvsHostNic []DvsHostVNicProfile `xml:"dvsHostNic,omitempty" json:"dvsHostNic,omitempty"`
	// List of subprofiles for host Virtual NICs connected to a NSX logic switch.
	//
	// Use the `NsxHostVNicProfile*.*NsxHostVNicProfile.key` property
	// to access a subprofile in the list.
	NsxHostNic []NsxHostVNicProfile `xml:"nsxHostNic,omitempty" json:"nsxHostNic,omitempty"`
	// List of NetStackInstance subprofiles.
	//
	// Use the `NetStackInstanceProfile.key` property to access
	// a subprofile in the list.
	NetStackInstance []NetStackInstanceProfile `xml:"netStackInstance,omitempty" json:"netStackInstance,omitempty"`
	// OpaqueSwitch subprofile.
	OpaqueSwitch *OpaqueSwitchProfile `xml:"opaqueSwitch,omitempty" json:"opaqueSwitch,omitempty"`
}

func init() {
	t["NetworkProfile"] = reflect.TypeOf((*NetworkProfile)(nil)).Elem()
}

// The `NetworkProfileDnsConfigProfile` data object represents DNS configuration
// for the host.
//
// Use the `ApplyProfile.policy` list for
// access to configuration data for the DNS profile. Use the
// `ApplyProfile.property` list for access to subprofiles, if any.
type NetworkProfileDnsConfigProfile struct {
	ApplyProfile
}

func init() {
	t["NetworkProfileDnsConfigProfile"] = reflect.TypeOf((*NetworkProfileDnsConfigProfile)(nil)).Elem()
}

// This event records when networking configuration on the host
// is rolled back as it disconnects the host from vCenter server.
type NetworkRollbackEvent struct {
	Event

	// Method name which caused the disconnect
	MethodName string `xml:"methodName" json:"methodName"`
	// Transaction ID for the method call that caused the disconnect
	TransactionId string `xml:"transactionId" json:"transactionId"`
}

func init() {
	t["NetworkRollbackEvent"] = reflect.TypeOf((*NetworkRollbackEvent)(nil)).Elem()
}

// General information about a network.
type NetworkSummary struct {
	DynamicData

	// Reference to the associated managed object.
	//
	// Refers instance of `Network`.
	Network *ManagedObjectReference `xml:"network,omitempty" json:"network,omitempty"`
	// Name of the network.
	Name string `xml:"name" json:"name"`
	// At least one host is configured to provide this network.
	Accessible bool `xml:"accessible" json:"accessible"`
	// Name of the associated IP pool.
	//
	// Empty if the network is not associated with an
	// IP pool.
	IpPoolName string `xml:"ipPoolName" json:"ipPoolName"`
	// Identifier of the associated IP pool.
	//
	// Zero if the network is not associated
	// with an IP pool.
	IpPoolId *int32 `xml:"ipPoolId" json:"ipPoolId,omitempty"`
}

func init() {
	t["NetworkSummary"] = reflect.TypeOf((*NetworkSummary)(nil)).Elem()
}

// Used as a warning if a virtual machine provisioning operation is done
// across datacenters.
//
// This warns that the network used by the virtual
// machine before and after the operation may not be the same even though
// the two networks have the same name. This is because network names
// are only unique within a datacenter.
type NetworksMayNotBeTheSame struct {
	MigrationFault

	// The name of the network.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
}

func init() {
	t["NetworksMayNotBeTheSame"] = reflect.TypeOf((*NetworksMayNotBeTheSame)(nil)).Elem()
}

type NetworksMayNotBeTheSameFault NetworksMayNotBeTheSame

func init() {
	t["NetworksMayNotBeTheSameFault"] = reflect.TypeOf((*NetworksMayNotBeTheSameFault)(nil)).Elem()
}

// The number of network adapter settings in the customization specification
// does not match the number of network adapters present in the virtual machine.
type NicSettingMismatch struct {
	CustomizationFault

	// The number of network adapter settings specified in the customization
	// specification.
	NumberOfNicsInSpec int32 `xml:"numberOfNicsInSpec" json:"numberOfNicsInSpec"`
	// The number of network adapters present in the virtual machine.
	NumberOfNicsInVM int32 `xml:"numberOfNicsInVM" json:"numberOfNicsInVM"`
}

func init() {
	t["NicSettingMismatch"] = reflect.TypeOf((*NicSettingMismatch)(nil)).Elem()
}

type NicSettingMismatchFault NicSettingMismatch

func init() {
	t["NicSettingMismatchFault"] = reflect.TypeOf((*NicSettingMismatchFault)(nil)).Elem()
}

// This event records a failed user logon due to insufficient access permission.
type NoAccessUserEvent struct {
	SessionEvent

	// The IP address of the peer that initiated the connection.
	//
	// This may
	// be the client that originated the session, or it may be an intervening
	// proxy if the binding uses a protocol that supports proxies, such as HTTP.
	IpAddress string `xml:"ipAddress" json:"ipAddress"`
}

func init() {
	t["NoAccessUserEvent"] = reflect.TypeOf((*NoAccessUserEvent)(nil)).Elem()
}

// A NoActiveHostInCluster fault is thrown when there is no host in a valid
// state in the given compute resource to perform a specified operation.
//
// This
// can happen, for example, if all the hosts are disconnected or in maintenance
// mode.
type NoActiveHostInCluster struct {
	InvalidState

	// The compute resource that does not have any active hosts.
	//
	// Refers instance of `ComputeResource`.
	ComputeResource ManagedObjectReference `xml:"computeResource" json:"computeResource"`
}

func init() {
	t["NoActiveHostInCluster"] = reflect.TypeOf((*NoActiveHostInCluster)(nil)).Elem()
}

type NoActiveHostInClusterFault NoActiveHostInCluster

func init() {
	t["NoActiveHostInClusterFault"] = reflect.TypeOf((*NoActiveHostInClusterFault)(nil)).Elem()
}

// There are no more IP addresses available on the given network.
type NoAvailableIp struct {
	VAppPropertyFault

	// A reference to the network
	//
	// Refers instance of `Network`.
	Network ManagedObjectReference `xml:"network" json:"network"`
}

func init() {
	t["NoAvailableIp"] = reflect.TypeOf((*NoAvailableIp)(nil)).Elem()
}

type NoAvailableIpFault NoAvailableIp

func init() {
	t["NoAvailableIpFault"] = reflect.TypeOf((*NoAvailableIpFault)(nil)).Elem()
}

// This exception is thrown when a client has connected without supplying a
// certificate but the associated call expects that the client has done so.
type NoClientCertificate struct {
	VimFault
}

func init() {
	t["NoClientCertificate"] = reflect.TypeOf((*NoClientCertificate)(nil)).Elem()
}

type NoClientCertificateFault NoClientCertificate

func init() {
	t["NoClientCertificateFault"] = reflect.TypeOf((*NoClientCertificateFault)(nil)).Elem()
}

// A NoCompatibleDatastore fault is thrown when Storage DRS cannot find a compatible
// datastore in a given storage pod to place a disk or a virtual machine.
//
// a virtual machine.
type NoCompatibleDatastore struct {
	VimFault
}

func init() {
	t["NoCompatibleDatastore"] = reflect.TypeOf((*NoCompatibleDatastore)(nil)).Elem()
}

type NoCompatibleDatastoreFault NoCompatibleDatastore

func init() {
	t["NoCompatibleDatastoreFault"] = reflect.TypeOf((*NoCompatibleDatastoreFault)(nil)).Elem()
}

// The cluster contains no hosts satisfying the hard VM/host affinity rules
// constraint for the VM.
type NoCompatibleHardAffinityHost struct {
	VmConfigFault

	// The vm for which there are no compatible hard-affine hosts in the cluster.
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["NoCompatibleHardAffinityHost"] = reflect.TypeOf((*NoCompatibleHardAffinityHost)(nil)).Elem()
}

type NoCompatibleHardAffinityHostFault NoCompatibleHardAffinityHost

func init() {
	t["NoCompatibleHardAffinityHostFault"] = reflect.TypeOf((*NoCompatibleHardAffinityHostFault)(nil)).Elem()
}

// A NoCompatibleHost fault is thrown when DRS cannot find a compatible
// host in a given compute resource to run a virtual machine on.
type NoCompatibleHost struct {
	VimFault

	// The list of hosts that are not compatible, each element has a
	// corresponding fault in the error array.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// An error in this array indicates why the corresponding host in the
	// host array is incompatible.
	Error []LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
}

func init() {
	t["NoCompatibleHost"] = reflect.TypeOf((*NoCompatibleHost)(nil)).Elem()
}

type NoCompatibleHostFault BaseNoCompatibleHost

func init() {
	t["NoCompatibleHostFault"] = reflect.TypeOf((*NoCompatibleHostFault)(nil)).Elem()
}

// This fault is used to report that a FT VM cannot be placed because there is
// no compatible host that can access all devices required to be connected when
// the VM powers on.
type NoCompatibleHostWithAccessToDevice struct {
	NoCompatibleHost
}

func init() {
	t["NoCompatibleHostWithAccessToDevice"] = reflect.TypeOf((*NoCompatibleHostWithAccessToDevice)(nil)).Elem()
}

type NoCompatibleHostWithAccessToDeviceFault NoCompatibleHostWithAccessToDevice

func init() {
	t["NoCompatibleHostWithAccessToDeviceFault"] = reflect.TypeOf((*NoCompatibleHostWithAccessToDeviceFault)(nil)).Elem()
}

// The cluster contains no hosts satisfying the soft VM/host affinity rules
// constraint for the VM.
type NoCompatibleSoftAffinityHost struct {
	VmConfigFault

	// The vm for which there are no compatible soft-affine hosts in the cluster.
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["NoCompatibleSoftAffinityHost"] = reflect.TypeOf((*NoCompatibleSoftAffinityHost)(nil)).Elem()
}

type NoCompatibleSoftAffinityHostFault NoCompatibleSoftAffinityHost

func init() {
	t["NoCompatibleSoftAffinityHostFault"] = reflect.TypeOf((*NoCompatibleSoftAffinityHostFault)(nil)).Elem()
}

// The fault occurs when Storage DRS cannot move a virtual machine because
// the host it is registered on is not connected to any other datastore
// in the storage pod.
type NoConnectedDatastore struct {
	VimFault
}

func init() {
	t["NoConnectedDatastore"] = reflect.TypeOf((*NoConnectedDatastore)(nil)).Elem()
}

type NoConnectedDatastoreFault NoConnectedDatastore

func init() {
	t["NoConnectedDatastoreFault"] = reflect.TypeOf((*NoConnectedDatastoreFault)(nil)).Elem()
}

// No datastores have been configured on the host.
type NoDatastoresConfiguredEvent struct {
	HostEvent
}

func init() {
	t["NoDatastoresConfiguredEvent"] = reflect.TypeOf((*NoDatastoresConfiguredEvent)(nil)).Elem()
}

// This exception is thrown when a virtual machine
// which has no virtual disks is being upgraded or relaid out
// using the VirtualMachine.upgradeVirtualHardware or upgradeVmLayout
// commands.
type NoDiskFound struct {
	VimFault
}

func init() {
	t["NoDiskFound"] = reflect.TypeOf((*NoDiskFound)(nil)).Elem()
}

type NoDiskFoundFault NoDiskFound

func init() {
	t["NoDiskFoundFault"] = reflect.TypeOf((*NoDiskFoundFault)(nil)).Elem()
}

// This fault is thrown when an operation fails because of insufficient
// disk space.
type NoDiskSpace struct {
	FileFault

	// The name of the datastore with insufficient disk space.
	Datastore string `xml:"datastore" json:"datastore"`
}

func init() {
	t["NoDiskSpace"] = reflect.TypeOf((*NoDiskSpace)(nil)).Elem()
}

type NoDiskSpaceFault NoDiskSpace

func init() {
	t["NoDiskSpaceFault"] = reflect.TypeOf((*NoDiskSpaceFault)(nil)).Elem()
}

// None of the disks attached to the VM are suitable for customization.
type NoDisksToCustomize struct {
	CustomizationFault
}

func init() {
	t["NoDisksToCustomize"] = reflect.TypeOf((*NoDisksToCustomize)(nil)).Elem()
}

type NoDisksToCustomizeFault NoDisksToCustomize

func init() {
	t["NoDisksToCustomizeFault"] = reflect.TypeOf((*NoDisksToCustomizeFault)(nil)).Elem()
}

// This error occurs when an operation fails because of vmkernel gateway
// is unset.
type NoGateway struct {
	HostConfigFault
}

func init() {
	t["NoGateway"] = reflect.TypeOf((*NoGateway)(nil)).Elem()
}

type NoGatewayFault NoGateway

func init() {
	t["NoGatewayFault"] = reflect.TypeOf((*NoGatewayFault)(nil)).Elem()
}

// A powered-on virtual machine has a guest OS with Tools installed, but it does not
// have a valid heartbeat.
type NoGuestHeartbeat struct {
	MigrationFault
}

func init() {
	t["NoGuestHeartbeat"] = reflect.TypeOf((*NoGuestHeartbeat)(nil)).Elem()
}

type NoGuestHeartbeatFault NoGuestHeartbeat

func init() {
	t["NoGuestHeartbeatFault"] = reflect.TypeOf((*NoGuestHeartbeatFault)(nil)).Elem()
}

// A NoHostFault fault occurs when a host
// cannot be reached.
type NoHost struct {
	HostConnectFault

	Name string `xml:"name,omitempty" json:"name,omitempty"`
}

func init() {
	t["NoHost"] = reflect.TypeOf((*NoHost)(nil)).Elem()
}

type NoHostFault NoHost

func init() {
	t["NoHostFault"] = reflect.TypeOf((*NoHostFault)(nil)).Elem()
}

// The NoHostSuitableForFtSecondary fault is thrown when the system is unable to
// find a suitable host for the Fault Tolerance secondary virtual machine.
//
// This fault can be thrown when Virtual Center is trying to place or power on
// a Fault Tolerance Secondary, in both DRS or non-DRS cases.
type NoHostSuitableForFtSecondary struct {
	VmFaultToleranceIssue

	// The primary virtual machine corresponding to the secondary virtual
	// machine.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The name of the primary virtual machine corresponding to the secondary
	// virtual machine.
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["NoHostSuitableForFtSecondary"] = reflect.TypeOf((*NoHostSuitableForFtSecondary)(nil)).Elem()
}

type NoHostSuitableForFtSecondaryFault NoHostSuitableForFtSecondary

func init() {
	t["NoHostSuitableForFtSecondaryFault"] = reflect.TypeOf((*NoHostSuitableForFtSecondaryFault)(nil)).Elem()
}

// These are events reported by License Manager.
//
// A NoLicenseEvent is reported if the required licenses could not be
// reserved. Each feature that is not fully licensed is reported.
type NoLicenseEvent struct {
	LicenseEvent

	Feature LicenseFeatureInfo `xml:"feature" json:"feature"`
}

func init() {
	t["NoLicenseEvent"] = reflect.TypeOf((*NoLicenseEvent)(nil)).Elem()
}

// The NoLicenseServerConfigured fault is thrown when there is no
// valid license server configured for the system and the system
// is not in evaluation mode.
//
// Any operation occurs that requires
// evaluation license or a valid license will throw the
// NoLicenseServerConfigured. This can happen with the new licensing
// scheme that is a hybrid of flex-based licensing and serial number
// based licensing. There can be cases where VirtualCenter is licensed
// by a serial number and there is no need for a flex license server.
// These cases are valid as long as no operation that requires flex-
// based license server is invoked, for example, adding a pre-4.0
// host that requires flex licenses. If however, such an operation is
// invoked, the NoLicenseServerConfigured fault is thrown.
type NoLicenseServerConfigured struct {
	NotEnoughLicenses
}

func init() {
	t["NoLicenseServerConfigured"] = reflect.TypeOf((*NoLicenseServerConfigured)(nil)).Elem()
}

type NoLicenseServerConfiguredFault NoLicenseServerConfigured

func init() {
	t["NoLicenseServerConfiguredFault"] = reflect.TypeOf((*NoLicenseServerConfiguredFault)(nil)).Elem()
}

// This event records that DRS did not recommend a migration for a
// powered on virtual machine, even though its host is going
// into maintenance mode.
//
// DRS may not be able to recommend a migration for a virtual machine
// for reasons, include but not limited to:
//   - No other connected host is compatible with this virtual machine.
//   - None of the other compatible hosts have sufficient resources
//     to satisfy the reservation requirements of this virtual machine.
//   - Moving to any other host would violate a DRS rule. For example, all
//     other compatible hosts have some incompatible virtual machines
//     running.
//   - DRS is disabled on this virtual machine.
//   - This virtual machine was still in the process of migrating
//     into the host going into maintenance mode and was not
//     considered by DRS.
//   - This virtual machine was in the process of migrating to another
//     host when the host tried to enter maintenance mode.
type NoMaintenanceModeDrsRecommendationForVM struct {
	VmEvent
}

func init() {
	t["NoMaintenanceModeDrsRecommendationForVM"] = reflect.TypeOf((*NoMaintenanceModeDrsRecommendationForVM)(nil)).Elem()
}

// This fault is thrown when no peer host is found to wake up this host.
type NoPeerHostFound struct {
	HostPowerOpFailed
}

func init() {
	t["NoPeerHostFound"] = reflect.TypeOf((*NoPeerHostFound)(nil)).Elem()
}

type NoPeerHostFoundFault NoPeerHostFound

func init() {
	t["NoPeerHostFoundFault"] = reflect.TypeOf((*NoPeerHostFoundFault)(nil)).Elem()
}

// Thrown when an operation is denied because of privileges
// not held on managed object(s).
type NoPermission struct {
	SecurityError

	// Deprecated as of vSphere 8.0, use the `NoPermission.missingPrivileges` field.
	//
	// The managed object on which a permission is required.
	Object *ManagedObjectReference `xml:"object,omitempty" json:"object,omitempty"`
	// Deprecated as of vSphere 8.0, use the `NoPermission.missingPrivileges` field.
	//
	// The privilege identifier required
	PrivilegeId string `xml:"privilegeId,omitempty" json:"privilegeId,omitempty"`
	// List of entities and missing privileges for each entity
	MissingPrivileges []NoPermissionEntityPrivileges `xml:"missingPrivileges,omitempty" json:"missingPrivileges,omitempty" vim:"7.0.3.2"`
}

func init() {
	t["NoPermission"] = reflect.TypeOf((*NoPermission)(nil)).Elem()
}

// Entity and privileges for the entity
type NoPermissionEntityPrivileges struct {
	DynamicData

	Entity       ManagedObjectReference `xml:"entity" json:"entity"`
	PrivilegeIds []string               `xml:"privilegeIds,omitempty" json:"privilegeIds,omitempty"`
}

func init() {
	t["NoPermissionEntityPrivileges"] = reflect.TypeOf((*NoPermissionEntityPrivileges)(nil)).Elem()
	minAPIVersionForType["NoPermissionEntityPrivileges"] = "7.0.3.2"
}

type NoPermissionFault BaseNoPermission

func init() {
	t["NoPermissionFault"] = reflect.TypeOf((*NoPermissionFault)(nil)).Elem()
}

// Fault indicating that the user account used to connect to the
// Active Directory doesn not have enough permissions for the action
// that was attempted.
type NoPermissionOnAD struct {
	ActiveDirectoryFault
}

func init() {
	t["NoPermissionOnAD"] = reflect.TypeOf((*NoPermissionOnAD)(nil)).Elem()
}

type NoPermissionOnADFault NoPermissionOnAD

func init() {
	t["NoPermissionOnADFault"] = reflect.TypeOf((*NoPermissionOnADFault)(nil)).Elem()
}

// This indicates that the user account used to connect to the host does
// not have enough permissions to enable VirtualCenter to manage the host.
type NoPermissionOnHost struct {
	HostConnectFault
}

func init() {
	t["NoPermissionOnHost"] = reflect.TypeOf((*NoPermissionOnHost)(nil)).Elem()
}

type NoPermissionOnHostFault NoPermissionOnHost

func init() {
	t["NoPermissionOnHostFault"] = reflect.TypeOf((*NoPermissionOnHostFault)(nil)).Elem()
}

// This fault is thrown when an operation to configure a NAS volume fails
// because of insufficient user permissions.
//
// For CIFS volumes, this implies that the user specified in the
// `spec` does not have access to the
// network resource.
type NoPermissionOnNasVolume struct {
	NasConfigFault

	UserName string `xml:"userName,omitempty" json:"userName,omitempty"`
}

func init() {
	t["NoPermissionOnNasVolume"] = reflect.TypeOf((*NoPermissionOnNasVolume)(nil)).Elem()
}

type NoPermissionOnNasVolumeFault NoPermissionOnNasVolume

func init() {
	t["NoPermissionOnNasVolumeFault"] = reflect.TypeOf((*NoPermissionOnNasVolumeFault)(nil)).Elem()
}

// This exception is thrown when an extension has attempted to use certificate-based
// authentication but the extension has been registered without a subject name.
type NoSubjectName struct {
	VimFault
}

func init() {
	t["NoSubjectName"] = reflect.TypeOf((*NoSubjectName)(nil)).Elem()
}

type NoSubjectNameFault NoSubjectName

func init() {
	t["NoSubjectNameFault"] = reflect.TypeOf((*NoSubjectNameFault)(nil)).Elem()
}

// The IP address of the VC server has not be configured, and a vApp
// property is requesting to use it.
type NoVcManagedIpConfigured struct {
	VAppPropertyFault
}

func init() {
	t["NoVcManagedIpConfigured"] = reflect.TypeOf((*NoVcManagedIpConfigured)(nil)).Elem()
}

type NoVcManagedIpConfiguredFault NoVcManagedIpConfigured

func init() {
	t["NoVcManagedIpConfiguredFault"] = reflect.TypeOf((*NoVcManagedIpConfiguredFault)(nil)).Elem()
}

// This error occurs when an operation fails because of
// no virtual NIC available.
type NoVirtualNic struct {
	HostConfigFault
}

func init() {
	t["NoVirtualNic"] = reflect.TypeOf((*NoVirtualNic)(nil)).Elem()
}

type NoVirtualNicFault NoVirtualNic

func init() {
	t["NoVirtualNicFault"] = reflect.TypeOf((*NoVirtualNicFault)(nil)).Elem()
}

// Attempting to power-on or power-off a vApp that contains no
// virtual machines.
type NoVmInVApp struct {
	VAppConfigFault
}

func init() {
	t["NoVmInVApp"] = reflect.TypeOf((*NoVmInVApp)(nil)).Elem()
}

type NoVmInVAppFault NoVmInVApp

func init() {
	t["NoVmInVAppFault"] = reflect.TypeOf((*NoVmInVAppFault)(nil)).Elem()
}

// The NodeDeploymentSpec class defines location
// specification of the nodes the VCHA Cluster along with Management
// vCenter Server information that manages node VM.
type NodeDeploymentSpec struct {
	DynamicData

	// ESX host on which the VM is to be deployed.
	//
	// For behavior when an esxHost is not specified,
	//
	// See also `VirtualMachineRelocateSpec.host`.
	//
	// Refers instance of `HostSystem`.
	EsxHost *ManagedObjectReference `xml:"esxHost,omitempty" json:"esxHost,omitempty"`
	// Datastore used for deploying the VM.
	//
	// For behavior when a datastore is not specified,
	//
	// See also `VirtualMachineRelocateSpec.datastore`.
	//
	// Refers instance of `Datastore`.
	Datastore *ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty"`
	// Name of the portgroup that is associated with the public IP address
	// where clients connect to vCenter Server.
	//
	// If a portgroup is not
	// specified same portgroup present on source is used to deploy the VM
	// with an assumption that portgroup is present on destination.
	//
	// Refers instance of `Network`.
	PublicNetworkPortGroup *ManagedObjectReference `xml:"publicNetworkPortGroup,omitempty" json:"publicNetworkPortGroup,omitempty"`
	// Name of the portgroup that is associated with the VCHA Cluster IP
	// address where clients connect to vCenter Server.
	//
	// If a portgroup is not
	// specified same portgroup present on source is used to deploy the VM
	// with an assumption that portgroup is present on destination.
	//
	// Refers instance of `Network`.
	ClusterNetworkPortGroup *ManagedObjectReference `xml:"clusterNetworkPortGroup,omitempty" json:"clusterNetworkPortGroup,omitempty"`
	// Folder in which the VM is to be created.
	//
	// Refers instance of `Folder`.
	Folder ManagedObjectReference `xml:"folder" json:"folder"`
	// ResourcePool that will be used to deploy this node.
	//
	// If the ResourcePool is not specified, the root resource pool for the
	// host will be used.
	//
	// Refers instance of `ResourcePool`.
	ResourcePool *ManagedObjectReference `xml:"resourcePool,omitempty" json:"resourcePool,omitempty"`
	// Management vCenter Server managing this VM.
	//
	// If the managementVc is not specified, managementVc specified as
	// part of SourceNodeSpec is used.
	ManagementVc *ServiceLocator `xml:"managementVc,omitempty" json:"managementVc,omitempty"`
	// nodeName here refers to a name that will be assigned to the VM to which
	// this node will be deployed to.
	NodeName string `xml:"nodeName" json:"nodeName"`
	// VCHA Cluster network configuration of the node.
	//
	// All cluster communication (state replication, heartbeat,
	// cluster messages) happens over this network.
	IpSettings CustomizationIPSettings `xml:"ipSettings" json:"ipSettings"`
}

func init() {
	t["NodeDeploymentSpec"] = reflect.TypeOf((*NodeDeploymentSpec)(nil)).Elem()
}

// The NodeNetworkSpec class defines network specification of a node
// in the VCHA Cluster.
type NodeNetworkSpec struct {
	DynamicData

	// VCHA Cluster network configuration of the node.
	//
	// All cluster communication (state replication, heartbeat,
	// cluster messages) happens over this network.
	IpSettings CustomizationIPSettings `xml:"ipSettings" json:"ipSettings"`
}

func init() {
	t["NodeNetworkSpec"] = reflect.TypeOf((*NodeNetworkSpec)(nil)).Elem()
}

// Fault indicating that an operation must be executed by a
// non Active Directory user.
type NonADUserRequired struct {
	ActiveDirectoryFault
}

func init() {
	t["NonADUserRequired"] = reflect.TypeOf((*NonADUserRequired)(nil)).Elem()
}

type NonADUserRequiredFault NonADUserRequired

func init() {
	t["NonADUserRequiredFault"] = reflect.TypeOf((*NonADUserRequiredFault)(nil)).Elem()
}

// An operation on a powered-on virtual machine requests that an existing
// Raw Disk Mapping end up in a location other than the new home datastore
// for the virtual machine, but the host does not have that capability.
type NonHomeRDMVMotionNotSupported struct {
	MigrationFeatureNotSupported

	// The label of an RDM device for which an unsupported move was requested.
	//
	// This is not guaranteed to be the only such device.
	Device string `xml:"device" json:"device"`
}

func init() {
	t["NonHomeRDMVMotionNotSupported"] = reflect.TypeOf((*NonHomeRDMVMotionNotSupported)(nil)).Elem()
}

type NonHomeRDMVMotionNotSupportedFault NonHomeRDMVMotionNotSupported

func init() {
	t["NonHomeRDMVMotionNotSupportedFault"] = reflect.TypeOf((*NonHomeRDMVMotionNotSupportedFault)(nil)).Elem()
}

// The virtual machine has nonpersistent virtual disk.
//
// This is an error for
// any powered-on migration which involves moving virtual disks.
type NonPersistentDisksNotSupported struct {
	DeviceNotSupported
}

func init() {
	t["NonPersistentDisksNotSupported"] = reflect.TypeOf((*NonPersistentDisksNotSupported)(nil)).Elem()
}

type NonPersistentDisksNotSupportedFault NonPersistentDisksNotSupported

func init() {
	t["NonPersistentDisksNotSupportedFault"] = reflect.TypeOf((*NonPersistentDisksNotSupportedFault)(nil)).Elem()
}

// This event records that non-VI workload is detected on the datastore.
type NonVIWorkloadDetectedOnDatastoreEvent struct {
	DatastoreEvent
}

func init() {
	t["NonVIWorkloadDetectedOnDatastoreEvent"] = reflect.TypeOf((*NonVIWorkloadDetectedOnDatastoreEvent)(nil)).Elem()
}

// The host does not support VM that has VPX assigned prefix or ranged based
// MAC address (i.e.
//
// MAC is not prefixed with 00:50:56:\[80-BF\])
type NonVmwareOuiMacNotSupportedHost struct {
	NotSupportedHost

	// The name of the host.
	HostName string `xml:"hostName" json:"hostName"`
}

func init() {
	t["NonVmwareOuiMacNotSupportedHost"] = reflect.TypeOf((*NonVmwareOuiMacNotSupportedHost)(nil)).Elem()
}

type NonVmwareOuiMacNotSupportedHostFault NonVmwareOuiMacNotSupportedHost

func init() {
	t["NonVmwareOuiMacNotSupportedHostFault"] = reflect.TypeOf((*NonVmwareOuiMacNotSupportedHostFault)(nil)).Elem()
}

// This fault is thrown when an operation fails because the specified object
// is not a directory.
type NotADirectory struct {
	FileFault
}

func init() {
	t["NotADirectory"] = reflect.TypeOf((*NotADirectory)(nil)).Elem()
}

type NotADirectoryFault NotADirectory

func init() {
	t["NotADirectoryFault"] = reflect.TypeOf((*NotADirectoryFault)(nil)).Elem()
}

// This fault is thrown when an operation fails because the specified object
// is not a file.
type NotAFile struct {
	FileFault
}

func init() {
	t["NotAFile"] = reflect.TypeOf((*NotAFile)(nil)).Elem()
}

type NotAFileFault NotAFile

func init() {
	t["NotAFileFault"] = reflect.TypeOf((*NotAFileFault)(nil)).Elem()
}

// Thrown when an operation is denied because the session
// has not yet successfully logged in.
type NotAuthenticated struct {
	NoPermission
}

func init() {
	t["NotAuthenticated"] = reflect.TypeOf((*NotAuthenticated)(nil)).Elem()
}

type NotAuthenticatedFault NotAuthenticated

func init() {
	t["NotAuthenticatedFault"] = reflect.TypeOf((*NotAuthenticatedFault)(nil)).Elem()
}

// The host hardware does not have enough CPU cores to support the number of
// virtual CPUs in the virtual machine.
//
// If the host is using hyperthreading, NotEnoughLogicalCpus is
// employed instead of NotEnoughCpus.
type NotEnoughCpus struct {
	VirtualHardwareCompatibilityIssue

	// The number of CPUs present on the host.
	NumCpuDest int32 `xml:"numCpuDest" json:"numCpuDest"`
	// The number of virtual CPUs present in the virtual machine.
	NumCpuVm int32 `xml:"numCpuVm" json:"numCpuVm"`
}

func init() {
	t["NotEnoughCpus"] = reflect.TypeOf((*NotEnoughCpus)(nil)).Elem()
}

type NotEnoughCpusFault BaseNotEnoughCpus

func init() {
	t["NotEnoughCpusFault"] = reflect.TypeOf((*NotEnoughCpusFault)(nil)).Elem()
}

// A NotEnoughLicensesFault occurs when an operation
// fails because there are not enough licenses installed.
type NotEnoughLicenses struct {
	RuntimeFault
}

func init() {
	t["NotEnoughLicenses"] = reflect.TypeOf((*NotEnoughLicenses)(nil)).Elem()
}

type NotEnoughLicensesFault BaseNotEnoughLicenses

func init() {
	t["NotEnoughLicensesFault"] = reflect.TypeOf((*NotEnoughLicensesFault)(nil)).Elem()
}

// The host hardware does not have enough logical CPUs (hyperthreads) to
// support the number of virtual CPUs in the virtual machine.
type NotEnoughLogicalCpus struct {
	NotEnoughCpus

	// The host that does not have enough logical CPUs.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["NotEnoughLogicalCpus"] = reflect.TypeOf((*NotEnoughLogicalCpus)(nil)).Elem()
}

type NotEnoughLogicalCpusFault NotEnoughLogicalCpus

func init() {
	t["NotEnoughLogicalCpusFault"] = reflect.TypeOf((*NotEnoughLogicalCpusFault)(nil)).Elem()
}

// This event records when the HA does not find sufficient resources to failover a
// virtual machine.
type NotEnoughResourcesToStartVmEvent struct {
	VmEvent

	// The reason why the virtual machine could not be restarted
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["NotEnoughResourcesToStartVmEvent"] = reflect.TypeOf((*NotEnoughResourcesToStartVmEvent)(nil)).Elem()
}

// A NotFound error occurs when a referenced component of a managed
// object cannot be found.
//
// The referenced component can be a data
// object type (such as a role or permission) or a primitive
// (such as a string).
//
// For example, if the missing referenced component is a data object, such as
// VirtualSwitch, the NotFound error is
// thrown. The NotFound error is also thrown if the data object is found, but the referenced name
// (for example, "vswitch0") is not.
type NotFound struct {
	VimFault
}

func init() {
	t["NotFound"] = reflect.TypeOf((*NotFound)(nil)).Elem()
}

type NotFoundFault NotFound

func init() {
	t["NotFoundFault"] = reflect.TypeOf((*NotFoundFault)(nil)).Elem()
}

// NotImplemented exception is thrown if the method is not
// yet implemented.
type NotImplemented struct {
	RuntimeFault
}

func init() {
	t["NotImplemented"] = reflect.TypeOf((*NotImplemented)(nil)).Elem()
}

type NotImplementedFault NotImplemented

func init() {
	t["NotImplementedFault"] = reflect.TypeOf((*NotImplementedFault)(nil)).Elem()
}

// Thrown if the method is not supported on the
// server.
//
// Not all methods are supported on all servers
// (for example, an ESX Server host supports less functionality than
// a VirtualCenter server). A feature might also be disabled
// due to missing liceneses.
type NotSupported struct {
	RuntimeFault
}

func init() {
	t["NotSupported"] = reflect.TypeOf((*NotSupported)(nil)).Elem()
}

// Deprecated as of vSphere API 7.0. Not used since vSphere API 6.5.
//
// VMs with pvscsi or vmxnet3 virtual devices support Fault Tolerance only
// on 4.1 or later hosts.
type NotSupportedDeviceForFT struct {
	VmFaultToleranceIssue

	// The host
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The host name
	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
	// The virtual machine
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The virtual machine name
	VmName string `xml:"vmName,omitempty" json:"vmName,omitempty"`
	// The device type
	DeviceType string `xml:"deviceType" json:"deviceType"`
	// The device label
	DeviceLabel string `xml:"deviceLabel,omitempty" json:"deviceLabel,omitempty"`
}

func init() {
	t["NotSupportedDeviceForFT"] = reflect.TypeOf((*NotSupportedDeviceForFT)(nil)).Elem()
}

type NotSupportedDeviceForFTFault NotSupportedDeviceForFT

func init() {
	t["NotSupportedDeviceForFTFault"] = reflect.TypeOf((*NotSupportedDeviceForFTFault)(nil)).Elem()
}

type NotSupportedFault BaseNotSupported

func init() {
	t["NotSupportedFault"] = reflect.TypeOf((*NotSupportedFault)(nil)).Elem()
}

// A NotSupportedHostFault occurs when the host is of a type
// that is not supported.
type NotSupportedHost struct {
	HostConnectFault

	// The name of the unsupported product if available;
	// for example, "VMware ESX Server".
	ProductName string `xml:"productName,omitempty" json:"productName,omitempty"`
	// The version of the unsupported product; for example, "1.5.2"
	ProductVersion string `xml:"productVersion,omitempty" json:"productVersion,omitempty"`
}

func init() {
	t["NotSupportedHost"] = reflect.TypeOf((*NotSupportedHost)(nil)).Elem()
}

type NotSupportedHostFault BaseNotSupportedHost

func init() {
	t["NotSupportedHostFault"] = reflect.TypeOf((*NotSupportedHostFault)(nil)).Elem()
}

// Base class for host checksum related faults
type NotSupportedHostForChecksum struct {
	VimFault
}

func init() {
	t["NotSupportedHostForChecksum"] = reflect.TypeOf((*NotSupportedHostForChecksum)(nil)).Elem()
}

type NotSupportedHostForChecksumFault NotSupportedHostForChecksum

func init() {
	t["NotSupportedHostForChecksumFault"] = reflect.TypeOf((*NotSupportedHostForChecksumFault)(nil)).Elem()
}

// The host does not support vFlash feature.
type NotSupportedHostForVFlash struct {
	NotSupportedHost

	// The name of the host.
	HostName string `xml:"hostName" json:"hostName"`
}

func init() {
	t["NotSupportedHostForVFlash"] = reflect.TypeOf((*NotSupportedHostForVFlash)(nil)).Elem()
}

type NotSupportedHostForVFlashFault NotSupportedHostForVFlash

func init() {
	t["NotSupportedHostForVFlashFault"] = reflect.TypeOf((*NotSupportedHostForVFlashFault)(nil)).Elem()
}

// The host does not support VM Component Protection.
type NotSupportedHostForVmcp struct {
	NotSupportedHost

	// The name of the host.
	HostName string `xml:"hostName" json:"hostName"`
}

func init() {
	t["NotSupportedHostForVmcp"] = reflect.TypeOf((*NotSupportedHostForVmcp)(nil)).Elem()
}

type NotSupportedHostForVmcpFault NotSupportedHostForVmcp

func init() {
	t["NotSupportedHostForVmcpFault"] = reflect.TypeOf((*NotSupportedHostForVmcpFault)(nil)).Elem()
}

// The host does not support VM Component Protection.
type NotSupportedHostForVmemFile struct {
	NotSupportedHost

	// The name of the host.
	HostName string `xml:"hostName" json:"hostName"`
}

func init() {
	t["NotSupportedHostForVmemFile"] = reflect.TypeOf((*NotSupportedHostForVmemFile)(nil)).Elem()
}

type NotSupportedHostForVmemFileFault NotSupportedHostForVmemFile

func init() {
	t["NotSupportedHostForVmemFileFault"] = reflect.TypeOf((*NotSupportedHostForVmemFileFault)(nil)).Elem()
}

// The host does not support VSAN.
type NotSupportedHostForVsan struct {
	NotSupportedHost

	// The name of the host.
	HostName string `xml:"hostName" json:"hostName"`
}

func init() {
	t["NotSupportedHostForVsan"] = reflect.TypeOf((*NotSupportedHostForVsan)(nil)).Elem()
}

type NotSupportedHostForVsanFault NotSupportedHostForVsan

func init() {
	t["NotSupportedHostForVsanFault"] = reflect.TypeOf((*NotSupportedHostForVsanFault)(nil)).Elem()
}

// A NotSupportedHostInCluster fault occurs when the host does not support
// the necessary features to participate in the cluster.
type NotSupportedHostInCluster struct {
	NotSupportedHost
}

func init() {
	t["NotSupportedHostInCluster"] = reflect.TypeOf((*NotSupportedHostInCluster)(nil)).Elem()
}

type NotSupportedHostInClusterFault BaseNotSupportedHostInCluster

func init() {
	t["NotSupportedHostInClusterFault"] = reflect.TypeOf((*NotSupportedHostInClusterFault)(nil)).Elem()
}

// A NotSupportedHostInDvs fault occurs when the host does not support
// the necessary features to participate in the DVS.
type NotSupportedHostInDvs struct {
	NotSupportedHost

	// The product spec of the DVS.
	//
	// This determines which host versions may
	// participate in the DVS; that information may be queried by using
	// `DistributedVirtualSwitchManager.QueryDvsCompatibleHostSpec`.
	SwitchProductSpec DistributedVirtualSwitchProductSpec `xml:"switchProductSpec" json:"switchProductSpec"`
}

func init() {
	t["NotSupportedHostInDvs"] = reflect.TypeOf((*NotSupportedHostInDvs)(nil)).Elem()
}

type NotSupportedHostInDvsFault NotSupportedHostInDvs

func init() {
	t["NotSupportedHostInDvsFault"] = reflect.TypeOf((*NotSupportedHostInDvsFault)(nil)).Elem()
}

// A NotSupportedHostInHACluster fault occurs when the host does not support
// the necessary features to participate in the HA cluster.
type NotSupportedHostInHACluster struct {
	NotSupportedHost

	// The name of the host.
	HostName string `xml:"hostName" json:"hostName"`
	// The product build number of the host.
	Build string `xml:"build" json:"build"`
}

func init() {
	t["NotSupportedHostInHACluster"] = reflect.TypeOf((*NotSupportedHostInHACluster)(nil)).Elem()
}

type NotSupportedHostInHAClusterFault NotSupportedHostInHACluster

func init() {
	t["NotSupportedHostInHAClusterFault"] = reflect.TypeOf((*NotSupportedHostInHAClusterFault)(nil)).Elem()
}

// The property value cannot be changed since it is not
// user configurable.
type NotUserConfigurableProperty struct {
	VAppPropertyFault
}

func init() {
	t["NotUserConfigurableProperty"] = reflect.TypeOf((*NotUserConfigurableProperty)(nil)).Elem()
}

type NotUserConfigurablePropertyFault NotUserConfigurableProperty

func init() {
	t["NotUserConfigurablePropertyFault"] = reflect.TypeOf((*NotUserConfigurablePropertyFault)(nil)).Elem()
}

type NotifyAffectedServices NotifyAffectedServicesRequestType

func init() {
	t["NotifyAffectedServices"] = reflect.TypeOf((*NotifyAffectedServices)(nil)).Elem()
}

// The parameters of `HostCertificateManager.NotifyAffectedServices`.
type NotifyAffectedServicesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// list of services that need to be notified and no
	// other service would be notified. if not provided all supported
	// services would be notified.
	Services []string `xml:"services,omitempty" json:"services,omitempty" vim:"8.0.1.0"`
}

func init() {
	t["NotifyAffectedServicesRequestType"] = reflect.TypeOf((*NotifyAffectedServicesRequestType)(nil)).Elem()
}

type NotifyAffectedServicesResponse struct {
}

// The `NsxHostVNicProfile` data object is the base object
// for host Virtual NIC connected to NSX logic switch subprofiles.
//
// If a profile plug-in defines additional policies or subprofiles, use the
// `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the configuration data.
type NsxHostVNicProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
	// IP address for the Virtual NIC belonging to a logic switch.
	IpConfig IpAddressProfile `xml:"ipConfig" json:"ipConfig"`
}

func init() {
	t["NsxHostVNicProfile"] = reflect.TypeOf((*NsxHostVNicProfile)(nil)).Elem()
}

// The NumPortsProfile data object represents a
// subprofile for the number of ports for a
// virtual switch
type NumPortsProfile struct {
	ApplyProfile
}

func init() {
	t["NumPortsProfile"] = reflect.TypeOf((*NumPortsProfile)(nil)).Elem()
}

// The host's software does not support enough cores per socket to
// accommodate the virtual machine.
//
// This is always an error.
type NumVirtualCoresPerSocketNotSupported struct {
	VirtualHardwareCompatibilityIssue

	// The maximum number of cores per socket supported on the host.
	MaxSupportedCoresPerSocketDest int32 `xml:"maxSupportedCoresPerSocketDest" json:"maxSupportedCoresPerSocketDest"`
	// The number of cores per socket in the virtual machine.
	NumCoresPerSocketVm int32 `xml:"numCoresPerSocketVm" json:"numCoresPerSocketVm"`
}

func init() {
	t["NumVirtualCoresPerSocketNotSupported"] = reflect.TypeOf((*NumVirtualCoresPerSocketNotSupported)(nil)).Elem()
}

type NumVirtualCoresPerSocketNotSupportedFault NumVirtualCoresPerSocketNotSupported

func init() {
	t["NumVirtualCoresPerSocketNotSupportedFault"] = reflect.TypeOf((*NumVirtualCoresPerSocketNotSupportedFault)(nil)).Elem()
}

// This fault is thrown when the total number of virtual CPUs present or requested
// in virtual machines' configuration has exceeded the limit on the host.
type NumVirtualCpusExceedsLimit struct {
	InsufficientResourcesFault

	// The maximum number of virtual CPUs supported on the host.
	MaxSupportedVcpus int32 `xml:"maxSupportedVcpus" json:"maxSupportedVcpus"`
}

func init() {
	t["NumVirtualCpusExceedsLimit"] = reflect.TypeOf((*NumVirtualCpusExceedsLimit)(nil)).Elem()
}

type NumVirtualCpusExceedsLimitFault NumVirtualCpusExceedsLimit

func init() {
	t["NumVirtualCpusExceedsLimitFault"] = reflect.TypeOf((*NumVirtualCpusExceedsLimitFault)(nil)).Elem()
}

// The number of virtual CPUs present or requested in the virtual machine's
// configuration is not supported for a specific feature.
type NumVirtualCpusIncompatible struct {
	VmConfigFault

	// The reason for the incompatibility.
	//
	// See `NumVirtualCpusIncompatibleReason_enum` for valid values.
	Reason string `xml:"reason" json:"reason"`
	// The number of virtual CPUs in the virtual machine.
	NumCpu int32 `xml:"numCpu" json:"numCpu"`
}

func init() {
	t["NumVirtualCpusIncompatible"] = reflect.TypeOf((*NumVirtualCpusIncompatible)(nil)).Elem()
}

type NumVirtualCpusIncompatibleFault NumVirtualCpusIncompatible

func init() {
	t["NumVirtualCpusIncompatibleFault"] = reflect.TypeOf((*NumVirtualCpusIncompatibleFault)(nil)).Elem()
}

// The host's software does not support enough virtual CPUs to
// accommodate the virtual machine.
//
// This is always an error.
type NumVirtualCpusNotSupported struct {
	VirtualHardwareCompatibilityIssue

	// The maximum number of virtual CPUs supported on the host.
	MaxSupportedVcpusDest int32 `xml:"maxSupportedVcpusDest" json:"maxSupportedVcpusDest"`
	// The number of virtual CPUs in the virtual machine.
	NumCpuVm int32 `xml:"numCpuVm" json:"numCpuVm"`
}

func init() {
	t["NumVirtualCpusNotSupported"] = reflect.TypeOf((*NumVirtualCpusNotSupported)(nil)).Elem()
}

type NumVirtualCpusNotSupportedFault NumVirtualCpusNotSupported

func init() {
	t["NumVirtualCpusNotSupportedFault"] = reflect.TypeOf((*NumVirtualCpusNotSupportedFault)(nil)).Elem()
}

// The class that describe an integer range.
type NumericRange struct {
	DynamicData

	// The starting number.
	Start int32 `xml:"start" json:"start"`
	// The ending number (inclusive).
	End int32 `xml:"end" json:"end"`
}

func init() {
	t["NumericRange"] = reflect.TypeOf((*NumericRange)(nil)).Elem()
}

// Get detailed information of a nvdimm
type NvdimmDimmInfo struct {
	DynamicData

	// Unique device identifier
	DimmHandle int32 `xml:"dimmHandle" json:"dimmHandle"`
	// Health status of nvdimm.
	//
	// `NvdimmHealthInfo`
	HealthInfo NvdimmHealthInfo `xml:"healthInfo" json:"healthInfo"`
	// Total capacity of NVDIMM in bytes
	TotalCapacity int64 `xml:"totalCapacity" json:"totalCapacity"`
	// Total persistent capacity in DIMM (in bytes)
	PersistentCapacity int64 `xml:"persistentCapacity" json:"persistentCapacity"`
	// Persistent Capacity in DIMM currently not allocated
	AvailablePersistentCapacity int64 `xml:"availablePersistentCapacity" json:"availablePersistentCapacity"`
	// Total volatile capacity in DIMM (in bytes)
	VolatileCapacity int64 `xml:"volatileCapacity" json:"volatileCapacity"`
	// Volatile capacity in DIMM currently not allocated
	AvailableVolatileCapacity int64 `xml:"availableVolatileCapacity" json:"availableVolatileCapacity"`
	// Total block capacity in DIMM (in bytes)
	BlockCapacity int64 `xml:"blockCapacity" json:"blockCapacity"`
	// NVDIMM region information.
	//
	// List of regions in the NVDIMM. These regions may or maynot
	// be a part of an interleave set.
	RegionInfo []NvdimmRegionInfo `xml:"regionInfo,omitempty" json:"regionInfo,omitempty"`
	// NVDIMM Representation string which is a sequence of
	// numbers to uniquely identify the DIMM.
	RepresentationString string `xml:"representationString" json:"representationString"`
}

func init() {
	t["NvdimmDimmInfo"] = reflect.TypeOf((*NvdimmDimmInfo)(nil)).Elem()
}

// A unique identifier used for namespaces
type NvdimmGuid struct {
	DynamicData

	// Universally unique identifier in string format
	Uuid string `xml:"uuid" json:"uuid"`
}

func init() {
	t["NvdimmGuid"] = reflect.TypeOf((*NvdimmGuid)(nil)).Elem()
}

// \\brief NVDIMM health information
type NvdimmHealthInfo struct {
	DynamicData

	// Device health status.
	HealthStatus string `xml:"healthStatus" json:"healthStatus"`
	// Health status description.
	HealthInformation string `xml:"healthInformation" json:"healthInformation"`
	// State flag information.
	//
	// This information is the cumulation of state flags of all the
	// NVDIMM region state flags. It must be one or more of
	// `NvdimmNvdimmHealthInfoState_enum`
	StateFlagInfo []string `xml:"stateFlagInfo,omitempty" json:"stateFlagInfo,omitempty"`
	// Current Nvdimm temperature in degree Celsius.
	DimmTemperature int32 `xml:"dimmTemperature" json:"dimmTemperature"`
	// Nvdimm temperature threshold.
	//
	// Default value is 0, indicating threshold has not reached,
	// if set to 1, reached threshold limit.
	DimmTemperatureThreshold int32 `xml:"dimmTemperatureThreshold" json:"dimmTemperatureThreshold"`
	// Percentage of spare capavity as a percentage of
	// factory configured space (valid range 0 to 100)
	SpareBlocksPercentage int32 `xml:"spareBlocksPercentage" json:"spareBlocksPercentage"`
	// Spare block threshold.
	//
	// Default value is 0, indicating threshold has not reached,
	// if set to 1, reached threshold limit.
	SpareBlockThreshold int32 `xml:"spareBlockThreshold" json:"spareBlockThreshold"`
	// Lifespan of Nvdimm as percentage.
	//
	// 100% = Warranted life span has reached.
	DimmLifespanPercentage int32 `xml:"dimmLifespanPercentage" json:"dimmLifespanPercentage"`
	// Energy source current temperature in degree Celsius.
	//
	// Default value is 0, indicating there is no
	// energy source for these nvdimms.
	EsTemperature int32 `xml:"esTemperature,omitempty" json:"esTemperature,omitempty"`
	// Energy source temperature threshold.
	//
	// Default value is 0, indicating threshold has not reached,
	// if set to 1, reached threshold limit.
	EsTemperatureThreshold int32 `xml:"esTemperatureThreshold,omitempty" json:"esTemperatureThreshold,omitempty"`
	// Lifespan of Energy source as percentage.
	//
	// 100% = Warranted life span has reached.
	// Default value is 0, indicating there is no energy
	// source.
	EsLifespanPercentage int32 `xml:"esLifespanPercentage,omitempty" json:"esLifespanPercentage,omitempty"`
}

func init() {
	t["NvdimmHealthInfo"] = reflect.TypeOf((*NvdimmHealthInfo)(nil)).Elem()
}

// Characteristics of an interleave set of a NVDIMM
type NvdimmInterleaveSetInfo struct {
	DynamicData

	// Unique set ID
	SetId int32 `xml:"setId" json:"setId"`
	// Volatile or persistent interleave set.
	//
	// Must be one of the values of
	// `NvdimmRangeType_enum`
	RangeType string `xml:"rangeType" json:"rangeType"`
	// Start address of range
	BaseAddress int64 `xml:"baseAddress" json:"baseAddress"`
	// Length of range in bytes
	Size int64 `xml:"size" json:"size"`
	// Capacity currently not allocated to namespace in bytes
	AvailableSize int64 `xml:"availableSize" json:"availableSize"`
	// List of nvdimms contributing to this interleave set
	DeviceList []int32 `xml:"deviceList,omitempty" json:"deviceList,omitempty"`
	// State of interleave set.
	//
	// Must be one of the values in
	// `NvdimmInterleaveSetState_enum`
	State string `xml:"state" json:"state"`
}

func init() {
	t["NvdimmInterleaveSetInfo"] = reflect.TypeOf((*NvdimmInterleaveSetInfo)(nil)).Elem()
}

// Deprecated as of vSphere 6.7u1, use PMemNamespaceCreateReq.
//
// Arguments for creating a namespace.
type NvdimmNamespaceCreateSpec struct {
	DynamicData

	// Friendly name of the namespace to be created.
	//
	// A friendly name can be provided by user to assosiate a name to
	// the created namespace, but such a name is not mandatory and is
	// empty string by default.
	FriendlyName string `xml:"friendlyName,omitempty" json:"friendlyName,omitempty"`
	// Size of block in the namespace.
	//
	// For persistent region type, block size is one.
	// For block region, block size represents one of the logical block sizes
	// of 512, 4096 etc.
	BlockSize int64 `xml:"blockSize" json:"blockSize"`
	// Number of blocks in the namespace.
	//
	// For persistent region type, blockCount is the size of persistent
	// region in bytes.
	// For block region type, block count represent number of bytes per
	// block size.
	BlockCount int64 `xml:"blockCount" json:"blockCount"`
	// Type of the namespace to be created - block or persistent.
	//
	// Must be one of the values in
	// `NvdimmNamespaceType_enum`
	Type string `xml:"type" json:"type"`
	// This identifier is the interleave set ID if the namespace
	// is being used in persistent mode.
	//
	// If in block mode, this
	// is a device handle.
	LocationID int32 `xml:"locationID" json:"locationID"`
}

func init() {
	t["NvdimmNamespaceCreateSpec"] = reflect.TypeOf((*NvdimmNamespaceCreateSpec)(nil)).Elem()
}

// Arguments for deleting a namespace
type NvdimmNamespaceDeleteSpec struct {
	DynamicData

	// Universally unique identifier of the namespace to be deleted
	Uuid string `xml:"uuid" json:"uuid"`
}

func init() {
	t["NvdimmNamespaceDeleteSpec"] = reflect.TypeOf((*NvdimmNamespaceDeleteSpec)(nil)).Elem()
}

// Detailed information about a particular namespace.
type NvdimmNamespaceDetails struct {
	DynamicData

	// Universally unique identifier assigned to namespace
	// in string format
	Uuid string `xml:"uuid" json:"uuid"`
	// Human readable name of namespace
	FriendlyName string `xml:"friendlyName" json:"friendlyName"`
	// Size of namespace in bytes.
	Size int64 `xml:"size" json:"size"`
	// Type of the namespace to be created - block or persistent.
	//
	// Must be one of the values in
	// `NvdimmNamespaceType_enum`
	Type string `xml:"type" json:"type"`
	// Health status of DIMM(s) part of the namespace.
	//
	// Must be one of the values of
	// `NvdimmNamespaceDetailsHealthStatus_enum`
	NamespaceHealthStatus string `xml:"namespaceHealthStatus" json:"namespaceHealthStatus"`
	// The interleave set ID of the namespace.
	InterleavesetID int32 `xml:"interleavesetID" json:"interleavesetID"`
	// State of namespace.
	//
	// Must be one of
	// `NvdimmNamespaceDetailsState_enum`
	State string `xml:"state" json:"state"`
}

func init() {
	t["NvdimmNamespaceDetails"] = reflect.TypeOf((*NvdimmNamespaceDetails)(nil)).Elem()
}

// Deprecated as of vSphere 6.7u1, use NamespaceDetails.
//
// Detailed information about a particular namespace.
type NvdimmNamespaceInfo struct {
	DynamicData

	// Universally unique identifier assigned to namespace
	// in string format
	Uuid string `xml:"uuid" json:"uuid"`
	// Friendly name of namespace
	FriendlyName string `xml:"friendlyName" json:"friendlyName"`
	// Size of logical block size.
	//
	// For persistent region type, block size is one.
	// For block region, block size represents one of the logical block sizes
	// of 512, 4096 etc.
	BlockSize int64 `xml:"blockSize" json:"blockSize"`
	// Number of blocks in the namespace.
	//
	// For persistent region type, blockCount is the size of persistent
	// region in bytes.
	// For block region type, block count represent number of bytes per
	// block size.
	BlockCount int64 `xml:"blockCount" json:"blockCount"`
	// Type of the namespace to be created - block or persistent.
	//
	// Must be one of the values in
	// `NvdimmNamespaceType_enum`
	Type string `xml:"type" json:"type"`
	// Health status of DIMM(s) part of the namespace.
	//
	// Must be one of the values of
	// `NvdimmNamespaceHealthStatus_enum`
	NamespaceHealthStatus string `xml:"namespaceHealthStatus" json:"namespaceHealthStatus"`
	// This identifier is the interleave set ID if this namespace
	// is being used in persistent mode.
	//
	// If in block mode, this
	// is a nvdimm device handle.
	LocationID int32 `xml:"locationID" json:"locationID"`
	// State of namespace.
	//
	// Must be one of
	// `NvdimmNamespaceState_enum`
	State string `xml:"state" json:"state"`
}

func init() {
	t["NvdimmNamespaceInfo"] = reflect.TypeOf((*NvdimmNamespaceInfo)(nil)).Elem()
}

// Arguments for creating a persistent memory mode namespace
type NvdimmPMemNamespaceCreateSpec struct {
	DynamicData

	// Friendly name of the namespace to be created.
	//
	// A friendly name can be provided by user to associate a name to
	// the created namespace, but such a name is not mandatory and is
	// empty string by default.
	FriendlyName string `xml:"friendlyName,omitempty" json:"friendlyName,omitempty"`
	// Size of the namespace in bytes.
	Size int64 `xml:"size" json:"size"`
	// The interleave set ID of the namespace.
	InterleavesetID int32 `xml:"interleavesetID" json:"interleavesetID"`
}

func init() {
	t["NvdimmPMemNamespaceCreateSpec"] = reflect.TypeOf((*NvdimmPMemNamespaceCreateSpec)(nil)).Elem()
}

// \\brief NVDIMM region information.
//
// This represents a region which is a part of NVDIMM.
type NvdimmRegionInfo struct {
	DynamicData

	// NVDIMM region ID
	RegionId int32 `xml:"regionId" json:"regionId"`
	// Interleave set ID.
	//
	// Interleave set to which this region belongs. A value
	// of 0 indicates that this region is not a part of any
	// interleave set.
	SetId int32 `xml:"setId" json:"setId"`
	// Type of region.
	//
	// Must be one of the values of
	// `NvdimmRangeType_enum`
	RangeType string `xml:"rangeType" json:"rangeType"`
	// Region start address.
	//
	// This represents the address within the NVDIMM to which this
	// NVDIMM region belongs (Dimm physical address).
	// If `NvdimmRegionInfo.setId` is 0, this field is not valid.
	StartAddr int64 `xml:"startAddr" json:"startAddr"`
	// Size of region in bytes.
	//
	// If this region is part of interleave set (represented by non zero
	// `NvdimmRegionInfo.setId`) and the region is interleaved across
	// multiple dimms (represented by more that one element in
	// `NvdimmInterleaveSetInfo.deviceList` for assosiated set id
	// `NvdimmRegionInfo.setId`), this size represents part of the
	// interleave set size - (total interleave set size / number
	// of dimms in `NvdimmInterleaveSetInfo.deviceList`).
	// Example: If Interleave set with set id 5, has a size of 2TB
	// and has 2 NVDIMMs contributing to it (size of
	// `NvdimmInterleaveSetInfo.deviceList` is 2), then this size
	// parameter is 2TB/2 = 1TB.
	// If `NvdimmRegionInfo.setId` is 0, this field is not valid.
	Size int64 `xml:"size" json:"size"`
	// Offset of nvdimm within interleave set.
	//
	// This represents offset with respect to base address
	// in `NvdimmInterleaveSetInfo.baseAddress`.
	// If `NvdimmRegionInfo.setId` is 0, this field is not valid.
	Offset int64 `xml:"offset" json:"offset"`
}

func init() {
	t["NvdimmRegionInfo"] = reflect.TypeOf((*NvdimmRegionInfo)(nil)).Elem()
}

// \\brief Get summary of nvdimm
type NvdimmSummary struct {
	DynamicData

	// Number of NVDIMMs in the system
	NumDimms int32 `xml:"numDimms" json:"numDimms"`
	// Summary of health status of all NVDIMMs in the system.
	HealthStatus string `xml:"healthStatus" json:"healthStatus"`
	// Total capacity of all NVDIMMs in bytes
	TotalCapacity int64 `xml:"totalCapacity" json:"totalCapacity"`
	// Persistent region capacity in bytes
	PersistentCapacity int64 `xml:"persistentCapacity" json:"persistentCapacity"`
	// Block region capacity in bytes
	BlockCapacity int64 `xml:"blockCapacity" json:"blockCapacity"`
	// Capacity not covered by namespace in bytes
	AvailableCapacity int64 `xml:"availableCapacity" json:"availableCapacity"`
	// Total number of interleave sets in the system
	NumInterleavesets int32 `xml:"numInterleavesets" json:"numInterleavesets"`
	// Total number of namespaces in the system
	NumNamespaces int32 `xml:"numNamespaces" json:"numNamespaces"`
}

func init() {
	t["NvdimmSummary"] = reflect.TypeOf((*NvdimmSummary)(nil)).Elem()
}

// This data object represents Non-Volatile DIMMs host
// configuration.
type NvdimmSystemInfo struct {
	DynamicData

	// Host NVDIMM system summary.
	//
	// Summary is unset if the system does not support PMem feature.
	Summary *NvdimmSummary `xml:"summary,omitempty" json:"summary,omitempty"`
	// List of NVDIMMs on the host.
	//
	// NVDIMM list unset if the system does not support PMem feature.
	Dimms []int32 `xml:"dimms,omitempty" json:"dimms,omitempty"`
	// List of DIMM information of all NVDIMMs on the host.
	//
	// Dimm information is unset if the system does not support PMem feature.
	DimmInfo []NvdimmDimmInfo `xml:"dimmInfo,omitempty" json:"dimmInfo,omitempty"`
	// List of NVDIMM Interleave sets on the host.
	//
	// Interleave set is unset if the system does not support PMem feature.
	InterleaveSet []int32 `xml:"interleaveSet,omitempty" json:"interleaveSet,omitempty"`
	// List of information of all NVDIMM interleave sets on the host.
	//
	// Interleave set information is unset if the system does not
	// support PMem feature.
	ISetInfo []NvdimmInterleaveSetInfo `xml:"iSetInfo,omitempty" json:"iSetInfo,omitempty"`
	// List of NVDIMM namespaces on the host.
	//
	// Namespace is unset if the system does not support PMem feature.
	Namespace []NvdimmGuid `xml:"namespace,omitempty" json:"namespace,omitempty"`
	// Deprecated as of vSphere 6.7u1, use nsDetails.
	//
	// List of information of all NVDIMM namespaces on the host.
	//
	// Namespace information is unset if the system does not support
	// PMem feature.
	NsInfo []NvdimmNamespaceInfo `xml:"nsInfo,omitempty" json:"nsInfo,omitempty"`
	// List of details of all NVDIMM namespaces on the host.
	//
	// Namespace details is unset if the system does not support
	// PMem feature.
	NsDetails []NvdimmNamespaceDetails `xml:"nsDetails,omitempty" json:"nsDetails,omitempty"`
}

func init() {
	t["NvdimmSystemInfo"] = reflect.TypeOf((*NvdimmSystemInfo)(nil)).Elem()
}

// The `ObjectContent` data object type contains the
// contents retrieved for a single managed object.
type ObjectContent struct {
	DynamicData

	// Reference to the managed object that contains properties of interest.
	Obj ManagedObjectReference `xml:"obj" json:"obj"`
	// Set of name-value pairs for the properties of the managed object.
	PropSet []DynamicProperty `xml:"propSet,omitempty" json:"propSet,omitempty"`
	// Properties for which values could not be retrieved and the associated
	// fault.
	MissingSet []MissingProperty `xml:"missingSet,omitempty" json:"missingSet,omitempty"`
}

func init() {
	t["ObjectContent"] = reflect.TypeOf((*ObjectContent)(nil)).Elem()
}

// Within a `PropertyFilterSpec`, the `ObjectSpec` data object type specifies the managed
// object at which the filter begins to collect the managed object
// references and properties specified by the associated `PropertySpec` set.
//
// If the "skip" property is present
// and set to true, then the filter does not check to see if the starting
// object's type matches any of the types listed in the associated sets of
// `PropertySpec` data objects.
//
// If the `ObjectSpec.selectSet` property is
// present, then this specifies additional objects to filter. These objects
// are defined by one or more `SelectionSpec`
// objects.
type ObjectSpec struct {
	DynamicData

	// Starting object.
	Obj ManagedObjectReference `xml:"obj" json:"obj"`
	// Flag to specify whether or not to report this managed object's
	// properties.
	//
	// If the flag is true, the filter will not report this
	// managed object's properties.
	Skip *bool `xml:"skip" json:"skip,omitempty"`
	// Set of selections to specify additional objects to filter.
	SelectSet []BaseSelectionSpec `xml:"selectSet,omitempty,typeattr" json:"selectSet,omitempty"`
}

func init() {
	t["ObjectSpec"] = reflect.TypeOf((*ObjectSpec)(nil)).Elem()
}

// The `ObjectUpdate` data object type contains
// information about changes to a particular managed object.
//
// We distinguish
// updates when an object is created, destroyed, or modified, as well as
// when the object enters or leaves the set of objects dynamically
// associated with a filter.
type ObjectUpdate struct {
	DynamicData

	// Kind of update that caused the filter to report a change.
	Kind ObjectUpdateKind `xml:"kind" json:"kind"`
	// Reference to the managed object to which this update applies.
	Obj ManagedObjectReference `xml:"obj" json:"obj"`
	// Optional set of changes to the object.
	//
	// Present only if the "kind" is
	// either "modify" or "enter".
	ChangeSet []PropertyChange `xml:"changeSet,omitempty" json:"changeSet,omitempty"`
	// Properties whose value could not be retrieved and their associated
	// faults.
	//
	// Present only if the "kind" is either "modify" or "enter".
	MissingSet []MissingProperty `xml:"missingSet,omitempty" json:"missingSet,omitempty"`
}

func init() {
	t["ObjectUpdate"] = reflect.TypeOf((*ObjectUpdate)(nil)).Elem()
}

// The `OnceTaskScheduler` data object establishes the time for running
// a scheduled task only once.
type OnceTaskScheduler struct {
	TaskScheduler

	// The time a task will run.
	//
	// If you do not set the time, it executes immediately.
	RunAt *time.Time `xml:"runAt" json:"runAt,omitempty"`
}

func init() {
	t["OnceTaskScheduler"] = reflect.TypeOf((*OnceTaskScheduler)(nil)).Elem()
}

// The data object representing the capabilities supported by the Opaque
// Network.
type OpaqueNetworkCapability struct {
	DynamicData

	// Indicates whether network I/O control is supported for a network
	// adapter that connects to the opaque network.
	NetworkReservationSupported bool `xml:"networkReservationSupported" json:"networkReservationSupported"`
}

func init() {
	t["OpaqueNetworkCapability"] = reflect.TypeOf((*OpaqueNetworkCapability)(nil)).Elem()
}

// The summary of a opaque network.
//
// An object of this class is returned by the `Network.summary` property.
type OpaqueNetworkSummary struct {
	NetworkSummary

	// The opaque network ID
	OpaqueNetworkId string `xml:"opaqueNetworkId" json:"opaqueNetworkId"`
	// The opaque network type
	OpaqueNetworkType string `xml:"opaqueNetworkType" json:"opaqueNetworkType"`
}

func init() {
	t["OpaqueNetworkSummary"] = reflect.TypeOf((*OpaqueNetworkSummary)(nil)).Elem()
}

// This class describes an opaque network that a device backing
// can attached to.
type OpaqueNetworkTargetInfo struct {
	VirtualMachineTargetInfo

	// Information about the opaque network
	Network OpaqueNetworkSummary `xml:"network" json:"network"`
	// Indicates whether network bandwidth reservation is supported on
	// the opaque network
	NetworkReservationSupported *bool `xml:"networkReservationSupported" json:"networkReservationSupported,omitempty"`
}

func init() {
	t["OpaqueNetworkTargetInfo"] = reflect.TypeOf((*OpaqueNetworkTargetInfo)(nil)).Elem()
}

// The `OpaqueSwitchProfile` data object represents opaque switch
// configuration for the host.
//
// If a profile plug-in defines policies or subprofiles, use the
// `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the additional configuration data.
type OpaqueSwitchProfile struct {
	ApplyProfile
}

func init() {
	t["OpaqueSwitchProfile"] = reflect.TypeOf((*OpaqueSwitchProfile)(nil)).Elem()
}

type OpenInventoryViewFolder OpenInventoryViewFolderRequestType

func init() {
	t["OpenInventoryViewFolder"] = reflect.TypeOf((*OpenInventoryViewFolder)(nil)).Elem()
}

// The parameters of `InventoryView.OpenInventoryViewFolder`.
type OpenInventoryViewFolderRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// An array of managed object references. Each array entry is a reference
	// to an entity to expand. Expands each entity in the
	// order given. If an entity is not in the current view,
	// expands the view as needed.
	//
	// Required privileges: System.View
	//
	// Refers instances of `ManagedEntity`.
	Entity []ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["OpenInventoryViewFolderRequestType"] = reflect.TypeOf((*OpenInventoryViewFolderRequestType)(nil)).Elem()
}

type OpenInventoryViewFolderResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// An OperationDisabledByGuest exception is thrown when an
// operation fails because the guest operations agent has been configured to
// disable the operation.
type OperationDisabledByGuest struct {
	GuestOperationsFault
}

func init() {
	t["OperationDisabledByGuest"] = reflect.TypeOf((*OperationDisabledByGuest)(nil)).Elem()
}

type OperationDisabledByGuestFault OperationDisabledByGuest

func init() {
	t["OperationDisabledByGuestFault"] = reflect.TypeOf((*OperationDisabledByGuestFault)(nil)).Elem()
}

// An OperationDisallowedOnHost is thrown if an operation is diasllowed
// on host when a direct connection is used.
//
// Examples for such operations include VM powering on / memory hot-plug
// which could potentially violate hard-enforcement licenses if allowed
// on host.
// The functionality these operations provide is still available, but only
// through calls to an external entity.
type OperationDisallowedOnHost struct {
	RuntimeFault
}

func init() {
	t["OperationDisallowedOnHost"] = reflect.TypeOf((*OperationDisallowedOnHost)(nil)).Elem()
}

type OperationDisallowedOnHostFault OperationDisallowedOnHost

func init() {
	t["OperationDisallowedOnHostFault"] = reflect.TypeOf((*OperationDisallowedOnHostFault)(nil)).Elem()
}

// An OperationNotSupportedByGuest exception is thrown when an
// operation fails because the guest OS does not support
// the operation (e.g., Registry manipulation in Linux guests.).
type OperationNotSupportedByGuest struct {
	GuestOperationsFault
}

func init() {
	t["OperationNotSupportedByGuest"] = reflect.TypeOf((*OperationNotSupportedByGuest)(nil)).Elem()
}

type OperationNotSupportedByGuestFault OperationNotSupportedByGuest

func init() {
	t["OperationNotSupportedByGuestFault"] = reflect.TypeOf((*OperationNotSupportedByGuestFault)(nil)).Elem()
}

// Describes a user-defined option.
//
// The name of each option is identified by the
// "key" property, inherited from the `ElementDescription`
// data object type.
// You can indicate the property's position in a hierarchy by using a dot-separated
// notation. The string preceding the first dot is the top of the hierarchy. The
// hierarchy descends to a new sublevel with each dot.
// For example, "Ethernet.NetworkConnection.Bridged".
type OptionDef struct {
	ElementDescription

	// The option type which defines allowed values.
	OptionType BaseOptionType `xml:"optionType,typeattr" json:"optionType"`
}

func init() {
	t["OptionDef"] = reflect.TypeOf((*OptionDef)(nil)).Elem()
}

// The `OptionProfile` data object encapsulates one advanced configuration.
//
// Use the `ApplyProfile.policy` list for access to configuration data
// for the option profile. Use the `ApplyProfile.property` list for access
// to subprofile configuration data, if any.
type OptionProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["OptionProfile"] = reflect.TypeOf((*OptionProfile)(nil)).Elem()
}

// The base data object type for all options.
type OptionType struct {
	DynamicData

	// The flag to indicate whether or not a user
	// can modify a value belonging to this option type.
	//
	// If
	// the flag is not set, the value can be modified.
	ValueIsReadonly *bool `xml:"valueIsReadonly" json:"valueIsReadonly,omitempty"`
}

func init() {
	t["OptionType"] = reflect.TypeOf((*OptionType)(nil)).Elem()
}

// Describes the key/value pair of a configured option.
type OptionValue struct {
	DynamicData

	// The name of the option using dot notation to reflect the
	// option's position in a hierarchy.
	//
	// For example, you might
	// have an option called "Ethernet" and another option that is
	// a child of that called "Connection". In this case, the key
	// for the latter could be defined as "Ethernet.Connection"
	Key string `xml:"key" json:"key"`
	// The value of the option.
	//
	// The Any data object type enables you to
	// define any value for the option. Typically, however, the value
	// of an option is of type String or Integer.
	Value AnyType `xml:"value,typeattr" json:"value"`
}

func init() {
	t["OptionValue"] = reflect.TypeOf((*OptionValue)(nil)).Elem()
}

// A data object type that links multiple alarm expressions with OR operators.
type OrAlarmExpression struct {
	AlarmExpression

	// List of alarm expressions that define the overall status of the alarm.
	//   - The state of the alarm expression is gray if all subexpressions are gray.
	//     Otherwise, gray subexpressions are ignored.
	//   - The state is red if any subexpression is red.
	//   - Otherwise, the state is yellow if any subexpression is yellow.
	//   - Otherwise, the state of the alarm expression is green.
	Expression []BaseAlarmExpression `xml:"expression,typeattr" json:"expression"`
}

func init() {
	t["OrAlarmExpression"] = reflect.TypeOf((*OrAlarmExpression)(nil)).Elem()
}

// Thrown if a parameter exceeds the acceptable range of values.
type OutOfBounds struct {
	VimFault

	// This should be the name of the field that holds the allowed maximum
	// (for example, Host.capability.maxSupportedVMs).
	ArgumentName string `xml:"argumentName" json:"argumentName"`
}

func init() {
	t["OutOfBounds"] = reflect.TypeOf((*OutOfBounds)(nil)).Elem()
}

type OutOfBoundsFault OutOfBounds

func init() {
	t["OutOfBoundsFault"] = reflect.TypeOf((*OutOfBoundsFault)(nil)).Elem()
}

// The list of hosts that have the DVS configuration on the host
// diverged from that of the Virtual Center Server.
type OutOfSyncDvsHost struct {
	DvsEvent

	// The host that went out of sync.
	HostOutOfSync []DvsOutOfSyncHostArgument `xml:"hostOutOfSync" json:"hostOutOfSync"`
}

func init() {
	t["OutOfSyncDvsHost"] = reflect.TypeOf((*OutOfSyncDvsHost)(nil)).Elem()
}

type OverwriteCustomizationSpec OverwriteCustomizationSpecRequestType

func init() {
	t["OverwriteCustomizationSpec"] = reflect.TypeOf((*OverwriteCustomizationSpec)(nil)).Elem()
}

// The parameters of `CustomizationSpecManager.OverwriteCustomizationSpec`.
type OverwriteCustomizationSpecRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Item CustomizationSpecItem  `xml:"item" json:"item"`
}

func init() {
	t["OverwriteCustomizationSpecRequestType"] = reflect.TypeOf((*OverwriteCustomizationSpecRequestType)(nil)).Elem()
}

type OverwriteCustomizationSpecResponse struct {
}

// An OVF descriptor Attribute base class.
type OvfAttribute struct {
	OvfInvalidPackage

	// Element name where the attribute is defined
	ElementName string `xml:"elementName" json:"elementName"`
	// Attribute name
	AttributeName string `xml:"attributeName" json:"attributeName"`
}

func init() {
	t["OvfAttribute"] = reflect.TypeOf((*OvfAttribute)(nil)).Elem()
}

type OvfAttributeFault BaseOvfAttribute

func init() {
	t["OvfAttributeFault"] = reflect.TypeOf((*OvfAttributeFault)(nil)).Elem()
}

type OvfConnectedDevice struct {
	OvfHardwareExport
}

func init() {
	t["OvfConnectedDevice"] = reflect.TypeOf((*OvfConnectedDevice)(nil)).Elem()
}

type OvfConnectedDeviceFault BaseOvfConnectedDevice

func init() {
	t["OvfConnectedDeviceFault"] = reflect.TypeOf((*OvfConnectedDeviceFault)(nil)).Elem()
}

type OvfConnectedDeviceFloppy struct {
	OvfConnectedDevice

	// The filename of the floppy image
	Filename string `xml:"filename" json:"filename"`
}

func init() {
	t["OvfConnectedDeviceFloppy"] = reflect.TypeOf((*OvfConnectedDeviceFloppy)(nil)).Elem()
}

type OvfConnectedDeviceFloppyFault OvfConnectedDeviceFloppy

func init() {
	t["OvfConnectedDeviceFloppyFault"] = reflect.TypeOf((*OvfConnectedDeviceFloppyFault)(nil)).Elem()
}

type OvfConnectedDeviceIso struct {
	OvfConnectedDevice

	// The filename of the ISO
	Filename string `xml:"filename" json:"filename"`
}

func init() {
	t["OvfConnectedDeviceIso"] = reflect.TypeOf((*OvfConnectedDeviceIso)(nil)).Elem()
}

type OvfConnectedDeviceIsoFault OvfConnectedDeviceIso

func init() {
	t["OvfConnectedDeviceIsoFault"] = reflect.TypeOf((*OvfConnectedDeviceIsoFault)(nil)).Elem()
}

// A base fault for Ovf descriptor constraints
type OvfConstraint struct {
	OvfInvalidPackage

	// The name of the element
	Name string `xml:"name" json:"name"`
}

func init() {
	t["OvfConstraint"] = reflect.TypeOf((*OvfConstraint)(nil)).Elem()
}

type OvfConstraintFault BaseOvfConstraint

func init() {
	t["OvfConstraintFault"] = reflect.TypeOf((*OvfConstraintFault)(nil)).Elem()
}

// Superclass for all faults that can be thrown during the callback to an OVF
// consumer.
//
// The `MethodFault.faultCause` gives details about what went
// wrong.
type OvfConsumerCallbackFault struct {
	OvfFault

	// The OVF consumer's extension key.
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
	// The OVF consumer's extension name.
	ExtensionName string `xml:"extensionName" json:"extensionName"`
}

func init() {
	t["OvfConsumerCallbackFault"] = reflect.TypeOf((*OvfConsumerCallbackFault)(nil)).Elem()
}

type OvfConsumerCallbackFaultFault BaseOvfConsumerCallbackFault

func init() {
	t["OvfConsumerCallbackFaultFault"] = reflect.TypeOf((*OvfConsumerCallbackFaultFault)(nil)).Elem()
}

// A fault type indicating that network communication with an OVF consumer failed.
type OvfConsumerCommunicationError struct {
	OvfConsumerCallbackFault

	// The network library error message.
	Description string `xml:"description" json:"description"`
}

func init() {
	t["OvfConsumerCommunicationError"] = reflect.TypeOf((*OvfConsumerCommunicationError)(nil)).Elem()
}

type OvfConsumerCommunicationErrorFault OvfConsumerCommunicationError

func init() {
	t["OvfConsumerCommunicationErrorFault"] = reflect.TypeOf((*OvfConsumerCommunicationErrorFault)(nil)).Elem()
}

// Localized fault that may be thrown by an OVF consumer.
type OvfConsumerFault struct {
	OvfConsumerCallbackFault

	// An error code that uniquely describes the fault within this extension.
	ErrorKey string `xml:"errorKey" json:"errorKey"`
	// The error message, localized by the OVF consumer
	Message string `xml:"message" json:"message"`
	// Additional parameters for this fault
	Params []KeyValue `xml:"params,omitempty" json:"params,omitempty"`
}

func init() {
	t["OvfConsumerFault"] = reflect.TypeOf((*OvfConsumerFault)(nil)).Elem()
}

type OvfConsumerFaultFault OvfConsumerFault

func init() {
	t["OvfConsumerFaultFault"] = reflect.TypeOf((*OvfConsumerFaultFault)(nil)).Elem()
}

// A fault type indicating that the XML of a section appended by an OVF consumer was
// invalid.
type OvfConsumerInvalidSection struct {
	OvfConsumerCallbackFault

	// The line number in the section on which the error was found.
	LineNumber int32 `xml:"lineNumber" json:"lineNumber"`
	// The XML parser error message.
	Description string `xml:"description" json:"description"`
}

func init() {
	t["OvfConsumerInvalidSection"] = reflect.TypeOf((*OvfConsumerInvalidSection)(nil)).Elem()
}

type OvfConsumerInvalidSectionFault OvfConsumerInvalidSection

func init() {
	t["OvfConsumerInvalidSectionFault"] = reflect.TypeOf((*OvfConsumerInvalidSectionFault)(nil)).Elem()
}

// A node in the OVF section tree.
//
// This class represents a node on which OVF sections can be defined. The possible
// node types are OstNodeType.envelope, OstNodeType.virtualSystem or
// OstNodeType.virtualSystemCollection, corresponding to the identically named OVF
// element types.
//
// Since the node contains a list of children, it can also be regarded as a tree. This
// tree mirrors the structure of the OVF descriptor. It is provided to OVF consumers
// as a more convenient way to navigate and modify the OVF than by working directly on
// the XML.
type OvfConsumerOstNode struct {
	DynamicData

	// The OVF id of the Content (VirtualSystem or VirtualSystemCollection)
	// element.
	//
	// Empty on the envelope node.
	Id string `xml:"id" json:"id"`
	// The type of the node.
	//
	// Possible values are defined in the OstNodeType enum.
	//
	// Since the OstNode tree structure mirrors the structure of the OVF descriptor,
	// only one Envelope node is defined, and it is always the root of the tree.
	Type string `xml:"type" json:"type"`
	// The list of sections on this node.
	Section []OvfConsumerOvfSection `xml:"section,omitempty" json:"section,omitempty"`
	// The list of child nodes.
	//
	// As dictated by OVF, this list is subject to the
	// following rules:
	//   - The Envelope node must have exactly one child.
	//   - VirtualSystemCollection nodes may have zero or more children.
	//   - VirtualSystem nodes must have no children.
	Child []OvfConsumerOstNode `xml:"child,omitempty" json:"child,omitempty"`
	// The VM or vApp corresponding to this node.
	//
	// This field is set when this OstNode represents an existing managed entity.
	//
	// The entity is unset on nodes of type OstNodeType.envelope.
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["OvfConsumerOstNode"] = reflect.TypeOf((*OvfConsumerOstNode)(nil)).Elem()
}

// A self-contained OVF section
type OvfConsumerOvfSection struct {
	DynamicData

	// The line number in the OVF descriptor on which this section starts.
	//
	// The line number is only present on sections that were imported as part of an OVF
	// descriptor (as opposed to sections that are about to be exported to OVF).
	//
	// The value is zero if the section did not originate from an OVF descriptor.
	LineNumber int32 `xml:"lineNumber" json:"lineNumber"`
	// The XML fragment for the section.
	//
	// The XML fragment must explicitly define all namespaces and namespace prefixes
	// that are used in the fragment, including the default namespace.
	Xml string `xml:"xml" json:"xml"`
}

func init() {
	t["OvfConsumerOvfSection"] = reflect.TypeOf((*OvfConsumerOvfSection)(nil)).Elem()
}

// A fault type indicating that the power on operation failed.
type OvfConsumerPowerOnFault struct {
	InvalidState

	// The OVF consumer's extension key.
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
	// The OVF consumer's extension name.
	ExtensionName string `xml:"extensionName" json:"extensionName"`
	// A localized, human-readable description of the error.
	Description string `xml:"description" json:"description"`
}

func init() {
	t["OvfConsumerPowerOnFault"] = reflect.TypeOf((*OvfConsumerPowerOnFault)(nil)).Elem()
}

type OvfConsumerPowerOnFaultFault OvfConsumerPowerOnFault

func init() {
	t["OvfConsumerPowerOnFaultFault"] = reflect.TypeOf((*OvfConsumerPowerOnFaultFault)(nil)).Elem()
}

// A fault type indicating that an OVF consumer appended an undeclared section to an OST.
//
// An undeclared section means a section with a qualified type that the OVF consumer was
// not registered as a handler of.
type OvfConsumerUndeclaredSection struct {
	OvfConsumerCallbackFault

	// The undeclared qualified section type appended by the OVF consumer.
	QualifiedSectionType string `xml:"qualifiedSectionType" json:"qualifiedSectionType"`
}

func init() {
	t["OvfConsumerUndeclaredSection"] = reflect.TypeOf((*OvfConsumerUndeclaredSection)(nil)).Elem()
}

type OvfConsumerUndeclaredSectionFault OvfConsumerUndeclaredSection

func init() {
	t["OvfConsumerUndeclaredSectionFault"] = reflect.TypeOf((*OvfConsumerUndeclaredSectionFault)(nil)).Elem()
}

// A fault type indicating that an OVF consumer added a section with an unbound prefix.
type OvfConsumerUndefinedPrefix struct {
	OvfConsumerCallbackFault

	// The prefix for which no namespace definition was found.
	Prefix string `xml:"prefix" json:"prefix"`
}

func init() {
	t["OvfConsumerUndefinedPrefix"] = reflect.TypeOf((*OvfConsumerUndefinedPrefix)(nil)).Elem()
}

type OvfConsumerUndefinedPrefixFault OvfConsumerUndefinedPrefix

func init() {
	t["OvfConsumerUndefinedPrefixFault"] = reflect.TypeOf((*OvfConsumerUndefinedPrefixFault)(nil)).Elem()
}

// Thrown by an OVF consumer if an error occurred while validating an instantiation OST.
type OvfConsumerValidationFault struct {
	VmConfigFault

	// The OVF consumer's extension key.
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
	// The OVF consumer's extension name.
	ExtensionName string `xml:"extensionName" json:"extensionName"`
	// The error message, localized by the OVF consumer
	Message string `xml:"message" json:"message"`
}

func init() {
	t["OvfConsumerValidationFault"] = reflect.TypeOf((*OvfConsumerValidationFault)(nil)).Elem()
}

type OvfConsumerValidationFaultFault OvfConsumerValidationFault

func init() {
	t["OvfConsumerValidationFaultFault"] = reflect.TypeOf((*OvfConsumerValidationFaultFault)(nil)).Elem()
}

type OvfCpuCompatibility struct {
	OvfImport

	// Possible register names are eax, ebx, ecx, or edx.
	RegisterName string `xml:"registerName" json:"registerName"`
	// The CpuId level where a problem was detected.
	//
	// Other levels may
	// also have problems
	Level int32 `xml:"level" json:"level"`
	// The register value where the problem was detected
	RegisterValue string `xml:"registerValue" json:"registerValue"`
	// The desired register value return from the host
	DesiredRegisterValue string `xml:"desiredRegisterValue" json:"desiredRegisterValue"`
}

func init() {
	t["OvfCpuCompatibility"] = reflect.TypeOf((*OvfCpuCompatibility)(nil)).Elem()
}

type OvfCpuCompatibilityCheckNotSupported struct {
	OvfImport
}

func init() {
	t["OvfCpuCompatibilityCheckNotSupported"] = reflect.TypeOf((*OvfCpuCompatibilityCheckNotSupported)(nil)).Elem()
}

type OvfCpuCompatibilityCheckNotSupportedFault OvfCpuCompatibilityCheckNotSupported

func init() {
	t["OvfCpuCompatibilityCheckNotSupportedFault"] = reflect.TypeOf((*OvfCpuCompatibilityCheckNotSupportedFault)(nil)).Elem()
}

type OvfCpuCompatibilityFault OvfCpuCompatibility

func init() {
	t["OvfCpuCompatibilityFault"] = reflect.TypeOf((*OvfCpuCompatibilityFault)(nil)).Elem()
}

// Collection of parameters for createDescriptor
type OvfCreateDescriptorParams struct {
	DynamicData

	// Contains information about the files of the entity, if they have already been
	// downloaded.
	//
	// Needed to construct the References section of the descriptor.
	//
	// OvfFile is a positive list of files to include in the export. An Empty list
	// will do no filtering.
	OvfFiles []OvfFile `xml:"ovfFiles,omitempty" json:"ovfFiles,omitempty"`
	// The ovf:id to use for the top-level OVF Entity.
	//
	// If unset, the entity's
	// product name is used if available. Otherwise, the VI entity name is used.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// The contents of the Annontation section of the top-level OVF Entity.
	//
	// If unset,
	// any existing annotation on the entity is left unchanged.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// Controls whether attached image files should be included in the descriptor.
	//
	// This applies to image files attached to VirtualCdrom and VirtualFloppy.
	IncludeImageFiles *bool `xml:"includeImageFiles" json:"includeImageFiles,omitempty"`
	// An optional argument for modifying the export process.
	//
	// The option is used to control what extra information that will be included in the
	// OVF descriptor.
	//
	// To get a list of supported keywords see `OvfManager.ovfExportOption`. Unknown
	// options will be ignored by the server.
	ExportOption []string `xml:"exportOption,omitempty" json:"exportOption,omitempty"`
	// Snapshot reference from which the OVF descriptor should be based.
	//
	// If this parameter is set, the OVF descriptor is based off the
	// snapshot point. This means that the OVF descriptor will have the
	// same configuration as the virtual machine at the time the snapshot
	// was taken.
	//
	// The snapshot must be belong to the specified ManagedEntity in the
	// createDescriptor call.
	//
	// Refers instance of `VirtualMachineSnapshot`.
	Snapshot *ManagedObjectReference `xml:"snapshot,omitempty" json:"snapshot,omitempty"`
}

func init() {
	t["OvfCreateDescriptorParams"] = reflect.TypeOf((*OvfCreateDescriptorParams)(nil)).Elem()
}

// The result of creating the OVF descriptor for the entity.
type OvfCreateDescriptorResult struct {
	DynamicData

	// The OVF descriptor for the entity.
	OvfDescriptor string `xml:"ovfDescriptor" json:"ovfDescriptor"`
	// Errors that happened during processing.
	//
	// For example, unknown or unsupported devices could be found (in which case
	// this array will contain one or more instances of Unsupported-/UnknownDevice).
	Error []LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
	// Non-fatal warnings from the processing.
	//
	// The result will be valid, but the user may choose to reject it based on these
	// warnings.
	Warning []LocalizedMethodFault `xml:"warning,omitempty" json:"warning,omitempty"`
	// Returns true if there are ISO or Floppy images attached to one or more VMs.
	IncludeImageFiles *bool `xml:"includeImageFiles" json:"includeImageFiles,omitempty"`
}

func init() {
	t["OvfCreateDescriptorResult"] = reflect.TypeOf((*OvfCreateDescriptorResult)(nil)).Elem()
}

// Parameters for deploying an OVF.
type OvfCreateImportSpecParams struct {
	OvfManagerCommonParams

	// The name to set on the entity (more precisely, on the top-level vApp or
	// VM of the entity) as it appears in VI.
	//
	// If empty, the product name is obtained
	// from the ProductSection of the descriptor. If that name is not specified, the
	// ovf:id of the top-level entity is used.
	EntityName string `xml:"entityName" json:"entityName"`
	// The host to validate the OVF descriptor against, if it cannot be deduced from
	// the resource pool.
	//
	// The privilege System.Read is required on the host.
	//
	// Refers instance of `HostSystem`.
	HostSystem *ManagedObjectReference `xml:"hostSystem,omitempty" json:"hostSystem,omitempty"`
	// The mapping of network identifiers from the descriptor to networks in the VI
	// infrastructure.
	//
	// The privilege Network.Assign is required on all networks in the list.
	NetworkMapping []OvfNetworkMapping `xml:"networkMapping,omitempty" json:"networkMapping,omitempty"`
	// The IP allocation policy chosen by the caller.
	//
	// See `VAppIPAssignmentInfo`.
	IpAllocationPolicy string `xml:"ipAllocationPolicy,omitempty" json:"ipAllocationPolicy,omitempty"`
	// The IP protocol chosen by the caller.
	//
	// See `VAppIPAssignmentInfo`.
	IpProtocol string `xml:"ipProtocol,omitempty" json:"ipProtocol,omitempty"`
	// The assignment of values to the properties found in the descriptor.
	//
	// If no value
	// is specified for an option, the default value from the descriptor is used.
	PropertyMapping []KeyValue `xml:"propertyMapping,omitempty" json:"propertyMapping,omitempty"`
	// Deprecated as of vSphere API 5.1.
	//
	// The resource configuration for the created vApp.
	//
	// This can be used to distribute
	// a vApp across multiple resource pools (and create linked children).
	ResourceMapping []OvfResourceMap `xml:"resourceMapping,omitempty" json:"resourceMapping,omitempty"`
	// An optional disk provisioning.
	//
	// If set, all the disks in the deployed OVF will
	// have get the same specified disk type (e.g., thin provisioned).
	// The valide values for disk provisioning are:
	//   - `monolithicSparse`
	//   - `monolithicFlat`
	//   - `twoGbMaxExtentSparse`
	//   - `twoGbMaxExtentFlat`
	//   - `thin`
	//   - `thick`
	//   - `sparse`
	//   - `flat`
	//   - `seSparse`
	//
	// See also `VirtualDiskMode_enum`.
	DiskProvisioning string `xml:"diskProvisioning,omitempty" json:"diskProvisioning,omitempty"`
	// The instantiation OST to configure OVF consumers.
	//
	// This is created by the client
	// from the annotated OST. See `OvfConsumer` for details.
	InstantiationOst *OvfConsumerOstNode `xml:"instantiationOst,omitempty" json:"instantiationOst,omitempty"`
}

func init() {
	t["OvfCreateImportSpecParams"] = reflect.TypeOf((*OvfCreateImportSpecParams)(nil)).Elem()
}

// The CreateImportSpecResult contains all information regarding the import that can
// be extracted from the OVF descriptor.
//
// For example, this includes the list of items that the caller must upload in order
// to complete the import, but not the list of URLs to which the files must be
// uploaded. These paths are not known until the VMs have been created, ie. until
// `ResourcePool.importVApp` has been
// called.
type OvfCreateImportSpecResult struct {
	DynamicData

	// The ImportSpec contains information about which `VirtualMachine`s
	// and `VirtualApp`s are present in the entity and
	// how they relate to each other.
	ImportSpec BaseImportSpec `xml:"importSpec,omitempty,typeattr" json:"importSpec,omitempty"`
	// The files that must be uploaded by the caller as part of importing the entity.
	//
	// The files must be uploaded in order, because some of them may be delta files
	// that patch already-uploaded files.
	FileItem []OvfFileItem `xml:"fileItem,omitempty" json:"fileItem,omitempty"`
	// Non-fatal warnings from the processing.
	//
	// The ImportSpec will be valid, but the
	// user may choose to reject it based on these warnings.
	Warning []LocalizedMethodFault `xml:"warning,omitempty" json:"warning,omitempty"`
	// Errors that happened during processing.
	//
	// Something will be wrong with the
	// ImportSpec, or it is not present.
	Error []LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
}

func init() {
	t["OvfCreateImportSpecResult"] = reflect.TypeOf((*OvfCreateImportSpecResult)(nil)).Elem()
}

// A deployment option as defined in the OVF specfication.
//
// This corresponds to the Configuration element of the DeploymentOptionSection in the
// specification.
type OvfDeploymentOption struct {
	DynamicData

	// The key of the deployment option, corresponding to the ovf:id attribute in the
	// OVF descriptor
	Key string `xml:"key" json:"key"`
	// A localized label for the deployment option
	Label string `xml:"label" json:"label"`
	// A localizable description for the deployment option.
	Description string `xml:"description" json:"description"`
}

func init() {
	t["OvfDeploymentOption"] = reflect.TypeOf((*OvfDeploymentOption)(nil)).Elem()
}

type OvfDiskMappingNotFound struct {
	OvfSystemFault

	// The disk name that is not found
	DiskName string `xml:"diskName" json:"diskName"`
	// The VM Name
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["OvfDiskMappingNotFound"] = reflect.TypeOf((*OvfDiskMappingNotFound)(nil)).Elem()
}

type OvfDiskMappingNotFoundFault OvfDiskMappingNotFound

func init() {
	t["OvfDiskMappingNotFoundFault"] = reflect.TypeOf((*OvfDiskMappingNotFoundFault)(nil)).Elem()
}

// Class used to indicate that the Disks in a DiskSection was not defined
// in the same order as in the Reference section
type OvfDiskOrderConstraint struct {
	OvfConstraint
}

func init() {
	t["OvfDiskOrderConstraint"] = reflect.TypeOf((*OvfDiskOrderConstraint)(nil)).Elem()
}

type OvfDiskOrderConstraintFault OvfDiskOrderConstraint

func init() {
	t["OvfDiskOrderConstraintFault"] = reflect.TypeOf((*OvfDiskOrderConstraintFault)(nil)).Elem()
}

// OvfDuplicateElement is thrown if Ovf descriptor contains an invalid duplicate element.
type OvfDuplicateElement struct {
	OvfElement
}

func init() {
	t["OvfDuplicateElement"] = reflect.TypeOf((*OvfDuplicateElement)(nil)).Elem()
}

type OvfDuplicateElementFault OvfDuplicateElement

func init() {
	t["OvfDuplicateElementFault"] = reflect.TypeOf((*OvfDuplicateElementFault)(nil)).Elem()
}

// If the Ovf descriptor element have duplicated element bound.
type OvfDuplicatedElementBoundary struct {
	OvfElement

	// Name of duplicated boundary
	Boundary string `xml:"boundary" json:"boundary"`
}

func init() {
	t["OvfDuplicatedElementBoundary"] = reflect.TypeOf((*OvfDuplicatedElementBoundary)(nil)).Elem()
}

type OvfDuplicatedElementBoundaryFault OvfDuplicatedElementBoundary

func init() {
	t["OvfDuplicatedElementBoundaryFault"] = reflect.TypeOf((*OvfDuplicatedElementBoundaryFault)(nil)).Elem()
}

// Two or more user-configurable properties are
// found with the same fully-qualified property
// name.
type OvfDuplicatedPropertyIdExport struct {
	OvfExport

	// The fully qualified property id.
	Fqid string `xml:"fqid" json:"fqid"`
}

func init() {
	t["OvfDuplicatedPropertyIdExport"] = reflect.TypeOf((*OvfDuplicatedPropertyIdExport)(nil)).Elem()
}

type OvfDuplicatedPropertyIdExportFault OvfDuplicatedPropertyIdExport

func init() {
	t["OvfDuplicatedPropertyIdExportFault"] = reflect.TypeOf((*OvfDuplicatedPropertyIdExportFault)(nil)).Elem()
}

// Two or more user-configurable properties are
// found with the same fully-qualified property
// name.
type OvfDuplicatedPropertyIdImport struct {
	OvfExport
}

func init() {
	t["OvfDuplicatedPropertyIdImport"] = reflect.TypeOf((*OvfDuplicatedPropertyIdImport)(nil)).Elem()
}

type OvfDuplicatedPropertyIdImportFault OvfDuplicatedPropertyIdImport

func init() {
	t["OvfDuplicatedPropertyIdImportFault"] = reflect.TypeOf((*OvfDuplicatedPropertyIdImportFault)(nil)).Elem()
}

// A base fault for element exceptions in the Ovf XML descriptor.
type OvfElement struct {
	OvfInvalidPackage

	// The name of the element
	Name string `xml:"name" json:"name"`
}

func init() {
	t["OvfElement"] = reflect.TypeOf((*OvfElement)(nil)).Elem()
}

type OvfElementFault BaseOvfElement

func init() {
	t["OvfElementFault"] = reflect.TypeOf((*OvfElementFault)(nil)).Elem()
}

// A class used if a element node is found to have an invalid value.
//
// Base class for OvfProperty errors.
type OvfElementInvalidValue struct {
	OvfElement

	// The value of the element
	Value string `xml:"value" json:"value"`
}

func init() {
	t["OvfElementInvalidValue"] = reflect.TypeOf((*OvfElementInvalidValue)(nil)).Elem()
}

type OvfElementInvalidValueFault OvfElementInvalidValue

func init() {
	t["OvfElementInvalidValueFault"] = reflect.TypeOf((*OvfElementInvalidValueFault)(nil)).Elem()
}

// A common base class to host all the Ovf Lib Export Exceptions.
type OvfExport struct {
	OvfFault
}

func init() {
	t["OvfExport"] = reflect.TypeOf((*OvfExport)(nil)).Elem()
}

// This fault is used if we fail to export an OVF package.
type OvfExportFailed struct {
	OvfExport
}

func init() {
	t["OvfExportFailed"] = reflect.TypeOf((*OvfExportFailed)(nil)).Elem()
}

type OvfExportFailedFault OvfExportFailed

func init() {
	t["OvfExportFailedFault"] = reflect.TypeOf((*OvfExportFailedFault)(nil)).Elem()
}

type OvfExportFault BaseOvfExport

func init() {
	t["OvfExportFault"] = reflect.TypeOf((*OvfExportFault)(nil)).Elem()
}

// A common base type fault for all Ovf related faults.
//
// The structure of OvfFault is as listed.
//   - OvfFault
//   - OvfInvalidPackage
//   - OvfXmlFormat
//   - OvfWrongNamespace
//   - OvfElement
//   - OvfElementInvalidValue
//   - OvfUnexpectedElement
//   - OvfDuplicateElement
//   - OvfMissingElement
//   - OvfMissingElementNormalBoundary
//   - OvfDuplicatedElementBoundary
//   - OvfAttribute
//   - OvfMissingAttribute
//   - OvfInvalidValue
//   - OvfInvalidValueFormatMalformed
//   - OvfInvalidValueConfiguration
//   - OvfInvalidValueReference
//   - OvfInvalidValueEmpty
//   - OvfProperty
//   - OvfPropertyType
//   - OvfPropertyValue
//   - OvfPropertyNetwork
//   - OvfPropertyQualifier
//   - OvfPropertyQualifierWarning
//   - OvfConstraint
//   - OvfDiskOrderConstraint
//   - OvfHostResourceConstraint
//   - OvfUnsupportedPackage
//   - OvfNoHostNic
//   - OvfInvalidVmName
//   - OvfUnsupportedAttribute
//   - OvfUnsupportedAttributeValue
//   - OvfUnsupportedElement
//   - OvfUnsupportedElementValue
//   - OvfUnsupportedSection
//   - OvfNoSpaceOnController
//   - OvfUnsupportedType
//   - OvfUnsupportedSubType
//   - OvfHardwareCheck
//   - OvfNoSupportedHardwareFamily
//   - OvfExport
//   - OvfExportFailed
//   - OvfHardwareExport
//   - OvfUnsupportedDeviceExport
//   - OvfUnknownDeviceBacking
//   - OvfConnectedDevice
//   - OvfConnectedDeviceISO
//   - OvfUnableToExportDisk
//   - OvfPropertyExport
//   - OvfPropertyNetworkExport
//   - OvfDuplicatedPropertyIdExport
//   - OvfImport (these are typically returned as warnings)
//   - OvfImportFailed
//   - OvfHardwareCheck
//   - OvfMissingHardware
//   - OvfCpuCompatibility
//   - OvfCpuCompatibilityCheckNotSupported
//   - OvfUnsupportedDiskProvisioning
//   - OvfDuplicatedPropertyIdImport
//   - OvfNetworkMappingNotSupported
//   - OvfSystemFault
//   - OvfDiskMappingNotFound
//   - OvfHostValueNotParsed
//   - OvfInternalError
//   - OvfUnsupportedDeviceBackingOption
//   - OvfUnsupportedDeviceBackingInfo
//   - OvfToXmlUnsupportedElement
//   - OvfUnknownDevice
//   - OvfUnknownEntity
//   - OvfConsumerCallbackFault
//   - OvfConsumerFault
//   - OvfConsumerCommunicationError
//   - OvfConsumerInvalidSection
//   - OvfConsumerUndeclaredSection
//   - OvfConsumerUndefinedPrefix
//
// All messages go into the vimlocale
type OvfFault struct {
	VimFault
}

func init() {
	t["OvfFault"] = reflect.TypeOf((*OvfFault)(nil)).Elem()
}

type OvfFaultFault BaseOvfFault

func init() {
	t["OvfFaultFault"] = reflect.TypeOf((*OvfFaultFault)(nil)).Elem()
}

// Represents a file that the caller has downloaded and stored somewhere appropriate.
//
// An instance of this class is used to tell OvfManager about the choices the caller
// made about a file. This information is needed when the OVF descriptor is generated
// with createDescriptor.
type OvfFile struct {
	DynamicData

	// The ID of the device backed by this file.
	//
	// This ID uniquely identifies the
	// device within the entity hierarchy.
	//
	// The caller will have received this along with the URL needed to download the
	// file (this is handled by another service interface).
	DeviceId string `xml:"deviceId" json:"deviceId"`
	// The path chosen by the caller for this file.
	//
	// This path becomes the value of the
	// "href" attribute of the corresponding "File" element in the OVF descriptor.
	//
	// This path must be relative to the path chosen for the OVF descriptor. This
	// implies that the caller must decide in advance on the path to which it will
	// write the OVF descriptor, once it is returned.
	//
	// The folder separator must be "/" (forward slash).
	//
	// The path must not begin with a slash - ie. it must not be an absolute path.
	Path string `xml:"path" json:"path"`
	// The compression method the caller chose to employ for this file.
	CompressionMethod string `xml:"compressionMethod,omitempty" json:"compressionMethod,omitempty"`
	// The chunksize chosen by the caller.
	//
	// When using chunking, the caller must adhere to the method described in the OVF
	// specification.
	ChunkSize int64 `xml:"chunkSize,omitempty" json:"chunkSize,omitempty"`
	// The file size, as observed by the caller during download.
	Size int64 `xml:"size" json:"size"`
	// The capacity of the disk backed by this file.
	//
	// This should only be set if the
	// device backed by this file is a disk. This value will be written in the
	// "capacity" attribute of the corresponding "Disk" element in the OVF descriptor.
	//
	// Note that the "capacity" attribute is normally set to the capacity of the
	// corresponding `VirtualDisk`. Setting this variable
	// overrides the capacity from the VirtualDisk.
	Capacity int64 `xml:"capacity,omitempty" json:"capacity,omitempty"`
	// The populated size of the disk backed by this file.
	//
	// This should only be set if
	// the device backed by this file is a disk. This value will be written in the
	// "populatedSize" attribute of the corresponding "Disk" element in the OVF
	// descriptor.
	PopulatedSize int64 `xml:"populatedSize,omitempty" json:"populatedSize,omitempty"`
}

func init() {
	t["OvfFile"] = reflect.TypeOf((*OvfFile)(nil)).Elem()
}

// An FileItem represents a file that must be uploaded by the caller when the
// inventory objects has been created in VI.
//
// These objects are created by `ResourcePool.importVApp`.
//
// Files can either be new files, in which case the "create" flag will be true, or
// updates to existing files in VI. The latter is used to support the OVF parentRef
// mechanism for Disks.
type OvfFileItem struct {
	DynamicData

	// Uniquely identifies the device (disk, CD-ROM etc.) within the entity hierarchy.
	//
	// When `ResourcePool.importVApp` is
	// called to create the `VirtualMachine`s and `VirtualApp`s, it returns a map,
	// device ID -&gt; URL, of where to upload the backing files.
	DeviceId string `xml:"deviceId" json:"deviceId"`
	// The path of the item to upload, relative to the path of the OVF descriptor.
	Path string `xml:"path" json:"path"`
	// The compression method as specified by the OVF
	// specification (for example "gzip" or "bzip2").
	CompressionMethod string `xml:"compressionMethod,omitempty" json:"compressionMethod,omitempty"`
	// The chunksize as specified by the OVF specification.
	//
	// If this attribute is set, the "path" attribute is a prefix to
	// each chunk of the complete file.
	// For example, if chunksize is 2000000000 bytes, the actual files
	// might be:
	// myfile.000000000 (2000000000 bytes)
	// myfile.000000001 (2000000000 bytes)
	// myfile.000000002 (1500000000 bytes)
	ChunkSize int64 `xml:"chunkSize,omitempty" json:"chunkSize,omitempty"`
	// The complete size of the file, if it is specified in the
	// OVF descriptor.
	Size int64 `xml:"size,omitempty" json:"size,omitempty"`
	// The CIM type of the device for which this file provides
	// backing.
	//
	// For example, the value 17 means "Disk drive".
	CimType int32 `xml:"cimType" json:"cimType"`
	// True if the item is not expected to exist in the infrastructure
	// and should therefore be created by the caller (for example using HTTP PUT).
	Create bool `xml:"create" json:"create"`
}

func init() {
	t["OvfFileItem"] = reflect.TypeOf((*OvfFileItem)(nil)).Elem()
}

type OvfHardwareCheck struct {
	OvfImport
}

func init() {
	t["OvfHardwareCheck"] = reflect.TypeOf((*OvfHardwareCheck)(nil)).Elem()
}

type OvfHardwareCheckFault OvfHardwareCheck

func init() {
	t["OvfHardwareCheckFault"] = reflect.TypeOf((*OvfHardwareCheckFault)(nil)).Elem()
}

// A common base class to host all the OvfLib Export Exceptions for hardware.
type OvfHardwareExport struct {
	OvfExport

	// The virtual device we are exporting to OVF
	Device BaseVirtualDevice `xml:"device,omitempty,typeattr" json:"device,omitempty"`
	// The path to the VM containing the device.
	//
	// This path shows the location of the VM in the vApp hierarchy, on the form:
	//
	// /ParentVApp/ChildVApp/VMName
	VmPath string `xml:"vmPath" json:"vmPath"`
}

func init() {
	t["OvfHardwareExport"] = reflect.TypeOf((*OvfHardwareExport)(nil)).Elem()
}

type OvfHardwareExportFault BaseOvfHardwareExport

func init() {
	t["OvfHardwareExportFault"] = reflect.TypeOf((*OvfHardwareExportFault)(nil)).Elem()
}

// Class used to indicate that the value in HostResoruce did not map to
// a valid reference element.
type OvfHostResourceConstraint struct {
	OvfConstraint

	// Value of the element
	Value string `xml:"value" json:"value"`
}

func init() {
	t["OvfHostResourceConstraint"] = reflect.TypeOf((*OvfHostResourceConstraint)(nil)).Elem()
}

type OvfHostResourceConstraintFault OvfHostResourceConstraint

func init() {
	t["OvfHostResourceConstraintFault"] = reflect.TypeOf((*OvfHostResourceConstraintFault)(nil)).Elem()
}

type OvfHostValueNotParsed struct {
	OvfSystemFault

	// The host property field that could not be parsed.
	Property string `xml:"property" json:"property"`
	// Value of the field that could not be parsed.
	Value string `xml:"value" json:"value"`
}

func init() {
	t["OvfHostValueNotParsed"] = reflect.TypeOf((*OvfHostValueNotParsed)(nil)).Elem()
}

type OvfHostValueNotParsedFault OvfHostValueNotParsed

func init() {
	t["OvfHostValueNotParsedFault"] = reflect.TypeOf((*OvfHostValueNotParsedFault)(nil)).Elem()
}

// A common base class for errors that can happen during Import and
// that is not due to an invalid package (OvfInvalidPackage).
//
// These
// are typically issued as warnings.
type OvfImport struct {
	OvfFault
}

func init() {
	t["OvfImport"] = reflect.TypeOf((*OvfImport)(nil)).Elem()
}

// This fault is used if we fail to deploy an OVF package.
type OvfImportFailed struct {
	OvfImport
}

func init() {
	t["OvfImportFailed"] = reflect.TypeOf((*OvfImportFailed)(nil)).Elem()
}

type OvfImportFailedFault OvfImportFailed

func init() {
	t["OvfImportFailedFault"] = reflect.TypeOf((*OvfImportFailedFault)(nil)).Elem()
}

type OvfImportFault BaseOvfImport

func init() {
	t["OvfImportFault"] = reflect.TypeOf((*OvfImportFault)(nil)).Elem()
}

// Disk mode not supported
type OvfInternalError struct {
	OvfSystemFault
}

func init() {
	t["OvfInternalError"] = reflect.TypeOf((*OvfInternalError)(nil)).Elem()
}

type OvfInternalErrorFault OvfInternalError

func init() {
	t["OvfInternalErrorFault"] = reflect.TypeOf((*OvfInternalErrorFault)(nil)).Elem()
}

// Base fault class for all Invalid OVF package faults.
type OvfInvalidPackage struct {
	OvfFault

	// XML OVF descriptor line numbers
	LineNumber int32 `xml:"lineNumber" json:"lineNumber"`
}

func init() {
	t["OvfInvalidPackage"] = reflect.TypeOf((*OvfInvalidPackage)(nil)).Elem()
}

type OvfInvalidPackageFault BaseOvfInvalidPackage

func init() {
	t["OvfInvalidPackageFault"] = reflect.TypeOf((*OvfInvalidPackageFault)(nil)).Elem()
}

// If an invalid value is found in the Ovf descriptor we throw an OvfInvalidValue exception.
type OvfInvalidValue struct {
	OvfAttribute

	// Attribute value
	Value string `xml:"value" json:"value"`
}

func init() {
	t["OvfInvalidValue"] = reflect.TypeOf((*OvfInvalidValue)(nil)).Elem()
}

// If an malformed ovf:configuration attribute value is found in the
// Ovf descriptor we throw an OvfInvalidValueConfiguration exception.
type OvfInvalidValueConfiguration struct {
	OvfInvalidValue
}

func init() {
	t["OvfInvalidValueConfiguration"] = reflect.TypeOf((*OvfInvalidValueConfiguration)(nil)).Elem()
}

type OvfInvalidValueConfigurationFault OvfInvalidValueConfiguration

func init() {
	t["OvfInvalidValueConfigurationFault"] = reflect.TypeOf((*OvfInvalidValueConfigurationFault)(nil)).Elem()
}

// If an attribute is found with an empty value where it is not allowed.
type OvfInvalidValueEmpty struct {
	OvfInvalidValue
}

func init() {
	t["OvfInvalidValueEmpty"] = reflect.TypeOf((*OvfInvalidValueEmpty)(nil)).Elem()
}

type OvfInvalidValueEmptyFault OvfInvalidValueEmpty

func init() {
	t["OvfInvalidValueEmptyFault"] = reflect.TypeOf((*OvfInvalidValueEmptyFault)(nil)).Elem()
}

type OvfInvalidValueFault BaseOvfInvalidValue

func init() {
	t["OvfInvalidValueFault"] = reflect.TypeOf((*OvfInvalidValueFault)(nil)).Elem()
}

// If an malformed value is found in the Ovf descriptor we throw an OvfInvalidValueFormatMalformed
// exception.
type OvfInvalidValueFormatMalformed struct {
	OvfInvalidValue
}

func init() {
	t["OvfInvalidValueFormatMalformed"] = reflect.TypeOf((*OvfInvalidValueFormatMalformed)(nil)).Elem()
}

type OvfInvalidValueFormatMalformedFault OvfInvalidValueFormatMalformed

func init() {
	t["OvfInvalidValueFormatMalformedFault"] = reflect.TypeOf((*OvfInvalidValueFormatMalformedFault)(nil)).Elem()
}

// If a value refer to something that is not found is found in the Ovf descriptor
// we throw an OvfInvalidValueReference exception.
type OvfInvalidValueReference struct {
	OvfInvalidValue
}

func init() {
	t["OvfInvalidValueReference"] = reflect.TypeOf((*OvfInvalidValueReference)(nil)).Elem()
}

type OvfInvalidValueReferenceFault OvfInvalidValueReference

func init() {
	t["OvfInvalidValueReferenceFault"] = reflect.TypeOf((*OvfInvalidValueReferenceFault)(nil)).Elem()
}

// This fault is used if we can not normalize the vm name
type OvfInvalidVmName struct {
	OvfUnsupportedPackage

	// The name of the invalid Virtual Machine
	Name string `xml:"name" json:"name"`
}

func init() {
	t["OvfInvalidVmName"] = reflect.TypeOf((*OvfInvalidVmName)(nil)).Elem()
}

type OvfInvalidVmNameFault OvfInvalidVmName

func init() {
	t["OvfInvalidVmNameFault"] = reflect.TypeOf((*OvfInvalidVmNameFault)(nil)).Elem()
}

// A common super-class for basic OVF descriptor parameters
type OvfManagerCommonParams struct {
	DynamicData

	// The locale-identifier to choose from the descriptor.
	//
	// If empty, the
	// default locale on the server is used.
	Locale string `xml:"locale" json:"locale"`
	// The key of the chosen deployment option.
	//
	// If empty, the default option is
	// chosen. The list of possible deployment options is returned in the result of
	// parseDescriptor.
	DeploymentOption string `xml:"deploymentOption" json:"deploymentOption"`
	// An optional set of localization strings to be used.
	//
	// The server will use
	// these message strings to localize information in the result and in
	// error and warning messages.
	//
	// This argument allows a client to pass messages from external
	// string bundles. The client is responsible for selecting the right string
	// bundle (based on locale) and parsing the external string bundle. The
	// passed in key/value pairs are looked up before any messages
	// included in the OVF descriptor itself.
	MsgBundle []KeyValue `xml:"msgBundle,omitempty" json:"msgBundle,omitempty"`
	// An optional argument for modifing the OVF parsing.
	//
	// When the server parses an OVF
	// descriptor a set of options can be used to modify the parsing. The argument is a list
	// of keywords.
	//
	// To get a list of supported keywords see `OvfManager.ovfImportOption`. Unknown
	// options will be ignored by the server.
	ImportOption []string `xml:"importOption,omitempty" json:"importOption,omitempty"`
}

func init() {
	t["OvfManagerCommonParams"] = reflect.TypeOf((*OvfManagerCommonParams)(nil)).Elem()
}

type OvfMappedOsId struct {
	OvfImport

	// The operating system id specified in the OVF descriptor.
	OvfId int32 `xml:"ovfId" json:"ovfId"`
	// The OS description specified in the OVF descriptor.
	OvfDescription string `xml:"ovfDescription" json:"ovfDescription"`
	// The display name of the target OS
	TargetDescription string `xml:"targetDescription" json:"targetDescription"`
}

func init() {
	t["OvfMappedOsId"] = reflect.TypeOf((*OvfMappedOsId)(nil)).Elem()
}

type OvfMappedOsIdFault OvfMappedOsId

func init() {
	t["OvfMappedOsIdFault"] = reflect.TypeOf((*OvfMappedOsIdFault)(nil)).Elem()
}

// If the Ovf descriptor is missing an attribute this exception is thrown.
type OvfMissingAttribute struct {
	OvfAttribute
}

func init() {
	t["OvfMissingAttribute"] = reflect.TypeOf((*OvfMissingAttribute)(nil)).Elem()
}

type OvfMissingAttributeFault OvfMissingAttribute

func init() {
	t["OvfMissingAttributeFault"] = reflect.TypeOf((*OvfMissingAttributeFault)(nil)).Elem()
}

// If the Ovf descriptor is missing an Element this exception is thrown.
type OvfMissingElement struct {
	OvfElement
}

func init() {
	t["OvfMissingElement"] = reflect.TypeOf((*OvfMissingElement)(nil)).Elem()
}

type OvfMissingElementFault BaseOvfMissingElement

func init() {
	t["OvfMissingElementFault"] = reflect.TypeOf((*OvfMissingElementFault)(nil)).Elem()
}

// If the Ovf descriptor element normal boundary is not met this exception is thrown.
type OvfMissingElementNormalBoundary struct {
	OvfMissingElement

	// The missing bound
	Boundary string `xml:"boundary" json:"boundary"`
}

func init() {
	t["OvfMissingElementNormalBoundary"] = reflect.TypeOf((*OvfMissingElementNormalBoundary)(nil)).Elem()
}

type OvfMissingElementNormalBoundaryFault OvfMissingElementNormalBoundary

func init() {
	t["OvfMissingElementNormalBoundaryFault"] = reflect.TypeOf((*OvfMissingElementNormalBoundaryFault)(nil)).Elem()
}

// The OVF descriptor does not have a description of
// a required hardware element e.g CPU, Memory
type OvfMissingHardware struct {
	OvfImport

	// Name of the missing hardware.
	Name string `xml:"name" json:"name"`
	// OVF rasd resource type of the missing hardware.
	ResourceType int32 `xml:"resourceType" json:"resourceType"`
}

func init() {
	t["OvfMissingHardware"] = reflect.TypeOf((*OvfMissingHardware)(nil)).Elem()
}

type OvfMissingHardwareFault OvfMissingHardware

func init() {
	t["OvfMissingHardwareFault"] = reflect.TypeOf((*OvfMissingHardwareFault)(nil)).Elem()
}

// The name and description of a network as specified by the OVF descriptor.
type OvfNetworkInfo struct {
	DynamicData

	Name        string `xml:"name" json:"name"`
	Description string `xml:"description" json:"description"`
}

func init() {
	t["OvfNetworkInfo"] = reflect.TypeOf((*OvfNetworkInfo)(nil)).Elem()
}

// A NetworkMapping is a choice made by the caller about which VI network to use for a
// specific network in the OVF descriptor.
type OvfNetworkMapping struct {
	DynamicData

	Name string `xml:"name" json:"name"`
	// Refers instance of `Network`.
	Network ManagedObjectReference `xml:"network" json:"network"`
}

func init() {
	t["OvfNetworkMapping"] = reflect.TypeOf((*OvfNetworkMapping)(nil)).Elem()
}

// The network mapping provided for OVF Import
// is not supported by any hosts
type OvfNetworkMappingNotSupported struct {
	OvfImport
}

func init() {
	t["OvfNetworkMappingNotSupported"] = reflect.TypeOf((*OvfNetworkMappingNotSupported)(nil)).Elem()
}

type OvfNetworkMappingNotSupportedFault OvfNetworkMappingNotSupported

func init() {
	t["OvfNetworkMappingNotSupportedFault"] = reflect.TypeOf((*OvfNetworkMappingNotSupportedFault)(nil)).Elem()
}

// This fault is used if there is no network defined on host
type OvfNoHostNic struct {
	OvfUnsupportedPackage
}

func init() {
	t["OvfNoHostNic"] = reflect.TypeOf((*OvfNoHostNic)(nil)).Elem()
}

type OvfNoHostNicFault OvfNoHostNic

func init() {
	t["OvfNoHostNicFault"] = reflect.TypeOf((*OvfNoHostNicFault)(nil)).Elem()
}

// If the hardware element (RASD) point to a parent controller where there is no
// space left.
type OvfNoSpaceOnController struct {
	OvfUnsupportedElement

	// The parent reference
	Parent string `xml:"parent" json:"parent"`
}

func init() {
	t["OvfNoSpaceOnController"] = reflect.TypeOf((*OvfNoSpaceOnController)(nil)).Elem()
}

type OvfNoSpaceOnControllerFault OvfNoSpaceOnController

func init() {
	t["OvfNoSpaceOnControllerFault"] = reflect.TypeOf((*OvfNoSpaceOnControllerFault)(nil)).Elem()
}

type OvfNoSupportedHardwareFamily struct {
	OvfUnsupportedPackage

	// Version found that was not supported
	Version string `xml:"version" json:"version"`
}

func init() {
	t["OvfNoSupportedHardwareFamily"] = reflect.TypeOf((*OvfNoSupportedHardwareFamily)(nil)).Elem()
}

type OvfNoSupportedHardwareFamilyFault OvfNoSupportedHardwareFamily

func init() {
	t["OvfNoSupportedHardwareFamilyFault"] = reflect.TypeOf((*OvfNoSupportedHardwareFamilyFault)(nil)).Elem()
}

// Represents the OVF options the server support for import and export of
// OVFs
type OvfOptionInfo struct {
	DynamicData

	// The name of the OVF option that is supported by the server
	Option string `xml:"option" json:"option"`
	// A description of the OVF option
	Description LocalizableMessage `xml:"description" json:"description"`
}

func init() {
	t["OvfOptionInfo"] = reflect.TypeOf((*OvfOptionInfo)(nil)).Elem()
}

type OvfParseDescriptorParams struct {
	OvfManagerCommonParams
}

func init() {
	t["OvfParseDescriptorParams"] = reflect.TypeOf((*OvfParseDescriptorParams)(nil)).Elem()
}

type OvfParseDescriptorResult struct {
	DynamicData

	// The list of all EULAs contained in the OVF
	Eula []string `xml:"eula,omitempty" json:"eula,omitempty"`
	// The list of networks required by the OVF
	Network []OvfNetworkInfo `xml:"network,omitempty" json:"network,omitempty"`
	// The kind of IP allocation supported by the guest.
	//
	// See `VAppIPAssignmentInfo`.
	IpAllocationScheme []string `xml:"ipAllocationScheme,omitempty" json:"ipAllocationScheme,omitempty"`
	// The IP protocols supported by the guest.
	//
	// See `VAppIPAssignmentInfo`.
	IpProtocols []string `xml:"ipProtocols,omitempty" json:"ipProtocols,omitempty"`
	// Metadata about the properties contained in the OVF
	Property []VAppPropertyInfo `xml:"property,omitempty" json:"property,omitempty"`
	// The product info contained in the OVF
	ProductInfo *VAppProductInfo `xml:"productInfo,omitempty" json:"productInfo,omitempty"`
	// The annotation info contained in the OVF
	Annotation string `xml:"annotation" json:"annotation"`
	// The OVF Manager's best guess as to the total amount
	// of data that must be transferred to download the entity.
	//
	// This may be inaccurate due to disk compression etc.
	ApproximateDownloadSize int64 `xml:"approximateDownloadSize,omitempty" json:"approximateDownloadSize,omitempty"`
	// The OVF Manager's best guess as to the total amount of space required to deploy
	// the entity if using flat disks.
	ApproximateFlatDeploymentSize int64 `xml:"approximateFlatDeploymentSize,omitempty" json:"approximateFlatDeploymentSize,omitempty"`
	// The OVF Manager's best guess as to the total amount of space required to deploy
	// the entity using sparse disks.
	ApproximateSparseDeploymentSize int64 `xml:"approximateSparseDeploymentSize,omitempty" json:"approximateSparseDeploymentSize,omitempty"`
	// The default name to use for the entity, if a product name is not
	// specified.
	//
	// This is the ID of the OVF top-level entity, or taken from a
	// ProductSection.
	DefaultEntityName string `xml:"defaultEntityName" json:"defaultEntityName"`
	// True if the OVF contains a vApp (containing one or more vApps
	// and/or virtual machines), as opposed to a single virtual machine.
	VirtualApp bool `xml:"virtualApp" json:"virtualApp"`
	// The list of possible deployment options.
	DeploymentOption []OvfDeploymentOption `xml:"deploymentOption,omitempty" json:"deploymentOption,omitempty"`
	// The key of the default deployment option.
	//
	// Empty only if there are no
	// deployment options.
	DefaultDeploymentOption string `xml:"defaultDeploymentOption" json:"defaultDeploymentOption"`
	// A list of the child entities contained in this package
	// and their location in the vApp hierarchy.
	//
	// Each entry is a
	// (key,value) pair, where the key is the display name, and
	// the value is a unique path identifier for the entity in
	// the vApp. The path is constructed by appending the id
	// of each entity of the path down to the entity, separated
	// by slashes. For example, the path for a child of the root
	// entity with id = "vm1", would simply be "vm1". If the vm is
	// the child of a VirtualSystemCollection called "webTier", then
	// the path would be "webTier/vm".
	EntityName []KeyValue `xml:"entityName,omitempty" json:"entityName,omitempty"`
	// The annotated OST for the OVF descriptor, generated by OVF
	// consumers.
	//
	// See `OvfConsumer` for details.
	AnnotatedOst *OvfConsumerOstNode `xml:"annotatedOst,omitempty" json:"annotatedOst,omitempty"`
	// Errors that happened during processing.
	//
	// Something
	// will be wrong with the result.
	//
	// For example, during export, devices could be
	// missing (in which case this array will contain one
	// or more instances of Unsupported-/UnknownDevice).
	Error []LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
	// Non-fatal warnings from the processing.
	//
	// The result will be valid, but the
	// user may choose to reject it based on these
	// warnings.
	Warning []LocalizedMethodFault `xml:"warning,omitempty" json:"warning,omitempty"`
}

func init() {
	t["OvfParseDescriptorResult"] = reflect.TypeOf((*OvfParseDescriptorResult)(nil)).Elem()
}

// A base fault for property faults in the property section of the Ovf XML descriptor.
type OvfProperty struct {
	OvfInvalidPackage

	// The type of the property
	Type string `xml:"type" json:"type"`
	// The value of the property
	Value string `xml:"value" json:"value"`
}

func init() {
	t["OvfProperty"] = reflect.TypeOf((*OvfProperty)(nil)).Elem()
}

// VIM property type that can not be converted to OVF
type OvfPropertyExport struct {
	OvfExport

	// VIM type
	Type string `xml:"type" json:"type"`
	// VIM value
	Value string `xml:"value" json:"value"`
}

func init() {
	t["OvfPropertyExport"] = reflect.TypeOf((*OvfPropertyExport)(nil)).Elem()
}

type OvfPropertyExportFault OvfPropertyExport

func init() {
	t["OvfPropertyExportFault"] = reflect.TypeOf((*OvfPropertyExportFault)(nil)).Elem()
}

type OvfPropertyFault BaseOvfProperty

func init() {
	t["OvfPropertyFault"] = reflect.TypeOf((*OvfPropertyFault)(nil)).Elem()
}

// A class used indicate there was a property network error
type OvfPropertyNetwork struct {
	OvfProperty
}

func init() {
	t["OvfPropertyNetwork"] = reflect.TypeOf((*OvfPropertyNetwork)(nil)).Elem()
}

// VIM property type that refers to a network that
// does not exist in the package since no virtual machines
// are hooked up to it.
type OvfPropertyNetworkExport struct {
	OvfExport

	// name of network
	Network string `xml:"network" json:"network"`
}

func init() {
	t["OvfPropertyNetworkExport"] = reflect.TypeOf((*OvfPropertyNetworkExport)(nil)).Elem()
}

type OvfPropertyNetworkExportFault OvfPropertyNetworkExport

func init() {
	t["OvfPropertyNetworkExportFault"] = reflect.TypeOf((*OvfPropertyNetworkExportFault)(nil)).Elem()
}

type OvfPropertyNetworkFault OvfPropertyNetwork

func init() {
	t["OvfPropertyNetworkFault"] = reflect.TypeOf((*OvfPropertyNetworkFault)(nil)).Elem()
}

// A class used to indicate there was a property qualifier error
type OvfPropertyQualifier struct {
	OvfProperty

	// qualifiers
	Qualifier string `xml:"qualifier" json:"qualifier"`
}

func init() {
	t["OvfPropertyQualifier"] = reflect.TypeOf((*OvfPropertyQualifier)(nil)).Elem()
}

// Indicate that a property qualifier was duplicated.
type OvfPropertyQualifierDuplicate struct {
	OvfProperty

	// qualifiers
	Qualifier string `xml:"qualifier" json:"qualifier"`
}

func init() {
	t["OvfPropertyQualifierDuplicate"] = reflect.TypeOf((*OvfPropertyQualifierDuplicate)(nil)).Elem()
}

type OvfPropertyQualifierDuplicateFault OvfPropertyQualifierDuplicate

func init() {
	t["OvfPropertyQualifierDuplicateFault"] = reflect.TypeOf((*OvfPropertyQualifierDuplicateFault)(nil)).Elem()
}

type OvfPropertyQualifierFault OvfPropertyQualifier

func init() {
	t["OvfPropertyQualifierFault"] = reflect.TypeOf((*OvfPropertyQualifierFault)(nil)).Elem()
}

// Indicate that the was qualifier was ignored
type OvfPropertyQualifierIgnored struct {
	OvfProperty

	// qualifiers
	Qualifier string `xml:"qualifier" json:"qualifier"`
}

func init() {
	t["OvfPropertyQualifierIgnored"] = reflect.TypeOf((*OvfPropertyQualifierIgnored)(nil)).Elem()
}

type OvfPropertyQualifierIgnoredFault OvfPropertyQualifierIgnored

func init() {
	t["OvfPropertyQualifierIgnoredFault"] = reflect.TypeOf((*OvfPropertyQualifierIgnoredFault)(nil)).Elem()
}

// A class used to indicate there was a property type error
type OvfPropertyType struct {
	OvfProperty
}

func init() {
	t["OvfPropertyType"] = reflect.TypeOf((*OvfPropertyType)(nil)).Elem()
}

type OvfPropertyTypeFault OvfPropertyType

func init() {
	t["OvfPropertyTypeFault"] = reflect.TypeOf((*OvfPropertyTypeFault)(nil)).Elem()
}

// A class used indicate there was a property value error
type OvfPropertyValue struct {
	OvfProperty
}

func init() {
	t["OvfPropertyValue"] = reflect.TypeOf((*OvfPropertyValue)(nil)).Elem()
}

type OvfPropertyValueFault OvfPropertyValue

func init() {
	t["OvfPropertyValueFault"] = reflect.TypeOf((*OvfPropertyValueFault)(nil)).Elem()
}

// Deprecated as of vSphere API 5.1.
//
// Maps source child entities to destination resource pools
// and resource settings.
//
// If a mapping is not specified,
// a child is copied as a direct child of the parent.
type OvfResourceMap struct {
	DynamicData

	// Identifies a source VirtualSystem or VirtualSystemCollection in an OVF
	// descriptor.
	//
	// The source cannot be the root VirtualSystem or
	// VirtualSystemCollection of the OVF.
	// This is a path created by concatenating the OVF ids for each entity, e.g., "vm1",
	// "WebTier/vm2", etc.
	Source string `xml:"source" json:"source"`
	// The parent resource pool to use for the entity.
	//
	// This must specify a
	// resource pool that is not part of the vApp. If this is specified, a linked
	// child (as opposed to a direct child) is created for the vApp.
	//
	// Refers instance of `ResourcePool`.
	Parent *ManagedObjectReference `xml:"parent,omitempty" json:"parent,omitempty"`
	// An optional resource configuration for the created entity.
	//
	// If
	// not specified, the resource configuration given in the OVF descriptor
	// is used.
	ResourceSpec *ResourceConfigSpec `xml:"resourceSpec,omitempty" json:"resourceSpec,omitempty"`
	// A client can optionally specify a datastore location in the resource map to
	// override the default datastore passed into `OvfManager.CreateImportSpec` field.
	//
	// This enables importing to different compute resources that do not have shared
	// datastores.
	//
	// Refers instance of `Datastore`.
	Datastore *ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty"`
}

func init() {
	t["OvfResourceMap"] = reflect.TypeOf((*OvfResourceMap)(nil)).Elem()
}

// A common base class to host all the OVF subsystems's system faults.
//
// This is a class of fault that can be thrown because of
// some api changes, new hardware that are not supported by
// the host.
type OvfSystemFault struct {
	OvfFault
}

func init() {
	t["OvfSystemFault"] = reflect.TypeOf((*OvfSystemFault)(nil)).Elem()
}

type OvfSystemFaultFault BaseOvfSystemFault

func init() {
	t["OvfSystemFaultFault"] = reflect.TypeOf((*OvfSystemFaultFault)(nil)).Elem()
}

// Unsupported element to export to XML
type OvfToXmlUnsupportedElement struct {
	OvfSystemFault

	// The name of the xml element we could not write to the xml descriptor
	Name string `xml:"name,omitempty" json:"name,omitempty"`
}

func init() {
	t["OvfToXmlUnsupportedElement"] = reflect.TypeOf((*OvfToXmlUnsupportedElement)(nil)).Elem()
}

type OvfToXmlUnsupportedElementFault OvfToXmlUnsupportedElement

func init() {
	t["OvfToXmlUnsupportedElementFault"] = reflect.TypeOf((*OvfToXmlUnsupportedElementFault)(nil)).Elem()
}

type OvfUnableToExportDisk struct {
	OvfHardwareExport

	// disk name
	DiskName string `xml:"diskName" json:"diskName"`
}

func init() {
	t["OvfUnableToExportDisk"] = reflect.TypeOf((*OvfUnableToExportDisk)(nil)).Elem()
}

type OvfUnableToExportDiskFault OvfUnableToExportDisk

func init() {
	t["OvfUnableToExportDiskFault"] = reflect.TypeOf((*OvfUnableToExportDiskFault)(nil)).Elem()
}

// Class used to indicate an unexpected element in the Ovf descriptor
type OvfUnexpectedElement struct {
	OvfElement
}

func init() {
	t["OvfUnexpectedElement"] = reflect.TypeOf((*OvfUnexpectedElement)(nil)).Elem()
}

type OvfUnexpectedElementFault OvfUnexpectedElement

func init() {
	t["OvfUnexpectedElementFault"] = reflect.TypeOf((*OvfUnexpectedElementFault)(nil)).Elem()
}

type OvfUnknownDevice struct {
	OvfSystemFault

	// The unknown device
	Device BaseVirtualDevice `xml:"device,omitempty,typeattr" json:"device,omitempty"`
	// The name of the Virtual Machine containing the unkown device
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["OvfUnknownDevice"] = reflect.TypeOf((*OvfUnknownDevice)(nil)).Elem()
}

type OvfUnknownDeviceBacking struct {
	OvfHardwareExport

	// The VirtualDevice BackingInfo that is not supported by OVF export.
	Backing BaseVirtualDeviceBackingInfo `xml:"backing,typeattr" json:"backing"`
}

func init() {
	t["OvfUnknownDeviceBacking"] = reflect.TypeOf((*OvfUnknownDeviceBacking)(nil)).Elem()
}

type OvfUnknownDeviceBackingFault OvfUnknownDeviceBacking

func init() {
	t["OvfUnknownDeviceBackingFault"] = reflect.TypeOf((*OvfUnknownDeviceBackingFault)(nil)).Elem()
}

type OvfUnknownDeviceFault OvfUnknownDevice

func init() {
	t["OvfUnknownDeviceFault"] = reflect.TypeOf((*OvfUnknownDeviceFault)(nil)).Elem()
}

type OvfUnknownEntity struct {
	OvfSystemFault

	// line number where the unknown entity was found
	LineNumber int32 `xml:"lineNumber" json:"lineNumber"`
}

func init() {
	t["OvfUnknownEntity"] = reflect.TypeOf((*OvfUnknownEntity)(nil)).Elem()
}

type OvfUnknownEntityFault OvfUnknownEntity

func init() {
	t["OvfUnknownEntityFault"] = reflect.TypeOf((*OvfUnknownEntityFault)(nil)).Elem()
}

// If the Ovf descriptor have an unsupported attribute.
type OvfUnsupportedAttribute struct {
	OvfUnsupportedPackage

	// The name of the element with the unsupported attribute
	ElementName string `xml:"elementName" json:"elementName"`
	// The name of the unsupported attribute
	AttributeName string `xml:"attributeName" json:"attributeName"`
}

func init() {
	t["OvfUnsupportedAttribute"] = reflect.TypeOf((*OvfUnsupportedAttribute)(nil)).Elem()
}

type OvfUnsupportedAttributeFault BaseOvfUnsupportedAttribute

func init() {
	t["OvfUnsupportedAttributeFault"] = reflect.TypeOf((*OvfUnsupportedAttributeFault)(nil)).Elem()
}

// Used when an OVF descriptor attribute has an unsupported value.
type OvfUnsupportedAttributeValue struct {
	OvfUnsupportedAttribute

	// Unsupported attribute value
	Value string `xml:"value" json:"value"`
}

func init() {
	t["OvfUnsupportedAttributeValue"] = reflect.TypeOf((*OvfUnsupportedAttributeValue)(nil)).Elem()
}

type OvfUnsupportedAttributeValueFault OvfUnsupportedAttributeValue

func init() {
	t["OvfUnsupportedAttributeValueFault"] = reflect.TypeOf((*OvfUnsupportedAttributeValueFault)(nil)).Elem()
}

type OvfUnsupportedDeviceBackingInfo struct {
	OvfSystemFault

	// The element name
	ElementName string `xml:"elementName,omitempty" json:"elementName,omitempty"`
	// The InstanceId on the hardware description
	InstanceId string `xml:"instanceId,omitempty" json:"instanceId,omitempty"`
	// The device name
	DeviceName string `xml:"deviceName" json:"deviceName"`
	// The name of the VirtualDevice Backing Info not supported on the device.
	BackingName string `xml:"backingName,omitempty" json:"backingName,omitempty"`
}

func init() {
	t["OvfUnsupportedDeviceBackingInfo"] = reflect.TypeOf((*OvfUnsupportedDeviceBackingInfo)(nil)).Elem()
}

type OvfUnsupportedDeviceBackingInfoFault OvfUnsupportedDeviceBackingInfo

func init() {
	t["OvfUnsupportedDeviceBackingInfoFault"] = reflect.TypeOf((*OvfUnsupportedDeviceBackingInfoFault)(nil)).Elem()
}

type OvfUnsupportedDeviceBackingOption struct {
	OvfSystemFault

	// The element name
	ElementName string `xml:"elementName,omitempty" json:"elementName,omitempty"`
	// The InstanceId for the hardware element
	InstanceId string `xml:"instanceId,omitempty" json:"instanceId,omitempty"`
	// The device name
	DeviceName string `xml:"deviceName" json:"deviceName"`
	// The name of the VirtualDevice Backing Option not supported on the device.
	BackingName string `xml:"backingName,omitempty" json:"backingName,omitempty"`
}

func init() {
	t["OvfUnsupportedDeviceBackingOption"] = reflect.TypeOf((*OvfUnsupportedDeviceBackingOption)(nil)).Elem()
}

type OvfUnsupportedDeviceBackingOptionFault OvfUnsupportedDeviceBackingOption

func init() {
	t["OvfUnsupportedDeviceBackingOptionFault"] = reflect.TypeOf((*OvfUnsupportedDeviceBackingOptionFault)(nil)).Elem()
}

type OvfUnsupportedDeviceExport struct {
	OvfHardwareExport
}

func init() {
	t["OvfUnsupportedDeviceExport"] = reflect.TypeOf((*OvfUnsupportedDeviceExport)(nil)).Elem()
}

type OvfUnsupportedDeviceExportFault OvfUnsupportedDeviceExport

func init() {
	t["OvfUnsupportedDeviceExportFault"] = reflect.TypeOf((*OvfUnsupportedDeviceExportFault)(nil)).Elem()
}

// Disk provisioning not supported
type OvfUnsupportedDiskProvisioning struct {
	OvfImport

	// The disk provisioning that was not supported.
	DiskProvisioning string `xml:"diskProvisioning" json:"diskProvisioning"`
	// Disk modes supported by the host.
	SupportedDiskProvisioning string `xml:"supportedDiskProvisioning" json:"supportedDiskProvisioning"`
}

func init() {
	t["OvfUnsupportedDiskProvisioning"] = reflect.TypeOf((*OvfUnsupportedDiskProvisioning)(nil)).Elem()
}

type OvfUnsupportedDiskProvisioningFault OvfUnsupportedDiskProvisioning

func init() {
	t["OvfUnsupportedDiskProvisioningFault"] = reflect.TypeOf((*OvfUnsupportedDiskProvisioningFault)(nil)).Elem()
}

// If the Ovf descriptor has an unsupported element where it is not allowed.
type OvfUnsupportedElement struct {
	OvfUnsupportedPackage

	// The name of the unsupported element
	Name string `xml:"name" json:"name"`
}

func init() {
	t["OvfUnsupportedElement"] = reflect.TypeOf((*OvfUnsupportedElement)(nil)).Elem()
}

type OvfUnsupportedElementFault BaseOvfUnsupportedElement

func init() {
	t["OvfUnsupportedElementFault"] = reflect.TypeOf((*OvfUnsupportedElementFault)(nil)).Elem()
}

// If the Ovf descriptor has an unsupported value of a element in the
// OVF descriptor.
type OvfUnsupportedElementValue struct {
	OvfUnsupportedElement

	// The unsupported element value
	Value string `xml:"value" json:"value"`
}

func init() {
	t["OvfUnsupportedElementValue"] = reflect.TypeOf((*OvfUnsupportedElementValue)(nil)).Elem()
}

type OvfUnsupportedElementValueFault OvfUnsupportedElementValue

func init() {
	t["OvfUnsupportedElementValueFault"] = reflect.TypeOf((*OvfUnsupportedElementValueFault)(nil)).Elem()
}

// A common base class to host all the Ovf Lib Unsupported Package faults
type OvfUnsupportedPackage struct {
	OvfFault

	// OVF descriptor linenumber
	LineNumber int32 `xml:"lineNumber,omitempty" json:"lineNumber,omitempty"`
}

func init() {
	t["OvfUnsupportedPackage"] = reflect.TypeOf((*OvfUnsupportedPackage)(nil)).Elem()
}

type OvfUnsupportedPackageFault BaseOvfUnsupportedPackage

func init() {
	t["OvfUnsupportedPackageFault"] = reflect.TypeOf((*OvfUnsupportedPackageFault)(nil)).Elem()
}

// If the Ovf descriptor has an unsupported required section.
type OvfUnsupportedSection struct {
	OvfUnsupportedElement

	// The info of the unsupported section
	Info string `xml:"info" json:"info"`
}

func init() {
	t["OvfUnsupportedSection"] = reflect.TypeOf((*OvfUnsupportedSection)(nil)).Elem()
}

type OvfUnsupportedSectionFault OvfUnsupportedSection

func init() {
	t["OvfUnsupportedSectionFault"] = reflect.TypeOf((*OvfUnsupportedSectionFault)(nil)).Elem()
}

type OvfUnsupportedSubType struct {
	OvfUnsupportedPackage

	// The name of the element with the unsupported type
	ElementName string `xml:"elementName" json:"elementName"`
	// The OVF RASD InstanceId for the hardware description
	InstanceId string `xml:"instanceId" json:"instanceId"`
	// The device type
	DeviceType int32 `xml:"deviceType" json:"deviceType"`
	// The device subtype that is unsupported
	DeviceSubType string `xml:"deviceSubType" json:"deviceSubType"`
}

func init() {
	t["OvfUnsupportedSubType"] = reflect.TypeOf((*OvfUnsupportedSubType)(nil)).Elem()
}

type OvfUnsupportedSubTypeFault OvfUnsupportedSubType

func init() {
	t["OvfUnsupportedSubTypeFault"] = reflect.TypeOf((*OvfUnsupportedSubTypeFault)(nil)).Elem()
}

type OvfUnsupportedType struct {
	OvfUnsupportedPackage

	// The name of the element with the unsupported type
	Name string `xml:"name" json:"name"`
	// The OVF RASD InstanceId for the hardware description
	InstanceId string `xml:"instanceId" json:"instanceId"`
	// The device type that is unsupported
	DeviceType int32 `xml:"deviceType" json:"deviceType"`
}

func init() {
	t["OvfUnsupportedType"] = reflect.TypeOf((*OvfUnsupportedType)(nil)).Elem()
}

type OvfUnsupportedTypeFault OvfUnsupportedType

func init() {
	t["OvfUnsupportedTypeFault"] = reflect.TypeOf((*OvfUnsupportedTypeFault)(nil)).Elem()
}

type OvfValidateHostParams struct {
	OvfManagerCommonParams
}

func init() {
	t["OvfValidateHostParams"] = reflect.TypeOf((*OvfValidateHostParams)(nil)).Elem()
}

type OvfValidateHostResult struct {
	DynamicData

	// The total amount of data that must be transferred to download the entity.
	//
	// This may be inaccurate due to disk compression etc.
	DownloadSize int64 `xml:"downloadSize,omitempty" json:"downloadSize,omitempty"`
	// The total amount of space required to deploy the entity if using flat disks.
	FlatDeploymentSize int64 `xml:"flatDeploymentSize,omitempty" json:"flatDeploymentSize,omitempty"`
	// The total amount of space required to deploy the entity using sparse disks,
	// if known.
	SparseDeploymentSize int64 `xml:"sparseDeploymentSize,omitempty" json:"sparseDeploymentSize,omitempty"`
	// Errors that happened during validation.
	//
	// The presence of faults in this list
	// indicates that the validation failed.
	Error []LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
	// Non-fatal warnings from the validation.
	Warning []LocalizedMethodFault `xml:"warning,omitempty" json:"warning,omitempty"`
	// An array of the disk provisioning type supported by the target host system.
	SupportedDiskProvisioning []string `xml:"supportedDiskProvisioning,omitempty" json:"supportedDiskProvisioning,omitempty"`
}

func init() {
	t["OvfValidateHostResult"] = reflect.TypeOf((*OvfValidateHostResult)(nil)).Elem()
}

// If the Ovf descriptor has an element that is not accepted, this exception is thrown.
type OvfWrongElement struct {
	OvfElement
}

func init() {
	t["OvfWrongElement"] = reflect.TypeOf((*OvfWrongElement)(nil)).Elem()
}

type OvfWrongElementFault OvfWrongElement

func init() {
	t["OvfWrongElementFault"] = reflect.TypeOf((*OvfWrongElementFault)(nil)).Elem()
}

// A OvfWrongNamespace exception is throw if the ovf descriptor has a
// Namespace error as defined in the Ovf spec
type OvfWrongNamespace struct {
	OvfInvalidPackage

	// The name of the invalid namespace
	NamespaceName string `xml:"namespaceName" json:"namespaceName"`
}

func init() {
	t["OvfWrongNamespace"] = reflect.TypeOf((*OvfWrongNamespace)(nil)).Elem()
}

type OvfWrongNamespaceFault OvfWrongNamespace

func init() {
	t["OvfWrongNamespaceFault"] = reflect.TypeOf((*OvfWrongNamespaceFault)(nil)).Elem()
}

// Class used to specify if the Ovf XML descriptor could not be parsed
type OvfXmlFormat struct {
	OvfInvalidPackage

	// Description of the XML parser error
	//
	// High level error description
	Description string `xml:"description" json:"description"`
}

func init() {
	t["OvfXmlFormat"] = reflect.TypeOf((*OvfXmlFormat)(nil)).Elem()
}

type OvfXmlFormatFault OvfXmlFormat

func init() {
	t["OvfXmlFormatFault"] = reflect.TypeOf((*OvfXmlFormatFault)(nil)).Elem()
}

type PMemDatastoreInfo struct {
	DatastoreInfo

	Pmem HostPMemVolume `xml:"pmem" json:"pmem"`
}

func init() {
	t["PMemDatastoreInfo"] = reflect.TypeOf((*PMemDatastoreInfo)(nil)).Elem()
}

// ParaVirtualSCSIController is the data object that represents
// a paravirtualized SCSI controller.
type ParaVirtualSCSIController struct {
	VirtualSCSIController
}

func init() {
	t["ParaVirtualSCSIController"] = reflect.TypeOf((*ParaVirtualSCSIController)(nil)).Elem()
}

// ParaVirtualSCSIControllerOption is the data object that contains
// the options for a a paravirtualized SCSI controller.
type ParaVirtualSCSIControllerOption struct {
	VirtualSCSIControllerOption
}

func init() {
	t["ParaVirtualSCSIControllerOption"] = reflect.TypeOf((*ParaVirtualSCSIControllerOption)(nil)).Elem()
}

type ParseDescriptor ParseDescriptorRequestType

func init() {
	t["ParseDescriptor"] = reflect.TypeOf((*ParseDescriptor)(nil)).Elem()
}

// The parameters of `OvfManager.ParseDescriptor`.
type ParseDescriptorRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The OVF descriptor to examine.
	OvfDescriptor string `xml:"ovfDescriptor" json:"ovfDescriptor"`
	// Additional parameters for parseDescriptor, wrapped in an instance of
	// ParseDescriptorParams.
	Pdp OvfParseDescriptorParams `xml:"pdp" json:"pdp"`
}

func init() {
	t["ParseDescriptorRequestType"] = reflect.TypeOf((*ParseDescriptorRequestType)(nil)).Elem()
}

type ParseDescriptorResponse struct {
	Returnval OvfParseDescriptorResult `xml:"returnval" json:"returnval"`
}

// The PassiveNodeDeploymentSpec class defines VCHA Cluster configuration
// of the Passive node VM in the VCHA Cluster.
type PassiveNodeDeploymentSpec struct {
	NodeDeploymentSpec

	// Failover IP address that this node must assume after the failover
	// to serve client requests.
	//
	// If not specified, it will assume the public
	// IP address of the Active vCenter Server.
	FailoverIpSettings *CustomizationIPSettings `xml:"failoverIpSettings,omitempty" json:"failoverIpSettings,omitempty"`
}

func init() {
	t["PassiveNodeDeploymentSpec"] = reflect.TypeOf((*PassiveNodeDeploymentSpec)(nil)).Elem()
}

// The PassiveNodeNetworkSpec class defines VCHA Failover and Cluster
// network configuration of the Passive node VM in the VCHA Cluster.
type PassiveNodeNetworkSpec struct {
	NodeNetworkSpec

	// Failover IP address that this node must assume after the failover
	// to serve client requests.
	//
	// If not specified, it will assume the public
	// IP address of the Active vCenter Server.
	FailoverIpSettings *CustomizationIPSettings `xml:"failoverIpSettings,omitempty" json:"failoverIpSettings,omitempty"`
}

func init() {
	t["PassiveNodeNetworkSpec"] = reflect.TypeOf((*PassiveNodeNetworkSpec)(nil)).Elem()
}

// Thrown when a server login fails due to expired user password.
type PasswordExpired struct {
	InvalidLogin
}

func init() {
	t["PasswordExpired"] = reflect.TypeOf((*PasswordExpired)(nil)).Elem()
}

type PasswordExpiredFault PasswordExpired

func init() {
	t["PasswordExpiredFault"] = reflect.TypeOf((*PasswordExpiredFault)(nil)).Elem()
}

// DataObject which represents a Password field.
//
// Password is functionally equivalent to String.
type PasswordField struct {
	DynamicData

	Value string `xml:"value" json:"value"`
}

func init() {
	t["PasswordField"] = reflect.TypeOf((*PasswordField)(nil)).Elem()
}

// This fault is thrown if a patch install fails because the patch
// is already installed on the host.
type PatchAlreadyInstalled struct {
	PatchNotApplicable
}

func init() {
	t["PatchAlreadyInstalled"] = reflect.TypeOf((*PatchAlreadyInstalled)(nil)).Elem()
}

type PatchAlreadyInstalledFault PatchAlreadyInstalled

func init() {
	t["PatchAlreadyInstalledFault"] = reflect.TypeOf((*PatchAlreadyInstalledFault)(nil)).Elem()
}

// This fault is thrown if a patch install fails
// because the binaries associated with the patch are not found.
type PatchBinariesNotFound struct {
	VimFault

	// The patch whose associated binaries are not found.
	PatchID string `xml:"patchID" json:"patchID"`
	// The binaries that are not found.
	Binary []string `xml:"binary,omitempty" json:"binary,omitempty"`
}

func init() {
	t["PatchBinariesNotFound"] = reflect.TypeOf((*PatchBinariesNotFound)(nil)).Elem()
}

type PatchBinariesNotFoundFault PatchBinariesNotFound

func init() {
	t["PatchBinariesNotFoundFault"] = reflect.TypeOf((*PatchBinariesNotFoundFault)(nil)).Elem()
}

// This is a general-purpose fault indicating that some error has
// occurred regarding a patch install.
//
// Data about the fault is
// available and is presented as a platform specific string.
type PatchInstallFailed struct {
	PlatformConfigFault

	// Whether or not the patch install has been rolled back.
	//
	// If not,
	// a manual rollback is required.
	RolledBack bool `xml:"rolledBack" json:"rolledBack"`
}

func init() {
	t["PatchInstallFailed"] = reflect.TypeOf((*PatchInstallFailed)(nil)).Elem()
}

type PatchInstallFailedFault PatchInstallFailed

func init() {
	t["PatchInstallFailedFault"] = reflect.TypeOf((*PatchInstallFailedFault)(nil)).Elem()
}

// This fault is thrown if a patch operation fails because the signature of
// the patch did not check out.
type PatchIntegrityError struct {
	PlatformConfigFault
}

func init() {
	t["PatchIntegrityError"] = reflect.TypeOf((*PatchIntegrityError)(nil)).Elem()
}

type PatchIntegrityErrorFault PatchIntegrityError

func init() {
	t["PatchIntegrityErrorFault"] = reflect.TypeOf((*PatchIntegrityErrorFault)(nil)).Elem()
}

// This fault is thrown if the metadata associated with a patch is
// corrupted or unreadable when a patch query or install is attempted.
type PatchMetadataCorrupted struct {
	PatchMetadataInvalid
}

func init() {
	t["PatchMetadataCorrupted"] = reflect.TypeOf((*PatchMetadataCorrupted)(nil)).Elem()
}

type PatchMetadataCorruptedFault PatchMetadataCorrupted

func init() {
	t["PatchMetadataCorruptedFault"] = reflect.TypeOf((*PatchMetadataCorruptedFault)(nil)).Elem()
}

// This fault is thrown if a patch query or
// installation operation fails because of a problem with the metadata
// associated with the patch.
//
// Typically, a subclass of this exception is
// thrown, indicating a problem such as the metadata is not found or the
// metadata is corrupted.
type PatchMetadataInvalid struct {
	VimFault

	// The patch ID whose associated metadata is invalid.
	PatchID string `xml:"patchID" json:"patchID"`
	// The metadata file that is not available or corrupted.
	MetaData []string `xml:"metaData,omitempty" json:"metaData,omitempty"`
}

func init() {
	t["PatchMetadataInvalid"] = reflect.TypeOf((*PatchMetadataInvalid)(nil)).Elem()
}

type PatchMetadataInvalidFault BasePatchMetadataInvalid

func init() {
	t["PatchMetadataInvalidFault"] = reflect.TypeOf((*PatchMetadataInvalidFault)(nil)).Elem()
}

// This fault is thrown if the metadata associated with a patch is not
// found when a patch query or install is attempted.
type PatchMetadataNotFound struct {
	PatchMetadataInvalid
}

func init() {
	t["PatchMetadataNotFound"] = reflect.TypeOf((*PatchMetadataNotFound)(nil)).Elem()
}

type PatchMetadataNotFoundFault PatchMetadataNotFound

func init() {
	t["PatchMetadataNotFoundFault"] = reflect.TypeOf((*PatchMetadataNotFoundFault)(nil)).Elem()
}

// This fault is thrown if a patch install fails because the patch
// requires other patches or libraries that are not installed on the host.
type PatchMissingDependencies struct {
	PatchNotApplicable

	// The ID of required patches.
	PrerequisitePatch []string `xml:"prerequisitePatch,omitempty" json:"prerequisitePatch,omitempty"`
	// The names of required libraries or RPMs.
	PrerequisiteLib []string `xml:"prerequisiteLib,omitempty" json:"prerequisiteLib,omitempty"`
}

func init() {
	t["PatchMissingDependencies"] = reflect.TypeOf((*PatchMissingDependencies)(nil)).Elem()
}

type PatchMissingDependenciesFault PatchMissingDependencies

func init() {
	t["PatchMissingDependenciesFault"] = reflect.TypeOf((*PatchMissingDependenciesFault)(nil)).Elem()
}

// This fault is thrown if a patch install fails because the patch is not
// applicable to the host.
//
// Typically, a subclass of this exception is
// thrown, indicating a problem such as the patch is superseded, already
// installed, or has dependencies missing, and so on.
type PatchNotApplicable struct {
	VimFault

	// The ID of the patch that is not applicable to the host.
	PatchID string `xml:"patchID" json:"patchID"`
}

func init() {
	t["PatchNotApplicable"] = reflect.TypeOf((*PatchNotApplicable)(nil)).Elem()
}

type PatchNotApplicableFault BasePatchNotApplicable

func init() {
	t["PatchNotApplicableFault"] = reflect.TypeOf((*PatchNotApplicableFault)(nil)).Elem()
}

// This fault is thrown if a patch install fails because the patch is
// superseded by patches already installed.
type PatchSuperseded struct {
	PatchNotApplicable

	// The patches that supersede this patch.
	Supersede []string `xml:"supersede,omitempty" json:"supersede,omitempty"`
}

func init() {
	t["PatchSuperseded"] = reflect.TypeOf((*PatchSuperseded)(nil)).Elem()
}

type PatchSupersededFault PatchSuperseded

func init() {
	t["PatchSupersededFault"] = reflect.TypeOf((*PatchSupersededFault)(nil)).Elem()
}

// `PerfCompositeMetric` includes an optional
// aggregated entity performance statistics and a list of composite entities
// performance statistics&#46; The aggregated entity statistics are optional
// because some entities, such as folders, do not have their own
// statistics&#46;
type PerfCompositeMetric struct {
	DynamicData

	// The aggregated entity performance metrics.
	//
	// If it exists, the `PerfSampleInfo` list of the aggregate entity is a
	// complete list of `PerfSampleInfo` that could
	// be contained in `PerfSampleInfo` lists of
	// child entities.
	Entity BasePerfEntityMetricBase `xml:"entity,omitempty,typeattr" json:"entity,omitempty"`
	// A list of `metrics` of
	// performance providers that comprise the aggregated entity.
	//
	// For
	// example, Host is an aggregated entity for virtual machines and
	// virtual machine Folders. ResourcePools are aggregate entities for
	// virtual machines. Host, Folder, and Cluster are aggregate entities
	// for hosts in the cluster or folder.
	ChildEntity []BasePerfEntityMetricBase `xml:"childEntity,omitempty,typeattr" json:"childEntity,omitempty"`
}

func init() {
	t["PerfCompositeMetric"] = reflect.TypeOf((*PerfCompositeMetric)(nil)).Elem()
}

// This data object type contains metadata for a performance counter.
//
// See
// `PerformanceManager` for definitions of available counters.
type PerfCounterInfo struct {
	DynamicData

	// A system-generated number that uniquely identifies the counter in the
	// context of the system.
	//
	// The performance counter ID.
	Key int32 `xml:"key" json:"key"`
	// The name of the counter with label and summary details.
	//
	// For example,
	// the counter with name "usage" for the "cpu" group of performance
	// counters.
	NameInfo BaseElementDescription `xml:"nameInfo,typeattr" json:"nameInfo"`
	// The group of the performance counter with its label and summary
	// details.
	//
	// Counter groups include "cpu," "mem," "net," "disk," "system,"
	// "rescpu," and "clusterServices," for example.
	GroupInfo BaseElementDescription `xml:"groupInfo,typeattr" json:"groupInfo"`
	// The unit for the values of the performance counter with its label and
	// summary details.
	//
	// See `PerformanceManagerUnit_enum` for a
	// description of the valid values.
	UnitInfo BaseElementDescription `xml:"unitInfo,typeattr" json:"unitInfo"`
	// The counter type.
	//
	// Valid values include average, maximum, minimum,
	// latest, summation, or none. This determines the type of statistical
	// values that are returned for the counter. None means that the counter
	// is never rolled up.
	RollupType PerfSummaryType `xml:"rollupType" json:"rollupType"`
	// Statistics type for the counter.
	//
	// Valid values include absolute, delta,
	// or rate.
	StatsType PerfStatsType `xml:"statsType" json:"statsType"`
	// Minimum level at which metrics of this type will be collected by
	// VirtualCenter Server.
	//
	// The value for this property for any performance
	// counter is a number from 1 to 4. The higher the setting, the more data
	// is collected by VirtualCenter Server. The default setting for
	// VirtualCenter Server is 1, which collects the minimal amount of
	// performance data that is typically useful to administrators and
	// developers alike. The specific level of each counter is documented in
	// the respective counter-documentation pages, by group. See `PerformanceManager` for links to the counter group pages.
	Level int32 `xml:"level,omitempty" json:"level,omitempty"`
	// Minimum level at which the per device metrics of this type will be
	// collected by vCenter Server.
	//
	// The value for this property for any
	// performance counter is a number from 1 to 4. By default all per device
	// metrics are calculated at level 3 or more. If a certain per device
	// counter is collected at a certain level, the aggregate metric is also
	// calculated at that level, i.e., perDeviceLevel is greater than or
	// equal to level.
	PerDeviceLevel int32 `xml:"perDeviceLevel,omitempty" json:"perDeviceLevel,omitempty"`
	// Deprecated as of VI API 2.5, this property is not used.
	//
	// The counter IDs associated with the same performance counter name for
	// the same device type.
	//
	// For example, the rollup types for CPU Usage for
	// a host are average, minimum, and maximum&#46; Therefore, their counter
	// IDs are associated.
	AssociatedCounterId []int32 `xml:"associatedCounterId,omitempty" json:"associatedCounterId,omitempty"`
}

func init() {
	t["PerfCounterInfo"] = reflect.TypeOf((*PerfCounterInfo)(nil)).Elem()
}

// This data object type stores values and metadata for metrics associated
// with a specific entity, in 'normal' format.
type PerfEntityMetric struct {
	PerfEntityMetricBase

	// A list of objects containing information (an interval and a timestamp)
	// about the samples collected.
	SampleInfo []PerfSampleInfo `xml:"sampleInfo,omitempty" json:"sampleInfo,omitempty"`
	// A list of values that corresponds to the samples collected.
	Value []BasePerfMetricSeries `xml:"value,omitempty,typeattr" json:"value,omitempty"`
}

func init() {
	t["PerfEntityMetric"] = reflect.TypeOf((*PerfEntityMetric)(nil)).Elem()
}

// Base type for the various `PerfEntityMetric`
// encodings.
type PerfEntityMetricBase struct {
	DynamicData

	// Performance provider ID.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["PerfEntityMetricBase"] = reflect.TypeOf((*PerfEntityMetricBase)(nil)).Elem()
}

// This data object type stores metric values for a specific entity in CSV
// format.
type PerfEntityMetricCSV struct {
	PerfEntityMetricBase

	// The `PerfSampleInfo` encoded in the following CSV
	// format: \[interval1\], \[date1\], \[interval2\], \[date2\], and so on.
	SampleInfoCSV string `xml:"sampleInfoCSV" json:"sampleInfoCSV"`
	// Metric values corresponding to the samples collected in this list.
	Value []PerfMetricSeriesCSV `xml:"value,omitempty" json:"value,omitempty"`
}

func init() {
	t["PerfEntityMetricCSV"] = reflect.TypeOf((*PerfEntityMetricCSV)(nil)).Elem()
}

// This data object type contains metadata about a performance interval.
//   - For VirtualCenter Server systems, instances of this data object are
//     referred to as &#147;historical intervals&#148; because they control
//     how data collected from the ESX systems will be aggregated and stored
//     in the database.
//   - For ESX system, this data object is typically referred to simply as the
//     &#147;interval&#148; or &#147;performance interval&#148; because ESX
//     does not aggregate statistical data.
//
// For ESX systems, a single instance of this data object exists. It cannot
// be modified. It has these properties:
// <table border="1"width="100%">
// <tr>
// <th>key</th>
// <th>samplingPeriod</th>
// <th>length</th>
// <th>name</th>
// <th>level</th>
// <th>enabled</th>
// </tr>
// <tr>
// <td>1</td>
// <td>300</td>
// <td>129600</td>
// <td>PastDay</td>
// <td>null</td>
// <td>true</td>
// </tr>
// </table>
//
// VirtualCenter Server system provides four instances of this data object
// by default, that apply globally to all system entities.
//
// **Example Collection Levels**
// VirtualCenter Server
// uses the specifications configured in its historical intervals to collect metrics
// from the ESX systems that it manages. The quantity of data collected depends on
// the level settings for the server, and the level associated with a specific counter.
// Both factors may change from one version of the products to the next. In general,
// the lower the number, the smaller the amount of data collected. For VirtualCenter
// Server 2.5, for example, the levels 1 through 4 collected data as follows:
//  1. Basic counters defined with "average" *rollup type* for CPU, Memory,
//     Disk, and Network; plus counters for System Uptime, System Heartbeat,
//     and DRS (Distributed Resource Scheduler, tracked in the
//     "clusterServices" group). Does not include counters for devices.
//  2. Counters defined with "average," "summation," and "latest" *rollup types* for CPU,
//     Memory, Disk, and Network; plus counters for System Uptime, System
//     Heartbeat, and DRS (clusterServices). Does not include counters for
//     devices.
//  3. Counters defined with "average," "summmation," and "latest" *rollup types* for CPU,
//     Memory, Disk, Network, and all devices; plus counters for System
//     Uptime, System Heartbeat, and DRS (clusterServices).
//  4. All counters defined for all entities and devices, for every *rollup type*, including
//     &#147;minimum&#148; and &#147;maximum&#46;&#148;
//
// Default properties for the four built-in historical intervals
// include:
// <table border="1"width="100%">
// <tr>
// <th>key</th>
// <th>samplingPeriod</th>
// <th>length</th>
// <th>name</th>
// <th>level</th>
// <th>enabled</th>
// </tr>
// <tr>
// <td>1</td>
// <td>300</td>
// <td>86400</td>
// <td>Past&nbsp;day</td>
// <td>1</td>
// <td>true</td>
// </tr>
// <tr>
// <td>2</td>
// <td>1800</td>
// <td>604800</td>
// <td>Past&nbsp;week</td>
// <td>1</td>
// <td>true</td>
// </tr>
// <tr>
// <td>3</td>
// <td>7200</td>
// <td>2592000</td>
// <td>Past&nbsp;month</td>
// <td>1</td>
// <td>true</td>
// </tr>
// <tr>
// <td>4</td>
// <td>86400</td>
// <td>31536000</td>
// <td>Past&nbsp;year</td>
// <td>1</td>
// <td>true</td>
// </tr>
// </table>
//
// All values are in seconds. The default setting for vCenter Server is
// level 1, which retains sampled statistical data as follows:
//   - 5-minute samples for the past day
//   - 30-minute samples for the past week
//   - 2-hour samples for the past month
//   - 1-day samples for the past year
//
// Data older than a year is purged from the vCenter Server database.
//
// Prior to version 2&#46;5 of the API, this data object could be used in
// conjunction with the `PerformanceManager.CreatePerfInterval`
// operation, to define new, custom historical intervals. That operation has
// been deprecated: Adding and deleting objects of this type is no longer
// supported. However, the default historical intervals can be enabled or
// disabled, and can be modified within certain limits (with the `PerformanceManager.UpdatePerfInterval` operation)&#46;
type PerfInterval struct {
	DynamicData

	// A unique identifier for the interval.
	Key int32 `xml:"key" json:"key"`
	// Number of seconds that data is sampled for this interval.
	//
	// The real-time
	// samplingPeriod is 20 seconds.
	SamplingPeriod int32 `xml:"samplingPeriod" json:"samplingPeriod"`
	// The name of the historical interval.
	//
	// A localized string that provides a
	// name for the interval. Names include:
	//   - "Past Day"
	//   - "Past Week"
	//   - "Past Month"
	//   - "Past Year"
	//
	// The name is not meaningful in terms of system behavior. That is, the
	// interval named &#147;Past Week&#148; works as it does because of its
	// length, level, and so on, not because of the value of this string.
	Name string `xml:"name" json:"name"`
	// Number of seconds that the statistics corresponding to this interval are
	// kept on the system.
	Length int32 `xml:"length" json:"length"`
	// Statistics collection level for this historical interval.
	//
	// vCenter Server
	// will aggregate only those statistics that match the value of this
	// property for this historical interval. For ESX, the value of this
	// property is null. For vCenter Server, the value will be a number from 1
	// to 4.
	Level int32 `xml:"level,omitempty" json:"level,omitempty"`
	// Indicates whether the interval is enabled (true) or disabled (false).
	//
	// Disabling a historical interval prevents vCenter Server from collecting
	// metrics for that interval and all higher (longer) intervals.
	//
	// For example, disabling the "Past Month" interval disables both "Past
	// Month" and "Past Year" intervals. The system will aggregate and retain
	// performance data using the "Past Day" and "Past Week" intervals only.
	Enabled bool `xml:"enabled" json:"enabled"`
}

func init() {
	t["PerfInterval"] = reflect.TypeOf((*PerfInterval)(nil)).Elem()
}

// This data object type contains information that associates a performance
// counter with a performance metric.
//
// When constructing this data object for
// the `PerfQuerySpec.metricId` property of the `PerfQuerySpec` to submit to one of the `PerformanceManager` query operations, the `PerfMetricId.instance` property
// supports these special characters:
//   - An asterisk (\*) to specify all instances of the metric for the
//     specified `PerfMetricId.counterId`
//   - Double-quotes ("") to specify aggregated statistics
type PerfMetricId struct {
	DynamicData

	// The `ID` of the counter for
	// the metric.
	CounterId int32 `xml:"counterId" json:"counterId"`
	// An identifier that is derived from configuration names for the device
	// associated with the metric.
	//
	// It identifies the instance of the metric
	// with its source. This property may be empty.
	//   - For memory and aggregated statistics, this property is empty.
	//   - For host and virtual machine devices, this property contains the
	//     name of the device, such as the name of the host-bus adapter or
	//     the name of the virtual Ethernet adapter. For example,
	//     &#147;mpx&#46;vmhba33&#58;C0&#58;T0&#58;L0&#148; or
	//     &#147;vmnic0&#58;&#148;
	//   - For a CPU, this property identifies the numeric position within
	//     the CPU core, such as 0, 1, 2, 3.
	//   - For a virtual disk, this property identifies the file type:
	//   - DISKFILE, for virtual machine base-disk files
	//   - SWAPFILE, for virtual machine swap files
	//   - DELTAFILE, for virtual machine snapshot overhead files
	//   - OTHERFILE, for all other files of a virtual machine
	Instance string `xml:"instance" json:"instance"`
}

func init() {
	t["PerfMetricId"] = reflect.TypeOf((*PerfMetricId)(nil)).Elem()
}

// This data object type describes integer metric values.
//
// The size of the
// array must match the size of `PerfEntityMetric.sampleInfo` property in the `PerfEntityMetric` that contains this series.
type PerfMetricIntSeries struct {
	PerfMetricSeries

	// An array of 64-bit integer values.
	//
	// The size of the array matches the
	// size as the `PerfSampleInfo`, because the values
	// can only be interpreted in the context of the sample that generated
	// the value.
	Value []int64 `xml:"value,omitempty" json:"value,omitempty"`
}

func init() {
	t["PerfMetricIntSeries"] = reflect.TypeOf((*PerfMetricIntSeries)(nil)).Elem()
}

// This is a generic data object type that stores values for a specific
// performance metric.
//
// Useful data objects that store actual metric values
// extend this data object (see `PerfMetricIntSeries`).
type PerfMetricSeries struct {
	DynamicData

	// An identifier for the performance metric.
	Id PerfMetricId `xml:"id" json:"id"`
}

func init() {
	t["PerfMetricSeries"] = reflect.TypeOf((*PerfMetricSeries)(nil)).Elem()
}

// This data object type represents a `PerfMetricSeries` encoded in CSV format.
type PerfMetricSeriesCSV struct {
	PerfMetricSeries

	// An array of sample values in CSV format
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

func init() {
	t["PerfMetricSeriesCSV"] = reflect.TypeOf((*PerfMetricSeriesCSV)(nil)).Elem()
}

// This data object type contains information about a performance provider,
// the type of statistics it generates, and the `PerfProviderSummary.refreshRate` for
// statistics generation.
//
// A performance provider is any *managed object* that generates real-time or
// historical statistics (or both&#151;the `PerfProviderSummary.currentSupported` and
// `PerfProviderSummary.summarySupported` properties are not mutually exclusive).
type PerfProviderSummary struct {
	DynamicData

	// Reference to the performance provider, the *managed object* that provides real-time or
	// historical metrics.
	//
	// The managed objects include but are not limited to
	// *managed entities*, such as *host systems*, *virtual machines*, and *resource pools*.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// True if this entity supports real-time (current) statistics; false if
	// it does not.
	//
	// If this property is true for an entity, a client application
	// can set the `PerfQuerySpec.intervalId` of the
	// `PerfQuerySpec` (passed to the
	// `PerformanceManager.QueryPerf` operation) to the `PerfProviderSummary.refreshRate` to obtain the maximum information possible for the
	// entity.
	CurrentSupported bool `xml:"currentSupported" json:"currentSupported"`
	// True if this entity supports historical (aggregated) statistics; false
	// if it does not.
	//
	// When this property is true for an entity, a client
	// application can set the `PerfQuerySpec.intervalId` of `PerformanceManager.QueryPerf` to one of the historical `intervals` to obtain historical statistics for this
	// entity.
	SummarySupported bool `xml:"summarySupported" json:"summarySupported"`
	// Number of seconds between the generation of each counter.
	//
	// This value
	// applies only to entities that support real-time (current)
	// statistics&#46;
	RefreshRate int32 `xml:"refreshRate,omitempty" json:"refreshRate,omitempty"`
}

func init() {
	t["PerfProviderSummary"] = reflect.TypeOf((*PerfProviderSummary)(nil)).Elem()
}

// This data object specifies the query parameters, including the managed
// object reference to the target entity for statistics retrieval.
//   - If the optional `PerfQuerySpec.intervalId` is omitted, the metrics are
//     returned in their originally sampled interval.
//   - When an `PerfQuerySpec.intervalId` is specified, the server tries to
//     summarize the information for the specified `PerfQuerySpec.intervalId`.
//     However, if that interval does not exist or has no data, the
//     server summarizes the information using the best interval
//     available.
//   - If the range between `PerfQuerySpec.startTime` and `PerfQuerySpec.endTime` crosses
//     multiple sample interval periods, the result contains data from the
//     longest interval in the period.
type PerfQuerySpec struct {
	DynamicData

	// The managed object whose performance statistics are being queried.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// The server time from which to obtain counters.
	//
	// If not specified,
	// defaults to the first available counter. When a startTime is
	// specified, the returned samples do not include the sample at
	// startTime.
	StartTime *time.Time `xml:"startTime" json:"startTime,omitempty"`
	// The time up to which statistics are retrieved.
	//
	// Corresponds to server
	// time. When endTime is omitted, the returned result includes up to the
	// most recent metric value. When an endTime is specified, the returned
	// samples include the sample at endTime.
	EndTime *time.Time `xml:"endTime" json:"endTime,omitempty"`
	// Limits the number of samples returned.
	//
	// Defaults to the most recent
	// sample (or samples), unless a time range is specified. Use this
	// property only in conjunction with the `PerfQuerySpec.intervalId` to obtain
	// real-time statistics (set the `PerfQuerySpec.intervalId` to the `PerfProviderSummary.refreshRate`. This property is
	// ignored for historical statistics, and is not valid for the `PerformanceManager.QueryPerfComposite` operation.
	MaxSample int32 `xml:"maxSample,omitempty" json:"maxSample,omitempty"`
	// The performance metrics to be retrieved.
	//
	// This property is required for
	// the `PerformanceManager.QueryPerfComposite` operation.
	MetricId []PerfMetricId `xml:"metricId,omitempty" json:"metricId,omitempty"`
	// The interval (`PerfInterval.samplingPeriod`), in seconds,
	// for the performance statistics&#46; For aggregated information, use
	// one of the historical intervals for this property.
	//
	// See `PerfInterval` for more information.
	//   - To obtain the greatest detail, use the provider&#146;s `PerfProviderSummary.refreshRate` for this
	//     property.
	IntervalId int32 `xml:"intervalId,omitempty" json:"intervalId,omitempty"`
	// The format to be used while returning the statistics&#46;
	//
	// See also `PerfFormat_enum`.
	Format string `xml:"format,omitempty" json:"format,omitempty"`
}

func init() {
	t["PerfQuerySpec"] = reflect.TypeOf((*PerfQuerySpec)(nil)).Elem()
}

// This data object type describes information contained in a sample
// collection, its timestamp, and sampling interval.
type PerfSampleInfo struct {
	DynamicData

	// The time at which the sample was collected.
	Timestamp time.Time `xml:"timestamp" json:"timestamp"`
	// The interval in seconds for which performance statistics were
	// collected.
	//
	// This can be the refreshRate of the managed object for which
	// this statistics was collected or one of the intervals for historical
	// statistics configured in the system. See `PerformanceManager.UpdatePerfInterval` for more information about the intervals
	// configured in the system.
	Interval int32 `xml:"interval" json:"interval"`
}

func init() {
	t["PerfSampleInfo"] = reflect.TypeOf((*PerfSampleInfo)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.PerformDvsProductSpecOperation_Task`.
type PerformDvsProductSpecOperationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The operation. See `DistributedVirtualSwitchProductSpecOperationType_enum` for
	// valid values. For
	// `VmwareDistributedVirtualSwitch`,
	// only `upgrade`
	// is valid.
	Operation string `xml:"operation" json:"operation"`
	// The product info of the implementation.
	ProductSpec *DistributedVirtualSwitchProductSpec `xml:"productSpec,omitempty" json:"productSpec,omitempty"`
}

func init() {
	t["PerformDvsProductSpecOperationRequestType"] = reflect.TypeOf((*PerformDvsProductSpecOperationRequestType)(nil)).Elem()
}

type PerformDvsProductSpecOperation_Task PerformDvsProductSpecOperationRequestType

func init() {
	t["PerformDvsProductSpecOperation_Task"] = reflect.TypeOf((*PerformDvsProductSpecOperation_Task)(nil)).Elem()
}

type PerformDvsProductSpecOperation_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type PerformVsanUpgradePreflightCheck PerformVsanUpgradePreflightCheckRequestType

func init() {
	t["PerformVsanUpgradePreflightCheck"] = reflect.TypeOf((*PerformVsanUpgradePreflightCheck)(nil)).Elem()
}

// The parameters of `VsanUpgradeSystem.PerformVsanUpgradePreflightCheck`.
type PerformVsanUpgradePreflightCheckRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The cluster for which to perform the check.
	//
	// Refers instance of `ClusterComputeResource`.
	Cluster ManagedObjectReference `xml:"cluster" json:"cluster"`
	// Intend to perform a on-disk format downgrade instead
	// of upgrade. Adds additional checks.
	DowngradeFormat *bool `xml:"downgradeFormat" json:"downgradeFormat,omitempty"`
}

func init() {
	t["PerformVsanUpgradePreflightCheckRequestType"] = reflect.TypeOf((*PerformVsanUpgradePreflightCheckRequestType)(nil)).Elem()
}

type PerformVsanUpgradePreflightCheckResponse struct {
	Returnval VsanUpgradeSystemPreflightCheckResult `xml:"returnval" json:"returnval"`
}

// The parameters of `VsanUpgradeSystem.PerformVsanUpgrade_Task`.
type PerformVsanUpgradeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The cluster to be upgraded
	//
	// Refers instance of `ClusterComputeResource`.
	Cluster ManagedObjectReference `xml:"cluster" json:"cluster"`
	// After all disk groups have been updated, also
	// upgrade all objects. Once started, rollback
	// of the on disk format is no longer possible.
	// Object upgrade unlocks new VSAN features.
	PerformObjectUpgrade *bool `xml:"performObjectUpgrade" json:"performObjectUpgrade,omitempty"`
	// Perform a on-disk format downgrade instead of
	// upgrade. Only possible if no upgraded objects exist.
	DowngradeFormat *bool `xml:"downgradeFormat" json:"downgradeFormat,omitempty"`
	// Removes the need for one disk group worth of
	// free space, by allowing reduced redundancy
	// during disk upgrade.
	AllowReducedRedundancy *bool `xml:"allowReducedRedundancy" json:"allowReducedRedundancy,omitempty"`
	// Internal debug option meant for functional testing
	// of VSAN upgrades. Skips upgrade on certain hosts and
	// implies performObjectUpgrade being false. Should not
	// be used by customers.
	//
	// Refers instances of `HostSystem`.
	ExcludeHosts []ManagedObjectReference `xml:"excludeHosts,omitempty" json:"excludeHosts,omitempty"`
}

func init() {
	t["PerformVsanUpgradeRequestType"] = reflect.TypeOf((*PerformVsanUpgradeRequestType)(nil)).Elem()
}

type PerformVsanUpgrade_Task PerformVsanUpgradeRequestType

func init() {
	t["PerformVsanUpgrade_Task"] = reflect.TypeOf((*PerformVsanUpgrade_Task)(nil)).Elem()
}

type PerformVsanUpgrade_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Static strings for performance metrics.
type PerformanceDescription struct {
	DynamicData

	// Identifies the `type` of
	// the counter.
	CounterType []BaseElementDescription `xml:"counterType,typeattr" json:"counterType"`
	// Identifies the `type`
	// of statistic.
	StatsType []BaseElementDescription `xml:"statsType,typeattr" json:"statsType"`
}

func init() {
	t["PerformanceDescription"] = reflect.TypeOf((*PerformanceDescription)(nil)).Elem()
}

// `PerformanceManagerCounterLevelMapping` class captures the counter
// and level mapping.
//
// Any counter has two aspects: aggregate value or the
// per-device value. For example, cpu.usage.average on a host is an
// aggregate counter and cpu.usage.average on pcpus in a host is a
// per-device counters. There is a need to be able to specify different
// levels for the two versions. Currently, all per-device stats are
// collected at level greater than or equal to 3.
//
// In order to be able to configure the level of collections for
// aggregate and per-device counters we have two optional level fields.
// `PerformanceManagerCounterLevelMapping` is used to update the
// levels for a counter.
type PerformanceManagerCounterLevelMapping struct {
	DynamicData

	// The counter Id
	CounterId int32 `xml:"counterId" json:"counterId"`
	// Level for the aggregate counter.
	//
	// If not set then the value is not
	// changed when updateCounterLevelMapping is called.
	AggregateLevel int32 `xml:"aggregateLevel,omitempty" json:"aggregateLevel,omitempty"`
	// Level for the per device counter.
	//
	// If not set then the value is not
	// changed when updateCounterLevelMapping is called.
	PerDeviceLevel int32 `xml:"perDeviceLevel,omitempty" json:"perDeviceLevel,omitempty"`
}

func init() {
	t["PerformanceManagerCounterLevelMapping"] = reflect.TypeOf((*PerformanceManagerCounterLevelMapping)(nil)).Elem()
}

// Data object to capture all information needed to
// describe a sample inventory.
type PerformanceStatisticsDescription struct {
	DynamicData

	// Historic interval setting.
	//
	// Default value is the same as the historic
	// interval settings of the current instance
	// of running VC.
	Intervals []PerfInterval `xml:"intervals,omitempty" json:"intervals,omitempty"`
}

func init() {
	t["PerformanceStatisticsDescription"] = reflect.TypeOf((*PerformanceStatisticsDescription)(nil)).Elem()
}

// This data object type provides assignment of some role access to
// a principal on a specific entity.
//
// A ManagedEntity is limited to
// one permission per principal.
type Permission struct {
	DynamicData

	// Managed entity the permission is defined on.
	//
	// Left unset
	// when calling setPermissions or resetPermissions, but present
	// for the results of permission queries.
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
	// User or group receiving access in the form of
	// "login" for local or "DOMAIN\\login" for users in a Windows domain.
	Principal string `xml:"principal" json:"principal"`
	// Whether principal refers to a user or a group.
	//
	// True for
	// a group and false for a user.
	Group bool `xml:"group" json:"group"`
	// Reference to the role providing the access.
	RoleId int32 `xml:"roleId" json:"roleId"`
	// Whether or not this permission propagates down the hierarchy
	// to sub-entities.
	Propagate bool `xml:"propagate" json:"propagate"`
}

func init() {
	t["Permission"] = reflect.TypeOf((*Permission)(nil)).Elem()
}

// This event records the creation of a permission.
type PermissionAddedEvent struct {
	PermissionEvent

	// The associated role.
	Role RoleEventArgument `xml:"role" json:"role"`
	// Whether or not the permission applies to sub-entities.
	Propagate bool `xml:"propagate" json:"propagate"`
}

func init() {
	t["PermissionAddedEvent"] = reflect.TypeOf((*PermissionAddedEvent)(nil)).Elem()
}

// This event records a permission operation.
type PermissionEvent struct {
	AuthorizationEvent

	// The entity to which the permission applied.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
	// The user name or group to which the permission was granted.
	Principal string `xml:"principal" json:"principal"`
	// Whether or not the principal was a group.
	Group bool `xml:"group" json:"group"`
}

func init() {
	t["PermissionEvent"] = reflect.TypeOf((*PermissionEvent)(nil)).Elem()
}

// The `PermissionProfile` data object represents the profile
// for a permission rule.
//
// Use the `ApplyProfile.policy` list for
// access to configuration data for the permission profile. Use the
// `ApplyProfile.property` list for access to subprofiles, if any.
type PermissionProfile struct {
	ApplyProfile

	Key string `xml:"key" json:"key"`
}

func init() {
	t["PermissionProfile"] = reflect.TypeOf((*PermissionProfile)(nil)).Elem()
}

// This event records the removal of a permission.
type PermissionRemovedEvent struct {
	PermissionEvent
}

func init() {
	t["PermissionRemovedEvent"] = reflect.TypeOf((*PermissionRemovedEvent)(nil)).Elem()
}

// This event records the update of a permission.
type PermissionUpdatedEvent struct {
	PermissionEvent

	// The associated role.
	Role RoleEventArgument `xml:"role" json:"role"`
	// Whether or not the permission applies to sub-entities.
	Propagate bool `xml:"propagate" json:"propagate"`
	// The previous associated role.
	PrevRole *RoleEventArgument `xml:"prevRole,omitempty" json:"prevRole,omitempty"`
	// Previous propogate value.
	PrevPropagate *bool `xml:"prevPropagate" json:"prevPropagate,omitempty"`
}

func init() {
	t["PermissionUpdatedEvent"] = reflect.TypeOf((*PermissionUpdatedEvent)(nil)).Elem()
}

// The virtual machine is configured with a Raw Disk Mapping in physical compatibility mode.
//
// This mode is not supported on the host.
type PhysCompatRDMNotSupported struct {
	RDMNotSupported
}

func init() {
	t["PhysCompatRDMNotSupported"] = reflect.TypeOf((*PhysCompatRDMNotSupported)(nil)).Elem()
}

type PhysCompatRDMNotSupportedFault PhysCompatRDMNotSupported

func init() {
	t["PhysCompatRDMNotSupportedFault"] = reflect.TypeOf((*PhysCompatRDMNotSupportedFault)(nil)).Elem()
}

// This data object type describes the physical network adapter
// as seen by the primary operating system.
type PhysicalNic struct {
	DynamicData

	// The linkable identifier.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// The device name of the physical network adapter.
	Device string `xml:"device" json:"device"`
	// Device hash of the PCI device corresponding to this
	// physical network adapter.
	Pci string `xml:"pci" json:"pci"`
	// The name of the driver.
	//
	// From command line: esxcli network nic get
	Driver string `xml:"driver,omitempty" json:"driver,omitempty"`
	// The version of the physical network adapter operating system driver.
	DriverVersion string `xml:"driverVersion,omitempty" json:"driverVersion,omitempty" vim:"8.0.0.1"`
	// The version of the firmware running in the network adapter.
	FirmwareVersion string `xml:"firmwareVersion,omitempty" json:"firmwareVersion,omitempty" vim:"8.0.0.1"`
	// The current link state of the physical network adapter.
	//
	// If this object is not set, then the link is down.
	LinkSpeed *PhysicalNicLinkInfo `xml:"linkSpeed,omitempty" json:"linkSpeed,omitempty"`
	// The valid combinations of speed and duplexity for this
	// physical network adapter.
	//
	// The speed and the duplex settings usually must be configured
	// as a pair. This array lists all the valid combinations available
	// for a physical network adapter.
	//
	// Autonegotiate is not listed as one of the combinations supported.
	// If is implicitly supported by the physical network adapter
	// unless `PhysicalNic.autoNegotiateSupported` is set to false.
	ValidLinkSpecification []PhysicalNicLinkInfo `xml:"validLinkSpecification,omitempty" json:"validLinkSpecification,omitempty"`
	// The specification of the physical network adapter.
	Spec PhysicalNicSpec `xml:"spec" json:"spec"`
	// Flag indicating whether the NIC is wake-on-LAN capable
	WakeOnLanSupported bool `xml:"wakeOnLanSupported" json:"wakeOnLanSupported"`
	// The media access control (MAC) address of the physical
	// network adapter.
	Mac string `xml:"mac" json:"mac"`
	// The FCoE configuration of the physical network adapter.
	FcoeConfiguration *FcoeConfig `xml:"fcoeConfiguration,omitempty" json:"fcoeConfiguration,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
	// there is no replacement.
	//
	// Flag indicating whether the NIC supports VMDirectPath Gen 2.
	//
	// Note that
	// this is only an indicator of the capabilities of this NIC, not of the
	// whole host.
	//
	// If the host software is not capable of VMDirectPath Gen 2,
	// this property will be unset, as the host cannot provide information on
	// the NIC capability.
	//
	// See also `HostCapability.vmDirectPathGen2Supported`.
	VmDirectPathGen2Supported *bool `xml:"vmDirectPathGen2Supported" json:"vmDirectPathGen2Supported,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
	// there is no replacement.
	//
	// If `PhysicalNic.vmDirectPathGen2Supported` is true, this property advertises
	// the VMDirectPath Gen 2 mode supported by this NIC (chosen from
	// `PhysicalNicVmDirectPathGen2SupportedMode_enum`).
	//
	// A mode may require that the associated vSphere Distributed Switch have
	// a particular ProductSpec in order for network passthrough to be possible.
	VmDirectPathGen2SupportedMode string `xml:"vmDirectPathGen2SupportedMode,omitempty" json:"vmDirectPathGen2SupportedMode,omitempty"`
	// Flag indicating whether the NIC allows resource pool based scheduling
	// for network I/O control.
	ResourcePoolSchedulerAllowed *bool `xml:"resourcePoolSchedulerAllowed" json:"resourcePoolSchedulerAllowed,omitempty"`
	// If `PhysicalNic.resourcePoolSchedulerAllowed` is false, this property
	// advertises the reason for disallowing resource scheduling on
	// this NIC.
	//
	// The reasons may be one of
	// `PhysicalNicResourcePoolSchedulerDisallowedReason_enum`
	ResourcePoolSchedulerDisallowedReason []string `xml:"resourcePoolSchedulerDisallowedReason,omitempty" json:"resourcePoolSchedulerDisallowedReason,omitempty"`
	// If set the flag indicates if the physical network adapter supports
	// autonegotiate.
	AutoNegotiateSupported *bool `xml:"autoNegotiateSupported" json:"autoNegotiateSupported,omitempty"`
	// If set the flag indicates whether a physical nic supports Enhanced
	// Networking Stack driver
	EnhancedNetworkingStackSupported *bool `xml:"enhancedNetworkingStackSupported" json:"enhancedNetworkingStackSupported,omitempty"`
	// If set the flag indicates whether a physical nic supports Enhanced
	// Networking Stack interrupt mode
	EnsInterruptSupported *bool `xml:"ensInterruptSupported" json:"ensInterruptSupported,omitempty"`
	// Associated RDMA device, if any.
	RdmaDevice string `xml:"rdmaDevice,omitempty" json:"rdmaDevice,omitempty"`
	// The identifier of the DPU by which the physical NIC is backed.
	//
	// When physical NIC is not backed by DPU, dpuId will be unset.
	DpuId string `xml:"dpuId,omitempty" json:"dpuId,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["PhysicalNic"] = reflect.TypeOf((*PhysicalNic)(nil)).Elem()
}

// The capability of the CDP-awared device that connects to a Physical NIC.
//
// `PhysicalNicCdpInfo`
type PhysicalNicCdpDeviceCapability struct {
	DynamicData

	// The CDP-awared device has the capability of a routing for
	// at least one network layer protocol
	Router bool `xml:"router" json:"router"`
	// The CDP-awared device has the capability of transparent
	// bridging
	TransparentBridge bool `xml:"transparentBridge" json:"transparentBridge"`
	// The CDP-awared device has the capability of source-route
	// bridging
	SourceRouteBridge bool `xml:"sourceRouteBridge" json:"sourceRouteBridge"`
	// The CDP-awared device has the capability of switching.
	//
	// The
	// difference between this capability and transparentBridge is
	// that a switch does not run the Spanning-Tree Protocol. This
	// device is assumed to be deployed in a physical loop-free topology.
	NetworkSwitch bool `xml:"networkSwitch" json:"networkSwitch"`
	// The CDP-awared device has the capability of a host, which
	// Sends and receives packets for at least one network layer protocol.
	Host bool `xml:"host" json:"host"`
	// The CDP-awared device is IGMP-enabled, which does not forward IGMP
	// Report packets on nonrouter ports.
	IgmpEnabled bool `xml:"igmpEnabled" json:"igmpEnabled"`
	// The CDP-awared device has the capability of a repeater
	Repeater bool `xml:"repeater" json:"repeater"`
}

func init() {
	t["PhysicalNicCdpDeviceCapability"] = reflect.TypeOf((*PhysicalNicCdpDeviceCapability)(nil)).Elem()
}

// CDP (Cisco Discovery Protocol) is a link level protocol that allows
// for discovering the CDP-awared network hardware at either end of a
// DIRECT connection.
//
// It's only good for direct connection because CDP
// doesn't get forwarded through switches.
// It's a simple advertisement protocol which beacons information about
// the switch or host along with some port information. The CDP information
// allows ESX Server admins to know which Cisco switch port is connected to
// any given virtual switch uplink (PNIC).
type PhysicalNicCdpInfo struct {
	DynamicData

	// CDP version.
	//
	// The value is always 1.
	CdpVersion int32 `xml:"cdpVersion,omitempty" json:"cdpVersion,omitempty"`
	// This is the periodicity of advertisement, the time between two
	// successive CDP message transmissions
	Timeout int32 `xml:"timeout,omitempty" json:"timeout,omitempty"`
	// Time-To-Live.
	//
	// the amount of time, in seconds, that a receiver should
	// retain the information contained in the CDP packet.
	Ttl int32 `xml:"ttl,omitempty" json:"ttl,omitempty"`
	// The number of CDP messages we have received from the device.
	Samples int32 `xml:"samples,omitempty" json:"samples,omitempty"`
	// Device ID which identifies the device.
	//
	// By default, the device ID is
	// either the device's fully-qualified host name (including the domain
	// name) or the device's hardware serial number in ASCII.
	DevId string `xml:"devId,omitempty" json:"devId,omitempty"`
	// The advertised IP address that is assigned to the interface of the device
	// on which the CDP message is sent.
	//
	// The device can advertise all addresses for
	// a given protocol suite and, optionally, can advertise one or more loopback
	// IP addresses. But this property only show the first address.
	Address string `xml:"address,omitempty" json:"address,omitempty"`
	// Port ID.
	//
	// An ASCII character string that identifies the port on which
	// the CDP message is sent, e.g. "FastEthernet0/8"
	PortId string `xml:"portId,omitempty" json:"portId,omitempty"`
	// Device Capability
	// `PhysicalNicCdpDeviceCapability`
	DeviceCapability *PhysicalNicCdpDeviceCapability `xml:"deviceCapability,omitempty" json:"deviceCapability,omitempty"`
	// Software version on the device.
	//
	// A character string that provides
	// information about the software release version that the device is
	// running. e.g. "Cisco Internetwork Operating Syscisco WS-C2940-8TT-S"
	SoftwareVersion string `xml:"softwareVersion,omitempty" json:"softwareVersion,omitempty"`
	// Hardware platform.
	//
	// An ASCII character string that describes the
	// hardware platform of the device , e.g. "cisco WS-C2940-8TT-S"
	HardwarePlatform string `xml:"hardwarePlatform,omitempty" json:"hardwarePlatform,omitempty"`
	// IP prefix.
	//
	// Each IP prefix represents one of the directly connected
	// IP network segments of the local route.
	IpPrefix string `xml:"ipPrefix,omitempty" json:"ipPrefix,omitempty"`
	// ipPrefix length.
	IpPrefixLen int32 `xml:"ipPrefixLen,omitempty" json:"ipPrefixLen,omitempty"`
	// The native VLAN of advertising port.
	//
	// The native VLAN is the VLAN to
	// which a port returns when it is not trunking. Also, the native VLAN
	// is the untagged VLAN on an 802.1Q trunk.
	Vlan int32 `xml:"vlan,omitempty" json:"vlan,omitempty"`
	// Half/full duplex setting of the advertising port.
	FullDuplex *bool `xml:"fullDuplex" json:"fullDuplex,omitempty"`
	// MTU, the maximum transmission unit for the advertising port.
	//
	// Possible
	// values are 1500 through 18190.
	Mtu int32 `xml:"mtu,omitempty" json:"mtu,omitempty"`
	// The configured SNMP system name of the device.
	SystemName string `xml:"systemName,omitempty" json:"systemName,omitempty"`
	// The configured SNMP system OID of the device.
	SystemOID string `xml:"systemOID,omitempty" json:"systemOID,omitempty"`
	// The configured IP address of the SNMP management interface for the
	// device.
	MgmtAddr string `xml:"mgmtAddr,omitempty" json:"mgmtAddr,omitempty"`
	// The configured location of the device.
	Location string `xml:"location,omitempty" json:"location,omitempty"`
}

func init() {
	t["PhysicalNicCdpInfo"] = reflect.TypeOf((*PhysicalNicCdpInfo)(nil)).Elem()
}

// The configuration of the physical network adapter containing
// both the configurable properties and identification information.
type PhysicalNicConfig struct {
	DynamicData

	// PhysicalNic device to which configuration applies.
	Device string `xml:"device" json:"device"`
	// The specification of the physical network adapter.
	Spec PhysicalNicSpec `xml:"spec" json:"spec"`
}

func init() {
	t["PhysicalNicConfig"] = reflect.TypeOf((*PhysicalNicConfig)(nil)).Elem()
}

// This data object type describes each network of a physical
// network adapter's network hint.
type PhysicalNicHint struct {
	DynamicData

	// The optional VLAN Id of the network.
	VlanId int32 `xml:"vlanId,omitempty" json:"vlanId,omitempty"`
}

func init() {
	t["PhysicalNicHint"] = reflect.TypeOf((*PhysicalNicHint)(nil)).Elem()
}

// The NetworkHint data object type is some information about
// the network to which the
// physical network adapter is attached.
type PhysicalNicHintInfo struct {
	DynamicData

	// The physical network adapter device to which
	// this hint applies.
	Device string `xml:"device" json:"device"`
	// The list of subnets that were detected on this
	// physical network adapter.
	Subnet []PhysicalNicIpHint `xml:"subnet,omitempty" json:"subnet,omitempty"`
	// The list of network names that were detected on this
	// physical network adapter.
	Network []PhysicalNicNameHint `xml:"network,omitempty" json:"network,omitempty"`
	// If the uplink directly connects to a CDP-awared network device
	// and the device's CDP broadcast is enabled, this property will be
	// set to return the CDP information that vmkernel received on this
	// Physical NIC.
	//
	// CDP data contains the device information and port ID that
	// the Physical NIC connects to. If the uplink is not connecting to a
	// CDP-awared device or CDP is not enabled on the device, this
	// property will be unset.
	// `PhysicalNicCdpInfo`
	ConnectedSwitchPort *PhysicalNicCdpInfo `xml:"connectedSwitchPort,omitempty" json:"connectedSwitchPort,omitempty"`
	// If the uplink directly connects to an LLDP-aware network device and
	// the device's LLDP broadcast is enabled, this property will be set to
	// return the LLDP information that is received on this physical network
	// adapter.
	//
	// If the uplink is not connecting to a LLDP-aware device or
	// LLDP is not enabled on the device, this property will be unset.
	LldpInfo *LinkLayerDiscoveryProtocolInfo `xml:"lldpInfo,omitempty" json:"lldpInfo,omitempty"`
}

func init() {
	t["PhysicalNicHintInfo"] = reflect.TypeOf((*PhysicalNicHintInfo)(nil)).Elem()
}

// This data object type describes a network in network hint where
// the network is specified using IP addresses, for example,
// 10.27.49.1-10.27.49.254
type PhysicalNicIpHint struct {
	PhysicalNicHint

	// The network IP addresses.
	IpSubnet string `xml:"ipSubnet" json:"ipSubnet"`
}

func init() {
	t["PhysicalNicIpHint"] = reflect.TypeOf((*PhysicalNicIpHint)(nil)).Elem()
}

// The `PhysicalNicLinkInfo` data object describes
// the link speed and the type of duplex communication.
//
// The link speed indicates
// the bit rate in megabits per second. The duplex boolean indicates if the link
// is capable of full-duplex or half-duplex communication.
type PhysicalNicLinkInfo struct {
	DynamicData

	// Bit rate on the link.
	SpeedMb int32 `xml:"speedMb" json:"speedMb"`
	// Flag to indicate whether or not the link is capable of
	// full-duplex ("true") or only half-duplex ("false").
	Duplex bool `xml:"duplex" json:"duplex"`
}

func init() {
	t["PhysicalNicLinkInfo"] = reflect.TypeOf((*PhysicalNicLinkInfo)(nil)).Elem()
}

// This data object type describes a network in network hint where
// the network describes the color, label, or the name of the
// network.
type PhysicalNicNameHint struct {
	PhysicalNicHint

	// The network name.
	Network string `xml:"network" json:"network"`
}

func init() {
	t["PhysicalNicNameHint"] = reflect.TypeOf((*PhysicalNicNameHint)(nil)).Elem()
}

// The `PhysicalNicProfile` data object represents physical NIC configuration.
//
// Use the `ApplyProfile.policy` list for access to configuration data
// for the physical NIC profile. Use the `ApplyProfile.property` list
// for access to subprofile configuration data, if any.
type PhysicalNicProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["PhysicalNicProfile"] = reflect.TypeOf((*PhysicalNicProfile)(nil)).Elem()
}

// This data object type describes the physical network adapter specification
// representing the properties on a physical network adapter that
// can be configured once the object exists.
type PhysicalNicSpec struct {
	DynamicData

	// The IP configuration on the physical network adapter (applies
	// only to a hosted network adapter).
	//
	// The data object will be NULL on an ESX Server system.
	Ip *HostIpConfig `xml:"ip,omitempty" json:"ip,omitempty"`
	// The link speed and duplexity that this physical network
	// adapter is currently
	// configured to use.
	//
	// If this property is not set, the physical
	// network adapter autonegotiates its proper settings.
	LinkSpeed *PhysicalNicLinkInfo `xml:"linkSpeed,omitempty" json:"linkSpeed,omitempty"`
	// If set the flag indicates if the physical network adapter is
	// configured for Enhanced Networking Stack
	EnableEnhancedNetworkingStack *bool `xml:"enableEnhancedNetworkingStack" json:"enableEnhancedNetworkingStack,omitempty"`
	// If set the flag indicates if the physical network adapter is
	// configured for Enhanced Networking Stack interrupt mode
	EnsInterruptEnabled *bool `xml:"ensInterruptEnabled" json:"ensInterruptEnabled,omitempty"`
}

func init() {
	t["PhysicalNicSpec"] = reflect.TypeOf((*PhysicalNicSpec)(nil)).Elem()
}

// Specifies SSL policy to trust a pinned SSL certificate.
type PinnedCertificate struct {
	IoFilterManagerSslTrust

	// PEM-encoded pinned SSL certificate of the server that needs to be
	// trusted.
	SslCertificate string `xml:"sslCertificate" json:"sslCertificate"`
}

func init() {
	t["PinnedCertificate"] = reflect.TypeOf((*PinnedCertificate)(nil)).Elem()
	minAPIVersionForType["PinnedCertificate"] = "8.0.3.0"
}

type PlaceVm PlaceVmRequestType

func init() {
	t["PlaceVm"] = reflect.TypeOf((*PlaceVm)(nil)).Elem()
}

// The parameters of `ClusterComputeResource.PlaceVm`.
type PlaceVmRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specification for placing a virtual machine
	// and its virtual disks
	PlacementSpec PlacementSpec `xml:"placementSpec" json:"placementSpec"`
}

func init() {
	t["PlaceVmRequestType"] = reflect.TypeOf((*PlaceVmRequestType)(nil)).Elem()
}

type PlaceVmResponse struct {
	Returnval PlacementResult `xml:"returnval" json:"returnval"`
}

// Describes a placement action of a single virtual machine.
//
// One or more of such actions can be included in a placement recommendation,
// and such recommendations can be generated by the
// `ClusterComputeResource.PlaceVm` method.
type PlacementAction struct {
	ClusterAction

	// Virtual machine reference.
	//
	// Unset if the VM has not been created.
	//
	// Refers instance of `VirtualMachine`.
	Vm *ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
	// The host where the virtual machine should be placed.
	//
	// Unset if no host recommendation is provided.
	//
	// Refers instance of `HostSystem`.
	TargetHost *ManagedObjectReference `xml:"targetHost,omitempty" json:"targetHost,omitempty"`
	// Specification for placing the configuration files and the virtual
	// disks of the virtual machine on one or more datastores.
	//
	// Unset if no datastore recommendation is provided.
	RelocateSpec *VirtualMachineRelocateSpec `xml:"relocateSpec,omitempty" json:"relocateSpec,omitempty"`
}

func init() {
	t["PlacementAction"] = reflect.TypeOf((*PlacementAction)(nil)).Elem()
}

// The `PlacementAffinityRule` data object specifies
// affinity rules for placement
type PlacementAffinityRule struct {
	DynamicData

	// Type of affinity rule.
	//
	// The set of possible values are described in
	// `PlacementAffinityRuleRuleType_enum`
	RuleType string `xml:"ruleType" json:"ruleType"`
	// Scope of the affinity rule.
	//
	// The set of possible values are described in
	// `PlacementAffinityRuleRuleScope_enum`
	RuleScope string `xml:"ruleScope" json:"ruleScope"`
	// List of virtual machines that are part of this rule.
	//
	// Refers instances of `VirtualMachine`.
	Vms []ManagedObjectReference `xml:"vms,omitempty" json:"vms,omitempty"`
	// List of PlacementSpec keys that are part of this rule representing
	// virtual machines yet to be placed.
	Keys []string `xml:"keys,omitempty" json:"keys,omitempty"`
}

func init() {
	t["PlacementAffinityRule"] = reflect.TypeOf((*PlacementAffinityRule)(nil)).Elem()
}

// PlacementRankResult is the class of the result returned by
// the vCenter Server for rankClustersForPlacement method
type PlacementRankResult struct {
	DynamicData

	// Reference key for the placement request
	Key string `xml:"key" json:"key"`
	// Candidate cluster for the placement problem
	//
	// Refers instance of `ClusterComputeResource`.
	Candidate ManagedObjectReference `xml:"candidate" json:"candidate"`
	// The reserved storage space for the candidate cluster after placement
	// The unit is in Megabytes
	ReservedSpaceMB int64 `xml:"reservedSpaceMB" json:"reservedSpaceMB"`
	// The expected space usage for the candidate cluster after placement
	// The unit is in Megabytes
	UsedSpaceMB int64 `xml:"usedSpaceMB" json:"usedSpaceMB"`
	// The expected total space for the candidate cluster after placement
	// The unit is in Megabytes
	TotalSpaceMB int64 `xml:"totalSpaceMB" json:"totalSpaceMB"`
	// The expected aggregate resource utilization for the candidate cluster
	// after placement
	// The unit is a fractional value between 0 and 1.
	Utilization float64 `xml:"utilization" json:"utilization"`
	// Information about why a given cluster is not recommended for
	// placement
	Faults []LocalizedMethodFault `xml:"faults,omitempty" json:"faults,omitempty"`
}

func init() {
	t["PlacementRankResult"] = reflect.TypeOf((*PlacementRankResult)(nil)).Elem()
}

// PlacementRankSpec encapsulates all of the inputs passed to
// the `StorageResourceManager.RankForPlacement` method.
type PlacementRankSpec struct {
	DynamicData

	// List of VM placement specifications for ranking clusters
	Specs []PlacementSpec `xml:"specs" json:"specs"`
	// List of candidate clusters for the placement request
	//
	// Refers instances of `ClusterComputeResource`.
	Clusters []ManagedObjectReference `xml:"clusters" json:"clusters"`
	// List of affinity rules for the placement request
	Rules []PlacementAffinityRule `xml:"rules,omitempty" json:"rules,omitempty"`
	// List of preferred clusters for individual VM placement requests
	PlacementRankByVm []StorageDrsPlacementRankVmSpec `xml:"placementRankByVm,omitempty" json:"placementRankByVm,omitempty"`
}

func init() {
	t["PlacementRankSpec"] = reflect.TypeOf((*PlacementRankSpec)(nil)).Elem()
}

// `ClusterComputeResource.PlaceVm` method can invoke DRS
// for recommendations for target hosts and datastores for placing a
// virtual machine and its virtual disks using xVMotion.
//
// PlacementResult is the class of the result returned by that method.
type PlacementResult struct {
	DynamicData

	// The list of recommendations for where to place the virtual machine
	// and its virtual disks.
	Recommendations []ClusterRecommendation `xml:"recommendations,omitempty" json:"recommendations,omitempty"`
	// Information about any fault in case DRS fails to make a recommendation.
	DrsFault *ClusterDrsFaults `xml:"drsFault,omitempty" json:"drsFault,omitempty"`
}

func init() {
	t["PlacementResult"] = reflect.TypeOf((*PlacementResult)(nil)).Elem()
}

// PlacementSpec encapsulates all of the information passed to the
// `ClusterComputeResource.PlaceVm` method, which asks
// DRS for recommendations for target hosts and datastores for placing
// a virtual machine and its virtual disks in a cluster using
// unified VMotion.
type PlacementSpec struct {
	DynamicData

	// Priority of the migration operation.
	//
	// The default value is defaultPriority.
	Priority VirtualMachineMovePriority `xml:"priority,omitempty" json:"priority,omitempty"`
	// The virtual machine to be placed.
	//
	// For an intra-vCenter migration, this argument is required.
	// For a cross-vCenter migration, this argument should be unset,
	// and the caller is responsible for applying the DRS-recommended
	// placement to the correct vm.
	//
	// Refers instance of `VirtualMachine`.
	Vm *ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
	// Configuration information for the virtual machine.
	//
	// For an intra-vCenter migration, this argument should be unset.
	// For a cross-vCenter migration, this argument is required.
	// In the latter case, the following elements of the configSpec
	// will be expected: version, cpuAllocation, memoryAllocation, numCPUs,
	// memoryMB, files, swapPlacement; in addition, the configSpec.deviceChange
	// should contain all the virtual disks of the virtual machine to be migrated.
	// If configSpec.deviceChange is empty, the vm will be treated as a
	// diskless vm.
	// If a storage profile is specified for a virtual disk or vm configuration,
	// only datastores that match this profile will be considered for that
	// virtual disk or vm configuration.
	ConfigSpec *VirtualMachineConfigSpec `xml:"configSpec,omitempty" json:"configSpec,omitempty"`
	// Specification for relocating a virtual machine.
	//
	// Can be used to optionally specify a target host, a target datastore,
	// or a target resource pool. If a target host is specified, this host
	// becomes the recommended host; if a target datastore is specified,
	// this datastore becomes the recommended datastore; if no resource
	// pool is specified, the virtual machine will be attached to the
	// cluster root resource pool; if the target resource pool specified
	// is a VirtualApp, an InvalidArgument fault will be thrown.
	// If a storage profile is specified for a virtual disk or vm configuration,
	// only datastores that match this profile will be considered for that
	// virtual disk or vm configuration.
	// For cross-vCenter migration, the caller
	// should set the service and the folder arguments properly either in
	// the input relocateSpec or in the output relocateSpec in the placement
	// recommendation before passing the relocateSpec to the RelocateVM API.
	RelocateSpec *VirtualMachineRelocateSpec `xml:"relocateSpec,omitempty" json:"relocateSpec,omitempty"`
	// A list of compatible hosts for the virtual machine.
	//
	// This list is ignored if relocateSpec.host is set.
	// For both intra-vCenter and cross-vCenter migrations, this list is required
	// if relocateSpec.host is unset.
	// If neither relocateSpec.host nor a list of compatible hosts are specified,
	// all hosts in the cluster will be considered, in which case, the selected
	// hosts in the PlacementResult are not guaranteed to be compatible with the
	// incoming virtual machine.
	//
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts,omitempty" json:"hosts,omitempty"`
	// A list of compatible datastores for the virtual machine.
	//
	// This list is ignored if relocateSpec.datastore is set.
	// For both intra-vCenter and cross-vCenter migrations, this list is required
	// if relocateSpec.datastore is unset.
	// If neither relocateSpec.datastore nor a list of compatible datastores are
	// specified, all datastores connected to hosts in the cluster will be
	// considered, in which case, the selected datastores in the PlacementResult
	// are not guaranteed to be compatible with the incoming virtual machine.
	//
	// Refers instances of `Datastore`.
	Datastores []ManagedObjectReference `xml:"datastores,omitempty" json:"datastores,omitempty"`
	// A list of compatible datastore clusters for the virtual machine.
	//
	// This list is ignored if relocateSpec.datastore is set.
	// For both intra-vCenter and cross-vCenter migrations, this list can be
	// empty, in which case, the user should set either RelocateSpec.datastore
	// or PlacementSpec.datastores as the target datastore or the list of
	// compatible datastores.
	//
	// Refers instances of `StoragePod`.
	StoragePods []ManagedObjectReference `xml:"storagePods,omitempty" json:"storagePods,omitempty"`
	// Specification for whether to disable pre-requisite vmotions or storage
	// vmotions for virtual machine placement.
	//
	// The default value is true,
	// that is, to disallow such prerequisite moves.
	DisallowPrerequisiteMoves *bool `xml:"disallowPrerequisiteMoves" json:"disallowPrerequisiteMoves,omitempty"`
	// A list of rules to respect while placing the virtual machine on
	// target cluster.
	//
	// If the list is empty, rules will not be considered during placement,
	// in case of cross-cluster placement within a VC and cross VC
	// placement across VCs.
	Rules []BaseClusterRuleInfo `xml:"rules,omitempty,typeattr" json:"rules,omitempty"`
	// Client generated identifier as a reference to the placement request
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// Type of the placement.
	//
	// The set of possible values are described in
	// `PlacementSpecPlacementType_enum`
	PlacementType string `xml:"placementType,omitempty" json:"placementType,omitempty"`
	// Specification for a virtual machine clone operation
	CloneSpec *VirtualMachineCloneSpec `xml:"cloneSpec,omitempty" json:"cloneSpec,omitempty"`
	// Name for the cloned virtual machine, if the operation type is a clone
	CloneName string `xml:"cloneName,omitempty" json:"cloneName,omitempty"`
}

func init() {
	t["PlacementSpec"] = reflect.TypeOf((*PlacementSpec)(nil)).Elem()
}

// A PlatformConfigFault is a catch-all fault indicating that some error has
// occurred regarding the configuration of the host.
//
// Data about the fault is
// available and will be presented as a platform specific string.
//
// This information carried by this fault cannot be localized. Most likely
// this information will already have been localized to the locale of the
// server that generated this fault. Where possible, a more specific fault
// will be thrown.
type PlatformConfigFault struct {
	HostConfigFault

	// Platform specific text string describing this error.
	Text string `xml:"text" json:"text"`
}

func init() {
	t["PlatformConfigFault"] = reflect.TypeOf((*PlatformConfigFault)(nil)).Elem()
}

type PlatformConfigFaultFault BasePlatformConfigFault

func init() {
	t["PlatformConfigFaultFault"] = reflect.TypeOf((*PlatformConfigFaultFault)(nil)).Elem()
}

// The `PnicUplinkProfile` data object specifies the mapping between
// a physical NIC and an uplink port.
//
// The `ApplyProfile.policy` property contains
// the configuration data values.
type PnicUplinkProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["PnicUplinkProfile"] = reflect.TypeOf((*PnicUplinkProfile)(nil)).Elem()
}

// The disk locator class.
type PodDiskLocator struct {
	DynamicData

	// The disk ID.
	DiskId int32 `xml:"diskId" json:"diskId"`
	// The disk move type.
	DiskMoveType string `xml:"diskMoveType,omitempty" json:"diskMoveType,omitempty"`
	// The disk backing info.
	DiskBackingInfo BaseVirtualDeviceBackingInfo `xml:"diskBackingInfo,omitempty,typeattr" json:"diskBackingInfo,omitempty"`
	// Virtual Disk Profile requirement.
	//
	// Profiles are solution specific.
	// Profile Based Storage Management is a vSphere server extension.
	// The API users who want to provision VMs using Storage Profiles, need to
	// interact with it.
	// This is an optional parameter and if user doesn't specify profile,
	// the default behavior will apply.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
}

func init() {
	t["PodDiskLocator"] = reflect.TypeOf((*PodDiskLocator)(nil)).Elem()
}

// An entry containing storage DRS configuration, runtime
// results, and history for a pod `StoragePod`.
type PodStorageDrsEntry struct {
	DynamicData

	// Storage DRS configuration.
	StorageDrsConfig StorageDrsConfigInfo `xml:"storageDrsConfig" json:"storageDrsConfig"`
	// List of recommended actions for the Storage Pod.
	//
	// It is
	// possible that the current set of recommendations may be empty,
	// either due to not having any running dynamic recommendation
	// generation module, or since there may be no recommended actions
	// at this time.
	Recommendation []ClusterRecommendation `xml:"recommendation,omitempty" json:"recommendation,omitempty"`
	// A collection of the DRS faults generated in the last Storage DRS invocation.
	//
	// Each element of the collection is the set of faults generated in one
	// recommendation.
	DrsFault []ClusterDrsFaults `xml:"drsFault,omitempty" json:"drsFault,omitempty"`
	// The set of actions that have been performed recently.
	ActionHistory []ClusterActionHistory `xml:"actionHistory,omitempty" json:"actionHistory,omitempty"`
}

func init() {
	t["PodStorageDrsEntry"] = reflect.TypeOf((*PodStorageDrsEntry)(nil)).Elem()
}

// The `PolicyOption` data object represents one or more configuration
// values.
//
// A policy option is one of the configuration options from the
// `ProfilePolicyMetadata*.*ProfilePolicyMetadata.possibleOption`
// list.
type PolicyOption struct {
	DynamicData

	// Identifier for the policy option.
	//
	// This value matches one of the
	// keys from the list of possible options in the policy metadata
	// (`ProfilePolicyMetadata*.*ProfilePolicyMetadata.possibleOption*\[\].*ProfilePolicyOptionMetadata.id*.*ElementDescription.key`).
	Id string `xml:"id" json:"id"`
	// Parameters for the policy option.
	//
	// This list must include all parameters that are not marked as optional
	// in the policy option metadata parameter list
	// (`ProfilePolicyMetadata*.*ProfilePolicyMetadata.possibleOption*\[\].*ProfilePolicyOptionMetadata.parameter*\[\].*ProfileParameterMetadata.optional`).
	Parameter []KeyAnyValue `xml:"parameter,omitempty" json:"parameter,omitempty"`
}

func init() {
	t["PolicyOption"] = reflect.TypeOf((*PolicyOption)(nil)).Elem()
}

// `PortGroupProfile` is the base class for the different port group
// subprofile objects.
type PortGroupProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
	// Name of the portgroup.
	Name string `xml:"name" json:"name"`
	// VLAN identifier for the port group.
	Vlan VlanProfile `xml:"vlan" json:"vlan"`
	// Virtual switch to which the port group is connected.
	Vswitch VirtualSwitchSelectionProfile `xml:"vswitch" json:"vswitch"`
	// The network policy/policies applicable on the port group.
	NetworkPolicy NetworkPolicyProfile `xml:"networkPolicy" json:"networkPolicy"`
}

func init() {
	t["PortGroupProfile"] = reflect.TypeOf((*PortGroupProfile)(nil)).Elem()
}

// Searching for users and groups on POSIX systems provides
// User ID and Group ID information, in addition to that
// defined in UserSearchResult.
type PosixUserSearchResult struct {
	UserSearchResult

	// If the search result is for a user, then id refers to User ID.
	//
	// For a group,
	// the value of Group ID is assigned to id.
	Id int32 `xml:"id" json:"id"`
	// If the search result is for a user, shellAccess indicates whether shell
	// access has been granted or not.
	ShellAccess *bool `xml:"shellAccess" json:"shellAccess,omitempty"`
}

func init() {
	t["PosixUserSearchResult"] = reflect.TypeOf((*PosixUserSearchResult)(nil)).Elem()
}

type PostEvent PostEventRequestType

func init() {
	t["PostEvent"] = reflect.TypeOf((*PostEvent)(nil)).Elem()
}

// The parameters of `EventManager.PostEvent`.
type PostEventRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Fully-specified event to post
	EventToPost BaseEvent `xml:"eventToPost,typeattr" json:"eventToPost"`
	// optional task associated with the event
	TaskInfo *TaskInfo `xml:"taskInfo,omitempty" json:"taskInfo,omitempty"`
}

func init() {
	t["PostEventRequestType"] = reflect.TypeOf((*PostEventRequestType)(nil)).Elem()
}

type PostEventResponse struct {
}

type PostHealthUpdates PostHealthUpdatesRequestType

func init() {
	t["PostHealthUpdates"] = reflect.TypeOf((*PostHealthUpdates)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.PostHealthUpdates`.
type PostHealthUpdatesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The provider id.
	ProviderId string `xml:"providerId" json:"providerId"`
	// The changes in health states.
	Updates []HealthUpdate `xml:"updates,omitempty" json:"updates,omitempty"`
}

func init() {
	t["PostHealthUpdatesRequestType"] = reflect.TypeOf((*PostHealthUpdatesRequestType)(nil)).Elem()
}

type PostHealthUpdatesResponse struct {
}

// The parameters of `HostSystem.PowerDownHostToStandBy_Task`.
type PowerDownHostToStandByRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The task completes when the host successfully
	// enters standby mode and stops sending heartbeat signals.
	// If heartbeats are still coming after timeoutSecs seconds,
	// the host is declared timedout, and the task is assumed
	// failed.
	TimeoutSec int32 `xml:"timeoutSec" json:"timeoutSec"`
	// This is a parameter used only by VirtualCenter. If
	// set to true, for a DRS disabled cluster, the task will not
	// succeed unless all powered-off virtual machines have been manually
	// reregistered; for a DRS enabled cluster, VirtualCenter will
	// automatically reregister powered-off virtual machines and a
	// powered-off virtual machine may remain at the host only for two
	// reasons: (a) no compatible host found for reregistration, (b) DRS
	// is disabled for the virtual machine.
	EvacuatePoweredOffVms *bool `xml:"evacuatePoweredOffVms" json:"evacuatePoweredOffVms,omitempty"`
}

func init() {
	t["PowerDownHostToStandByRequestType"] = reflect.TypeOf((*PowerDownHostToStandByRequestType)(nil)).Elem()
}

type PowerDownHostToStandBy_Task PowerDownHostToStandByRequestType

func init() {
	t["PowerDownHostToStandBy_Task"] = reflect.TypeOf((*PowerDownHostToStandBy_Task)(nil)).Elem()
}

type PowerDownHostToStandBy_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualApp.PowerOffVApp_Task`.
type PowerOffVAppRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If force is false, the shutdown order in the vApp is
	// executed. If force is true, all virtual machines are powered-off
	// (regardless of shutdown order).
	Force bool `xml:"force" json:"force"`
}

func init() {
	t["PowerOffVAppRequestType"] = reflect.TypeOf((*PowerOffVAppRequestType)(nil)).Elem()
}

type PowerOffVApp_Task PowerOffVAppRequestType

func init() {
	t["PowerOffVApp_Task"] = reflect.TypeOf((*PowerOffVApp_Task)(nil)).Elem()
}

type PowerOffVApp_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type PowerOffVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["PowerOffVMRequestType"] = reflect.TypeOf((*PowerOffVMRequestType)(nil)).Elem()
}

type PowerOffVM_Task PowerOffVMRequestType

func init() {
	t["PowerOffVM_Task"] = reflect.TypeOf((*PowerOffVM_Task)(nil)).Elem()
}

type PowerOffVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The PowerOnFtSecondaryFailed fault is thrown when the system is unable to
// power on a Fault Tolerance secondary virtual machine.
//
// It includes a list
// of failures on different hosts.
type PowerOnFtSecondaryFailed struct {
	VmFaultToleranceIssue

	// The primary virtual machine corresponding to the secondary that is to
	// be powered on
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The name of the primary virtual machine corresponding to the secondary
	// that is to be powered on.
	VmName string `xml:"vmName" json:"vmName"`
	// The host selection type
	HostSelectionBy FtIssuesOnHostHostSelectionType `xml:"hostSelectionBy" json:"hostSelectionBy"`
	// Information on why the system can not power on a Fault Tolerance
	// secondary virtual machine on specific hosts.
	//
	// Everything in the array
	// should be FtIssuesOnHost.
	HostErrors []LocalizedMethodFault `xml:"hostErrors,omitempty" json:"hostErrors,omitempty"`
	// The reason why powering on secondary failed.
	RootCause LocalizedMethodFault `xml:"rootCause" json:"rootCause"`
}

func init() {
	t["PowerOnFtSecondaryFailed"] = reflect.TypeOf((*PowerOnFtSecondaryFailed)(nil)).Elem()
}

type PowerOnFtSecondaryFailedFault PowerOnFtSecondaryFailed

func init() {
	t["PowerOnFtSecondaryFailedFault"] = reflect.TypeOf((*PowerOnFtSecondaryFailedFault)(nil)).Elem()
}

// PowerOnFtSecondaryTimedout exception is thrown when Virtual Center
// fails the operation to power on a Fault Tolerance secondary virtual
// machine because it is taking longer than expected.
type PowerOnFtSecondaryTimedout struct {
	Timedout

	// The primary virtual machine corresponding to the secondary that is to
	// be powered on
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The name of the primary virtual machine corresponding to the secondary
	// that is to be powered on.
	VmName string `xml:"vmName" json:"vmName"`
	// The time out value in seconds
	Timeout int32 `xml:"timeout" json:"timeout"`
}

func init() {
	t["PowerOnFtSecondaryTimedout"] = reflect.TypeOf((*PowerOnFtSecondaryTimedout)(nil)).Elem()
}

type PowerOnFtSecondaryTimedoutFault PowerOnFtSecondaryTimedout

func init() {
	t["PowerOnFtSecondaryTimedoutFault"] = reflect.TypeOf((*PowerOnFtSecondaryTimedoutFault)(nil)).Elem()
}

// The parameters of `Datacenter.PowerOnMultiVM_Task`.
type PowerOnMultiVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The virtual machines to power on.
	//
	// Required privileges: VirtualMachine.Interact.PowerOn
	//
	// Refers instances of `VirtualMachine`.
	Vm []ManagedObjectReference `xml:"vm" json:"vm"`
	// An array of `OptionValue` options
	// for this power-on session. The names and values of the
	// options are defined in
	// `ClusterPowerOnVmOption_enum`.
	Option []BaseOptionValue `xml:"option,omitempty,typeattr" json:"option,omitempty"`
}

func init() {
	t["PowerOnMultiVMRequestType"] = reflect.TypeOf((*PowerOnMultiVMRequestType)(nil)).Elem()
}

type PowerOnMultiVM_Task PowerOnMultiVMRequestType

func init() {
	t["PowerOnMultiVM_Task"] = reflect.TypeOf((*PowerOnMultiVM_Task)(nil)).Elem()
}

type PowerOnMultiVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type PowerOnVAppRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["PowerOnVAppRequestType"] = reflect.TypeOf((*PowerOnVAppRequestType)(nil)).Elem()
}

type PowerOnVApp_Task PowerOnVAppRequestType

func init() {
	t["PowerOnVApp_Task"] = reflect.TypeOf((*PowerOnVApp_Task)(nil)).Elem()
}

type PowerOnVApp_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.PowerOnVM_Task`.
type PowerOnVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// (optional) The host where the virtual machine is to be powered on.
	// If no host is specified, the current associated host is used. This field must
	// specify a host that is part of the same compute resource that the virtual machine
	// is currently associated with. If this host is not compatible, the current host
	// association is used.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["PowerOnVMRequestType"] = reflect.TypeOf((*PowerOnVMRequestType)(nil)).Elem()
}

type PowerOnVM_Task PowerOnVMRequestType

func init() {
	t["PowerOnVM_Task"] = reflect.TypeOf((*PowerOnVM_Task)(nil)).Elem()
}

type PowerOnVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Power System Capability data object.
//
// Exposes policies available in power management system.
type PowerSystemCapability struct {
	DynamicData

	// List of available host power policies.
	AvailablePolicy []HostPowerPolicy `xml:"availablePolicy" json:"availablePolicy"`
}

func init() {
	t["PowerSystemCapability"] = reflect.TypeOf((*PowerSystemCapability)(nil)).Elem()
}

// Power System Info data object.
//
// Shows current state of power management system.
type PowerSystemInfo struct {
	DynamicData

	// Currently selected host power management policy.
	//
	// This property can have one of the values from
	// `PowerSystemCapability.availablePolicy`.
	CurrentPolicy HostPowerPolicy `xml:"currentPolicy" json:"currentPolicy"`
}

func init() {
	t["PowerSystemInfo"] = reflect.TypeOf((*PowerSystemInfo)(nil)).Elem()
}

// The parameters of `HostSystem.PowerUpHostFromStandBy_Task`.
type PowerUpHostFromStandByRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The task completes when the host successfully
	// exits standby state and sends a heartbeat signal. If nothing is
	// received from the host for timeoutSec seconds, the host is
	// declared timedout, and the task is assumed failed.
	TimeoutSec int32 `xml:"timeoutSec" json:"timeoutSec"`
}

func init() {
	t["PowerUpHostFromStandByRequestType"] = reflect.TypeOf((*PowerUpHostFromStandByRequestType)(nil)).Elem()
}

type PowerUpHostFromStandBy_Task PowerUpHostFromStandByRequestType

func init() {
	t["PowerUpHostFromStandBy_Task"] = reflect.TypeOf((*PowerUpHostFromStandBy_Task)(nil)).Elem()
}

type PowerUpHostFromStandBy_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type PrepareCrypto PrepareCryptoRequestType

func init() {
	t["PrepareCrypto"] = reflect.TypeOf((*PrepareCrypto)(nil)).Elem()
}

type PrepareCryptoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["PrepareCryptoRequestType"] = reflect.TypeOf((*PrepareCryptoRequestType)(nil)).Elem()
}

type PrepareCryptoResponse struct {
}

// This class defines whether a specific privilege is granted.
type PrivilegeAvailability struct {
	DynamicData

	// The privilege ID.
	PrivId string `xml:"privId" json:"privId"`
	// True if the privilege is granted.
	IsGranted bool `xml:"isGranted" json:"isGranted"`
}

func init() {
	t["PrivilegeAvailability"] = reflect.TypeOf((*PrivilegeAvailability)(nil)).Elem()
}

// Describes a basic privilege policy.
type PrivilegePolicyDef struct {
	DynamicData

	// Name of privilege required for creation.
	CreatePrivilege string `xml:"createPrivilege" json:"createPrivilege"`
	// Name of privilege required for reading.
	ReadPrivilege string `xml:"readPrivilege" json:"readPrivilege"`
	// Name of privilege required for updating.
	UpdatePrivilege string `xml:"updatePrivilege" json:"updatePrivilege"`
	// Name of privilege required for deleting.
	DeletePrivilege string `xml:"deletePrivilege" json:"deletePrivilege"`
}

func init() {
	t["PrivilegePolicyDef"] = reflect.TypeOf((*PrivilegePolicyDef)(nil)).Elem()
}

// ProductComponentInfo data object type describes installed components.
//
// Product component is defined as a software module that is released
// and versioned independently but has dependency relationship with other products.
// If one product, for usability or any other reason, bundles other products,
// ProductComponentInfo type may be used to describe installed components.
// For example, ESX product may bundle VI Client in its releases.
type ProductComponentInfo struct {
	DynamicData

	// Opaque identifier that is unique for this product component
	Id string `xml:"id" json:"id"`
	// Canonical name of product component
	Name string `xml:"name" json:"name"`
	// Version of product component
	Version string `xml:"version" json:"version"`
	// Release property is a number which increments with each
	// new release of product.
	//
	// Product release may not rev version
	// but release number is always incremented.
	Release int32 `xml:"release" json:"release"`
}

func init() {
	t["ProductComponentInfo"] = reflect.TypeOf((*ProductComponentInfo)(nil)).Elem()
}

// DataObject which represents an ApplyProfile element.
//
// An ApplyProfile element is an ApplyProfile for a set of host
// configuration settings which may be instanced.
// For example, there may be multiple virtual switch instances
// represented by individual ApplyProfileElement DataObjects.
type ProfileApplyProfileElement struct {
	ApplyProfile

	// The linkable identifier.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["ProfileApplyProfileElement"] = reflect.TypeOf((*ProfileApplyProfileElement)(nil)).Elem()
}

// The `ProfileApplyProfileProperty` data object defines one or more subprofiles.
type ProfileApplyProfileProperty struct {
	DynamicData

	// Name of the property.
	PropertyName string `xml:"propertyName" json:"propertyName"`
	// Flag indicating whether this property is an array of profiles.
	Array bool `xml:"array" json:"array"`
	// Subprofiles that define policies and nested subprofiles.
	Profile []BaseApplyProfile `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
}

func init() {
	t["ProfileApplyProfileProperty"] = reflect.TypeOf((*ProfileApplyProfileProperty)(nil)).Elem()
}

// This event records that a Profile was associated with a managed entitiy.
type ProfileAssociatedEvent struct {
	ProfileEvent
}

func init() {
	t["ProfileAssociatedEvent"] = reflect.TypeOf((*ProfileAssociatedEvent)(nil)).Elem()
}

// This event records that the profile has beed edited
type ProfileChangedEvent struct {
	ProfileEvent
}

func init() {
	t["ProfileChangedEvent"] = reflect.TypeOf((*ProfileChangedEvent)(nil)).Elem()
}

// DataObject to Compose expressions.
//
// It is used to group expressions
// together. They are similar to a parentheses in an expression.
type ProfileCompositeExpression struct {
	ProfileExpression

	// Logical operator to be applied between the expressions in
	// the composite expression.
	//
	// e.g: or, and
	Operator string `xml:"operator" json:"operator"`
	// List of expression names that will be used for this composition.
	//
	// The individual expressions will return a boolean. The return values
	// of the individual expressions will be used to compute the final
	// return value of the CompositeExpression.
	// The expressions specified in the list can themselves be
	// CompositeExpressions.
	ExpressionName []string `xml:"expressionName" json:"expressionName"`
}

func init() {
	t["ProfileCompositeExpression"] = reflect.TypeOf((*ProfileCompositeExpression)(nil)).Elem()
}

// The `ProfileCompositePolicyOptionMetadata` data object represents the metadata information
// for a composite `PolicyOption`.
//
// The user will retrieve metadata
// information about a composite policy and then combine policy options to produce
// the composite policy option.
type ProfileCompositePolicyOptionMetadata struct {
	ProfilePolicyOptionMetadata

	// List of optional policy option identifiers that could be combined
	// in this composite policy option.
	//
	// The policy options should already be
	// part of the possible policy options for the policy. See the
	// `ProfilePolicyMetadata*.*ProfilePolicyMetadata.possibleOption`
	// list.
	Option []string `xml:"option" json:"option"`
}

func init() {
	t["ProfileCompositePolicyOptionMetadata"] = reflect.TypeOf((*ProfileCompositePolicyOptionMetadata)(nil)).Elem()
}

type ProfileConfigInfo struct {
	DynamicData

	// Name of the profile
	Name string `xml:"name" json:"name"`
	// User Provided description of the profile
	Annotation string `xml:"annotation,omitempty" json:"annotation,omitempty"`
	// Flag indicating if the Profile is enabled
	Enabled bool `xml:"enabled" json:"enabled"`
}

func init() {
	t["ProfileConfigInfo"] = reflect.TypeOf((*ProfileConfigInfo)(nil)).Elem()
}

// Specification describing the parameters during Profile creation
type ProfileCreateSpec struct {
	DynamicData

	// Name of the profile
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// User Provided description of the profile
	Annotation string `xml:"annotation,omitempty" json:"annotation,omitempty"`
	// Flag indicating if the Profile is enabled
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
}

func init() {
	t["ProfileCreateSpec"] = reflect.TypeOf((*ProfileCreateSpec)(nil)).Elem()
}

// This event records that a Profile was created.
type ProfileCreatedEvent struct {
	ProfileEvent
}

func init() {
	t["ProfileCreatedEvent"] = reflect.TypeOf((*ProfileCreatedEvent)(nil)).Elem()
}

// The `ProfileDeferredPolicyOptionParameter` data object contains
// information about a single deferred parameter for host configuration.
//   - The Server verifies deferred parameter data when it calls the
//     `HostProfile*.*HostProfile.ExecuteHostProfile`
//     method.
//   - The client supplies deferred parameter data for host configuration when it calls the
//     `HostProfileManager*.*HostProfileManager.ApplyHostConfig_Task`
//     method.
//   - The vCenter Server stores deferred parameter data in answer files
//     (`AnswerFile*.*AnswerFile.userInput`).
type ProfileDeferredPolicyOptionParameter struct {
	DynamicData

	// Complete path to the `PolicyOption` that defines the parameters.
	InputPath ProfilePropertyPath `xml:"inputPath" json:"inputPath"`
	// List that contains values for the policy parameters.
	//
	// During parameter verification, this property is unspecified
	// if the client has not provided the values for this parameter.
	// See `ProfileExecuteResult*.*ProfileExecuteResult.requireInput`.
	Parameter []KeyAnyValue `xml:"parameter,omitempty" json:"parameter,omitempty"`
}

func init() {
	t["ProfileDeferredPolicyOptionParameter"] = reflect.TypeOf((*ProfileDeferredPolicyOptionParameter)(nil)).Elem()
}

// The `ProfileDescription` data object describes a profile.
//
// The description contains multiple sections. Each section
// describes a part of the profile.
type ProfileDescription struct {
	DynamicData

	// Sections which make up the profile description.
	Section []ProfileDescriptionSection `xml:"section" json:"section"`
}

func init() {
	t["ProfileDescription"] = reflect.TypeOf((*ProfileDescription)(nil)).Elem()
}

// The `ProfileDescriptionSection` data object
// contains a profile element description and any messages that may
// be associated with the profile section.
type ProfileDescriptionSection struct {
	DynamicData

	// Localized message data.
	Description ExtendedElementDescription `xml:"description" json:"description"`
	// List of messages that make up the section.
	Message []LocalizableMessage `xml:"message,omitempty" json:"message,omitempty"`
}

func init() {
	t["ProfileDescriptionSection"] = reflect.TypeOf((*ProfileDescriptionSection)(nil)).Elem()
}

// This event records that a Profile was dissociated from a managed entity
type ProfileDissociatedEvent struct {
	ProfileEvent
}

func init() {
	t["ProfileDissociatedEvent"] = reflect.TypeOf((*ProfileDissociatedEvent)(nil)).Elem()
}

// This event records a Profile specific event.
type ProfileEvent struct {
	Event

	// Link to the profile to which this event applies
	Profile ProfileEventArgument `xml:"profile" json:"profile"`
}

func init() {
	t["ProfileEvent"] = reflect.TypeOf((*ProfileEvent)(nil)).Elem()
}

// The event argument is a Profile object
type ProfileEventArgument struct {
	EventArgument

	// Refers instance of `Profile`.
	Profile ManagedObjectReference `xml:"profile" json:"profile"`
	Name    string                 `xml:"name" json:"name"`
}

func init() {
	t["ProfileEventArgument"] = reflect.TypeOf((*ProfileEventArgument)(nil)).Elem()
}

// The `ProfileExecuteError` data object
// describes an error encountered during host profile execution.
type ProfileExecuteError struct {
	DynamicData

	// Path to the profile or policy with which the error is associated.
	Path *ProfilePropertyPath `xml:"path,omitempty" json:"path,omitempty"`
	// Message describing the error.
	Message LocalizableMessage `xml:"message" json:"message"`
}

func init() {
	t["ProfileExecuteError"] = reflect.TypeOf((*ProfileExecuteError)(nil)).Elem()
}

// The `ProfileExecuteResult` data object contains the results from a
// `HostProfile*.*HostProfile.ExecuteHostProfile`
// operation.
type ProfileExecuteResult struct {
	DynamicData

	// Status of the profile execution operation.
	//
	// The value is a string that contains
	// one of the `ProfileExecuteResultStatus_enum` enumerations.
	Status string `xml:"status" json:"status"`
	// Host configuration specification.
	//
	// This data is valid only if
	// the <code>status</code> value is <code>success</code>.
	// See `ProfileExecuteResultStatus_enum`.
	//
	// Use this data object when you apply the configuration
	// to a host. See the <code>configSpec</code> parameter to the
	// `HostProfileManager*.*HostProfileManager.ApplyHostConfig_Task`
	// method.
	ConfigSpec *HostConfigSpec `xml:"configSpec,omitempty" json:"configSpec,omitempty"`
	// List of property paths.
	//
	// Each path identifies a policy that does not apply
	// to this host. For example, if the precheck policies for a port group are not satisfied,
	// the port group will not be created when you apply the profile to the host.
	// Based on this information, the client might not display that part of the profile tree.
	InapplicablePath []string `xml:"inapplicablePath,omitempty" json:"inapplicablePath,omitempty"`
	// List that describes the required input for host configuration and identifies
	// any policy options that still require parameter data.
	//
	// Each entry in the list
	// specifies the path to a policy and a parameter list. If the call to
	// `HostProfile.ExecuteHostProfile` includes deferred parameters,
	// the <code>requireInput</code> entries
	// (<code>requireInput\[\].</code>`ProfileDeferredPolicyOptionParameter.parameter`\[\])
	// will be populated with the parameter data that was passed to the execute method.
	// For policies that still require input data, the parameter list in the corresponding
	// entry will be null.
	//
	// A vSphere client that displays a GUI can use this information to show the host-specific
	// configuration policy options. The client can highlight required input fields
	// and ask the user for data in increments instead of collecting all of the input at once.
	// For example, in the first pass, the client collects a minimum of user input and
	// sends that to the Server. The Server evaluates the profile and might decide to
	// invalidate a particular part of the subtree or enable a new
	// subtree in the profile. This would result in a new set of invalid paths
	// (`ProfileExecuteResult.inapplicablePath`\[\]) and
	// required input property paths
	// (`ProfileDeferredPolicyOptionParameter*.*ProfileDeferredPolicyOptionParameter.inputPath`).
	// The client can make a series of calls to the method until it achieves a success status.
	//
	// When `HostProfile.ExecuteHostProfile` returns a success status,
	// the <code>requireInput</code> list contains the complete list of parameters,
	// consisting of the following data:
	//   - Deferred parameter values resolved through successive calls to
	//     `HostProfile.ExecuteHostProfile`.
	//   - Default parameter values from the host configuration.
	//   - User-specified values that override the defaults.
	//
	// You can specify the returned <code>requireInput</code> list in the
	// <code>userInput</code> parameter to the
	// `HostProfileManager*.*HostProfileManager.ApplyHostConfig_Task`
	// method. The Server will use the list to update the `AnswerFile`
	// associated with the host.
	RequireInput []ProfileDeferredPolicyOptionParameter `xml:"requireInput,omitempty" json:"requireInput,omitempty"`
	// List of errors that were encountered during execute.
	//
	// This field will be set if status is set to error.
	Error []ProfileExecuteError `xml:"error,omitempty" json:"error,omitempty"`
}

func init() {
	t["ProfileExecuteResult"] = reflect.TypeOf((*ProfileExecuteResult)(nil)).Elem()
}

type ProfileExpression struct {
	DynamicData

	// Identifier of this expression.
	//
	// The id has to be unique within a Profile.
	// The id can be used as a key while building composite expressions.
	Id string `xml:"id" json:"id"`
	// User visible display name
	DisplayName string `xml:"displayName" json:"displayName"`
	// Flag indicating if the condition of the expression should be negated.
	//
	// e.g: conditions like VSwitch0 has vmnic0 connected to it can be turned into
	// VSwitch0 doesn't have vmnic0 connected to it.
	Negated bool `xml:"negated" json:"negated"`
}

func init() {
	t["ProfileExpression"] = reflect.TypeOf((*ProfileExpression)(nil)).Elem()
}

// DataObject to represent the metadata associated with a SimpleExpression.
type ProfileExpressionMetadata struct {
	DynamicData

	// Id of the SimpleExpression
	ExpressionId ExtendedElementDescription `xml:"expressionId" json:"expressionId"`
	// Parameters that can be specified for this SimpleExpression
	Parameter []ProfileParameterMetadata `xml:"parameter,omitempty" json:"parameter,omitempty"`
}

func init() {
	t["ProfileExpressionMetadata"] = reflect.TypeOf((*ProfileExpressionMetadata)(nil)).Elem()
}

// This data object represents the metadata information of a Profile.
type ProfileMetadata struct {
	DynamicData

	// Type of the Profile
	Key string `xml:"key" json:"key"`
	// Type identifier for the ApplyProfile
	ProfileTypeName string `xml:"profileTypeName,omitempty" json:"profileTypeName,omitempty"`
	// Property which describes the profile
	Description *ExtendedDescription `xml:"description,omitempty" json:"description,omitempty"`
	// Property that determines a sorting order for display purposes.
	//
	// If
	// the list contains more than one sort spec, then the precedence should
	// be determined by the list order (i.e. sort first by the first spec in
	// the list, then sort by the second spec in the list, etc).
	SortSpec []ProfileMetadataProfileSortSpec `xml:"sortSpec,omitempty" json:"sortSpec,omitempty"`
	// Identifies the profile category that this subprofile is a part of.
	//
	// The
	// value of this string should correspond to the key value of a
	// `ProfileCategoryMetadata` object's `ElementDescription.key`
	// in its `ProfileCategoryMetadata.id` property.
	ProfileCategory string `xml:"profileCategory,omitempty" json:"profileCategory,omitempty"`
	// Property indicating that the subprofile described by this
	// <code>ProfileMetadata</code> object is declared in the
	// `ProfileComponentMetadata.profileTypeNames` of the specified
	// profile component.
	//
	// The value of this property should correspond to the key
	// value of the `ProfileComponentMetadata` object's
	// `ElementDescription.key` in its
	// `ProfileComponentMetadata.id` property.
	// This property should not be present for subprofiles that are not directly
	// declared in the `ProfileComponentMetadata.profileTypeNames`
	// property of a `ProfileComponentMetadata` object.
	ProfileComponent string `xml:"profileComponent,omitempty" json:"profileComponent,omitempty"`
	// A list of <code>ProfileOperationMessage</code> for this profile.
	OperationMessages []ProfileMetadataProfileOperationMessage `xml:"operationMessages,omitempty" json:"operationMessages,omitempty"`
}

func init() {
	t["ProfileMetadata"] = reflect.TypeOf((*ProfileMetadata)(nil)).Elem()
}

// Some operations on host profile documents may cause unexpected result.
//
// For example, deleting a profile instance of vswitch may break the
// network connectivity.
// This data class provides the localizable message which may be
// presented before or after an operation happens.
type ProfileMetadataProfileOperationMessage struct {
	DynamicData

	// The operation name.
	OperationName string `xml:"operationName" json:"operationName"`
	// The localization message for the operation.
	Message LocalizableMessage `xml:"message" json:"message"`
}

func init() {
	t["ProfileMetadataProfileOperationMessage"] = reflect.TypeOf((*ProfileMetadataProfileOperationMessage)(nil)).Elem()
}

type ProfileMetadataProfileSortSpec struct {
	DynamicData

	// The id of the policy used to sort instances of the profile
	PolicyId string `xml:"policyId" json:"policyId"`
	// The parameter to be used for sorting.
	//
	// Note that if the policy to be
	// used for sorting has multiple possible policy options, all possible
	// policy options defined for that policy type must have this parameter.
	Parameter string `xml:"parameter" json:"parameter"`
}

func init() {
	t["ProfileMetadataProfileSortSpec"] = reflect.TypeOf((*ProfileMetadataProfileSortSpec)(nil)).Elem()
}

// The `ProfileParameterMetadata` data object represents the metadata information
// for expressions, policy options, and host-specific configuration data.
type ProfileParameterMetadata struct {
	DynamicData

	// Identifier for the parameter.
	Id ExtendedElementDescription `xml:"id" json:"id"`
	// Type of the parameter.
	Type string `xml:"type" json:"type"`
	// Whether the parameter is optional.
	Optional bool `xml:"optional" json:"optional"`
	// Default value that can be used for the parameter.
	DefaultValue AnyType `xml:"defaultValue,omitempty,typeattr" json:"defaultValue,omitempty"`
	// Whether the parameter will not be displayed in UI.
	Hidden *bool `xml:"hidden" json:"hidden,omitempty"`
	// Whether the parameter is security sensitive.
	SecuritySensitive *bool `xml:"securitySensitive" json:"securitySensitive,omitempty"`
	// Indicates that the parameter value is read-only.
	ReadOnly *bool `xml:"readOnly" json:"readOnly,omitempty"`
	// Relations with other profile or parameters.
	ParameterRelations []ProfileParameterMetadataParameterRelationMetadata `xml:"parameterRelations,omitempty" json:"parameterRelations,omitempty"`
}

func init() {
	t["ProfileParameterMetadata"] = reflect.TypeOf((*ProfileParameterMetadata)(nil)).Elem()
}

// This class to define a relation between the parameter and a profile
// or a parameter, or a constant list of values.
type ProfileParameterMetadataParameterRelationMetadata struct {
	DynamicData

	// The types of this relation.
	RelationTypes []string `xml:"relationTypes,omitempty" json:"relationTypes,omitempty"`
	// The valid value list.
	Values []AnyType `xml:"values,omitempty,typeattr" json:"values,omitempty"`
	// The property path of the related profile/parameter.
	Path *ProfilePropertyPath `xml:"path,omitempty" json:"path,omitempty"`
	// The minimal count of values to map to.
	MinCount int32 `xml:"minCount" json:"minCount"`
	// The maximum count of values to map to.
	MaxCount int32 `xml:"maxCount" json:"maxCount"`
}

func init() {
	t["ProfileParameterMetadataParameterRelationMetadata"] = reflect.TypeOf((*ProfileParameterMetadataParameterRelationMetadata)(nil)).Elem()
}

// The `ProfilePolicy` data object represents a policy.
type ProfilePolicy struct {
	DynamicData

	// Identifier for the policy.
	Id string `xml:"id" json:"id"`
	// Configuration parameters.
	PolicyOption BasePolicyOption `xml:"policyOption,typeattr" json:"policyOption"`
}

func init() {
	t["ProfilePolicy"] = reflect.TypeOf((*ProfilePolicy)(nil)).Elem()
}

// The `ProfilePolicyMetadata` data object represents the metadata information
// for a `ProfilePolicy`.
type ProfilePolicyMetadata struct {
	DynamicData

	// Identifier for the policy.
	Id ExtendedElementDescription `xml:"id" json:"id"`
	// Possible policy options that can be set for a policy of the
	// given kind.
	//
	// `HostProfile`s and subprofiles
	// will contain selected policy options from this list. See
	// `PolicyOption`.
	PossibleOption []BaseProfilePolicyOptionMetadata `xml:"possibleOption,typeattr" json:"possibleOption"`
}

func init() {
	t["ProfilePolicyMetadata"] = reflect.TypeOf((*ProfilePolicyMetadata)(nil)).Elem()
}

// The `ProfilePolicyOptionMetadata` data object contains the metadata information
// for a `PolicyOption`.
type ProfilePolicyOptionMetadata struct {
	DynamicData

	// Identifier for the policy option.
	//   - The <code>id.key</code> value
	//     (`ExtendedElementDescription*.*ElementDescription.key`)
	//     identifies the policy option type.
	//   - The <code>id.label</code> property
	//     (`ExtendedElementDescription*.*Description.label`)
	//     contains a brief localizable message describing the policy option.
	//   - The <code>id.summary</code> property
	//     (`ExtendedElementDescription*.*Description.summary`)
	//     contains a localizable summary of the policy option.
	//     Summary information can contain embedded variable names which can
	//     be replaced with values from the <code>parameter</code> property.
	Id ExtendedElementDescription `xml:"id" json:"id"`
	// Metadata about the parameters for the policy option.
	Parameter []ProfileParameterMetadata `xml:"parameter,omitempty" json:"parameter,omitempty"`
}

func init() {
	t["ProfilePolicyOptionMetadata"] = reflect.TypeOf((*ProfilePolicyOptionMetadata)(nil)).Elem()
}

type ProfileProfileStructure struct {
	DynamicData

	// Identifier for the profile type
	ProfileTypeName string `xml:"profileTypeName" json:"profileTypeName"`
	// SubProfile properties available for this profile
	Child []ProfileProfileStructureProperty `xml:"child,omitempty" json:"child,omitempty"`
}

func init() {
	t["ProfileProfileStructure"] = reflect.TypeOf((*ProfileProfileStructure)(nil)).Elem()
}

type ProfileProfileStructureProperty struct {
	DynamicData

	// Name of the property where this ProfileStructureProperty is being used
	PropertyName string `xml:"propertyName" json:"propertyName"`
	// Flag indicating if this property is an Array of profiles
	Array bool `xml:"array" json:"array"`
	// Details about the profile contained within this property
	Element ProfileProfileStructure `xml:"element" json:"element"`
}

func init() {
	t["ProfileProfileStructureProperty"] = reflect.TypeOf((*ProfileProfileStructureProperty)(nil)).Elem()
}

// The `ProfilePropertyPath` data object represents
// the path to a profile, policy option, or specific parameter.
//
// If <code>profilePath</code>,
// <code>policyId</code>, and <code>parameterId</code> are all specified, the
// combination of the three identifies a particular parameter. If only <code>profilePath</code>
// and <code>policyId</code> are specified, the combination identifies a
// specific profile policy option. If just the <code>profilePath</code> is
// specified, the data object identifies a profile instance.
type ProfilePropertyPath struct {
	DynamicData

	// Complete path to the leaf profile, relative to the root of the host profile
	// document.
	ProfilePath string `xml:"profilePath" json:"profilePath"`
	// Policy identifier.
	PolicyId string `xml:"policyId,omitempty" json:"policyId,omitempty"`
	// Key for a parameter in the policy specified by <code>policyId</code>.
	//
	// See `PolicyOption*.*PolicyOption.parameter`
	// and `KeyAnyValue.key`.
	ParameterId string `xml:"parameterId,omitempty" json:"parameterId,omitempty"`
	// Policy option identifier.
	PolicyOptionId string `xml:"policyOptionId,omitempty" json:"policyOptionId,omitempty"`
}

func init() {
	t["ProfilePropertyPath"] = reflect.TypeOf((*ProfilePropertyPath)(nil)).Elem()
}

// This event records that the reference host associated with this profile has changed
type ProfileReferenceHostChangedEvent struct {
	ProfileEvent

	// The newly associated reference host with this profile
	//
	// Refers instance of `HostSystem`.
	ReferenceHost *ManagedObjectReference `xml:"referenceHost,omitempty" json:"referenceHost,omitempty"`
	// The newly associated reference host name
	ReferenceHostName string `xml:"referenceHostName,omitempty" json:"referenceHostName,omitempty"`
	// The previous reference host name
	PrevReferenceHostName string `xml:"prevReferenceHostName,omitempty" json:"prevReferenceHostName,omitempty"`
}

func init() {
	t["ProfileReferenceHostChangedEvent"] = reflect.TypeOf((*ProfileReferenceHostChangedEvent)(nil)).Elem()
}

// This event records that a Profile was removed.
type ProfileRemovedEvent struct {
	ProfileEvent
}

func init() {
	t["ProfileRemovedEvent"] = reflect.TypeOf((*ProfileRemovedEvent)(nil)).Elem()
}

// The `ProfileSerializedCreateSpec` data object
// defines a string that contains a serialized representation of a host profile.
type ProfileSerializedCreateSpec struct {
	ProfileCreateSpec

	// Representation of the profile in the string form.
	ProfileConfigString string `xml:"profileConfigString" json:"profileConfigString"`
}

func init() {
	t["ProfileSerializedCreateSpec"] = reflect.TypeOf((*ProfileSerializedCreateSpec)(nil)).Elem()
}

// DataObject represents a pre-defined expression
type ProfileSimpleExpression struct {
	ProfileExpression

	// Type of the simple expression to instantiate.
	//
	// The expressionType should be derived from the available expressions as
	// listed in the metadata.
	ExpressionType string `xml:"expressionType" json:"expressionType"`
	// The parameters for the expressionType.
	//
	// The list of parameters needed for a simple expression can
	// be obtained from the metadata.
	Parameter []KeyAnyValue `xml:"parameter,omitempty" json:"parameter,omitempty"`
}

func init() {
	t["ProfileSimpleExpression"] = reflect.TypeOf((*ProfileSimpleExpression)(nil)).Elem()
}

// Errors were detected during Profile update.
type ProfileUpdateFailed struct {
	VimFault

	// Failures encountered during update/validation
	Failure []ProfileUpdateFailedUpdateFailure `xml:"failure" json:"failure"`
	// Warnings encountered during update/validation
	Warnings []ProfileUpdateFailedUpdateFailure `xml:"warnings,omitempty" json:"warnings,omitempty"`
}

func init() {
	t["ProfileUpdateFailed"] = reflect.TypeOf((*ProfileUpdateFailed)(nil)).Elem()
}

type ProfileUpdateFailedFault ProfileUpdateFailed

func init() {
	t["ProfileUpdateFailedFault"] = reflect.TypeOf((*ProfileUpdateFailedFault)(nil)).Elem()
}

type ProfileUpdateFailedUpdateFailure struct {
	DynamicData

	// Location in the profile which has the error
	ProfilePath ProfilePropertyPath `xml:"profilePath" json:"profilePath"`
	// Message which explains the problem encountered
	ErrMsg LocalizableMessage `xml:"errMsg" json:"errMsg"`
}

func init() {
	t["ProfileUpdateFailedUpdateFailure"] = reflect.TypeOf((*ProfileUpdateFailedUpdateFailure)(nil)).Elem()
}

// The parameters of `VirtualMachine.PromoteDisks_Task`.
type PromoteDisksRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If true, then these disks will be unlinked before consolidation.
	Unlink bool `xml:"unlink" json:"unlink"`
	// The set of disks that are to be promoted.
	// If this value is unset or the array is empty,
	// all disks which have delta disk backings are promoted.
	Disks []VirtualDisk `xml:"disks,omitempty" json:"disks,omitempty"`
}

func init() {
	t["PromoteDisksRequestType"] = reflect.TypeOf((*PromoteDisksRequestType)(nil)).Elem()
}

type PromoteDisks_Task PromoteDisksRequestType

func init() {
	t["PromoteDisks_Task"] = reflect.TypeOf((*PromoteDisks_Task)(nil)).Elem()
}

type PromoteDisks_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Describes a change to a property.
type PropertyChange struct {
	DynamicData

	// Property or nested property to which the change applies.
	//
	// Nested
	// properties are specified by paths; for example,
	//   - foo.bar
	//   - foo.arProp\["key val"\]
	//   - foo.arProp\["key val"\].baz
	Name string `xml:"name" json:"name"`
	// Change operation for the property.
	//
	// Valid values are:
	// <dl>
	// <dt>add</dt>
	// <dd>The property is a collection and the change inserts an element
	// into the collection.</dd>
	// <dt>remove</dt>
	// <dd>The property is a collection and the change deletes an element
	// from the collection.</dd>
	// <dt>assign</dt>
	// <dd>The change is a new value for the property.</dd>
	// <dt>indirectRemove</dt>
	// <dd>The property was removed because a containing property was removed
	// or unset</dd>
	// </dl>
	Op PropertyChangeOp `xml:"op" json:"op"`
	// New value for the property when "op" is either "add" or "assign".
	Val AnyType `xml:"val,typeattr" json:"val"`
}

func init() {
	t["PropertyChange"] = reflect.TypeOf((*PropertyChange)(nil)).Elem()
}

// Specify the property data that is included in a filter.
//
// A filter can
// specify part of a single managed object, or parts of multiple related
// managed objects in an inventory hierarchy - for example, to collect
// updates from all virtual machines in a given folder.
type PropertyFilterSpec struct {
	DynamicData

	// Set of properties to include in the filter, specified for each object
	// type.
	PropSet []PropertySpec `xml:"propSet" json:"propSet"`
	// Set of specifications that determine the objects to filter.
	ObjectSet []ObjectSpec `xml:"objectSet" json:"objectSet"`
	// Control how to report missing objects during filter creation.
	//
	// If false or unset and `PropertyFilterSpec.objectSet` refers to missing objects,
	// filter creation will fail with a `ManagedObjectNotFound` fault.
	//
	// If true and `PropertyFilterSpec.objectSet` refers
	// to missing objects, filter creation will not fail and missing objects
	// will be reported via filter results. This is the recommended setting
	// when `PropertyFilterSpec.objectSet` refers to
	// transient objects.
	//
	// In an `UpdateSet` missing objects will
	// appear in the `PropertyFilterUpdate.missingSet` field.
	//
	// In a `RetrieveResult` missing objects will
	// simply be omitted from the objects field.
	//
	// For a call to `PropertyCollector.RetrieveProperties` missing objects will simply
	// be omitted from the results.
	ReportMissingObjectsInResults *bool `xml:"reportMissingObjectsInResults" json:"reportMissingObjectsInResults,omitempty"`
}

func init() {
	t["PropertyFilterSpec"] = reflect.TypeOf((*PropertyFilterSpec)(nil)).Elem()
}

// The `PropertyFilterUpdate` data object type contains a
// list of updates to data visible through a specific filter.
//
// Note that if a
// property changes through multiple filters, then a client receives an
// update for each filter.
type PropertyFilterUpdate struct {
	DynamicData

	// Filter that was updated.
	//
	// Refers instance of `PropertyFilter`.
	Filter ManagedObjectReference `xml:"filter" json:"filter"`
	// Set of changes to object properties in the filter.
	ObjectSet []ObjectUpdate `xml:"objectSet,omitempty" json:"objectSet,omitempty"`
	// Objects that could not be found on the server, but were specified in a
	// `PropertyFilterSpec.objectSet`.
	//
	// This field will only be populated for objects that were determined
	// to be missing since the data version passed to `PropertyCollector.CheckForUpdates`, `PropertyCollector.WaitForUpdates`, or `PropertyCollector.WaitForUpdatesEx` and will not contain objects that were missing
	// prior to that data version.
	MissingSet []MissingObject `xml:"missingSet,omitempty" json:"missingSet,omitempty"`
}

func init() {
	t["PropertyFilterUpdate"] = reflect.TypeOf((*PropertyFilterUpdate)(nil)).Elem()
}

// Within a `PropertyFilterSpec`, A `PropertySpec` specifies which properties should be
// reported to the client for objects of the given managed object type that
// are visited and not skipped.
//
// One more subtle side effect is that if a
// managed object is visited and not skipped, but there is no `PropertySpec` associated with the managed object's
// type, the managed object will not be reported to the client.
//
// Also, the set of properties applicable to a given managed object type
// is the union of the properties implied by the `PropertySpec` objects even, in the case of a `RetrieveResult`, where there may be an applicable
// `PropertySpec` in more than one filter.
type PropertySpec struct {
	DynamicData

	// Name of the managed object type being collected.
	Type string `xml:"type" json:"type"`
	// Specifies whether or not all properties of the object are read.
	//
	// If
	// this property is set to true, the `PropertySpec.pathSet` property is ignored.
	All *bool `xml:"all" json:"all,omitempty"`
	// Specifies which managed object properties are retrieved.
	//
	// If the `PropertySpec.pathSet` is empty, then the
	// `PropertyCollector` retrieves references to the managed objects
	// and no managed object properties are collected.
	PathSet []string `xml:"pathSet,omitempty" json:"pathSet,omitempty"`
}

func init() {
	t["PropertySpec"] = reflect.TypeOf((*PropertySpec)(nil)).Elem()
}

type ProvisionServerPrivateKey ProvisionServerPrivateKeyRequestType

func init() {
	t["ProvisionServerPrivateKey"] = reflect.TypeOf((*ProvisionServerPrivateKey)(nil)).Elem()
}

// The parameters of `HostCertificateManager.ProvisionServerPrivateKey`.
type ProvisionServerPrivateKeyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// SSL private key in PEM format
	Key string `xml:"key" json:"key"`
}

func init() {
	t["ProvisionServerPrivateKeyRequestType"] = reflect.TypeOf((*ProvisionServerPrivateKeyRequestType)(nil)).Elem()
	minAPIVersionForType["ProvisionServerPrivateKeyRequestType"] = "8.0.3.0"
}

type ProvisionServerPrivateKeyResponse struct {
}

type PutUsbScanCodes PutUsbScanCodesRequestType

func init() {
	t["PutUsbScanCodes"] = reflect.TypeOf((*PutUsbScanCodes)(nil)).Elem()
}

// The parameters of `VirtualMachine.PutUsbScanCodes`.
type PutUsbScanCodesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Spec UsbScanCodeSpec        `xml:"spec" json:"spec"`
}

func init() {
	t["PutUsbScanCodesRequestType"] = reflect.TypeOf((*PutUsbScanCodesRequestType)(nil)).Elem()
}

type PutUsbScanCodesResponse struct {
	Returnval int32 `xml:"returnval" json:"returnval"`
}

type QuarantineModeFault struct {
	VmConfigFault

	VmName    string `xml:"vmName" json:"vmName"`
	FaultType string `xml:"faultType" json:"faultType"`
}

func init() {
	t["QuarantineModeFault"] = reflect.TypeOf((*QuarantineModeFault)(nil)).Elem()
}

type QuarantineModeFaultFault QuarantineModeFault

func init() {
	t["QuarantineModeFaultFault"] = reflect.TypeOf((*QuarantineModeFaultFault)(nil)).Elem()
}

type QueryAnswerFileStatus QueryAnswerFileStatusRequestType

func init() {
	t["QueryAnswerFileStatus"] = reflect.TypeOf((*QueryAnswerFileStatus)(nil)).Elem()
}

// The parameters of `HostProfileManager.QueryAnswerFileStatus`.
type QueryAnswerFileStatusRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The hosts the answer file is associated with.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["QueryAnswerFileStatusRequestType"] = reflect.TypeOf((*QueryAnswerFileStatusRequestType)(nil)).Elem()
}

type QueryAnswerFileStatusResponse struct {
	Returnval []AnswerFileStatusResult `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryAssignedLicenses QueryAssignedLicensesRequestType

func init() {
	t["QueryAssignedLicenses"] = reflect.TypeOf((*QueryAssignedLicenses)(nil)).Elem()
}

// The parameters of `LicenseAssignmentManager.QueryAssignedLicenses`.
type QueryAssignedLicensesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// ID of the entity. E.g. HostSystem.
	EntityId string `xml:"entityId,omitempty" json:"entityId,omitempty"`
}

func init() {
	t["QueryAssignedLicensesRequestType"] = reflect.TypeOf((*QueryAssignedLicensesRequestType)(nil)).Elem()
}

type QueryAssignedLicensesResponse struct {
	Returnval []LicenseAssignmentManagerLicenseAssignment `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryAvailableDisksForVmfs QueryAvailableDisksForVmfsRequestType

func init() {
	t["QueryAvailableDisksForVmfs"] = reflect.TypeOf((*QueryAvailableDisksForVmfs)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.QueryAvailableDisksForVmfs`.
type QueryAvailableDisksForVmfsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The managed object reference of the VMFS datastore
	// you want extents for.
	//
	// Refers instance of `Datastore`.
	Datastore *ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty"`
}

func init() {
	t["QueryAvailableDisksForVmfsRequestType"] = reflect.TypeOf((*QueryAvailableDisksForVmfsRequestType)(nil)).Elem()
}

type QueryAvailableDisksForVmfsResponse struct {
	Returnval []HostScsiDisk `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryAvailableDvsSpec QueryAvailableDvsSpecRequestType

func init() {
	t["QueryAvailableDvsSpec"] = reflect.TypeOf((*QueryAvailableDvsSpec)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitchManager.QueryAvailableDvsSpec`.
type QueryAvailableDvsSpecRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If set to true, return only the recommended versions.
	// If set to false, return only the not recommended versions.
	// If unset, return all supported versions.
	Recommended *bool `xml:"recommended" json:"recommended,omitempty"`
}

func init() {
	t["QueryAvailableDvsSpecRequestType"] = reflect.TypeOf((*QueryAvailableDvsSpecRequestType)(nil)).Elem()
}

type QueryAvailableDvsSpecResponse struct {
	Returnval []DistributedVirtualSwitchProductSpec `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryAvailablePartition QueryAvailablePartitionRequestType

func init() {
	t["QueryAvailablePartition"] = reflect.TypeOf((*QueryAvailablePartition)(nil)).Elem()
}

type QueryAvailablePartitionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryAvailablePartitionRequestType"] = reflect.TypeOf((*QueryAvailablePartitionRequestType)(nil)).Elem()
}

type QueryAvailablePartitionResponse struct {
	Returnval []HostDiagnosticPartition `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryAvailablePerfMetric QueryAvailablePerfMetricRequestType

func init() {
	t["QueryAvailablePerfMetric"] = reflect.TypeOf((*QueryAvailablePerfMetric)(nil)).Elem()
}

// The parameters of `PerformanceManager.QueryAvailablePerfMetric`.
type QueryAvailablePerfMetricRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The *managed object* that
	// provides performance metrics.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// Starting time (server time) for a period of time from which to return
	// available metrics. If not specified, defaults to oldest available metric
	// for the specified entity.
	BeginTime *time.Time `xml:"beginTime" json:"beginTime,omitempty"`
	// Ending time (server time) for a period of time from which to return
	// available performance metrics. If not specified, defaults to the most
	// recently generated metric for the specified entity.
	EndTime *time.Time `xml:"endTime" json:"endTime,omitempty"`
	// Period of time from which to retrieve metrics, defined by intervalId
	// (rather than beginTime or endTime). Valid intervalIds include:
	//   - For real-time counters, the `refreshRate` of
	//     the *performance
	//     provider*.
	//   - For historical counters, the `samplingPeriod` of the *historical interval*.
	//
	// If this parameter is not specified, the system returns available metrics
	// for historical statistics&#46;
	IntervalId int32 `xml:"intervalId,omitempty" json:"intervalId,omitempty"`
}

func init() {
	t["QueryAvailablePerfMetricRequestType"] = reflect.TypeOf((*QueryAvailablePerfMetricRequestType)(nil)).Elem()
}

type QueryAvailablePerfMetricResponse struct {
	Returnval []PerfMetricId `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryAvailableSsds QueryAvailableSsdsRequestType

func init() {
	t["QueryAvailableSsds"] = reflect.TypeOf((*QueryAvailableSsds)(nil)).Elem()
}

// The parameters of `HostStorageSystem.QueryAvailableSsds`.
type QueryAvailableSsdsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The path of the VFFS to extend. See `FileSystemMountInfo`.
	VffsPath string `xml:"vffsPath,omitempty" json:"vffsPath,omitempty"`
}

func init() {
	t["QueryAvailableSsdsRequestType"] = reflect.TypeOf((*QueryAvailableSsdsRequestType)(nil)).Elem()
}

type QueryAvailableSsdsResponse struct {
	Returnval []HostScsiDisk `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryAvailableTimeZones QueryAvailableTimeZonesRequestType

func init() {
	t["QueryAvailableTimeZones"] = reflect.TypeOf((*QueryAvailableTimeZones)(nil)).Elem()
}

type QueryAvailableTimeZonesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryAvailableTimeZonesRequestType"] = reflect.TypeOf((*QueryAvailableTimeZonesRequestType)(nil)).Elem()
}

type QueryAvailableTimeZonesResponse struct {
	Returnval []HostDateTimeSystemTimeZone `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryBootDevices QueryBootDevicesRequestType

func init() {
	t["QueryBootDevices"] = reflect.TypeOf((*QueryBootDevices)(nil)).Elem()
}

type QueryBootDevicesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryBootDevicesRequestType"] = reflect.TypeOf((*QueryBootDevicesRequestType)(nil)).Elem()
}

type QueryBootDevicesResponse struct {
	Returnval *HostBootDeviceInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryBoundVnics QueryBoundVnicsRequestType

func init() {
	t["QueryBoundVnics"] = reflect.TypeOf((*QueryBoundVnics)(nil)).Elem()
}

// The parameters of `IscsiManager.QueryBoundVnics`.
type QueryBoundVnicsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// iSCSI adapter name for which the method to be
	// applied.
	IScsiHbaName string `xml:"iScsiHbaName" json:"iScsiHbaName"`
}

func init() {
	t["QueryBoundVnicsRequestType"] = reflect.TypeOf((*QueryBoundVnicsRequestType)(nil)).Elem()
}

type QueryBoundVnicsResponse struct {
	Returnval []IscsiPortInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryCandidateNics QueryCandidateNicsRequestType

func init() {
	t["QueryCandidateNics"] = reflect.TypeOf((*QueryCandidateNics)(nil)).Elem()
}

// The parameters of `IscsiManager.QueryCandidateNics`.
type QueryCandidateNicsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// iSCSI Adapter name for which the method to be
	// applied.
	IScsiHbaName string `xml:"iScsiHbaName" json:"iScsiHbaName"`
}

func init() {
	t["QueryCandidateNicsRequestType"] = reflect.TypeOf((*QueryCandidateNicsRequestType)(nil)).Elem()
}

type QueryCandidateNicsResponse struct {
	Returnval []IscsiPortInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryChangedDiskAreas QueryChangedDiskAreasRequestType

func init() {
	t["QueryChangedDiskAreas"] = reflect.TypeOf((*QueryChangedDiskAreas)(nil)).Elem()
}

// The parameters of `VirtualMachine.QueryChangedDiskAreas`.
type QueryChangedDiskAreasRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Snapshot for which changes that have been made sine
	// "changeId" should be computed. If not set, changes are computed
	// against the "current" snapshot of the virtual machine. However,
	// using the "current" snapshot will only work for virtual machines
	// that are powered off.
	//
	// Refers instance of `VirtualMachineSnapshot`.
	Snapshot *ManagedObjectReference `xml:"snapshot,omitempty" json:"snapshot,omitempty"`
	// Identifies the virtual disk for which to compute changes.
	DeviceKey int32 `xml:"deviceKey" json:"deviceKey"`
	// Start Offset in bytes at which to start computing changes.
	// Typically, callers will make multiple calls to this function, starting
	// with startOffset 0 and then examine the "length" property in the
	// returned DiskChangeInfo structure, repeatedly calling queryChangedDiskAreas
	// until a map forthe entire virtual disk has been obtained.
	StartOffset int64 `xml:"startOffset" json:"startOffset"`
	// Identifyer referring to a point in the past that should be used
	// as the point in time at which to begin including changes to the disk in
	// the result. A typical use case would be a backup application obtaining a
	// changeId from a virtual disk's backing info when performing a
	// backup. When a subsequent incremental backup is to be performed, this
	// change Id can be used to obtain a list of changed areas on disk.
	ChangeId string `xml:"changeId" json:"changeId"`
}

func init() {
	t["QueryChangedDiskAreasRequestType"] = reflect.TypeOf((*QueryChangedDiskAreasRequestType)(nil)).Elem()
}

type QueryChangedDiskAreasResponse struct {
	Returnval DiskChangeInfo `xml:"returnval" json:"returnval"`
}

type QueryCmmds QueryCmmdsRequestType

func init() {
	t["QueryCmmds"] = reflect.TypeOf((*QueryCmmds)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.QueryCmmds`.
type QueryCmmdsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of CMMDS query specs.
	Queries []HostVsanInternalSystemCmmdsQuery `xml:"queries" json:"queries"`
}

func init() {
	t["QueryCmmdsRequestType"] = reflect.TypeOf((*QueryCmmdsRequestType)(nil)).Elem()
}

type QueryCmmdsResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type QueryCompatibleHostForExistingDvs QueryCompatibleHostForExistingDvsRequestType

func init() {
	t["QueryCompatibleHostForExistingDvs"] = reflect.TypeOf((*QueryCompatibleHostForExistingDvs)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitchManager.QueryCompatibleHostForExistingDvs`.
type QueryCompatibleHostForExistingDvsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Where to look for hosts. Supported types of objects for
	// this parameter are `Datacenter`,
	// `ComputeResource` and `Folder`.
	//
	// Refers instance of `ManagedEntity`.
	Container ManagedObjectReference `xml:"container" json:"container"`
	// Whether to search for hosts in the subfolders,
	// if applicable. In the case when container is a `Datacenter`,
	// the recursive flag is applied to its HostFolder.
	Recursive bool `xml:"recursive" json:"recursive"`
	// Search the host based on the specification published in the
	// `DVSCapability.compatibleHostComponentProductInfo`
	// of a `DistributedVirtualSwitch`. If not
	// set, it is assumed to be the specification that a
	// DistributedVirtualSwitch would have if it is created
	// with the default `DistributedVirtualSwitchProductSpec`.
	//
	// Refers instance of `DistributedVirtualSwitch`.
	Dvs ManagedObjectReference `xml:"dvs" json:"dvs"`
}

func init() {
	t["QueryCompatibleHostForExistingDvsRequestType"] = reflect.TypeOf((*QueryCompatibleHostForExistingDvsRequestType)(nil)).Elem()
}

type QueryCompatibleHostForExistingDvsResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryCompatibleHostForNewDvs QueryCompatibleHostForNewDvsRequestType

func init() {
	t["QueryCompatibleHostForNewDvs"] = reflect.TypeOf((*QueryCompatibleHostForNewDvs)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitchManager.QueryCompatibleHostForNewDvs`.
type QueryCompatibleHostForNewDvsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Where to look for hosts. Supported types of objects for
	// this parameter are `Datacenter`,
	// `ComputeResource` and `Folder`.
	//
	// Refers instance of `ManagedEntity`.
	Container ManagedObjectReference `xml:"container" json:"container"`
	// Whether to search for hosts in the subfolders,
	// if applicable. In the case when container is a `Datacenter`,
	// the recursive flag is applied to its HostFolder.
	Recursive bool `xml:"recursive" json:"recursive"`
	// The productSpec of a `DistributedVirtualSwitch`.
	// If not set, it is assumed to be the default one used for
	// DistributedVirtualSwitch creation.
	SwitchProductSpec *DistributedVirtualSwitchProductSpec `xml:"switchProductSpec,omitempty" json:"switchProductSpec,omitempty"`
}

func init() {
	t["QueryCompatibleHostForNewDvsRequestType"] = reflect.TypeOf((*QueryCompatibleHostForNewDvsRequestType)(nil)).Elem()
}

type QueryCompatibleHostForNewDvsResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryCompatibleVmnicsFromHosts QueryCompatibleVmnicsFromHostsRequestType

func init() {
	t["QueryCompatibleVmnicsFromHosts"] = reflect.TypeOf((*QueryCompatibleVmnicsFromHosts)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitchManager.QueryCompatibleVmnicsFromHosts`.
type QueryCompatibleVmnicsFromHostsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The array of hosts on which the query is to be made to
	// fetch valid PhysicalNics on each host.
	//
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts,omitempty" json:"hosts,omitempty"`
	// The distributed virtual switch on which the query is to be
	// made.
	//
	// Refers instance of `DistributedVirtualSwitch`.
	Dvs ManagedObjectReference `xml:"dvs" json:"dvs"`
}

func init() {
	t["QueryCompatibleVmnicsFromHostsRequestType"] = reflect.TypeOf((*QueryCompatibleVmnicsFromHostsRequestType)(nil)).Elem()
	minAPIVersionForType["QueryCompatibleVmnicsFromHostsRequestType"] = "8.0.0.1"
}

type QueryCompatibleVmnicsFromHostsResponse struct {
	Returnval []DVSManagerPhysicalNicsList `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryComplianceStatus QueryComplianceStatusRequestType

func init() {
	t["QueryComplianceStatus"] = reflect.TypeOf((*QueryComplianceStatus)(nil)).Elem()
}

// The parameters of `ProfileComplianceManager.QueryComplianceStatus`.
type QueryComplianceStatusRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If specified, compliance result for the specified profiles will be
	// returned. This acts like a filtering criteria for the ComplianceResults based on
	// specified profiles.
	//
	// Refers instances of `Profile`.
	Profile []ManagedObjectReference `xml:"profile,omitempty" json:"profile,omitempty"`
	// If specified, compliance results for these entities will be returned.
	// This acts like a filtering criteria for the ComplianceResults based on entities.
	//
	// Refers instances of `ManagedEntity`.
	Entity []ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["QueryComplianceStatusRequestType"] = reflect.TypeOf((*QueryComplianceStatusRequestType)(nil)).Elem()
}

type QueryComplianceStatusResponse struct {
	Returnval []ComplianceResult `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryConfigOption QueryConfigOptionRequestType

func init() {
	t["QueryConfigOption"] = reflect.TypeOf((*QueryConfigOption)(nil)).Elem()
}

type QueryConfigOptionDescriptor QueryConfigOptionDescriptorRequestType

func init() {
	t["QueryConfigOptionDescriptor"] = reflect.TypeOf((*QueryConfigOptionDescriptor)(nil)).Elem()
}

type QueryConfigOptionDescriptorRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryConfigOptionDescriptorRequestType"] = reflect.TypeOf((*QueryConfigOptionDescriptorRequestType)(nil)).Elem()
}

type QueryConfigOptionDescriptorResponse struct {
	Returnval []VirtualMachineConfigOptionDescriptor `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryConfigOptionEx QueryConfigOptionExRequestType

func init() {
	t["QueryConfigOptionEx"] = reflect.TypeOf((*QueryConfigOptionEx)(nil)).Elem()
}

// The parameters of `EnvironmentBrowser.QueryConfigOptionEx`.
type QueryConfigOptionExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Search criteria and filters to control the result.
	// If a `EnvironmentBrowserConfigOptionQuerySpec.key` or
	// `EnvironmentBrowserConfigOptionQuerySpec.host` (or both)
	// are specified, they will be used to search for a config option.
	// If `EnvironmentBrowserConfigOptionQuerySpec.guestId`
	// is nonempty, the `VirtualMachineConfigOption.guestOSDescriptor`
	// array of the config option is filtered to match against the guest
	// IDs in the spec. If there is no match, the whole list is returned.
	// If the spec argument is omitted, the default
	// `VirtualMachineConfigOption` for this environment browser is
	// returned.
	Spec *EnvironmentBrowserConfigOptionQuerySpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["QueryConfigOptionExRequestType"] = reflect.TypeOf((*QueryConfigOptionExRequestType)(nil)).Elem()
}

type QueryConfigOptionExResponse struct {
	Returnval *VirtualMachineConfigOption `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The parameters of `EnvironmentBrowser.QueryConfigOption`.
type QueryConfigOptionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The key found in the VirtualMachineConfigOptionDescriptor,
	// obtained by invoking the
	// `EnvironmentBrowser.QueryConfigOptionDescriptor` operation.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// The host whose ConfigOption is requested.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["QueryConfigOptionRequestType"] = reflect.TypeOf((*QueryConfigOptionRequestType)(nil)).Elem()
}

type QueryConfigOptionResponse struct {
	Returnval *VirtualMachineConfigOption `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryConfigTarget QueryConfigTargetRequestType

func init() {
	t["QueryConfigTarget"] = reflect.TypeOf((*QueryConfigTarget)(nil)).Elem()
}

// The parameters of `EnvironmentBrowser.QueryConfigTarget`.
type QueryConfigTargetRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If specified, the host whose default BackingInfo is requested.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["QueryConfigTargetRequestType"] = reflect.TypeOf((*QueryConfigTargetRequestType)(nil)).Elem()
}

type QueryConfigTargetResponse struct {
	Returnval *ConfigTarget `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryConfiguredModuleOptionString QueryConfiguredModuleOptionStringRequestType

func init() {
	t["QueryConfiguredModuleOptionString"] = reflect.TypeOf((*QueryConfiguredModuleOptionString)(nil)).Elem()
}

// The parameters of `HostKernelModuleSystem.QueryConfiguredModuleOptionString`.
type QueryConfiguredModuleOptionStringRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Module name.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["QueryConfiguredModuleOptionStringRequestType"] = reflect.TypeOf((*QueryConfiguredModuleOptionStringRequestType)(nil)).Elem()
}

type QueryConfiguredModuleOptionStringResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type QueryConnectionInfo QueryConnectionInfoRequestType

func init() {
	t["QueryConnectionInfo"] = reflect.TypeOf((*QueryConnectionInfo)(nil)).Elem()
}

// The parameters of `Datacenter.QueryConnectionInfo`.
type QueryConnectionInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The target of the query.
	Hostname string `xml:"hostname" json:"hostname"`
	// The port number of the target host. For ESX 2.x this is the authd port
	// (902 by default). For ESX 3.x and above and for VMware Server hosts
	// this is the https port (443 by default). You can specify -1 to have the
	// vCenter Server try the default ports.
	Port int32 `xml:"port" json:"port"`
	// The name of the user.
	Username string `xml:"username" json:"username"`
	// The password of the user.
	Password string `xml:"password" json:"password"`
	// The expected SSL thumbprint of the host's certificate.
	SslThumbprint string `xml:"sslThumbprint,omitempty" json:"sslThumbprint,omitempty"`
}

func init() {
	t["QueryConnectionInfoRequestType"] = reflect.TypeOf((*QueryConnectionInfoRequestType)(nil)).Elem()
}

type QueryConnectionInfoResponse struct {
	Returnval HostConnectInfo `xml:"returnval" json:"returnval"`
}

type QueryConnectionInfoViaSpec QueryConnectionInfoViaSpecRequestType

func init() {
	t["QueryConnectionInfoViaSpec"] = reflect.TypeOf((*QueryConnectionInfoViaSpec)(nil)).Elem()
}

// The parameters of `Datacenter.QueryConnectionInfoViaSpec`.
type QueryConnectionInfoViaSpecRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The connection spec for the host to be queried. It must contain
	// values for all parameters required by `Datacenter.QueryConnectionInfo`
	// See `Datacenter.QueryConnectionInfo` or a list of thrown expections.
	Spec HostConnectSpec `xml:"spec" json:"spec"`
}

func init() {
	t["QueryConnectionInfoViaSpecRequestType"] = reflect.TypeOf((*QueryConnectionInfoViaSpecRequestType)(nil)).Elem()
}

type QueryConnectionInfoViaSpecResponse struct {
	Returnval HostConnectInfo `xml:"returnval" json:"returnval"`
}

type QueryConnections QueryConnectionsRequestType

func init() {
	t["QueryConnections"] = reflect.TypeOf((*QueryConnections)(nil)).Elem()
}

type QueryConnectionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryConnectionsRequestType"] = reflect.TypeOf((*QueryConnectionsRequestType)(nil)).Elem()
}

type QueryConnectionsResponse struct {
	Returnval []BaseVirtualMachineConnection `xml:"returnval,omitempty,typeattr" json:"returnval,omitempty"`
}

type QueryCryptoKeyStatus QueryCryptoKeyStatusRequestType

func init() {
	t["QueryCryptoKeyStatus"] = reflect.TypeOf((*QueryCryptoKeyStatus)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.QueryCryptoKeyStatus`.
type QueryCryptoKeyStatusRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] The Crypto Key Ids to query.
	KeyIds []CryptoKeyId `xml:"keyIds,omitempty" json:"keyIds,omitempty"`
	// \[in\] The key state to check. Supported value:
	// 0x01. check if key data is available to VC.
	// 0x02. check the VMs which use that key.
	// 0x04. check the hosts using this key as host key.
	// 0x08. Check 3rd party program which use that key.
	// Other bits - reserved and will be igonred.
	CheckKeyBitMap int32 `xml:"checkKeyBitMap" json:"checkKeyBitMap"`
}

func init() {
	t["QueryCryptoKeyStatusRequestType"] = reflect.TypeOf((*QueryCryptoKeyStatusRequestType)(nil)).Elem()
}

type QueryCryptoKeyStatusResponse struct {
	Returnval []CryptoManagerKmipCryptoKeyStatus `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryDatastorePerformanceSummary QueryDatastorePerformanceSummaryRequestType

func init() {
	t["QueryDatastorePerformanceSummary"] = reflect.TypeOf((*QueryDatastorePerformanceSummary)(nil)).Elem()
}

// The parameters of `StorageResourceManager.QueryDatastorePerformanceSummary`.
type QueryDatastorePerformanceSummaryRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Datastore for which summary statistics is requested.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["QueryDatastorePerformanceSummaryRequestType"] = reflect.TypeOf((*QueryDatastorePerformanceSummaryRequestType)(nil)).Elem()
}

type QueryDatastorePerformanceSummaryResponse struct {
	Returnval []StoragePerformanceSummary `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryDateTime QueryDateTimeRequestType

func init() {
	t["QueryDateTime"] = reflect.TypeOf((*QueryDateTime)(nil)).Elem()
}

type QueryDateTimeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryDateTimeRequestType"] = reflect.TypeOf((*QueryDateTimeRequestType)(nil)).Elem()
}

type QueryDateTimeResponse struct {
	Returnval time.Time `xml:"returnval" json:"returnval"`
}

type QueryDescriptions QueryDescriptionsRequestType

func init() {
	t["QueryDescriptions"] = reflect.TypeOf((*QueryDescriptions)(nil)).Elem()
}

// The parameters of `DiagnosticManager.QueryDescriptions`.
type QueryDescriptionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specifies the host. If not specified, then it defaults
	// to the server itself. For example, if called on
	// VirtualCenter, then the value defaults to VirtualCenter
	// logs. When called on an ESX server host, the host should
	// not be specified.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["QueryDescriptionsRequestType"] = reflect.TypeOf((*QueryDescriptionsRequestType)(nil)).Elem()
}

type QueryDescriptionsResponse struct {
	Returnval []DiagnosticManagerLogDescriptor `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryDirectoryInfo QueryDirectoryInfoRequestType

func init() {
	t["QueryDirectoryInfo"] = reflect.TypeOf((*QueryDirectoryInfo)(nil)).Elem()
}

// The parameters of `DatastoreNamespaceManager.QueryDirectoryInfo`.
type QueryDirectoryInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// the datacenter of the namespace path. Needs to be set
	// when making the call to VC; ignored when the call is
	// made to ESX.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// stable vmfs path of the top-level directory to query
	StableName string `xml:"stableName" json:"stableName"`
}

func init() {
	t["QueryDirectoryInfoRequestType"] = reflect.TypeOf((*QueryDirectoryInfoRequestType)(nil)).Elem()
	minAPIVersionForType["QueryDirectoryInfoRequestType"] = "8.0.1.0"
}

type QueryDirectoryInfoResponse struct {
	Returnval DatastoreNamespaceManagerDirectoryInfo `xml:"returnval" json:"returnval"`
}

type QueryDisksForVsan QueryDisksForVsanRequestType

func init() {
	t["QueryDisksForVsan"] = reflect.TypeOf((*QueryDisksForVsan)(nil)).Elem()
}

// The parameters of `HostVsanSystem.QueryDisksForVsan`.
type QueryDisksForVsanRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// may be set to restrict the query to the list of
	// `HostScsiDisk` objects named by the
	// given paths
	CanonicalName []string `xml:"canonicalName,omitempty" json:"canonicalName,omitempty"`
}

func init() {
	t["QueryDisksForVsanRequestType"] = reflect.TypeOf((*QueryDisksForVsanRequestType)(nil)).Elem()
}

type QueryDisksForVsanResponse struct {
	Returnval []VsanHostDiskResult `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryDisksUsingFilter QueryDisksUsingFilterRequestType

func init() {
	t["QueryDisksUsingFilter"] = reflect.TypeOf((*QueryDisksUsingFilter)(nil)).Elem()
}

// The parameters of `IoFilterManager.QueryDisksUsingFilter`.
type QueryDisksUsingFilterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// ID of the filter.
	FilterId string `xml:"filterId" json:"filterId"`
	// The compute resource that the filter has been installed on.
	// "compRes" must be a cluster.
	//
	// Refers instance of `ComputeResource`.
	CompRes ManagedObjectReference `xml:"compRes" json:"compRes"`
}

func init() {
	t["QueryDisksUsingFilterRequestType"] = reflect.TypeOf((*QueryDisksUsingFilterRequestType)(nil)).Elem()
}

type QueryDisksUsingFilterResponse struct {
	Returnval []VirtualDiskId `xml:"returnval" json:"returnval"`
}

type QueryDvsByUuid QueryDvsByUuidRequestType

func init() {
	t["QueryDvsByUuid"] = reflect.TypeOf((*QueryDvsByUuid)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitchManager.QueryDvsByUuid`.
type QueryDvsByUuidRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Uuid string                 `xml:"uuid" json:"uuid"`
}

func init() {
	t["QueryDvsByUuidRequestType"] = reflect.TypeOf((*QueryDvsByUuidRequestType)(nil)).Elem()
}

type QueryDvsByUuidResponse struct {
	Returnval *ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryDvsCheckCompatibility QueryDvsCheckCompatibilityRequestType

func init() {
	t["QueryDvsCheckCompatibility"] = reflect.TypeOf((*QueryDvsCheckCompatibility)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitchManager.QueryDvsCheckCompatibility`.
type QueryDvsCheckCompatibilityRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The container of hosts on which we check the compatibility.
	// This container can be a datacenter, folder, or computeResource.
	// We can also include all the hosts in the hierarchy with container
	// as root of the tree.
	HostContainer DistributedVirtualSwitchManagerHostContainer `xml:"hostContainer" json:"hostContainer"`
	// The productSpec of a DistributedVirtualSwitch. If not
	// set, it is assumed to be the default one used for
	// DistributedVirtualSwitch creation for current version.
	DvsProductSpec *DistributedVirtualSwitchManagerDvsProductSpec `xml:"dvsProductSpec,omitempty" json:"dvsProductSpec,omitempty"`
	// The hosts against which to check compatibility. This is a
	// filterSpec and users can use this to specify all hosts in a
	// container (datacenter, folder, or computeResource), an array
	// of hosts, or hosts that might or might not be a DVS member.
	HostFilterSpec []BaseDistributedVirtualSwitchManagerHostDvsFilterSpec `xml:"hostFilterSpec,omitempty,typeattr" json:"hostFilterSpec,omitempty"`
}

func init() {
	t["QueryDvsCheckCompatibilityRequestType"] = reflect.TypeOf((*QueryDvsCheckCompatibilityRequestType)(nil)).Elem()
}

type QueryDvsCheckCompatibilityResponse struct {
	Returnval []DistributedVirtualSwitchManagerCompatibilityResult `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryDvsCompatibleHostSpec QueryDvsCompatibleHostSpecRequestType

func init() {
	t["QueryDvsCompatibleHostSpec"] = reflect.TypeOf((*QueryDvsCompatibleHostSpec)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitchManager.QueryDvsCompatibleHostSpec`.
type QueryDvsCompatibleHostSpecRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The productSpec of a `DistributedVirtualSwitch`.
	// If not set, it is assumed to be the default one used for
	// DistributedVirtualSwitch creation.
	SwitchProductSpec *DistributedVirtualSwitchProductSpec `xml:"switchProductSpec,omitempty" json:"switchProductSpec,omitempty"`
}

func init() {
	t["QueryDvsCompatibleHostSpecRequestType"] = reflect.TypeOf((*QueryDvsCompatibleHostSpecRequestType)(nil)).Elem()
}

type QueryDvsCompatibleHostSpecResponse struct {
	Returnval []DistributedVirtualSwitchHostProductSpec `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryDvsConfigTarget QueryDvsConfigTargetRequestType

func init() {
	t["QueryDvsConfigTarget"] = reflect.TypeOf((*QueryDvsConfigTarget)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitchManager.QueryDvsConfigTarget`.
type QueryDvsConfigTargetRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The host on which the query is to be made. If called
	// directly on the host this parameter need not be specified.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The distributed virtual switch on which the query is to be
	// made. If unspecified the config target will encompass all the
	// distributed virtual switches available on the host.
	//
	// Refers instance of `DistributedVirtualSwitch`.
	Dvs *ManagedObjectReference `xml:"dvs,omitempty" json:"dvs,omitempty"`
}

func init() {
	t["QueryDvsConfigTargetRequestType"] = reflect.TypeOf((*QueryDvsConfigTargetRequestType)(nil)).Elem()
}

type QueryDvsConfigTargetResponse struct {
	Returnval DVSManagerDvsConfigTarget `xml:"returnval" json:"returnval"`
}

type QueryDvsFeatureCapability QueryDvsFeatureCapabilityRequestType

func init() {
	t["QueryDvsFeatureCapability"] = reflect.TypeOf((*QueryDvsFeatureCapability)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitchManager.QueryDvsFeatureCapability`.
type QueryDvsFeatureCapabilityRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The productSpec of a `DistributedVirtualSwitch`.
	// If not set, it is assumed to be the default one used for
	// DistributedVirtualSwitch creation.
	SwitchProductSpec *DistributedVirtualSwitchProductSpec `xml:"switchProductSpec,omitempty" json:"switchProductSpec,omitempty"`
}

func init() {
	t["QueryDvsFeatureCapabilityRequestType"] = reflect.TypeOf((*QueryDvsFeatureCapabilityRequestType)(nil)).Elem()
}

type QueryDvsFeatureCapabilityResponse struct {
	Returnval BaseDVSFeatureCapability `xml:"returnval,omitempty,typeattr" json:"returnval,omitempty"`
}

type QueryEvents QueryEventsRequestType

func init() {
	t["QueryEvents"] = reflect.TypeOf((*QueryEvents)(nil)).Elem()
}

// The parameters of `EventManager.QueryEvents`.
type QueryEventsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The events qualified.
	Filter EventFilterSpec `xml:"filter" json:"filter"`
}

func init() {
	t["QueryEventsRequestType"] = reflect.TypeOf((*QueryEventsRequestType)(nil)).Elem()
}

type QueryEventsResponse struct {
	Returnval []BaseEvent `xml:"returnval,omitempty,typeattr" json:"returnval,omitempty"`
}

type QueryExpressionMetadata QueryExpressionMetadataRequestType

func init() {
	t["QueryExpressionMetadata"] = reflect.TypeOf((*QueryExpressionMetadata)(nil)).Elem()
}

// The parameters of `ProfileComplianceManager.QueryExpressionMetadata`.
type QueryExpressionMetadataRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Names of the Expressions for which metadata is requested.
	// If expressionNames are not specified, metadata for all known expressions is returned
	ExpressionName []string `xml:"expressionName,omitempty" json:"expressionName,omitempty"`
	// Base profile whose context needs to be used during the operation
	//
	// Refers instance of `Profile`.
	Profile *ManagedObjectReference `xml:"profile,omitempty" json:"profile,omitempty"`
}

func init() {
	t["QueryExpressionMetadataRequestType"] = reflect.TypeOf((*QueryExpressionMetadataRequestType)(nil)).Elem()
}

type QueryExpressionMetadataResponse struct {
	Returnval []ProfileExpressionMetadata `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryExtensionIpAllocationUsage QueryExtensionIpAllocationUsageRequestType

func init() {
	t["QueryExtensionIpAllocationUsage"] = reflect.TypeOf((*QueryExtensionIpAllocationUsage)(nil)).Elem()
}

// The parameters of `ExtensionManager.QueryExtensionIpAllocationUsage`.
type QueryExtensionIpAllocationUsageRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of extensions whose IP allocation is being queried.
	// If no extension keys are specified then allocation data
	// for all registered extensions are returned.
	ExtensionKeys []string `xml:"extensionKeys,omitempty" json:"extensionKeys,omitempty"`
}

func init() {
	t["QueryExtensionIpAllocationUsageRequestType"] = reflect.TypeOf((*QueryExtensionIpAllocationUsageRequestType)(nil)).Elem()
}

type QueryExtensionIpAllocationUsageResponse struct {
	Returnval []ExtensionManagerIpAllocationUsage `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryFaultToleranceCompatibility QueryFaultToleranceCompatibilityRequestType

func init() {
	t["QueryFaultToleranceCompatibility"] = reflect.TypeOf((*QueryFaultToleranceCompatibility)(nil)).Elem()
}

type QueryFaultToleranceCompatibilityEx QueryFaultToleranceCompatibilityExRequestType

func init() {
	t["QueryFaultToleranceCompatibilityEx"] = reflect.TypeOf((*QueryFaultToleranceCompatibilityEx)(nil)).Elem()
}

// The parameters of `VirtualMachine.QueryFaultToleranceCompatibilityEx`.
type QueryFaultToleranceCompatibilityExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// checks for legacy record-replay FT compatibility only
	// if this is set to true.
	ForLegacyFt *bool `xml:"forLegacyFt" json:"forLegacyFt,omitempty"`
}

func init() {
	t["QueryFaultToleranceCompatibilityExRequestType"] = reflect.TypeOf((*QueryFaultToleranceCompatibilityExRequestType)(nil)).Elem()
}

type QueryFaultToleranceCompatibilityExResponse struct {
	Returnval []LocalizedMethodFault `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryFaultToleranceCompatibilityRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryFaultToleranceCompatibilityRequestType"] = reflect.TypeOf((*QueryFaultToleranceCompatibilityRequestType)(nil)).Elem()
}

type QueryFaultToleranceCompatibilityResponse struct {
	Returnval []LocalizedMethodFault `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryFileLockInfo QueryFileLockInfoRequestType

func init() {
	t["QueryFileLockInfo"] = reflect.TypeOf((*QueryFileLockInfo)(nil)).Elem()
}

// The parameters of `FileManager.QueryFileLockInfo`.
type QueryFileLockInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Full file path to look up lock information on.
	// For example specific VM file like:
	// /vmfs/volumes/datastore1/vm/vm-flat.vmdk
	Path string `xml:"path" json:"path"`
	// Host id is required if API is invoked on vCenter Server.
	// It is optional if invoked on host directly. Esx does not
	// require this parameter.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["QueryFileLockInfoRequestType"] = reflect.TypeOf((*QueryFileLockInfoRequestType)(nil)).Elem()
	minAPIVersionForType["QueryFileLockInfoRequestType"] = "8.0.2.0"
}

type QueryFileLockInfoResponse struct {
	Returnval FileLockInfoResult `xml:"returnval" json:"returnval"`
}

type QueryFilterEntities QueryFilterEntitiesRequestType

func init() {
	t["QueryFilterEntities"] = reflect.TypeOf((*QueryFilterEntities)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.QueryFilterEntities`.
type QueryFilterEntitiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The filter id.
	FilterId string `xml:"filterId" json:"filterId"`
}

func init() {
	t["QueryFilterEntitiesRequestType"] = reflect.TypeOf((*QueryFilterEntitiesRequestType)(nil)).Elem()
}

type QueryFilterEntitiesResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryFilterInfoIds QueryFilterInfoIdsRequestType

func init() {
	t["QueryFilterInfoIds"] = reflect.TypeOf((*QueryFilterInfoIds)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.QueryFilterInfoIds`.
type QueryFilterInfoIdsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The filter id.
	FilterId string `xml:"filterId" json:"filterId"`
}

func init() {
	t["QueryFilterInfoIdsRequestType"] = reflect.TypeOf((*QueryFilterInfoIdsRequestType)(nil)).Elem()
}

type QueryFilterInfoIdsResponse struct {
	Returnval []string `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryFilterList QueryFilterListRequestType

func init() {
	t["QueryFilterList"] = reflect.TypeOf((*QueryFilterList)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.QueryFilterList`.
type QueryFilterListRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The provider id.
	ProviderId string `xml:"providerId" json:"providerId"`
}

func init() {
	t["QueryFilterListRequestType"] = reflect.TypeOf((*QueryFilterListRequestType)(nil)).Elem()
}

type QueryFilterListResponse struct {
	Returnval []string `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryFilterName QueryFilterNameRequestType

func init() {
	t["QueryFilterName"] = reflect.TypeOf((*QueryFilterName)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.QueryFilterName`.
type QueryFilterNameRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The filter id.
	FilterId string `xml:"filterId" json:"filterId"`
}

func init() {
	t["QueryFilterNameRequestType"] = reflect.TypeOf((*QueryFilterNameRequestType)(nil)).Elem()
}

type QueryFilterNameResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type QueryFirmwareConfigUploadURL QueryFirmwareConfigUploadURLRequestType

func init() {
	t["QueryFirmwareConfigUploadURL"] = reflect.TypeOf((*QueryFirmwareConfigUploadURL)(nil)).Elem()
}

type QueryFirmwareConfigUploadURLRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryFirmwareConfigUploadURLRequestType"] = reflect.TypeOf((*QueryFirmwareConfigUploadURLRequestType)(nil)).Elem()
}

type QueryFirmwareConfigUploadURLResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type QueryHealthUpdateInfos QueryHealthUpdateInfosRequestType

func init() {
	t["QueryHealthUpdateInfos"] = reflect.TypeOf((*QueryHealthUpdateInfos)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.QueryHealthUpdateInfos`.
type QueryHealthUpdateInfosRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The provider id.
	ProviderId string `xml:"providerId" json:"providerId"`
}

func init() {
	t["QueryHealthUpdateInfosRequestType"] = reflect.TypeOf((*QueryHealthUpdateInfosRequestType)(nil)).Elem()
}

type QueryHealthUpdateInfosResponse struct {
	Returnval []HealthUpdateInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryHealthUpdates QueryHealthUpdatesRequestType

func init() {
	t["QueryHealthUpdates"] = reflect.TypeOf((*QueryHealthUpdates)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.QueryHealthUpdates`.
type QueryHealthUpdatesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The provider id.
	ProviderId string `xml:"providerId" json:"providerId"`
}

func init() {
	t["QueryHealthUpdatesRequestType"] = reflect.TypeOf((*QueryHealthUpdatesRequestType)(nil)).Elem()
}

type QueryHealthUpdatesResponse struct {
	Returnval []HealthUpdate `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryHostConnectionInfo QueryHostConnectionInfoRequestType

func init() {
	t["QueryHostConnectionInfo"] = reflect.TypeOf((*QueryHostConnectionInfo)(nil)).Elem()
}

type QueryHostConnectionInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryHostConnectionInfoRequestType"] = reflect.TypeOf((*QueryHostConnectionInfoRequestType)(nil)).Elem()
}

type QueryHostConnectionInfoResponse struct {
	Returnval HostConnectInfo `xml:"returnval" json:"returnval"`
}

// The parameters of `HostPatchManager.QueryHostPatch_Task`.
type QueryHostPatchRequestType struct {
	This ManagedObjectReference                     `xml:"_this" json:"-"`
	Spec *HostPatchManagerPatchManagerOperationSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["QueryHostPatchRequestType"] = reflect.TypeOf((*QueryHostPatchRequestType)(nil)).Elem()
}

type QueryHostPatch_Task QueryHostPatchRequestType

func init() {
	t["QueryHostPatch_Task"] = reflect.TypeOf((*QueryHostPatch_Task)(nil)).Elem()
}

type QueryHostPatch_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type QueryHostProfileMetadata QueryHostProfileMetadataRequestType

func init() {
	t["QueryHostProfileMetadata"] = reflect.TypeOf((*QueryHostProfileMetadata)(nil)).Elem()
}

// The parameters of `HostProfileManager.QueryHostProfileMetadata`.
type QueryHostProfileMetadataRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Names of the profiles for which metadata is requested.
	// If not set, the method returns metadata for all the profiles.
	ProfileName []string `xml:"profileName,omitempty" json:"profileName,omitempty"`
	// Base profile whose context needs to be used during the operation
	//
	// Refers instance of `Profile`.
	Profile *ManagedObjectReference `xml:"profile,omitempty" json:"profile,omitempty"`
}

func init() {
	t["QueryHostProfileMetadataRequestType"] = reflect.TypeOf((*QueryHostProfileMetadataRequestType)(nil)).Elem()
}

type QueryHostProfileMetadataResponse struct {
	Returnval []ProfileMetadata `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryHostStatus QueryHostStatusRequestType

func init() {
	t["QueryHostStatus"] = reflect.TypeOf((*QueryHostStatus)(nil)).Elem()
}

type QueryHostStatusRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryHostStatusRequestType"] = reflect.TypeOf((*QueryHostStatusRequestType)(nil)).Elem()
}

type QueryHostStatusResponse struct {
	Returnval VsanHostClusterStatus `xml:"returnval" json:"returnval"`
}

type QueryHostsWithAttachedLun QueryHostsWithAttachedLunRequestType

func init() {
	t["QueryHostsWithAttachedLun"] = reflect.TypeOf((*QueryHostsWithAttachedLun)(nil)).Elem()
}

// The parameters of `StorageQueryManager.QueryHostsWithAttachedLun`.
type QueryHostsWithAttachedLunRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The UUID of the ScsiLun device.
	LunUuid string `xml:"lunUuid" json:"lunUuid"`
}

func init() {
	t["QueryHostsWithAttachedLunRequestType"] = reflect.TypeOf((*QueryHostsWithAttachedLunRequestType)(nil)).Elem()
}

type QueryHostsWithAttachedLunResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryIORMConfigOption QueryIORMConfigOptionRequestType

func init() {
	t["QueryIORMConfigOption"] = reflect.TypeOf((*QueryIORMConfigOption)(nil)).Elem()
}

// The parameters of `StorageResourceManager.QueryIORMConfigOption`.
type QueryIORMConfigOptionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] - The host VC will forward the query
	// to. This parameter is ignored by host if this method is
	// called on a host directly.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["QueryIORMConfigOptionRequestType"] = reflect.TypeOf((*QueryIORMConfigOptionRequestType)(nil)).Elem()
}

type QueryIORMConfigOptionResponse struct {
	Returnval StorageIORMConfigOption `xml:"returnval" json:"returnval"`
}

type QueryIPAllocations QueryIPAllocationsRequestType

func init() {
	t["QueryIPAllocations"] = reflect.TypeOf((*QueryIPAllocations)(nil)).Elem()
}

// The parameters of `IpPoolManager.QueryIPAllocations`.
type QueryIPAllocationsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datacenter on which to find the pool
	//
	// Required privileges: Datacenter.IpPoolQueryAllocations
	//
	// Refers instance of `Datacenter`.
	Dc ManagedObjectReference `xml:"dc" json:"dc"`
	// The unique ID of the pool
	PoolId int32 `xml:"poolId" json:"poolId"`
	// The key of the extension
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
}

func init() {
	t["QueryIPAllocationsRequestType"] = reflect.TypeOf((*QueryIPAllocationsRequestType)(nil)).Elem()
}

type QueryIPAllocationsResponse struct {
	Returnval []IpPoolManagerIpAllocation `xml:"returnval" json:"returnval"`
}

type QueryIoFilterInfo QueryIoFilterInfoRequestType

func init() {
	t["QueryIoFilterInfo"] = reflect.TypeOf((*QueryIoFilterInfo)(nil)).Elem()
}

// The parameters of `IoFilterManager.QueryIoFilterInfo`.
type QueryIoFilterInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The compute resource.
	// "compRes" must be a cluster.
	//
	// Refers instance of `ComputeResource`.
	CompRes ManagedObjectReference `xml:"compRes" json:"compRes"`
}

func init() {
	t["QueryIoFilterInfoRequestType"] = reflect.TypeOf((*QueryIoFilterInfoRequestType)(nil)).Elem()
}

type QueryIoFilterInfoResponse struct {
	Returnval []ClusterIoFilterInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryIoFilterIssues QueryIoFilterIssuesRequestType

func init() {
	t["QueryIoFilterIssues"] = reflect.TypeOf((*QueryIoFilterIssues)(nil)).Elem()
}

// The parameters of `IoFilterManager.QueryIoFilterIssues`.
type QueryIoFilterIssuesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The filter.
	FilterId string `xml:"filterId" json:"filterId"`
	// The compute resource.
	// "compRes" must be a cluster.
	//
	// Refers instance of `ComputeResource`.
	CompRes ManagedObjectReference `xml:"compRes" json:"compRes"`
}

func init() {
	t["QueryIoFilterIssuesRequestType"] = reflect.TypeOf((*QueryIoFilterIssuesRequestType)(nil)).Elem()
}

type QueryIoFilterIssuesResponse struct {
	Returnval IoFilterQueryIssueResult `xml:"returnval" json:"returnval"`
}

type QueryIpPools QueryIpPoolsRequestType

func init() {
	t["QueryIpPools"] = reflect.TypeOf((*QueryIpPools)(nil)).Elem()
}

// The parameters of `IpPoolManager.QueryIpPools`.
type QueryIpPoolsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datacenter for which to look up the IP pools.
	//
	// Required privileges: System.Read
	//
	// Refers instance of `Datacenter`.
	Dc ManagedObjectReference `xml:"dc" json:"dc"`
}

func init() {
	t["QueryIpPoolsRequestType"] = reflect.TypeOf((*QueryIpPoolsRequestType)(nil)).Elem()
}

type QueryIpPoolsResponse struct {
	Returnval []IpPool `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryLicenseSourceAvailability QueryLicenseSourceAvailabilityRequestType

func init() {
	t["QueryLicenseSourceAvailability"] = reflect.TypeOf((*QueryLicenseSourceAvailability)(nil)).Elem()
}

// The parameters of `LicenseManager.QueryLicenseSourceAvailability`.
type QueryLicenseSourceAvailabilityRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Use the license source of the specified host.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["QueryLicenseSourceAvailabilityRequestType"] = reflect.TypeOf((*QueryLicenseSourceAvailabilityRequestType)(nil)).Elem()
}

type QueryLicenseSourceAvailabilityResponse struct {
	Returnval []LicenseAvailabilityInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryLicenseUsage QueryLicenseUsageRequestType

func init() {
	t["QueryLicenseUsage"] = reflect.TypeOf((*QueryLicenseUsage)(nil)).Elem()
}

// The parameters of `LicenseManager.QueryLicenseUsage`.
type QueryLicenseUsageRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Host to query for usage. If missing, query the server the
	// `LicenseManager` is on.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["QueryLicenseUsageRequestType"] = reflect.TypeOf((*QueryLicenseUsageRequestType)(nil)).Elem()
}

type QueryLicenseUsageResponse struct {
	Returnval LicenseUsageInfo `xml:"returnval" json:"returnval"`
}

type QueryLockdownExceptions QueryLockdownExceptionsRequestType

func init() {
	t["QueryLockdownExceptions"] = reflect.TypeOf((*QueryLockdownExceptions)(nil)).Elem()
}

type QueryLockdownExceptionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryLockdownExceptionsRequestType"] = reflect.TypeOf((*QueryLockdownExceptionsRequestType)(nil)).Elem()
}

type QueryLockdownExceptionsResponse struct {
	Returnval []string `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryManagedBy QueryManagedByRequestType

func init() {
	t["QueryManagedBy"] = reflect.TypeOf((*QueryManagedBy)(nil)).Elem()
}

// The parameters of `ExtensionManager.QueryManagedBy`.
type QueryManagedByRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Key of the extension to find managed entities for.
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
}

func init() {
	t["QueryManagedByRequestType"] = reflect.TypeOf((*QueryManagedByRequestType)(nil)).Elem()
}

type QueryManagedByResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryMaxQueueDepth QueryMaxQueueDepthRequestType

func init() {
	t["QueryMaxQueueDepth"] = reflect.TypeOf((*QueryMaxQueueDepth)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.QueryMaxQueueDepth`.
type QueryMaxQueueDepthRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The NFS datastore which need to query max queue depth
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["QueryMaxQueueDepthRequestType"] = reflect.TypeOf((*QueryMaxQueueDepthRequestType)(nil)).Elem()
	minAPIVersionForType["QueryMaxQueueDepthRequestType"] = "8.0.0.1"
}

type QueryMaxQueueDepthResponse struct {
	Returnval int64 `xml:"returnval" json:"returnval"`
}

type QueryMemoryOverhead QueryMemoryOverheadRequestType

func init() {
	t["QueryMemoryOverhead"] = reflect.TypeOf((*QueryMemoryOverhead)(nil)).Elem()
}

type QueryMemoryOverheadEx QueryMemoryOverheadExRequestType

func init() {
	t["QueryMemoryOverheadEx"] = reflect.TypeOf((*QueryMemoryOverheadEx)(nil)).Elem()
}

// The parameters of `HostSystem.QueryMemoryOverheadEx`.
type QueryMemoryOverheadExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The configuration of the virtual machine.
	VmConfigInfo VirtualMachineConfigInfo `xml:"vmConfigInfo" json:"vmConfigInfo"`
}

func init() {
	t["QueryMemoryOverheadExRequestType"] = reflect.TypeOf((*QueryMemoryOverheadExRequestType)(nil)).Elem()
}

type QueryMemoryOverheadExResponse struct {
	Returnval int64 `xml:"returnval" json:"returnval"`
}

// The parameters of `HostSystem.QueryMemoryOverhead`.
type QueryMemoryOverheadRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The amount of virtual system RAM, in bytes. For an existing
	// virtual machine, this value can be found (in megabytes) as the memoryMB
	// property of the `VirtualHardware`.
	MemorySize int64 `xml:"memorySize" json:"memorySize"`
	// The amount of virtual video RAM, in bytes. For an existing
	// virtual machine on a host that supports advertising this property, this
	// value can be found (in kilobytes) as the videoRamSizeInKB property of the
	// `VirtualMachineVideoCard`. If this parameter is left unset, the
	// default video RAM size for virtual machines on this host is assumed.
	VideoRamSize int32 `xml:"videoRamSize,omitempty" json:"videoRamSize,omitempty"`
	// The number of virtual CPUs. For an existing virtual machine, this
	// value can be found as the numCPU property of the
	// `VirtualHardware`.
	NumVcpus int32 `xml:"numVcpus" json:"numVcpus"`
}

func init() {
	t["QueryMemoryOverheadRequestType"] = reflect.TypeOf((*QueryMemoryOverheadRequestType)(nil)).Elem()
}

type QueryMemoryOverheadResponse struct {
	Returnval int64 `xml:"returnval" json:"returnval"`
}

type QueryMigrationDependencies QueryMigrationDependenciesRequestType

func init() {
	t["QueryMigrationDependencies"] = reflect.TypeOf((*QueryMigrationDependencies)(nil)).Elem()
}

// The parameters of `IscsiManager.QueryMigrationDependencies`.
type QueryMigrationDependenciesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of Physical NICs to be migrated
	PnicDevice []string `xml:"pnicDevice" json:"pnicDevice"`
}

func init() {
	t["QueryMigrationDependenciesRequestType"] = reflect.TypeOf((*QueryMigrationDependenciesRequestType)(nil)).Elem()
}

type QueryMigrationDependenciesResponse struct {
	Returnval IscsiMigrationDependency `xml:"returnval" json:"returnval"`
}

type QueryModules QueryModulesRequestType

func init() {
	t["QueryModules"] = reflect.TypeOf((*QueryModules)(nil)).Elem()
}

type QueryModulesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryModulesRequestType"] = reflect.TypeOf((*QueryModulesRequestType)(nil)).Elem()
}

type QueryModulesResponse struct {
	Returnval []KernelModuleInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryMonitoredEntities QueryMonitoredEntitiesRequestType

func init() {
	t["QueryMonitoredEntities"] = reflect.TypeOf((*QueryMonitoredEntities)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.QueryMonitoredEntities`.
type QueryMonitoredEntitiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The provider id.
	ProviderId string `xml:"providerId" json:"providerId"`
}

func init() {
	t["QueryMonitoredEntitiesRequestType"] = reflect.TypeOf((*QueryMonitoredEntitiesRequestType)(nil)).Elem()
}

type QueryMonitoredEntitiesResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryNFSUser QueryNFSUserRequestType

func init() {
	t["QueryNFSUser"] = reflect.TypeOf((*QueryNFSUser)(nil)).Elem()
}

type QueryNFSUserRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryNFSUserRequestType"] = reflect.TypeOf((*QueryNFSUserRequestType)(nil)).Elem()
}

type QueryNFSUserResponse struct {
	Returnval *HostNasVolumeUserInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryNetConfig QueryNetConfigRequestType

func init() {
	t["QueryNetConfig"] = reflect.TypeOf((*QueryNetConfig)(nil)).Elem()
}

// The parameters of `HostVirtualNicManager.QueryNetConfig`.
type QueryNetConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The `HostVirtualNicManagerNicType_enum`
	NicType string `xml:"nicType" json:"nicType"`
}

func init() {
	t["QueryNetConfigRequestType"] = reflect.TypeOf((*QueryNetConfigRequestType)(nil)).Elem()
}

type QueryNetConfigResponse struct {
	Returnval *VirtualNicManagerNetConfig `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryNetworkHint QueryNetworkHintRequestType

func init() {
	t["QueryNetworkHint"] = reflect.TypeOf((*QueryNetworkHint)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.QueryNetworkHint`.
type QueryNetworkHintRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	Device []string               `xml:"device,omitempty" json:"device,omitempty"`
}

func init() {
	t["QueryNetworkHintRequestType"] = reflect.TypeOf((*QueryNetworkHintRequestType)(nil)).Elem()
}

type QueryNetworkHintResponse struct {
	Returnval []PhysicalNicHintInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryObjectsOnPhysicalVsanDisk QueryObjectsOnPhysicalVsanDiskRequestType

func init() {
	t["QueryObjectsOnPhysicalVsanDisk"] = reflect.TypeOf((*QueryObjectsOnPhysicalVsanDisk)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.QueryObjectsOnPhysicalVsanDisk`.
type QueryObjectsOnPhysicalVsanDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of VSAN disk UUIDs.
	Disks []string `xml:"disks" json:"disks"`
}

func init() {
	t["QueryObjectsOnPhysicalVsanDiskRequestType"] = reflect.TypeOf((*QueryObjectsOnPhysicalVsanDiskRequestType)(nil)).Elem()
}

type QueryObjectsOnPhysicalVsanDiskResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type QueryOptions QueryOptionsRequestType

func init() {
	t["QueryOptions"] = reflect.TypeOf((*QueryOptions)(nil)).Elem()
}

// The parameters of `OptionManager.QueryOptions`.
type QueryOptionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Name string                 `xml:"name,omitempty" json:"name,omitempty"`
}

func init() {
	t["QueryOptionsRequestType"] = reflect.TypeOf((*QueryOptionsRequestType)(nil)).Elem()
}

type QueryOptionsResponse struct {
	Returnval []BaseOptionValue `xml:"returnval,omitempty,typeattr" json:"returnval,omitempty"`
}

type QueryPartitionCreateDesc QueryPartitionCreateDescRequestType

func init() {
	t["QueryPartitionCreateDesc"] = reflect.TypeOf((*QueryPartitionCreateDesc)(nil)).Elem()
}

// The parameters of `HostDiagnosticSystem.QueryPartitionCreateDesc`.
type QueryPartitionCreateDescRequestType struct {
	This           ManagedObjectReference `xml:"_this" json:"-"`
	DiskUuid       string                 `xml:"diskUuid" json:"diskUuid"`
	DiagnosticType string                 `xml:"diagnosticType" json:"diagnosticType"`
}

func init() {
	t["QueryPartitionCreateDescRequestType"] = reflect.TypeOf((*QueryPartitionCreateDescRequestType)(nil)).Elem()
}

type QueryPartitionCreateDescResponse struct {
	Returnval HostDiagnosticPartitionCreateDescription `xml:"returnval" json:"returnval"`
}

type QueryPartitionCreateOptions QueryPartitionCreateOptionsRequestType

func init() {
	t["QueryPartitionCreateOptions"] = reflect.TypeOf((*QueryPartitionCreateOptions)(nil)).Elem()
}

// The parameters of `HostDiagnosticSystem.QueryPartitionCreateOptions`.
type QueryPartitionCreateOptionsRequestType struct {
	This           ManagedObjectReference `xml:"_this" json:"-"`
	StorageType    string                 `xml:"storageType" json:"storageType"`
	DiagnosticType string                 `xml:"diagnosticType" json:"diagnosticType"`
}

func init() {
	t["QueryPartitionCreateOptionsRequestType"] = reflect.TypeOf((*QueryPartitionCreateOptionsRequestType)(nil)).Elem()
}

type QueryPartitionCreateOptionsResponse struct {
	Returnval []HostDiagnosticPartitionCreateOption `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryPathSelectionPolicyOptions QueryPathSelectionPolicyOptionsRequestType

func init() {
	t["QueryPathSelectionPolicyOptions"] = reflect.TypeOf((*QueryPathSelectionPolicyOptions)(nil)).Elem()
}

type QueryPathSelectionPolicyOptionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryPathSelectionPolicyOptionsRequestType"] = reflect.TypeOf((*QueryPathSelectionPolicyOptionsRequestType)(nil)).Elem()
}

type QueryPathSelectionPolicyOptionsResponse struct {
	Returnval []HostPathSelectionPolicyOption `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryPerf QueryPerfRequestType

func init() {
	t["QueryPerf"] = reflect.TypeOf((*QueryPerf)(nil)).Elem()
}

type QueryPerfComposite QueryPerfCompositeRequestType

func init() {
	t["QueryPerfComposite"] = reflect.TypeOf((*QueryPerfComposite)(nil)).Elem()
}

// The parameters of `PerformanceManager.QueryPerfComposite`.
type QueryPerfCompositeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A `PerfQuerySpec` object specifying the query
	// parameters. This `PerfQuerySpec` object specifies a
	// managed object for which composite statistics should be retrieved, with
	// specific optional criteria for filtering the results.
	//
	// This `PerfQuerySpec` requires a valid `PerfQuerySpec.metricId` property that specifies a metric
	// that is available, in common, to the entity and its children. If the
	// specified metricId is not available to the entity and its children, it is
	// ignored.
	QuerySpec PerfQuerySpec `xml:"querySpec" json:"querySpec"`
}

func init() {
	t["QueryPerfCompositeRequestType"] = reflect.TypeOf((*QueryPerfCompositeRequestType)(nil)).Elem()
}

type QueryPerfCompositeResponse struct {
	Returnval PerfCompositeMetric `xml:"returnval" json:"returnval"`
}

type QueryPerfCounter QueryPerfCounterRequestType

func init() {
	t["QueryPerfCounter"] = reflect.TypeOf((*QueryPerfCounter)(nil)).Elem()
}

type QueryPerfCounterByLevel QueryPerfCounterByLevelRequestType

func init() {
	t["QueryPerfCounterByLevel"] = reflect.TypeOf((*QueryPerfCounterByLevel)(nil)).Elem()
}

// The parameters of `PerformanceManager.QueryPerfCounterByLevel`.
type QueryPerfCounterByLevelRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A number between 1 and 4 that specifies the collection level.
	Level int32 `xml:"level" json:"level"`
}

func init() {
	t["QueryPerfCounterByLevelRequestType"] = reflect.TypeOf((*QueryPerfCounterByLevelRequestType)(nil)).Elem()
}

type QueryPerfCounterByLevelResponse struct {
	Returnval []PerfCounterInfo `xml:"returnval" json:"returnval"`
}

// The parameters of `PerformanceManager.QueryPerfCounter`.
type QueryPerfCounterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// An array of one or more `counterIds` representing performance counters for which information is
	// being retrieved.
	CounterId []int32 `xml:"counterId" json:"counterId"`
}

func init() {
	t["QueryPerfCounterRequestType"] = reflect.TypeOf((*QueryPerfCounterRequestType)(nil)).Elem()
}

type QueryPerfCounterResponse struct {
	Returnval []PerfCounterInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryPerfProviderSummary QueryPerfProviderSummaryRequestType

func init() {
	t["QueryPerfProviderSummary"] = reflect.TypeOf((*QueryPerfProviderSummary)(nil)).Elem()
}

// The parameters of `PerformanceManager.QueryPerfProviderSummary`.
type QueryPerfProviderSummaryRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Reference to a managed object that provides performance data. If the
	// entity specified by managed object reference is not a performance
	// provider, an "InvalidArgument" exception is thrown.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["QueryPerfProviderSummaryRequestType"] = reflect.TypeOf((*QueryPerfProviderSummaryRequestType)(nil)).Elem()
}

type QueryPerfProviderSummaryResponse struct {
	Returnval PerfProviderSummary `xml:"returnval" json:"returnval"`
}

// The parameters of `PerformanceManager.QueryPerf`.
type QueryPerfRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// An array of `PerfQuerySpec` objects. Each `PerfQuerySpec` object specifies a managed object reference
	// for an entity, plus optional criteria for filtering results. Only metrics
	// for entities that can be resolved and that are valid *performance providers* are returned in
	// any result.
	//
	// Each `PerfQuerySpec` object in the array
	// submitted in this operation can query for different metrics. Or, select
	// all types of statistics for a single managed entity.
	//
	// Raw data feed workaround: Normally, QueryPerf will return performance
	// statistics stored in the VirtualCenter database. However this may not be
	// suitable for certain applications. For example, applications that treat
	// VirtualCenter as a raw data source, query for performance statistics
	// regularly (say every 5 minutes) and extract the data for external
	// archival and reporting. Such applications need better query performance.
	// These applications should query statistics using QueryPerf for the base
	// historical interval (5 minutes by default) having a start and end time
	// range within 30 minutes from the current VirtualCenter server system
	// time. These QueryPerf calls will have better performance than other
	// QueryPerf calls.
	QuerySpec []PerfQuerySpec `xml:"querySpec" json:"querySpec"`
}

func init() {
	t["QueryPerfRequestType"] = reflect.TypeOf((*QueryPerfRequestType)(nil)).Elem()
}

type QueryPerfResponse struct {
	Returnval []BasePerfEntityMetricBase `xml:"returnval,omitempty,typeattr" json:"returnval,omitempty"`
}

type QueryPhysicalVsanDisks QueryPhysicalVsanDisksRequestType

func init() {
	t["QueryPhysicalVsanDisks"] = reflect.TypeOf((*QueryPhysicalVsanDisks)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.QueryPhysicalVsanDisks`.
type QueryPhysicalVsanDisksRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of properties to gather. Not specifying a list will
	// fetch all properties.
	Props []string `xml:"props,omitempty" json:"props,omitempty"`
}

func init() {
	t["QueryPhysicalVsanDisksRequestType"] = reflect.TypeOf((*QueryPhysicalVsanDisksRequestType)(nil)).Elem()
}

type QueryPhysicalVsanDisksResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type QueryPnicStatus QueryPnicStatusRequestType

func init() {
	t["QueryPnicStatus"] = reflect.TypeOf((*QueryPnicStatus)(nil)).Elem()
}

// The parameters of `IscsiManager.QueryPnicStatus`.
type QueryPnicStatusRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Physical NIC device name to check the status for
	PnicDevice string `xml:"pnicDevice" json:"pnicDevice"`
}

func init() {
	t["QueryPnicStatusRequestType"] = reflect.TypeOf((*QueryPnicStatusRequestType)(nil)).Elem()
}

type QueryPnicStatusResponse struct {
	Returnval IscsiStatus `xml:"returnval" json:"returnval"`
}

type QueryPolicyMetadata QueryPolicyMetadataRequestType

func init() {
	t["QueryPolicyMetadata"] = reflect.TypeOf((*QueryPolicyMetadata)(nil)).Elem()
}

// The parameters of `ProfileManager.QueryPolicyMetadata`.
type QueryPolicyMetadataRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Retrieve metadata for the specified policyNames.
	// If policyName is not specified, metadata for all policies will be returned.
	PolicyName []string `xml:"policyName,omitempty" json:"policyName,omitempty"`
	// Base profile whose context needs to be used during the operation
	//
	// Refers instance of `Profile`.
	Profile *ManagedObjectReference `xml:"profile,omitempty" json:"profile,omitempty"`
}

func init() {
	t["QueryPolicyMetadataRequestType"] = reflect.TypeOf((*QueryPolicyMetadataRequestType)(nil)).Elem()
}

type QueryPolicyMetadataResponse struct {
	Returnval []ProfilePolicyMetadata `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryProductLockerLocation QueryProductLockerLocationRequestType

func init() {
	t["QueryProductLockerLocation"] = reflect.TypeOf((*QueryProductLockerLocation)(nil)).Elem()
}

type QueryProductLockerLocationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryProductLockerLocationRequestType"] = reflect.TypeOf((*QueryProductLockerLocationRequestType)(nil)).Elem()
}

type QueryProductLockerLocationResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type QueryProfileStructure QueryProfileStructureRequestType

func init() {
	t["QueryProfileStructure"] = reflect.TypeOf((*QueryProfileStructure)(nil)).Elem()
}

// The parameters of `HostProfileManager.QueryProfileStructure`.
type QueryProfileStructureRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Base profile whose context needs to be used during the operation
	//
	// Refers instance of `Profile`.
	Profile *ManagedObjectReference `xml:"profile,omitempty" json:"profile,omitempty"`
}

func init() {
	t["QueryProfileStructureRequestType"] = reflect.TypeOf((*QueryProfileStructureRequestType)(nil)).Elem()
}

type QueryProfileStructureResponse struct {
	Returnval ProfileProfileStructure `xml:"returnval" json:"returnval"`
}

type QueryProviderList QueryProviderListRequestType

func init() {
	t["QueryProviderList"] = reflect.TypeOf((*QueryProviderList)(nil)).Elem()
}

type QueryProviderListRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryProviderListRequestType"] = reflect.TypeOf((*QueryProviderListRequestType)(nil)).Elem()
}

type QueryProviderListResponse struct {
	Returnval []string `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryProviderName QueryProviderNameRequestType

func init() {
	t["QueryProviderName"] = reflect.TypeOf((*QueryProviderName)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.QueryProviderName`.
type QueryProviderNameRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Id   string                 `xml:"id" json:"id"`
}

func init() {
	t["QueryProviderNameRequestType"] = reflect.TypeOf((*QueryProviderNameRequestType)(nil)).Elem()
}

type QueryProviderNameResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type QueryResourceConfigOption QueryResourceConfigOptionRequestType

func init() {
	t["QueryResourceConfigOption"] = reflect.TypeOf((*QueryResourceConfigOption)(nil)).Elem()
}

type QueryResourceConfigOptionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryResourceConfigOptionRequestType"] = reflect.TypeOf((*QueryResourceConfigOptionRequestType)(nil)).Elem()
}

type QueryResourceConfigOptionResponse struct {
	Returnval ResourceConfigOption `xml:"returnval" json:"returnval"`
}

type QueryServiceList QueryServiceListRequestType

func init() {
	t["QueryServiceList"] = reflect.TypeOf((*QueryServiceList)(nil)).Elem()
}

// The parameters of `ServiceManager.QueryServiceList`.
type QueryServiceListRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the service to be located.
	ServiceName string `xml:"serviceName,omitempty" json:"serviceName,omitempty"`
	// The list of location information that needs to match for a service to be
	// considered a match.
	Location []string `xml:"location,omitempty" json:"location,omitempty"`
}

func init() {
	t["QueryServiceListRequestType"] = reflect.TypeOf((*QueryServiceListRequestType)(nil)).Elem()
}

type QueryServiceListResponse struct {
	Returnval []ServiceManagerServiceInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryStorageArrayTypePolicyOptions QueryStorageArrayTypePolicyOptionsRequestType

func init() {
	t["QueryStorageArrayTypePolicyOptions"] = reflect.TypeOf((*QueryStorageArrayTypePolicyOptions)(nil)).Elem()
}

type QueryStorageArrayTypePolicyOptionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryStorageArrayTypePolicyOptionsRequestType"] = reflect.TypeOf((*QueryStorageArrayTypePolicyOptionsRequestType)(nil)).Elem()
}

type QueryStorageArrayTypePolicyOptionsResponse struct {
	Returnval []HostStorageArrayTypePolicyOption `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QuerySupportedFeatures QuerySupportedFeaturesRequestType

func init() {
	t["QuerySupportedFeatures"] = reflect.TypeOf((*QuerySupportedFeatures)(nil)).Elem()
}

// The parameters of `LicenseManager.QuerySupportedFeatures`.
type QuerySupportedFeaturesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Use the license source of the specified host.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["QuerySupportedFeaturesRequestType"] = reflect.TypeOf((*QuerySupportedFeaturesRequestType)(nil)).Elem()
}

type QuerySupportedFeaturesResponse struct {
	Returnval []LicenseFeatureInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QuerySupportedNetworkOffloadSpec QuerySupportedNetworkOffloadSpecRequestType

func init() {
	t["QuerySupportedNetworkOffloadSpec"] = reflect.TypeOf((*QuerySupportedNetworkOffloadSpec)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitchManager.QuerySupportedNetworkOffloadSpec`.
type QuerySupportedNetworkOffloadSpecRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The productSpec of a
	// `DistributedVirtualSwitch`.
	SwitchProductSpec DistributedVirtualSwitchProductSpec `xml:"switchProductSpec" json:"switchProductSpec"`
}

func init() {
	t["QuerySupportedNetworkOffloadSpecRequestType"] = reflect.TypeOf((*QuerySupportedNetworkOffloadSpecRequestType)(nil)).Elem()
	minAPIVersionForType["QuerySupportedNetworkOffloadSpecRequestType"] = "8.0.0.1"
}

type QuerySupportedNetworkOffloadSpecResponse struct {
	Returnval []DistributedVirtualSwitchNetworkOffloadSpec `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QuerySyncingVsanObjects QuerySyncingVsanObjectsRequestType

func init() {
	t["QuerySyncingVsanObjects"] = reflect.TypeOf((*QuerySyncingVsanObjects)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.QuerySyncingVsanObjects`.
type QuerySyncingVsanObjectsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of VSAN/DOM object UUIDs to restrict search to.
	Uuids []string `xml:"uuids,omitempty" json:"uuids,omitempty"`
}

func init() {
	t["QuerySyncingVsanObjectsRequestType"] = reflect.TypeOf((*QuerySyncingVsanObjectsRequestType)(nil)).Elem()
}

type QuerySyncingVsanObjectsResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type QuerySystemUsers QuerySystemUsersRequestType

func init() {
	t["QuerySystemUsers"] = reflect.TypeOf((*QuerySystemUsers)(nil)).Elem()
}

type QuerySystemUsersRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QuerySystemUsersRequestType"] = reflect.TypeOf((*QuerySystemUsersRequestType)(nil)).Elem()
}

type QuerySystemUsersResponse struct {
	Returnval []string `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryTargetCapabilities QueryTargetCapabilitiesRequestType

func init() {
	t["QueryTargetCapabilities"] = reflect.TypeOf((*QueryTargetCapabilities)(nil)).Elem()
}

// The parameters of `EnvironmentBrowser.QueryTargetCapabilities`.
type QueryTargetCapabilitiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If specified, the host whose capabilities are requested.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["QueryTargetCapabilitiesRequestType"] = reflect.TypeOf((*QueryTargetCapabilitiesRequestType)(nil)).Elem()
}

type QueryTargetCapabilitiesResponse struct {
	Returnval *HostCapability `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryTpmAttestationReport QueryTpmAttestationReportRequestType

func init() {
	t["QueryTpmAttestationReport"] = reflect.TypeOf((*QueryTpmAttestationReport)(nil)).Elem()
}

type QueryTpmAttestationReportRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryTpmAttestationReportRequestType"] = reflect.TypeOf((*QueryTpmAttestationReportRequestType)(nil)).Elem()
}

type QueryTpmAttestationReportResponse struct {
	Returnval *HostTpmAttestationReport `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryUnmonitoredHosts QueryUnmonitoredHostsRequestType

func init() {
	t["QueryUnmonitoredHosts"] = reflect.TypeOf((*QueryUnmonitoredHosts)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.QueryUnmonitoredHosts`.
type QueryUnmonitoredHostsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The provider id.
	ProviderId string `xml:"providerId" json:"providerId"`
	// The cluster.
	//
	// Refers instance of `ClusterComputeResource`.
	Cluster ManagedObjectReference `xml:"cluster" json:"cluster"`
}

func init() {
	t["QueryUnmonitoredHostsRequestType"] = reflect.TypeOf((*QueryUnmonitoredHostsRequestType)(nil)).Elem()
}

type QueryUnmonitoredHostsResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryUnownedFiles QueryUnownedFilesRequestType

func init() {
	t["QueryUnownedFiles"] = reflect.TypeOf((*QueryUnownedFiles)(nil)).Elem()
}

type QueryUnownedFilesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryUnownedFilesRequestType"] = reflect.TypeOf((*QueryUnownedFilesRequestType)(nil)).Elem()
}

type QueryUnownedFilesResponse struct {
	Returnval []string `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryUnresolvedVmfsVolume QueryUnresolvedVmfsVolumeRequestType

func init() {
	t["QueryUnresolvedVmfsVolume"] = reflect.TypeOf((*QueryUnresolvedVmfsVolume)(nil)).Elem()
}

type QueryUnresolvedVmfsVolumeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryUnresolvedVmfsVolumeRequestType"] = reflect.TypeOf((*QueryUnresolvedVmfsVolumeRequestType)(nil)).Elem()
}

type QueryUnresolvedVmfsVolumeResponse struct {
	Returnval []HostUnresolvedVmfsVolume `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryUnresolvedVmfsVolumes QueryUnresolvedVmfsVolumesRequestType

func init() {
	t["QueryUnresolvedVmfsVolumes"] = reflect.TypeOf((*QueryUnresolvedVmfsVolumes)(nil)).Elem()
}

type QueryUnresolvedVmfsVolumesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryUnresolvedVmfsVolumesRequestType"] = reflect.TypeOf((*QueryUnresolvedVmfsVolumesRequestType)(nil)).Elem()
}

type QueryUnresolvedVmfsVolumesResponse struct {
	Returnval []HostUnresolvedVmfsVolume `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryUsedVlanIdInDvs QueryUsedVlanIdInDvsRequestType

func init() {
	t["QueryUsedVlanIdInDvs"] = reflect.TypeOf((*QueryUsedVlanIdInDvs)(nil)).Elem()
}

type QueryUsedVlanIdInDvsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryUsedVlanIdInDvsRequestType"] = reflect.TypeOf((*QueryUsedVlanIdInDvsRequestType)(nil)).Elem()
}

type QueryUsedVlanIdInDvsResponse struct {
	Returnval []int32 `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryVMotionCompatibility QueryVMotionCompatibilityRequestType

func init() {
	t["QueryVMotionCompatibility"] = reflect.TypeOf((*QueryVMotionCompatibility)(nil)).Elem()
}

// The parameters of `VirtualMachineProvisioningChecker.QueryVMotionCompatibilityEx_Task`.
type QueryVMotionCompatibilityExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The set of virtual machines to analyze for compatibility. All
	// virtual machines are assumed to be powered-on for the purposes of
	// this operation.
	//
	// Refers instances of `VirtualMachine`.
	Vm []ManagedObjectReference `xml:"vm" json:"vm"`
	// The set of hosts to analyze for compatibility. All hosts
	// are assumed to be connected and not in maintenance mode for the
	// purposes of this operation.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["QueryVMotionCompatibilityExRequestType"] = reflect.TypeOf((*QueryVMotionCompatibilityExRequestType)(nil)).Elem()
}

type QueryVMotionCompatibilityEx_Task QueryVMotionCompatibilityExRequestType

func init() {
	t["QueryVMotionCompatibilityEx_Task"] = reflect.TypeOf((*QueryVMotionCompatibilityEx_Task)(nil)).Elem()
}

type QueryVMotionCompatibilityEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `ServiceInstance.QueryVMotionCompatibility`.
type QueryVMotionCompatibilityRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The virtual machine that is the designated VMotion candidate.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The group of hosts to analyze for compatibility.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host" json:"host"`
	// The set of compatibility types to investigate.
	// Each is a string chosen from VMotionCompatibilityType. If this
	// argument is not set, then all compatibility types are
	// investigated.
	Compatibility []string `xml:"compatibility,omitempty" json:"compatibility,omitempty"`
}

func init() {
	t["QueryVMotionCompatibilityRequestType"] = reflect.TypeOf((*QueryVMotionCompatibilityRequestType)(nil)).Elem()
}

type QueryVMotionCompatibilityResponse struct {
	Returnval []HostVMotionCompatibility `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryVirtualDiskFragmentation QueryVirtualDiskFragmentationRequestType

func init() {
	t["QueryVirtualDiskFragmentation"] = reflect.TypeOf((*QueryVirtualDiskFragmentation)(nil)).Elem()
}

// The parameters of `VirtualDiskManager.QueryVirtualDiskFragmentation`.
type QueryVirtualDiskFragmentationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk for which to return the
	// percentage of fragmentation.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
}

func init() {
	t["QueryVirtualDiskFragmentationRequestType"] = reflect.TypeOf((*QueryVirtualDiskFragmentationRequestType)(nil)).Elem()
}

type QueryVirtualDiskFragmentationResponse struct {
	Returnval int32 `xml:"returnval" json:"returnval"`
}

type QueryVirtualDiskGeometry QueryVirtualDiskGeometryRequestType

func init() {
	t["QueryVirtualDiskGeometry"] = reflect.TypeOf((*QueryVirtualDiskGeometry)(nil)).Elem()
}

// The parameters of `VirtualDiskManager.QueryVirtualDiskGeometry`.
type QueryVirtualDiskGeometryRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk from which to get geometry information.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
}

func init() {
	t["QueryVirtualDiskGeometryRequestType"] = reflect.TypeOf((*QueryVirtualDiskGeometryRequestType)(nil)).Elem()
}

type QueryVirtualDiskGeometryResponse struct {
	Returnval HostDiskDimensionsChs `xml:"returnval" json:"returnval"`
}

type QueryVirtualDiskUuid QueryVirtualDiskUuidRequestType

func init() {
	t["QueryVirtualDiskUuid"] = reflect.TypeOf((*QueryVirtualDiskUuid)(nil)).Elem()
}

type QueryVirtualDiskUuidEx QueryVirtualDiskUuidExRequestType

func init() {
	t["QueryVirtualDiskUuidEx"] = reflect.TypeOf((*QueryVirtualDiskUuidEx)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.QueryVirtualDiskUuidEx`.
type QueryVirtualDiskUuidExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk whose uuid for the DDB entry needs to be queried.
	// A datastore path has the form
	// > \[_datastore_\] _path_
	//
	// where
	//   - _datastore_ is the datastore name.
	//   - _path_ is a slash-delimited path from the root of the datastore.
	//
	// An example datastore path is "\[storage\] path/to/file.extension".
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path is mandatory. Not needed when invoked directly on ESX.
	// If not specified on a call from VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
}

func init() {
	t["QueryVirtualDiskUuidExRequestType"] = reflect.TypeOf((*QueryVirtualDiskUuidExRequestType)(nil)).Elem()
	minAPIVersionForType["QueryVirtualDiskUuidExRequestType"] = "8.0.3.0"
}

type QueryVirtualDiskUuidExResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualDiskManager.QueryVirtualDiskUuid`.
type QueryVirtualDiskUuidRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk from which to get SCSI inquiry
	// page 0x83 data.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
}

func init() {
	t["QueryVirtualDiskUuidRequestType"] = reflect.TypeOf((*QueryVirtualDiskUuidRequestType)(nil)).Elem()
}

type QueryVirtualDiskUuidResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type QueryVmfsConfigOption QueryVmfsConfigOptionRequestType

func init() {
	t["QueryVmfsConfigOption"] = reflect.TypeOf((*QueryVmfsConfigOption)(nil)).Elem()
}

type QueryVmfsConfigOptionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["QueryVmfsConfigOptionRequestType"] = reflect.TypeOf((*QueryVmfsConfigOptionRequestType)(nil)).Elem()
}

type QueryVmfsConfigOptionResponse struct {
	Returnval []VmfsConfigOption `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryVmfsDatastoreCreateOptions QueryVmfsDatastoreCreateOptionsRequestType

func init() {
	t["QueryVmfsDatastoreCreateOptions"] = reflect.TypeOf((*QueryVmfsDatastoreCreateOptions)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.QueryVmfsDatastoreCreateOptions`.
type QueryVmfsDatastoreCreateOptionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The devicePath of the disk on which datastore creation
	// options are generated.
	DevicePath string `xml:"devicePath" json:"devicePath"`
	// major version of VMFS to be used for
	// formatting the datastore. If this
	// parameter is not specified, then the highest
	// *supported VMFS major version* for the host
	// is used.
	VmfsMajorVersion int32 `xml:"vmfsMajorVersion,omitempty" json:"vmfsMajorVersion,omitempty"`
}

func init() {
	t["QueryVmfsDatastoreCreateOptionsRequestType"] = reflect.TypeOf((*QueryVmfsDatastoreCreateOptionsRequestType)(nil)).Elem()
}

type QueryVmfsDatastoreCreateOptionsResponse struct {
	Returnval []VmfsDatastoreOption `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryVmfsDatastoreExpandOptions QueryVmfsDatastoreExpandOptionsRequestType

func init() {
	t["QueryVmfsDatastoreExpandOptions"] = reflect.TypeOf((*QueryVmfsDatastoreExpandOptions)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.QueryVmfsDatastoreExpandOptions`.
type QueryVmfsDatastoreExpandOptionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datastore to be expanded.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["QueryVmfsDatastoreExpandOptionsRequestType"] = reflect.TypeOf((*QueryVmfsDatastoreExpandOptionsRequestType)(nil)).Elem()
}

type QueryVmfsDatastoreExpandOptionsResponse struct {
	Returnval []VmfsDatastoreOption `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryVmfsDatastoreExtendOptions QueryVmfsDatastoreExtendOptionsRequestType

func init() {
	t["QueryVmfsDatastoreExtendOptions"] = reflect.TypeOf((*QueryVmfsDatastoreExtendOptions)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.QueryVmfsDatastoreExtendOptions`.
type QueryVmfsDatastoreExtendOptionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datastore to be extended.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The devicePath of the disk on which datastore extension
	// options are generated.
	DevicePath string `xml:"devicePath" json:"devicePath"`
	// Indicates whether to exclude options that can be
	// used for extent expansion also.
	// Free space can be used for adding an extent or expanding an existing
	// extent. If this parameter is set to true, the list of options
	// returned will not include free space that can be used for expansion.
	SuppressExpandCandidates *bool `xml:"suppressExpandCandidates" json:"suppressExpandCandidates,omitempty"`
}

func init() {
	t["QueryVmfsDatastoreExtendOptionsRequestType"] = reflect.TypeOf((*QueryVmfsDatastoreExtendOptionsRequestType)(nil)).Elem()
}

type QueryVmfsDatastoreExtendOptionsResponse struct {
	Returnval []VmfsDatastoreOption `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryVnicStatus QueryVnicStatusRequestType

func init() {
	t["QueryVnicStatus"] = reflect.TypeOf((*QueryVnicStatus)(nil)).Elem()
}

// The parameters of `IscsiManager.QueryVnicStatus`.
type QueryVnicStatusRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual NIC device to check the status for
	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
}

func init() {
	t["QueryVnicStatusRequestType"] = reflect.TypeOf((*QueryVnicStatusRequestType)(nil)).Elem()
}

type QueryVnicStatusResponse struct {
	Returnval IscsiStatus `xml:"returnval" json:"returnval"`
}

type QueryVsanObjectUuidsByFilter QueryVsanObjectUuidsByFilterRequestType

func init() {
	t["QueryVsanObjectUuidsByFilter"] = reflect.TypeOf((*QueryVsanObjectUuidsByFilter)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.QueryVsanObjectUuidsByFilter`.
type QueryVsanObjectUuidsByFilterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Objects UUID will be checked against the filtering
	// conditions.
	Uuids []string `xml:"uuids,omitempty" json:"uuids,omitempty"`
	// To limit the size of the result set.
	Limit *int32 `xml:"limit" json:"limit,omitempty"`
	// Filtering condition 1: object version.
	Version int32 `xml:"version,omitempty" json:"version,omitempty"`
}

func init() {
	t["QueryVsanObjectUuidsByFilterRequestType"] = reflect.TypeOf((*QueryVsanObjectUuidsByFilterRequestType)(nil)).Elem()
}

type QueryVsanObjectUuidsByFilterResponse struct {
	Returnval []string `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type QueryVsanObjects QueryVsanObjectsRequestType

func init() {
	t["QueryVsanObjects"] = reflect.TypeOf((*QueryVsanObjects)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.QueryVsanObjects`.
type QueryVsanObjectsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of VSAN/DOM object UUIDs.
	Uuids []string `xml:"uuids,omitempty" json:"uuids,omitempty"`
}

func init() {
	t["QueryVsanObjectsRequestType"] = reflect.TypeOf((*QueryVsanObjectsRequestType)(nil)).Elem()
}

type QueryVsanObjectsResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type QueryVsanStatistics QueryVsanStatisticsRequestType

func init() {
	t["QueryVsanStatistics"] = reflect.TypeOf((*QueryVsanStatistics)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.QueryVsanStatistics`.
type QueryVsanStatisticsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of labels of counters to retrieve.
	Labels []string `xml:"labels" json:"labels"`
}

func init() {
	t["QueryVsanStatisticsRequestType"] = reflect.TypeOf((*QueryVsanStatisticsRequestType)(nil)).Elem()
}

type QueryVsanStatisticsResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type QueryVsanUpgradeStatus QueryVsanUpgradeStatusRequestType

func init() {
	t["QueryVsanUpgradeStatus"] = reflect.TypeOf((*QueryVsanUpgradeStatus)(nil)).Elem()
}

// The parameters of `VsanUpgradeSystem.QueryVsanUpgradeStatus`.
type QueryVsanUpgradeStatusRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The cluster for which to retrieve the upgrade status.
	//
	// Refers instance of `ClusterComputeResource`.
	Cluster ManagedObjectReference `xml:"cluster" json:"cluster"`
}

func init() {
	t["QueryVsanUpgradeStatusRequestType"] = reflect.TypeOf((*QueryVsanUpgradeStatusRequestType)(nil)).Elem()
}

type QueryVsanUpgradeStatusResponse struct {
	Returnval VsanUpgradeSystemUpgradeStatus `xml:"returnval" json:"returnval"`
}

// Thrown when an operation cannot be performed on a virtual machine
// because it has a pending question requiring user input.
type QuestionPending struct {
	InvalidState

	// Text of the question from the virtual machine.
	Text string `xml:"text" json:"text"`
}

func init() {
	t["QuestionPending"] = reflect.TypeOf((*QuestionPending)(nil)).Elem()
}

type QuestionPendingFault QuestionPending

func init() {
	t["QuestionPendingFault"] = reflect.TypeOf((*QuestionPendingFault)(nil)).Elem()
}

// A QuiesceDatastoreIOForHAFailed fault occurs when the HA agent on a host
// cannot quiesce file activity on a datastore to be unmouonted or removed.
type QuiesceDatastoreIOForHAFailed struct {
	ResourceInUse

	// The host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Name of the host.
	HostName string `xml:"hostName" json:"hostName"`
	// The datastore.
	//
	// Refers instance of `Datastore`.
	Ds ManagedObjectReference `xml:"ds" json:"ds"`
	// Name of the datastore.
	DsName string `xml:"dsName" json:"dsName"`
}

func init() {
	t["QuiesceDatastoreIOForHAFailed"] = reflect.TypeOf((*QuiesceDatastoreIOForHAFailed)(nil)).Elem()
}

type QuiesceDatastoreIOForHAFailedFault QuiesceDatastoreIOForHAFailed

func init() {
	t["QuiesceDatastoreIOForHAFailedFault"] = reflect.TypeOf((*QuiesceDatastoreIOForHAFailedFault)(nil)).Elem()
}

// The virtual machine is using an RDM device with compatibility
// mode set to 'physicalMode' and operation is unable to convert
// the disk to a different type.
type RDMConversionNotSupported struct {
	MigrationFault

	// The name of the disk device using the RDM.
	Device string `xml:"device" json:"device"`
}

func init() {
	t["RDMConversionNotSupported"] = reflect.TypeOf((*RDMConversionNotSupported)(nil)).Elem()
}

type RDMConversionNotSupportedFault RDMConversionNotSupported

func init() {
	t["RDMConversionNotSupportedFault"] = reflect.TypeOf((*RDMConversionNotSupportedFault)(nil)).Elem()
}

// The virtual machine is configured with a Raw Disk Mapping.
//
// The host only supports Raw
// Disk Mappings in a limited fashion. After the migration, the RDM will function correctly,
// but it will be indistinguishable from a virtual disk when viewing the virtual machine's
// properties. This change will persist even if the virtual machine is migrated
// back to a host with full RDM support.
//
// This is a warning only for migrations to ESX 2.1.x hosts.
type RDMNotPreserved struct {
	MigrationFault

	// The name of the disk device using the RDM.
	Device string `xml:"device" json:"device"`
}

func init() {
	t["RDMNotPreserved"] = reflect.TypeOf((*RDMNotPreserved)(nil)).Elem()
}

type RDMNotPreservedFault RDMNotPreserved

func init() {
	t["RDMNotPreservedFault"] = reflect.TypeOf((*RDMNotPreservedFault)(nil)).Elem()
}

// The virtual machine is configured with a Raw Disk Mapping.
//
// This is not
// supported on the host.
type RDMNotSupported struct {
	DeviceNotSupported
}

func init() {
	t["RDMNotSupported"] = reflect.TypeOf((*RDMNotSupported)(nil)).Elem()
}

type RDMNotSupportedFault BaseRDMNotSupported

func init() {
	t["RDMNotSupportedFault"] = reflect.TypeOf((*RDMNotSupportedFault)(nil)).Elem()
}

// The virtual machine is configured with a Raw Disk Mapping.
//
// This is not
// supported on the datastore.
type RDMNotSupportedOnDatastore struct {
	VmConfigFault

	// The label of the RDM device that would have its backing placed on
	// the datastore.
	//
	// This is not guaranteed to be the only such device.
	Device string `xml:"device" json:"device"`
	// The datastore.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The name of the datastore.
	DatastoreName string `xml:"datastoreName" json:"datastoreName"`
}

func init() {
	t["RDMNotSupportedOnDatastore"] = reflect.TypeOf((*RDMNotSupportedOnDatastore)(nil)).Elem()
}

type RDMNotSupportedOnDatastoreFault RDMNotSupportedOnDatastore

func init() {
	t["RDMNotSupportedOnDatastoreFault"] = reflect.TypeOf((*RDMNotSupportedOnDatastoreFault)(nil)).Elem()
}

// One of the virtual machine's virtual disks is a Raw Disk Mapping
// that is itself accessible, but points to a LUN that is inaccessible.
type RDMPointsToInaccessibleDisk struct {
	CannotAccessVmDisk
}

func init() {
	t["RDMPointsToInaccessibleDisk"] = reflect.TypeOf((*RDMPointsToInaccessibleDisk)(nil)).Elem()
}

type RDMPointsToInaccessibleDiskFault RDMPointsToInaccessibleDisk

func init() {
	t["RDMPointsToInaccessibleDiskFault"] = reflect.TypeOf((*RDMPointsToInaccessibleDiskFault)(nil)).Elem()
}

// The virtual machine has a raw disk attached that is not supported.
//
// This is often
// used as a subfault for DisallowedMigrationDeviceAttached or
// DisallowedSnapshotDeviceAttached.
type RawDiskNotSupported struct {
	DeviceNotSupported
}

func init() {
	t["RawDiskNotSupported"] = reflect.TypeOf((*RawDiskNotSupported)(nil)).Elem()
}

type RawDiskNotSupportedFault RawDiskNotSupported

func init() {
	t["RawDiskNotSupportedFault"] = reflect.TypeOf((*RawDiskNotSupportedFault)(nil)).Elem()
}

type ReadEnvironmentVariableInGuest ReadEnvironmentVariableInGuestRequestType

func init() {
	t["ReadEnvironmentVariableInGuest"] = reflect.TypeOf((*ReadEnvironmentVariableInGuest)(nil)).Elem()
}

// The parameters of `GuestProcessManager.ReadEnvironmentVariableInGuest`.
type ReadEnvironmentVariableInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Query
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The names of the variables to be read. If not set, then
	// all the environment variables are returned.
	Names []string `xml:"names,omitempty" json:"names,omitempty"`
}

func init() {
	t["ReadEnvironmentVariableInGuestRequestType"] = reflect.TypeOf((*ReadEnvironmentVariableInGuestRequestType)(nil)).Elem()
}

type ReadEnvironmentVariableInGuestResponse struct {
	Returnval []string `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// Fault thrown on host connect if we were unable to correctly read the
// existing tree on the root.
//
// This is bad because then we don't know the
// available resources on the host, and all kinds of admission control will
// fail.
// This just allows for more robust error handling - we should be able to
// read the existing hierarchy under normal conditions.
type ReadHostResourcePoolTreeFailed struct {
	HostConnectFault
}

func init() {
	t["ReadHostResourcePoolTreeFailed"] = reflect.TypeOf((*ReadHostResourcePoolTreeFailed)(nil)).Elem()
}

type ReadHostResourcePoolTreeFailedFault ReadHostResourcePoolTreeFailed

func init() {
	t["ReadHostResourcePoolTreeFailedFault"] = reflect.TypeOf((*ReadHostResourcePoolTreeFailedFault)(nil)).Elem()
}

type ReadNextEvents ReadNextEventsRequestType

func init() {
	t["ReadNextEvents"] = reflect.TypeOf((*ReadNextEvents)(nil)).Elem()
}

// The parameters of `EventHistoryCollector.ReadNextEvents`.
type ReadNextEventsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The maximum number of items in the page.
	MaxCount int32 `xml:"maxCount" json:"maxCount"`
}

func init() {
	t["ReadNextEventsRequestType"] = reflect.TypeOf((*ReadNextEventsRequestType)(nil)).Elem()
}

type ReadNextEventsResponse struct {
	Returnval []BaseEvent `xml:"returnval,omitempty,typeattr" json:"returnval,omitempty"`
}

type ReadNextTasks ReadNextTasksRequestType

func init() {
	t["ReadNextTasks"] = reflect.TypeOf((*ReadNextTasks)(nil)).Elem()
}

// The parameters of `TaskHistoryCollector.ReadNextTasks`.
type ReadNextTasksRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The maximum number of items in the page.
	MaxCount int32 `xml:"maxCount" json:"maxCount"`
}

func init() {
	t["ReadNextTasksRequestType"] = reflect.TypeOf((*ReadNextTasksRequestType)(nil)).Elem()
}

type ReadNextTasksResponse struct {
	Returnval []TaskInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The virtual machine uses read-only (undoable or nonpersistent) disks that
// can cause a slower power on at the migration destination.
//
// As a result, VMtion
// could slow down considerably or timeout. This is an issue only for migration of
// powered-on virtual machines from an ESX host with version greater
// than 2.0.x to an ESX host with version 2.0.x. It will be an error if the
// number of such disks is great enough to cause timeout ( &ge; 3 ), or a warning
// otherwise.
type ReadOnlyDisksWithLegacyDestination struct {
	MigrationFault

	// The number of read-only disks in use.
	RoDiskCount int32 `xml:"roDiskCount" json:"roDiskCount"`
	// Whether this number of disks will cause a timeout failure.
	TimeoutDanger bool `xml:"timeoutDanger" json:"timeoutDanger"`
}

func init() {
	t["ReadOnlyDisksWithLegacyDestination"] = reflect.TypeOf((*ReadOnlyDisksWithLegacyDestination)(nil)).Elem()
}

type ReadOnlyDisksWithLegacyDestinationFault ReadOnlyDisksWithLegacyDestination

func init() {
	t["ReadOnlyDisksWithLegacyDestinationFault"] = reflect.TypeOf((*ReadOnlyDisksWithLegacyDestinationFault)(nil)).Elem()
}

type ReadPreviousEvents ReadPreviousEventsRequestType

func init() {
	t["ReadPreviousEvents"] = reflect.TypeOf((*ReadPreviousEvents)(nil)).Elem()
}

// The parameters of `EventHistoryCollector.ReadPreviousEvents`.
type ReadPreviousEventsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The maximum number of items in the page.
	MaxCount int32 `xml:"maxCount" json:"maxCount"`
}

func init() {
	t["ReadPreviousEventsRequestType"] = reflect.TypeOf((*ReadPreviousEventsRequestType)(nil)).Elem()
}

type ReadPreviousEventsResponse struct {
	Returnval []BaseEvent `xml:"returnval,omitempty,typeattr" json:"returnval,omitempty"`
}

type ReadPreviousTasks ReadPreviousTasksRequestType

func init() {
	t["ReadPreviousTasks"] = reflect.TypeOf((*ReadPreviousTasks)(nil)).Elem()
}

// The parameters of `TaskHistoryCollector.ReadPreviousTasks`.
type ReadPreviousTasksRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The maximum number of items in the page.
	MaxCount int32 `xml:"maxCount" json:"maxCount"`
}

func init() {
	t["ReadPreviousTasksRequestType"] = reflect.TypeOf((*ReadPreviousTasksRequestType)(nil)).Elem()
}

type ReadPreviousTasksResponse struct {
	Returnval []TaskInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RebootGuest RebootGuestRequestType

func init() {
	t["RebootGuest"] = reflect.TypeOf((*RebootGuest)(nil)).Elem()
}

type RebootGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RebootGuestRequestType"] = reflect.TypeOf((*RebootGuestRequestType)(nil)).Elem()
}

type RebootGuestResponse struct {
}

// The parameters of `HostSystem.RebootHost_Task`.
type RebootHostRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Flag to specify whether or not the host should be rebooted
	// regardless of whether it is in maintenance mode. If true, the host
	// is rebooted, even if there are virtual machines running or other
	// operations in progress.
	Force bool `xml:"force" json:"force"`
}

func init() {
	t["RebootHostRequestType"] = reflect.TypeOf((*RebootHostRequestType)(nil)).Elem()
}

type RebootHost_Task RebootHostRequestType

func init() {
	t["RebootHost_Task"] = reflect.TypeOf((*RebootHost_Task)(nil)).Elem()
}

type RebootHost_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This fault is thrown if a patch install fails because an installed
// nonchainable patch has not taken effect.
type RebootRequired struct {
	VimFault

	// The nonchainable patch installed.
	Patch string `xml:"patch,omitempty" json:"patch,omitempty"`
}

func init() {
	t["RebootRequired"] = reflect.TypeOf((*RebootRequired)(nil)).Elem()
}

type RebootRequiredFault RebootRequired

func init() {
	t["RebootRequiredFault"] = reflect.TypeOf((*RebootRequiredFault)(nil)).Elem()
}

type RecommendDatastores RecommendDatastoresRequestType

func init() {
	t["RecommendDatastores"] = reflect.TypeOf((*RecommendDatastores)(nil)).Elem()
}

// The parameters of `StorageResourceManager.RecommendDatastores`.
type RecommendDatastoresRequestType struct {
	This        ManagedObjectReference `xml:"_this" json:"-"`
	StorageSpec StoragePlacementSpec   `xml:"storageSpec" json:"storageSpec"`
}

func init() {
	t["RecommendDatastoresRequestType"] = reflect.TypeOf((*RecommendDatastoresRequestType)(nil)).Elem()
}

type RecommendDatastoresResponse struct {
	Returnval StoragePlacementResult `xml:"returnval" json:"returnval"`
}

type RecommendHostsForVm RecommendHostsForVmRequestType

func init() {
	t["RecommendHostsForVm"] = reflect.TypeOf((*RecommendHostsForVm)(nil)).Elem()
}

// The parameters of `ClusterComputeResource.RecommendHostsForVm`.
type RecommendHostsForVmRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specifies the virtual machine for which the user is requesting a
	// recommendations.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Specifies the ResourcePool into which the virtual machine is to be
	// migrated. If the virtual machine is powered-on, this argument must be
	// specified and it is relevant only when the virtual machine is
	// powered-on. This ResourcePool cannot be in the same cluster as the
	// virtual machine.
	//
	// Refers instance of `ResourcePool`.
	Pool *ManagedObjectReference `xml:"pool,omitempty" json:"pool,omitempty"`
}

func init() {
	t["RecommendHostsForVmRequestType"] = reflect.TypeOf((*RecommendHostsForVmRequestType)(nil)).Elem()
}

type RecommendHostsForVmResponse struct {
	Returnval []ClusterHostRecommendation `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RecommissionVsanNodeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RecommissionVsanNodeRequestType"] = reflect.TypeOf((*RecommissionVsanNodeRequestType)(nil)).Elem()
}

type RecommissionVsanNode_Task RecommissionVsanNodeRequestType

func init() {
	t["RecommissionVsanNode_Task"] = reflect.TypeOf((*RecommissionVsanNode_Task)(nil)).Elem()
}

type RecommissionVsanNode_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VcenterVStorageObjectManager.ReconcileDatastoreInventory_Task`.
type ReconcileDatastoreInventoryRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datastore that needs to be reconciled.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["ReconcileDatastoreInventoryRequestType"] = reflect.TypeOf((*ReconcileDatastoreInventoryRequestType)(nil)).Elem()
}

type ReconcileDatastoreInventory_Task ReconcileDatastoreInventoryRequestType

func init() {
	t["ReconcileDatastoreInventory_Task"] = reflect.TypeOf((*ReconcileDatastoreInventory_Task)(nil)).Elem()
}

type ReconcileDatastoreInventory_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.ReconfigVM_Task`.
type ReconfigVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The new configuration values.
	Spec VirtualMachineConfigSpec `xml:"spec" json:"spec"`
}

func init() {
	t["ReconfigVMRequestType"] = reflect.TypeOf((*ReconfigVMRequestType)(nil)).Elem()
}

type ReconfigVM_Task ReconfigVMRequestType

func init() {
	t["ReconfigVM_Task"] = reflect.TypeOf((*ReconfigVM_Task)(nil)).Elem()
}

type ReconfigVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ReconfigurationSatisfiable ReconfigurationSatisfiableRequestType

func init() {
	t["ReconfigurationSatisfiable"] = reflect.TypeOf((*ReconfigurationSatisfiable)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.ReconfigurationSatisfiable`.
type ReconfigurationSatisfiableRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of PolicyChangeBatch structure with uuids and policies.
	Pcbs []VsanPolicyChangeBatch `xml:"pcbs" json:"pcbs"`
	// Optionally populate PolicyCost even though
	// object cannot be reconfigured in the current cluster topology.
	IgnoreSatisfiability *bool `xml:"ignoreSatisfiability" json:"ignoreSatisfiability,omitempty"`
}

func init() {
	t["ReconfigurationSatisfiableRequestType"] = reflect.TypeOf((*ReconfigurationSatisfiableRequestType)(nil)).Elem()
}

type ReconfigurationSatisfiableResponse struct {
	Returnval []VsanPolicySatisfiability `xml:"returnval" json:"returnval"`
}

type ReconfigureAlarm ReconfigureAlarmRequestType

func init() {
	t["ReconfigureAlarm"] = reflect.TypeOf((*ReconfigureAlarm)(nil)).Elem()
}

// The parameters of `Alarm.ReconfigureAlarm`.
type ReconfigureAlarmRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The new specification for the alarm.
	Spec BaseAlarmSpec `xml:"spec,typeattr" json:"spec"`
}

func init() {
	t["ReconfigureAlarmRequestType"] = reflect.TypeOf((*ReconfigureAlarmRequestType)(nil)).Elem()
}

type ReconfigureAlarmResponse struct {
}

type ReconfigureAutostart ReconfigureAutostartRequestType

func init() {
	t["ReconfigureAutostart"] = reflect.TypeOf((*ReconfigureAutostart)(nil)).Elem()
}

// The parameters of `HostAutoStartManager.ReconfigureAutostart`.
type ReconfigureAutostartRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of changes to defaults and auto-start/auto-stop order.
	Spec HostAutoStartManagerConfig `xml:"spec" json:"spec"`
}

func init() {
	t["ReconfigureAutostartRequestType"] = reflect.TypeOf((*ReconfigureAutostartRequestType)(nil)).Elem()
}

type ReconfigureAutostartResponse struct {
}

// The parameters of `ClusterComputeResource.ReconfigureCluster_Task`.
type ReconfigureClusterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A set of configuration changes to apply to the cluster. The
	// specification can be a complete set of changes or a partial set of
	// changes, applied incrementally.
	Spec ClusterConfigSpec `xml:"spec" json:"spec"`
	// Flag to specify whether the specification ("spec") should
	// be applied incrementally. If "modify" is false and the
	// operation succeeds, then the configuration of the cluster
	// matches the specification exactly; in this case any unset
	// portions of the specification will result in unset or
	// default portions of the configuration.
	Modify bool `xml:"modify" json:"modify"`
}

func init() {
	t["ReconfigureClusterRequestType"] = reflect.TypeOf((*ReconfigureClusterRequestType)(nil)).Elem()
}

type ReconfigureCluster_Task ReconfigureClusterRequestType

func init() {
	t["ReconfigureCluster_Task"] = reflect.TypeOf((*ReconfigureCluster_Task)(nil)).Elem()
}

type ReconfigureCluster_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `ComputeResource.ReconfigureComputeResource_Task`.
type ReconfigureComputeResourceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A set of configuration changes to apply to the compute resource.
	// The specification can be a complete set of changes or a partial
	// set of changes, applied incrementally. When invoking
	// reconfigureEx on a cluster, this argument may be a
	// `ClusterConfigSpecEx` object.
	Spec BaseComputeResourceConfigSpec `xml:"spec,typeattr" json:"spec"`
	// Flag to specify whether the specification ("spec") should
	// be applied incrementally. If "modify" is false and the
	// operation succeeds, then the configuration of the cluster
	// matches the specification exactly; in this case any unset
	// portions of the specification will result in unset or
	// default portions of the configuration.
	Modify bool `xml:"modify" json:"modify"`
}

func init() {
	t["ReconfigureComputeResourceRequestType"] = reflect.TypeOf((*ReconfigureComputeResourceRequestType)(nil)).Elem()
}

type ReconfigureComputeResource_Task ReconfigureComputeResourceRequestType

func init() {
	t["ReconfigureComputeResource_Task"] = reflect.TypeOf((*ReconfigureComputeResource_Task)(nil)).Elem()
}

type ReconfigureComputeResource_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `DistributedVirtualSwitch.ReconfigureDVPort_Task`.
type ReconfigureDVPortRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specification of the ports.
	Port []DVPortConfigSpec `xml:"port" json:"port"`
}

func init() {
	t["ReconfigureDVPortRequestType"] = reflect.TypeOf((*ReconfigureDVPortRequestType)(nil)).Elem()
}

type ReconfigureDVPort_Task ReconfigureDVPortRequestType

func init() {
	t["ReconfigureDVPort_Task"] = reflect.TypeOf((*ReconfigureDVPort_Task)(nil)).Elem()
}

type ReconfigureDVPort_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `DistributedVirtualPortgroup.ReconfigureDVPortgroup_Task`.
type ReconfigureDVPortgroupRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Configuration data for the portgroup.
	Spec DVPortgroupConfigSpec `xml:"spec" json:"spec"`
}

func init() {
	t["ReconfigureDVPortgroupRequestType"] = reflect.TypeOf((*ReconfigureDVPortgroupRequestType)(nil)).Elem()
}

type ReconfigureDVPortgroup_Task ReconfigureDVPortgroupRequestType

func init() {
	t["ReconfigureDVPortgroup_Task"] = reflect.TypeOf((*ReconfigureDVPortgroup_Task)(nil)).Elem()
}

type ReconfigureDVPortgroup_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `Datacenter.ReconfigureDatacenter_Task`.
type ReconfigureDatacenterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A set of configuration changes to apply to the datacenter.
	// The specification can be a complete set of changes or a partial
	// set of changes, applied incrementally.
	Spec DatacenterConfigSpec `xml:"spec" json:"spec"`
	// Flag to specify whether the specification ("spec") should
	// be applied incrementally. If "modify" is false and the
	// operation succeeds, then the configuration of the datacenter
	// matches the specification exactly; in this case any unset
	// portions of the specification will result in unset or
	// default portions of the configuration.
	Modify bool `xml:"modify" json:"modify"`
}

func init() {
	t["ReconfigureDatacenterRequestType"] = reflect.TypeOf((*ReconfigureDatacenterRequestType)(nil)).Elem()
}

type ReconfigureDatacenter_Task ReconfigureDatacenterRequestType

func init() {
	t["ReconfigureDatacenter_Task"] = reflect.TypeOf((*ReconfigureDatacenter_Task)(nil)).Elem()
}

type ReconfigureDatacenter_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ReconfigureDomObject ReconfigureDomObjectRequestType

func init() {
	t["ReconfigureDomObject"] = reflect.TypeOf((*ReconfigureDomObject)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.ReconfigureDomObject`.
type ReconfigureDomObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// DOM object UUID.
	Uuid string `xml:"uuid" json:"uuid"`
	// VSAN expression formatted policy string.
	Policy string `xml:"policy" json:"policy"`
}

func init() {
	t["ReconfigureDomObjectRequestType"] = reflect.TypeOf((*ReconfigureDomObjectRequestType)(nil)).Elem()
}

type ReconfigureDomObjectResponse struct {
}

// The parameters of `DistributedVirtualSwitch.ReconfigureDvs_Task`.
type ReconfigureDvsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The configuration of the switch
	Spec BaseDVSConfigSpec `xml:"spec,typeattr" json:"spec"`
}

func init() {
	t["ReconfigureDvsRequestType"] = reflect.TypeOf((*ReconfigureDvsRequestType)(nil)).Elem()
}

type ReconfigureDvs_Task ReconfigureDvsRequestType

func init() {
	t["ReconfigureDvs_Task"] = reflect.TypeOf((*ReconfigureDvs_Task)(nil)).Elem()
}

type ReconfigureDvs_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ReconfigureHostForDASRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ReconfigureHostForDASRequestType"] = reflect.TypeOf((*ReconfigureHostForDASRequestType)(nil)).Elem()
}

type ReconfigureHostForDAS_Task ReconfigureHostForDASRequestType

func init() {
	t["ReconfigureHostForDAS_Task"] = reflect.TypeOf((*ReconfigureHostForDAS_Task)(nil)).Elem()
}

type ReconfigureHostForDAS_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ReconfigureScheduledTask ReconfigureScheduledTaskRequestType

func init() {
	t["ReconfigureScheduledTask"] = reflect.TypeOf((*ReconfigureScheduledTask)(nil)).Elem()
}

// The parameters of `ScheduledTask.ReconfigureScheduledTask`.
type ReconfigureScheduledTaskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The new specification for the scheduled task.
	Spec BaseScheduledTaskSpec `xml:"spec,typeattr" json:"spec"`
}

func init() {
	t["ReconfigureScheduledTaskRequestType"] = reflect.TypeOf((*ReconfigureScheduledTaskRequestType)(nil)).Elem()
}

type ReconfigureScheduledTaskResponse struct {
}

type ReconfigureServiceConsoleReservation ReconfigureServiceConsoleReservationRequestType

func init() {
	t["ReconfigureServiceConsoleReservation"] = reflect.TypeOf((*ReconfigureServiceConsoleReservation)(nil)).Elem()
}

// The parameters of `HostMemorySystem.ReconfigureServiceConsoleReservation`.
type ReconfigureServiceConsoleReservationRequestType struct {
	This     ManagedObjectReference `xml:"_this" json:"-"`
	CfgBytes int64                  `xml:"cfgBytes" json:"cfgBytes"`
}

func init() {
	t["ReconfigureServiceConsoleReservationRequestType"] = reflect.TypeOf((*ReconfigureServiceConsoleReservationRequestType)(nil)).Elem()
}

type ReconfigureServiceConsoleReservationResponse struct {
}

type ReconfigureSnmpAgent ReconfigureSnmpAgentRequestType

func init() {
	t["ReconfigureSnmpAgent"] = reflect.TypeOf((*ReconfigureSnmpAgent)(nil)).Elem()
}

// The parameters of `HostSnmpSystem.ReconfigureSnmpAgent`.
type ReconfigureSnmpAgentRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Spec HostSnmpConfigSpec     `xml:"spec" json:"spec"`
}

func init() {
	t["ReconfigureSnmpAgentRequestType"] = reflect.TypeOf((*ReconfigureSnmpAgentRequestType)(nil)).Elem()
}

type ReconfigureSnmpAgentResponse struct {
}

type ReconfigureVirtualMachineReservation ReconfigureVirtualMachineReservationRequestType

func init() {
	t["ReconfigureVirtualMachineReservation"] = reflect.TypeOf((*ReconfigureVirtualMachineReservation)(nil)).Elem()
}

// The parameters of `HostMemorySystem.ReconfigureVirtualMachineReservation`.
type ReconfigureVirtualMachineReservationRequestType struct {
	This ManagedObjectReference              `xml:"_this" json:"-"`
	Spec VirtualMachineMemoryReservationSpec `xml:"spec" json:"spec"`
}

func init() {
	t["ReconfigureVirtualMachineReservationRequestType"] = reflect.TypeOf((*ReconfigureVirtualMachineReservationRequestType)(nil)).Elem()
}

type ReconfigureVirtualMachineReservationResponse struct {
}

// The parameters of `HostSystem.ReconnectHost_Task`.
type ReconnectHostRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Includes the parameters to use, including user name and password,
	// when reconnecting to the host. If this parameter is not specified,
	// the default connection parameters is used.
	CnxSpec *HostConnectSpec `xml:"cnxSpec,omitempty" json:"cnxSpec,omitempty"`
	// Includes connection parameters specific to
	// reconnect. This will mainly be used to indicate how to
	// handle divergence between the host settings and vCenter Server
	// settings when the host was disconnected.
	ReconnectSpec *HostSystemReconnectSpec `xml:"reconnectSpec,omitempty" json:"reconnectSpec,omitempty"`
}

func init() {
	t["ReconnectHostRequestType"] = reflect.TypeOf((*ReconnectHostRequestType)(nil)).Elem()
}

type ReconnectHost_Task ReconnectHostRequestType

func init() {
	t["ReconnectHost_Task"] = reflect.TypeOf((*ReconnectHost_Task)(nil)).Elem()
}

type ReconnectHost_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Deprecated as of vSphere API 6.0.
//
// Fault thrown if a record or replay operation cannot be performed
// because these capabilities have been disabled on the virtual machine.
type RecordReplayDisabled struct {
	VimFault
}

func init() {
	t["RecordReplayDisabled"] = reflect.TypeOf((*RecordReplayDisabled)(nil)).Elem()
}

type RecordReplayDisabledFault RecordReplayDisabled

func init() {
	t["RecordReplayDisabledFault"] = reflect.TypeOf((*RecordReplayDisabledFault)(nil)).Elem()
}

// This event is generated when recovery takes place on a management vmknic
type RecoveryEvent struct {
	DvsEvent

	// The host on which recovery happened
	HostName string `xml:"hostName" json:"hostName"`
	// The key of the new port
	PortKey string `xml:"portKey" json:"portKey"`
	// The uuid of the DVS
	DvsUuid string `xml:"dvsUuid,omitempty" json:"dvsUuid,omitempty"`
	// The virtual management NIC device where recovery was done
	Vnic string `xml:"vnic,omitempty" json:"vnic,omitempty"`
}

func init() {
	t["RecoveryEvent"] = reflect.TypeOf((*RecoveryEvent)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.RectifyDvsHost_Task`.
type RectifyDvsHostRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The hosts to be rectified.
	//
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts,omitempty" json:"hosts,omitempty"`
}

func init() {
	t["RectifyDvsHostRequestType"] = reflect.TypeOf((*RectifyDvsHostRequestType)(nil)).Elem()
}

type RectifyDvsHost_Task RectifyDvsHostRequestType

func init() {
	t["RectifyDvsHost_Task"] = reflect.TypeOf((*RectifyDvsHost_Task)(nil)).Elem()
}

type RectifyDvsHost_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `DistributedVirtualSwitchManager.RectifyDvsOnHost_Task`.
type RectifyDvsOnHostRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The hosts to be rectified.
	//
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts" json:"hosts"`
}

func init() {
	t["RectifyDvsOnHostRequestType"] = reflect.TypeOf((*RectifyDvsOnHostRequestType)(nil)).Elem()
}

type RectifyDvsOnHost_Task RectifyDvsOnHostRequestType

func init() {
	t["RectifyDvsOnHost_Task"] = reflect.TypeOf((*RectifyDvsOnHost_Task)(nil)).Elem()
}

type RectifyDvsOnHost_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The `RecurrentTaskScheduler` data object is the base type for
// the hierarchy that includes hourly, daily, weekly, and monthly task schedulers.
type RecurrentTaskScheduler struct {
	TaskScheduler

	// How often to run the scheduled task.
	//
	// The value must be greater than
	// or equal to 1 and less than 1000. The default value is 1.
	// The interval acts as a multiplier for the unit of time associated
	// with a particular scheduler (hours, days, weeks, or months).
	// For example, setting the `HourlyTaskScheduler` interval
	// to 4 causes the task to run every 4 hours.
	Interval int32 `xml:"interval" json:"interval"`
}

func init() {
	t["RecurrentTaskScheduler"] = reflect.TypeOf((*RecurrentTaskScheduler)(nil)).Elem()
}

type Refresh RefreshRequestType

func init() {
	t["Refresh"] = reflect.TypeOf((*Refresh)(nil)).Elem()
}

type RefreshDVPortState RefreshDVPortStateRequestType

func init() {
	t["RefreshDVPortState"] = reflect.TypeOf((*RefreshDVPortState)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.RefreshDVPortState`.
type RefreshDVPortStateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The keys of the ports to be refreshed. If not specified, all port
	// states are refreshed.
	PortKeys []string `xml:"portKeys,omitempty" json:"portKeys,omitempty"`
}

func init() {
	t["RefreshDVPortStateRequestType"] = reflect.TypeOf((*RefreshDVPortStateRequestType)(nil)).Elem()
}

type RefreshDVPortStateResponse struct {
}

type RefreshDatastore RefreshDatastoreRequestType

func init() {
	t["RefreshDatastore"] = reflect.TypeOf((*RefreshDatastore)(nil)).Elem()
}

type RefreshDatastoreRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RefreshDatastoreRequestType"] = reflect.TypeOf((*RefreshDatastoreRequestType)(nil)).Elem()
}

type RefreshDatastoreResponse struct {
}

type RefreshDatastoreStorageInfo RefreshDatastoreStorageInfoRequestType

func init() {
	t["RefreshDatastoreStorageInfo"] = reflect.TypeOf((*RefreshDatastoreStorageInfo)(nil)).Elem()
}

type RefreshDatastoreStorageInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RefreshDatastoreStorageInfoRequestType"] = reflect.TypeOf((*RefreshDatastoreStorageInfoRequestType)(nil)).Elem()
}

type RefreshDatastoreStorageInfoResponse struct {
}

type RefreshDateTimeSystem RefreshDateTimeSystemRequestType

func init() {
	t["RefreshDateTimeSystem"] = reflect.TypeOf((*RefreshDateTimeSystem)(nil)).Elem()
}

type RefreshDateTimeSystemRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RefreshDateTimeSystemRequestType"] = reflect.TypeOf((*RefreshDateTimeSystemRequestType)(nil)).Elem()
}

type RefreshDateTimeSystemResponse struct {
}

type RefreshFirewall RefreshFirewallRequestType

func init() {
	t["RefreshFirewall"] = reflect.TypeOf((*RefreshFirewall)(nil)).Elem()
}

type RefreshFirewallRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RefreshFirewallRequestType"] = reflect.TypeOf((*RefreshFirewallRequestType)(nil)).Elem()
}

type RefreshFirewallResponse struct {
}

type RefreshGraphicsManager RefreshGraphicsManagerRequestType

func init() {
	t["RefreshGraphicsManager"] = reflect.TypeOf((*RefreshGraphicsManager)(nil)).Elem()
}

type RefreshGraphicsManagerRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RefreshGraphicsManagerRequestType"] = reflect.TypeOf((*RefreshGraphicsManagerRequestType)(nil)).Elem()
}

type RefreshGraphicsManagerResponse struct {
}

type RefreshHealthStatusSystem RefreshHealthStatusSystemRequestType

func init() {
	t["RefreshHealthStatusSystem"] = reflect.TypeOf((*RefreshHealthStatusSystem)(nil)).Elem()
}

type RefreshHealthStatusSystemRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RefreshHealthStatusSystemRequestType"] = reflect.TypeOf((*RefreshHealthStatusSystemRequestType)(nil)).Elem()
}

type RefreshHealthStatusSystemResponse struct {
}

type RefreshNetworkSystem RefreshNetworkSystemRequestType

func init() {
	t["RefreshNetworkSystem"] = reflect.TypeOf((*RefreshNetworkSystem)(nil)).Elem()
}

type RefreshNetworkSystemRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RefreshNetworkSystemRequestType"] = reflect.TypeOf((*RefreshNetworkSystemRequestType)(nil)).Elem()
}

type RefreshNetworkSystemResponse struct {
}

type RefreshRecommendation RefreshRecommendationRequestType

func init() {
	t["RefreshRecommendation"] = reflect.TypeOf((*RefreshRecommendation)(nil)).Elem()
}

type RefreshRecommendationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RefreshRecommendationRequestType"] = reflect.TypeOf((*RefreshRecommendationRequestType)(nil)).Elem()
}

type RefreshRecommendationResponse struct {
}

type RefreshRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RefreshRequestType"] = reflect.TypeOf((*RefreshRequestType)(nil)).Elem()
}

type RefreshResponse struct {
}

type RefreshRuntime RefreshRuntimeRequestType

func init() {
	t["RefreshRuntime"] = reflect.TypeOf((*RefreshRuntime)(nil)).Elem()
}

type RefreshRuntimeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RefreshRuntimeRequestType"] = reflect.TypeOf((*RefreshRuntimeRequestType)(nil)).Elem()
}

type RefreshRuntimeResponse struct {
}

type RefreshServices RefreshServicesRequestType

func init() {
	t["RefreshServices"] = reflect.TypeOf((*RefreshServices)(nil)).Elem()
}

type RefreshServicesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RefreshServicesRequestType"] = reflect.TypeOf((*RefreshServicesRequestType)(nil)).Elem()
}

type RefreshServicesResponse struct {
}

type RefreshStorageDrsRecommendation RefreshStorageDrsRecommendationRequestType

func init() {
	t["RefreshStorageDrsRecommendation"] = reflect.TypeOf((*RefreshStorageDrsRecommendation)(nil)).Elem()
}

// The parameters of `StorageResourceManager.RefreshStorageDrsRecommendation`.
type RefreshStorageDrsRecommendationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The storage pod.
	// The recommendations generated is stored at
	// `PodStorageDrsEntry.recommendation`.
	//
	// Refers instance of `StoragePod`.
	Pod ManagedObjectReference `xml:"pod" json:"pod"`
}

func init() {
	t["RefreshStorageDrsRecommendationRequestType"] = reflect.TypeOf((*RefreshStorageDrsRecommendationRequestType)(nil)).Elem()
}

type RefreshStorageDrsRecommendationResponse struct {
}

// The parameters of `StorageResourceManager.RefreshStorageDrsRecommendationsForPod_Task`.
type RefreshStorageDrsRecommendationsForPodRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The storage pod.
	// The recommendations generated is stored at
	// `PodStorageDrsEntry.recommendation`.
	//
	// Refers instance of `StoragePod`.
	Pod ManagedObjectReference `xml:"pod" json:"pod"`
}

func init() {
	t["RefreshStorageDrsRecommendationsForPodRequestType"] = reflect.TypeOf((*RefreshStorageDrsRecommendationsForPodRequestType)(nil)).Elem()
}

type RefreshStorageDrsRecommendationsForPod_Task RefreshStorageDrsRecommendationsForPodRequestType

func init() {
	t["RefreshStorageDrsRecommendationsForPod_Task"] = reflect.TypeOf((*RefreshStorageDrsRecommendationsForPod_Task)(nil)).Elem()
}

type RefreshStorageDrsRecommendationsForPod_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type RefreshStorageInfo RefreshStorageInfoRequestType

func init() {
	t["RefreshStorageInfo"] = reflect.TypeOf((*RefreshStorageInfo)(nil)).Elem()
}

type RefreshStorageInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RefreshStorageInfoRequestType"] = reflect.TypeOf((*RefreshStorageInfoRequestType)(nil)).Elem()
}

type RefreshStorageInfoResponse struct {
}

type RefreshStorageSystem RefreshStorageSystemRequestType

func init() {
	t["RefreshStorageSystem"] = reflect.TypeOf((*RefreshStorageSystem)(nil)).Elem()
}

type RefreshStorageSystemRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RefreshStorageSystemRequestType"] = reflect.TypeOf((*RefreshStorageSystemRequestType)(nil)).Elem()
}

type RefreshStorageSystemResponse struct {
}

// The parameters of `ResourcePool.RegisterChildVM_Task`.
type RegisterChildVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A datastore path to the virtual machine. If the path ends with
	// ".vmtx", indicating that it refers to a VM template, an InvalidArgument
	// fault is thrown.
	Path string `xml:"path" json:"path"`
	// The name to be assigned to the virtual machine. If this parameter is
	// not set, the displayName configuration parameter of the virtual machine is
	// used. An entity name must be a non-empty string of less than 80
	// characters. The slash (/), backslash (\\) and percent (%) will be
	// escaped using the URL syntax. For example, %2F.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// The target host on which the virtual machine will run. This parameter
	// must specify a host that is a member of the ComputeResource to which this
	// resource pool belongs. For a stand-alone host or a cluster with DRS,
	// the parameter can be omitted, and the system selects a default.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["RegisterChildVMRequestType"] = reflect.TypeOf((*RegisterChildVMRequestType)(nil)).Elem()
}

type RegisterChildVM_Task RegisterChildVMRequestType

func init() {
	t["RegisterChildVM_Task"] = reflect.TypeOf((*RegisterChildVM_Task)(nil)).Elem()
}

type RegisterChildVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type RegisterDisk RegisterDiskRequestType

func init() {
	t["RegisterDisk"] = reflect.TypeOf((*RegisterDisk)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.RegisterDisk`.
type RegisterDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// URL path to the virtual disk.
	Path string `xml:"path" json:"path"`
	// The descriptive name of the disk object. If
	// unset the name will be automatically determined
	// from the path. @see vim.vslm.BaseConfigInfo#name
	Name string `xml:"name,omitempty" json:"name,omitempty"`
}

func init() {
	t["RegisterDiskRequestType"] = reflect.TypeOf((*RegisterDiskRequestType)(nil)).Elem()
}

type RegisterDiskResponse struct {
	Returnval VStorageObject `xml:"returnval" json:"returnval"`
}

type RegisterExtension RegisterExtensionRequestType

func init() {
	t["RegisterExtension"] = reflect.TypeOf((*RegisterExtension)(nil)).Elem()
}

// The parameters of `ExtensionManager.RegisterExtension`.
type RegisterExtensionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Extension description to register.
	Extension Extension `xml:"extension" json:"extension"`
}

func init() {
	t["RegisterExtensionRequestType"] = reflect.TypeOf((*RegisterExtensionRequestType)(nil)).Elem()
}

type RegisterExtensionResponse struct {
}

type RegisterHealthUpdateProvider RegisterHealthUpdateProviderRequestType

func init() {
	t["RegisterHealthUpdateProvider"] = reflect.TypeOf((*RegisterHealthUpdateProvider)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.RegisterHealthUpdateProvider`.
type RegisterHealthUpdateProviderRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The provider name. Should follow Java package
	// naming convention to minimize name clashes with
	// currently registered providers.
	// For example, "com.vmware.HealthUpdateProvider".
	Name string `xml:"name" json:"name"`
	// The list of healthUpdateInfo that can be
	// reported in healthUpdates.
	HealthUpdateInfo []HealthUpdateInfo `xml:"healthUpdateInfo,omitempty" json:"healthUpdateInfo,omitempty"`
}

func init() {
	t["RegisterHealthUpdateProviderRequestType"] = reflect.TypeOf((*RegisterHealthUpdateProviderRequestType)(nil)).Elem()
}

type RegisterHealthUpdateProviderResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type RegisterKmipServer RegisterKmipServerRequestType

func init() {
	t["RegisterKmipServer"] = reflect.TypeOf((*RegisterKmipServer)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.RegisterKmipServer`.
type RegisterKmipServerRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP server connection information.
	// When register a new KMIP server to the key provider,
	// the `KmipServerSpec#defaultKeyType` and
	// `KmipServerSpec#wrappingKeySpec` must match
	// existing servers.
	Server KmipServerSpec `xml:"server" json:"server"`
}

func init() {
	t["RegisterKmipServerRequestType"] = reflect.TypeOf((*RegisterKmipServerRequestType)(nil)).Elem()
}

type RegisterKmipServerResponse struct {
}

type RegisterKmsCluster RegisterKmsClusterRequestType

func init() {
	t["RegisterKmsCluster"] = reflect.TypeOf((*RegisterKmsCluster)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.RegisterKmsCluster`.
type RegisterKmsClusterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMS cluster ID to register.
	ClusterId KeyProviderId `xml:"clusterId" json:"clusterId"`
	// \[in\] Key provider management type
	// See `KmipClusterInfoKmsManagementType_enum`
	// for valid values.
	// By default trustAuthority.
	ManagementType string `xml:"managementType,omitempty" json:"managementType,omitempty"`
}

func init() {
	t["RegisterKmsClusterRequestType"] = reflect.TypeOf((*RegisterKmsClusterRequestType)(nil)).Elem()
}

type RegisterKmsClusterResponse struct {
}

// The parameters of `Folder.RegisterVM_Task`.
type RegisterVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A datastore path to the virtual machine.
	Path string `xml:"path" json:"path"`
	// The name to be assigned to the virtual machine. If this parameter is
	// not set, the displayName configuration parameter of the virtual machine is
	// used. An entity name must be a non-empty string of less than 80
	// characters. The slash (/), backslash (\\) and percent (%) will be
	// escaped using the URL syntax. For example, %2F.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// Flag to specify whether or not the virtual machine
	// should be marked as a template.
	AsTemplate bool `xml:"asTemplate" json:"asTemplate"`
	// The resource pool to which the virtual machine should be attached.
	// If imported as a template, this parameter is not set.
	//
	// Required privileges: Resource.AssignVMToPool
	//
	// Refers instance of `ResourcePool`.
	Pool *ManagedObjectReference `xml:"pool,omitempty" json:"pool,omitempty"`
	// The target host on which the virtual machine will run. This parameter
	// must specify a host that is a member of the ComputeResource indirectly
	// specified by the pool. For a stand-alone host or a cluster,
	// the parameter can be omitted, and the system selects a default.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["RegisterVMRequestType"] = reflect.TypeOf((*RegisterVMRequestType)(nil)).Elem()
}

type RegisterVM_Task RegisterVMRequestType

func init() {
	t["RegisterVM_Task"] = reflect.TypeOf((*RegisterVM_Task)(nil)).Elem()
}

type RegisterVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type Relation struct {
	DynamicData

	// If contraint is not set, the relation holds for all versions.
	//
	// and if a constraint is defined it will be one of
	// `SoftwarePackageConstraint_enum`.
	Constraint string `xml:"constraint,omitempty" json:"constraint,omitempty"`
	Name       string `xml:"name" json:"name"`
	Version    string `xml:"version,omitempty" json:"version,omitempty"`
}

func init() {
	t["Relation"] = reflect.TypeOf((*Relation)(nil)).Elem()
}

type ReleaseCredentialsInGuest ReleaseCredentialsInGuestRequestType

func init() {
	t["ReleaseCredentialsInGuest"] = reflect.TypeOf((*ReleaseCredentialsInGuest)(nil)).Elem()
}

// The parameters of `GuestAuthManager.ReleaseCredentialsInGuest`.
type ReleaseCredentialsInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// MoRef of the VM to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Query
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
}

func init() {
	t["ReleaseCredentialsInGuestRequestType"] = reflect.TypeOf((*ReleaseCredentialsInGuestRequestType)(nil)).Elem()
}

type ReleaseCredentialsInGuestResponse struct {
}

type ReleaseIpAllocation ReleaseIpAllocationRequestType

func init() {
	t["ReleaseIpAllocation"] = reflect.TypeOf((*ReleaseIpAllocation)(nil)).Elem()
}

// The parameters of `IpPoolManager.ReleaseIpAllocation`.
type ReleaseIpAllocationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datacenter on which to find the pool
	//
	// Required privileges: Datacenter.IpPoolReleaseIp
	//
	// Refers instance of `Datacenter`.
	Dc ManagedObjectReference `xml:"dc" json:"dc"`
	// The unique ID of the pool
	PoolId int32 `xml:"poolId" json:"poolId"`
	// The unique ID for this allocation
	AllocationId string `xml:"allocationId" json:"allocationId"`
}

func init() {
	t["ReleaseIpAllocationRequestType"] = reflect.TypeOf((*ReleaseIpAllocationRequestType)(nil)).Elem()
}

type ReleaseIpAllocationResponse struct {
}

type ReleaseManagedSnapshot ReleaseManagedSnapshotRequestType

func init() {
	t["ReleaseManagedSnapshot"] = reflect.TypeOf((*ReleaseManagedSnapshot)(nil)).Elem()
}

// The parameters of `VirtualDiskManager.ReleaseManagedSnapshot`.
type ReleaseManagedSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \- The name of the disk to release, either a datastore path or a URL
	// referring to the virtual disk.
	Vdisk string `xml:"vdisk" json:"vdisk"`
	// If <code>vdisk</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>vdisk</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
}

func init() {
	t["ReleaseManagedSnapshotRequestType"] = reflect.TypeOf((*ReleaseManagedSnapshotRequestType)(nil)).Elem()
}

type ReleaseManagedSnapshotResponse struct {
}

type Reload ReloadRequestType

func init() {
	t["Reload"] = reflect.TypeOf((*Reload)(nil)).Elem()
}

type ReloadRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ReloadRequestType"] = reflect.TypeOf((*ReloadRequestType)(nil)).Elem()
}

type ReloadResponse struct {
}

// The parameters of `VirtualMachine.RelocateVM_Task`.
type RelocateVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specification of where to relocate the virtual machine
	// (see `VirtualMachineRelocateSpec`).
	Spec VirtualMachineRelocateSpec `xml:"spec" json:"spec"`
	// The task priority
	// (see `VirtualMachineMovePriority_enum`).
	Priority VirtualMachineMovePriority `xml:"priority,omitempty" json:"priority,omitempty"`
}

func init() {
	t["RelocateVMRequestType"] = reflect.TypeOf((*RelocateVMRequestType)(nil)).Elem()
}

type RelocateVM_Task RelocateVMRequestType

func init() {
	t["RelocateVM_Task"] = reflect.TypeOf((*RelocateVM_Task)(nil)).Elem()
}

type RelocateVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VcenterVStorageObjectManager.RelocateVStorageObject_Task`.
type RelocateVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The specification for relocation of the virtual
	// storage object.
	Spec VslmRelocateSpec `xml:"spec" json:"spec"`
}

func init() {
	t["RelocateVStorageObjectRequestType"] = reflect.TypeOf((*RelocateVStorageObjectRequestType)(nil)).Elem()
}

type RelocateVStorageObject_Task RelocateVStorageObjectRequestType

func init() {
	t["RelocateVStorageObject_Task"] = reflect.TypeOf((*RelocateVStorageObject_Task)(nil)).Elem()
}

type RelocateVStorageObject_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The virtual machine has a currently connected device with a remote backing.
//
// This is an error when migrating a powered-on virtual machine, and can be returned
// as a subfault of DisallowedMigrationDeviceAttached.
type RemoteDeviceNotSupported struct {
	DeviceNotSupported
}

func init() {
	t["RemoteDeviceNotSupported"] = reflect.TypeOf((*RemoteDeviceNotSupported)(nil)).Elem()
}

type RemoteDeviceNotSupportedFault RemoteDeviceNotSupported

func init() {
	t["RemoteDeviceNotSupportedFault"] = reflect.TypeOf((*RemoteDeviceNotSupportedFault)(nil)).Elem()
}

// Remote Tech Support Mode for the host has been enabled.
type RemoteTSMEnabledEvent struct {
	HostEvent
}

func init() {
	t["RemoteTSMEnabledEvent"] = reflect.TypeOf((*RemoteTSMEnabledEvent)(nil)).Elem()
}

type RemoveAlarm RemoveAlarmRequestType

func init() {
	t["RemoveAlarm"] = reflect.TypeOf((*RemoveAlarm)(nil)).Elem()
}

type RemoveAlarmRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RemoveAlarmRequestType"] = reflect.TypeOf((*RemoveAlarmRequestType)(nil)).Elem()
}

type RemoveAlarmResponse struct {
}

// The parameters of `VirtualMachine.RemoveAllSnapshots_Task`.
type RemoveAllSnapshotsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// (optional) If set to true, the virtual disks of the deleted
	// snapshot will be merged with other disk if possible. Default to true.
	Consolidate *bool `xml:"consolidate" json:"consolidate,omitempty"`
	// (optional) When provided, only snapshots satisfying the
	// criteria described by the spec will be removed. If unset, all snapshots
	// will be removed.
	Spec *SnapshotSelectionSpec `xml:"spec,omitempty" json:"spec,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["RemoveAllSnapshotsRequestType"] = reflect.TypeOf((*RemoveAllSnapshotsRequestType)(nil)).Elem()
}

type RemoveAllSnapshots_Task RemoveAllSnapshotsRequestType

func init() {
	t["RemoveAllSnapshots_Task"] = reflect.TypeOf((*RemoveAllSnapshots_Task)(nil)).Elem()
}

type RemoveAllSnapshots_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type RemoveAssignedLicense RemoveAssignedLicenseRequestType

func init() {
	t["RemoveAssignedLicense"] = reflect.TypeOf((*RemoveAssignedLicense)(nil)).Elem()
}

// The parameters of `LicenseAssignmentManager.RemoveAssignedLicense`.
type RemoveAssignedLicenseRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// ID of the entity. E.g. HostSystem.
	EntityId string `xml:"entityId" json:"entityId"`
}

func init() {
	t["RemoveAssignedLicenseRequestType"] = reflect.TypeOf((*RemoveAssignedLicenseRequestType)(nil)).Elem()
}

type RemoveAssignedLicenseResponse struct {
}

type RemoveAuthorizationRole RemoveAuthorizationRoleRequestType

func init() {
	t["RemoveAuthorizationRole"] = reflect.TypeOf((*RemoveAuthorizationRole)(nil)).Elem()
}

// The parameters of `AuthorizationManager.RemoveAuthorizationRole`.
type RemoveAuthorizationRoleRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	RoleId int32                  `xml:"roleId" json:"roleId"`
	// If true, prevents the role from being
	// removed if any permissions are using it.
	FailIfUsed bool `xml:"failIfUsed" json:"failIfUsed"`
}

func init() {
	t["RemoveAuthorizationRoleRequestType"] = reflect.TypeOf((*RemoveAuthorizationRoleRequestType)(nil)).Elem()
}

type RemoveAuthorizationRoleResponse struct {
}

type RemoveCustomFieldDef RemoveCustomFieldDefRequestType

func init() {
	t["RemoveCustomFieldDef"] = reflect.TypeOf((*RemoveCustomFieldDef)(nil)).Elem()
}

// The parameters of `CustomFieldsManager.RemoveCustomFieldDef`.
type RemoveCustomFieldDefRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The unique key for the field definition.
	Key int32 `xml:"key" json:"key"`
}

func init() {
	t["RemoveCustomFieldDefRequestType"] = reflect.TypeOf((*RemoveCustomFieldDefRequestType)(nil)).Elem()
}

type RemoveCustomFieldDefResponse struct {
}

type RemoveDatastore RemoveDatastoreRequestType

func init() {
	t["RemoveDatastore"] = reflect.TypeOf((*RemoveDatastore)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.RemoveDatastoreEx_Task`.
type RemoveDatastoreExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// each element specifies one datastore to be removed.
	//
	// Refers instances of `Datastore`.
	Datastore []ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["RemoveDatastoreExRequestType"] = reflect.TypeOf((*RemoveDatastoreExRequestType)(nil)).Elem()
}

type RemoveDatastoreEx_Task RemoveDatastoreExRequestType

func init() {
	t["RemoveDatastoreEx_Task"] = reflect.TypeOf((*RemoveDatastoreEx_Task)(nil)).Elem()
}

type RemoveDatastoreEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostDatastoreSystem.RemoveDatastore`.
type RemoveDatastoreRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datastore to be removed.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["RemoveDatastoreRequestType"] = reflect.TypeOf((*RemoveDatastoreRequestType)(nil)).Elem()
}

type RemoveDatastoreResponse struct {
}

// The parameters of `HostVsanSystem.RemoveDiskMapping_Task`.
type RemoveDiskMappingRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// list of disk mappings to be removed from VSAN usage.
	Mapping []VsanHostDiskMapping `xml:"mapping" json:"mapping"`
	// Any additional actions to move data out of the disk
	// before removing it. See `HostMaintenanceSpec`.
	// If unspecified, there is no action taken to move
	// data from the disk.
	MaintenanceSpec *HostMaintenanceSpec `xml:"maintenanceSpec,omitempty" json:"maintenanceSpec,omitempty"`
	// Time to wait for the task to complete in seconds.
	// If the value is less than or equal to zero, there
	// is no timeout. The operation fails with a Timedout
	// exception if it timed out.
	Timeout int32 `xml:"timeout,omitempty" json:"timeout,omitempty"`
}

func init() {
	t["RemoveDiskMappingRequestType"] = reflect.TypeOf((*RemoveDiskMappingRequestType)(nil)).Elem()
}

type RemoveDiskMapping_Task RemoveDiskMappingRequestType

func init() {
	t["RemoveDiskMapping_Task"] = reflect.TypeOf((*RemoveDiskMapping_Task)(nil)).Elem()
}

type RemoveDiskMapping_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostVsanSystem.RemoveDisk_Task`.
type RemoveDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// list of disks to be removed from use by the VSAN service.
	Disk []HostScsiDisk `xml:"disk" json:"disk"`
	// Any additional actions to move data out of the disk
	// before removing it. See `HostMaintenanceSpec`.
	// If unspecified, there is no action taken to move
	// data from the disk.
	MaintenanceSpec *HostMaintenanceSpec `xml:"maintenanceSpec,omitempty" json:"maintenanceSpec,omitempty"`
	// Time to wait for the task to complete in seconds.
	// If the value is less than or equal to zero, there
	// is no timeout. The operation fails with a Timedout
	// exception if it timed out.
	Timeout int32 `xml:"timeout,omitempty" json:"timeout,omitempty"`
}

func init() {
	t["RemoveDiskRequestType"] = reflect.TypeOf((*RemoveDiskRequestType)(nil)).Elem()
}

type RemoveDisk_Task RemoveDiskRequestType

func init() {
	t["RemoveDisk_Task"] = reflect.TypeOf((*RemoveDisk_Task)(nil)).Elem()
}

type RemoveDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type RemoveEntityPermission RemoveEntityPermissionRequestType

func init() {
	t["RemoveEntityPermission"] = reflect.TypeOf((*RemoveEntityPermission)(nil)).Elem()
}

// The parameters of `AuthorizationManager.RemoveEntityPermission`.
type RemoveEntityPermissionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Entity on which a permission is removed.
	//
	// Required privileges: Authorization.ModifyPermissions
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// User or group for which the permission is defined.
	User string `xml:"user" json:"user"`
	// True, if user refers to a group name; false, for a user name.
	IsGroup bool `xml:"isGroup" json:"isGroup"`
}

func init() {
	t["RemoveEntityPermissionRequestType"] = reflect.TypeOf((*RemoveEntityPermissionRequestType)(nil)).Elem()
}

type RemoveEntityPermissionResponse struct {
}

// This fault is thrown when the client attempts to remove an object that has
// active related objects (for example, a role that has active permissions).
type RemoveFailed struct {
	VimFault
}

func init() {
	t["RemoveFailed"] = reflect.TypeOf((*RemoveFailed)(nil)).Elem()
}

type RemoveFailedFault RemoveFailed

func init() {
	t["RemoveFailedFault"] = reflect.TypeOf((*RemoveFailedFault)(nil)).Elem()
}

type RemoveFilter RemoveFilterRequestType

func init() {
	t["RemoveFilter"] = reflect.TypeOf((*RemoveFilter)(nil)).Elem()
}

type RemoveFilterEntities RemoveFilterEntitiesRequestType

func init() {
	t["RemoveFilterEntities"] = reflect.TypeOf((*RemoveFilterEntities)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.RemoveFilterEntities`.
type RemoveFilterEntitiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The filter id.
	FilterId string `xml:"filterId" json:"filterId"`
	// The list of removed managed entities.
	//
	// Refers instances of `ManagedEntity`.
	Entities []ManagedObjectReference `xml:"entities,omitempty" json:"entities,omitempty"`
}

func init() {
	t["RemoveFilterEntitiesRequestType"] = reflect.TypeOf((*RemoveFilterEntitiesRequestType)(nil)).Elem()
}

type RemoveFilterEntitiesResponse struct {
}

// The parameters of `HealthUpdateManager.RemoveFilter`.
type RemoveFilterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The filter id.
	FilterId string `xml:"filterId" json:"filterId"`
}

func init() {
	t["RemoveFilterRequestType"] = reflect.TypeOf((*RemoveFilterRequestType)(nil)).Elem()
}

type RemoveFilterResponse struct {
}

type RemoveGroup RemoveGroupRequestType

func init() {
	t["RemoveGroup"] = reflect.TypeOf((*RemoveGroup)(nil)).Elem()
}

// The parameters of `HostLocalAccountManager.RemoveGroup`.
type RemoveGroupRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Group ID of the group account being removed.
	GroupName string `xml:"groupName" json:"groupName"`
}

func init() {
	t["RemoveGroupRequestType"] = reflect.TypeOf((*RemoveGroupRequestType)(nil)).Elem()
}

type RemoveGroupResponse struct {
}

type RemoveGuestAlias RemoveGuestAliasRequestType

func init() {
	t["RemoveGuestAlias"] = reflect.TypeOf((*RemoveGuestAlias)(nil)).Elem()
}

type RemoveGuestAliasByCert RemoveGuestAliasByCertRequestType

func init() {
	t["RemoveGuestAliasByCert"] = reflect.TypeOf((*RemoveGuestAliasByCert)(nil)).Elem()
}

// The parameters of `GuestAliasManager.RemoveGuestAliasByCert`.
type RemoveGuestAliasByCertRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.ModifyAliases
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data for this operation. See
	// `GuestAuthentication`. These credentials must satisfy
	// authentication requirements
	// for a guest account on the specified virtual machine.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// Username for the guest account on the virtual machine.
	Username string `xml:"username" json:"username"`
	// The X.509 certificate to be removed, in base64
	// encoded DER format.
	Base64Cert string `xml:"base64Cert" json:"base64Cert"`
}

func init() {
	t["RemoveGuestAliasByCertRequestType"] = reflect.TypeOf((*RemoveGuestAliasByCertRequestType)(nil)).Elem()
}

type RemoveGuestAliasByCertResponse struct {
}

// The parameters of `GuestAliasManager.RemoveGuestAlias`.
type RemoveGuestAliasRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.ModifyAliases
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data for this operation. See
	// `GuestAuthentication`. These credentials must satisfy
	// authentication requirements
	// for a guest account on the specified virtual machine.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// Username for the guest account on the virtual machine.
	Username string `xml:"username" json:"username"`
	// The X.509 certificate associated with the alias to be
	// removed, in base64 encoded DER format.
	Base64Cert string `xml:"base64Cert" json:"base64Cert"`
	// The subject of the alias.
	Subject BaseGuestAuthSubject `xml:"subject,typeattr" json:"subject"`
}

func init() {
	t["RemoveGuestAliasRequestType"] = reflect.TypeOf((*RemoveGuestAliasRequestType)(nil)).Elem()
}

type RemoveGuestAliasResponse struct {
}

type RemoveInternetScsiSendTargets RemoveInternetScsiSendTargetsRequestType

func init() {
	t["RemoveInternetScsiSendTargets"] = reflect.TypeOf((*RemoveInternetScsiSendTargets)(nil)).Elem()
}

// The parameters of `HostStorageSystem.RemoveInternetScsiSendTargets`.
type RemoveInternetScsiSendTargetsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device of the Internet SCSI HBA adapter.
	IScsiHbaDevice string `xml:"iScsiHbaDevice" json:"iScsiHbaDevice"`
	// An array of iSCSI send targets to remove.
	Targets []HostInternetScsiHbaSendTarget `xml:"targets" json:"targets"`
	// flag for forced removal of iSCSI send targets.
	// If unset, force flag will be treated as false.
	Force *bool `xml:"force" json:"force,omitempty" vim:"7.0.1.0"`
}

func init() {
	t["RemoveInternetScsiSendTargetsRequestType"] = reflect.TypeOf((*RemoveInternetScsiSendTargetsRequestType)(nil)).Elem()
}

type RemoveInternetScsiSendTargetsResponse struct {
}

type RemoveInternetScsiStaticTargets RemoveInternetScsiStaticTargetsRequestType

func init() {
	t["RemoveInternetScsiStaticTargets"] = reflect.TypeOf((*RemoveInternetScsiStaticTargets)(nil)).Elem()
}

// The parameters of `HostStorageSystem.RemoveInternetScsiStaticTargets`.
type RemoveInternetScsiStaticTargetsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device of the Internet SCSI HBA adapter.
	IScsiHbaDevice string `xml:"iScsiHbaDevice" json:"iScsiHbaDevice"`
	// An array of iSCSI static targets to remove.
	Targets []HostInternetScsiHbaStaticTarget `xml:"targets" json:"targets"`
}

func init() {
	t["RemoveInternetScsiStaticTargetsRequestType"] = reflect.TypeOf((*RemoveInternetScsiStaticTargetsRequestType)(nil)).Elem()
}

type RemoveInternetScsiStaticTargetsResponse struct {
}

type RemoveKey RemoveKeyRequestType

func init() {
	t["RemoveKey"] = reflect.TypeOf((*RemoveKey)(nil)).Elem()
}

// The parameters of `CryptoManager.RemoveKey`.
type RemoveKeyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] The key to remove.
	Key CryptoKeyId `xml:"key" json:"key"`
	// \[in\] Remove the key even if in use or not existent.
	Force bool `xml:"force" json:"force"`
}

func init() {
	t["RemoveKeyRequestType"] = reflect.TypeOf((*RemoveKeyRequestType)(nil)).Elem()
}

type RemoveKeyResponse struct {
}

type RemoveKeys RemoveKeysRequestType

func init() {
	t["RemoveKeys"] = reflect.TypeOf((*RemoveKeys)(nil)).Elem()
}

// The parameters of `CryptoManager.RemoveKeys`.
type RemoveKeysRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] List of keys to remove.
	Keys []CryptoKeyId `xml:"keys,omitempty" json:"keys,omitempty"`
	// \[in\] Remove the key even if in use. Always successful.
	Force bool `xml:"force" json:"force"`
}

func init() {
	t["RemoveKeysRequestType"] = reflect.TypeOf((*RemoveKeysRequestType)(nil)).Elem()
}

type RemoveKeysResponse struct {
	Returnval []CryptoKeyResult `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RemoveKmipServer RemoveKmipServerRequestType

func init() {
	t["RemoveKmipServer"] = reflect.TypeOf((*RemoveKmipServer)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.RemoveKmipServer`.
type RemoveKmipServerRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP cluster ID.
	ClusterId KeyProviderId `xml:"clusterId" json:"clusterId"`
	// \[in\] KMIP server name.
	ServerName string `xml:"serverName" json:"serverName"`
}

func init() {
	t["RemoveKmipServerRequestType"] = reflect.TypeOf((*RemoveKmipServerRequestType)(nil)).Elem()
}

type RemoveKmipServerResponse struct {
}

type RemoveLicense RemoveLicenseRequestType

func init() {
	t["RemoveLicense"] = reflect.TypeOf((*RemoveLicense)(nil)).Elem()
}

type RemoveLicenseLabel RemoveLicenseLabelRequestType

func init() {
	t["RemoveLicenseLabel"] = reflect.TypeOf((*RemoveLicenseLabel)(nil)).Elem()
}

// The parameters of `LicenseManager.RemoveLicenseLabel`.
type RemoveLicenseLabelRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A license.
	LicenseKey string `xml:"licenseKey" json:"licenseKey"`
	// A label key.
	LabelKey string `xml:"labelKey" json:"labelKey"`
}

func init() {
	t["RemoveLicenseLabelRequestType"] = reflect.TypeOf((*RemoveLicenseLabelRequestType)(nil)).Elem()
}

type RemoveLicenseLabelResponse struct {
}

// The parameters of `LicenseManager.RemoveLicense`.
type RemoveLicenseRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A licenses. E.g. a serial license.
	LicenseKey string `xml:"licenseKey" json:"licenseKey"`
}

func init() {
	t["RemoveLicenseRequestType"] = reflect.TypeOf((*RemoveLicenseRequestType)(nil)).Elem()
}

type RemoveLicenseResponse struct {
}

type RemoveMonitoredEntities RemoveMonitoredEntitiesRequestType

func init() {
	t["RemoveMonitoredEntities"] = reflect.TypeOf((*RemoveMonitoredEntities)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.RemoveMonitoredEntities`.
type RemoveMonitoredEntitiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The provider id.
	ProviderId string `xml:"providerId" json:"providerId"`
	// The entities that are no longer monitored by
	// this provider.
	//
	// Refers instances of `ManagedEntity`.
	Entities []ManagedObjectReference `xml:"entities,omitempty" json:"entities,omitempty"`
}

func init() {
	t["RemoveMonitoredEntitiesRequestType"] = reflect.TypeOf((*RemoveMonitoredEntitiesRequestType)(nil)).Elem()
}

type RemoveMonitoredEntitiesResponse struct {
}

type RemoveNetworkResourcePool RemoveNetworkResourcePoolRequestType

func init() {
	t["RemoveNetworkResourcePool"] = reflect.TypeOf((*RemoveNetworkResourcePool)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.RemoveNetworkResourcePool`.
type RemoveNetworkResourcePoolRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The network resource pool key.
	Key []string `xml:"key" json:"key"`
}

func init() {
	t["RemoveNetworkResourcePoolRequestType"] = reflect.TypeOf((*RemoveNetworkResourcePoolRequestType)(nil)).Elem()
}

type RemoveNetworkResourcePoolResponse struct {
}

type RemoveNvmeOverRdmaAdapter RemoveNvmeOverRdmaAdapterRequestType

func init() {
	t["RemoveNvmeOverRdmaAdapter"] = reflect.TypeOf((*RemoveNvmeOverRdmaAdapter)(nil)).Elem()
}

// The parameters of `HostStorageSystem.RemoveNvmeOverRdmaAdapter`.
type RemoveNvmeOverRdmaAdapterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device name of the NVME over RDMA adapter to be removed.
	HbaDeviceName string `xml:"hbaDeviceName" json:"hbaDeviceName"`
}

func init() {
	t["RemoveNvmeOverRdmaAdapterRequestType"] = reflect.TypeOf((*RemoveNvmeOverRdmaAdapterRequestType)(nil)).Elem()
}

type RemoveNvmeOverRdmaAdapterResponse struct {
}

type RemovePerfInterval RemovePerfIntervalRequestType

func init() {
	t["RemovePerfInterval"] = reflect.TypeOf((*RemovePerfInterval)(nil)).Elem()
}

// The parameters of `PerformanceManager.RemovePerfInterval`.
type RemovePerfIntervalRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The sampling period, in seconds, for the specified interval being
	// removed.
	SamplePeriod int32 `xml:"samplePeriod" json:"samplePeriod"`
}

func init() {
	t["RemovePerfIntervalRequestType"] = reflect.TypeOf((*RemovePerfIntervalRequestType)(nil)).Elem()
}

type RemovePerfIntervalResponse struct {
}

type RemovePortGroup RemovePortGroupRequestType

func init() {
	t["RemovePortGroup"] = reflect.TypeOf((*RemovePortGroup)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.RemovePortGroup`.
type RemovePortGroupRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	PgName string                 `xml:"pgName" json:"pgName"`
}

func init() {
	t["RemovePortGroupRequestType"] = reflect.TypeOf((*RemovePortGroupRequestType)(nil)).Elem()
}

type RemovePortGroupResponse struct {
}

type RemoveScheduledTask RemoveScheduledTaskRequestType

func init() {
	t["RemoveScheduledTask"] = reflect.TypeOf((*RemoveScheduledTask)(nil)).Elem()
}

type RemoveScheduledTaskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RemoveScheduledTaskRequestType"] = reflect.TypeOf((*RemoveScheduledTaskRequestType)(nil)).Elem()
}

type RemoveScheduledTaskResponse struct {
}

type RemoveServiceConsoleVirtualNic RemoveServiceConsoleVirtualNicRequestType

func init() {
	t["RemoveServiceConsoleVirtualNic"] = reflect.TypeOf((*RemoveServiceConsoleVirtualNic)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.RemoveServiceConsoleVirtualNic`.
type RemoveServiceConsoleVirtualNicRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	Device string                 `xml:"device" json:"device"`
}

func init() {
	t["RemoveServiceConsoleVirtualNicRequestType"] = reflect.TypeOf((*RemoveServiceConsoleVirtualNicRequestType)(nil)).Elem()
}

type RemoveServiceConsoleVirtualNicResponse struct {
}

type RemoveSmartCardTrustAnchor RemoveSmartCardTrustAnchorRequestType

func init() {
	t["RemoveSmartCardTrustAnchor"] = reflect.TypeOf((*RemoveSmartCardTrustAnchor)(nil)).Elem()
}

type RemoveSmartCardTrustAnchorByFingerprint RemoveSmartCardTrustAnchorByFingerprintRequestType

func init() {
	t["RemoveSmartCardTrustAnchorByFingerprint"] = reflect.TypeOf((*RemoveSmartCardTrustAnchorByFingerprint)(nil)).Elem()
}

// The parameters of `HostActiveDirectoryAuthentication.RemoveSmartCardTrustAnchorByFingerprint`.
type RemoveSmartCardTrustAnchorByFingerprintRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Certificate fingerprint
	Fingerprint string `xml:"fingerprint" json:"fingerprint"`
	// Digest function used to compute fingerprint. One of
	// `HostActiveDirectoryAuthenticationCertificateDigest_enum`.
	Digest string `xml:"digest" json:"digest"`
}

func init() {
	t["RemoveSmartCardTrustAnchorByFingerprintRequestType"] = reflect.TypeOf((*RemoveSmartCardTrustAnchorByFingerprintRequestType)(nil)).Elem()
}

type RemoveSmartCardTrustAnchorByFingerprintResponse struct {
}

// The parameters of `HostActiveDirectoryAuthentication.RemoveSmartCardTrustAnchor`.
type RemoveSmartCardTrustAnchorRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Certificate issuer
	Issuer string `xml:"issuer" json:"issuer"`
	// Certificate serial number (decimal integer)
	Serial string `xml:"serial" json:"serial"`
}

func init() {
	t["RemoveSmartCardTrustAnchorRequestType"] = reflect.TypeOf((*RemoveSmartCardTrustAnchorRequestType)(nil)).Elem()
}

type RemoveSmartCardTrustAnchorResponse struct {
}

// The parameters of `VirtualMachineSnapshot.RemoveSnapshot_Task`.
type RemoveSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Flag to specify removal of the entire snapshot subtree.
	RemoveChildren bool `xml:"removeChildren" json:"removeChildren"`
	// (optional) If set to true, the virtual disk associated
	// with this snapshot will be merged with other disk if possible. Defaults to true.
	Consolidate *bool `xml:"consolidate" json:"consolidate,omitempty"`
}

func init() {
	t["RemoveSnapshotRequestType"] = reflect.TypeOf((*RemoveSnapshotRequestType)(nil)).Elem()
}

type RemoveSnapshot_Task RemoveSnapshotRequestType

func init() {
	t["RemoveSnapshot_Task"] = reflect.TypeOf((*RemoveSnapshot_Task)(nil)).Elem()
}

type RemoveSnapshot_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type RemoveSoftwareAdapter RemoveSoftwareAdapterRequestType

func init() {
	t["RemoveSoftwareAdapter"] = reflect.TypeOf((*RemoveSoftwareAdapter)(nil)).Elem()
}

// The parameters of `HostStorageSystem.RemoveSoftwareAdapter`.
type RemoveSoftwareAdapterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device name of the adapter to be removed.
	HbaDeviceName string `xml:"hbaDeviceName" json:"hbaDeviceName"`
}

func init() {
	t["RemoveSoftwareAdapterRequestType"] = reflect.TypeOf((*RemoveSoftwareAdapterRequestType)(nil)).Elem()
	minAPIVersionForType["RemoveSoftwareAdapterRequestType"] = "7.0.3.0"
}

type RemoveSoftwareAdapterResponse struct {
}

type RemoveUser RemoveUserRequestType

func init() {
	t["RemoveUser"] = reflect.TypeOf((*RemoveUser)(nil)).Elem()
}

// The parameters of `HostLocalAccountManager.RemoveUser`.
type RemoveUserRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// User ID of the user account being removed.
	UserName string `xml:"userName" json:"userName"`
}

func init() {
	t["RemoveUserRequestType"] = reflect.TypeOf((*RemoveUserRequestType)(nil)).Elem()
}

type RemoveUserResponse struct {
}

type RemoveVirtualNic RemoveVirtualNicRequestType

func init() {
	t["RemoveVirtualNic"] = reflect.TypeOf((*RemoveVirtualNic)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.RemoveVirtualNic`.
type RemoveVirtualNicRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	Device string                 `xml:"device" json:"device"`
}

func init() {
	t["RemoveVirtualNicRequestType"] = reflect.TypeOf((*RemoveVirtualNicRequestType)(nil)).Elem()
}

type RemoveVirtualNicResponse struct {
}

type RemoveVirtualSwitch RemoveVirtualSwitchRequestType

func init() {
	t["RemoveVirtualSwitch"] = reflect.TypeOf((*RemoveVirtualSwitch)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.RemoveVirtualSwitch`.
type RemoveVirtualSwitchRequestType struct {
	This        ManagedObjectReference `xml:"_this" json:"-"`
	VswitchName string                 `xml:"vswitchName" json:"vswitchName"`
}

func init() {
	t["RemoveVirtualSwitchRequestType"] = reflect.TypeOf((*RemoveVirtualSwitchRequestType)(nil)).Elem()
}

type RemoveVirtualSwitchResponse struct {
}

type RenameCustomFieldDef RenameCustomFieldDefRequestType

func init() {
	t["RenameCustomFieldDef"] = reflect.TypeOf((*RenameCustomFieldDef)(nil)).Elem()
}

// The parameters of `CustomFieldsManager.RenameCustomFieldDef`.
type RenameCustomFieldDefRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The unique key for the field definition.
	Key int32 `xml:"key" json:"key"`
	// The new name for the field.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["RenameCustomFieldDefRequestType"] = reflect.TypeOf((*RenameCustomFieldDefRequestType)(nil)).Elem()
}

type RenameCustomFieldDefResponse struct {
}

type RenameCustomizationSpec RenameCustomizationSpecRequestType

func init() {
	t["RenameCustomizationSpec"] = reflect.TypeOf((*RenameCustomizationSpec)(nil)).Elem()
}

// The parameters of `CustomizationSpecManager.RenameCustomizationSpec`.
type RenameCustomizationSpecRequestType struct {
	This    ManagedObjectReference `xml:"_this" json:"-"`
	Name    string                 `xml:"name" json:"name"`
	NewName string                 `xml:"newName" json:"newName"`
}

func init() {
	t["RenameCustomizationSpecRequestType"] = reflect.TypeOf((*RenameCustomizationSpecRequestType)(nil)).Elem()
}

type RenameCustomizationSpecResponse struct {
}

type RenameDatastore RenameDatastoreRequestType

func init() {
	t["RenameDatastore"] = reflect.TypeOf((*RenameDatastore)(nil)).Elem()
}

// The parameters of `Datastore.RenameDatastore`.
type RenameDatastoreRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The new name to assign to the datastore.
	NewName string `xml:"newName" json:"newName"`
}

func init() {
	t["RenameDatastoreRequestType"] = reflect.TypeOf((*RenameDatastoreRequestType)(nil)).Elem()
}

type RenameDatastoreResponse struct {
}

// The parameters of `ManagedEntity.Rename_Task`.
type RenameRequestType struct {
	This    ManagedObjectReference `xml:"_this" json:"-"`
	NewName string                 `xml:"newName" json:"newName"`
}

func init() {
	t["RenameRequestType"] = reflect.TypeOf((*RenameRequestType)(nil)).Elem()
}

type RenameSnapshot RenameSnapshotRequestType

func init() {
	t["RenameSnapshot"] = reflect.TypeOf((*RenameSnapshot)(nil)).Elem()
}

// The parameters of `VirtualMachineSnapshot.RenameSnapshot`.
type RenameSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// New name for the snapshot.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// New description for the snapshot.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
}

func init() {
	t["RenameSnapshotRequestType"] = reflect.TypeOf((*RenameSnapshotRequestType)(nil)).Elem()
}

type RenameSnapshotResponse struct {
}

type RenameVStorageObject RenameVStorageObjectRequestType

func init() {
	t["RenameVStorageObject"] = reflect.TypeOf((*RenameVStorageObject)(nil)).Elem()
}

type RenameVStorageObjectEx RenameVStorageObjectExRequestType

func init() {
	t["RenameVStorageObjectEx"] = reflect.TypeOf((*RenameVStorageObjectEx)(nil)).Elem()
}

// The parameters of `VStorageObjectManagerBase.RenameVStorageObjectEx`.
type RenameVStorageObjectExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object to be renamed.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual storage object is
	// located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The new name for the virtual storage object.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["RenameVStorageObjectExRequestType"] = reflect.TypeOf((*RenameVStorageObjectExRequestType)(nil)).Elem()
	minAPIVersionForType["RenameVStorageObjectExRequestType"] = "8.0.2.0"
}

type RenameVStorageObjectExResponse struct {
	Returnval VslmVClockInfo `xml:"returnval" json:"returnval"`
}

// The parameters of `VcenterVStorageObjectManager.RenameVStorageObject`.
type RenameVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object to be renamed.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual storage object is
	// located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The new name for the virtual storage object.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["RenameVStorageObjectRequestType"] = reflect.TypeOf((*RenameVStorageObjectRequestType)(nil)).Elem()
}

type RenameVStorageObjectResponse struct {
}

type Rename_Task RenameRequestType

func init() {
	t["Rename_Task"] = reflect.TypeOf((*Rename_Task)(nil)).Elem()
}

type Rename_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ReplaceCACertificatesAndCRLs ReplaceCACertificatesAndCRLsRequestType

func init() {
	t["ReplaceCACertificatesAndCRLs"] = reflect.TypeOf((*ReplaceCACertificatesAndCRLs)(nil)).Elem()
}

// The parameters of `HostCertificateManager.ReplaceCACertificatesAndCRLs`.
type ReplaceCACertificatesAndCRLsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of SSL certificates, in PEM format,
	// of all CAs that should be trusted
	CaCert []string `xml:"caCert" json:"caCert"`
	// List of SSL CRLs, in PEM format,
	// issued by trusted CAs from the above list
	CaCrl []string `xml:"caCrl,omitempty" json:"caCrl,omitempty"`
}

func init() {
	t["ReplaceCACertificatesAndCRLsRequestType"] = reflect.TypeOf((*ReplaceCACertificatesAndCRLsRequestType)(nil)).Elem()
}

type ReplaceCACertificatesAndCRLsResponse struct {
}

type ReplaceSmartCardTrustAnchors ReplaceSmartCardTrustAnchorsRequestType

func init() {
	t["ReplaceSmartCardTrustAnchors"] = reflect.TypeOf((*ReplaceSmartCardTrustAnchors)(nil)).Elem()
}

// The parameters of `HostActiveDirectoryAuthentication.ReplaceSmartCardTrustAnchors`.
type ReplaceSmartCardTrustAnchorsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of trusted CA certificates in PEM format. If empty
	// then all existing trust anchors are removed.
	Certs []string `xml:"certs,omitempty" json:"certs,omitempty"`
}

func init() {
	t["ReplaceSmartCardTrustAnchorsRequestType"] = reflect.TypeOf((*ReplaceSmartCardTrustAnchorsRequestType)(nil)).Elem()
}

type ReplaceSmartCardTrustAnchorsResponse struct {
}

// Base type for Replication-related configuration errors.
type ReplicationConfigFault struct {
	ReplicationFault
}

func init() {
	t["ReplicationConfigFault"] = reflect.TypeOf((*ReplicationConfigFault)(nil)).Elem()
}

type ReplicationConfigFaultFault BaseReplicationConfigFault

func init() {
	t["ReplicationConfigFaultFault"] = reflect.TypeOf((*ReplicationConfigFaultFault)(nil)).Elem()
}

// The ReplicationConfigSpec object type encapsulates the replication
// configuration parameters for a virtual machine.
//
// It consists of two
// parts: 1) a set of virtual machine-wide replication properties; 2)
// a set of properties per replicated virtual disk. ReplicationSetting
// is passed as an argument for initial replication configuration
// (@see vim.HbrManager#enableReplication) as well as for
// re-configuration of a replicated VM's properties (@see
// vim.HbrManager#reconfigureReplication).
type ReplicationConfigSpec struct {
	DynamicData

	// A generation number (&gt;=0) that reflects the "freshness" of the
	// ReplicationConfigSpec on which a re-configuration is based.
	//
	// The
	// generation number is used to detect and disallow concurrent
	// updates to a VM's replication settings.
	// For initial replication enablement, generation = 0. The
	// replication settings of every replication re-configuration
	// operation must reflect the latest generation number known to the
	// caller. It takes an explicit call to get the latest replication
	// settings to find out what the latest generation number is. The
	// update algorithm of the generation number is opaque to the
	// caller; e.g., the caller cannot assume that the generation
	// numbers are incremented by one every time replication is
	// (re)configured, not even that they are changing monotonically.
	Generation int64 `xml:"generation" json:"generation"`
	// An opaque identifier that uniquely identifies a replicated VM
	// between primary and secondary sites.
	VmReplicationId string `xml:"vmReplicationId" json:"vmReplicationId"`
	// The IP address of the HBR Server in the secondary site
	// where this VM is replicated to.
	//
	// Note: If net encryption is enabled, this is the address of the
	// encryption tunnelling agent.
	Destination string `xml:"destination" json:"destination"`
	// The port on the HBR Server in the secondary site where this VM
	// is replicated to.
	//
	// Note: If net encryption is enabled, this is the port of the
	// encryption tunneling agent.
	Port int32 `xml:"port" json:"port"`
	// The Recovery Point Objective specified for this VM, in minutes.
	//
	// Currently, valid values are in the range of 1 minute to 1440
	// minutes (24 hours).
	Rpo int64 `xml:"rpo" json:"rpo"`
	// Flag that indicates whether or not to quiesce the file system or
	// applications in the guest OS before a consistent replica is
	// created.
	QuiesceGuestEnabled bool `xml:"quiesceGuestEnabled" json:"quiesceGuestEnabled"`
	// Flag that indicates whether or not the vm or group has been paused for
	// replication.
	Paused bool `xml:"paused" json:"paused"`
	// Flag that indicates whether or not to perform opportunistic
	// updates in-between consistent replicas.
	OppUpdatesEnabled bool `xml:"oppUpdatesEnabled" json:"oppUpdatesEnabled"`
	// Flag that indicates whether or not compression should
	// be used when sending traffic over the network.
	//
	// The primary will negotiate the best compression with
	// the server on the secondary if this is enabled.
	NetCompressionEnabled *bool `xml:"netCompressionEnabled" json:"netCompressionEnabled,omitempty"`
	// Flag that indicates whether or not encription should
	// be used when sending traffic over the network.
	//
	// The primary will use the remoteCertificateThumbprint
	// to verify the identity of the remote server.
	NetEncryptionEnabled *bool `xml:"netEncryptionEnabled" json:"netEncryptionEnabled,omitempty"`
	// The IP address of the remote HBR server, target for encrypted LWD.
	//
	// This field is required when net encryption is enabled, ignored otherwise.
	EncryptionDestination string `xml:"encryptionDestination,omitempty" json:"encryptionDestination,omitempty"`
	// The port on the remote HBR server, target for encrypted LWD.
	//
	// This field is only relevant when net encryption is enabled.
	EncryptionPort int32 `xml:"encryptionPort,omitempty" json:"encryptionPort,omitempty"`
	// Deprecated field is deprecated, use
	// `vim.HbrManager.configureReplicationTargets` instead.
	//
	// The SHA256 thumbprint of the remote server certificate.
	//
	// This field is only relevant when net encription is enabled.
	RemoteCertificateThumbprint string `xml:"remoteCertificateThumbprint,omitempty" json:"remoteCertificateThumbprint,omitempty"`
	// Flag that indicates whether DataSets files are replicated or not.
	DataSetsReplicationEnabled *bool `xml:"dataSetsReplicationEnabled" json:"dataSetsReplicationEnabled,omitempty" vim:"8.0.0.0"`
	// The set of the disks of this VM that are configured for
	// replication.
	Disk []ReplicationInfoDiskSettings `xml:"disk,omitempty" json:"disk,omitempty"`
}

func init() {
	t["ReplicationConfigSpec"] = reflect.TypeOf((*ReplicationConfigSpec)(nil)).Elem()
}

// A ReplicationDiskConfigFault is thrown when there is an issue with
// configuring disk replication properties.
type ReplicationDiskConfigFault struct {
	ReplicationConfigFault

	// The reason for the failure.
	//
	// One of the above.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
	// The virtual machine, for identification purposes.
	//
	// Refers instance of `VirtualMachine`.
	VmRef *ManagedObjectReference `xml:"vmRef,omitempty" json:"vmRef,omitempty"`
	// The disk (device) key in the parent VM for identification
	// purposes.
	Key int32 `xml:"key,omitempty" json:"key,omitempty"`
}

func init() {
	t["ReplicationDiskConfigFault"] = reflect.TypeOf((*ReplicationDiskConfigFault)(nil)).Elem()
}

type ReplicationDiskConfigFaultFault ReplicationDiskConfigFault

func init() {
	t["ReplicationDiskConfigFaultFault"] = reflect.TypeOf((*ReplicationDiskConfigFaultFault)(nil)).Elem()
}

// Base type for Replication-related errors.
type ReplicationFault struct {
	VimFault
}

func init() {
	t["ReplicationFault"] = reflect.TypeOf((*ReplicationFault)(nil)).Elem()
}

type ReplicationFaultFault BaseReplicationFault

func init() {
	t["ReplicationFaultFault"] = reflect.TypeOf((*ReplicationFaultFault)(nil)).Elem()
}

// The identity of a replication group.
//
// # A following well-known ReplicationGroupId
//
// {
//
// faultDomainId: <a validfaultdomainid>
//
// deviceGroupId: ffffffff-ffff-ffff-ffff-ffffffffffff
//
// }
//
// means that VASA provider can create a new ReplicationGroupId
// on demand (this feature may not be supported in the first
// vSphere release that supports VVol replication).
type ReplicationGroupId struct {
	DynamicData

	// ID of the fault domain to which the group belongs.
	//
	// Combined with the fault
	// domain id, the group id is unique. A group may (or may not) have the same
	// id in all the fault domains.
	FaultDomainId FaultDomainId `xml:"faultDomainId" json:"faultDomainId"`
	// Id of the replication device group.
	//
	// A group may have the same (or different) id in each fault
	// domain.
	DeviceGroupId DeviceGroupId `xml:"deviceGroupId" json:"deviceGroupId"`
}

func init() {
	t["ReplicationGroupId"] = reflect.TypeOf((*ReplicationGroupId)(nil)).Elem()
}

// Used to indicate that FT cannot be enabled on a replicated virtual machine
// (returned by `VirtualMachine.QueryFaultToleranceCompatibility`).
type ReplicationIncompatibleWithFT struct {
	ReplicationFault
}

func init() {
	t["ReplicationIncompatibleWithFT"] = reflect.TypeOf((*ReplicationIncompatibleWithFT)(nil)).Elem()
}

type ReplicationIncompatibleWithFTFault ReplicationIncompatibleWithFT

func init() {
	t["ReplicationIncompatibleWithFTFault"] = reflect.TypeOf((*ReplicationIncompatibleWithFTFault)(nil)).Elem()
}

// The ReplicationConfigSpec.DiskSettings object type encapsulates
// the replication properties of a replicated disk of a replicated
// virtual machine.
type ReplicationInfoDiskSettings struct {
	DynamicData

	// The disk's device key in the VM's configuration.
	//
	// Used to
	// uniquely identify the disk to be configured for replication
	// in the primary VM.
	Key int32 `xml:"key" json:"key"`
	// An opaque identifier that uniquely identifies a replicated
	// disk between primary and secondary sites.
	DiskReplicationId string `xml:"diskReplicationId" json:"diskReplicationId"`
}

func init() {
	t["ReplicationInfoDiskSettings"] = reflect.TypeOf((*ReplicationInfoDiskSettings)(nil)).Elem()
}

// A ReplicationInvalidOptions fault is thrown when the options
// string passed contains invalid characters or broken format.
type ReplicationInvalidOptions struct {
	ReplicationFault

	// The invalid options string.
	Options string `xml:"options" json:"options"`
	// Entity, if any, that has invalid options.
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["ReplicationInvalidOptions"] = reflect.TypeOf((*ReplicationInvalidOptions)(nil)).Elem()
}

type ReplicationInvalidOptionsFault ReplicationInvalidOptions

func init() {
	t["ReplicationInvalidOptionsFault"] = reflect.TypeOf((*ReplicationInvalidOptionsFault)(nil)).Elem()
}

// Thrown if the replication module is not loaded in the host.
type ReplicationNotSupportedOnHost struct {
	ReplicationFault
}

func init() {
	t["ReplicationNotSupportedOnHost"] = reflect.TypeOf((*ReplicationNotSupportedOnHost)(nil)).Elem()
}

type ReplicationNotSupportedOnHostFault ReplicationNotSupportedOnHost

func init() {
	t["ReplicationNotSupportedOnHostFault"] = reflect.TypeOf((*ReplicationNotSupportedOnHostFault)(nil)).Elem()
}

type ReplicationSpec struct {
	DynamicData

	// Replication Group id
	ReplicationGroupId ReplicationGroupId `xml:"replicationGroupId" json:"replicationGroupId"`
}

func init() {
	t["ReplicationSpec"] = reflect.TypeOf((*ReplicationSpec)(nil)).Elem()
}

// A ReplicationVmConfigFault is thrown when there is an issue with
// configuring VM-wide replication properties.
type ReplicationVmConfigFault struct {
	ReplicationConfigFault

	// The reason for the failure.
	//
	// One of the above `ReplicationVmConfigFaultReasonForFault_enum`.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
	// The virtual machine, for identification purposes.
	//
	// Refers instance of `VirtualMachine`.
	VmRef *ManagedObjectReference `xml:"vmRef,omitempty" json:"vmRef,omitempty"`
}

func init() {
	t["ReplicationVmConfigFault"] = reflect.TypeOf((*ReplicationVmConfigFault)(nil)).Elem()
}

type ReplicationVmConfigFaultFault ReplicationVmConfigFault

func init() {
	t["ReplicationVmConfigFaultFault"] = reflect.TypeOf((*ReplicationVmConfigFaultFault)(nil)).Elem()
}

// A ReplicationVmFault is thrown when there is an issue with
// an operation performed on a replicated `VirtualMachine`
type ReplicationVmFault struct {
	ReplicationFault

	// The reason for the failure.
	//
	// One of the above.
	Reason string `xml:"reason" json:"reason"`
	// The current `ReplicationVmState_enum` of the
	// `VirtualMachine`
	State string `xml:"state,omitempty" json:"state,omitempty"`
	// The name of the instance currently being created.
	InstanceId string `xml:"instanceId,omitempty" json:"instanceId,omitempty"`
	// The virtual machine, for identification purposes.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
}

func init() {
	t["ReplicationVmFault"] = reflect.TypeOf((*ReplicationVmFault)(nil)).Elem()
}

type ReplicationVmFaultFault BaseReplicationVmFault

func init() {
	t["ReplicationVmFaultFault"] = reflect.TypeOf((*ReplicationVmFaultFault)(nil)).Elem()
}

// A ReplicationVmInProgressFault is thrown when a replication operation
// failed to perform on a `VirtualMachine` because the VM is
// in the middle of another replication activity.
type ReplicationVmInProgressFault struct {
	ReplicationVmFault

	// The requsted activity for VM replication
	RequestedActivity string `xml:"requestedActivity" json:"requestedActivity"`
	// The in-progress activity for VM replication
	InProgressActivity string `xml:"inProgressActivity" json:"inProgressActivity"`
}

func init() {
	t["ReplicationVmInProgressFault"] = reflect.TypeOf((*ReplicationVmInProgressFault)(nil)).Elem()
}

type ReplicationVmInProgressFaultFault ReplicationVmInProgressFault

func init() {
	t["ReplicationVmInProgressFaultFault"] = reflect.TypeOf((*ReplicationVmInProgressFaultFault)(nil)).Elem()
}

// A set of statistics related to the progress of the current
// operation (full sync or lwd).
type ReplicationVmProgressInfo struct {
	DynamicData

	// An estimation of the operation progress as a percentage completed,
	// from 0 to 100.
	Progress int32 `xml:"progress" json:"progress"`
	// Number of bytes transferred so far.
	//
	// For sync operations, this value includes (i.e. counts multiple
	// times) areas that were transferred multiple times (due to stopping
	// and continuing the operation, or for some errors).
	BytesTransferred int64 `xml:"bytesTransferred" json:"bytesTransferred"`
	// The total number of bytes to be transferred.
	//
	// For lwd operations, this is the total size of the disk images that
	// are transferring. This is known from the start and will not change
	// during a lwd operation.
	//
	// For sync operations, this is the total size of the blocks that have
	// been found not to match between the primary and secondary (by
	// comparing checksums). It starts from 0 and grows as the checksum
	// operations advance. The value includes (i.e. counts multiple times)
	// areas that will end up being transferred more than once (due to
	// stopping and continuing the operation, or for some errors).
	BytesToTransfer int64 `xml:"bytesToTransfer" json:"bytesToTransfer"`
	// The total number of bytes to be checksummed, only present for sync
	// tasks.
	//
	// This is the total size of all disks.
	ChecksumTotalBytes int64 `xml:"checksumTotalBytes,omitempty" json:"checksumTotalBytes,omitempty"`
	// The total number of bytes that were checksummed, only present for
	// sync tasks.
	ChecksumComparedBytes int64 `xml:"checksumComparedBytes,omitempty" json:"checksumComparedBytes,omitempty"`
}

func init() {
	t["ReplicationVmProgressInfo"] = reflect.TypeOf((*ReplicationVmProgressInfo)(nil)).Elem()
}

// A RequestCanceled fault is thrown if the user canceled the task.
type RequestCanceled struct {
	RuntimeFault
}

func init() {
	t["RequestCanceled"] = reflect.TypeOf((*RequestCanceled)(nil)).Elem()
}

type RequestCanceledFault RequestCanceled

func init() {
	t["RequestCanceledFault"] = reflect.TypeOf((*RequestCanceledFault)(nil)).Elem()
}

type RescanAllHba RescanAllHbaRequestType

func init() {
	t["RescanAllHba"] = reflect.TypeOf((*RescanAllHba)(nil)).Elem()
}

type RescanAllHbaRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RescanAllHbaRequestType"] = reflect.TypeOf((*RescanAllHbaRequestType)(nil)).Elem()
}

type RescanAllHbaResponse struct {
}

type RescanHba RescanHbaRequestType

func init() {
	t["RescanHba"] = reflect.TypeOf((*RescanHba)(nil)).Elem()
}

// The parameters of `HostStorageSystem.RescanHba`.
type RescanHbaRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device of the host bus adapter.
	HbaDevice string `xml:"hbaDevice" json:"hbaDevice"`
}

func init() {
	t["RescanHbaRequestType"] = reflect.TypeOf((*RescanHbaRequestType)(nil)).Elem()
}

type RescanHbaResponse struct {
}

type RescanVffs RescanVffsRequestType

func init() {
	t["RescanVffs"] = reflect.TypeOf((*RescanVffs)(nil)).Elem()
}

type RescanVffsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RescanVffsRequestType"] = reflect.TypeOf((*RescanVffsRequestType)(nil)).Elem()
}

type RescanVffsResponse struct {
}

type RescanVmfs RescanVmfsRequestType

func init() {
	t["RescanVmfs"] = reflect.TypeOf((*RescanVmfs)(nil)).Elem()
}

type RescanVmfsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RescanVmfsRequestType"] = reflect.TypeOf((*RescanVmfsRequestType)(nil)).Elem()
}

type RescanVmfsResponse struct {
}

type ResetCollector ResetCollectorRequestType

func init() {
	t["ResetCollector"] = reflect.TypeOf((*ResetCollector)(nil)).Elem()
}

type ResetCollectorRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ResetCollectorRequestType"] = reflect.TypeOf((*ResetCollectorRequestType)(nil)).Elem()
}

type ResetCollectorResponse struct {
}

type ResetCounterLevelMapping ResetCounterLevelMappingRequestType

func init() {
	t["ResetCounterLevelMapping"] = reflect.TypeOf((*ResetCounterLevelMapping)(nil)).Elem()
}

// The parameters of `PerformanceManager.ResetCounterLevelMapping`.
type ResetCounterLevelMappingRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// An array of counter ids.
	Counters []int32 `xml:"counters" json:"counters"`
}

func init() {
	t["ResetCounterLevelMappingRequestType"] = reflect.TypeOf((*ResetCounterLevelMappingRequestType)(nil)).Elem()
}

type ResetCounterLevelMappingResponse struct {
}

type ResetEntityPermissions ResetEntityPermissionsRequestType

func init() {
	t["ResetEntityPermissions"] = reflect.TypeOf((*ResetEntityPermissions)(nil)).Elem()
}

// The parameters of `AuthorizationManager.ResetEntityPermissions`.
type ResetEntityPermissionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The entity on which permissions are updated.
	//
	// Required privileges: Authorization.ModifyPermissions
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// The list of Permission objects that define
	// the new rules for access to the entity and
	// potentially entities below it. If the list
	// is empty, all permissions on the entity are removed.
	Permission []Permission `xml:"permission,omitempty" json:"permission,omitempty"`
}

func init() {
	t["ResetEntityPermissionsRequestType"] = reflect.TypeOf((*ResetEntityPermissionsRequestType)(nil)).Elem()
}

type ResetEntityPermissionsResponse struct {
}

type ResetFirmwareToFactoryDefaults ResetFirmwareToFactoryDefaultsRequestType

func init() {
	t["ResetFirmwareToFactoryDefaults"] = reflect.TypeOf((*ResetFirmwareToFactoryDefaults)(nil)).Elem()
}

type ResetFirmwareToFactoryDefaultsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ResetFirmwareToFactoryDefaultsRequestType"] = reflect.TypeOf((*ResetFirmwareToFactoryDefaultsRequestType)(nil)).Elem()
}

type ResetFirmwareToFactoryDefaultsResponse struct {
}

type ResetGuestInformation ResetGuestInformationRequestType

func init() {
	t["ResetGuestInformation"] = reflect.TypeOf((*ResetGuestInformation)(nil)).Elem()
}

type ResetGuestInformationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ResetGuestInformationRequestType"] = reflect.TypeOf((*ResetGuestInformationRequestType)(nil)).Elem()
}

type ResetGuestInformationResponse struct {
}

type ResetListView ResetListViewRequestType

func init() {
	t["ResetListView"] = reflect.TypeOf((*ResetListView)(nil)).Elem()
}

type ResetListViewFromView ResetListViewFromViewRequestType

func init() {
	t["ResetListViewFromView"] = reflect.TypeOf((*ResetListViewFromView)(nil)).Elem()
}

// The parameters of `ListView.ResetListViewFromView`.
type ResetListViewFromViewRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The view to copy objects from.
	//
	// Refers instance of `View`.
	View ManagedObjectReference `xml:"view" json:"view"`
}

func init() {
	t["ResetListViewFromViewRequestType"] = reflect.TypeOf((*ResetListViewFromViewRequestType)(nil)).Elem()
}

type ResetListViewFromViewResponse struct {
}

// The parameters of `ListView.ResetListView`.
type ResetListViewRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The new list of objects.
	//
	// Required privileges: System.View
	Obj []ManagedObjectReference `xml:"obj,omitempty" json:"obj,omitempty"`
}

func init() {
	t["ResetListViewRequestType"] = reflect.TypeOf((*ResetListViewRequestType)(nil)).Elem()
}

type ResetListViewResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ResetSystemHealthInfo ResetSystemHealthInfoRequestType

func init() {
	t["ResetSystemHealthInfo"] = reflect.TypeOf((*ResetSystemHealthInfo)(nil)).Elem()
}

type ResetSystemHealthInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ResetSystemHealthInfoRequestType"] = reflect.TypeOf((*ResetSystemHealthInfoRequestType)(nil)).Elem()
}

type ResetSystemHealthInfoResponse struct {
}

type ResetVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ResetVMRequestType"] = reflect.TypeOf((*ResetVMRequestType)(nil)).Elem()
}

type ResetVM_Task ResetVMRequestType

func init() {
	t["ResetVM_Task"] = reflect.TypeOf((*ResetVM_Task)(nil)).Elem()
}

type ResetVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostDatastoreSystem.ResignatureUnresolvedVmfsVolume_Task`.
type ResignatureUnresolvedVmfsVolumeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A data object that describes what the disk
	// extents to be used for creating the new
	// VMFS volume.
	ResolutionSpec HostUnresolvedVmfsResignatureSpec `xml:"resolutionSpec" json:"resolutionSpec"`
}

func init() {
	t["ResignatureUnresolvedVmfsVolumeRequestType"] = reflect.TypeOf((*ResignatureUnresolvedVmfsVolumeRequestType)(nil)).Elem()
}

type ResignatureUnresolvedVmfsVolume_Task ResignatureUnresolvedVmfsVolumeRequestType

func init() {
	t["ResignatureUnresolvedVmfsVolume_Task"] = reflect.TypeOf((*ResignatureUnresolvedVmfsVolume_Task)(nil)).Elem()
}

type ResignatureUnresolvedVmfsVolume_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `IoFilterManager.ResolveInstallationErrorsOnCluster_Task`.
type ResolveInstallationErrorsOnClusterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// ID of the filter.
	FilterId string `xml:"filterId" json:"filterId"`
	// The cluster.
	//
	// Refers instance of `ClusterComputeResource`.
	Cluster ManagedObjectReference `xml:"cluster" json:"cluster"`
}

func init() {
	t["ResolveInstallationErrorsOnClusterRequestType"] = reflect.TypeOf((*ResolveInstallationErrorsOnClusterRequestType)(nil)).Elem()
}

type ResolveInstallationErrorsOnCluster_Task ResolveInstallationErrorsOnClusterRequestType

func init() {
	t["ResolveInstallationErrorsOnCluster_Task"] = reflect.TypeOf((*ResolveInstallationErrorsOnCluster_Task)(nil)).Elem()
}

type ResolveInstallationErrorsOnCluster_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `IoFilterManager.ResolveInstallationErrorsOnHost_Task`.
type ResolveInstallationErrorsOnHostRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// ID of the filter.
	FilterId string `xml:"filterId" json:"filterId"`
	// The host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["ResolveInstallationErrorsOnHostRequestType"] = reflect.TypeOf((*ResolveInstallationErrorsOnHostRequestType)(nil)).Elem()
}

type ResolveInstallationErrorsOnHost_Task ResolveInstallationErrorsOnHostRequestType

func init() {
	t["ResolveInstallationErrorsOnHost_Task"] = reflect.TypeOf((*ResolveInstallationErrorsOnHost_Task)(nil)).Elem()
}

type ResolveInstallationErrorsOnHost_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ResolveMultipleUnresolvedVmfsVolumes ResolveMultipleUnresolvedVmfsVolumesRequestType

func init() {
	t["ResolveMultipleUnresolvedVmfsVolumes"] = reflect.TypeOf((*ResolveMultipleUnresolvedVmfsVolumes)(nil)).Elem()
}

// The parameters of `HostStorageSystem.ResolveMultipleUnresolvedVmfsVolumesEx_Task`.
type ResolveMultipleUnresolvedVmfsVolumesExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of data object that describes what the disk
	// extents to be used for creating the new
	// VMFS volume.
	ResolutionSpec []HostUnresolvedVmfsResolutionSpec `xml:"resolutionSpec" json:"resolutionSpec"`
}

func init() {
	t["ResolveMultipleUnresolvedVmfsVolumesExRequestType"] = reflect.TypeOf((*ResolveMultipleUnresolvedVmfsVolumesExRequestType)(nil)).Elem()
}

type ResolveMultipleUnresolvedVmfsVolumesEx_Task ResolveMultipleUnresolvedVmfsVolumesExRequestType

func init() {
	t["ResolveMultipleUnresolvedVmfsVolumesEx_Task"] = reflect.TypeOf((*ResolveMultipleUnresolvedVmfsVolumesEx_Task)(nil)).Elem()
}

type ResolveMultipleUnresolvedVmfsVolumesEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostStorageSystem.ResolveMultipleUnresolvedVmfsVolumes`.
type ResolveMultipleUnresolvedVmfsVolumesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of data object that describes what the disk
	// extents to be used for creating the new
	// VMFS volume.
	ResolutionSpec []HostUnresolvedVmfsResolutionSpec `xml:"resolutionSpec" json:"resolutionSpec"`
}

func init() {
	t["ResolveMultipleUnresolvedVmfsVolumesRequestType"] = reflect.TypeOf((*ResolveMultipleUnresolvedVmfsVolumesRequestType)(nil)).Elem()
}

type ResolveMultipleUnresolvedVmfsVolumesResponse struct {
	Returnval []HostUnresolvedVmfsResolutionResult `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The ResourceAllocationInfo data object specifies the reserved resource
// requirement as well as the limit (maximum allowed usage) for a given
// kind of resource.
//
// This is specified for both memory
// allocation (specified in MB) and CPU allocation (specified in MHz).
//
// For a `ResourcePool`, the ResourceAllocationInfo object describes
// both the guaranteed amount of the resource (`ResourceAllocationInfo.reservation`)
// and whether or not it is expandable
// (`ResourceAllocationInfo.expandableReservation`).
// If expandableReservation is true, then the resource pool can grow its reservation
// dynamically by borrowing unreserved resources from its parent resource pool.
// For the methods `ResourcePool.CreateResourcePool`,
// `ResourcePool.CreateVApp` and `ResourcePool.ImportVApp`,
// you must provide values for all properties except overheadLimit; they are not optional.
// (Currently, overheadLimit is for vCenter Server use only.)
//
// If the limit is configured, it must be greater than or equal to the
// reservation.
type ResourceAllocationInfo struct {
	DynamicData

	// Amount of resource that is guaranteed available to the virtual machine or
	// resource pool.
	//
	// Reserved resources are not wasted if they are not used. If
	// the utilization is less than the reservation, the resources can be utilized by
	// other running virtual machines. Units are MB for memory, MHz for CPU.
	Reservation *int64 `xml:"reservation" json:"reservation,omitempty"`
	// In a resource pool with an expandable reservation, the reservation on a resource
	// pool can grow beyond the specified value, if the parent resource pool has
	// unreserved resources.
	//
	// A non-expandable reservation is called a fixed
	// reservation. This property is invalid for virtual machines.
	ExpandableReservation *bool `xml:"expandableReservation" json:"expandableReservation,omitempty"`
	// The utilization of a virtual machine/resource pool will not exceed this limit, even
	// if there are available resources.
	//
	// This is typically used to ensure a consistent
	// performance of virtual machines / resource pools independent of available resources.
	// If set to -1, then there is no fixed limit on resource usage (only bounded by available
	// resources and shares). Units are MB for memory, MHz for CPU.
	Limit *int64 `xml:"limit" json:"limit,omitempty"`
	// Memory shares are used in case of resource contention.
	Shares *SharesInfo `xml:"shares,omitempty" json:"shares,omitempty"`
	// The maximum allowed overhead memory.
	//
	// For a powered on virtual
	// machine, the overhead memory reservation cannot be larger than its
	// overheadLimit. This property is only applicable to powered on
	// virtual machines and is not persisted across reboots. This property
	// is not applicable for resource pools. If set to -1, then there is
	// no limit on reservation. Units are MB.
	//
	// Note: For vCenter Server use only. Not available for other clients
	// at this time.
	// The server will throw an exception if you attempt to set
	// this property.
	OverheadLimit *int64 `xml:"overheadLimit" json:"overheadLimit,omitempty"`
}

func init() {
	t["ResourceAllocationInfo"] = reflect.TypeOf((*ResourceAllocationInfo)(nil)).Elem()
}

// The ResourceAllocationOption data object specifies value ranges and
// default values for `ResourceAllocationInfo`.
type ResourceAllocationOption struct {
	DynamicData

	// Default value and value range for `ResourceAllocationInfo.shares`.
	SharesOption SharesOption `xml:"sharesOption" json:"sharesOption"`
}

func init() {
	t["ResourceAllocationOption"] = reflect.TypeOf((*ResourceAllocationOption)(nil)).Elem()
}

// This data object type is a default value and value range specification
// for `ResourceConfigSpec` object.
type ResourceConfigOption struct {
	DynamicData

	// Resource allocation options for CPU.
	//
	// See also `ResourceAllocationInfo`.
	CpuAllocationOption ResourceAllocationOption `xml:"cpuAllocationOption" json:"cpuAllocationOption"`
	// Resource allocation options for memory.
	//
	// See also `ResourceAllocationInfo`.
	MemoryAllocationOption ResourceAllocationOption `xml:"memoryAllocationOption" json:"memoryAllocationOption"`
}

func init() {
	t["ResourceConfigOption"] = reflect.TypeOf((*ResourceConfigOption)(nil)).Elem()
}

// This data object type is a specification for a set of resources
// allocated to a virtual machine or a resource pool.
type ResourceConfigSpec struct {
	DynamicData

	// Reference to the entity with this resource specification:
	// either a VirtualMachine or a ResourcePool.
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
	// The changeVersion is a unique identifier for a given version
	// of the configuration.
	//
	// Each change to the configuration will
	// update this value. This is typically implemented as an ever
	// increasing count or a time-stamp. However, a client should
	// always treat this as an opaque string.
	//
	// If specified when updating the resource config., the
	// changes will only be applied if the current changeVersion matches the
	// specified changeVersion. This field can be used to guard against updates that
	// has happened between the configInfo was read and until it is applied.
	ChangeVersion string `xml:"changeVersion,omitempty" json:"changeVersion,omitempty"`
	// Timestamp when the resources were last modified.
	//
	// This is ignored when
	// the object is used to update a configuration.
	LastModified *time.Time `xml:"lastModified" json:"lastModified,omitempty"`
	// Resource allocation for CPU.
	CpuAllocation ResourceAllocationInfo `xml:"cpuAllocation" json:"cpuAllocation"`
	// Resource allocation for memory.
	MemoryAllocation ResourceAllocationInfo `xml:"memoryAllocation" json:"memoryAllocation"`
	// Specifies the scaling behavior of the shares of all descendant resource
	// pools under a given resource pool.
	//
	// See `ResourceConfigSpecScaleSharesBehavior_enum` for possible values. If any
	// scaling behavior other than `disabled` is
	// specified, the system will scale the CPU and memory shares allocated to
	// each descendant resource pool with the total shares of all powered on
	// virtual machines under each respective pool. The system will also use the
	// `SharesInfo` set on each descendant resource pool as a
	// multiplier for the scale. If a resource pool's shares are already
	// scalable through the `ResourceConfigSpec.scaleDescendantsShares` setting on an ancestor
	// resource pool, the system will not allow `ResourceConfigSpec.scaleDescendantsShares` to be set on the resource
	// pool. The `ResourcePoolRuntimeInfo.sharesScalable` property
	// indicates whether or not a resource pool's shares are scalable. This
	// property does not apply to virtual machines.
	ScaleDescendantsShares string `xml:"scaleDescendantsShares,omitempty" json:"scaleDescendantsShares,omitempty"`
}

func init() {
	t["ResourceConfigSpec"] = reflect.TypeOf((*ResourceConfigSpec)(nil)).Elem()
}

// A ResourceInUse fault indicating that some error has occurred because a
// resource was in use.
//
// Information about the resource that is in use may
// be supplied.
type ResourceInUse struct {
	VimFault

	// Type of resource that is in use.
	Type string `xml:"type,omitempty" json:"type,omitempty"`
	// Name of the instance of the resource that is in use.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
}

func init() {
	t["ResourceInUse"] = reflect.TypeOf((*ResourceInUse)(nil)).Elem()
}

type ResourceInUseFault BaseResourceInUse

func init() {
	t["ResourceInUseFault"] = reflect.TypeOf((*ResourceInUseFault)(nil)).Elem()
}

// A ResourceNotAvailable fault indicating that some error has occurred because a
// resource was not available.
//
// Information about the resource that is in use may
// be supplied.
type ResourceNotAvailable struct {
	VimFault

	// Type of container that contains the resource.
	ContainerType string `xml:"containerType,omitempty" json:"containerType,omitempty"`
	// Name of container that contains the resource.
	//
	// .
	ContainerName string `xml:"containerName,omitempty" json:"containerName,omitempty"`
	// Type of resource that is not available.
	Type string `xml:"type,omitempty" json:"type,omitempty"`
}

func init() {
	t["ResourceNotAvailable"] = reflect.TypeOf((*ResourceNotAvailable)(nil)).Elem()
}

type ResourceNotAvailableFault ResourceNotAvailable

func init() {
	t["ResourceNotAvailableFault"] = reflect.TypeOf((*ResourceNotAvailableFault)(nil)).Elem()
}

// This event records when a new resource pool is created.
type ResourcePoolCreatedEvent struct {
	ResourcePoolEvent

	// The parent resource pool that new resource pool belongs to.
	Parent ResourcePoolEventArgument `xml:"parent" json:"parent"`
}

func init() {
	t["ResourcePoolCreatedEvent"] = reflect.TypeOf((*ResourcePoolCreatedEvent)(nil)).Elem()
}

// This event records when a resource pool is destroyed.
type ResourcePoolDestroyedEvent struct {
	ResourcePoolEvent
}

func init() {
	t["ResourcePoolDestroyedEvent"] = reflect.TypeOf((*ResourcePoolDestroyedEvent)(nil)).Elem()
}

// This event is the base class for all resource pool events.
type ResourcePoolEvent struct {
	Event

	ResourcePool ResourcePoolEventArgument `xml:"resourcePool" json:"resourcePool"`
}

func init() {
	t["ResourcePoolEvent"] = reflect.TypeOf((*ResourcePoolEvent)(nil)).Elem()
}

// The event argument is a ResourcePool object.
type ResourcePoolEventArgument struct {
	EntityEventArgument

	// The ResourcePool object.
	//
	// Refers instance of `ResourcePool`.
	ResourcePool ManagedObjectReference `xml:"resourcePool" json:"resourcePool"`
}

func init() {
	t["ResourcePoolEventArgument"] = reflect.TypeOf((*ResourcePoolEventArgument)(nil)).Elem()
}

// This event records when a resource pool is moved.
type ResourcePoolMovedEvent struct {
	ResourcePoolEvent

	// The old parent of the resource Pool.
	OldParent ResourcePoolEventArgument `xml:"oldParent" json:"oldParent"`
	// The new parent of the resource Pool.
	NewParent ResourcePoolEventArgument `xml:"newParent" json:"newParent"`
}

func init() {
	t["ResourcePoolMovedEvent"] = reflect.TypeOf((*ResourcePoolMovedEvent)(nil)).Elem()
}

// A set of statistics that are typically updated with near real-time regularity.
//
// These statistics are aggregates of the corresponding statistics of all virtual
// machines in the given resource pool, and unless otherwise noted, only make sense
// when at least one virtual machine in the given resource pool is powered on.
// This data object type does not support notification, for scalability reasons.
// Therefore, changes in QuickStats do not generate property collector updates. To
// monitor statistics values, use the statistics and alarms modules instead.
type ResourcePoolQuickStats struct {
	DynamicData

	// Basic CPU performance statistics, in MHz.
	OverallCpuUsage int64 `xml:"overallCpuUsage,omitempty" json:"overallCpuUsage,omitempty"`
	// Basic CPU performance statistics, in MHz.
	OverallCpuDemand int64 `xml:"overallCpuDemand,omitempty" json:"overallCpuDemand,omitempty"`
	// Guest memory utilization statistics, in MB.
	//
	// This
	// is also known as active guest memory. The number
	// can be between 0 and the configured memory size of
	// a virtual machine.
	GuestMemoryUsage int64 `xml:"guestMemoryUsage,omitempty" json:"guestMemoryUsage,omitempty"`
	// Host memory utilization statistics, in MB.
	//
	// This
	// is also known as consummed host memory. This is between 0 and
	// the configured resource limit. Valid while a virtual machine is
	// running. This includes the overhead memory of a virtual machine.
	HostMemoryUsage int64 `xml:"hostMemoryUsage,omitempty" json:"hostMemoryUsage,omitempty"`
	// This is the amount of CPU resource, in MHz, that this VM is entitled to, as
	// calculated by DRS.
	//
	// Valid only for a VM managed by DRS.
	DistributedCpuEntitlement int64 `xml:"distributedCpuEntitlement,omitempty" json:"distributedCpuEntitlement,omitempty"`
	// This is the amount of memory, in MB, that this VM is entitled to, as
	// calculated by DRS.
	//
	// Valid only for a VM managed by DRS.
	DistributedMemoryEntitlement int64 `xml:"distributedMemoryEntitlement,omitempty" json:"distributedMemoryEntitlement,omitempty"`
	// The static CPU resource entitlement for a virtual machine.
	//
	// This value is
	// calculated based on this virtual machine's resource reservations, shares
	// and limit, and doesn't take into account current usage. This is the worst
	// case CPU allocation for this virtual machine, that is, the amount of CPU
	// resource this virtual machine would receive if all virtual machines running
	// in the cluster went to maximum consumption. Units are MHz.
	StaticCpuEntitlement int32 `xml:"staticCpuEntitlement,omitempty" json:"staticCpuEntitlement,omitempty"`
	// The static memory resource entitlement for a virtual machine.
	//
	// This value is
	// calculated based on this virtual machine's resource reservations, shares
	// and limit, and doesn't take into account current usage. This is the worst
	// case memory allocation for this virtual machine, that is, the amount of
	// memory this virtual machine would receive if all virtual machines running
	// in the cluster went to maximum consumption. Units are MB.
	StaticMemoryEntitlement int32 `xml:"staticMemoryEntitlement,omitempty" json:"staticMemoryEntitlement,omitempty"`
	// The portion of memory, in MB, that is granted to a virtual machine from
	// non-shared host memory.
	PrivateMemory int64 `xml:"privateMemory,omitempty" json:"privateMemory,omitempty"`
	// The portion of memory, in MB, that is granted to a virtual machine from host
	// memory that is shared between VMs.
	SharedMemory int64 `xml:"sharedMemory,omitempty" json:"sharedMemory,omitempty"`
	// The portion of memory, in MB, that is granted to a virtual machine from the
	// host's swap space.
	//
	// This is a sign that there is memory pressure on the host.
	SwappedMemory int64 `xml:"swappedMemory,omitempty" json:"swappedMemory,omitempty"`
	// The size of the balloon driver in a virtual machine, in MB.
	//
	// The host will
	// inflate the balloon driver to reclaim physical memory from a virtual machine.
	// This is a sign that there is memory pressure on the host.
	BalloonedMemory int64 `xml:"balloonedMemory,omitempty" json:"balloonedMemory,omitempty"`
	// The amount of memory resource (in MB) that will be used by
	// a virtual machine above its guest memory requirements.
	//
	// This value is set if and only if a virtual machine is registered
	// on a host that supports memory resource allocation features.
	// For powered off VMs, this is the minimum overhead required to
	// power on the VM on the registered host.
	// For powered on VMs, this is the current overhead reservation, a
	// value which is almost always larger than the minimum overhead, and
	// which grows with time.
	//
	// See also `HostSystem.QueryMemoryOverheadEx`.
	OverheadMemory int64 `xml:"overheadMemory,omitempty" json:"overheadMemory,omitempty"`
	// The amount of overhead memory, in MB, currently being consumed to run a VM.
	//
	// This value is limited by the overhead memory reservation for a VM, stored
	// in `ResourcePoolQuickStats.overheadMemory`.
	ConsumedOverheadMemory int64 `xml:"consumedOverheadMemory,omitempty" json:"consumedOverheadMemory,omitempty"`
	// The amount of compressed memory currently consumed by VM, in KB.
	CompressedMemory int64 `xml:"compressedMemory,omitempty" json:"compressedMemory,omitempty"`
}

func init() {
	t["ResourcePoolQuickStats"] = reflect.TypeOf((*ResourcePoolQuickStats)(nil)).Elem()
}

// This event records when a resource pool configuration is changed.
type ResourcePoolReconfiguredEvent struct {
	ResourcePoolEvent

	// The configuration values changed during the reconfiguration.
	ConfigChanges *ChangesInfoEventArgument `xml:"configChanges,omitempty" json:"configChanges,omitempty"`
}

func init() {
	t["ResourcePoolReconfiguredEvent"] = reflect.TypeOf((*ResourcePoolReconfiguredEvent)(nil)).Elem()
}

// Specifies the resource usage for either memory
// or CPU.
//
// For CPU the unit is MHz, for memory the unit is bytes.
//
// In the typical case, where a resourcepool is in a consistent state,
// unreservedForVm will be equal to unreservedForPool. Hence, we
// can simply say talk about unreserved resources.
//
// If the reservation on the resource pool is not expandable, then
// the following is true:
//
//	reservation = reservationUsed + unreserved
//
// If the reservation on the resource pool is expandable, then
// the following is true:
//
//	reservation + parent.unreserved = reservationUsed + unreserved
type ResourcePoolResourceUsage struct {
	DynamicData

	// Total amount of resources that have been used to satisfy the
	// reservation requirements of all descendants of this
	// resource pool (includes both resource pools and virtual
	// machines).
	ReservationUsed int64 `xml:"reservationUsed" json:"reservationUsed"`
	// Total amount of resources that have been used to satisfy the reservation
	// requirements of running virtual machines in this resource pool or any of its
	// child resource pools.
	ReservationUsedForVm int64 `xml:"reservationUsedForVm" json:"reservationUsedForVm"`
	// Total amount of resources available to satisfy a reservation
	// for a child resource pool.
	//
	// In the undercommitted state, this is
	// limited by the capacity at the root node. In the overcommitted case,
	// this could be higher since we do not perform the dynamic capacity
	// checks.
	UnreservedForPool int64 `xml:"unreservedForPool" json:"unreservedForPool"`
	// Total amount of resources available to satisfy a reservation for
	// a child virtual machine.
	//
	// In general, this should be the same as
	// `ResourcePoolResourceUsage.unreservedForPool`. However, in the overcommitted case, this
	// is limited by the remaining available resources at the root
	// node.
	UnreservedForVm int64 `xml:"unreservedForVm" json:"unreservedForVm"`
	// Deprecated as of vSphere API 6.5.
	// Use `ResourcePoolQuickStats.overallCpuUsage` and
	// `ResourcePoolQuickStats.hostMemoryUsage`.
	//
	// Close to real-time resource usage of all running child virtual
	// machines, including virtual machines in child resource pools.
	OverallUsage int64 `xml:"overallUsage" json:"overallUsage"`
	// Current upper-bound on usage.
	//
	// The upper-bound is based on the limit configured
	// on this resource pool, as well as limits configured on any parent resource
	// pool.
	MaxUsage int64 `xml:"maxUsage" json:"maxUsage"`
}

func init() {
	t["ResourcePoolResourceUsage"] = reflect.TypeOf((*ResourcePoolResourceUsage)(nil)).Elem()
}

// Current runtime resource usage and state of the resource pool
type ResourcePoolRuntimeInfo struct {
	DynamicData

	// Runtime resource usage for memory.
	//
	// Values are in bytes.
	Memory ResourcePoolResourceUsage `xml:"memory" json:"memory"`
	// Runtime resource usage for CPU.
	//
	// Values are in Mhz.
	Cpu ResourcePoolResourceUsage `xml:"cpu" json:"cpu"`
	// Deprecated as of vSphere API 6.5.
	// Use `ManagedEntity.overallStatus`.
	//
	// Overall health of the tree.
	//
	// See header for description of various
	// statuses and when they are set.
	OverallStatus ManagedEntityStatus `xml:"overallStatus" json:"overallStatus"`
	// The scaling behavior of the shares of a given resource pool.
	//
	// See `ResourceConfigSpecScaleSharesBehavior_enum` for possible values. The
	// system will automatically compute this property based on the `ResourceConfigSpec.scaleDescendantsShares` setting on every
	// ancestor resource pool. This property does not apply to virtual
	// machines.
	SharesScalable string `xml:"sharesScalable,omitempty" json:"sharesScalable,omitempty"`
}

func init() {
	t["ResourcePoolRuntimeInfo"] = reflect.TypeOf((*ResourcePoolRuntimeInfo)(nil)).Elem()
}

// This data object type encapsulates a typical set of resource
// pool information that is useful for list views and summary pages.
type ResourcePoolSummary struct {
	DynamicData

	// Name of resource pool.
	Name string `xml:"name" json:"name"`
	// Current configuration of the resource pool.
	Config ResourceConfigSpec `xml:"config" json:"config"`
	// Current runtime state of the resource pool.
	Runtime ResourcePoolRuntimeInfo `xml:"runtime" json:"runtime"`
	// A set of statistics that are typically updated with near real-time regularity.
	//
	// This data object type does not support notification, for scalability reasons.
	// Therefore, changes in QuickStats do not generate property collector updates.
	// To monitor statistics values, use the statistics and alarms modules instead.
	QuickStats *ResourcePoolQuickStats `xml:"quickStats,omitempty" json:"quickStats,omitempty"`
	// Total configured memory of all virtual machines in the resource pool, in MB.
	ConfiguredMemoryMB int32 `xml:"configuredMemoryMB,omitempty" json:"configuredMemoryMB,omitempty"`
}

func init() {
	t["ResourcePoolSummary"] = reflect.TypeOf((*ResourcePoolSummary)(nil)).Elem()
}

// This event records when a conflict with a resource pool's resource
// configuration is detected.
type ResourceViolatedEvent struct {
	ResourcePoolEvent
}

func init() {
	t["ResourceViolatedEvent"] = reflect.TypeOf((*ResourceViolatedEvent)(nil)).Elem()
}

type RestartService RestartServiceRequestType

func init() {
	t["RestartService"] = reflect.TypeOf((*RestartService)(nil)).Elem()
}

type RestartServiceConsoleVirtualNic RestartServiceConsoleVirtualNicRequestType

func init() {
	t["RestartServiceConsoleVirtualNic"] = reflect.TypeOf((*RestartServiceConsoleVirtualNic)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.RestartServiceConsoleVirtualNic`.
type RestartServiceConsoleVirtualNicRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	Device string                 `xml:"device" json:"device"`
}

func init() {
	t["RestartServiceConsoleVirtualNicRequestType"] = reflect.TypeOf((*RestartServiceConsoleVirtualNicRequestType)(nil)).Elem()
}

type RestartServiceConsoleVirtualNicResponse struct {
}

// The parameters of `HostServiceSystem.RestartService`.
type RestartServiceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Service identifier
	// (`HostServiceSystem.serviceInfo*.*HostServiceInfo.service*.*HostService.key`).
	Id string `xml:"id" json:"id"`
}

func init() {
	t["RestartServiceRequestType"] = reflect.TypeOf((*RestartServiceRequestType)(nil)).Elem()
}

type RestartServiceResponse struct {
}

type RestoreFirmwareConfiguration RestoreFirmwareConfigurationRequestType

func init() {
	t["RestoreFirmwareConfiguration"] = reflect.TypeOf((*RestoreFirmwareConfiguration)(nil)).Elem()
}

// The parameters of `HostFirmwareSystem.RestoreFirmwareConfiguration`.
type RestoreFirmwareConfigurationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Forces application of the configuration even if the bundle
	// is mismatched.
	Force bool `xml:"force" json:"force"`
}

func init() {
	t["RestoreFirmwareConfigurationRequestType"] = reflect.TypeOf((*RestoreFirmwareConfigurationRequestType)(nil)).Elem()
}

type RestoreFirmwareConfigurationResponse struct {
}

// This fault is thrown when an operation cannot complete because of some
// restriction set by the server administrator.
type RestrictedByAdministrator struct {
	RuntimeFault

	Details string `xml:"details" json:"details"`
}

func init() {
	t["RestrictedByAdministrator"] = reflect.TypeOf((*RestrictedByAdministrator)(nil)).Elem()
}

type RestrictedByAdministratorFault RestrictedByAdministrator

func init() {
	t["RestrictedByAdministratorFault"] = reflect.TypeOf((*RestrictedByAdministratorFault)(nil)).Elem()
}

// Thrown when the caller is not permitted to perform the specified
// operation due to product versioning restrictions.
type RestrictedVersion struct {
	SecurityError
}

func init() {
	t["RestrictedVersion"] = reflect.TypeOf((*RestrictedVersion)(nil)).Elem()
}

type RestrictedVersionFault RestrictedVersion

func init() {
	t["RestrictedVersionFault"] = reflect.TypeOf((*RestrictedVersionFault)(nil)).Elem()
}

type RetrieveAllPermissions RetrieveAllPermissionsRequestType

func init() {
	t["RetrieveAllPermissions"] = reflect.TypeOf((*RetrieveAllPermissions)(nil)).Elem()
}

type RetrieveAllPermissionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveAllPermissionsRequestType"] = reflect.TypeOf((*RetrieveAllPermissionsRequestType)(nil)).Elem()
}

type RetrieveAllPermissionsResponse struct {
	Returnval []Permission `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveAnswerFile RetrieveAnswerFileRequestType

func init() {
	t["RetrieveAnswerFile"] = reflect.TypeOf((*RetrieveAnswerFile)(nil)).Elem()
}

type RetrieveAnswerFileForProfile RetrieveAnswerFileForProfileRequestType

func init() {
	t["RetrieveAnswerFileForProfile"] = reflect.TypeOf((*RetrieveAnswerFileForProfile)(nil)).Elem()
}

// The parameters of `HostProfileManager.RetrieveAnswerFileForProfile`.
type RetrieveAnswerFileForProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Host with which the answer file is associated.
	//
	// Required privileges: Profile.Edit
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Profile configuration used to generate answer file
	ApplyProfile HostApplyProfile `xml:"applyProfile" json:"applyProfile"`
}

func init() {
	t["RetrieveAnswerFileForProfileRequestType"] = reflect.TypeOf((*RetrieveAnswerFileForProfileRequestType)(nil)).Elem()
}

type RetrieveAnswerFileForProfileResponse struct {
	Returnval *AnswerFile `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The parameters of `HostProfileManager.RetrieveAnswerFile`.
type RetrieveAnswerFileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Host with which the answer file is associated.
	//
	// Required privileges: Profile.Edit
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["RetrieveAnswerFileRequestType"] = reflect.TypeOf((*RetrieveAnswerFileRequestType)(nil)).Elem()
}

type RetrieveAnswerFileResponse struct {
	Returnval *AnswerFile `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveArgumentDescription RetrieveArgumentDescriptionRequestType

func init() {
	t["RetrieveArgumentDescription"] = reflect.TypeOf((*RetrieveArgumentDescription)(nil)).Elem()
}

// The parameters of `EventManager.RetrieveArgumentDescription`.
type RetrieveArgumentDescriptionRequestType struct {
	This        ManagedObjectReference `xml:"_this" json:"-"`
	EventTypeId string                 `xml:"eventTypeId" json:"eventTypeId"`
}

func init() {
	t["RetrieveArgumentDescriptionRequestType"] = reflect.TypeOf((*RetrieveArgumentDescriptionRequestType)(nil)).Elem()
}

type RetrieveArgumentDescriptionResponse struct {
	Returnval []EventArgDesc `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveCertificateInfoList RetrieveCertificateInfoListRequestType

func init() {
	t["RetrieveCertificateInfoList"] = reflect.TypeOf((*RetrieveCertificateInfoList)(nil)).Elem()
}

type RetrieveCertificateInfoListRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveCertificateInfoListRequestType"] = reflect.TypeOf((*RetrieveCertificateInfoListRequestType)(nil)).Elem()
}

type RetrieveCertificateInfoListResponse struct {
	Returnval []HostCertificateManagerCertificateInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveClientCert RetrieveClientCertRequestType

func init() {
	t["RetrieveClientCert"] = reflect.TypeOf((*RetrieveClientCert)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.RetrieveClientCert`.
type RetrieveClientCertRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP cluster.
	Cluster KeyProviderId `xml:"cluster" json:"cluster"`
}

func init() {
	t["RetrieveClientCertRequestType"] = reflect.TypeOf((*RetrieveClientCertRequestType)(nil)).Elem()
}

type RetrieveClientCertResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type RetrieveClientCsr RetrieveClientCsrRequestType

func init() {
	t["RetrieveClientCsr"] = reflect.TypeOf((*RetrieveClientCsr)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.RetrieveClientCsr`.
type RetrieveClientCsrRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP cluster.
	Cluster KeyProviderId `xml:"cluster" json:"cluster"`
}

func init() {
	t["RetrieveClientCsrRequestType"] = reflect.TypeOf((*RetrieveClientCsrRequestType)(nil)).Elem()
}

type RetrieveClientCsrResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type RetrieveDasAdvancedRuntimeInfo RetrieveDasAdvancedRuntimeInfoRequestType

func init() {
	t["RetrieveDasAdvancedRuntimeInfo"] = reflect.TypeOf((*RetrieveDasAdvancedRuntimeInfo)(nil)).Elem()
}

type RetrieveDasAdvancedRuntimeInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveDasAdvancedRuntimeInfoRequestType"] = reflect.TypeOf((*RetrieveDasAdvancedRuntimeInfoRequestType)(nil)).Elem()
}

type RetrieveDasAdvancedRuntimeInfoResponse struct {
	Returnval BaseClusterDasAdvancedRuntimeInfo `xml:"returnval,omitempty,typeattr" json:"returnval,omitempty"`
}

type RetrieveDescription RetrieveDescriptionRequestType

func init() {
	t["RetrieveDescription"] = reflect.TypeOf((*RetrieveDescription)(nil)).Elem()
}

type RetrieveDescriptionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveDescriptionRequestType"] = reflect.TypeOf((*RetrieveDescriptionRequestType)(nil)).Elem()
}

type RetrieveDescriptionResponse struct {
	Returnval *ProfileDescription `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveDiskPartitionInfo RetrieveDiskPartitionInfoRequestType

func init() {
	t["RetrieveDiskPartitionInfo"] = reflect.TypeOf((*RetrieveDiskPartitionInfo)(nil)).Elem()
}

// The parameters of `HostStorageSystem.RetrieveDiskPartitionInfo`.
type RetrieveDiskPartitionInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// An array of device path names that identify disks.
	// See `ScsiDisk`.
	DevicePath []string `xml:"devicePath" json:"devicePath"`
}

func init() {
	t["RetrieveDiskPartitionInfoRequestType"] = reflect.TypeOf((*RetrieveDiskPartitionInfoRequestType)(nil)).Elem()
}

type RetrieveDiskPartitionInfoResponse struct {
	Returnval []HostDiskPartitionInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveDynamicPassthroughInfo RetrieveDynamicPassthroughInfoRequestType

func init() {
	t["RetrieveDynamicPassthroughInfo"] = reflect.TypeOf((*RetrieveDynamicPassthroughInfo)(nil)).Elem()
}

type RetrieveDynamicPassthroughInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveDynamicPassthroughInfoRequestType"] = reflect.TypeOf((*RetrieveDynamicPassthroughInfoRequestType)(nil)).Elem()
}

type RetrieveDynamicPassthroughInfoResponse struct {
	Returnval []VirtualMachineDynamicPassthroughInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveEntityPermissions RetrieveEntityPermissionsRequestType

func init() {
	t["RetrieveEntityPermissions"] = reflect.TypeOf((*RetrieveEntityPermissions)(nil)).Elem()
}

// The parameters of `AuthorizationManager.RetrieveEntityPermissions`.
type RetrieveEntityPermissionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Required privileges: System.Read
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// Whether or not to include propagating permissions
	// defined by parent entities.
	Inherited bool `xml:"inherited" json:"inherited"`
}

func init() {
	t["RetrieveEntityPermissionsRequestType"] = reflect.TypeOf((*RetrieveEntityPermissionsRequestType)(nil)).Elem()
}

type RetrieveEntityPermissionsResponse struct {
	Returnval []Permission `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveEntityScheduledTask RetrieveEntityScheduledTaskRequestType

func init() {
	t["RetrieveEntityScheduledTask"] = reflect.TypeOf((*RetrieveEntityScheduledTask)(nil)).Elem()
}

// The parameters of `ScheduledTaskManager.RetrieveEntityScheduledTask`.
type RetrieveEntityScheduledTaskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The entity. If null, all scheduled tasks are returned
	// for visible entities.
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["RetrieveEntityScheduledTaskRequestType"] = reflect.TypeOf((*RetrieveEntityScheduledTaskRequestType)(nil)).Elem()
}

type RetrieveEntityScheduledTaskResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveFreeEpcMemory RetrieveFreeEpcMemoryRequestType

func init() {
	t["RetrieveFreeEpcMemory"] = reflect.TypeOf((*RetrieveFreeEpcMemory)(nil)).Elem()
}

type RetrieveFreeEpcMemoryRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveFreeEpcMemoryRequestType"] = reflect.TypeOf((*RetrieveFreeEpcMemoryRequestType)(nil)).Elem()
}

type RetrieveFreeEpcMemoryResponse struct {
	Returnval int64 `xml:"returnval" json:"returnval"`
}

type RetrieveHardwareUptime RetrieveHardwareUptimeRequestType

func init() {
	t["RetrieveHardwareUptime"] = reflect.TypeOf((*RetrieveHardwareUptime)(nil)).Elem()
}

type RetrieveHardwareUptimeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveHardwareUptimeRequestType"] = reflect.TypeOf((*RetrieveHardwareUptimeRequestType)(nil)).Elem()
}

type RetrieveHardwareUptimeResponse struct {
	Returnval int64 `xml:"returnval" json:"returnval"`
}

type RetrieveHostAccessControlEntries RetrieveHostAccessControlEntriesRequestType

func init() {
	t["RetrieveHostAccessControlEntries"] = reflect.TypeOf((*RetrieveHostAccessControlEntries)(nil)).Elem()
}

type RetrieveHostAccessControlEntriesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveHostAccessControlEntriesRequestType"] = reflect.TypeOf((*RetrieveHostAccessControlEntriesRequestType)(nil)).Elem()
}

type RetrieveHostAccessControlEntriesResponse struct {
	Returnval []HostAccessControlEntry `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveHostCustomizations RetrieveHostCustomizationsRequestType

func init() {
	t["RetrieveHostCustomizations"] = reflect.TypeOf((*RetrieveHostCustomizations)(nil)).Elem()
}

type RetrieveHostCustomizationsForProfile RetrieveHostCustomizationsForProfileRequestType

func init() {
	t["RetrieveHostCustomizationsForProfile"] = reflect.TypeOf((*RetrieveHostCustomizationsForProfile)(nil)).Elem()
}

// The parameters of `HostProfileManager.RetrieveHostCustomizationsForProfile`.
type RetrieveHostCustomizationsForProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Hosts with which the answer files are associated.
	//
	// Required privileges: Profile.Edit
	//
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts,omitempty" json:"hosts,omitempty"`
	// Profile configuration used to generate answer file
	ApplyProfile HostApplyProfile `xml:"applyProfile" json:"applyProfile"`
}

func init() {
	t["RetrieveHostCustomizationsForProfileRequestType"] = reflect.TypeOf((*RetrieveHostCustomizationsForProfileRequestType)(nil)).Elem()
}

type RetrieveHostCustomizationsForProfileResponse struct {
	Returnval []StructuredCustomizations `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The parameters of `HostProfileManager.RetrieveHostCustomizations`.
type RetrieveHostCustomizationsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Hosts with which the answer files are associated.
	//
	// Required privileges: Profile.Edit
	//
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts,omitempty" json:"hosts,omitempty"`
}

func init() {
	t["RetrieveHostCustomizationsRequestType"] = reflect.TypeOf((*RetrieveHostCustomizationsRequestType)(nil)).Elem()
}

type RetrieveHostCustomizationsResponse struct {
	Returnval []StructuredCustomizations `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveHostSpecification RetrieveHostSpecificationRequestType

func init() {
	t["RetrieveHostSpecification"] = reflect.TypeOf((*RetrieveHostSpecification)(nil)).Elem()
}

// The parameters of `HostSpecificationManager.RetrieveHostSpecification`.
type RetrieveHostSpecificationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The specified host whose host specification will be retrieved.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Whether retrieve from the host.
	FromHost bool `xml:"fromHost" json:"fromHost"`
}

func init() {
	t["RetrieveHostSpecificationRequestType"] = reflect.TypeOf((*RetrieveHostSpecificationRequestType)(nil)).Elem()
}

type RetrieveHostSpecificationResponse struct {
	Returnval HostSpecification `xml:"returnval" json:"returnval"`
}

type RetrieveKmipServerCert RetrieveKmipServerCertRequestType

func init() {
	t["RetrieveKmipServerCert"] = reflect.TypeOf((*RetrieveKmipServerCert)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.RetrieveKmipServerCert`.
type RetrieveKmipServerCertRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP cluster in which the server is placed
	// or will be created.
	KeyProvider KeyProviderId `xml:"keyProvider" json:"keyProvider"`
	// \[in\] KMIP server.
	Server KmipServerInfo `xml:"server" json:"server"`
}

func init() {
	t["RetrieveKmipServerCertRequestType"] = reflect.TypeOf((*RetrieveKmipServerCertRequestType)(nil)).Elem()
}

type RetrieveKmipServerCertResponse struct {
	Returnval CryptoManagerKmipServerCertInfo `xml:"returnval" json:"returnval"`
}

// The parameters of `CryptoManagerKmip.RetrieveKmipServersStatus_Task`.
type RetrieveKmipServersStatusRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP clusters and their servers.
	Clusters []KmipClusterInfo `xml:"clusters,omitempty" json:"clusters,omitempty"`
}

func init() {
	t["RetrieveKmipServersStatusRequestType"] = reflect.TypeOf((*RetrieveKmipServersStatusRequestType)(nil)).Elem()
}

type RetrieveKmipServersStatus_Task RetrieveKmipServersStatusRequestType

func init() {
	t["RetrieveKmipServersStatus_Task"] = reflect.TypeOf((*RetrieveKmipServersStatus_Task)(nil)).Elem()
}

type RetrieveKmipServersStatus_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type RetrieveObjectScheduledTask RetrieveObjectScheduledTaskRequestType

func init() {
	t["RetrieveObjectScheduledTask"] = reflect.TypeOf((*RetrieveObjectScheduledTask)(nil)).Elem()
}

// The parameters of `ScheduledTaskManager.RetrieveObjectScheduledTask`.
type RetrieveObjectScheduledTaskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The object. If not specified, all scheduled tasks are returned
	// for visible entities and visible ManagedObjects.
	Obj *ManagedObjectReference `xml:"obj,omitempty" json:"obj,omitempty"`
}

func init() {
	t["RetrieveObjectScheduledTaskRequestType"] = reflect.TypeOf((*RetrieveObjectScheduledTaskRequestType)(nil)).Elem()
}

type RetrieveObjectScheduledTaskResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// Options for `PropertyCollector.RetrievePropertiesEx`.
type RetrieveOptions struct {
	DynamicData

	// The maximum number of `ObjectContent` data
	// objects that should be returned in a single result from `PropertyCollector.RetrievePropertiesEx`.
	//
	// An unset value indicates that there is no maximum. In this
	// case `PropertyCollector` policy may still limit the number
	// of objects. Any remaining objects may be retrieved with `PropertyCollector.ContinueRetrievePropertiesEx`.
	//
	// A positive value causes `PropertyCollector.RetrievePropertiesEx` to
	// suspend the retrieval when the count of objects reaches the
	// specified maximum. `PropertyCollector` policy may still
	// limit the count to something less than `RetrieveOptions.maxObjects`. Any remaining
	// objects may be retrieved with `PropertyCollector.ContinueRetrievePropertiesEx`.
	//
	// A value less than or equal to 0 is illegal.
	MaxObjects int32 `xml:"maxObjects,omitempty" json:"maxObjects,omitempty"`
}

func init() {
	t["RetrieveOptions"] = reflect.TypeOf((*RetrieveOptions)(nil)).Elem()
}

type RetrieveProductComponents RetrieveProductComponentsRequestType

func init() {
	t["RetrieveProductComponents"] = reflect.TypeOf((*RetrieveProductComponents)(nil)).Elem()
}

type RetrieveProductComponentsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveProductComponentsRequestType"] = reflect.TypeOf((*RetrieveProductComponentsRequestType)(nil)).Elem()
}

type RetrieveProductComponentsResponse struct {
	Returnval []ProductComponentInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveProperties RetrievePropertiesRequestType

func init() {
	t["RetrieveProperties"] = reflect.TypeOf((*RetrieveProperties)(nil)).Elem()
}

type RetrievePropertiesEx RetrievePropertiesExRequestType

func init() {
	t["RetrievePropertiesEx"] = reflect.TypeOf((*RetrievePropertiesEx)(nil)).Elem()
}

// The parameters of `PropertyCollector.RetrievePropertiesEx`.
type RetrievePropertiesExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specifies the properties to retrieve.
	SpecSet []PropertyFilterSpec `xml:"specSet" json:"specSet"`
	// Additional method options. If omitted, equivalent to an options
	// argument with no fields set.
	Options RetrieveOptions `xml:"options" json:"options"`
}

func init() {
	t["RetrievePropertiesExRequestType"] = reflect.TypeOf((*RetrievePropertiesExRequestType)(nil)).Elem()
}

type RetrievePropertiesExResponse struct {
	Returnval *RetrieveResult `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The parameters of `PropertyCollector.RetrieveProperties`.
type RetrievePropertiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specifies the properties to retrieve.
	SpecSet []PropertyFilterSpec `xml:"specSet" json:"specSet"`
}

func init() {
	t["RetrievePropertiesRequestType"] = reflect.TypeOf((*RetrievePropertiesRequestType)(nil)).Elem()
}

type RetrievePropertiesResponse struct {
	Returnval []ObjectContent `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// Result of `PropertyCollector.RetrievePropertiesEx` and `PropertyCollector.ContinueRetrievePropertiesEx`
type RetrieveResult struct {
	DynamicData

	// A token used to retrieve further retrieve results.
	//
	// If set, the token should be passed to `PropertyCollector.ContinueRetrievePropertiesEx` to retrieve more results. Each token
	// may be passed to continueRetrievePropertiesEx only once, and only in
	// the same session in which it was returned and to the same
	// `PropertyCollector` object that returned it.
	//
	// If unset, there are no further results to retrieve after this
	// `RetrieveResult`.
	Token string `xml:"token,omitempty" json:"token,omitempty"`
	// retrieved objects.
	Objects []ObjectContent `xml:"objects" json:"objects"`
}

func init() {
	t["RetrieveResult"] = reflect.TypeOf((*RetrieveResult)(nil)).Elem()
}

type RetrieveRolePermissions RetrieveRolePermissionsRequestType

func init() {
	t["RetrieveRolePermissions"] = reflect.TypeOf((*RetrieveRolePermissions)(nil)).Elem()
}

// The parameters of `AuthorizationManager.RetrieveRolePermissions`.
type RetrieveRolePermissionsRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	RoleId int32                  `xml:"roleId" json:"roleId"`
}

func init() {
	t["RetrieveRolePermissionsRequestType"] = reflect.TypeOf((*RetrieveRolePermissionsRequestType)(nil)).Elem()
}

type RetrieveRolePermissionsResponse struct {
	Returnval []Permission `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveSelfSignedClientCert RetrieveSelfSignedClientCertRequestType

func init() {
	t["RetrieveSelfSignedClientCert"] = reflect.TypeOf((*RetrieveSelfSignedClientCert)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.RetrieveSelfSignedClientCert`.
type RetrieveSelfSignedClientCertRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP cluster.
	Cluster KeyProviderId `xml:"cluster" json:"cluster"`
}

func init() {
	t["RetrieveSelfSignedClientCertRequestType"] = reflect.TypeOf((*RetrieveSelfSignedClientCertRequestType)(nil)).Elem()
}

type RetrieveSelfSignedClientCertResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type RetrieveServiceContent RetrieveServiceContentRequestType

func init() {
	t["RetrieveServiceContent"] = reflect.TypeOf((*RetrieveServiceContent)(nil)).Elem()
}

type RetrieveServiceContentRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveServiceContentRequestType"] = reflect.TypeOf((*RetrieveServiceContentRequestType)(nil)).Elem()
}

type RetrieveServiceContentResponse struct {
	Returnval ServiceContent `xml:"returnval" json:"returnval"`
}

type RetrieveServiceProviderEntities RetrieveServiceProviderEntitiesRequestType

func init() {
	t["RetrieveServiceProviderEntities"] = reflect.TypeOf((*RetrieveServiceProviderEntities)(nil)).Elem()
}

type RetrieveServiceProviderEntitiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveServiceProviderEntitiesRequestType"] = reflect.TypeOf((*RetrieveServiceProviderEntitiesRequestType)(nil)).Elem()
}

type RetrieveServiceProviderEntitiesResponse struct {
	Returnval []ManagedObjectReference `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveSnapshotDetails RetrieveSnapshotDetailsRequestType

func init() {
	t["RetrieveSnapshotDetails"] = reflect.TypeOf((*RetrieveSnapshotDetails)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.RetrieveSnapshotDetails`.
type RetrieveSnapshotDetailsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The ID of the snapshot of a virtual storage object.
	SnapshotId ID `xml:"snapshotId" json:"snapshotId"`
}

func init() {
	t["RetrieveSnapshotDetailsRequestType"] = reflect.TypeOf((*RetrieveSnapshotDetailsRequestType)(nil)).Elem()
}

type RetrieveSnapshotDetailsResponse struct {
	Returnval VStorageObjectSnapshotDetails `xml:"returnval" json:"returnval"`
}

type RetrieveSnapshotInfo RetrieveSnapshotInfoRequestType

func init() {
	t["RetrieveSnapshotInfo"] = reflect.TypeOf((*RetrieveSnapshotInfo)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.RetrieveSnapshotInfo`.
type RetrieveSnapshotInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["RetrieveSnapshotInfoRequestType"] = reflect.TypeOf((*RetrieveSnapshotInfoRequestType)(nil)).Elem()
}

type RetrieveSnapshotInfoResponse struct {
	Returnval VStorageObjectSnapshotInfo `xml:"returnval" json:"returnval"`
}

type RetrieveUserGroups RetrieveUserGroupsRequestType

func init() {
	t["RetrieveUserGroups"] = reflect.TypeOf((*RetrieveUserGroups)(nil)).Elem()
}

// The parameters of `UserDirectory.RetrieveUserGroups`.
type RetrieveUserGroupsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Domain to be searched. If not set, then the method searches
	// the local machine.
	Domain string `xml:"domain,omitempty" json:"domain,omitempty"`
	// Case insensitive substring used to filter results;
	// the search string is compared to the login and full name for users,
	// and the name and description for groups. Leave
	// this blank to match all users.
	SearchStr string `xml:"searchStr" json:"searchStr"`
	// If present, the returned list contains only users or groups
	// that directly belong to the specified group. Users or groups that
	// have indirect membership will not be included in the list.
	BelongsToGroup string `xml:"belongsToGroup,omitempty" json:"belongsToGroup,omitempty"`
	// If present, the returned list contains only groups that directly
	// contain the specified user. Groups that indirectly contain
	// the user will not be included in the list.
	BelongsToUser string `xml:"belongsToUser,omitempty" json:"belongsToUser,omitempty"`
	// Indicates the searchStr passed should match a user or
	// group name exactly.
	ExactMatch bool `xml:"exactMatch" json:"exactMatch"`
	// True, if users should be included in the result.
	FindUsers bool `xml:"findUsers" json:"findUsers"`
	// True, if groups should be included in the result.
	FindGroups bool `xml:"findGroups" json:"findGroups"`
}

func init() {
	t["RetrieveUserGroupsRequestType"] = reflect.TypeOf((*RetrieveUserGroupsRequestType)(nil)).Elem()
}

type RetrieveUserGroupsResponse struct {
	Returnval []BaseUserSearchResult `xml:"returnval,omitempty,typeattr" json:"returnval,omitempty"`
}

type RetrieveVStorageInfrastructureObjectPolicy RetrieveVStorageInfrastructureObjectPolicyRequestType

func init() {
	t["RetrieveVStorageInfrastructureObjectPolicy"] = reflect.TypeOf((*RetrieveVStorageInfrastructureObjectPolicy)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.RetrieveVStorageInfrastructureObjectPolicy`.
type RetrieveVStorageInfrastructureObjectPolicyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Datastore on which policy needs to be retrieved.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["RetrieveVStorageInfrastructureObjectPolicyRequestType"] = reflect.TypeOf((*RetrieveVStorageInfrastructureObjectPolicyRequestType)(nil)).Elem()
}

type RetrieveVStorageInfrastructureObjectPolicyResponse struct {
	Returnval []VslmInfrastructureObjectPolicy `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// This data object is a pair of the virtural storage object id and
// its datastore.
type RetrieveVStorageObjSpec struct {
	DynamicData

	// ID of this virtual storage object.
	Id ID `xml:"id" json:"id"`
	// Datastore where the object is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["RetrieveVStorageObjSpec"] = reflect.TypeOf((*RetrieveVStorageObjSpec)(nil)).Elem()
}

type RetrieveVStorageObject RetrieveVStorageObjectRequestType

func init() {
	t["RetrieveVStorageObject"] = reflect.TypeOf((*RetrieveVStorageObject)(nil)).Elem()
}

type RetrieveVStorageObjectAssociations RetrieveVStorageObjectAssociationsRequestType

func init() {
	t["RetrieveVStorageObjectAssociations"] = reflect.TypeOf((*RetrieveVStorageObjectAssociations)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.RetrieveVStorageObjectAssociations`.
type RetrieveVStorageObjectAssociationsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The IDs of the virtual storage objects of the query.
	Ids []RetrieveVStorageObjSpec `xml:"ids,omitempty" json:"ids,omitempty"`
}

func init() {
	t["RetrieveVStorageObjectAssociationsRequestType"] = reflect.TypeOf((*RetrieveVStorageObjectAssociationsRequestType)(nil)).Elem()
}

type RetrieveVStorageObjectAssociationsResponse struct {
	Returnval []VStorageObjectAssociations `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The parameters of `VcenterVStorageObjectManager.RetrieveVStorageObject`.
type RetrieveVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object to be retrieved.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual storage object is
	// located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// Flags indicating the FCD information to be
	// retrieved. If diskInfoFlags is unset, then all FCD
	// information will be retrieved. See
	// `vslmDiskInfoFlag_enum` for the list of
	// supported values.
	DiskInfoFlags []string `xml:"diskInfoFlags,omitempty" json:"diskInfoFlags,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["RetrieveVStorageObjectRequestType"] = reflect.TypeOf((*RetrieveVStorageObjectRequestType)(nil)).Elem()
}

type RetrieveVStorageObjectResponse struct {
	Returnval VStorageObject `xml:"returnval" json:"returnval"`
}

type RetrieveVStorageObjectState RetrieveVStorageObjectStateRequestType

func init() {
	t["RetrieveVStorageObjectState"] = reflect.TypeOf((*RetrieveVStorageObjectState)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.RetrieveVStorageObjectState`.
type RetrieveVStorageObjectStateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object the state to be retrieved.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual storage object is
	// located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["RetrieveVStorageObjectStateRequestType"] = reflect.TypeOf((*RetrieveVStorageObjectStateRequestType)(nil)).Elem()
}

type RetrieveVStorageObjectStateResponse struct {
	Returnval VStorageObjectStateInfo `xml:"returnval" json:"returnval"`
}

type RetrieveVendorDeviceGroupInfo RetrieveVendorDeviceGroupInfoRequestType

func init() {
	t["RetrieveVendorDeviceGroupInfo"] = reflect.TypeOf((*RetrieveVendorDeviceGroupInfo)(nil)).Elem()
}

type RetrieveVendorDeviceGroupInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveVendorDeviceGroupInfoRequestType"] = reflect.TypeOf((*RetrieveVendorDeviceGroupInfoRequestType)(nil)).Elem()
}

type RetrieveVendorDeviceGroupInfoResponse struct {
	Returnval []VirtualMachineVendorDeviceGroupInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveVgpuDeviceInfo RetrieveVgpuDeviceInfoRequestType

func init() {
	t["RetrieveVgpuDeviceInfo"] = reflect.TypeOf((*RetrieveVgpuDeviceInfo)(nil)).Elem()
}

type RetrieveVgpuDeviceInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveVgpuDeviceInfoRequestType"] = reflect.TypeOf((*RetrieveVgpuDeviceInfoRequestType)(nil)).Elem()
}

type RetrieveVgpuDeviceInfoResponse struct {
	Returnval []VirtualMachineVgpuDeviceInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type RetrieveVgpuProfileInfo RetrieveVgpuProfileInfoRequestType

func init() {
	t["RetrieveVgpuProfileInfo"] = reflect.TypeOf((*RetrieveVgpuProfileInfo)(nil)).Elem()
}

type RetrieveVgpuProfileInfoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RetrieveVgpuProfileInfoRequestType"] = reflect.TypeOf((*RetrieveVgpuProfileInfoRequestType)(nil)).Elem()
}

type RetrieveVgpuProfileInfoResponse struct {
	Returnval []VirtualMachineVgpuProfileInfo `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The parameters of `VirtualMachine.RevertToCurrentSnapshot_Task`.
type RevertToCurrentSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// (optional) Choice of host for the virtual machine,
	// in case this operation causes the virtual machine to power on.
	//
	// If a snapshot was taken while a virtual machine was powered on,
	// and this operation is invoked after the virtual machine was
	// powered off, the operation causes the virtual machine to power
	// on to reach the snapshot state. This parameter can be used to
	// specify a choice of host where the virtual machine should power
	// on.
	//
	// If this parameter is not set, and the vBalance feature is
	// configured for automatic load balancing, a host is
	// automatically selected. Otherwise, the virtual machine keeps
	// its existing host affiliation.
	//
	// This is not supported for virtual machines associated with hosts on ESX 2.x
	// servers.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// (optional) If set to true, the virtual
	// machine will not be powered on regardless of the power state when
	// the current snapshot was created. Default to false.
	SuppressPowerOn *bool `xml:"suppressPowerOn" json:"suppressPowerOn,omitempty"`
}

func init() {
	t["RevertToCurrentSnapshotRequestType"] = reflect.TypeOf((*RevertToCurrentSnapshotRequestType)(nil)).Elem()
}

type RevertToCurrentSnapshot_Task RevertToCurrentSnapshotRequestType

func init() {
	t["RevertToCurrentSnapshot_Task"] = reflect.TypeOf((*RevertToCurrentSnapshot_Task)(nil)).Elem()
}

type RevertToCurrentSnapshot_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachineSnapshot.RevertToSnapshot_Task`.
type RevertToSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// (optional) Choice of host for the virtual machine, in case this
	// operation causes the virtual machine to power on.
	//
	// If a snapshot was taken while a virtual machine was powered on, and this operation
	// is invoked after the virtual machine was powered off, the operation causes the
	// virtual machine to power on to reach the snapshot state. This parameter can be
	// used to specify a choice of host where the virtual machine should power on.
	//
	// If this parameter is not set and the vBalance feature is configured for automatic
	// load balancing, a host is automatically selected. Otherwise, the virtual machine
	// keeps its existing host affiliation.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// (optional) If set to true, the virtual
	// machine will not be powered on regardless of the power state when
	// the snapshot was created. Default to false.
	SuppressPowerOn *bool `xml:"suppressPowerOn" json:"suppressPowerOn,omitempty"`
}

func init() {
	t["RevertToSnapshotRequestType"] = reflect.TypeOf((*RevertToSnapshotRequestType)(nil)).Elem()
}

type RevertToSnapshot_Task RevertToSnapshotRequestType

func init() {
	t["RevertToSnapshot_Task"] = reflect.TypeOf((*RevertToSnapshot_Task)(nil)).Elem()
}

type RevertToSnapshot_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VStorageObjectManagerBase.RevertVStorageObjectEx_Task`.
type RevertVStorageObjectExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The ID of the snapshot of a virtual storage object.
	SnapshotId ID `xml:"snapshotId" json:"snapshotId"`
}

func init() {
	t["RevertVStorageObjectExRequestType"] = reflect.TypeOf((*RevertVStorageObjectExRequestType)(nil)).Elem()
	minAPIVersionForType["RevertVStorageObjectExRequestType"] = "8.0.2.0"
}

type RevertVStorageObjectEx_Task RevertVStorageObjectExRequestType

func init() {
	t["RevertVStorageObjectEx_Task"] = reflect.TypeOf((*RevertVStorageObjectEx_Task)(nil)).Elem()
}

type RevertVStorageObjectEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VcenterVStorageObjectManager.RevertVStorageObject_Task`.
type RevertVStorageObjectRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The ID of the snapshot of a virtual storage object.
	SnapshotId ID `xml:"snapshotId" json:"snapshotId"`
}

func init() {
	t["RevertVStorageObjectRequestType"] = reflect.TypeOf((*RevertVStorageObjectRequestType)(nil)).Elem()
}

type RevertVStorageObject_Task RevertVStorageObjectRequestType

func init() {
	t["RevertVStorageObject_Task"] = reflect.TypeOf((*RevertVStorageObject_Task)(nil)).Elem()
}

type RevertVStorageObject_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type RewindCollector RewindCollectorRequestType

func init() {
	t["RewindCollector"] = reflect.TypeOf((*RewindCollector)(nil)).Elem()
}

type RewindCollectorRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RewindCollectorRequestType"] = reflect.TypeOf((*RewindCollectorRequestType)(nil)).Elem()
}

type RewindCollectorResponse struct {
}

// This event records the creation of a role.
type RoleAddedEvent struct {
	RoleEvent

	// The privileges granted to the role.
	PrivilegeList []string `xml:"privilegeList,omitempty" json:"privilegeList,omitempty"`
}

func init() {
	t["RoleAddedEvent"] = reflect.TypeOf((*RoleAddedEvent)(nil)).Elem()
}

// This event records a role operation.
type RoleEvent struct {
	AuthorizationEvent

	// The associated role.
	Role RoleEventArgument `xml:"role" json:"role"`
}

func init() {
	t["RoleEvent"] = reflect.TypeOf((*RoleEvent)(nil)).Elem()
}

// The event argument is a Role object.
type RoleEventArgument struct {
	EventArgument

	// The ID of the role.
	RoleId int32 `xml:"roleId" json:"roleId"`
	// The name of the role.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["RoleEventArgument"] = reflect.TypeOf((*RoleEventArgument)(nil)).Elem()
}

// This class records the removal of a role.
type RoleRemovedEvent struct {
	RoleEvent
}

func init() {
	t["RoleRemovedEvent"] = reflect.TypeOf((*RoleRemovedEvent)(nil)).Elem()
}

// This event records the creation of a role.
type RoleUpdatedEvent struct {
	RoleEvent

	// The privileges granted to the role.
	PrivilegeList []string `xml:"privilegeList,omitempty" json:"privilegeList,omitempty"`
	// The name of the previous role.
	PrevRoleName string `xml:"prevRoleName,omitempty" json:"prevRoleName,omitempty"`
	// The privileges added to the role.
	PrivilegesAdded []string `xml:"privilegesAdded,omitempty" json:"privilegesAdded,omitempty"`
	// The privileges removed from the role.
	PrivilegesRemoved []string `xml:"privilegesRemoved,omitempty" json:"privilegesRemoved,omitempty"`
}

func init() {
	t["RoleUpdatedEvent"] = reflect.TypeOf((*RoleUpdatedEvent)(nil)).Elem()
}

// This event is generated when network configuration rollback
// occurs on a host due configuration change that disconnected
// the host from vSphere server
type RollbackEvent struct {
	DvsEvent

	// The host on which rollback happened
	HostName string `xml:"hostName" json:"hostName"`
	// The API method that was rolled back
	MethodName string `xml:"methodName,omitempty" json:"methodName,omitempty"`
}

func init() {
	t["RollbackEvent"] = reflect.TypeOf((*RollbackEvent)(nil)).Elem()
}

// Thrown if a Rollback operation fails
type RollbackFailure struct {
	DvsFault

	// The entity name on which rollback failed
	EntityName string `xml:"entityName" json:"entityName"`
	// The entity type on which rollback failed
	EntityType string `xml:"entityType" json:"entityType"`
}

func init() {
	t["RollbackFailure"] = reflect.TypeOf((*RollbackFailure)(nil)).Elem()
}

type RollbackFailureFault RollbackFailure

func init() {
	t["RollbackFailureFault"] = reflect.TypeOf((*RollbackFailureFault)(nil)).Elem()
}

// The virtual machine if powered on, would violate an
// affinity/anti-affinity rule.
//
// In this case, the VM can still be powered
// on manually by a user who knows what they are doing, but VirtualCenter
// will never automatically move or power on a VM such that it triggers
// the violation.
type RuleViolation struct {
	VmConfigFault

	// The host that the virtual machine can not be powered on without
	// violate a rule.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The rule that is violated.
	//
	// It can be an affinity or anti-affinity rule.
	Rule BaseClusterRuleInfo `xml:"rule,omitempty,typeattr" json:"rule,omitempty"`
}

func init() {
	t["RuleViolation"] = reflect.TypeOf((*RuleViolation)(nil)).Elem()
}

type RuleViolationFault RuleViolation

func init() {
	t["RuleViolationFault"] = reflect.TypeOf((*RuleViolationFault)(nil)).Elem()
}

type RunScheduledTask RunScheduledTaskRequestType

func init() {
	t["RunScheduledTask"] = reflect.TypeOf((*RunScheduledTask)(nil)).Elem()
}

type RunScheduledTaskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["RunScheduledTaskRequestType"] = reflect.TypeOf((*RunScheduledTaskRequestType)(nil)).Elem()
}

type RunScheduledTaskResponse struct {
}

// This data object type specifies a script that is triggered by an alarm.
//
// You can use any elements of the
// `ActionParameter` enumerated list
// as part of your script to provide information available at runtime.
type RunScriptAction struct {
	Action

	// The fully-qualified path to a shell script that runs on the
	// VirtualCenter server as a result of an alarm.
	Script string `xml:"script" json:"script"`
}

func init() {
	t["RunScriptAction"] = reflect.TypeOf((*RunScriptAction)(nil)).Elem()
}

type RunVsanPhysicalDiskDiagnostics RunVsanPhysicalDiskDiagnosticsRequestType

func init() {
	t["RunVsanPhysicalDiskDiagnostics"] = reflect.TypeOf((*RunVsanPhysicalDiskDiagnostics)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.RunVsanPhysicalDiskDiagnostics`.
type RunVsanPhysicalDiskDiagnosticsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// List of VSAN disk UUIDs. If specified restricts the
	// diagnostics run to VSAN disks present in the provided list.
	Disks []string `xml:"disks,omitempty" json:"disks,omitempty"`
}

func init() {
	t["RunVsanPhysicalDiskDiagnosticsRequestType"] = reflect.TypeOf((*RunVsanPhysicalDiskDiagnosticsRequestType)(nil)).Elem()
}

type RunVsanPhysicalDiskDiagnosticsResponse struct {
	Returnval []HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult `xml:"returnval" json:"returnval"`
}

// The base data object type for all runtime faults that can be
// thrown by a method.
type RuntimeFault struct {
	MethodFault
}

func init() {
	t["RuntimeFault"] = reflect.TypeOf((*RuntimeFault)(nil)).Elem()
}

type RuntimeFaultFault BaseRuntimeFault

func init() {
	t["RuntimeFaultFault"] = reflect.TypeOf((*RuntimeFaultFault)(nil)).Elem()
}

// SAMLTokenAuthentication contains the information necessary to authenticate
// within a guest using a SAML bearer token.
//
// SAML token authentication relies on a guest alias that associates a guest
// account with the subject and certificate
// encoded in a SAML token obtained from the VMware SSO Server.
//   - Use the `GuestAliasManager`.
//     `GuestAliasManager.AddGuestAlias` method to create a guest
//     alias.
//   - Use a SAMLTokenAuthentication object for the
//     auth parameter to guest operations methods.
//
// After you have created an alias, you can use SAML token authentication
// for guest operations methods.
// Do not use SAML token authentication for the
// `GuestAuthManager.AcquireCredentialsInGuest` and
// `GuestAuthManager.ReleaseCredentialsInGuest` methods.
type SAMLTokenAuthentication struct {
	GuestAuthentication

	// The SAML bearer token.
	Token string `xml:"token" json:"token"`
	// This is the guest user to be associated with the authentication.
	//
	// If none is specified, a guest dependent mapping will decide what
	// user account is applied.
	Username string `xml:"username,omitempty" json:"username,omitempty"`
}

func init() {
	t["SAMLTokenAuthentication"] = reflect.TypeOf((*SAMLTokenAuthentication)(nil)).Elem()
}

// An empty data object which can be used as the base class for data objects
// outside VIM namespace which have to be proxied through vCenter opaquely.
//
// For example, vSan configuration spec will extend from this which will
// allow HCI API to pass the spec to set up vSan on the cluster.
type SDDCBase struct {
	DynamicData
}

func init() {
	t["SDDCBase"] = reflect.TypeOf((*SDDCBase)(nil)).Elem()
}

// A SSLDisabledFault fault occurs when a host does not have ssl enabled.
type SSLDisabledFault struct {
	HostConnectFault
}

func init() {
	t["SSLDisabledFault"] = reflect.TypeOf((*SSLDisabledFault)(nil)).Elem()
}

type SSLDisabledFaultFault SSLDisabledFault

func init() {
	t["SSLDisabledFaultFault"] = reflect.TypeOf((*SSLDisabledFaultFault)(nil)).Elem()
}

// SSLVerifyFault is thrown by the host connect method if the VC
// server could not verify the authenticity of the host's SSL
// certificate.
//
// Currently, we do not distinguish the various possible reasons why
// the certificate could not be verified because we don't provide a
// way for the user to overwrite these reasons other than turning off
// SSL certificate verification completely.
// The only exception is the case when the certificate was rejected
// because it was self-signed. This is the most likely case when the
// user may want to overwrite the behavior by specifying the
// certificate's thumbprint in the ConnectSpec the next time the user
// connects to the host.
type SSLVerifyFault struct {
	HostConnectFault

	// Whether the host's certificate was self signed
	SelfSigned bool `xml:"selfSigned" json:"selfSigned"`
	// The thumbprint of the host's certificate.
	//
	// This field is optional since vSphere 8.0u2.
	Thumbprint string `xml:"thumbprint,omitempty" json:"thumbprint,omitempty"`
}

func init() {
	t["SSLVerifyFault"] = reflect.TypeOf((*SSLVerifyFault)(nil)).Elem()
}

type SSLVerifyFaultFault SSLVerifyFault

func init() {
	t["SSLVerifyFaultFault"] = reflect.TypeOf((*SSLVerifyFaultFault)(nil)).Elem()
}

// SSPIAuthentication contains the information necessary to
// initiate a ticketed authentication session in the guest
// using SSPI credentials.
//
// The ticketed session is not stateless and stores state inside of the guest.
//
// To use SSPIAuthentication, populate sspiToken with a base64 encoded SSPI token.
// Then call `GuestAuthManager.AcquireCredentialsInGuest` with
// the SSPIAuthentication object and no sessionID.
// After issuing the `GuestAuthManager.AcquireCredentialsInGuest` call, a
// `GuestAuthenticationChallenge` will be thrown.
// Use the serverChallenge sspiToken in `GuestAuthenticationChallenge`
// to generate the proper SSPI response token.
// Populate an SSPIAuthentication object with the base64 encoded SSPI response token, and
// call `GuestAuthManager.AcquireCredentialsInGuest` with the SSPIAuthentication object and
// the sessionID found in `GuestAuthenticationChallenge`.
//
// Successful authentication will result in a `TicketedSessionAuthentication`
// object being returned. You can use the `TicketedSessionAuthentication` in any
// guest operations function call. You should NOT attempt to use SSPIAuthentication in any guest
// operations function call.
//
// When you no longer need the `TicketedSessionAuthentication` object, you should
// call `GuestAuthManager.ReleaseCredentialsInGuest` to free associated resources
// and session data.
//
// Usage notes: SSPI authentication has the same limitations as a duplicated primary token obtained
// from the Windows API function LogonUser with the LOGON32\_LOGON\_NETWORK logon type. This will affect
// programs started with `GuestProcessManager.StartProgramInGuest`. For example, launched
// programs will be unable to use WMI functions unless the "Remote Enable" privilege is enabled for
// the user. Similarly, access to network resources may fail due to the limitations of the token.
type SSPIAuthentication struct {
	GuestAuthentication

	// This contains a base64 encoded SSPI Token.
	SspiToken string `xml:"sspiToken" json:"sspiToken"`
}

func init() {
	t["SSPIAuthentication"] = reflect.TypeOf((*SSPIAuthentication)(nil)).Elem()
}

// Thrown during SSPI pass-through authentication if further
// negotiation is required.
type SSPIChallenge struct {
	VimFault

	// The opaque server response token, base-64 encoded.
	Base64Token string `xml:"base64Token" json:"base64Token"`
}

func init() {
	t["SSPIChallenge"] = reflect.TypeOf((*SSPIChallenge)(nil)).Elem()
}

type SSPIChallengeFault SSPIChallenge

func init() {
	t["SSPIChallengeFault"] = reflect.TypeOf((*SSPIChallengeFault)(nil)).Elem()
}

// The parameters of `HostPatchManager.ScanHostPatch_Task`.
type ScanHostPatchRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Location of the repository that contains the
	// bulletin depot. The depot must be organized as a flat
	// collection of bulletins with each one being a folder named
	// after the bulletin ID. Each folder must contain the full
	// update metadata.
	Repository HostPatchManagerLocator `xml:"repository" json:"repository"`
	// The updates to scan. Wildcards can be used to specify
	// the update IDs. The wildcards will be expanded to include all
	// updates whose IDs match the specified wildcard and whose metadata
	// is available in the repository. Specifying no update is
	// equivalent to a wildcard "\*". In this case all updates available
	// in the repository will be scanned.
	UpdateID []string `xml:"updateID,omitempty" json:"updateID,omitempty"`
}

func init() {
	t["ScanHostPatchRequestType"] = reflect.TypeOf((*ScanHostPatchRequestType)(nil)).Elem()
}

// The parameters of `HostPatchManager.ScanHostPatchV2_Task`.
type ScanHostPatchV2RequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// a list of urls pointing to metadata.zip.
	MetaUrls []string `xml:"metaUrls,omitempty" json:"metaUrls,omitempty"`
	// a list of urls pointing to an "offline" bundle. It is not supported in 5.0 or later.
	BundleUrls []string                                   `xml:"bundleUrls,omitempty" json:"bundleUrls,omitempty"`
	Spec       *HostPatchManagerPatchManagerOperationSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["ScanHostPatchV2RequestType"] = reflect.TypeOf((*ScanHostPatchV2RequestType)(nil)).Elem()
}

type ScanHostPatchV2_Task ScanHostPatchV2RequestType

func init() {
	t["ScanHostPatchV2_Task"] = reflect.TypeOf((*ScanHostPatchV2_Task)(nil)).Elem()
}

type ScanHostPatchV2_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ScanHostPatch_Task ScanHostPatchRequestType

func init() {
	t["ScanHostPatch_Task"] = reflect.TypeOf((*ScanHostPatch_Task)(nil)).Elem()
}

type ScanHostPatch_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ScheduleReconcileDatastoreInventory ScheduleReconcileDatastoreInventoryRequestType

func init() {
	t["ScheduleReconcileDatastoreInventory"] = reflect.TypeOf((*ScheduleReconcileDatastoreInventory)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.ScheduleReconcileDatastoreInventory`.
type ScheduleReconcileDatastoreInventoryRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datastore that needs to be reconciled.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
}

func init() {
	t["ScheduleReconcileDatastoreInventoryRequestType"] = reflect.TypeOf((*ScheduleReconcileDatastoreInventoryRequestType)(nil)).Elem()
}

type ScheduleReconcileDatastoreInventoryResponse struct {
}

// Data object type containing settings for the scheduled hardware upgrades.
type ScheduledHardwareUpgradeInfo struct {
	DynamicData

	// Scheduled hardware upgrade policy setting for the virtual machine.
	//
	// See also `ScheduledHardwareUpgradeInfoHardwareUpgradePolicy_enum`.
	UpgradePolicy string `xml:"upgradePolicy,omitempty" json:"upgradePolicy,omitempty"`
	// Key for target hardware version to be used on next scheduled upgrade
	// in the format of `VirtualMachineConfigOptionDescriptor.key`.
	VersionKey string `xml:"versionKey,omitempty" json:"versionKey,omitempty"`
	// Status for last attempt to run scheduled hardware upgrade.
	//
	// See also `ScheduledHardwareUpgradeInfoHardwareUpgradeStatus_enum`.
	ScheduledHardwareUpgradeStatus string `xml:"scheduledHardwareUpgradeStatus,omitempty" json:"scheduledHardwareUpgradeStatus,omitempty"`
	// Contains information about the failure of last attempt to run
	// scheduled hardware upgrade.
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["ScheduledHardwareUpgradeInfo"] = reflect.TypeOf((*ScheduledHardwareUpgradeInfo)(nil)).Elem()
}

// This event records the completion of a scheduled task.
type ScheduledTaskCompletedEvent struct {
	ScheduledTaskEvent
}

func init() {
	t["ScheduledTaskCompletedEvent"] = reflect.TypeOf((*ScheduledTaskCompletedEvent)(nil)).Elem()
}

// This event records the creation of a scheduled task.
type ScheduledTaskCreatedEvent struct {
	ScheduledTaskEvent
}

func init() {
	t["ScheduledTaskCreatedEvent"] = reflect.TypeOf((*ScheduledTaskCreatedEvent)(nil)).Elem()
}

// Static strings for scheduled tasks.
//
// These strings are locale-specific.
type ScheduledTaskDescription struct {
	DynamicData

	// Action class descriptions for a scheduled task.
	Action []BaseTypeDescription `xml:"action,typeattr" json:"action"`
	// Scheduler class description details.
	SchedulerInfo []ScheduledTaskDetail `xml:"schedulerInfo" json:"schedulerInfo"`
	// *TaskInfo State enum*
	State []BaseElementDescription `xml:"state,typeattr" json:"state"`
	// *MonthlyByWeekdayTaskScheduler Days of the week enum description*
	DayOfWeek []BaseElementDescription `xml:"dayOfWeek,typeattr" json:"dayOfWeek"`
	// *MonthlyByWeekdayTaskScheduler Week of the month enum description*
	WeekOfMonth []BaseElementDescription `xml:"weekOfMonth,typeattr" json:"weekOfMonth"`
}

func init() {
	t["ScheduledTaskDescription"] = reflect.TypeOf((*ScheduledTaskDescription)(nil)).Elem()
}

// Descriptive detail for each scheduler type.
type ScheduledTaskDetail struct {
	TypeDescription

	// Scheduler frequency description.
	Frequency string `xml:"frequency" json:"frequency"`
}

func init() {
	t["ScheduledTaskDetail"] = reflect.TypeOf((*ScheduledTaskDetail)(nil)).Elem()
}

// This event records the sending of a notification via email for a scheduled task.
type ScheduledTaskEmailCompletedEvent struct {
	ScheduledTaskEvent

	// The destination email address.
	To string `xml:"to" json:"to"`
}

func init() {
	t["ScheduledTaskEmailCompletedEvent"] = reflect.TypeOf((*ScheduledTaskEmailCompletedEvent)(nil)).Elem()
}

// This event records the failure of an attempt to send a notification via email
// for a scheduled task.
type ScheduledTaskEmailFailedEvent struct {
	ScheduledTaskEvent

	// The destination email address.
	To string `xml:"to" json:"to"`
	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["ScheduledTaskEmailFailedEvent"] = reflect.TypeOf((*ScheduledTaskEmailFailedEvent)(nil)).Elem()
}

// These events are scheduled task events.
type ScheduledTaskEvent struct {
	Event

	// The scheduled task object.
	ScheduledTask ScheduledTaskEventArgument `xml:"scheduledTask" json:"scheduledTask"`
	// The entity on which the scheduled task registered.
	Entity ManagedEntityEventArgument `xml:"entity" json:"entity"`
}

func init() {
	t["ScheduledTaskEvent"] = reflect.TypeOf((*ScheduledTaskEvent)(nil)).Elem()
}

// The event argument is a scheduled task object.
type ScheduledTaskEventArgument struct {
	EntityEventArgument

	// The scheduled task object.
	//
	// Refers instance of `ScheduledTask`.
	ScheduledTask ManagedObjectReference `xml:"scheduledTask" json:"scheduledTask"`
}

func init() {
	t["ScheduledTaskEventArgument"] = reflect.TypeOf((*ScheduledTaskEventArgument)(nil)).Elem()
}

// This event records the failure of a scheduled task.
type ScheduledTaskFailedEvent struct {
	ScheduledTaskEvent

	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["ScheduledTaskFailedEvent"] = reflect.TypeOf((*ScheduledTaskFailedEvent)(nil)).Elem()
}

// The scheduled task details.
type ScheduledTaskInfo struct {
	ScheduledTaskSpec

	// Scheduled task object.
	//
	// Refers instance of `ScheduledTask`.
	ScheduledTask ManagedObjectReference `xml:"scheduledTask" json:"scheduledTask"`
	// The entity on which related events will be logged.
	//
	// If the task is scheduled on a ManagedEntity, this
	// field will also reflect the same ManagedEntity.
	// If task is scheduled on a ManagedObject, this field
	// will have information about the entity on which
	// the events will be logged on behalf of the ManagedObject.
	// ManagedObject itself will be denoted by `ScheduledTaskInfo.taskObject`
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// The time the scheduled task is created or modified.
	LastModifiedTime time.Time `xml:"lastModifiedTime" json:"lastModifiedTime"`
	// Last user that modified the scheduled task.
	LastModifiedUser string `xml:"lastModifiedUser" json:"lastModifiedUser"`
	// The next time the scheduled task will run.
	NextRunTime *time.Time `xml:"nextRunTime" json:"nextRunTime,omitempty"`
	// The last time the scheduled task ran.
	PrevRunTime *time.Time `xml:"prevRunTime" json:"prevRunTime,omitempty"`
	// Scheduled task state.
	State TaskInfoState `xml:"state" json:"state"`
	// The fault code when the scheduled task state is "error".
	Error *LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
	// The operation result when the scheduled task state is "success".
	Result AnyType `xml:"result,omitempty,typeattr" json:"result,omitempty"`
	// The task progress when the scheduled task state is "running".
	Progress int32 `xml:"progress,omitempty" json:"progress,omitempty"`
	// The running task instance when the scheduled task state is "running".
	//
	// Refers instance of `Task`.
	ActiveTask *ManagedObjectReference `xml:"activeTask,omitempty" json:"activeTask,omitempty"`
	// The object on which the scheduled task is defined.
	//
	// This field will have information about either the
	// ManagedEntity or the ManagedObject on which the scheduled
	// task is defined.
	TaskObject *ManagedObjectReference `xml:"taskObject,omitempty" json:"taskObject,omitempty"`
}

func init() {
	t["ScheduledTaskInfo"] = reflect.TypeOf((*ScheduledTaskInfo)(nil)).Elem()
}

// This event records the reconfiguration of a scheduled task.
type ScheduledTaskReconfiguredEvent struct {
	ScheduledTaskEvent

	// The configuration values changed during the reconfiguration.
	ConfigChanges *ChangesInfoEventArgument `xml:"configChanges,omitempty" json:"configChanges,omitempty"`
}

func init() {
	t["ScheduledTaskReconfiguredEvent"] = reflect.TypeOf((*ScheduledTaskReconfiguredEvent)(nil)).Elem()
}

// This event records the removal of a scheduled task.
type ScheduledTaskRemovedEvent struct {
	ScheduledTaskEvent
}

func init() {
	t["ScheduledTaskRemovedEvent"] = reflect.TypeOf((*ScheduledTaskRemovedEvent)(nil)).Elem()
}

// Parameters for scheduled task creation.
type ScheduledTaskSpec struct {
	DynamicData

	// Name of the scheduled task.
	Name string `xml:"name" json:"name"`
	// Description of the scheduled task.
	Description string `xml:"description" json:"description"`
	// Flag to indicate whether the scheduled task is enabled or disabled.
	Enabled bool `xml:"enabled" json:"enabled"`
	// The time scheduler that determines when the scheduled task runs.
	Scheduler BaseTaskScheduler `xml:"scheduler,typeattr" json:"scheduler"`
	// The action of the scheduled task, to be done when the scheduled task runs.
	Action BaseAction `xml:"action,typeattr" json:"action"`
	// The email notification.
	//
	// If not set, this property is set to empty string, indicating no notification.
	Notification string `xml:"notification,omitempty" json:"notification,omitempty"`
}

func init() {
	t["ScheduledTaskSpec"] = reflect.TypeOf((*ScheduledTaskSpec)(nil)).Elem()
}

// This event records when a scheduled task started.
type ScheduledTaskStartedEvent struct {
	ScheduledTaskEvent
}

func init() {
	t["ScheduledTaskStartedEvent"] = reflect.TypeOf((*ScheduledTaskStartedEvent)(nil)).Elem()
}

// The `ScsiLun` data object describes a SCSI logical unit.
//
// A SCSI logical unit is a host device that an ESX Server or virtual machine
// can use for I/O operations.
//
// An ESX Server creates SCSI logical unit objects to represent
// devices in the host configuration. (See the definition of
// `ScsiLunType_enum` for a list of the supported device types.)
// The vSphere API uses one of two object types to represent a SCSI
// logical unit, depending on the device type.
//   - Disks containing file system volumes or parts of volumes for hosts
//     or raw disks for virtual machines. To represent disks, the ESX Server
//     creates a `HostScsiDisk` object, which inherits properties from
//     the `ScsiLun` base class.
//   - Other SCSI devices, for example SCSI passthrough devices
//     for virtual machines. To represent one of these devices,
//     the ESX Server creates a `ScsiLun` object.
//
// When the Server creates a `HostScsiDisk` or `ScsiLun` object,
// it specifies a valid device name and type:
//   - `HostDevice.deviceName` - A string representing the name of the device
//     that is meaningful to the host. The following are some examples of
//     device names.
//     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>/dev/cdrom</code>
//     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>/vmkdev/vmhba0:0:1:0</code>
//     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>PhysicalDrive0</code>
//   - `HostDevice.deviceType` - A string describing the type of device.
//     The following are some examples of device types.
//     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-cdrom</code>
//     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-tape</code>
//     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-disk</code>
//     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-processor</code>
//     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-unknown</code>
type ScsiLun struct {
	HostDevice

	// Linkable identifier
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// Universally unique identifier for the LUN used to identify ScsiLun across
	// multiple servers.
	//
	// This identifier can be used to identify analogous objects in other views
	// such as `HostMultipathInfoLogicalUnit` and `HostScsiTopologyLun`.
	//
	// See also `HostMultipathInfoLogicalUnit`, `HostScsiTopologyLun`.
	Uuid string `xml:"uuid" json:"uuid"`
	// List of descriptors that can be used to identify the LUN object.
	//
	// The
	// uuid will also appear as a descriptor.
	//
	// The id field in the descriptor is a string that can be used to correlate
	// the ScsiLun across multiple servers. A ScsiLun may have multiple
	// descriptors. The choice and order of these descriptors may be different
	// on different servers.
	//
	// Not all descriptors are suitable for correlation. Some descriptors are
	// only sufficient to identify the ScsiLun within a single host. Each
	// descriptor contains a quality property that indicates whether or not
	// the descriptor is suitable for correlation.
	Descriptor []ScsiLunDescriptor `xml:"descriptor,omitempty" json:"descriptor,omitempty"`
	// Canonical name of the SCSI logical unit.
	//
	// Disk partition or extent identifiers refer to this name when
	// referring to a disk. Use this property to correlate a partition
	// or extent to a specific SCSI disk.
	//
	// See also `HostScsiDiskPartition.diskName`.
	CanonicalName string `xml:"canonicalName,omitempty" json:"canonicalName,omitempty"`
	// User configurable display name of the SCSI logical unit.
	//
	// A default
	// display name will be used if available. If the display name is not
	// supported, it will be unset. The display name does not have to be
	// unique but it is recommended that it be unique.
	DisplayName string `xml:"displayName,omitempty" json:"displayName,omitempty"`
	// The type of SCSI device.
	//
	// Must be one of the values of
	// `ScsiLunType_enum`.
	LunType string `xml:"lunType" json:"lunType"`
	// The vendor of the SCSI device.
	Vendor string `xml:"vendor,omitempty" json:"vendor,omitempty"`
	// The model number of the SCSI device.
	Model string `xml:"model,omitempty" json:"model,omitempty"`
	// The revision of the SCSI device.
	Revision string `xml:"revision,omitempty" json:"revision,omitempty"`
	// The SCSI level of the SCSI device.
	ScsiLevel int32 `xml:"scsiLevel,omitempty" json:"scsiLevel,omitempty"`
	// The serial number of the SCSI device.
	//
	// For a device that is SCSI-3 compliant, this property is derived
	// from page 80h of the Vital Product Data (VPD), as defined by the
	// SCSI-3 Primary Commands (SPC-3) spec. Not all SCSI-3 compliant
	// devices provide this information. For devices that are not
	// SCSI-3 compliant, this property is not defined.
	SerialNumber string `xml:"serialNumber,omitempty" json:"serialNumber,omitempty"`
	// The durable name of the SCSI device.
	//
	// For a SCSI-3 compliant device this property is derived from the
	// payloads of pages 80h and 83h of the Vital Product Data (VPD) as
	// defined by the T10 and SMI standards. For devices that do not provide
	// this information, this property is not defined.
	DurableName *ScsiLunDurableName `xml:"durableName,omitempty" json:"durableName,omitempty"`
	// Alternate durable names.
	//
	// Records all available durable names derived from page 80h of the Vital
	// Product Data (VPD) and the Identification Vital Product Data (VPD) page
	// 83h as defined by the SCSI-3 Primary Commands. For devices that are not
	// SCSI-3 compliant this property is not defined.
	AlternateName []ScsiLunDurableName `xml:"alternateName,omitempty" json:"alternateName,omitempty"`
	// Standard Inquiry payload.
	//
	// For a SCSI-3 compliant device this property is derived from the
	// standard inquiry data. For devices that are not SCSI-3 compliant this
	// property is not defined.
	StandardInquiry ByteSlice `xml:"standardInquiry,omitempty" json:"standardInquiry,omitempty"`
	// The queue depth of SCSI device.
	QueueDepth int32 `xml:"queueDepth,omitempty" json:"queueDepth,omitempty"`
	// The operational states of the LUN.
	//
	// When more than one item is present in the array, the first state
	// should be considered the primary state. For example, a LUN may
	// be "ok" and "degraded" indicating I/O is still possible to the LUN, but
	// it is operating in a degraded mode.
	//
	// See also `ScsiLunState_enum`.
	OperationalState []string `xml:"operationalState" json:"operationalState"`
	// Capabilities of SCSI device.
	Capabilities *ScsiLunCapabilities `xml:"capabilities,omitempty" json:"capabilities,omitempty"`
	// vStorage hardware acceleration support status.
	//
	// This property
	// represents storage acceleration provided by the SCSI logical unit.
	// See `ScsiLunVStorageSupportStatus_enum` for valid values.
	//
	// If a storage device supports hardware acceleration,
	// the ESX host can offload specific virtual machine management
	// operations to the storage device. With hardware assistance,
	// the host performs storage operations faster and consumes
	// less CPU, memory, and storage fabric bandwidth.
	//
	// For vSphere 4.0 or earlier hosts, this value will be unset.
	VStorageSupport string `xml:"vStorageSupport,omitempty" json:"vStorageSupport,omitempty"`
	// Indicates that this SCSI LUN is protocol endpoint.
	//
	// This
	// property will be populated if and only if host supports
	// VirtualVolume based Datastore. Check the host capability
	// `HostCapability.virtualVolumeDatastoreSupported`.
	// See `HostProtocolEndpoint`.
	ProtocolEndpoint *bool `xml:"protocolEndpoint" json:"protocolEndpoint,omitempty"`
	// Indicates the state of a perennially reserved flag for a LUN.
	//
	// If
	// set for Raw Device Mapped (RDM) LUNs, the host startup or LUN rescan
	// take comparatively shorter duration than when it is unset.
	PerenniallyReserved *bool `xml:"perenniallyReserved" json:"perenniallyReserved,omitempty"`
	// Indicates if LUN has the prequisite properties to enable Clustered Vmdk
	// feature once formatted into VMFS Datastore.
	ClusteredVmdkSupported *bool `xml:"clusteredVmdkSupported" json:"clusteredVmdkSupported,omitempty"`
	// Indicates the current device protocol.
	//
	// Application protocol for a device which is set based on input
	// from vmkctl storage control plane. Must be one of the values of
	// `DeviceProtocol_enum`.
	ApplicationProtocol string `xml:"applicationProtocol,omitempty" json:"applicationProtocol,omitempty" vim:"8.0.1.0"`
	// Indicates whether namespace is dispersed.
	//
	// Set to true when the namespace of LUN is dispersed.
	DispersedNs *bool `xml:"dispersedNs" json:"dispersedNs,omitempty" vim:"8.0.1.0"`
	// Indicates whether a device is under SCSI/NVMe reservation.
	//
	// Device reservation for a SCSI/NVMe device set based on
	// values received from vmkernel. The list of supported values is defined in
	// `ScsiLunLunReservationStatus_enum`.
	// If unset, the reservation status is unknown.
	DeviceReservation string `xml:"deviceReservation,omitempty" json:"deviceReservation,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["ScsiLun"] = reflect.TypeOf((*ScsiLun)(nil)).Elem()
}

// Scsi device specific capabilities.
type ScsiLunCapabilities struct {
	DynamicData

	// Can the display name of the SCSI device be updated?
	UpdateDisplayNameSupported bool `xml:"updateDisplayNameSupported" json:"updateDisplayNameSupported"`
}

func init() {
	t["ScsiLunCapabilities"] = reflect.TypeOf((*ScsiLunCapabilities)(nil)).Elem()
}

// A structure that encapsulates an identifier and its properties for the
// ScsiLun object.
type ScsiLunDescriptor struct {
	DynamicData

	// An indicator of the utility of the descriptor as an identifier that
	// is stable, unique, and correlatable.
	//
	// See also `ScsiLunDescriptorQuality_enum`.
	Quality string `xml:"quality" json:"quality"`
	// The identifier represented as a string.
	Id string `xml:"id" json:"id"`
}

func init() {
	t["ScsiLunDescriptor"] = reflect.TypeOf((*ScsiLunDescriptor)(nil)).Elem()
}

// This data object type represents an SMI-S "Correlatable and
// Durable Name" which is an
// identifier for a logical unit number (LUN) that is generated using
// a common algorithm.
//
// The algorithm divides the identifier into
// multiple namespaces where each
// namespace uses a different set of properties of the LUN to generate
// the identifier. The namespace itself is encoded in the identifier.
type ScsiLunDurableName struct {
	DynamicData

	// The string describing the namespace used for the durable name.
	Namespace string `xml:"namespace" json:"namespace"`
	// The byte used by the ESX Server product to represent the namespace.
	NamespaceId byte `xml:"namespaceId" json:"namespaceId"`
	// The variable length byte array containing the namespace-specific data.
	//
	// For a SCSI-3 compliant device this field is the descriptor header
	// along with the payload for data obtained from page 83h, and is the
	// payload for data obtained from page 80h of the Vital Product Data
	// (VPD).
	Data ByteSlice `xml:"data,omitempty" json:"data,omitempty"`
}

func init() {
	t["ScsiLunDurableName"] = reflect.TypeOf((*ScsiLunDurableName)(nil)).Elem()
}

// Specification used to create an Flex-SE based virtual disk
type SeSparseVirtualDiskSpec struct {
	FileBackedVirtualDiskSpec

	// The grain size in kB for Flex-SE disk types.
	//
	// Default value will
	// be used if unset.
	GrainSizeKb int32 `xml:"grainSizeKb,omitempty" json:"grainSizeKb,omitempty"`
}

func init() {
	t["SeSparseVirtualDiskSpec"] = reflect.TypeOf((*SeSparseVirtualDiskSpec)(nil)).Elem()
}

// The parameters of `HostDatastoreBrowser.SearchDatastore_Task`.
type SearchDatastoreRequestType struct {
	This          ManagedObjectReference          `xml:"_this" json:"-"`
	DatastorePath string                          `xml:"datastorePath" json:"datastorePath"`
	SearchSpec    *HostDatastoreBrowserSearchSpec `xml:"searchSpec,omitempty" json:"searchSpec,omitempty"`
}

func init() {
	t["SearchDatastoreRequestType"] = reflect.TypeOf((*SearchDatastoreRequestType)(nil)).Elem()
}

// The parameters of `HostDatastoreBrowser.SearchDatastoreSubFolders_Task`.
type SearchDatastoreSubFoldersRequestType struct {
	This          ManagedObjectReference          `xml:"_this" json:"-"`
	DatastorePath string                          `xml:"datastorePath" json:"datastorePath"`
	SearchSpec    *HostDatastoreBrowserSearchSpec `xml:"searchSpec,omitempty" json:"searchSpec,omitempty"`
}

func init() {
	t["SearchDatastoreSubFoldersRequestType"] = reflect.TypeOf((*SearchDatastoreSubFoldersRequestType)(nil)).Elem()
}

type SearchDatastoreSubFolders_Task SearchDatastoreSubFoldersRequestType

func init() {
	t["SearchDatastoreSubFolders_Task"] = reflect.TypeOf((*SearchDatastoreSubFolders_Task)(nil)).Elem()
}

type SearchDatastoreSubFolders_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type SearchDatastore_Task SearchDatastoreRequestType

func init() {
	t["SearchDatastore_Task"] = reflect.TypeOf((*SearchDatastore_Task)(nil)).Elem()
}

type SearchDatastore_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This fault is thrown when an attempt is made to disable a secondary
// virtual machine that has already been disabled.
type SecondaryVmAlreadyDisabled struct {
	VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string `xml:"instanceUuid" json:"instanceUuid"`
}

func init() {
	t["SecondaryVmAlreadyDisabled"] = reflect.TypeOf((*SecondaryVmAlreadyDisabled)(nil)).Elem()
}

type SecondaryVmAlreadyDisabledFault SecondaryVmAlreadyDisabled

func init() {
	t["SecondaryVmAlreadyDisabledFault"] = reflect.TypeOf((*SecondaryVmAlreadyDisabledFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to enable a secondary
// virtual machine that has already been enabled.
type SecondaryVmAlreadyEnabled struct {
	VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string `xml:"instanceUuid" json:"instanceUuid"`
}

func init() {
	t["SecondaryVmAlreadyEnabled"] = reflect.TypeOf((*SecondaryVmAlreadyEnabled)(nil)).Elem()
}

type SecondaryVmAlreadyEnabledFault SecondaryVmAlreadyEnabled

func init() {
	t["SecondaryVmAlreadyEnabledFault"] = reflect.TypeOf((*SecondaryVmAlreadyEnabledFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to register a secondary
// virtual machine with a primary virtual machine with whom it is
// already registered.
type SecondaryVmAlreadyRegistered struct {
	VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string `xml:"instanceUuid" json:"instanceUuid"`
}

func init() {
	t["SecondaryVmAlreadyRegistered"] = reflect.TypeOf((*SecondaryVmAlreadyRegistered)(nil)).Elem()
}

type SecondaryVmAlreadyRegisteredFault SecondaryVmAlreadyRegistered

func init() {
	t["SecondaryVmAlreadyRegisteredFault"] = reflect.TypeOf((*SecondaryVmAlreadyRegisteredFault)(nil)).Elem()
}

// This fault is thrown when an attempt is made to unregister a secondary
// virtual machine from a primary virtual machine with whom it has not
// been previously registered.
type SecondaryVmNotRegistered struct {
	VmFaultToleranceIssue

	// Instance UUID of the secondary virtual machine.
	InstanceUuid string `xml:"instanceUuid" json:"instanceUuid"`
}

func init() {
	t["SecondaryVmNotRegistered"] = reflect.TypeOf((*SecondaryVmNotRegistered)(nil)).Elem()
}

type SecondaryVmNotRegisteredFault SecondaryVmNotRegistered

func init() {
	t["SecondaryVmNotRegisteredFault"] = reflect.TypeOf((*SecondaryVmNotRegisteredFault)(nil)).Elem()
}

// Thrown when the client is not allowed access to the property or method.
type SecurityError struct {
	RuntimeFault
}

func init() {
	t["SecurityError"] = reflect.TypeOf((*SecurityError)(nil)).Elem()
}

type SecurityErrorFault BaseSecurityError

func init() {
	t["SecurityErrorFault"] = reflect.TypeOf((*SecurityErrorFault)(nil)).Elem()
}

// The `SecurityProfile` data object represents host security configuration.
//
// If a profile plug-in defines policies or subprofiles, use the
// `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the additional configuration data.
type SecurityProfile struct {
	ApplyProfile

	// Permission configuration.
	Permission []PermissionProfile `xml:"permission,omitempty" json:"permission,omitempty"`
}

func init() {
	t["SecurityProfile"] = reflect.TypeOf((*SecurityProfile)(nil)).Elem()
}

type SelectActivePartition SelectActivePartitionRequestType

func init() {
	t["SelectActivePartition"] = reflect.TypeOf((*SelectActivePartition)(nil)).Elem()
}

// The parameters of `HostDiagnosticSystem.SelectActivePartition`.
type SelectActivePartitionRequestType struct {
	This      ManagedObjectReference `xml:"_this" json:"-"`
	Partition *HostScsiDiskPartition `xml:"partition,omitempty" json:"partition,omitempty"`
}

func init() {
	t["SelectActivePartitionRequestType"] = reflect.TypeOf((*SelectActivePartitionRequestType)(nil)).Elem()
}

type SelectActivePartitionResponse struct {
}

type SelectVnic SelectVnicRequestType

func init() {
	t["SelectVnic"] = reflect.TypeOf((*SelectVnic)(nil)).Elem()
}

type SelectVnicForNicType SelectVnicForNicTypeRequestType

func init() {
	t["SelectVnicForNicType"] = reflect.TypeOf((*SelectVnicForNicType)(nil)).Elem()
}

// The parameters of `HostVirtualNicManager.SelectVnicForNicType`.
type SelectVnicForNicTypeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The type of VirtualNic that would be selected
	NicType string `xml:"nicType" json:"nicType"`
	// The device that uniquely identifies the VirtualNic.
	Device string `xml:"device" json:"device"`
}

func init() {
	t["SelectVnicForNicTypeRequestType"] = reflect.TypeOf((*SelectVnicForNicTypeRequestType)(nil)).Elem()
}

type SelectVnicForNicTypeResponse struct {
}

// The parameters of `HostVMotionSystem.SelectVnic`.
type SelectVnicRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device that uniquely identifies the VirtualNic.
	Device string `xml:"device" json:"device"`
}

func init() {
	t["SelectVnicRequestType"] = reflect.TypeOf((*SelectVnicRequestType)(nil)).Elem()
}

type SelectVnicResponse struct {
}

// Base class for selecting entities
type SelectionSet struct {
	DynamicData
}

func init() {
	t["SelectionSet"] = reflect.TypeOf((*SelectionSet)(nil)).Elem()
}

// The `SelectionSpec` is the base type for data
// object types that specify what additional objects to filter.
//
// The base
// type contains only an optional "name" field, which allows a selection to
// be named for future reference. More information is available in the
// subtype.
//
// Named selections support recursive specifications on an object
// hierarchy. When used by a derived object, the "name" field allows other
// `SelectionSpec` objects to refer to the object by
// name. When used as the base type only, the "name" field indicates
// recursion to the derived object by name.
//
// Names are meaningful only within the same FilterSpec.
type SelectionSpec struct {
	DynamicData

	// Name of the selection specification.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
}

func init() {
	t["SelectionSpec"] = reflect.TypeOf((*SelectionSpec)(nil)).Elem()
}

// This data object type defines an email that is triggered by an
// alarm.
//
// You can use any
// elements of the `ActionParameter`
// enumerated list as part of your strings to provide information available
// at runtime.
type SendEmailAction struct {
	Action

	// A comma-separated list of addresses to which the email notification is sent.
	ToList string `xml:"toList" json:"toList"`
	// A comma-separated list of addresses that are cc'ed on the email notification.
	CcList string `xml:"ccList" json:"ccList"`
	// Subject of the email notification.
	Subject string `xml:"subject" json:"subject"`
	// Content of the email notification.
	Body string `xml:"body" json:"body"`
}

func init() {
	t["SendEmailAction"] = reflect.TypeOf((*SendEmailAction)(nil)).Elem()
}

type SendNMI SendNMIRequestType

func init() {
	t["SendNMI"] = reflect.TypeOf((*SendNMI)(nil)).Elem()
}

type SendNMIRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["SendNMIRequestType"] = reflect.TypeOf((*SendNMIRequestType)(nil)).Elem()
}

type SendNMIResponse struct {
}

// This data object type specifies an SNMP trap that is triggered by an alarm.
type SendSNMPAction struct {
	Action
}

func init() {
	t["SendSNMPAction"] = reflect.TypeOf((*SendSNMPAction)(nil)).Elem()
}

type SendTestNotification SendTestNotificationRequestType

func init() {
	t["SendTestNotification"] = reflect.TypeOf((*SendTestNotification)(nil)).Elem()
}

type SendTestNotificationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["SendTestNotificationRequestType"] = reflect.TypeOf((*SendTestNotificationRequestType)(nil)).Elem()
}

type SendTestNotificationResponse struct {
}

// This event records an expired VirtualCenter server license.
type ServerLicenseExpiredEvent struct {
	LicenseEvent

	Product string `xml:"product" json:"product"`
}

func init() {
	t["ServerLicenseExpiredEvent"] = reflect.TypeOf((*ServerLicenseExpiredEvent)(nil)).Elem()
}

// This event records the starting of the VirtualCenter server.
type ServerStartedSessionEvent struct {
	SessionEvent
}

func init() {
	t["ServerStartedSessionEvent"] = reflect.TypeOf((*ServerStartedSessionEvent)(nil)).Elem()
}

// The `ServiceConsolePortGroupProfile` data object represents
// the profile for a port group that will be used by the service console.
//
// If a profile plug-in defines policies or subprofiles, use the
// `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the additional configuration data.
type ServiceConsolePortGroupProfile struct {
	PortGroupProfile

	// IP address configuration for the service console network.
	IpConfig IpAddressProfile `xml:"ipConfig" json:"ipConfig"`
}

func init() {
	t["ServiceConsolePortGroupProfile"] = reflect.TypeOf((*ServiceConsolePortGroupProfile)(nil)).Elem()
}

// The ServiceConsoleReservationInfo data object type describes the
// amount of memory that is being reserved by the service console.
//
// Memory reserved for use by the service console is a hard reservation
// that cannot be changed except across hardware restarts.
//
// This memory that is reserved for the service console is used primarily
// to provide system management services. In addition, a small overhead
// is needed by each virtual machine on the service console.
//
// The only property of the data object that can be changed directly is the
// serviceConsoleReservedCfg property. This property indicates how much
// memory should be reserved for the service console on the next boot. In
// most cases, this amount is the same as the current reservation.
type ServiceConsoleReservationInfo struct {
	DynamicData

	// The amount of memory that should be reserved for the service console on
	// the next boot.
	ServiceConsoleReservedCfg int64 `xml:"serviceConsoleReservedCfg" json:"serviceConsoleReservedCfg"`
	// The amount of memory that is currently reserved for the service console.
	ServiceConsoleReserved int64 `xml:"serviceConsoleReserved" json:"serviceConsoleReserved"`
	// The amount of memory that is not reserved for use by the service console.
	Unreserved int64 `xml:"unreserved" json:"unreserved"`
}

func init() {
	t["ServiceConsoleReservationInfo"] = reflect.TypeOf((*ServiceConsoleReservationInfo)(nil)).Elem()
}

// The `ServiceContent` data object defines properties for the ServiceInstance
// managed object.
//
// The ServiceInstance itself does not have directly-accessible
// properties because reading the properties of a managed object requires
// the use of a property collector, and the property collector itself
// is a property of the `ServiceInstance`.
// For this reason, use the method `ServiceInstance.RetrieveServiceContent`
// to retrieve the `ServiceContent` object.
type ServiceContent struct {
	DynamicData

	// Reference to the top of the inventory managed by this service.
	//
	// Refers instance of `Folder`.
	RootFolder ManagedObjectReference `xml:"rootFolder" json:"rootFolder"`
	// Reference to a per-session object for retrieving properties and updates.
	//
	// Refers instance of `PropertyCollector`.
	PropertyCollector ManagedObjectReference `xml:"propertyCollector" json:"propertyCollector"`
	// A singleton managed object for tracking custom sets of objects.
	//
	// Refers instance of `ViewManager`.
	ViewManager *ManagedObjectReference `xml:"viewManager,omitempty" json:"viewManager,omitempty"`
	// Information about the service, such as the software version.
	About AboutInfo `xml:"about" json:"about"`
	// Generic configuration for a management server.
	//
	// This is for example by
	// vCenter to store the vCenter Settings. This is not used for a
	// stand-alone host, instead the vim.host.ConfigManager.advancedOption is used.
	//
	// See also `HostConfigManager`.
	//
	// Refers instance of `OptionManager`.
	Setting *ManagedObjectReference `xml:"setting,omitempty" json:"setting,omitempty"`
	// A user directory managed object.
	//
	// Refers instance of `UserDirectory`.
	UserDirectory *ManagedObjectReference `xml:"userDirectory,omitempty" json:"userDirectory,omitempty"`
	// Managed object for logging in and managing sessions.
	//
	// Refers instance of `SessionManager`.
	SessionManager *ManagedObjectReference `xml:"sessionManager,omitempty" json:"sessionManager,omitempty"`
	// Manages permissions for managed entities in the service.
	//
	// Refers instance of `AuthorizationManager`.
	AuthorizationManager *ManagedObjectReference `xml:"authorizationManager,omitempty" json:"authorizationManager,omitempty"`
	// A singleton managed object that manages local services.
	//
	// Refers instance of `ServiceManager`.
	ServiceManager *ManagedObjectReference `xml:"serviceManager,omitempty" json:"serviceManager,omitempty"`
	// A singleton managed object that manages the collection and reporting
	// of performance statistics.
	//
	// Refers instance of `PerformanceManager`.
	PerfManager *ManagedObjectReference `xml:"perfManager,omitempty" json:"perfManager,omitempty"`
	// A singleton managed object that manages scheduled tasks.
	//
	// Refers instance of `ScheduledTaskManager`.
	ScheduledTaskManager *ManagedObjectReference `xml:"scheduledTaskManager,omitempty" json:"scheduledTaskManager,omitempty"`
	// A singleton managed object that manages alarms.
	//
	// Refers instance of `AlarmManager`.
	AlarmManager *ManagedObjectReference `xml:"alarmManager,omitempty" json:"alarmManager,omitempty"`
	// A singleton managed object that manages events.
	//
	// Refers instance of `EventManager`.
	EventManager *ManagedObjectReference `xml:"eventManager,omitempty" json:"eventManager,omitempty"`
	// A singleton managed object that manages tasks.
	//
	// Refers instance of `TaskManager`.
	TaskManager *ManagedObjectReference `xml:"taskManager,omitempty" json:"taskManager,omitempty"`
	// A singleton managed object that manages extensions.
	//
	// Refers instance of `ExtensionManager`.
	ExtensionManager *ManagedObjectReference `xml:"extensionManager,omitempty" json:"extensionManager,omitempty"`
	// A singleton managed object that manages saved guest customization
	// specifications.
	//
	// Refers instance of `CustomizationSpecManager`.
	CustomizationSpecManager *ManagedObjectReference `xml:"customizationSpecManager,omitempty" json:"customizationSpecManager,omitempty"`
	// A singleton managed object that manages guest customization of
	// a running VM.
	//
	// The typical usage is for the guest customization after the
	// InstantClone operation. See `VirtualMachine.InstantClone_Task`.
	//
	// Refers instance of `VirtualMachineGuestCustomizationManager`.
	GuestCustomizationManager *ManagedObjectReference `xml:"guestCustomizationManager,omitempty" json:"guestCustomizationManager,omitempty"`
	// A singleton managed object that managed custom fields.
	//
	// Refers instance of `CustomFieldsManager`.
	CustomFieldsManager *ManagedObjectReference `xml:"customFieldsManager,omitempty" json:"customFieldsManager,omitempty"`
	// A singleton managed object that manages host local user and group accounts.
	//
	// Refers instance of `HostLocalAccountManager`.
	AccountManager *ManagedObjectReference `xml:"accountManager,omitempty" json:"accountManager,omitempty"`
	// A singleton managed object that provides access to low-level log files.
	//
	// Refers instance of `DiagnosticManager`.
	DiagnosticManager *ManagedObjectReference `xml:"diagnosticManager,omitempty" json:"diagnosticManager,omitempty"`
	// A singleton managed object that manages licensing
	//
	// Refers instance of `LicenseManager`.
	LicenseManager *ManagedObjectReference `xml:"licenseManager,omitempty" json:"licenseManager,omitempty"`
	// A singleton managed object that allows search of the inventory
	//
	// Refers instance of `SearchIndex`.
	SearchIndex *ManagedObjectReference `xml:"searchIndex,omitempty" json:"searchIndex,omitempty"`
	// A singleton managed object that allows management of files present
	// on datastores.
	//
	// Refers instance of `FileManager`.
	FileManager *ManagedObjectReference `xml:"fileManager,omitempty" json:"fileManager,omitempty"`
	// Datastore Namespace manager.
	//
	// A singleton managed object that is used to manage manipulations
	// related to datastores' namespaces.
	//
	// Refers instance of `DatastoreNamespaceManager`.
	DatastoreNamespaceManager *ManagedObjectReference `xml:"datastoreNamespaceManager,omitempty" json:"datastoreNamespaceManager,omitempty"`
	// A singleton managed object that allows management of virtual disks
	// on datastores.
	//
	// Refers instance of `VirtualDiskManager`.
	VirtualDiskManager *ManagedObjectReference `xml:"virtualDiskManager,omitempty" json:"virtualDiskManager,omitempty"`
	// Deprecated as of VI API 2.5, use the VMware vCenter Converter plug-in.
	//
	// A singleton managed object that manages the discovery, analysis,
	// recommendation and virtualization of physical machines
	//
	// Refers instance of `VirtualizationManager`.
	VirtualizationManager *ManagedObjectReference `xml:"virtualizationManager,omitempty" json:"virtualizationManager,omitempty"`
	// A singleton managed object that allows SNMP configuration.
	//
	// Not set if not supported on a particular platform.
	//
	// Refers instance of `HostSnmpSystem`.
	SnmpSystem *ManagedObjectReference `xml:"snmpSystem,omitempty" json:"snmpSystem,omitempty"`
	// A singleton managed object that can answer questions about the
	// feasibility of certain provisioning operations.
	//
	// Refers instance of `VirtualMachineProvisioningChecker`.
	VmProvisioningChecker *ManagedObjectReference `xml:"vmProvisioningChecker,omitempty" json:"vmProvisioningChecker,omitempty"`
	// A singleton managed object that can answer questions about compatibility
	// of a virtual machine with a host.
	//
	// Refers instance of `VirtualMachineCompatibilityChecker`.
	VmCompatibilityChecker *ManagedObjectReference `xml:"vmCompatibilityChecker,omitempty" json:"vmCompatibilityChecker,omitempty"`
	// A singleton managed object that can generate OVF descriptors (export) and create
	// vApps (single-VM or vApp container-based) from OVF descriptors (import).
	//
	// Refers instance of `OvfManager`.
	OvfManager *ManagedObjectReference `xml:"ovfManager,omitempty" json:"ovfManager,omitempty"`
	// A singleton managed object that supports management of IpPool objects.
	//
	// IP pools are
	// used when allocating IPv4 and IPv6 addresses to vApps.
	//
	// Refers instance of `IpPoolManager`.
	IpPoolManager *ManagedObjectReference `xml:"ipPoolManager,omitempty" json:"ipPoolManager,omitempty"`
	// A singleton managed object that provides relevant information of
	// DistributedVirtualSwitch.
	//
	// Refers instance of `DistributedVirtualSwitchManager`.
	DvSwitchManager *ManagedObjectReference `xml:"dvSwitchManager,omitempty" json:"dvSwitchManager,omitempty"`
	// A singleton managed object that manages the host profiles.
	//
	// Refers instance of `HostProfileManager`.
	HostProfileManager *ManagedObjectReference `xml:"hostProfileManager,omitempty" json:"hostProfileManager,omitempty"`
	// A singleton managed object that manages the cluster profiles.
	//
	// Refers instance of `ClusterProfileManager`.
	ClusterProfileManager *ManagedObjectReference `xml:"clusterProfileManager,omitempty" json:"clusterProfileManager,omitempty"`
	// A singleton managed object that manages compliance aspects of entities.
	//
	// Refers instance of `ProfileComplianceManager`.
	ComplianceManager *ManagedObjectReference `xml:"complianceManager,omitempty" json:"complianceManager,omitempty"`
	// A singleton managed object that provides methods for retrieving message
	// catalogs for client-side localization support.
	//
	// Refers instance of `LocalizationManager`.
	LocalizationManager *ManagedObjectReference `xml:"localizationManager,omitempty" json:"localizationManager,omitempty"`
	// A singleton managed object that provides methods for storage resource
	// management.
	//
	// Refers instance of `StorageResourceManager`.
	StorageResourceManager *ManagedObjectReference `xml:"storageResourceManager,omitempty" json:"storageResourceManager,omitempty"`
	// A singleton managed object that provides methods for guest operations.
	//
	// Refers instance of `GuestOperationsManager`.
	GuestOperationsManager *ManagedObjectReference `xml:"guestOperationsManager,omitempty" json:"guestOperationsManager,omitempty"`
	// A singleton managed object that provides methods for looking up static VM
	// overhead memory.
	//
	// Refers instance of `OverheadMemoryManager`.
	OverheadMemoryManager *ManagedObjectReference `xml:"overheadMemoryManager,omitempty" json:"overheadMemoryManager,omitempty"`
	// host certificate manager
	// A singleton managed object to manage the certificates between the
	// Certificate Server and the host.
	//
	// Refers instance of `CertificateManager`.
	CertificateManager *ManagedObjectReference `xml:"certificateManager,omitempty" json:"certificateManager,omitempty"`
	// A singleton managed object that manages IO Filters installed on the ESXi
	// hosts and IO Filter configuration of virtual disks.
	//
	// Refers instance of `IoFilterManager`.
	IoFilterManager *ManagedObjectReference `xml:"ioFilterManager,omitempty" json:"ioFilterManager,omitempty"`
	// A singleton managed object that manages all storage objects in the
	// Virtual Infrastructure.
	//
	// If connected to a vCenter,
	// this is the `VcenterVStorageObjectManager`; If connected
	// to an ESXi host, this is the `HostVStorageObjectManager`.
	//
	// A storage object in the Virtual Infrastructure is represented by a
	// vStorageObject.
	//
	// Refers instance of `VStorageObjectManagerBase`.
	VStorageObjectManager *ManagedObjectReference `xml:"vStorageObjectManager,omitempty" json:"vStorageObjectManager,omitempty"`
	// A singleton managed object that manages the host specification data.
	//
	// Refers instance of `HostSpecificationManager`.
	HostSpecManager *ManagedObjectReference `xml:"hostSpecManager,omitempty" json:"hostSpecManager,omitempty"`
	// A singleton managed object used to manage cryptographic keys.
	//
	// Refers instance of `CryptoManager`.
	CryptoManager *ManagedObjectReference `xml:"cryptoManager,omitempty" json:"cryptoManager,omitempty"`
	// A singleton managed object that manages the health updates.
	//
	// Refers instance of `HealthUpdateManager`.
	HealthUpdateManager *ManagedObjectReference `xml:"healthUpdateManager,omitempty" json:"healthUpdateManager,omitempty"`
	// A singleton managed object that manages the VCHA Cluster
	// configuration.
	//
	// Refers instance of `FailoverClusterConfigurator`.
	FailoverClusterConfigurator *ManagedObjectReference `xml:"failoverClusterConfigurator,omitempty" json:"failoverClusterConfigurator,omitempty"`
	// A singleton managed object for managing a configured VCHA Cluster.
	//
	// Refers instance of `FailoverClusterManager`.
	FailoverClusterManager *ManagedObjectReference `xml:"failoverClusterManager,omitempty" json:"failoverClusterManager,omitempty"`
	// A singleton managed object used to configure tenants.
	//
	// Refers instance of `TenantTenantManager`.
	TenantManager *ManagedObjectReference `xml:"tenantManager,omitempty" json:"tenantManager,omitempty"`
	// A singleton managed object used to manage site related capabilities.
	//
	// Refers instance of `SiteInfoManager`.
	SiteInfoManager *ManagedObjectReference `xml:"siteInfoManager,omitempty" json:"siteInfoManager,omitempty"`
	// A singleton managed object used to query storage related entities.
	//
	// Refers instance of `StorageQueryManager`.
	StorageQueryManager *ManagedObjectReference `xml:"storageQueryManager,omitempty" json:"storageQueryManager,omitempty"`
}

func init() {
	t["ServiceContent"] = reflect.TypeOf((*ServiceContent)(nil)).Elem()
}

// This data object type specifies the information of a service endpoint as
// well as the parameters needed to locate and login to to the service
// endpoint.
type ServiceLocator struct {
	DynamicData

	// Unique ID of the instance to which the service belongs.
	//
	// For
	// instances that support the vSphere API, this is the same as the
	// value found in `AboutInfo.instanceUuid`.
	InstanceUuid string `xml:"instanceUuid" json:"instanceUuid"`
	// URL used to access the service endpoint
	Url string `xml:"url" json:"url"`
	// Credential to establish the connection and login to the service.
	Credential BaseServiceLocatorCredential `xml:"credential,typeattr" json:"credential"`
	// The SSL thumbprint of the certificate of the service endpoint.
	//
	// Superceded by `#sslCertificate`.
	// Note: If both <code>sslThumbprint</code> and <code>sslCertificate</code> are set,
	// <code>sslThumbprint</code> must correspond to the <code>sslCertificate</code>.
	SslThumbprint string `xml:"sslThumbprint,omitempty" json:"sslThumbprint,omitempty"`
}

func init() {
	t["ServiceLocator"] = reflect.TypeOf((*ServiceLocator)(nil)).Elem()
}

// The data object type is a base type of credential for authentication such
// as username/password or SAML token.
type ServiceLocatorCredential struct {
	DynamicData
}

func init() {
	t["ServiceLocatorCredential"] = reflect.TypeOf((*ServiceLocatorCredential)(nil)).Elem()
}

// The data object type specifies the username and password credential for
// authenticating to a service endpoint.
type ServiceLocatorNamePassword struct {
	ServiceLocatorCredential

	// The username for Username-Password authentication
	Username string `xml:"username" json:"username"`
	// The password for Username-Password authentication
	Password string `xml:"password" json:"password"`
}

func init() {
	t["ServiceLocatorNamePassword"] = reflect.TypeOf((*ServiceLocatorNamePassword)(nil)).Elem()
}

// The data object type specifies the SAML token (SSO) based credential for
// authenticating to a service endpoint.
type ServiceLocatorSAMLCredential struct {
	ServiceLocatorCredential

	// The SAML token for authentication
	Token string `xml:"token,omitempty" json:"token,omitempty"`
}

func init() {
	t["ServiceLocatorSAMLCredential"] = reflect.TypeOf((*ServiceLocatorSAMLCredential)(nil)).Elem()
}

// This data object represents essential information about a particular service.
//
// The information is sufficient to be able to identify the service and retrieve
// the object implementing it.
type ServiceManagerServiceInfo struct {
	DynamicData

	// A service name.
	//
	// Each service is expected to create a unique name
	// for itself that can be used to locate the service. This name
	// does not need to be unique across hosts or other such locations though.
	ServiceName string `xml:"serviceName" json:"serviceName"`
	// A list of data that can be used to uniquely identify a particular instance of a service.
	//
	// Multiple instances of a service can exist across different domains (for instance, a service
	// that is associated with a particular virtual machine or a particular host). In such cases,
	// the service name is insufficient to identify the service and location data can be used
	// to identify the instance of interest. A service may publish as much location data
	// as is needed to identify it (e.g, vmware.host.&lt;hostname&gt; or vmware.vm.&lt;uuid&gt; or both).
	// The particular choice of locations have to be agreed upon by
	// the client and the service.
	Location []string `xml:"location,omitempty" json:"location,omitempty"`
	// The managed object that presents this service.
	Service ManagedObjectReference `xml:"service" json:"service"`
	// A description of the service.
	//
	// Provides help text on how
	// to use the service.
	Description string `xml:"description" json:"description"`
}

func init() {
	t["ServiceManagerServiceInfo"] = reflect.TypeOf((*ServiceManagerServiceInfo)(nil)).Elem()
}

// The `ServiceProfile` data object controls the configuration of a service.
//
// Use the `ApplyProfile.policy` list for access to configuration data
// for the service profile. Use the `ApplyProfile.property` list for access
// to subprofiles, if any.
type ServiceProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["ServiceProfile"] = reflect.TypeOf((*ServiceProfile)(nil)).Elem()
}

// These are session events.
type SessionEvent struct {
	Event
}

func init() {
	t["SessionEvent"] = reflect.TypeOf((*SessionEvent)(nil)).Elem()
}

type SessionIsActive SessionIsActiveRequestType

func init() {
	t["SessionIsActive"] = reflect.TypeOf((*SessionIsActive)(nil)).Elem()
}

// The parameters of `SessionManager.SessionIsActive`.
type SessionIsActiveRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Session ID to validate.
	SessionID string `xml:"sessionID" json:"sessionID"`
	// User name to validate.
	UserName string `xml:"userName" json:"userName"`
}

func init() {
	t["SessionIsActiveRequestType"] = reflect.TypeOf((*SessionIsActiveRequestType)(nil)).Elem()
}

type SessionIsActiveResponse struct {
	Returnval bool `xml:"returnval" json:"returnval"`
}

// This data object represents a ticket which grants access to some service.
//
// The ticket may be used only once and is valid only for the
// `SessionManagerServiceRequestSpec` with which it was acquired.
// For HTTP service requests (when spec is of type HttpServiceRequestSpec)
// the returned ticket must be used by setting
// `SessionManagerGenericServiceTicket.id`
// as the value of a special cookie in the HTTP request.
// For CGI requests the name of this cookie is 'vmware\_cgi\_ticket'.
// The use of the returned ticket for other services is to be defined.
type SessionManagerGenericServiceTicket struct {
	DynamicData

	// A unique string identifying the ticket.
	Id string `xml:"id" json:"id"`
	// The name of the host that the service is running on
	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
	// The expected thumbprint of the SSL certificate of the host.
	//
	// If it is empty, the host must be authenticated by name.
	SslThumbprint string `xml:"sslThumbprint,omitempty" json:"sslThumbprint,omitempty"`
	// List of expected thumbprints of the certificate of the host to
	// which we are connecting.
	//
	// The list can be configured on the host
	// to include only certain hash types. The default configuration
	// includes all hash types that are considered secure. See vmware.com
	// for the current security standards.
	CertThumbprintList []VirtualMachineCertThumbprint `xml:"certThumbprintList,omitempty" json:"certThumbprintList,omitempty" vim:"7.0.3.1"`
	// Type of the ticket
	// See { @Vim::SessionManager::GenericServiceTicket::TicketType }
	TicketType string `xml:"ticketType,omitempty" json:"ticketType,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["SessionManagerGenericServiceTicket"] = reflect.TypeOf((*SessionManagerGenericServiceTicket)(nil)).Elem()
}

// This data object type describes a request to an HTTP or HTTPS service.
type SessionManagerHttpServiceRequestSpec struct {
	SessionManagerServiceRequestSpec

	// The HTTP method used for the request.
	//
	// If null, then any method is assumed.
	//
	// See also `SessionManagerHttpServiceRequestSpecMethod_enum`.
	Method string `xml:"method,omitempty" json:"method,omitempty"`
	// URL of the HTTP request.
	//
	// E.g. 'https://127.0.0.1:8080/cgi-bin/vm-support.cgi?n=val'.
	//
	// For ESXi CGI service requests:
	//   - only the path and query parts of the URL are used
	//     (e.g. "/cgi-bin/vm-support.cgi?n=val").
	//
	// This is so because the scheme is not known to the CGI service,
	// and the port may not be the same if using a proxy.
	Url string `xml:"url" json:"url"`
}

func init() {
	t["SessionManagerHttpServiceRequestSpec"] = reflect.TypeOf((*SessionManagerHttpServiceRequestSpec)(nil)).Elem()
}

// This data object type contains the user name
// and location of the file containing the password that
// clients can use for one-time logon to a server.
type SessionManagerLocalTicket struct {
	DynamicData

	// User name to be used for logon.
	UserName string `xml:"userName" json:"userName"`
	// Absolute local path to the file containing a one-time password.
	PasswordFilePath string `xml:"passwordFilePath" json:"passwordFilePath"`
}

func init() {
	t["SessionManagerLocalTicket"] = reflect.TypeOf((*SessionManagerLocalTicket)(nil)).Elem()
}

// This data object type describes a request to a service.
//
// It is used as argument to
// `SessionManager.AcquireGenericServiceTicket`.
// This is the base class for more specific service request specifications.
// E.g. for HTTP services the derived class will provide a URL property.
type SessionManagerServiceRequestSpec struct {
	DynamicData
}

func init() {
	t["SessionManagerServiceRequestSpec"] = reflect.TypeOf((*SessionManagerServiceRequestSpec)(nil)).Elem()
}

// This data object type describes a request to invoke a specific method
// in a VMOMI service.
//
// It currently only supports {link vim.SessionManager#cloneSession} method.
// The GenericServiceTicket.id returned from
// `SessionManager.AcquireGenericServiceTicket` for this request
// can be use for `SessionManager.CloneSession` to clone a session
type SessionManagerVmomiServiceRequestSpec struct {
	SessionManagerServiceRequestSpec

	// Name of the method identified by this request spec
	Method string `xml:"method" json:"method"`
}

func init() {
	t["SessionManagerVmomiServiceRequestSpec"] = reflect.TypeOf((*SessionManagerVmomiServiceRequestSpec)(nil)).Elem()
}

// This event records the termination of a session.
type SessionTerminatedEvent struct {
	SessionEvent

	// The unique identifier of the terminated session.
	SessionId string `xml:"sessionId" json:"sessionId"`
	// The name of the user owning the terminated session.
	TerminatedUsername string `xml:"terminatedUsername" json:"terminatedUsername"`
}

func init() {
	t["SessionTerminatedEvent"] = reflect.TypeOf((*SessionTerminatedEvent)(nil)).Elem()
}

type SetCollectorPageSize SetCollectorPageSizeRequestType

func init() {
	t["SetCollectorPageSize"] = reflect.TypeOf((*SetCollectorPageSize)(nil)).Elem()
}

// The parameters of `HistoryCollector.SetCollectorPageSize`.
type SetCollectorPageSizeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The maximum number of items in the page.
	MaxCount int32 `xml:"maxCount" json:"maxCount"`
}

func init() {
	t["SetCollectorPageSizeRequestType"] = reflect.TypeOf((*SetCollectorPageSizeRequestType)(nil)).Elem()
}

type SetCollectorPageSizeResponse struct {
}

type SetCryptoMode SetCryptoModeRequestType

func init() {
	t["SetCryptoMode"] = reflect.TypeOf((*SetCryptoMode)(nil)).Elem()
}

// The parameters of `ClusterComputeResource.SetCryptoMode`.
type SetCryptoModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The encryption mode for the cluster.
	// See `ClusterCryptoConfigInfoCryptoMode_enum` for
	// supported values. An empty string is treated as a valid
	// input and will be interpreted as
	// `onDemand`.
	CryptoMode string `xml:"cryptoMode" json:"cryptoMode"`
	// The encryption mode policy for the cluster. When no policy
	// is specified, host keys will be automcatically generated
	// using the current default key provider.
	Policy *ClusterComputeResourceCryptoModePolicy `xml:"policy,omitempty" json:"policy,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["SetCryptoModeRequestType"] = reflect.TypeOf((*SetCryptoModeRequestType)(nil)).Elem()
}

type SetCryptoModeResponse struct {
}

type SetDefaultKmsCluster SetDefaultKmsClusterRequestType

func init() {
	t["SetDefaultKmsCluster"] = reflect.TypeOf((*SetDefaultKmsCluster)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.SetDefaultKmsCluster`.
type SetDefaultKmsClusterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] The managed entity where the default KMS cluster to be
	// set. Currently the valid managed entity could be
	// cluster or host folder.
	// If omitted, then will set global default KMS cluster.
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
	// \[in\] KMS cluster ID to become default.
	// If omitted, then will clear the default KMS cluster
	// setting.
	ClusterId *KeyProviderId `xml:"clusterId,omitempty" json:"clusterId,omitempty"`
}

func init() {
	t["SetDefaultKmsClusterRequestType"] = reflect.TypeOf((*SetDefaultKmsClusterRequestType)(nil)).Elem()
}

type SetDefaultKmsClusterResponse struct {
}

type SetDisplayTopology SetDisplayTopologyRequestType

func init() {
	t["SetDisplayTopology"] = reflect.TypeOf((*SetDisplayTopology)(nil)).Elem()
}

// The parameters of `VirtualMachine.SetDisplayTopology`.
type SetDisplayTopologyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The topology for each monitor that the
	// virtual machine's display must span.
	Displays []VirtualMachineDisplayTopology `xml:"displays" json:"displays"`
}

func init() {
	t["SetDisplayTopologyRequestType"] = reflect.TypeOf((*SetDisplayTopologyRequestType)(nil)).Elem()
}

type SetDisplayTopologyResponse struct {
}

type SetEntityPermissions SetEntityPermissionsRequestType

func init() {
	t["SetEntityPermissions"] = reflect.TypeOf((*SetEntityPermissions)(nil)).Elem()
}

// The parameters of `AuthorizationManager.SetEntityPermissions`.
type SetEntityPermissionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The entity on which to set permissions.
	//
	// Required privileges: Authorization.ModifyPermissions
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// An array of specifications for permissions on the entity.
	Permission []Permission `xml:"permission,omitempty" json:"permission,omitempty"`
}

func init() {
	t["SetEntityPermissionsRequestType"] = reflect.TypeOf((*SetEntityPermissionsRequestType)(nil)).Elem()
}

type SetEntityPermissionsResponse struct {
}

type SetExtensionCertificate SetExtensionCertificateRequestType

func init() {
	t["SetExtensionCertificate"] = reflect.TypeOf((*SetExtensionCertificate)(nil)).Elem()
}

// The parameters of `ExtensionManager.SetExtensionCertificate`.
type SetExtensionCertificateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Key of extension to update.
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
	// PEM encoded certificate. If not specified, the
	// certificate passed over SSL handshake is used.
	CertificatePem string `xml:"certificatePem,omitempty" json:"certificatePem,omitempty"`
}

func init() {
	t["SetExtensionCertificateRequestType"] = reflect.TypeOf((*SetExtensionCertificateRequestType)(nil)).Elem()
}

type SetExtensionCertificateResponse struct {
}

type SetField SetFieldRequestType

func init() {
	t["SetField"] = reflect.TypeOf((*SetField)(nil)).Elem()
}

// The parameters of `CustomFieldsManager.SetField`.
type SetFieldRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Required privileges: Global.SetCustomField
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	Key    int32                  `xml:"key" json:"key"`
	Value  string                 `xml:"value" json:"value"`
}

func init() {
	t["SetFieldRequestType"] = reflect.TypeOf((*SetFieldRequestType)(nil)).Elem()
}

type SetFieldResponse struct {
}

type SetKeyCustomAttributes SetKeyCustomAttributesRequestType

func init() {
	t["SetKeyCustomAttributes"] = reflect.TypeOf((*SetKeyCustomAttributes)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.SetKeyCustomAttributes`.
type SetKeyCustomAttributesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] The crypto Key Id.
	KeyId CryptoKeyId `xml:"keyId" json:"keyId"`
	// \[in\] The spec that contains custom attributes key/value pairs.
	Spec CryptoManagerKmipCustomAttributeSpec `xml:"spec" json:"spec"`
}

func init() {
	t["SetKeyCustomAttributesRequestType"] = reflect.TypeOf((*SetKeyCustomAttributesRequestType)(nil)).Elem()
	minAPIVersionForType["SetKeyCustomAttributesRequestType"] = "8.0.1.0"
}

type SetKeyCustomAttributesResponse struct {
	Returnval CryptoKeyResult `xml:"returnval" json:"returnval"`
}

type SetLicenseEdition SetLicenseEditionRequestType

func init() {
	t["SetLicenseEdition"] = reflect.TypeOf((*SetLicenseEdition)(nil)).Elem()
}

// The parameters of `LicenseManager.SetLicenseEdition`.
type SetLicenseEditionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Host to act on if LicenseManager is not on a host.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// Name of edition feature to select. If featureKey is not
	// set or set to empty string, the product becomes unlicensed.
	FeatureKey string `xml:"featureKey,omitempty" json:"featureKey,omitempty"`
}

func init() {
	t["SetLicenseEditionRequestType"] = reflect.TypeOf((*SetLicenseEditionRequestType)(nil)).Elem()
}

type SetLicenseEditionResponse struct {
}

type SetLocale SetLocaleRequestType

func init() {
	t["SetLocale"] = reflect.TypeOf((*SetLocale)(nil)).Elem()
}

// The parameters of `SessionManager.SetLocale`.
type SetLocaleRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A two-character ISO-639 language ID (like "en")
	// optionally followed by an
	// underscore and a two-character ISO 3166 country ID (like "US").
	//
	// Examples are "de", "fr\_CA", "zh", "zh\_CN", and "zh\_TW".
	// Note: The method uses the server default locale when
	// a locale is not provided. This default can be configured in the
	// server configuration file. If unspecified, it defaults to the
	// locale of the server environment or English ("en") if unsupported.
	Locale string `xml:"locale" json:"locale"`
}

func init() {
	t["SetLocaleRequestType"] = reflect.TypeOf((*SetLocaleRequestType)(nil)).Elem()
}

type SetLocaleResponse struct {
}

type SetMaxQueueDepth SetMaxQueueDepthRequestType

func init() {
	t["SetMaxQueueDepth"] = reflect.TypeOf((*SetMaxQueueDepth)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.SetMaxQueueDepth`.
type SetMaxQueueDepthRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The NFS datastore which need to set max queue depth
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// Max queue depth value for a datastore
	MaxQdepth int64 `xml:"maxQdepth" json:"maxQdepth"`
}

func init() {
	t["SetMaxQueueDepthRequestType"] = reflect.TypeOf((*SetMaxQueueDepthRequestType)(nil)).Elem()
	minAPIVersionForType["SetMaxQueueDepthRequestType"] = "8.0.0.1"
}

type SetMaxQueueDepthResponse struct {
}

type SetMultipathLunPolicy SetMultipathLunPolicyRequestType

func init() {
	t["SetMultipathLunPolicy"] = reflect.TypeOf((*SetMultipathLunPolicy)(nil)).Elem()
}

// The parameters of `HostStorageSystem.SetMultipathLunPolicy`.
type SetMultipathLunPolicyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The logical unit ID
	LunId string `xml:"lunId" json:"lunId"`
	// A data object that describes a path selection policy for
	// the logical unit.
	Policy BaseHostMultipathInfoLogicalUnitPolicy `xml:"policy,typeattr" json:"policy"`
}

func init() {
	t["SetMultipathLunPolicyRequestType"] = reflect.TypeOf((*SetMultipathLunPolicyRequestType)(nil)).Elem()
}

type SetMultipathLunPolicyResponse struct {
}

type SetNFSUser SetNFSUserRequestType

func init() {
	t["SetNFSUser"] = reflect.TypeOf((*SetNFSUser)(nil)).Elem()
}

// The parameters of `HostStorageSystem.SetNFSUser`.
type SetNFSUserRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// User to be saved on the the esx host
	User string `xml:"user" json:"user"`
	// Password for the user.
	Password string `xml:"password" json:"password"`
}

func init() {
	t["SetNFSUserRequestType"] = reflect.TypeOf((*SetNFSUserRequestType)(nil)).Elem()
}

type SetNFSUserResponse struct {
}

type SetPublicKey SetPublicKeyRequestType

func init() {
	t["SetPublicKey"] = reflect.TypeOf((*SetPublicKey)(nil)).Elem()
}

// The parameters of `ExtensionManager.SetPublicKey`.
type SetPublicKeyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Key of extension to update.
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
	// Public key of extension, encoded
	// in PEM (privacy-enhanced mail) format.
	PublicKey string `xml:"publicKey" json:"publicKey"`
}

func init() {
	t["SetPublicKeyRequestType"] = reflect.TypeOf((*SetPublicKeyRequestType)(nil)).Elem()
}

type SetPublicKeyResponse struct {
}

type SetRegistryValueInGuest SetRegistryValueInGuestRequestType

func init() {
	t["SetRegistryValueInGuest"] = reflect.TypeOf((*SetRegistryValueInGuest)(nil)).Elem()
}

// The parameters of `GuestWindowsRegistryManager.SetRegistryValueInGuest`.
type SetRegistryValueInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Modify
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The information for the registry value to be set/created.
	// The Value "name" (specified in
	// `GuestRegValueNameSpec`)
	// and the Value "data" (specified in
	// `GuestRegValueSpec`)
	// can both be empty. If "name" is empty, it sets the value for
	// the unnamed or default value of the given key.
	Value GuestRegValueSpec `xml:"value" json:"value"`
}

func init() {
	t["SetRegistryValueInGuestRequestType"] = reflect.TypeOf((*SetRegistryValueInGuestRequestType)(nil)).Elem()
}

type SetRegistryValueInGuestResponse struct {
}

type SetScreenResolution SetScreenResolutionRequestType

func init() {
	t["SetScreenResolution"] = reflect.TypeOf((*SetScreenResolution)(nil)).Elem()
}

// The parameters of `VirtualMachine.SetScreenResolution`.
type SetScreenResolutionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The screen width that should be set.
	Width int32 `xml:"width" json:"width"`
	// The screen height that should be set.
	Height int32 `xml:"height" json:"height"`
}

func init() {
	t["SetScreenResolutionRequestType"] = reflect.TypeOf((*SetScreenResolutionRequestType)(nil)).Elem()
}

type SetScreenResolutionResponse struct {
}

type SetServiceAccount SetServiceAccountRequestType

func init() {
	t["SetServiceAccount"] = reflect.TypeOf((*SetServiceAccount)(nil)).Elem()
}

// The parameters of `ExtensionManager.SetServiceAccount`.
type SetServiceAccountRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Key of extension to update.
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
	// account name qualified with SSO domain.
	ServiceAccount string `xml:"serviceAccount" json:"serviceAccount"`
}

func init() {
	t["SetServiceAccountRequestType"] = reflect.TypeOf((*SetServiceAccountRequestType)(nil)).Elem()
	minAPIVersionForType["SetServiceAccountRequestType"] = "8.0.2.0"
}

type SetServiceAccountResponse struct {
}

type SetTaskDescription SetTaskDescriptionRequestType

func init() {
	t["SetTaskDescription"] = reflect.TypeOf((*SetTaskDescription)(nil)).Elem()
}

// The parameters of `Task.SetTaskDescription`.
type SetTaskDescriptionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// New description for task
	Description LocalizableMessage `xml:"description" json:"description"`
}

func init() {
	t["SetTaskDescriptionRequestType"] = reflect.TypeOf((*SetTaskDescriptionRequestType)(nil)).Elem()
}

type SetTaskDescriptionResponse struct {
}

type SetTaskState SetTaskStateRequestType

func init() {
	t["SetTaskState"] = reflect.TypeOf((*SetTaskState)(nil)).Elem()
}

// The parameters of `Task.SetTaskState`.
type SetTaskStateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// New state for task
	State TaskInfoState `xml:"state" json:"state"`
	// Result to set, valid only if task state is
	// TaskInfo.State.success
	Result AnyType `xml:"result,omitempty,typeattr" json:"result,omitempty"`
	// Fault to set, valid only if task state is
	// `error`. The fault must be a of a fault type that
	// directly or indirectly extends `VimFault`.
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["SetTaskStateRequestType"] = reflect.TypeOf((*SetTaskStateRequestType)(nil)).Elem()
}

type SetTaskStateResponse struct {
}

type SetVStorageObjectControlFlags SetVStorageObjectControlFlagsRequestType

func init() {
	t["SetVStorageObjectControlFlags"] = reflect.TypeOf((*SetVStorageObjectControlFlags)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.SetVStorageObjectControlFlags`.
type SetVStorageObjectControlFlagsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage
	// object is located.
	//
	// Required privileges: Datastore.FileManagement
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// control flags enum array to be set on the
	// VStorageObject. All control flags not included
	// in the array remain intact.
	ControlFlags []string `xml:"controlFlags,omitempty" json:"controlFlags,omitempty"`
}

func init() {
	t["SetVStorageObjectControlFlagsRequestType"] = reflect.TypeOf((*SetVStorageObjectControlFlagsRequestType)(nil)).Elem()
}

type SetVStorageObjectControlFlagsResponse struct {
}

type SetVirtualDiskUuid SetVirtualDiskUuidRequestType

func init() {
	t["SetVirtualDiskUuid"] = reflect.TypeOf((*SetVirtualDiskUuid)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.SetVirtualDiskUuidEx_Task`.
type SetVirtualDiskUuidExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk whose uuid for the DDB entry needs to be set.
	// A datastore path has the form
	// > \[_datastore_\] _path_
	//
	// where
	//   - _datastore_ is the datastore name.
	//   - _path_ is a slash-delimited path from the root of the datastore.
	//
	// An example datastore path is "\[storage\] path/to/file.extension".
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path is mandatory. Not needed when invoked directly on ESX.
	// If not specified on a call from VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// The hex representation of the unique ID for this virtual disk. If uuid is not set or missing,
	// a random UUID is generated and assigned.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
}

func init() {
	t["SetVirtualDiskUuidExRequestType"] = reflect.TypeOf((*SetVirtualDiskUuidExRequestType)(nil)).Elem()
	minAPIVersionForType["SetVirtualDiskUuidExRequestType"] = "8.0.3.0"
}

type SetVirtualDiskUuidEx_Task SetVirtualDiskUuidExRequestType

func init() {
	t["SetVirtualDiskUuidEx_Task"] = reflect.TypeOf((*SetVirtualDiskUuidEx_Task)(nil)).Elem()
}

type SetVirtualDiskUuidEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualDiskManager.SetVirtualDiskUuid`.
type SetVirtualDiskUuidRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk whose SCSI inquiry page 0x83
	// data should be set.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// The hex representation of the unique ID for this virtual disk.
	Uuid string `xml:"uuid" json:"uuid"`
}

func init() {
	t["SetVirtualDiskUuidRequestType"] = reflect.TypeOf((*SetVirtualDiskUuidRequestType)(nil)).Elem()
}

type SetVirtualDiskUuidResponse struct {
}

// The virtual machine has one or more SCSI controllers that are engaged
// in bus sharing.
//
// This is an error when migrating a powered-on virtual machine,
// and can be returned as a subfault of DisallowedMigrationDeviceAttached.
type SharedBusControllerNotSupported struct {
	DeviceNotSupported
}

func init() {
	t["SharedBusControllerNotSupported"] = reflect.TypeOf((*SharedBusControllerNotSupported)(nil)).Elem()
}

type SharedBusControllerNotSupportedFault SharedBusControllerNotSupported

func init() {
	t["SharedBusControllerNotSupportedFault"] = reflect.TypeOf((*SharedBusControllerNotSupportedFault)(nil)).Elem()
}

// Specification of shares.
//
// Shares are used to determine relative allocation between resource consumers.
// In general, a consumer with more shares gets proportionally more of
// the resource, subject to certain other constraints.
type SharesInfo struct {
	DynamicData

	// The number of shares allocated.
	//
	// Used to determine resource allocation in case of
	// resource contention. This value is only set if level is set to custom. If level is
	// not set to custom, this value is ignored. Therefore, only shares with custom
	// values can be compared.
	//
	// There is no unit for this value. It is a relative measure based on the settings
	// for other resource pools.
	Shares int32 `xml:"shares" json:"shares"`
	// The allocation level.
	//
	// The level is a simplified view of shares.
	// Levels map to a pre-determined set of numeric values for shares.
	// If the shares value does not map to a predefined size, then
	// the level is set as custom.
	Level SharesLevel `xml:"level" json:"level"`
}

func init() {
	t["SharesInfo"] = reflect.TypeOf((*SharesInfo)(nil)).Elem()
}

// Specification of shares.
//
// Object of this class specifies value ranges for object of
// instance `SharesInfo`
type SharesOption struct {
	DynamicData

	// Value range which can be used for share definition
	// in `SharesInfo.shares`
	SharesOption IntOption `xml:"sharesOption" json:"sharesOption"`
	// Default value for `SharesInfo.level`
	DefaultLevel SharesLevel `xml:"defaultLevel" json:"defaultLevel"`
}

func init() {
	t["SharesOption"] = reflect.TypeOf((*SharesOption)(nil)).Elem()
}

// This exception is thrown when VirtualMachine.shrinkDisk
// encounters an error
type ShrinkDiskFault struct {
	VimFault

	// Disk Id of the virtual disk that caused the fault
	DiskId int32 `xml:"diskId,omitempty" json:"diskId,omitempty"`
}

func init() {
	t["ShrinkDiskFault"] = reflect.TypeOf((*ShrinkDiskFault)(nil)).Elem()
}

type ShrinkDiskFaultFault ShrinkDiskFault

func init() {
	t["ShrinkDiskFaultFault"] = reflect.TypeOf((*ShrinkDiskFaultFault)(nil)).Elem()
}

// The parameters of `VirtualDiskManager.ShrinkVirtualDisk_Task`.
type ShrinkVirtualDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk that should be shrink.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// If true or omitted, performs shrink in copy-shrink mode, otherwise
	// shrink in in-place mode.
	Copy *bool `xml:"copy" json:"copy,omitempty"`
}

func init() {
	t["ShrinkVirtualDiskRequestType"] = reflect.TypeOf((*ShrinkVirtualDiskRequestType)(nil)).Elem()
}

type ShrinkVirtualDisk_Task ShrinkVirtualDiskRequestType

func init() {
	t["ShrinkVirtualDisk_Task"] = reflect.TypeOf((*ShrinkVirtualDisk_Task)(nil)).Elem()
}

type ShrinkVirtualDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ShutdownGuest ShutdownGuestRequestType

func init() {
	t["ShutdownGuest"] = reflect.TypeOf((*ShutdownGuest)(nil)).Elem()
}

type ShutdownGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["ShutdownGuestRequestType"] = reflect.TypeOf((*ShutdownGuestRequestType)(nil)).Elem()
}

type ShutdownGuestResponse struct {
}

// The parameters of `HostSystem.ShutdownHost_Task`.
type ShutdownHostRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Flag to specify whether or not the host should be shut down
	// regardless of whether it is in maintenance mode.
	// If true, the host is shut down, even if there are
	// virtual machines running or other operations in progress.
	Force bool `xml:"force" json:"force"`
}

func init() {
	t["ShutdownHostRequestType"] = reflect.TypeOf((*ShutdownHostRequestType)(nil)).Elem()
}

type ShutdownHost_Task ShutdownHostRequestType

func init() {
	t["ShutdownHost_Task"] = reflect.TypeOf((*ShutdownHost_Task)(nil)).Elem()
}

type ShutdownHost_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This class specifies a single IP address.
type SingleIp struct {
	IpAddress

	// The IP address.
	//
	// The value of this property should either be an
	// IPv4 address such as "192.168.0.1" or an IPv6 address such as
	// "fc00:192:168:0:6cd9:a132:e889:b612"
	Address string `xml:"address" json:"address"`
}

func init() {
	t["SingleIp"] = reflect.TypeOf((*SingleIp)(nil)).Elem()
}

// This class defines a Single MAC address.
type SingleMac struct {
	MacAddress

	// The MAC address.
	//
	// The value for this property should be in the form
	// like "00:50:56:bc:ef:ab".
	Address string `xml:"address" json:"address"`
}

func init() {
	t["SingleMac"] = reflect.TypeOf((*SingleMac)(nil)).Elem()
}

// This data object type represents the external site-related capabilities
// available in the environment managed by this vCenter.
type SiteInfo struct {
	DynamicData
}

func init() {
	t["SiteInfo"] = reflect.TypeOf((*SiteInfo)(nil)).Elem()
}

// An attempt is being made to copy a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host under any circumstances.
//
// This is a warning.
type SnapshotCloneNotSupported struct {
	SnapshotCopyNotSupported
}

func init() {
	t["SnapshotCloneNotSupported"] = reflect.TypeOf((*SnapshotCloneNotSupported)(nil)).Elem()
}

type SnapshotCloneNotSupportedFault SnapshotCloneNotSupported

func init() {
	t["SnapshotCloneNotSupportedFault"] = reflect.TypeOf((*SnapshotCloneNotSupportedFault)(nil)).Elem()
}

// An attempt is being made to move or copy a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported
// because of some aspect of the virtual machine configuration, virtual
// machine power state, or the requested disk placement.
//
// This is an error
// for move operations (where the source is deleted after the copy) and a
// warning for clones (where the source is preserved).
type SnapshotCopyNotSupported struct {
	MigrationFault
}

func init() {
	t["SnapshotCopyNotSupported"] = reflect.TypeOf((*SnapshotCopyNotSupported)(nil)).Elem()
}

type SnapshotCopyNotSupportedFault BaseSnapshotCopyNotSupported

func init() {
	t["SnapshotCopyNotSupportedFault"] = reflect.TypeOf((*SnapshotCopyNotSupportedFault)(nil)).Elem()
}

// Fault thrown if a snapshot operation cannot be performed because
// snapshots are disabled on the virtual machine.
type SnapshotDisabled struct {
	SnapshotFault
}

func init() {
	t["SnapshotDisabled"] = reflect.TypeOf((*SnapshotDisabled)(nil)).Elem()
}

type SnapshotDisabledFault SnapshotDisabled

func init() {
	t["SnapshotDisabledFault"] = reflect.TypeOf((*SnapshotDisabledFault)(nil)).Elem()
}

// Base type for Snapshot-related errors.
type SnapshotFault struct {
	VimFault
}

func init() {
	t["SnapshotFault"] = reflect.TypeOf((*SnapshotFault)(nil)).Elem()
}

type SnapshotFaultFault BaseSnapshotFault

func init() {
	t["SnapshotFaultFault"] = reflect.TypeOf((*SnapshotFaultFault)(nil)).Elem()
}

// Thrown if a snapshot operation cannot be performed on account
// of an incompatible device.
//
// This fault can be thrown for instance
// if a virtual machine uses a raw disk or a shared bus controller.
type SnapshotIncompatibleDeviceInVm struct {
	SnapshotFault

	// A fault specifies the particular device issue.
	//
	// This is typically
	// a subclass of VirtualHardwareCompatibilityIssue, such as
	// RawDiskNotSupported, or SharedBusControllerNotSupported.
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["SnapshotIncompatibleDeviceInVm"] = reflect.TypeOf((*SnapshotIncompatibleDeviceInVm)(nil)).Elem()
}

type SnapshotIncompatibleDeviceInVmFault SnapshotIncompatibleDeviceInVm

func init() {
	t["SnapshotIncompatibleDeviceInVmFault"] = reflect.TypeOf((*SnapshotIncompatibleDeviceInVmFault)(nil)).Elem()
}

// Fault thrown when an attempt is made to create or delete a snapshot on a
// virtual machine that has its snapshot locked.
type SnapshotLocked struct {
	SnapshotFault
}

func init() {
	t["SnapshotLocked"] = reflect.TypeOf((*SnapshotLocked)(nil)).Elem()
}

type SnapshotLockedFault SnapshotLocked

func init() {
	t["SnapshotLockedFault"] = reflect.TypeOf((*SnapshotLockedFault)(nil)).Elem()
}

// An attempt is being made to move a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host because the disk is currently located somewhere other than the virtual
// machine's home datastore.
type SnapshotMoveFromNonHomeNotSupported struct {
	SnapshotCopyNotSupported
}

func init() {
	t["SnapshotMoveFromNonHomeNotSupported"] = reflect.TypeOf((*SnapshotMoveFromNonHomeNotSupported)(nil)).Elem()
}

type SnapshotMoveFromNonHomeNotSupportedFault SnapshotMoveFromNonHomeNotSupported

func init() {
	t["SnapshotMoveFromNonHomeNotSupportedFault"] = reflect.TypeOf((*SnapshotMoveFromNonHomeNotSupportedFault)(nil)).Elem()
}

// An attempt is being made to move a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host under any circumstances.
type SnapshotMoveNotSupported struct {
	SnapshotCopyNotSupported
}

func init() {
	t["SnapshotMoveNotSupported"] = reflect.TypeOf((*SnapshotMoveNotSupported)(nil)).Elem()
}

type SnapshotMoveNotSupportedFault SnapshotMoveNotSupported

func init() {
	t["SnapshotMoveNotSupportedFault"] = reflect.TypeOf((*SnapshotMoveNotSupportedFault)(nil)).Elem()
}

// An attempt is being made to move a virtual machine's disk that has
// associated snapshots, and preserving the snapshots is not supported by the
// host because the disk is being moved to some location other than the new
// home datastore for the virtual machine.
type SnapshotMoveToNonHomeNotSupported struct {
	SnapshotCopyNotSupported
}

func init() {
	t["SnapshotMoveToNonHomeNotSupported"] = reflect.TypeOf((*SnapshotMoveToNonHomeNotSupported)(nil)).Elem()
}

type SnapshotMoveToNonHomeNotSupportedFault SnapshotMoveToNonHomeNotSupported

func init() {
	t["SnapshotMoveToNonHomeNotSupportedFault"] = reflect.TypeOf((*SnapshotMoveToNonHomeNotSupportedFault)(nil)).Elem()
}

// This fault is for a snapshot request on a virtual machine whose state
// has not changed since a previous successful snapshot.
//
// For example, this
// occurs when you suspend the virtual machine, create a snapshot, and
// then request another snapshot of the suspended virtual machine.
type SnapshotNoChange struct {
	SnapshotFault
}

func init() {
	t["SnapshotNoChange"] = reflect.TypeOf((*SnapshotNoChange)(nil)).Elem()
}

type SnapshotNoChangeFault SnapshotNoChange

func init() {
	t["SnapshotNoChangeFault"] = reflect.TypeOf((*SnapshotNoChangeFault)(nil)).Elem()
}

// If the virtual machine is migrated to the destination host, there may be
// a problem reverting to one of its snapshots.
//
// This is a warning. If the
// snapshot name is not set and the event array is empty, then it the snapshot
// might possibly revert correctly. If the name is set and the event array is not
// empty then there surely will be a problem reverting to the snapshot.
type SnapshotRevertIssue struct {
	MigrationFault

	// The name of the problematic snapshot.
	SnapshotName string `xml:"snapshotName,omitempty" json:"snapshotName,omitempty"`
	// The problem(s) that would occur on reverting to the snapshot.
	//
	// This
	// is determined similarly to invoking validateMigration on a powered-off
	// virtual machine with the snapshot's state. However, not all errors
	// or warnings for virtual machine migration are guaranteed to be
	// detected for snapshots.
	Event []BaseEvent `xml:"event,omitempty,typeattr" json:"event,omitempty"`
	// True if any of the events above are error events.
	Errors bool `xml:"errors" json:"errors"`
}

func init() {
	t["SnapshotRevertIssue"] = reflect.TypeOf((*SnapshotRevertIssue)(nil)).Elem()
}

type SnapshotRevertIssueFault SnapshotRevertIssue

func init() {
	t["SnapshotRevertIssueFault"] = reflect.TypeOf((*SnapshotRevertIssueFault)(nil)).Elem()
}

// This data type defines the filtering specification for removing snapshots
// from virtual machine.
type SnapshotSelectionSpec struct {
	DynamicData

	// This is the property to select snapshots older than X days.
	RetentionDays int32 `xml:"retentionDays,omitempty" json:"retentionDays,omitempty"`
}

func init() {
	t["SnapshotSelectionSpec"] = reflect.TypeOf((*SnapshotSelectionSpec)(nil)).Elem()
	minAPIVersionForType["SnapshotSelectionSpec"] = "8.0.3.0"
}

// The current DRS migration priority setting prevents generating
// a recommendation to correct the soft VM/Host affinity rules constraint
// violation for the VM so the violation will not be corrected.
type SoftRuleVioCorrectionDisallowed struct {
	VmConfigFault

	// The vm for which the VM/Host soft affinity rules constraint violation
	// is not being corrected by DRS.
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["SoftRuleVioCorrectionDisallowed"] = reflect.TypeOf((*SoftRuleVioCorrectionDisallowed)(nil)).Elem()
}

type SoftRuleVioCorrectionDisallowedFault SoftRuleVioCorrectionDisallowed

func init() {
	t["SoftRuleVioCorrectionDisallowedFault"] = reflect.TypeOf((*SoftRuleVioCorrectionDisallowedFault)(nil)).Elem()
}

// DRS has determined that correcting the soft VM/Host affinity rules
// constraint violation for the VM impacts respecting cluster constraints
// or performance goals so the violation will not be corrected.
type SoftRuleVioCorrectionImpact struct {
	VmConfigFault

	// The vm for which the VM/Host soft affinity rules constraint violation
	// is not being corrected by DRS.
	VmName string `xml:"vmName" json:"vmName"`
}

func init() {
	t["SoftRuleVioCorrectionImpact"] = reflect.TypeOf((*SoftRuleVioCorrectionImpact)(nil)).Elem()
}

type SoftRuleVioCorrectionImpactFault SoftRuleVioCorrectionImpact

func init() {
	t["SoftRuleVioCorrectionImpactFault"] = reflect.TypeOf((*SoftRuleVioCorrectionImpactFault)(nil)).Elem()
}

// Software Packages provide discrete version and packaging.
//
// This data is reported by CLI:: esxcli software vib get -n ...
type SoftwarePackage struct {
	DynamicData

	// Identifier that uniquely identifies the software package.
	Name string `xml:"name" json:"name"`
	// Version string uniquely identifies this package.
	Version string `xml:"version" json:"version"`
	// Type of vib installed.
	//
	// See `SoftwarePackageVibType_enum`.
	Type string `xml:"type" json:"type"`
	// The corporate entity that created this package.
	Vendor string `xml:"vendor" json:"vendor"`
	// See also `HostImageAcceptanceLevel_enum`.
	AcceptanceLevel string `xml:"acceptanceLevel" json:"acceptanceLevel"`
	// A brief description of the package contents.
	Summary string `xml:"summary" json:"summary"`
	// A full account of the package contents.
	Description string `xml:"description" json:"description"`
	// The list of SupportReference objects with in-depth support information.
	ReferenceURL []string `xml:"referenceURL,omitempty" json:"referenceURL,omitempty"`
	// The time when the package was installed.
	//
	// On Autodeploy stateless installs
	// there is no set value.
	CreationDate *time.Time `xml:"creationDate" json:"creationDate,omitempty"`
	// A list of VIBs that must be installed at the same time as this VIB.
	Depends []Relation `xml:"depends,omitempty" json:"depends,omitempty"`
	// A list of VIBs that cannot be installed at the same time as
	// this VIB for a given version.
	Conflicts []Relation `xml:"conflicts,omitempty" json:"conflicts,omitempty"`
	// A list of SoftwareConstraint objects that identify VIBs that
	// replace this VIB or make it obsolete.
	//
	// VIBs automatically replace VIBs with
	// the same name but lower versions.
	Replaces []Relation `xml:"replaces,omitempty" json:"replaces,omitempty"`
	// A list of virtual packages or interfaces this VIB provides.
	Provides []string `xml:"provides,omitempty" json:"provides,omitempty"`
	// True if hosts must be in maintenance mode for installation of this VIB.
	MaintenanceModeRequired *bool `xml:"maintenanceModeRequired" json:"maintenanceModeRequired,omitempty"`
	// A list of hardware platforms this package is supported on.
	HardwarePlatformsRequired []string `xml:"hardwarePlatformsRequired,omitempty" json:"hardwarePlatformsRequired,omitempty"`
	// A set of optional attributes for this package.
	Capability SoftwarePackageCapability `xml:"capability" json:"capability"`
	// A list of string tags for this package defined by the vendor
	// or publisher.
	//
	// Tags can be used to identify characteristics of a package.
	Tag []string `xml:"tag,omitempty" json:"tag,omitempty"`
	// A list of string tags to indicate one or more of what is
	// contained: may be one of bootloader, upgrade, bootisobios, bootisoefi,
	// vgz, tgz, boot or other values.
	Payload []string `xml:"payload,omitempty" json:"payload,omitempty"`
}

func init() {
	t["SoftwarePackage"] = reflect.TypeOf((*SoftwarePackage)(nil)).Elem()
}

type SoftwarePackageCapability struct {
	DynamicData

	// True if live installs of this VIB are supported.
	LiveInstallAllowed *bool `xml:"liveInstallAllowed" json:"liveInstallAllowed,omitempty"`
	// True if live removals of this VIB are supported.
	LiveRemoveAllowed *bool `xml:"liveRemoveAllowed" json:"liveRemoveAllowed,omitempty"`
	// True if the package supports host profiles or other technologies
	// that make it suitable for use in conjunction with vSphere Auto Deploy.
	StatelessReady *bool `xml:"statelessReady" json:"statelessReady,omitempty"`
	// True if this vib will supplant files from another package at runtime.
	//
	// When False this prevents two packages from installing the same file.
	Overlay *bool `xml:"overlay" json:"overlay,omitempty"`
}

func init() {
	t["SoftwarePackageCapability"] = reflect.TypeOf((*SoftwarePackageCapability)(nil)).Elem()
}

// Thrown when an operation is denied because the entity
// invoking it is not a Solution User.
type SolutionUserRequired struct {
	SecurityError
}

func init() {
	t["SolutionUserRequired"] = reflect.TypeOf((*SolutionUserRequired)(nil)).Elem()
}

type SolutionUserRequiredFault SolutionUserRequired

func init() {
	t["SolutionUserRequiredFault"] = reflect.TypeOf((*SolutionUserRequiredFault)(nil)).Elem()
}

// The SourceNodeSpec class defines specification of
// the source node that is used to initiate the configuration or
// deployment for VCHA.
type SourceNodeSpec struct {
	DynamicData

	// Credentials for the management vCenter Server that is managing
	// this node.
	ManagementVc ServiceLocator `xml:"managementVc" json:"managementVc"`
	// VirtualMachine reference for this vCenter Server.
	//
	// Refers instance of `VirtualMachine`.
	ActiveVc ManagedObjectReference `xml:"activeVc" json:"activeVc"`
}

func init() {
	t["SourceNodeSpec"] = reflect.TypeOf((*SourceNodeSpec)(nil)).Elem()
}

// A SsdDiskNotAvailable fault indicating that the specified SSD
// disk is not available.
//
// The disk either has been used or not a
// SSD disk.
type SsdDiskNotAvailable struct {
	VimFault

	// The device path of the disk.
	//
	// See also `HostScsiDisk.devicePath`.
	DevicePath string `xml:"devicePath" json:"devicePath"`
}

func init() {
	t["SsdDiskNotAvailable"] = reflect.TypeOf((*SsdDiskNotAvailable)(nil)).Elem()
}

type SsdDiskNotAvailableFault SsdDiskNotAvailable

func init() {
	t["SsdDiskNotAvailableFault"] = reflect.TypeOf((*SsdDiskNotAvailableFault)(nil)).Elem()
}

// The parameters of `HostPatchManager.StageHostPatch_Task`.
type StageHostPatchRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A list of urls pointing to metadata.zip.
	MetaUrls []string `xml:"metaUrls,omitempty" json:"metaUrls,omitempty"`
	// a list of urls pointing to an "offline" bundle. It is not supported in 5.0 or later.
	BundleUrls []string `xml:"bundleUrls,omitempty" json:"bundleUrls,omitempty"`
	// The urls of update binary files to be staged.
	VibUrls []string                                   `xml:"vibUrls,omitempty" json:"vibUrls,omitempty"`
	Spec    *HostPatchManagerPatchManagerOperationSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["StageHostPatchRequestType"] = reflect.TypeOf((*StageHostPatchRequestType)(nil)).Elem()
}

type StageHostPatch_Task StageHostPatchRequestType

func init() {
	t["StageHostPatch_Task"] = reflect.TypeOf((*StageHostPatch_Task)(nil)).Elem()
}

type StageHostPatch_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type StampAllRulesWithUuidRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["StampAllRulesWithUuidRequestType"] = reflect.TypeOf((*StampAllRulesWithUuidRequestType)(nil)).Elem()
}

type StampAllRulesWithUuid_Task StampAllRulesWithUuidRequestType

func init() {
	t["StampAllRulesWithUuid_Task"] = reflect.TypeOf((*StampAllRulesWithUuid_Task)(nil)).Elem()
}

type StampAllRulesWithUuid_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type StandbyGuest StandbyGuestRequestType

func init() {
	t["StandbyGuest"] = reflect.TypeOf((*StandbyGuest)(nil)).Elem()
}

type StandbyGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["StandbyGuestRequestType"] = reflect.TypeOf((*StandbyGuestRequestType)(nil)).Elem()
}

type StandbyGuestResponse struct {
}

// The parameters of `VirtualMachineGuestCustomizationManager.StartGuestNetwork_Task`.
type StartGuestNetworkRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The Virtual Machine managed object reference.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
}

func init() {
	t["StartGuestNetworkRequestType"] = reflect.TypeOf((*StartGuestNetworkRequestType)(nil)).Elem()
}

type StartGuestNetwork_Task StartGuestNetworkRequestType

func init() {
	t["StartGuestNetwork_Task"] = reflect.TypeOf((*StartGuestNetwork_Task)(nil)).Elem()
}

type StartGuestNetwork_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type StartProgramInGuest StartProgramInGuestRequestType

func init() {
	t["StartProgramInGuest"] = reflect.TypeOf((*StartProgramInGuest)(nil)).Elem()
}

// The parameters of `GuestProcessManager.StartProgramInGuest`.
type StartProgramInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Execute
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// The arguments describing the program to be started.
	Spec BaseGuestProgramSpec `xml:"spec,typeattr" json:"spec"`
}

func init() {
	t["StartProgramInGuestRequestType"] = reflect.TypeOf((*StartProgramInGuestRequestType)(nil)).Elem()
}

type StartProgramInGuestResponse struct {
	Returnval int64 `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.StartRecording_Task`.
type StartRecordingRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name for the snapshot associated with this recording.
	// The name need not be unique for this virtual machine.
	Name string `xml:"name" json:"name"`
	// A description for the snapshot associated with this
	// recording. If omitted, a default description may be provided.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
}

func init() {
	t["StartRecordingRequestType"] = reflect.TypeOf((*StartRecordingRequestType)(nil)).Elem()
}

type StartRecording_Task StartRecordingRequestType

func init() {
	t["StartRecording_Task"] = reflect.TypeOf((*StartRecording_Task)(nil)).Elem()
}

type StartRecording_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.StartReplaying_Task`.
type StartReplayingRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The snapshot from which to start the replay. This
	// snapshot must have been created by a record operation on the
	// virtual machine.
	//
	// Refers instance of `VirtualMachineSnapshot`.
	ReplaySnapshot ManagedObjectReference `xml:"replaySnapshot" json:"replaySnapshot"`
}

func init() {
	t["StartReplayingRequestType"] = reflect.TypeOf((*StartReplayingRequestType)(nil)).Elem()
}

type StartReplaying_Task StartReplayingRequestType

func init() {
	t["StartReplaying_Task"] = reflect.TypeOf((*StartReplaying_Task)(nil)).Elem()
}

type StartReplaying_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type StartService StartServiceRequestType

func init() {
	t["StartService"] = reflect.TypeOf((*StartService)(nil)).Elem()
}

// The parameters of `HostServiceSystem.StartService`.
type StartServiceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Service identifier
	// (`HostServiceSystem.serviceInfo*.*HostServiceInfo.service*.*HostService.key`).
	Id string `xml:"id" json:"id"`
}

func init() {
	t["StartServiceRequestType"] = reflect.TypeOf((*StartServiceRequestType)(nil)).Elem()
}

type StartServiceResponse struct {
}

// An alarm expression that uses the running state of either a virtual machine or
// a host as the condition that triggers the alarm.
//
// Base type.
//
// There are two alarm operands: yellow and red. At least one of them
// must be set. The value of the alarm expression is determined as follows:
//   - If the red state is set but the yellow state is not: the expression is red when
//     the state operand matches (isEqual operator) or does not match (isUnequal operator)
//     the state of the managed entity. The expression is green otherwise.
//   - If yellow is set but red is not: the expression is yellow when
//     the state operand matches (isEqual) or does not match (isUnequal)
//     the state of the managed entity. The expression is green otherwise.
//   - If both yellow and red are set, the value of the expression is red when
//     the red state operand matches (isEqual) or does not match (isUnequal)
//     the state of the managed entity. Otherwise, the expression is
//     yellow when the yellow state operand matches (isEqual) or does not match (isUnequal)
//     the state of the managed entity. Otherwise, the expression is green.
type StateAlarmExpression struct {
	AlarmExpression

	// The operation to be tested on the target state.
	Operator StateAlarmOperator `xml:"operator" json:"operator"`
	// Name of the object type containing the property.
	Type string `xml:"type" json:"type"`
	// Path of the state property.
	//
	// The supported values:
	//   - for vim.VirtualMachine type:
	//   - runtime.powerState or summary.quickStats.guestHeartbeatStatus
	//   - for vim.HostSystem type: runtime.connectionState
	StatePath string `xml:"statePath" json:"statePath"`
	// Whether or not to test for a yellow condition.
	//
	// If this property is not set, do not calculate yellow status.
	Yellow string `xml:"yellow,omitempty" json:"yellow,omitempty"`
	// Whether or not to test for a red condition.
	//
	// If this property is not set, do not calculate red status.
	Red string `xml:"red,omitempty" json:"red,omitempty"`
}

func init() {
	t["StateAlarmExpression"] = reflect.TypeOf((*StateAlarmExpression)(nil)).Elem()
}

// The `StaticRouteProfile` data object represents a single static IP route.
//
// The `ApplyProfile.policy` property contains
// data values for static route configuration.
type StaticRouteProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
}

func init() {
	t["StaticRouteProfile"] = reflect.TypeOf((*StaticRouteProfile)(nil)).Elem()
}

type StopRecordingRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["StopRecordingRequestType"] = reflect.TypeOf((*StopRecordingRequestType)(nil)).Elem()
}

type StopRecording_Task StopRecordingRequestType

func init() {
	t["StopRecording_Task"] = reflect.TypeOf((*StopRecording_Task)(nil)).Elem()
}

type StopRecording_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type StopReplayingRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["StopReplayingRequestType"] = reflect.TypeOf((*StopReplayingRequestType)(nil)).Elem()
}

type StopReplaying_Task StopReplayingRequestType

func init() {
	t["StopReplaying_Task"] = reflect.TypeOf((*StopReplaying_Task)(nil)).Elem()
}

type StopReplaying_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type StopService StopServiceRequestType

func init() {
	t["StopService"] = reflect.TypeOf((*StopService)(nil)).Elem()
}

// The parameters of `HostServiceSystem.StopService`.
type StopServiceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Service identifier
	// (`HostServiceSystem.serviceInfo*.*HostServiceInfo.service*.*HostService.key`).
	Id string `xml:"id" json:"id"`
}

func init() {
	t["StopServiceRequestType"] = reflect.TypeOf((*StopServiceRequestType)(nil)).Elem()
}

type StopServiceResponse struct {
}

// Storage DRS fine grain automation controls
type StorageDrsAutomationConfig struct {
	DynamicData

	// Specifies the behavior of Storage DRS when it generates
	// recommendations for correcting space load imbalance in a
	// datastore cluster.
	//
	// See `StorageDrsPodConfigInfo`. If specified, this option
	// overrides the datastore cluster level automation behavior defined in the
	// `StorageDrsPodConfigInfo`.
	SpaceLoadBalanceAutomationMode string `xml:"spaceLoadBalanceAutomationMode,omitempty" json:"spaceLoadBalanceAutomationMode,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Specifies the behavior of Storage DRS when it generates
	// recommendations for correcting I/O load imbalance in a datastore
	// cluster.
	//
	// See `StorageDrsPodConfigInfo`. If specified, this option
	// overrides the datastore cluster level automation behavior defined in the
	// `StorageDrsPodConfigInfo`.
	IoLoadBalanceAutomationMode string `xml:"ioLoadBalanceAutomationMode,omitempty" json:"ioLoadBalanceAutomationMode,omitempty"`
	// Specifies the behavior of Storage DRS when it generates
	// recommendations for correcting affinity rule violations in a
	// datastore cluster.
	//
	// See `StorageDrsPodConfigInfoBehavior_enum`. If
	// specified, this option overrides the datastore cluster level
	// automation behavior defined in the `StorageDrsPodConfigInfo` for
	// recommendations aimed at fixing rule violations.
	RuleEnforcementAutomationMode string `xml:"ruleEnforcementAutomationMode,omitempty" json:"ruleEnforcementAutomationMode,omitempty"`
	// Specifies the behavior of Storage DRS when it generates
	// recommendations for correcting storage and Vm policy violations
	// in a datastore cluster.
	//
	// See `StorageDrsPodConfigInfoBehavior_enum`. If
	// specified, this option overrides the datastore cluster level
	// automation behavior defined in the `StorageDrsPodConfigInfo` for
	// recommendations aimed at fixing storage policy violations.
	PolicyEnforcementAutomationMode string `xml:"policyEnforcementAutomationMode,omitempty" json:"policyEnforcementAutomationMode,omitempty"`
	// Specifies the behavior of Storage DRS when it generates
	// recommendations for datastore evacuations in a datastore
	// cluster.
	//
	// See `StorageDrsPodConfigInfoBehavior_enum`. If specified, this
	// option overrides the datastore cluster level automation behavior
	// defined in the `StorageDrsPodConfigInfo` for recommendations aimed at
	// evacuating Vms from a datastore.
	VmEvacuationAutomationMode string `xml:"vmEvacuationAutomationMode,omitempty" json:"vmEvacuationAutomationMode,omitempty"`
}

func init() {
	t["StorageDrsAutomationConfig"] = reflect.TypeOf((*StorageDrsAutomationConfig)(nil)).Elem()
}

// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate one or more virtual disks of a VM because the disk has
// multi-writer mode enabled.
type StorageDrsCannotMoveDiskInMultiWriterMode struct {
	VimFault
}

func init() {
	t["StorageDrsCannotMoveDiskInMultiWriterMode"] = reflect.TypeOf((*StorageDrsCannotMoveDiskInMultiWriterMode)(nil)).Elem()
}

type StorageDrsCannotMoveDiskInMultiWriterModeFault StorageDrsCannotMoveDiskInMultiWriterMode

func init() {
	t["StorageDrsCannotMoveDiskInMultiWriterModeFault"] = reflect.TypeOf((*StorageDrsCannotMoveDiskInMultiWriterModeFault)(nil)).Elem()
}

// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate Fault Tolerant VMs across datastores.
type StorageDrsCannotMoveFTVm struct {
	VimFault
}

func init() {
	t["StorageDrsCannotMoveFTVm"] = reflect.TypeOf((*StorageDrsCannotMoveFTVm)(nil)).Elem()
}

type StorageDrsCannotMoveFTVmFault StorageDrsCannotMoveFTVm

func init() {
	t["StorageDrsCannotMoveFTVmFault"] = reflect.TypeOf((*StorageDrsCannotMoveFTVmFault)(nil)).Elem()
}

// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate an independent disk.
type StorageDrsCannotMoveIndependentDisk struct {
	VimFault
}

func init() {
	t["StorageDrsCannotMoveIndependentDisk"] = reflect.TypeOf((*StorageDrsCannotMoveIndependentDisk)(nil)).Elem()
}

type StorageDrsCannotMoveIndependentDiskFault StorageDrsCannotMoveIndependentDisk

func init() {
	t["StorageDrsCannotMoveIndependentDiskFault"] = reflect.TypeOf((*StorageDrsCannotMoveIndependentDiskFault)(nil)).Elem()
}

// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate VM because it has a manually selected fixed location for its
// swap file.
type StorageDrsCannotMoveManuallyPlacedSwapFile struct {
	VimFault
}

func init() {
	t["StorageDrsCannotMoveManuallyPlacedSwapFile"] = reflect.TypeOf((*StorageDrsCannotMoveManuallyPlacedSwapFile)(nil)).Elem()
}

type StorageDrsCannotMoveManuallyPlacedSwapFileFault StorageDrsCannotMoveManuallyPlacedSwapFile

func init() {
	t["StorageDrsCannotMoveManuallyPlacedSwapFileFault"] = reflect.TypeOf((*StorageDrsCannotMoveManuallyPlacedSwapFileFault)(nil)).Elem()
}

// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate a Vm that is placed by user to a specific datastore.
type StorageDrsCannotMoveManuallyPlacedVm struct {
	VimFault
}

func init() {
	t["StorageDrsCannotMoveManuallyPlacedVm"] = reflect.TypeOf((*StorageDrsCannotMoveManuallyPlacedVm)(nil)).Elem()
}

type StorageDrsCannotMoveManuallyPlacedVmFault StorageDrsCannotMoveManuallyPlacedVm

func init() {
	t["StorageDrsCannotMoveManuallyPlacedVmFault"] = reflect.TypeOf((*StorageDrsCannotMoveManuallyPlacedVmFault)(nil)).Elem()
}

// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate a shared virtual disk that is attached to more than one Vm.
type StorageDrsCannotMoveSharedDisk struct {
	VimFault
}

func init() {
	t["StorageDrsCannotMoveSharedDisk"] = reflect.TypeOf((*StorageDrsCannotMoveSharedDisk)(nil)).Elem()
}

type StorageDrsCannotMoveSharedDiskFault StorageDrsCannotMoveSharedDisk

func init() {
	t["StorageDrsCannotMoveSharedDiskFault"] = reflect.TypeOf((*StorageDrsCannotMoveSharedDiskFault)(nil)).Elem()
}

// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate template VMs across datastores.
type StorageDrsCannotMoveTemplate struct {
	VimFault
}

func init() {
	t["StorageDrsCannotMoveTemplate"] = reflect.TypeOf((*StorageDrsCannotMoveTemplate)(nil)).Elem()
}

type StorageDrsCannotMoveTemplateFault StorageDrsCannotMoveTemplate

func init() {
	t["StorageDrsCannotMoveTemplateFault"] = reflect.TypeOf((*StorageDrsCannotMoveTemplateFault)(nil)).Elem()
}

// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate VMs placed in user-specified folders.
type StorageDrsCannotMoveVmInUserFolder struct {
	VimFault
}

func init() {
	t["StorageDrsCannotMoveVmInUserFolder"] = reflect.TypeOf((*StorageDrsCannotMoveVmInUserFolder)(nil)).Elem()
}

type StorageDrsCannotMoveVmInUserFolderFault StorageDrsCannotMoveVmInUserFolder

func init() {
	t["StorageDrsCannotMoveVmInUserFolderFault"] = reflect.TypeOf((*StorageDrsCannotMoveVmInUserFolderFault)(nil)).Elem()
}

// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate VMs that have a CD-ROM device mounted.
type StorageDrsCannotMoveVmWithMountedCDROM struct {
	VimFault
}

func init() {
	t["StorageDrsCannotMoveVmWithMountedCDROM"] = reflect.TypeOf((*StorageDrsCannotMoveVmWithMountedCDROM)(nil)).Elem()
}

type StorageDrsCannotMoveVmWithMountedCDROMFault StorageDrsCannotMoveVmWithMountedCDROM

func init() {
	t["StorageDrsCannotMoveVmWithMountedCDROMFault"] = reflect.TypeOf((*StorageDrsCannotMoveVmWithMountedCDROMFault)(nil)).Elem()
}

// This fault is thrown because Storage DRS cannot generate recommendations
// to relocate VMs that have no files in its file layout.
type StorageDrsCannotMoveVmWithNoFilesInLayout struct {
	VimFault
}

func init() {
	t["StorageDrsCannotMoveVmWithNoFilesInLayout"] = reflect.TypeOf((*StorageDrsCannotMoveVmWithNoFilesInLayout)(nil)).Elem()
}

type StorageDrsCannotMoveVmWithNoFilesInLayoutFault StorageDrsCannotMoveVmWithNoFilesInLayout

func init() {
	t["StorageDrsCannotMoveVmWithNoFilesInLayoutFault"] = reflect.TypeOf((*StorageDrsCannotMoveVmWithNoFilesInLayoutFault)(nil)).Elem()
}

// The `StorageDrsConfigInfo` data object describes storage DRS configuration
// for a pod `StoragePod`.
type StorageDrsConfigInfo struct {
	DynamicData

	// Pod-wide configuration of the storage DRS service.
	PodConfig StorageDrsPodConfigInfo `xml:"podConfig" json:"podConfig"`
	// List of virtual machine configurations for the storage DRS
	// service.
	//
	// Each entry applies to all the virtual disks of the virtual machine
	// on this pod.
	//
	// If a virtual machine is not specified in this array, the service uses
	// the default settings for that virtual machine.
	VmConfig []StorageDrsVmConfigInfo `xml:"vmConfig,omitempty" json:"vmConfig,omitempty"`
}

func init() {
	t["StorageDrsConfigInfo"] = reflect.TypeOf((*StorageDrsConfigInfo)(nil)).Elem()
}

// The `StorageDrsConfigSpec` data object provides a set of update
// specifications for storage DRS configuration.
//
// To support
// incremental changes, these properties are all optional.
type StorageDrsConfigSpec struct {
	DynamicData

	// Changes to the configuration of the storage DRS service.
	PodConfigSpec *StorageDrsPodConfigSpec `xml:"podConfigSpec,omitempty" json:"podConfigSpec,omitempty"`
	// Changes to the per-virtual-machine storage DRS settings.
	VmConfigSpec []StorageDrsVmConfigSpec `xml:"vmConfigSpec,omitempty" json:"vmConfigSpec,omitempty"`
}

func init() {
	t["StorageDrsConfigSpec"] = reflect.TypeOf((*StorageDrsConfigSpec)(nil)).Elem()
}

// This fault is thrown when one datastore using Storage DRS is added to two
// different datacenters.
type StorageDrsDatacentersCannotShareDatastore struct {
	VimFault
}

func init() {
	t["StorageDrsDatacentersCannotShareDatastore"] = reflect.TypeOf((*StorageDrsDatacentersCannotShareDatastore)(nil)).Elem()
}

type StorageDrsDatacentersCannotShareDatastoreFault StorageDrsDatacentersCannotShareDatastore

func init() {
	t["StorageDrsDatacentersCannotShareDatastoreFault"] = reflect.TypeOf((*StorageDrsDatacentersCannotShareDatastoreFault)(nil)).Elem()
}

// This fault is thrown when Storage DRS cannot move disks of a virtual machine
// because Storage DRS is disabled on it.
type StorageDrsDisabledOnVm struct {
	VimFault
}

func init() {
	t["StorageDrsDisabledOnVm"] = reflect.TypeOf((*StorageDrsDisabledOnVm)(nil)).Elem()
}

type StorageDrsDisabledOnVmFault StorageDrsDisabledOnVm

func init() {
	t["StorageDrsDisabledOnVmFault"] = reflect.TypeOf((*StorageDrsDisabledOnVmFault)(nil)).Elem()
}

// This fault is thrown when HMS service cannot move certain secondary
// replica disks per Storage DRS move recommendations
type StorageDrsHbrDiskNotMovable struct {
	VimFault

	// Comma-separated list of disk IDs that are not movable and failed
	// Storage DRS recommendation action.
	NonMovableDiskIds string `xml:"nonMovableDiskIds" json:"nonMovableDiskIds"`
}

func init() {
	t["StorageDrsHbrDiskNotMovable"] = reflect.TypeOf((*StorageDrsHbrDiskNotMovable)(nil)).Elem()
}

type StorageDrsHbrDiskNotMovableFault StorageDrsHbrDiskNotMovable

func init() {
	t["StorageDrsHbrDiskNotMovableFault"] = reflect.TypeOf((*StorageDrsHbrDiskNotMovableFault)(nil)).Elem()
}

// This fault is thrown HMS service is in the process of moving
// a subset of disks for which Storage DRS recommendation is generated.
type StorageDrsHmsMoveInProgress struct {
	VimFault
}

func init() {
	t["StorageDrsHmsMoveInProgress"] = reflect.TypeOf((*StorageDrsHmsMoveInProgress)(nil)).Elem()
}

type StorageDrsHmsMoveInProgressFault StorageDrsHmsMoveInProgress

func init() {
	t["StorageDrsHmsMoveInProgressFault"] = reflect.TypeOf((*StorageDrsHmsMoveInProgressFault)(nil)).Elem()
}

// This fault is thrown when Storage DRS cannot connect to HMS service
// or HMS APIs invoked by Storage DRS error out due to connection issues.
type StorageDrsHmsUnreachable struct {
	VimFault
}

func init() {
	t["StorageDrsHmsUnreachable"] = reflect.TypeOf((*StorageDrsHmsUnreachable)(nil)).Elem()
}

type StorageDrsHmsUnreachableFault StorageDrsHmsUnreachable

func init() {
	t["StorageDrsHmsUnreachableFault"] = reflect.TypeOf((*StorageDrsHmsUnreachableFault)(nil)).Elem()
}

// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
//
// Storage DRS configuration for I/O load balancing.
type StorageDrsIoLoadBalanceConfig struct {
	DynamicData

	// Storage DRS makes storage migration recommendations if total
	// IOPs reservation of all VMs running on a datastore is higher than
	// the specified threshold.
	//
	// Storage DRS recommends migration out of
	// all such datastores, if more than one datastore exceed their reserved
	// IOPs threshold.
	//
	// The actual Iops used to determine threshold are computed from Storage
	// DRS estimation of IOPs capacity of a datastore. The absolute value
	// may change over time, according to storage response to workloads.
	//
	// The valid values are in the range of 30 (i.e., 30%) to 100 (i.e., 100%).
	// If not specified, the default value is 60%.
	ReservablePercentThreshold int32 `xml:"reservablePercentThreshold,omitempty" json:"reservablePercentThreshold,omitempty"`
	// Storage DRS makes storage migration recommendations if total
	// IOPs reservation of all VMs running on a datastore is higher than
	// the specified threshold.
	//
	// Storage DRS recommends migration out of
	// all such datastores, if more than one datastore exceed their reserved
	// IOPs threshold.
	//
	// This is an advanced option, and should only be used if Storage DRS
	// estimated IOPs capacity is incorrect for datastores. The value
	// should be based on conservative estimate of storage performance,
	// and ideally should be set to about 50-60% of worse case peak
	// performance of backing LUN.
	ReservableIopsThreshold int32 `xml:"reservableIopsThreshold,omitempty" json:"reservableIopsThreshold,omitempty"`
	// Determines which reservation threshold specification to use.
	//
	// See `StorageDrsPodConfigInfoBehavior_enum`. If unspecified, the
	// mode is assumed automatic by default. Storage DRS uses
	// percentage value in that case.
	// If mode is specified, but corresponding reservationThreshold
	// value is absent, option specific defaults are used.
	ReservableThresholdMode string `xml:"reservableThresholdMode,omitempty" json:"reservableThresholdMode,omitempty"`
	// Storage DRS makes storage migration recommendations if
	// I/O latency on one (or more) of the datastores is higher than
	// the specified threshold.
	//
	// Unit: millisecond.
	// The valid values are in the range of 5 to 100. If not specified,
	// the default value is 15.
	IoLatencyThreshold int32 `xml:"ioLatencyThreshold,omitempty" json:"ioLatencyThreshold,omitempty"`
	// Storage DRS makes storage migration recommendations if
	// I/O load imbalance level is higher than the specified threshold.
	//
	// Unit: a number.
	// The valid values are in the range of 1 to 100. If not specified,
	// the default value is 5.
	IoLoadImbalanceThreshold int32 `xml:"ioLoadImbalanceThreshold,omitempty" json:"ioLoadImbalanceThreshold,omitempty"`
}

func init() {
	t["StorageDrsIoLoadBalanceConfig"] = reflect.TypeOf((*StorageDrsIoLoadBalanceConfig)(nil)).Elem()
}

// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
//
// The fault occurs when Storage DRS disables IO Load balancing internally
// even though it is enabled by the user.
//
// This can happen due to one of the
// following reasons:
// 1\. SIOC couldn't get enabled on at least one of the datastores
// 2\. The connectivity between hosts and datastores is not uniform for all datastores.
// 3\. Some statistics are not available to run IO load balancing
type StorageDrsIolbDisabledInternally struct {
	VimFault
}

func init() {
	t["StorageDrsIolbDisabledInternally"] = reflect.TypeOf((*StorageDrsIolbDisabledInternally)(nil)).Elem()
}

type StorageDrsIolbDisabledInternallyFault StorageDrsIolbDisabledInternally

func init() {
	t["StorageDrsIolbDisabledInternallyFault"] = reflect.TypeOf((*StorageDrsIolbDisabledInternallyFault)(nil)).Elem()
}

// An incremental update to the advance settings.
type StorageDrsOptionSpec struct {
	ArrayUpdateSpec

	Option BaseOptionValue `xml:"option,omitempty,typeattr" json:"option,omitempty"`
}

func init() {
	t["StorageDrsOptionSpec"] = reflect.TypeOf((*StorageDrsOptionSpec)(nil)).Elem()
}

type StorageDrsPlacementRankVmSpec struct {
	DynamicData

	// Individual VM placement specification for ranking clusters
	VmPlacementSpec PlacementSpec `xml:"vmPlacementSpec" json:"vmPlacementSpec"`
	// Set of candidate clusters for the placement request
	//
	// Refers instances of `ClusterComputeResource`.
	VmClusters []ManagedObjectReference `xml:"vmClusters" json:"vmClusters"`
}

func init() {
	t["StorageDrsPlacementRankVmSpec"] = reflect.TypeOf((*StorageDrsPlacementRankVmSpec)(nil)).Elem()
}

// The `StorageDrsPodConfigInfo` data object contains pod-wide configuration information
// for the storage DRS service.
type StorageDrsPodConfigInfo struct {
	DynamicData

	// Flag indicating whether or not storage DRS is enabled.
	Enabled bool `xml:"enabled" json:"enabled"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Flag indicating whether or not storage DRS takes into account storage I/O
	// workload when making load balancing and initial placement recommendations.
	IoLoadBalanceEnabled bool `xml:"ioLoadBalanceEnabled" json:"ioLoadBalanceEnabled"`
	// Specifies the pod-wide default storage DRS behavior for virtual machines.
	//
	// For currently supported storage DRS behavior, see `StorageDrsPodConfigInfoBehavior_enum`.
	// You can override the default behavior for a virtual machine
	// by using the `StorageDrsVmConfigInfo` object.
	DefaultVmBehavior string `xml:"defaultVmBehavior" json:"defaultVmBehavior"`
	// Specify the interval that storage DRS runs to load balance among datastores
	// within a storage pod.
	//
	// Unit: minute.
	// The valid values are from 60 (1 hour) to 43200 (30 days).
	// If not specified, the default value is 480 (8 hours).
	LoadBalanceInterval int32 `xml:"loadBalanceInterval,omitempty" json:"loadBalanceInterval,omitempty"`
	// Specifies whether or not each virtual machine in this pod should have its virtual
	// disks on the same datastore by default.
	//
	// If set to true, virtual machines will have
	// all their virtual disks on the same datastore. If set to false, the virtual disks
	// of a virtual machine may or may not be placed on the same datastore.
	// If not set, the default value is true.
	// You can override the default behavior for a virtual machine
	// by using the `StorageDrsVmConfigInfo` object.
	DefaultIntraVmAffinity *bool `xml:"defaultIntraVmAffinity" json:"defaultIntraVmAffinity,omitempty"`
	// The configuration settings for load balancing storage space.
	SpaceLoadBalanceConfig *StorageDrsSpaceLoadBalanceConfig `xml:"spaceLoadBalanceConfig,omitempty" json:"spaceLoadBalanceConfig,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// The configuration settings for load balancing I/O workload.
	//
	// This takes effect only if `StorageDrsPodConfigInfo.ioLoadBalanceEnabled` is <code>true</code>.
	IoLoadBalanceConfig *StorageDrsIoLoadBalanceConfig `xml:"ioLoadBalanceConfig,omitempty" json:"ioLoadBalanceConfig,omitempty"`
	// Configuration settings for fine-grain automation overrides on
	// the cluster level setting.
	AutomationOverrides *StorageDrsAutomationConfig `xml:"automationOverrides,omitempty" json:"automationOverrides,omitempty"`
	// Pod-wide rules.
	Rule []BaseClusterRuleInfo `xml:"rule,omitempty,typeattr" json:"rule,omitempty"`
	// Advanced settings.
	Option []BaseOptionValue `xml:"option,omitempty,typeattr" json:"option,omitempty"`
}

func init() {
	t["StorageDrsPodConfigInfo"] = reflect.TypeOf((*StorageDrsPodConfigInfo)(nil)).Elem()
}

// The `StorageDrsPodConfigSpec` data object provides a set of update
// specifications for pod-wide storage DRS configuration.
//
// To support
// incremental changes, these properties are all optional.
type StorageDrsPodConfigSpec struct {
	DynamicData

	// Flag indicating whether or not storage DRS is enabled.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Flag indicating whether or not storage DRS takes into account storage I/O
	// workload when making load balancing and initial placement recommendations.
	IoLoadBalanceEnabled *bool `xml:"ioLoadBalanceEnabled" json:"ioLoadBalanceEnabled,omitempty"`
	// Specifies the pod-wide default storage DRS behavior for virtual machines.
	//
	// For currently supported storage DRS behavior, see `StorageDrsPodConfigInfoBehavior_enum`.
	// You can override the default behavior for a virtual machine
	// by using the `StorageDrsVmConfigInfo` object.
	DefaultVmBehavior string `xml:"defaultVmBehavior,omitempty" json:"defaultVmBehavior,omitempty"`
	// Specify the interval that storage DRS runs to load balance among datastores
	// within a storage pod.
	LoadBalanceInterval int32 `xml:"loadBalanceInterval,omitempty" json:"loadBalanceInterval,omitempty"`
	// Specifies whether or not each virtual machine in this pod should have its virtual
	// disks on the same datastore by default.
	DefaultIntraVmAffinity *bool `xml:"defaultIntraVmAffinity" json:"defaultIntraVmAffinity,omitempty"`
	// The configuration settings for load balancing storage space.
	SpaceLoadBalanceConfig *StorageDrsSpaceLoadBalanceConfig `xml:"spaceLoadBalanceConfig,omitempty" json:"spaceLoadBalanceConfig,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// The configuration settings for load balancing I/O workload.
	//
	// This takes effect only if `StorageDrsPodConfigInfo.ioLoadBalanceEnabled` is <code>true</code>.
	IoLoadBalanceConfig *StorageDrsIoLoadBalanceConfig `xml:"ioLoadBalanceConfig,omitempty" json:"ioLoadBalanceConfig,omitempty"`
	// Configuration settings for fine-grain automation overrides on
	// the cluster level setting.
	AutomationOverrides *StorageDrsAutomationConfig `xml:"automationOverrides,omitempty" json:"automationOverrides,omitempty"`
	// Changes to the set of rules.
	Rule []ClusterRuleSpec `xml:"rule,omitempty" json:"rule,omitempty"`
	// Changes to advance settings.
	Option []StorageDrsOptionSpec `xml:"option,omitempty" json:"option,omitempty"`
}

func init() {
	t["StorageDrsPodConfigSpec"] = reflect.TypeOf((*StorageDrsPodConfigSpec)(nil)).Elem()
}

// Specification for moving or copying a virtual machine to a different Storage Pod.
type StorageDrsPodSelectionSpec struct {
	DynamicData

	// An optional list that allows specifying the storage pod location
	// for each virtual disk and the VM configurations and overrides to be
	// used during placement.
	InitialVmConfig []VmPodConfigForPlacement `xml:"initialVmConfig,omitempty" json:"initialVmConfig,omitempty"`
	// The storage pod where the virtual machine should be located.
	//
	// Refers instance of `StoragePod`.
	StoragePod *ManagedObjectReference `xml:"storagePod,omitempty" json:"storagePod,omitempty"`
}

func init() {
	t["StorageDrsPodSelectionSpec"] = reflect.TypeOf((*StorageDrsPodSelectionSpec)(nil)).Elem()
}

// This fault is thrown when Storage DRS cannot move disks of a virtual machine
// because the relocate method of the virtual machine is disabled.
type StorageDrsRelocateDisabled struct {
	VimFault
}

func init() {
	t["StorageDrsRelocateDisabled"] = reflect.TypeOf((*StorageDrsRelocateDisabled)(nil)).Elem()
}

type StorageDrsRelocateDisabledFault StorageDrsRelocateDisabled

func init() {
	t["StorageDrsRelocateDisabledFault"] = reflect.TypeOf((*StorageDrsRelocateDisabledFault)(nil)).Elem()
}

// Storage DRS configuration for space load balancing.
type StorageDrsSpaceLoadBalanceConfig struct {
	DynamicData

	SpaceThresholdMode string `xml:"spaceThresholdMode,omitempty" json:"spaceThresholdMode,omitempty"`
	// Storage DRS makes storage migration recommendations if
	// space utilization on one (or more) of the datastores is higher than
	// the specified threshold.
	//
	// The valid values are in the range of 50 (i.e., 50%) to 100 (i.e., 100%).
	// If not specified, the default value is 80%.
	SpaceUtilizationThreshold int32 `xml:"spaceUtilizationThreshold,omitempty" json:"spaceUtilizationThreshold,omitempty"`
	// Storage DRS makes storage migration recommendations if
	// free space on one (or more) of the datastores falls below
	// the specified threshold.
	//
	// The unit is in gigabytes and the minimum value is 1GB.
	// The maximum value is limited by the capacity of the smallest
	// datastore in a datastore cluster.
	// If not specified, the default value is 50GB.
	FreeSpaceThresholdGB int32 `xml:"freeSpaceThresholdGB,omitempty" json:"freeSpaceThresholdGB,omitempty"`
	// Storage DRS considers making storage migration recommendations if
	// the difference in space utilization between the source and destination datastores
	// is higher than the specified threshold.
	//
	// The valid values are in the range of 1 (i.e., 1%) to 50 (i.e., 50%).
	// If not specified, the default value is 5%.
	MinSpaceUtilizationDifference int32 `xml:"minSpaceUtilizationDifference,omitempty" json:"minSpaceUtilizationDifference,omitempty"`
}

func init() {
	t["StorageDrsSpaceLoadBalanceConfig"] = reflect.TypeOf((*StorageDrsSpaceLoadBalanceConfig)(nil)).Elem()
}

// This fault is thrown when Storage DRS action for relocating
// HMS collection of replica disks does not correspond to current
// HMS inventory configuration and hence, is rejected by HMS service.
type StorageDrsStaleHmsCollection struct {
	VimFault
}

func init() {
	t["StorageDrsStaleHmsCollection"] = reflect.TypeOf((*StorageDrsStaleHmsCollection)(nil)).Elem()
}

type StorageDrsStaleHmsCollectionFault StorageDrsStaleHmsCollection

func init() {
	t["StorageDrsStaleHmsCollectionFault"] = reflect.TypeOf((*StorageDrsStaleHmsCollectionFault)(nil)).Elem()
}

// This fault is thrown when Storage DRS cannot generate recommendations
// to move VM files due to pre-existing cross datastore disk backings.
type StorageDrsUnableToMoveFiles struct {
	VimFault
}

func init() {
	t["StorageDrsUnableToMoveFiles"] = reflect.TypeOf((*StorageDrsUnableToMoveFiles)(nil)).Elem()
}

type StorageDrsUnableToMoveFilesFault StorageDrsUnableToMoveFiles

func init() {
	t["StorageDrsUnableToMoveFilesFault"] = reflect.TypeOf((*StorageDrsUnableToMoveFilesFault)(nil)).Elem()
}

// Storage DRS configuration for a single virtual machine.
//
// This makes it
// possible to override the default behavior for an individual virtual machine.
type StorageDrsVmConfigInfo struct {
	DynamicData

	// Reference to the virtual machine.
	//
	// Can be NULL during initial placement.
	//
	// Refers instance of `VirtualMachine`.
	Vm *ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
	// Flag to indicate whether or not VirtualCenter is allowed to perform any
	// storage migration or initial placement recommendations for this virtual
	// machine on the pod `StoragePod`.
	//
	// If this flag is false, the virtual machine is effectively excluded from
	// storage DRS.
	//
	// If no individual DRS specification exists for a virtual machine,
	// this property defaults to true.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Specifies the particular storage DRS behavior for this virtual machine.
	//
	// For supported values, see `StorageDrsPodConfigInfoBehavior_enum`.
	Behavior string `xml:"behavior,omitempty" json:"behavior,omitempty"`
	// Specifies whether or not to have the affinity rule for the virtual disks
	// of this virtual machine.
	//
	// If not set, the default value is derived from
	// the pod-wide default `StorageDrsPodConfigInfo.defaultIntraVmAffinity`.
	IntraVmAffinity *bool `xml:"intraVmAffinity" json:"intraVmAffinity,omitempty"`
	// Deprecated as of vSphere API 7.0.
	//
	// Specifies the disks for this virtual machine that should be placed
	// on different datastores.
	//
	// A VM cannot have both an affinity and an
	// anti-affinity rule at the same time. Virtual machine disks that are
	// not in this rule are unconstrained and can be placed either on the
	// same datastore or on a different datastore as other disks from this
	// virtual machine.
	IntraVmAntiAffinity *VirtualDiskAntiAffinityRuleSpec `xml:"intraVmAntiAffinity,omitempty" json:"intraVmAntiAffinity,omitempty"`
	// List of the virtual disk rules that can be overridden/created.
	VirtualDiskRules []VirtualDiskRuleSpec `xml:"virtualDiskRules,omitempty" json:"virtualDiskRules,omitempty"`
}

func init() {
	t["StorageDrsVmConfigInfo"] = reflect.TypeOf((*StorageDrsVmConfigInfo)(nil)).Elem()
}

// Updates the per-virtual-machine storage DRS configuration.
type StorageDrsVmConfigSpec struct {
	ArrayUpdateSpec

	Info *StorageDrsVmConfigInfo `xml:"info,omitempty" json:"info,omitempty"`
}

func init() {
	t["StorageDrsVmConfigSpec"] = reflect.TypeOf((*StorageDrsVmConfigSpec)(nil)).Elem()
}

// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
//
// The IOAllocationInfo specifies the shares, limit and reservation
// for storage I/O resource.
//
// The storage I/O resource is allocated to virtual machines based on their
// shares, limit and reservation. The reservation is currently exposed only
// at the host level for local and shared datastores.
// We do not support storage I/O resource management on resource pools.
//
// Each virtual machine has one IOAllocationInfo object per virtual
// disk. For example, we can specify that a virtual machine has 500 shares
// on the first virtual disk, 1000 shares on the second virtual disk, etc.
type StorageIOAllocationInfo struct {
	DynamicData

	// The utilization of a virtual machine will not exceed this limit, even
	// if there are available resources.
	//
	// This is typically used to ensure a consistent
	// performance of virtual machines independent of available resources.
	// If set to -1, then there is no fixed limit on resource usage (only
	// bounded by available resources and shares). The unit is number of
	// I/O per second.
	// While setting the limit for storage I/O resource, if the property is unset,
	// it is treated as no change and the property is not updated. While reading
	// back the limit information of storage I/O resource, if the property is unset,
	// a default value of -1 will be returned, which indicates that there is no
	// limit on resource usage.
	Limit *int64 `xml:"limit" json:"limit,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Shares are used in case of resource contention.
	//
	// The value should be within a range of 200 to 4000.
	// While setting shares for storage I/O resource, if the property is unset,
	// it is treated as no change and the property is not updated. While reading
	// back the shares information of storage I/O resource, if the property is unset,
	// a default value of `SharesInfo.level` = normal,
	// `SharesInfo.shares` = 1000 will be returned.
	Shares *SharesInfo `xml:"shares,omitempty" json:"shares,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Reservation control is used to provide guaranteed allocation in terms
	// of IOPS.
	//
	// Large IO sizes are considered as multiple IOs using a chunk
	// size of 32 KB as default. This control is initially supported only
	// at host level for local datastores. It future, it may get supported
	// on shared storage based on integration with Storage IO Control.
	// Also right now we don't do any admission control based on IO
	// reservation values.
	Reservation *int32 `xml:"reservation" json:"reservation,omitempty"`
}

func init() {
	t["StorageIOAllocationInfo"] = reflect.TypeOf((*StorageIOAllocationInfo)(nil)).Elem()
}

// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
//
// The IOAllocationOption specifies value ranges that can be used
// to initialize `StorageIOAllocationInfo` object.
type StorageIOAllocationOption struct {
	DynamicData

	// limitOptions defines a range of values allowed to be used for
	// storage IO limit `StorageIOAllocationInfo.limit`.
	LimitOption LongOption `xml:"limitOption" json:"limitOption"`
	// sharesOption defines a range of values allowed to be used to
	// specify allocated io shares `StorageIOAllocationInfo.shares`.
	SharesOption SharesOption `xml:"sharesOption" json:"sharesOption"`
}

func init() {
	t["StorageIOAllocationOption"] = reflect.TypeOf((*StorageIOAllocationOption)(nil)).Elem()
}

// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
//
// Configuration setting ranges for `StorageIORMConfigSpec` object.
type StorageIORMConfigOption struct {
	DynamicData

	// enabledOption provides default state value for
	// `StorageIORMConfigSpec.enabled`
	EnabledOption BoolOption `xml:"enabledOption" json:"enabledOption"`
	// congestionThresholdOption defines value range which can be used for
	// `StorageIORMConfigSpec.congestionThreshold`
	CongestionThresholdOption IntOption `xml:"congestionThresholdOption" json:"congestionThresholdOption"`
	// statsCollectionEnabledOption provides default value for
	// `StorageIORMConfigSpec.statsCollectionEnabled`
	StatsCollectionEnabledOption *BoolOption `xml:"statsCollectionEnabledOption,omitempty" json:"statsCollectionEnabledOption,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// reservationEnabledOption provides default value for
	// `StorageIORMConfigSpec.reservationEnabled`
	ReservationEnabledOption *BoolOption `xml:"reservationEnabledOption,omitempty" json:"reservationEnabledOption,omitempty"`
}

func init() {
	t["StorageIORMConfigOption"] = reflect.TypeOf((*StorageIORMConfigOption)(nil)).Elem()
}

// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
//
// Configuration settings used for creating or reconfiguring
// storage I/O resource management.
//
// All fields are defined as optional. If a field is unset,
// the property is not changed.
type StorageIORMConfigSpec struct {
	DynamicData

	// Flag indicating whether or not the service is enabled.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Mode of congestion threshold specification
	// For more information, see
	// `StorageIORMThresholdMode_enum`
	CongestionThresholdMode string `xml:"congestionThresholdMode,omitempty" json:"congestionThresholdMode,omitempty"`
	// The latency beyond which the storage array is considered congested.
	//
	// For more information, see
	// `StorageIORMInfo.congestionThreshold`
	CongestionThreshold int32 `xml:"congestionThreshold,omitempty" json:"congestionThreshold,omitempty"`
	// The percentage of peak throughput to be used for setting threshold latency
	// of a datastore.
	//
	// Valid values are between 50 to 100.
	//
	// For more information, see
	// `StorageIORMInfo.congestionThreshold`
	PercentOfPeakThroughput int32 `xml:"percentOfPeakThroughput,omitempty" json:"percentOfPeakThroughput,omitempty"`
	// Flag indicating whether the service is enabled in stats collection mode.
	StatsCollectionEnabled *bool `xml:"statsCollectionEnabled" json:"statsCollectionEnabled,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Flag indicating whether IO reservations support is enabled.
	ReservationEnabled *bool `xml:"reservationEnabled" json:"reservationEnabled,omitempty"`
	// Flag indicating whether stats aggregation is disabled.
	StatsAggregationDisabled *bool `xml:"statsAggregationDisabled" json:"statsAggregationDisabled,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Storage DRS makes storage migration recommendations
	// if total IOPs reservation for all VMs running on the
	// datastore is higher than specified threshold value.
	//
	// This value (if present) overrides
	// `vim.StorageResourceManager.PodConfigInfo.reservableIopsThreshold`
	ReservableIopsThreshold int32 `xml:"reservableIopsThreshold,omitempty" json:"reservableIopsThreshold,omitempty"`
}

func init() {
	t["StorageIORMConfigSpec"] = reflect.TypeOf((*StorageIORMConfigSpec)(nil)).Elem()
}

// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
//
// Configuration of storage I/O resource management.
type StorageIORMInfo struct {
	DynamicData

	// Flag indicating whether or not the service is enabled.
	Enabled bool `xml:"enabled" json:"enabled"`
	// Mode of congestion threshold specification
	// For more information, see
	// `StorageIORMThresholdMode_enum`
	CongestionThresholdMode string `xml:"congestionThresholdMode,omitempty" json:"congestionThresholdMode,omitempty"`
	// The latency beyond which the storage array is considered congested.
	//
	// If storage I/O resource management is enabled on a datastore,
	// the algorithm tries to maintain the latency to be below or
	// close to this value. The unit is millisecond. The range of
	// this value is between 5 to 100 milliseconds.
	CongestionThreshold int32 `xml:"congestionThreshold" json:"congestionThreshold"`
	// The percentage of peak throughput to be used for setting congestion threshold
	// of a datastore.
	//
	// Valid values are between 50 to 100. Default value is 90%
	//
	// For more information, see
	// `StorageIORMInfo.congestionThreshold`
	PercentOfPeakThroughput int32 `xml:"percentOfPeakThroughput,omitempty" json:"percentOfPeakThroughput,omitempty"`
	// Deprecated as of vSphere API 6.5, use `StorageIORMInfo.enabled` instead.
	//
	// Flag indicating whether service is running in stats collection mode.
	StatsCollectionEnabled *bool `xml:"statsCollectionEnabled" json:"statsCollectionEnabled,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Flag indicating whether IO reservations support is enabled.
	ReservationEnabled *bool `xml:"reservationEnabled" json:"reservationEnabled,omitempty"`
	// Flag indicating whether stats aggregation is disabled.
	StatsAggregationDisabled *bool `xml:"statsAggregationDisabled" json:"statsAggregationDisabled,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Storage DRS makes storage migration recommendations
	// if total IOPs reservation for all VMs running on the
	// datastore is higher than specified threshold value.
	//
	// This value (if present) overrides
	// `vim.StorageResourceManager.PodConfigInfo.reservableIopsThreshold`
	ReservableIopsThreshold int32 `xml:"reservableIopsThreshold,omitempty" json:"reservableIopsThreshold,omitempty"`
}

func init() {
	t["StorageIORMInfo"] = reflect.TypeOf((*StorageIORMInfo)(nil)).Elem()
}

// Describes a single storage migration action.
//
// The storage migration
// action applies either to a virtual machine or a set of virtual disks.
type StorageMigrationAction struct {
	ClusterAction

	// Virtual machine reference.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Specification for moving a virtual machine or a set of virtual disks
	// to a different datastore.
	RelocateSpec VirtualMachineRelocateSpec `xml:"relocateSpec" json:"relocateSpec"`
	// Source datastore.
	//
	// Refers instance of `Datastore`.
	Source ManagedObjectReference `xml:"source" json:"source"`
	// Destination datastore.
	//
	// Refers instance of `Datastore`.
	Destination ManagedObjectReference `xml:"destination" json:"destination"`
	// The amount of data to be transferred.
	//
	// Unit: KB.
	SizeTransferred int64 `xml:"sizeTransferred" json:"sizeTransferred"`
	// Space utilization on the source datastore before storage migration.
	//
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilSrcBefore float32 `xml:"spaceUtilSrcBefore,omitempty" json:"spaceUtilSrcBefore,omitempty"`
	// Space utilization on the destination datastore before storage migration.
	//
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilDstBefore float32 `xml:"spaceUtilDstBefore,omitempty" json:"spaceUtilDstBefore,omitempty"`
	// Expected space utilization on the source datastore after storage migration.
	//
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilSrcAfter float32 `xml:"spaceUtilSrcAfter,omitempty" json:"spaceUtilSrcAfter,omitempty"`
	// Expected space utilization on the destination datastore after storage migration.
	//
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilDstAfter float32 `xml:"spaceUtilDstAfter,omitempty" json:"spaceUtilDstAfter,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// I/O latency on the source datastore before storage migration.
	//
	// Unit: millisecond.
	// If not set, the value is not available.
	IoLatencySrcBefore float32 `xml:"ioLatencySrcBefore,omitempty" json:"ioLatencySrcBefore,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// I/O latency on the destination datastore before storage migration.
	//
	// Unit: millisecond.
	// If not set, the value is not available.
	IoLatencyDstBefore float32 `xml:"ioLatencyDstBefore,omitempty" json:"ioLatencyDstBefore,omitempty"`
}

func init() {
	t["StorageMigrationAction"] = reflect.TypeOf((*StorageMigrationAction)(nil)).Elem()
}

// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
//
// Summary statistics for datastore performance
// The statistics are reported in aggregated quantiles over a time period
type StoragePerformanceSummary struct {
	DynamicData

	// Time period over which statistics are aggregated
	// The reported time unit is in seconds
	Interval int32 `xml:"interval" json:"interval"`
	// Metric percentile specification.
	//
	// A percentile is a value
	// between 1 and 100. The metric value reported in the
	// aggregated statistics corresponds with the percentile values
	// in this field. For example, if the value of percentile\[0\] is
	// P, and the value of the datastoreReadLatency\[0\] is L, then
	// P% of all the read IOs performed during observation interval
	// is less than L milliseconds.
	Percentile []int32 `xml:"percentile" json:"percentile"`
	// Aggregated datastore latency in milliseconds for read operations
	DatastoreReadLatency []float64 `xml:"datastoreReadLatency" json:"datastoreReadLatency"`
	// Aggregated datastore latency in milliseconds for write operations
	DatastoreWriteLatency []float64 `xml:"datastoreWriteLatency" json:"datastoreWriteLatency"`
	// Aggregated datastore latency as observed by Vms using the datastore
	// The reported latency is in milliseconds.
	DatastoreVmLatency []float64 `xml:"datastoreVmLatency" json:"datastoreVmLatency"`
	// Aggregated datastore Read IO rate (Reads/second)
	DatastoreReadIops []float64 `xml:"datastoreReadIops" json:"datastoreReadIops"`
	// Aggregated datastore Write IO rate (Writes/second)
	DatastoreWriteIops []float64 `xml:"datastoreWriteIops" json:"datastoreWriteIops"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Cumulative SIOC activity to satisfy SIOC latency threshold
	// setting.
	//
	// This metric indicates the total time that SIOC is
	// actively throttling IO requests. The SIOC throttling
	// activity occurs whenever the datastore latency exceeds the
	// SIOC latency threshold. If SIOC is not enabled on the
	// datastore, the metric indicates the total time that SIOC
	// would have been active. The unit of reporting is in
	// milliseconds.
	SiocActivityDuration int32 `xml:"siocActivityDuration" json:"siocActivityDuration"`
}

func init() {
	t["StoragePerformanceSummary"] = reflect.TypeOf((*StoragePerformanceSummary)(nil)).Elem()
}

// Describes a single storage initial placement action for placing a virtual
// machine or a set of virtual disks on a datastore.
type StoragePlacementAction struct {
	ClusterAction

	// Virtual machine reference.
	//
	// It is possible that the VM has not been created, in which case,
	// this property is left unset.
	//
	// Refers instance of `VirtualMachine`.
	Vm *ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
	// Specification for placing a virtual machine or a set of virtual disks
	// to a datastore.
	RelocateSpec VirtualMachineRelocateSpec `xml:"relocateSpec" json:"relocateSpec"`
	// Target datastore.
	//
	// Refers instance of `Datastore`.
	Destination ManagedObjectReference `xml:"destination" json:"destination"`
	// Current space utilization on the target datastore.
	//
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilBefore float32 `xml:"spaceUtilBefore,omitempty" json:"spaceUtilBefore,omitempty"`
	// Current space demand on the target datastore.
	//
	// Unit: percentage. For example, if set to 70.0, space demand is 70%. This
	// value include the space demanded by thin provisioned VMs. Hence, it may
	// be higher than 100%. If not set, the value is not available.
	SpaceDemandBefore float32 `xml:"spaceDemandBefore,omitempty" json:"spaceDemandBefore,omitempty"`
	// Space utilization on the target datastore after placing the virtual disk.
	//
	// Unit: percentage. For example, if set to 70.0, space utilization is 70%.
	// If not set, the value is not available.
	SpaceUtilAfter float32 `xml:"spaceUtilAfter,omitempty" json:"spaceUtilAfter,omitempty"`
	// Space demand on the target datastore after placing the virtual disk.
	//
	// Unit: percentage. For example, if set to 70.0, space demand is 70%. This
	// value include the space demanded by thin provisioned VMs. Hence, it may
	// be higher than 100%. If not set, the value is not available.
	SpaceDemandAfter float32 `xml:"spaceDemandAfter,omitempty" json:"spaceDemandAfter,omitempty"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Current I/O latency on the target datastore.
	//
	// Unit: millisecond.
	// If not set, the value is not available.
	IoLatencyBefore float32 `xml:"ioLatencyBefore,omitempty" json:"ioLatencyBefore,omitempty"`
}

func init() {
	t["StoragePlacementAction"] = reflect.TypeOf((*StoragePlacementAction)(nil)).Elem()
}

// Both `StorageResourceManager.RecommendDatastores` and
// `Datastore.DatastoreEnterMaintenanceMode` methods may invoke Storage DRS
// for recommendations on placing or evacuating virtual disks.
//
// StoragePlacementResult is the class of the result returned by
// the methods.
type StoragePlacementResult struct {
	DynamicData

	// The list of recommendations that the client needs to approve manually.
	Recommendations []ClusterRecommendation `xml:"recommendations,omitempty" json:"recommendations,omitempty"`
	// Information about any fault in case Storage DRS failed to make a recommendation.
	DrsFault *ClusterDrsFaults `xml:"drsFault,omitempty" json:"drsFault,omitempty"`
	// The ID of the task, which monitors the storage placement or datastore entering
	// maintennace mode operation.
	//
	// Refers instance of `Task`.
	Task *ManagedObjectReference `xml:"task,omitempty" json:"task,omitempty"`
}

func init() {
	t["StoragePlacementResult"] = reflect.TypeOf((*StoragePlacementResult)(nil)).Elem()
}

// StoragePlacementSpec encapsulates all of the inputs passed to the
// `StorageResourceManager.RecommendDatastores` method.
type StoragePlacementSpec struct {
	DynamicData

	// The storage placement type.
	//
	// The set of possible values is described in
	// `StoragePlacementSpecPlacementType_enum`
	Type string `xml:"type" json:"type"`
	// Priority of this placement operation.
	Priority VirtualMachineMovePriority `xml:"priority,omitempty" json:"priority,omitempty"`
	// The relevant virtual machine.
	//
	// Refers instance of `VirtualMachine`.
	Vm *ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
	// Specification for moving a virtual machine or a set of virtual disks
	// to a different storage pod.
	PodSelectionSpec StorageDrsPodSelectionSpec `xml:"podSelectionSpec" json:"podSelectionSpec"`
	// Specification for a virtual machine cloning operation.
	CloneSpec *VirtualMachineCloneSpec `xml:"cloneSpec,omitempty" json:"cloneSpec,omitempty"`
	// Name for cloned virtual machine.
	CloneName string `xml:"cloneName,omitempty" json:"cloneName,omitempty"`
	// Configuration for the virtual machine.
	ConfigSpec *VirtualMachineConfigSpec `xml:"configSpec,omitempty" json:"configSpec,omitempty"`
	// Specification for relocating a virtual machine.
	RelocateSpec *VirtualMachineRelocateSpec `xml:"relocateSpec,omitempty" json:"relocateSpec,omitempty"`
	// The resource pool to which this virtual machine should be attached.
	//
	// Refers instance of `ResourcePool`.
	ResourcePool *ManagedObjectReference `xml:"resourcePool,omitempty" json:"resourcePool,omitempty"`
	// The target host for the virtual machine.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The target virtual machine folder for the virtual machine.
	//
	// Note that this is a different folder than the pod(s) that the virtual
	// machine belongs to. The pod mapping represents the storage view of
	// the virtual machine, while the virtual machine folder mapping
	// represents an inventory view of the virtual machine.
	// For manual VM provisioning operations, this is specified implicitly
	// as the object that the `Folder.CreateVM_Task` method is invoked on.
	//
	// Refers instance of `Folder`.
	Folder *ManagedObjectReference `xml:"folder,omitempty" json:"folder,omitempty"`
	// Specification for whether to disable pre-requisite storage vmotions
	// for storage placements.
	//
	// If unset, default behavior is to allow such
	// prerequisite moves.
	DisallowPrerequisiteMoves *bool `xml:"disallowPrerequisiteMoves" json:"disallowPrerequisiteMoves,omitempty"`
	// Resource lease duration in seconds.
	//
	// If the duration is within bounds,
	// Storage DRS will hold onto resources needed for applying recommendations
	// generated as part of that call.
	// Only initial placement recommendations generated by storage DRS can reserve
	// resources this way.
	ResourceLeaseDurationSec int32 `xml:"resourceLeaseDurationSec,omitempty" json:"resourceLeaseDurationSec,omitempty"`
}

func init() {
	t["StoragePlacementSpec"] = reflect.TypeOf((*StoragePlacementSpec)(nil)).Elem()
}

// The `StoragePodSummary` data object
// encapsulates runtime properties of a `StoragePod`.
type StoragePodSummary struct {
	DynamicData

	// The name of the storage pod.
	Name string `xml:"name" json:"name"`
	// Total capacity of this storage pod, in bytes.
	//
	// This value is the sum of the
	// capacity of all datastores that are part of this storage pod, and is updated
	// periodically by the server.
	Capacity int64 `xml:"capacity" json:"capacity"`
	// Total free space on this storage pod, in bytes.
	//
	// This value is the sum of the
	// free space on all datastores that are part of this storage pod, and is updated
	// periodically by the server.
	FreeSpace int64 `xml:"freeSpace" json:"freeSpace"`
}

func init() {
	t["StoragePodSummary"] = reflect.TypeOf((*StoragePodSummary)(nil)).Elem()
}

// The `StorageProfile` data object represents the host storage configuration.
//
// If a profile plug-in defines policies or subprofiles, use the
// `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the additional configuration data.
type StorageProfile struct {
	ApplyProfile

	// List of NAS storage subprofiles.
	//
	// Use the `NasStorageProfile.key` property
	// to access a subprofile in the list.
	NasStorage []NasStorageProfile `xml:"nasStorage,omitempty" json:"nasStorage,omitempty"`
}

func init() {
	t["StorageProfile"] = reflect.TypeOf((*StorageProfile)(nil)).Elem()
}

// Describes the storage requirement to perform a consolidation
// operation.
type StorageRequirement struct {
	DynamicData

	// The datastore.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// Space required.
	FreeSpaceRequiredInKb int64 `xml:"freeSpaceRequiredInKb" json:"freeSpaceRequiredInKb"`
}

func init() {
	t["StorageRequirement"] = reflect.TypeOf((*StorageRequirement)(nil)).Elem()
}

// A data object to report aggregate storage statistics by storage
// profile
type StorageResourceManagerStorageProfileStatistics struct {
	DynamicData

	// Profile identifier for the reported statistics
	ProfileId string `xml:"profileId" json:"profileId"`
	// The aggregate storage capacity available for a given storage
	// capability profile.
	//
	// The capacity is reported in Megabytes.
	TotalSpaceMB int64 `xml:"totalSpaceMB" json:"totalSpaceMB"`
	// The aggregate used storage capacity by a given storage capability
	// profile
	// The used space is reported in Megabytes
	UsedSpaceMB int64 `xml:"usedSpaceMB" json:"usedSpaceMB"`
}

func init() {
	t["StorageResourceManagerStorageProfileStatistics"] = reflect.TypeOf((*StorageResourceManagerStorageProfileStatistics)(nil)).Elem()
}

// An operation on a powered-on virtual machine requests a change of storage
// location, but the host does not have that capability.
type StorageVMotionNotSupported struct {
	MigrationFeatureNotSupported
}

func init() {
	t["StorageVMotionNotSupported"] = reflect.TypeOf((*StorageVMotionNotSupported)(nil)).Elem()
}

type StorageVMotionNotSupportedFault StorageVMotionNotSupported

func init() {
	t["StorageVMotionNotSupportedFault"] = reflect.TypeOf((*StorageVMotionNotSupportedFault)(nil)).Elem()
}

// This fault is thrown when Storage DRS tries to migrate disks of a virtual machine to a datastore,
// but finds that the datastore is incompatible with the given virtual machine.
type StorageVmotionIncompatible struct {
	VirtualHardwareCompatibilityIssue

	// The datastore that is incompatible with a given virtual machine.
	//
	// Refers instance of `Datastore`.
	Datastore *ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty"`
}

func init() {
	t["StorageVmotionIncompatible"] = reflect.TypeOf((*StorageVmotionIncompatible)(nil)).Elem()
}

type StorageVmotionIncompatibleFault StorageVmotionIncompatible

func init() {
	t["StorageVmotionIncompatibleFault"] = reflect.TypeOf((*StorageVmotionIncompatibleFault)(nil)).Elem()
}

// The string type of setting or configuration that may get a
// negated value.
type StringExpression struct {
	NegatableExpression

	// The String value that is either used as it is or negated.
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

func init() {
	t["StringExpression"] = reflect.TypeOf((*StringExpression)(nil)).Elem()
}

// The StringOption data object type is used to define an open-ended
// string value based on an optional subset of valid characters.
type StringOption struct {
	OptionType

	// The default value.
	DefaultValue string `xml:"defaultValue" json:"defaultValue"`
	// The string containing the set of valid characters.
	//
	// If a string
	// option is not specified, all strings are allowed.
	ValidCharacters string `xml:"validCharacters,omitempty" json:"validCharacters,omitempty"`
}

func init() {
	t["StringOption"] = reflect.TypeOf((*StringOption)(nil)).Elem()
}

// The string type of setting or configuration that may get an
// inherited value.
type StringPolicy struct {
	InheritablePolicy

	// The String value that is either set or inherited.
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

func init() {
	t["StringPolicy"] = reflect.TypeOf((*StringPolicy)(nil)).Elem()
}

// Implementation of `HostProfilesEntityCustomizations`
// that maps a cluster or host profile to the `AnswerFile`
// object containing the host profiles customizations for that entity.
//
// This
// object will be used as elements of the
// `HostProfilesEntityCustomizations`.{vim.profile.host.ProfileManager.EntityCustomizations#entityCustomizations}
// when the `HostProfilesEntityCustomizations`.{vim.profile.host.ProfileManager.EntityCustomizations#customizationsFormat}
// value is "structured".
type StructuredCustomizations struct {
	HostProfilesEntityCustomizations

	// Entity associated with the host customizations specified in the
	// <code>customizations</code> `AnswerFile` object.
	//
	// In the current release, this object will always be a host.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// Host Profile Customizations for the associated <code>entity</code>.
	//
	// This is the same object that would be returned by the
	// `HostProfileManager.RetrieveAnswerFile` method
	Customizations *AnswerFile `xml:"customizations,omitempty" json:"customizations,omitempty"`
}

func init() {
	t["StructuredCustomizations"] = reflect.TypeOf((*StructuredCustomizations)(nil)).Elem()
}

type SuspendVAppRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["SuspendVAppRequestType"] = reflect.TypeOf((*SuspendVAppRequestType)(nil)).Elem()
}

type SuspendVApp_Task SuspendVAppRequestType

func init() {
	t["SuspendVApp_Task"] = reflect.TypeOf((*SuspendVApp_Task)(nil)).Elem()
}

type SuspendVApp_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type SuspendVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["SuspendVMRequestType"] = reflect.TypeOf((*SuspendVMRequestType)(nil)).Elem()
}

type SuspendVM_Task SuspendVMRequestType

func init() {
	t["SuspendVM_Task"] = reflect.TypeOf((*SuspendVM_Task)(nil)).Elem()
}

type SuspendVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Either the source host product or the destination host product does not support
// relocation of suspended VMs.
//
// It must be supported on both, in order for the
// relocation to succeed. This fault is only applicable to suspended virtual machines.
type SuspendedRelocateNotSupported struct {
	MigrationFault
}

func init() {
	t["SuspendedRelocateNotSupported"] = reflect.TypeOf((*SuspendedRelocateNotSupported)(nil)).Elem()
}

type SuspendedRelocateNotSupportedFault SuspendedRelocateNotSupported

func init() {
	t["SuspendedRelocateNotSupportedFault"] = reflect.TypeOf((*SuspendedRelocateNotSupportedFault)(nil)).Elem()
}

// The compute resource and/or virtual machine configurations indicate that
// when executing on the host the virtual machine should use a specific
// datastore, but host does not have read/write access to that datastore.
//
// (It may have no access at all, or read-only access.) If executing on the
// host the virtual machine would instead use its own directory for swapfile
// placement. This is a compatibility warning, not an error.
type SwapDatastoreNotWritableOnHost struct {
	DatastoreNotWritableOnHost
}

func init() {
	t["SwapDatastoreNotWritableOnHost"] = reflect.TypeOf((*SwapDatastoreNotWritableOnHost)(nil)).Elem()
}

type SwapDatastoreNotWritableOnHostFault SwapDatastoreNotWritableOnHost

func init() {
	t["SwapDatastoreNotWritableOnHostFault"] = reflect.TypeOf((*SwapDatastoreNotWritableOnHostFault)(nil)).Elem()
}

// The compute resource and/or virtual machine configurations indicate that
// when executing on the host the virtual machine should use a swap
// datastore, but the host does not have a swap datastore configured.
//
// If
// executing on the host the virtual machine would instead use its own directory
// for swapfile placement. This is a compatibility warning, not an error.
// Note it is actually the common case for a host to not have a configured
// swap datastore, and the problem may rest with the compute resource and/or
// virtual machine configuration; therefore this is not a HostConfigFault.
type SwapDatastoreUnset struct {
	VimFault
}

func init() {
	t["SwapDatastoreUnset"] = reflect.TypeOf((*SwapDatastoreUnset)(nil)).Elem()
}

type SwapDatastoreUnsetFault SwapDatastoreUnset

func init() {
	t["SwapDatastoreUnsetFault"] = reflect.TypeOf((*SwapDatastoreUnsetFault)(nil)).Elem()
}

// The virtual machine is configured to override the default swapfile placement
// policy, which is not supported on the host.
type SwapPlacementOverrideNotSupported struct {
	InvalidVmConfig
}

func init() {
	t["SwapPlacementOverrideNotSupported"] = reflect.TypeOf((*SwapPlacementOverrideNotSupported)(nil)).Elem()
}

type SwapPlacementOverrideNotSupportedFault SwapPlacementOverrideNotSupported

func init() {
	t["SwapPlacementOverrideNotSupportedFault"] = reflect.TypeOf((*SwapPlacementOverrideNotSupportedFault)(nil)).Elem()
}

// The distributed virtual switch received a reconfiguration request to
// activate a feature that requires a switch IP address.
//
// However, the IP
// address for the switch has not been specified.
type SwitchIpUnset struct {
	DvsFault
}

func init() {
	t["SwitchIpUnset"] = reflect.TypeOf((*SwitchIpUnset)(nil)).Elem()
}

type SwitchIpUnsetFault SwitchIpUnset

func init() {
	t["SwitchIpUnsetFault"] = reflect.TypeOf((*SwitchIpUnsetFault)(nil)).Elem()
}

// Thrown if an operation is not supported while the DistributedVirtualSwitch
// is not in upgrade mode.
type SwitchNotInUpgradeMode struct {
	DvsFault
}

func init() {
	t["SwitchNotInUpgradeMode"] = reflect.TypeOf((*SwitchNotInUpgradeMode)(nil)).Elem()
}

type SwitchNotInUpgradeModeFault SwitchNotInUpgradeMode

func init() {
	t["SwitchNotInUpgradeModeFault"] = reflect.TypeOf((*SwitchNotInUpgradeModeFault)(nil)).Elem()
}

// Exception type for reporting a low-level operating system
// error.
type SystemError struct {
	RuntimeFault

	// A message to indicate detailed information about the error.
	//
	// This property is not internationalization friendly and
	// normally reported by the underlying operating system.
	Reason string `xml:"reason" json:"reason"`
}

func init() {
	t["SystemError"] = reflect.TypeOf((*SystemError)(nil)).Elem()
}

type SystemErrorFault SystemError

func init() {
	t["SystemErrorFault"] = reflect.TypeOf((*SystemErrorFault)(nil)).Elem()
}

// IPMI System Event Log (SEL) provides a history of hardware sensor states.
//
// This is defined in IPMI specification, section 32.1 SEL Event Records.
// CLI:: esxcli hardware ipmi sel list
type SystemEventInfo struct {
	DynamicData

	// The recordId uniquely identifies an entry in IPMI System Event Log.
	RecordId int64 `xml:"recordId" json:"recordId"`
	// A ISO 8601 timestamp when the event was added to IPMI System Event Log.
	//
	// This timestamp comes from the IPMI subsystem clock and may not be
	// the same as hypervisor's clock.
	When string `xml:"when" json:"when"`
	// The IPMI SEL type defines the if the SEL event uses
	// the system event format format or is OEM defined.
	//
	// A value of 2 indicates system event.
	// Values 0xC0-0xDF, 0xE0-0xFF are OEM event ranges.
	SelType int64 `xml:"selType" json:"selType"`
	// A description of what the event is about.
	Message string `xml:"message" json:"message"`
	// The IPMI Sensor/probe that is reporting this event.
	//
	// A value of zero (0) indicates event has no related sensor.
	SensorNumber int64 `xml:"sensorNumber" json:"sensorNumber"`
}

func init() {
	t["SystemEventInfo"] = reflect.TypeOf((*SystemEventInfo)(nil)).Elem()
}

// Defines a tag that can be associated with a managed entity.
type Tag struct {
	DynamicData

	// The tag key in human readable form.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["Tag"] = reflect.TypeOf((*Tag)(nil)).Elem()
}

// Static strings for task objects.
//
// These strings are locale-specific.
type TaskDescription struct {
	DynamicData

	// Display label and summary for all tasks
	MethodInfo []BaseElementDescription `xml:"methodInfo,typeattr" json:"methodInfo"`
	// *TaskInfo State enum*
	State []BaseElementDescription `xml:"state,typeattr" json:"state"`
	// Kind of entity responsible for creating this task.
	Reason []BaseTypeDescription `xml:"reason,typeattr" json:"reason"`
}

func init() {
	t["TaskDescription"] = reflect.TypeOf((*TaskDescription)(nil)).Elem()
}

// This event records the creation of a Task.
//
// Note that the embedded TaskInfo object is a _snapshot_ of the
// Task state at the time of its creation, so its state will always be
// "queued". To find the current status of the task, query for the
// current state of the Task using the eventChainId in the embedded
// TaskInfo object.
type TaskEvent struct {
	Event

	// The information about the task.
	Info TaskInfo `xml:"info" json:"info"`
}

func init() {
	t["TaskEvent"] = reflect.TypeOf((*TaskEvent)(nil)).Elem()
}

// This data object type defines the specification for the task filter used
// to query tasks in the history collector database.
//
// The client creates a task
// history collector with a filter specification, then retrieves the tasks from
// the task history collector.
type TaskFilterSpec struct {
	DynamicData

	// The filter specification for retrieving tasks by managed entity.
	//
	// If not provided, then the tasks attached to all managed entities are
	// collected.
	Entity *TaskFilterSpecByEntity `xml:"entity,omitempty" json:"entity,omitempty"`
	// The filter specification for retrieving tasks by time.
	//
	// If not provided, then the tasks with any time stamp are collected.
	Time *TaskFilterSpecByTime `xml:"time,omitempty" json:"time,omitempty"`
	// The filter specification for retrieving tasks by user name.
	//
	// If not provided, then the tasks belonging to any user are collected.
	UserName *TaskFilterSpecByUsername `xml:"userName,omitempty" json:"userName,omitempty"`
	// This property, if provided, limits the set of collected tasks to those
	// associated with the specified activation Ids.
	ActivationId []string `xml:"activationId,omitempty" json:"activationId,omitempty"`
	// This property, if provided, limits the set of collected tasks by their states.
	//
	// Task states are enumerated in `State`.
	// If not provided, tasks are collected regardless of their state.
	State []TaskInfoState `xml:"state,omitempty" json:"state,omitempty"`
	// This property, if provided, limits the set of collected tasks to those
	// associated with the specified alarm.
	//
	// If not provided, tasks are collected regardless of their association with alarms.
	//
	// Refers instance of `Alarm`.
	Alarm *ManagedObjectReference `xml:"alarm,omitempty" json:"alarm,omitempty"`
	// This property, if provided, limits the set of collected tasks to those
	// associated with the specified scheduled task.
	//
	// If not provided, tasks are collected regardless of their association with any
	// scheduled task.
	//
	// Refers instance of `ScheduledTask`.
	ScheduledTask *ManagedObjectReference `xml:"scheduledTask,omitempty" json:"scheduledTask,omitempty"`
	// The filter specification for retrieving tasks by chain ID.
	//
	// If it is set,
	// tasks not with the given `TaskInfo.eventChainId` will be
	// filtered out. If the property is not set, tasks' chain ID is disregarded
	// for filtering purposes.
	EventChainId []int32 `xml:"eventChainId,omitempty" json:"eventChainId,omitempty"`
	// The filter specification for retrieving tasks by
	// `tag`.
	//
	// If it is set, tasks not with the given tag(s)
	// will be filtered out. If the property is not set, tasks' tag is disregarded for
	// filtering purposes. If it is set, and includes an empty string, tasks without a
	// tag will be returned.
	Tag []string `xml:"tag,omitempty" json:"tag,omitempty"`
	// The filter specification for retrieving tasks by
	// `TaskInfo.parentTaskKey`.
	//
	// If it is set, tasks not with the
	// given parentTaskKey(s) will be filtered out. If the property is not set,
	// tasks' parentTaskKey is disregarded for filtering purposes.
	ParentTaskKey []string `xml:"parentTaskKey,omitempty" json:"parentTaskKey,omitempty"`
	// The filter specification for retrieving tasks by
	// `TaskInfo.rootTaskKey`.
	//
	// If it is set, tasks not with the
	// given rootTaskKey(s) will be filtered out. If the property is not set,
	// tasks' rootTaskKey is disregarded for filtering purposes.
	RootTaskKey []string `xml:"rootTaskKey,omitempty" json:"rootTaskKey,omitempty"`
}

func init() {
	t["TaskFilterSpec"] = reflect.TypeOf((*TaskFilterSpec)(nil)).Elem()
}

// This data object type specifies a managed entity used to
// filter task history.
type TaskFilterSpecByEntity struct {
	DynamicData

	// The managed entity to which the task pertains.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// Specification of related managed entities in the inventory hierarchy.
	Recursion TaskFilterSpecRecursionOption `xml:"recursion" json:"recursion"`
}

func init() {
	t["TaskFilterSpecByEntity"] = reflect.TypeOf((*TaskFilterSpecByEntity)(nil)).Elem()
}

// This data object type specifies a time range used to filter task history.
type TaskFilterSpecByTime struct {
	DynamicData

	// The time stamp to filter: queued, started, or completed time.
	TimeType TaskFilterSpecTimeOption `xml:"timeType" json:"timeType"`
	// The beginning of the time range.
	//
	// If this property is not specified, then tasks are collected from
	// the earliest time in the database.
	//
	// When this property is specified, the time type field must also be specified.
	BeginTime *time.Time `xml:"beginTime" json:"beginTime,omitempty"`
	// The end of the time range.
	//
	// If this property is not specified, then tasks are collected up to
	// the latest time in the database.
	//
	// When this property is specified, the time type field must also be specified.
	EndTime *time.Time `xml:"endTime" json:"endTime,omitempty"`
}

func init() {
	t["TaskFilterSpecByTime"] = reflect.TypeOf((*TaskFilterSpecByTime)(nil)).Elem()
}

// This data object type enables you to filter task history according to
// the users who performed the tasks.
type TaskFilterSpecByUsername struct {
	DynamicData

	// Whether or not to filter by system user.
	//
	// If set to true, filters for system user event.
	SystemUser bool `xml:"systemUser" json:"systemUser"`
	// Specifies the username list to use in the filter.
	//
	// If not set, then all regular user tasks are collected.
	UserList []string `xml:"userList,omitempty" json:"userList,omitempty"`
}

func init() {
	t["TaskFilterSpecByUsername"] = reflect.TypeOf((*TaskFilterSpecByUsername)(nil)).Elem()
}

// The TaskInProgress data object type represents a fault when an operation tries
// to access an entity that already has another (long) operation in progress.
type TaskInProgress struct {
	VimFault

	// The task already in progress when the operation was attempted.
	//
	// Refers instance of `Task`.
	Task ManagedObjectReference `xml:"task" json:"task"`
}

func init() {
	t["TaskInProgress"] = reflect.TypeOf((*TaskInProgress)(nil)).Elem()
}

type TaskInProgressFault BaseTaskInProgress

func init() {
	t["TaskInProgressFault"] = reflect.TypeOf((*TaskInProgressFault)(nil)).Elem()
}

// This data object type contains all information about a task.
//
// A task
// represents an operation performed by VirtualCenter or ESX.
type TaskInfo struct {
	DynamicData

	// The unique key for the task.
	Key string `xml:"key" json:"key"`
	// The managed object that represents this task.
	//
	// Refers instance of `Task`.
	Task ManagedObjectReference `xml:"task" json:"task"`
	// The description field of the task describes the current phase of
	// operation of the task.
	//
	// For a task that does a single monolithic
	// activity, this will be fixed and unchanging.
	// For tasks that have various substeps, this field will change
	// as the task progresses from one phase to another.
	Description *LocalizableMessage `xml:"description,omitempty" json:"description,omitempty"`
	// The name of the operation that created the task.
	//
	// This is not set
	// for internal tasks.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// An identifier for this operation.
	//
	// This includes publicly visible
	// internal tasks and is a lookup in the TaskDescription methodInfo
	// data object.
	DescriptionId string `xml:"descriptionId" json:"descriptionId"`
	// Managed entity to which the operation applies.
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
	// The name of the managed entity, locale-specific, retained for the
	// history collector database.
	EntityName string `xml:"entityName,omitempty" json:"entityName,omitempty"`
	// If the state of the task is "running", then this property is a list of
	// managed entities that the operation has locked, with a shared lock.
	//
	// Refers instances of `ManagedEntity`.
	Locked []ManagedObjectReference `xml:"locked,omitempty" json:"locked,omitempty"`
	// Runtime status of the task.
	State TaskInfoState `xml:"state" json:"state"`
	// Flag to indicate whether or not the client requested
	// cancellation of the task.
	Cancelled bool `xml:"cancelled" json:"cancelled"`
	// Flag to indicate whether or not the cancel task operation is supported.
	Cancelable bool `xml:"cancelable" json:"cancelable"`
	// If the task state is "error", then this property contains the fault code.
	Error *LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
	// If the task state is "success", then this property may be used
	// to hold a return value.
	Result AnyType `xml:"result,omitempty,typeattr" json:"result,omitempty"`
	// If the task state is "running", then this property contains a
	// progress measurement, expressed as percentage completed, from 0 to 100.
	//
	// If this property is not set, then the command does not report progress.
	Progress        int32         `xml:"progress,omitempty" json:"progress,omitempty"`
	ProgressDetails []KeyAnyValue `xml:"progressDetails,omitempty" json:"progressDetails,omitempty" vim:"8.0.1.0"`
	// Kind of entity responsible for creating this task.
	Reason BaseTaskReason `xml:"reason,typeattr" json:"reason"`
	// Time stamp when the task was created.
	QueueTime time.Time `xml:"queueTime" json:"queueTime"`
	// Time stamp when the task started running.
	StartTime *time.Time `xml:"startTime" json:"startTime,omitempty"`
	// Time stamp when the task was completed (whether success or failure).
	CompleteTime *time.Time `xml:"completeTime" json:"completeTime,omitempty"`
	// Event chain ID that leads to the corresponding events.
	EventChainId int32 `xml:"eventChainId" json:"eventChainId"`
	// The user entered tag to identify the operations and their side effects
	ChangeTag string `xml:"changeTag,omitempty" json:"changeTag,omitempty"`
	// Tasks can be created by another task.
	//
	// This shows `TaskInfo.key` of the task spun off this task. This is to
	// track causality between tasks.
	ParentTaskKey string `xml:"parentTaskKey,omitempty" json:"parentTaskKey,omitempty"`
	// Tasks can be created by another task and such creation can go on for
	// multiple levels.
	//
	// This is the `TaskInfo.key` of the task
	// that started the chain of tasks.
	RootTaskKey string `xml:"rootTaskKey,omitempty" json:"rootTaskKey,omitempty"`
	// The activation Id is a client-provided token to link an API call with a task.
	ActivationId string `xml:"activationId,omitempty" json:"activationId,omitempty"`
}

func init() {
	t["TaskInfo"] = reflect.TypeOf((*TaskInfo)(nil)).Elem()
}

// This data object type defines the specification for the filter used
// to include or exclude various information from the tasks while retrieving
// from the history collector database.
//
// The client creates a task history
// collector with `TaskFilterSpec` along with this optional
// spec, then retrieves the tasks from the task history collector.
type TaskInfoFilterSpec struct {
	DynamicData

	// The filter specification for filtering out tasks' results.
	//
	// If it is set, then the
	// results information will be included or excluded based on the supplied parameters. If it is
	// not set, then results information of all tasks will be included.
	FilterTaskResults *TaskInfoFilterSpecFilterTaskResults `xml:"filterTaskResults,omitempty" json:"filterTaskResults,omitempty"`
}

func init() {
	t["TaskInfoFilterSpec"] = reflect.TypeOf((*TaskInfoFilterSpec)(nil)).Elem()
	minAPIVersionForType["TaskInfoFilterSpec"] = "8.0.3.0"
}

// This data object type enables to filter the results information for
// all or the specified tasks.
//
// 1\. If removeAll=true, the results information of all tasks will be excluded.
// 2\. If removeAll=false/unset:
// a. If descriptionIds is empty, the results information of all tasks will be included.
// b. If descriptionIds is non-empty:
// i. If filterIn=true, the results information of all tasks will be included.
// ii. If filterIn=false/unset, the results information of all tasks will be excluded.
type TaskInfoFilterSpecFilterTaskResults struct {
	DynamicData

	// Excludes results information of all tasks.
	//
	// If set to true, the results information of all tasks will be excluded.
	RemoveAll *bool `xml:"removeAll" json:"removeAll,omitempty"`
	// The description IDs of tasks that have to be filtered out.
	//
	// The `TaskInfoFilterSpecFilterTaskResults.filterIn`
	// option can switch the behavior to filter in.
	DescriptionIds []string `xml:"descriptionIds,omitempty" json:"descriptionIds,omitempty"`
	// Boolean Flag to invert the filter semantics to filter in the results instead of
	// filtering out.
	//
	// If set to true, then the results of only the tasks specified by the
	// `TaskInfoFilterSpecFilterTaskResults.descriptionIds` will be included.
	// If unset or set to false, then the results of only the tasks specified by the
	// `TaskInfoFilterSpecFilterTaskResults.descriptionIds` will be excluded.
	// This boolean flag will only be considered if descriptionsIds is non-empty and if removeAll is false.
	FilterIn *bool `xml:"filterIn" json:"filterIn,omitempty"`
}

func init() {
	t["TaskInfoFilterSpecFilterTaskResults"] = reflect.TypeOf((*TaskInfoFilterSpecFilterTaskResults)(nil)).Elem()
	minAPIVersionForType["TaskInfoFilterSpecFilterTaskResults"] = "8.0.3.0"
}

// Base type for all task reasons.
//
// Task reasons represent the kind of entity responsible for a task's creation.
type TaskReason struct {
	DynamicData
}

func init() {
	t["TaskReason"] = reflect.TypeOf((*TaskReason)(nil)).Elem()
}

// Indicates that the task was queued by an alarm.
type TaskReasonAlarm struct {
	TaskReason

	// The name of the alarm that queued the task, retained in the history
	// collector database.
	AlarmName string `xml:"alarmName" json:"alarmName"`
	// The alarm object that queued the task.
	//
	// Refers instance of `Alarm`.
	Alarm ManagedObjectReference `xml:"alarm" json:"alarm"`
	// The name of the managed entity on which the alarm is triggered,
	// retained in the history collector database.
	EntityName string `xml:"entityName" json:"entityName"`
	// The managed entity object on which the alarm is triggered.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
}

func init() {
	t["TaskReasonAlarm"] = reflect.TypeOf((*TaskReasonAlarm)(nil)).Elem()
}

// Indicates that the task was queued by a scheduled task.
type TaskReasonSchedule struct {
	TaskReason

	// The name of the scheduled task that queued this task.
	Name string `xml:"name" json:"name"`
	// The scheduledTask object that queued this task.
	//
	// Refers instance of `ScheduledTask`.
	ScheduledTask ManagedObjectReference `xml:"scheduledTask" json:"scheduledTask"`
}

func init() {
	t["TaskReasonSchedule"] = reflect.TypeOf((*TaskReasonSchedule)(nil)).Elem()
}

// Indicates that the task was started by the system (a default task).
type TaskReasonSystem struct {
	TaskReason
}

func init() {
	t["TaskReasonSystem"] = reflect.TypeOf((*TaskReasonSystem)(nil)).Elem()
}

// Indicates that the task was queued by a specific user.
type TaskReasonUser struct {
	TaskReason

	// Name of the user that queued the task.
	UserName string `xml:"userName" json:"userName"`
}

func init() {
	t["TaskReasonUser"] = reflect.TypeOf((*TaskReasonUser)(nil)).Elem()
}

// The `TaskScheduler` data object is the base type for the scheduler objects.
//
// The hierarchy of scheduler objects is as follows:
//
//	TaskScheduler
//	    `AfterStartupTaskScheduler`
//	    `OnceTaskScheduler`
//	    `RecurrentTaskScheduler`
//	        `HourlyTaskScheduler`
//	            `DailyTaskScheduler`
//	                `WeeklyTaskScheduler`
//	                `MonthlyTaskScheduler`
//	                    `MonthlyByDayTaskScheduler`
//	                    `MonthlyByWeekdayTaskScheduler`
//
// Use a scheduler object to set the time(s) for task execution.
// You can use two scheduling modes - single execution or
// recurring execution:
//   - Use the `AfterStartupTaskScheduler` or the `OnceTaskScheduler`
//     to schedule a single instance of task execution.
//   - Use one of the recurrent task schedulers to schedule
//     hourly, daily, weekly, or monthly task execution.
//
// After you have established the task timing, use the scheduler
// object for the `ScheduledTaskSpec`
// `ScheduledTaskSpec.scheduler` property value.
type TaskScheduler struct {
	DynamicData

	// The time that the schedule for the task takes effect.
	//
	// Task activation is distinct from task execution.
	// When you activate a task, its schedule starts,
	// and when the next execution time occurs, the task will run.
	// If you do not set activeTime, the activation time defaults to
	// the time that you create the scheduled task.
	ActiveTime *time.Time `xml:"activeTime" json:"activeTime,omitempty"`
	// The time the schedule for the task expires.
	//
	// If you do not set expireTime, the schedule does not expire.
	ExpireTime *time.Time `xml:"expireTime" json:"expireTime,omitempty"`
}

func init() {
	t["TaskScheduler"] = reflect.TypeOf((*TaskScheduler)(nil)).Elem()
}

// This event records when a task is cleaned up b/c of timeout
type TaskTimeoutEvent struct {
	TaskEvent
}

func init() {
	t["TaskTimeoutEvent"] = reflect.TypeOf((*TaskTimeoutEvent)(nil)).Elem()
}

// The teaming configuration of the uplink ports in the DVS matches
// physical switch configuration.
type TeamingMatchEvent struct {
	DvsHealthStatusChangeEvent
}

func init() {
	t["TeamingMatchEvent"] = reflect.TypeOf((*TeamingMatchEvent)(nil)).Elem()
}

// The teaming configuration of the uplink ports in the DVS
// does not match physical switch configuration.
type TeamingMisMatchEvent struct {
	DvsHealthStatusChangeEvent
}

func init() {
	t["TeamingMisMatchEvent"] = reflect.TypeOf((*TeamingMisMatchEvent)(nil)).Elem()
}

// This event records the start of a template upgrade.
type TemplateBeingUpgradedEvent struct {
	TemplateUpgradeEvent
}

func init() {
	t["TemplateBeingUpgradedEvent"] = reflect.TypeOf((*TemplateBeingUpgradedEvent)(nil)).Elem()
}

// This data object type describes a template virtual machine configuration file.
type TemplateConfigFileInfo struct {
	VmConfigFileInfo
}

func init() {
	t["TemplateConfigFileInfo"] = reflect.TypeOf((*TemplateConfigFileInfo)(nil)).Elem()
}

// This data object type describes the query specification for a template virtual
// machine configuration file.
type TemplateConfigFileQuery struct {
	VmConfigFileQuery
}

func init() {
	t["TemplateConfigFileQuery"] = reflect.TypeOf((*TemplateConfigFileQuery)(nil)).Elem()
}

// This event is the base class for all the template upgrade events.
type TemplateUpgradeEvent struct {
	Event

	LegacyTemplate string `xml:"legacyTemplate" json:"legacyTemplate"`
}

func init() {
	t["TemplateUpgradeEvent"] = reflect.TypeOf((*TemplateUpgradeEvent)(nil)).Elem()
}

// This event records that the template upgrade failed.
type TemplateUpgradeFailedEvent struct {
	TemplateUpgradeEvent

	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["TemplateUpgradeFailedEvent"] = reflect.TypeOf((*TemplateUpgradeFailedEvent)(nil)).Elem()
}

// This event records that the template upgrade succeeded.
type TemplateUpgradedEvent struct {
	TemplateUpgradeEvent
}

func init() {
	t["TemplateUpgradedEvent"] = reflect.TypeOf((*TemplateUpgradedEvent)(nil)).Elem()
}

// The parameters of `VirtualMachine.TerminateFaultTolerantVM_Task`.
type TerminateFaultTolerantVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The secondary virtual machine specified will be terminated, allowing
	// fault tolerance to activate. If no virtual machine is specified,
	// all secondary virtual machines will be terminated. If vm is a
	// primary, InvalidArgument exception is thrown.
	// This field must specify a virtual machine that is part of the fault
	// tolerant group that this virtual machine is currently associated with. It can
	// only be invoked from the primary virtual machine in the group. If the primary
	// virtual machine is terminated, an available secondary virtual machine will be
	// promoted to primary. If no secondary exists, an exception will be thrown and
	// the primary virtual machine will not be terminated. If a secondary virtual
	// machine is terminated, it may be respawned on a potentially different host.
	//
	// Refers instance of `VirtualMachine`.
	Vm *ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
}

func init() {
	t["TerminateFaultTolerantVMRequestType"] = reflect.TypeOf((*TerminateFaultTolerantVMRequestType)(nil)).Elem()
}

type TerminateFaultTolerantVM_Task TerminateFaultTolerantVMRequestType

func init() {
	t["TerminateFaultTolerantVM_Task"] = reflect.TypeOf((*TerminateFaultTolerantVM_Task)(nil)).Elem()
}

type TerminateFaultTolerantVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type TerminateProcessInGuest TerminateProcessInGuestRequestType

func init() {
	t["TerminateProcessInGuest"] = reflect.TypeOf((*TerminateProcessInGuest)(nil)).Elem()
}

// The parameters of `GuestProcessManager.TerminateProcessInGuest`.
type TerminateProcessInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Virtual machine to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Execute
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
	// Process ID of the process to be terminated
	Pid int64 `xml:"pid" json:"pid"`
}

func init() {
	t["TerminateProcessInGuestRequestType"] = reflect.TypeOf((*TerminateProcessInGuestRequestType)(nil)).Elem()
}

type TerminateProcessInGuestResponse struct {
}

type TerminateSession TerminateSessionRequestType

func init() {
	t["TerminateSession"] = reflect.TypeOf((*TerminateSession)(nil)).Elem()
}

// The parameters of `SessionManager.TerminateSession`.
type TerminateSessionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A list of sessions to terminate.
	SessionId []string `xml:"sessionId" json:"sessionId"`
}

func init() {
	t["TerminateSessionRequestType"] = reflect.TypeOf((*TerminateSessionRequestType)(nil)).Elem()
}

type TerminateSessionResponse struct {
}

type TerminateVM TerminateVMRequestType

func init() {
	t["TerminateVM"] = reflect.TypeOf((*TerminateVM)(nil)).Elem()
}

type TerminateVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["TerminateVMRequestType"] = reflect.TypeOf((*TerminateVMRequestType)(nil)).Elem()
}

type TerminateVMResponse struct {
}

type TestTimeService TestTimeServiceRequestType

func init() {
	t["TestTimeService"] = reflect.TypeOf((*TestTimeService)(nil)).Elem()
}

type TestTimeServiceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["TestTimeServiceRequestType"] = reflect.TypeOf((*TestTimeServiceRequestType)(nil)).Elem()
}

type TestTimeServiceResponse struct {
	Returnval *HostDateTimeSystemServiceTestResult `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// A ThirdPartyLicenseAssignmentFailed fault is thrown when
// the license assignment to a 3rd party module fails.
//
// The 3rd-party modules are installed and ran on ESX hosts,
// so this fault provides both host and module IDs.
type ThirdPartyLicenseAssignmentFailed struct {
	RuntimeFault

	// The ESX host where 3rd party license was applied.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The asset-id of 3rd party module
	Module string `xml:"module" json:"module"`
	// The reason why the assignment failed, if known.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["ThirdPartyLicenseAssignmentFailed"] = reflect.TypeOf((*ThirdPartyLicenseAssignmentFailed)(nil)).Elem()
}

type ThirdPartyLicenseAssignmentFailedFault ThirdPartyLicenseAssignmentFailed

func init() {
	t["ThirdPartyLicenseAssignmentFailedFault"] = reflect.TypeOf((*ThirdPartyLicenseAssignmentFailedFault)(nil)).Elem()
}

// TicketedSessionAuthentication contains the information necessary to
// use previously obtained credentials in the guest.
//
// The ticketed session is not stateless and stores state inside of the guest.
//
// A TicketedSessionAuthentication object will be returned as the result of a
// successful call to `GuestAuthManager.AcquireCredentialsInGuest`. You can
// use this object in any guest operations function call.
//
// When you no longer need the TicketedSessionAuthentication object, you should
// call `GuestAuthManager.ReleaseCredentialsInGuest` to free associated resources
// and session data.
type TicketedSessionAuthentication struct {
	GuestAuthentication

	// This contains a base64 encoded Ticket.
	Ticket string `xml:"ticket" json:"ticket"`
}

func init() {
	t["TicketedSessionAuthentication"] = reflect.TypeOf((*TicketedSessionAuthentication)(nil)).Elem()
}

// This event indicates that an operation performed on the host timed out.
//
// Typically,
// a previous event in the sequence of events contains more
// information about the cause of the operation timing out.
type TimedOutHostOperationEvent struct {
	HostEvent
}

func init() {
	t["TimedOutHostOperationEvent"] = reflect.TypeOf((*TimedOutHostOperationEvent)(nil)).Elem()
}

// Timedout exception is thrown when a server abandons an operation that
// is taking longer than expected.
type Timedout struct {
	VimFault
}

func init() {
	t["Timedout"] = reflect.TypeOf((*Timedout)(nil)).Elem()
}

type TimedoutFault BaseTimedout

func init() {
	t["TimedoutFault"] = reflect.TypeOf((*TimedoutFault)(nil)).Elem()
}

// Thrown if the number of levels in the snapshot tree exceeds
// the supported maximum.
type TooManyConcurrentNativeClones struct {
	FileFault
}

func init() {
	t["TooManyConcurrentNativeClones"] = reflect.TypeOf((*TooManyConcurrentNativeClones)(nil)).Elem()
}

type TooManyConcurrentNativeClonesFault TooManyConcurrentNativeClones

func init() {
	t["TooManyConcurrentNativeClonesFault"] = reflect.TypeOf((*TooManyConcurrentNativeClonesFault)(nil)).Elem()
}

// Thrown if there are too many consecutive user overrides of
// server-managed settings.
//
// There are some properties which users are
// allowed to set only in certain configurations. The system controls them
// in other configurations, and overrides all user updates. If there are
// such frequent user overrides in the system controlled state that the
// next update arrives before the previous override is complete, the
// system can enter a tight loop and appear unresponsive to the user. This
// would typically happen if the user overrides are generated by a script.
// If the number of such user overrides exceeds the supported maximum, we
// conceptually "throw" this fault. In practice, this is converted into a
// host-level ConfigIssue in VC.
type TooManyConsecutiveOverrides struct {
	VimFault
}

func init() {
	t["TooManyConsecutiveOverrides"] = reflect.TypeOf((*TooManyConsecutiveOverrides)(nil)).Elem()
}

type TooManyConsecutiveOverridesFault TooManyConsecutiveOverrides

func init() {
	t["TooManyConsecutiveOverridesFault"] = reflect.TypeOf((*TooManyConsecutiveOverridesFault)(nil)).Elem()
}

// Thrown when the number of virtual devices exceeds the maximum for
// a given controller.
type TooManyDevices struct {
	InvalidVmConfig
}

func init() {
	t["TooManyDevices"] = reflect.TypeOf((*TooManyDevices)(nil)).Elem()
}

type TooManyDevicesFault TooManyDevices

func init() {
	t["TooManyDevicesFault"] = reflect.TypeOf((*TooManyDevicesFault)(nil)).Elem()
}

// Deprecated as of vSphere 4.1, this error condition is no longer possible.
//
// The VM has too many disks which can cause the VM to take a long time
// to power-on.
//
// This can result in migration taking a long time to complete
// or to fail due to timeout. This is a problem only for migration of
// powered-on virtual machines from or to ESX 2.x hosts.
type TooManyDisksOnLegacyHost struct {
	MigrationFault

	// The number disks this VM has.
	DiskCount int32 `xml:"diskCount" json:"diskCount"`
	// Whether this number of disks will cause a timeout failure.
	TimeoutDanger bool `xml:"timeoutDanger" json:"timeoutDanger"`
}

func init() {
	t["TooManyDisksOnLegacyHost"] = reflect.TypeOf((*TooManyDisksOnLegacyHost)(nil)).Elem()
}

type TooManyDisksOnLegacyHostFault TooManyDisksOnLegacyHost

func init() {
	t["TooManyDisksOnLegacyHostFault"] = reflect.TypeOf((*TooManyDisksOnLegacyHostFault)(nil)).Elem()
}

// A TooManyGuestLogons exception is thrown when
// there are too many concurrent login sessions active
// in the guest.
//
// `GuestAuthManager.ReleaseCredentialsInGuest` can be called
// on ticketed sessions that are no longer needed. This will decrease
// the number of concurrent sessions active in the guest.
type TooManyGuestLogons struct {
	GuestOperationsFault
}

func init() {
	t["TooManyGuestLogons"] = reflect.TypeOf((*TooManyGuestLogons)(nil)).Elem()
}

type TooManyGuestLogonsFault TooManyGuestLogons

func init() {
	t["TooManyGuestLogonsFault"] = reflect.TypeOf((*TooManyGuestLogonsFault)(nil)).Elem()
}

// Thrown when a computer resource does not accept any more hosts.
//
// Clusters with DRS or
// HA enabled might impose a limit on the size of the cluster.
type TooManyHosts struct {
	HostConnectFault
}

func init() {
	t["TooManyHosts"] = reflect.TypeOf((*TooManyHosts)(nil)).Elem()
}

type TooManyHostsFault TooManyHosts

func init() {
	t["TooManyHostsFault"] = reflect.TypeOf((*TooManyHostsFault)(nil)).Elem()
}

// Thrown if the number of levels in the snapshot tree exceeds
// the supported maximum.
type TooManyNativeCloneLevels struct {
	FileFault
}

func init() {
	t["TooManyNativeCloneLevels"] = reflect.TypeOf((*TooManyNativeCloneLevels)(nil)).Elem()
}

type TooManyNativeCloneLevelsFault TooManyNativeCloneLevels

func init() {
	t["TooManyNativeCloneLevelsFault"] = reflect.TypeOf((*TooManyNativeCloneLevelsFault)(nil)).Elem()
}

// Thrown if the number of levels in the snapshot tree exceeds
// the supported maximum.
type TooManyNativeClonesOnFile struct {
	FileFault
}

func init() {
	t["TooManyNativeClonesOnFile"] = reflect.TypeOf((*TooManyNativeClonesOnFile)(nil)).Elem()
}

type TooManyNativeClonesOnFileFault TooManyNativeClonesOnFile

func init() {
	t["TooManyNativeClonesOnFileFault"] = reflect.TypeOf((*TooManyNativeClonesOnFileFault)(nil)).Elem()
}

// Thrown if the number of levels in the snapshot tree exceeds
// the supported maximum.
type TooManySnapshotLevels struct {
	SnapshotFault
}

func init() {
	t["TooManySnapshotLevels"] = reflect.TypeOf((*TooManySnapshotLevels)(nil)).Elem()
}

type TooManySnapshotLevelsFault TooManySnapshotLevels

func init() {
	t["TooManySnapshotLevelsFault"] = reflect.TypeOf((*TooManySnapshotLevelsFault)(nil)).Elem()
}

// Thrown when tools upgrade fails because the version of tools
// installed in the guest is already up-to-date.
type ToolsAlreadyUpgraded struct {
	VmToolsUpgradeFault
}

func init() {
	t["ToolsAlreadyUpgraded"] = reflect.TypeOf((*ToolsAlreadyUpgraded)(nil)).Elem()
}

type ToolsAlreadyUpgradedFault ToolsAlreadyUpgraded

func init() {
	t["ToolsAlreadyUpgradedFault"] = reflect.TypeOf((*ToolsAlreadyUpgradedFault)(nil)).Elem()
}

// Thrown when tools upgrade fails because the virtual machine's
// guest operating system doesn't support tools auto-upgrades.
type ToolsAutoUpgradeNotSupported struct {
	VmToolsUpgradeFault
}

func init() {
	t["ToolsAutoUpgradeNotSupported"] = reflect.TypeOf((*ToolsAutoUpgradeNotSupported)(nil)).Elem()
}

type ToolsAutoUpgradeNotSupportedFault ToolsAutoUpgradeNotSupported

func init() {
	t["ToolsAutoUpgradeNotSupportedFault"] = reflect.TypeOf((*ToolsAutoUpgradeNotSupportedFault)(nil)).Elem()
}

// ToolsConfigInfo is a data object type containing settings for the VMware Tools
// software running in the guest operating system.
type ToolsConfigInfo struct {
	DynamicData

	// Version of VMware Tools installed on the guest operating system.
	ToolsVersion int32 `xml:"toolsVersion,omitempty" json:"toolsVersion,omitempty"`
	// Installation type of VMware Tools in the guest operating system.
	//
	// The set of possible values is described in
	// `VirtualMachineToolsInstallType_enum`
	ToolsInstallType string `xml:"toolsInstallType,omitempty" json:"toolsInstallType,omitempty"`
	// Flag to specify whether or not scripts should run
	// after the virtual machine powers on.
	AfterPowerOn *bool `xml:"afterPowerOn" json:"afterPowerOn,omitempty"`
	// Flag to specify whether or not scripts should run
	// after the virtual machine resumes.
	AfterResume *bool `xml:"afterResume" json:"afterResume,omitempty"`
	// Flag to specify whether or not scripts should run
	// before the virtual machine suspends.
	BeforeGuestStandby *bool `xml:"beforeGuestStandby" json:"beforeGuestStandby,omitempty"`
	// Flag to specify whether or not scripts should run
	// before the virtual machine powers off.
	BeforeGuestShutdown *bool `xml:"beforeGuestShutdown" json:"beforeGuestShutdown,omitempty"`
	// Flag to specify whether or not scripts should run
	// before the virtual machine reboots.
	BeforeGuestReboot *bool `xml:"beforeGuestReboot" json:"beforeGuestReboot,omitempty"`
	// Tools upgrade policy setting for the virtual machine.
	//
	// See also `UpgradePolicy_enum`.
	ToolsUpgradePolicy string `xml:"toolsUpgradePolicy,omitempty" json:"toolsUpgradePolicy,omitempty"`
	// When set, this indicates that a customization operation is pending on the VM.
	//
	// The value represents the filename of the customization package on the host.
	PendingCustomization string `xml:"pendingCustomization,omitempty" json:"pendingCustomization,omitempty"`
	// When set, provides the id of the key used to encrypt the customization
	// package attached to the VM.
	CustomizationKeyId *CryptoKeyId `xml:"customizationKeyId,omitempty" json:"customizationKeyId,omitempty"`
	// Indicates whether or not the tools program is allowed to synchronize
	// guest time with host time.
	//
	// When set to <code>false</code>, disallows
	// tool periodic time synchronization as well as guest time step corrections
	// due to one-off events like resume from suspend.
	SyncTimeWithHostAllowed *bool `xml:"syncTimeWithHostAllowed" json:"syncTimeWithHostAllowed,omitempty" vim:"7.0.1.0"`
	// Flag to specify whether or not the tools program will periodically
	// synchronize guest time with host time.
	//
	// Periodical synchronization is
	// only allowed if `ToolsConfigInfo.syncTimeWithHostAllowed`
	// is not set to <code>false</code>.
	SyncTimeWithHost *bool `xml:"syncTimeWithHost" json:"syncTimeWithHost,omitempty"`
	// Information about the last tools upgrade attempt if applicable.
	//
	// This information is maintained by the server and is ignored if set by the client.
	LastInstallInfo *ToolsConfigInfoToolsLastInstallInfo `xml:"lastInstallInfo,omitempty" json:"lastInstallInfo,omitempty"`
}

func init() {
	t["ToolsConfigInfo"] = reflect.TypeOf((*ToolsConfigInfo)(nil)).Elem()
}

// Describes status of last tools upgrade attempt
type ToolsConfigInfoToolsLastInstallInfo struct {
	DynamicData

	// Number of attempts that have been made to upgrade the version of tools
	// installed on this virtual machine.
	Counter int32 `xml:"counter" json:"counter"`
	// Error that happened, if any, during last attempt to upgrade tools.
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["ToolsConfigInfoToolsLastInstallInfo"] = reflect.TypeOf((*ToolsConfigInfoToolsLastInstallInfo)(nil)).Elem()
}

// Thrown when the tools image couldn't be copied to the guest
// operating system: disk out of space, file access error, etc.
type ToolsImageCopyFailed struct {
	VmToolsUpgradeFault
}

func init() {
	t["ToolsImageCopyFailed"] = reflect.TypeOf((*ToolsImageCopyFailed)(nil)).Elem()
}

type ToolsImageCopyFailedFault ToolsImageCopyFailed

func init() {
	t["ToolsImageCopyFailedFault"] = reflect.TypeOf((*ToolsImageCopyFailedFault)(nil)).Elem()
}

// Thrown when tools install or upgrade fails because the required
// tools image is not available.
type ToolsImageNotAvailable struct {
	VmToolsUpgradeFault
}

func init() {
	t["ToolsImageNotAvailable"] = reflect.TypeOf((*ToolsImageNotAvailable)(nil)).Elem()
}

type ToolsImageNotAvailableFault ToolsImageNotAvailable

func init() {
	t["ToolsImageNotAvailableFault"] = reflect.TypeOf((*ToolsImageNotAvailableFault)(nil)).Elem()
}

// Thrown when tools install or upgrade fails because the
// signature check on the tools image failed.
type ToolsImageSignatureCheckFailed struct {
	VmToolsUpgradeFault
}

func init() {
	t["ToolsImageSignatureCheckFailed"] = reflect.TypeOf((*ToolsImageSignatureCheckFailed)(nil)).Elem()
}

type ToolsImageSignatureCheckFailedFault ToolsImageSignatureCheckFailed

func init() {
	t["ToolsImageSignatureCheckFailedFault"] = reflect.TypeOf((*ToolsImageSignatureCheckFailedFault)(nil)).Elem()
}

// The virtual machine is currently in the progress of guest tools installation
// that prevents the migration operation.
type ToolsInstallationInProgress struct {
	MigrationFault
}

func init() {
	t["ToolsInstallationInProgress"] = reflect.TypeOf((*ToolsInstallationInProgress)(nil)).Elem()
}

type ToolsInstallationInProgressFault ToolsInstallationInProgress

func init() {
	t["ToolsInstallationInProgressFault"] = reflect.TypeOf((*ToolsInstallationInProgressFault)(nil)).Elem()
}

// A ToolsUnavailableFault exception is thrown when an
// operation fails to contact VMware Tools
// running inside the virtual machine.
type ToolsUnavailable struct {
	VimFault
}

func init() {
	t["ToolsUnavailable"] = reflect.TypeOf((*ToolsUnavailable)(nil)).Elem()
}

type ToolsUnavailableFault ToolsUnavailable

func init() {
	t["ToolsUnavailableFault"] = reflect.TypeOf((*ToolsUnavailableFault)(nil)).Elem()
}

// Thrown when tools install or upgrade fails because the
// operation was canclled by the user.
type ToolsUpgradeCancelled struct {
	VmToolsUpgradeFault
}

func init() {
	t["ToolsUpgradeCancelled"] = reflect.TypeOf((*ToolsUpgradeCancelled)(nil)).Elem()
}

type ToolsUpgradeCancelledFault ToolsUpgradeCancelled

func init() {
	t["ToolsUpgradeCancelledFault"] = reflect.TypeOf((*ToolsUpgradeCancelledFault)(nil)).Elem()
}

// The `TraversalSpec` data object type specifies
// how to derive a new set of objects to add to the filter.
//
// It specifies a property path whose value is either another managed
// object or an array of managed objects included in the set of objects for
// consideration. This data object can also be named, using the "name"
// field in the base type.
type TraversalSpec struct {
	SelectionSpec

	// Name of the object type containing the property.
	Type string `xml:"type" json:"type"`
	// Name of the property to use in order to select additional objects.
	Path string `xml:"path" json:"path"`
	// Flag to indicate whether or not to filter the object in the "path"
	// field.
	Skip *bool `xml:"skip" json:"skip,omitempty"`
	// Optional set of selections to specify additional objects to filter.
	SelectSet []BaseSelectionSpec `xml:"selectSet,omitempty,typeattr" json:"selectSet,omitempty"`
}

func init() {
	t["TraversalSpec"] = reflect.TypeOf((*TraversalSpec)(nil)).Elem()
}

// The parameters of `HostStorageSystem.TurnDiskLocatorLedOff_Task`.
type TurnDiskLocatorLedOffRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The SCSI disk UUIDs for which the disk locator LED
	// should be turned off.
	ScsiDiskUuids []string `xml:"scsiDiskUuids" json:"scsiDiskUuids"`
}

func init() {
	t["TurnDiskLocatorLedOffRequestType"] = reflect.TypeOf((*TurnDiskLocatorLedOffRequestType)(nil)).Elem()
}

type TurnDiskLocatorLedOff_Task TurnDiskLocatorLedOffRequestType

func init() {
	t["TurnDiskLocatorLedOff_Task"] = reflect.TypeOf((*TurnDiskLocatorLedOff_Task)(nil)).Elem()
}

type TurnDiskLocatorLedOff_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostStorageSystem.TurnDiskLocatorLedOn_Task`.
type TurnDiskLocatorLedOnRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The SCSI disk UUIDs for which the disk locator LED
	// should be turned on.
	ScsiDiskUuids []string `xml:"scsiDiskUuids" json:"scsiDiskUuids"`
}

func init() {
	t["TurnDiskLocatorLedOnRequestType"] = reflect.TypeOf((*TurnDiskLocatorLedOnRequestType)(nil)).Elem()
}

type TurnDiskLocatorLedOn_Task TurnDiskLocatorLedOnRequestType

func init() {
	t["TurnDiskLocatorLedOn_Task"] = reflect.TypeOf((*TurnDiskLocatorLedOn_Task)(nil)).Elem()
}

type TurnDiskLocatorLedOn_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type TurnOffFaultToleranceForVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["TurnOffFaultToleranceForVMRequestType"] = reflect.TypeOf((*TurnOffFaultToleranceForVMRequestType)(nil)).Elem()
}

type TurnOffFaultToleranceForVM_Task TurnOffFaultToleranceForVMRequestType

func init() {
	t["TurnOffFaultToleranceForVM_Task"] = reflect.TypeOf((*TurnOffFaultToleranceForVM_Task)(nil)).Elem()
}

type TurnOffFaultToleranceForVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// Static strings used for describing an object type.
type TypeDescription struct {
	Description

	// Type being described
	Key string `xml:"key" json:"key"`
}

func init() {
	t["TypeDescription"] = reflect.TypeOf((*TypeDescription)(nil)).Elem()
}

// VFlash is not supported on the datastore.
type UnSupportedDatastoreForVFlash struct {
	UnsupportedDatastore

	// The name of the Datastore.
	DatastoreName string `xml:"datastoreName" json:"datastoreName"`
	// Datastore file system volume type.
	//
	// See `DatastoreSummary.type`
	Type string `xml:"type" json:"type"`
}

func init() {
	t["UnSupportedDatastoreForVFlash"] = reflect.TypeOf((*UnSupportedDatastoreForVFlash)(nil)).Elem()
}

type UnSupportedDatastoreForVFlashFault UnSupportedDatastoreForVFlash

func init() {
	t["UnSupportedDatastoreForVFlashFault"] = reflect.TypeOf((*UnSupportedDatastoreForVFlashFault)(nil)).Elem()
}

type UnassignUserFromGroup UnassignUserFromGroupRequestType

func init() {
	t["UnassignUserFromGroup"] = reflect.TypeOf((*UnassignUserFromGroup)(nil)).Elem()
}

// The parameters of `HostLocalAccountManager.UnassignUserFromGroup`.
type UnassignUserFromGroupRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// User being unassigned from group.
	User string `xml:"user" json:"user"`
	// Group from which the user is being removed.
	Group string `xml:"group" json:"group"`
}

func init() {
	t["UnassignUserFromGroupRequestType"] = reflect.TypeOf((*UnassignUserFromGroupRequestType)(nil)).Elem()
}

type UnassignUserFromGroupResponse struct {
}

type UnbindVnic UnbindVnicRequestType

func init() {
	t["UnbindVnic"] = reflect.TypeOf((*UnbindVnic)(nil)).Elem()
}

// The parameters of `IscsiManager.UnbindVnic`.
type UnbindVnicRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// iSCSI adapter name for which the Virtual NIC to
	// be removed.
	IScsiHbaName string `xml:"iScsiHbaName" json:"iScsiHbaName"`
	// Virtual NIC that is to be removed from the iSCSI HBA
	VnicDevice string `xml:"vnicDevice" json:"vnicDevice"`
	Force      bool   `xml:"force" json:"force"`
}

func init() {
	t["UnbindVnicRequestType"] = reflect.TypeOf((*UnbindVnicRequestType)(nil)).Elem()
}

type UnbindVnicResponse struct {
}

// Fault thrown when an attempt is made to move or clone an undoable disk with an
// uncommitted REDO log.
//
// This is an error. Undoable disks may be moved but they must
// be committed.
type UncommittedUndoableDisk struct {
	MigrationFault
}

func init() {
	t["UncommittedUndoableDisk"] = reflect.TypeOf((*UncommittedUndoableDisk)(nil)).Elem()
}

type UncommittedUndoableDiskFault UncommittedUndoableDisk

func init() {
	t["UncommittedUndoableDiskFault"] = reflect.TypeOf((*UncommittedUndoableDiskFault)(nil)).Elem()
}

// The property value has not been configured by the user, so the application
// cannot be started.
//
// This is thrown if a property value is the empty string
// and the types does not allow it. For example, for an integer type or
// a string where the minimum length is 1, and so forth.
type UnconfiguredPropertyValue struct {
	InvalidPropertyValue
}

func init() {
	t["UnconfiguredPropertyValue"] = reflect.TypeOf((*UnconfiguredPropertyValue)(nil)).Elem()
}

type UnconfiguredPropertyValueFault UnconfiguredPropertyValue

func init() {
	t["UnconfiguredPropertyValueFault"] = reflect.TypeOf((*UnconfiguredPropertyValueFault)(nil)).Elem()
}

// The specified guest operating system is not supported by the guest
// customization process.
type UncustomizableGuest struct {
	CustomizationFault

	// The guest OS ID for the uncustomizable guest.
	UncustomizableGuestOS string `xml:"uncustomizableGuestOS" json:"uncustomizableGuestOS"`
}

func init() {
	t["UncustomizableGuest"] = reflect.TypeOf((*UncustomizableGuest)(nil)).Elem()
}

type UncustomizableGuestFault UncustomizableGuest

func init() {
	t["UncustomizableGuestFault"] = reflect.TypeOf((*UncustomizableGuestFault)(nil)).Elem()
}

// Error received when customization fails, possibly due to a scripting runtime
// error or invalid script parameters.
type UnexpectedCustomizationFault struct {
	CustomizationFault
}

func init() {
	t["UnexpectedCustomizationFault"] = reflect.TypeOf((*UnexpectedCustomizationFault)(nil)).Elem()
}

type UnexpectedCustomizationFaultFault UnexpectedCustomizationFault

func init() {
	t["UnexpectedCustomizationFaultFault"] = reflect.TypeOf((*UnexpectedCustomizationFaultFault)(nil)).Elem()
}

// An UnexpectedFault may be thrown when a newer version of the server
// reports a error that a cannot be converted to a fault that a client
// that is using an older version of the API would expect.
type UnexpectedFault struct {
	RuntimeFault

	// Name of the unexpected fault.
	FaultName string `xml:"faultName" json:"faultName"`
	// The unexpected fault if the server can send it in a form that the client
	// will be able to de-serialize.
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["UnexpectedFault"] = reflect.TypeOf((*UnexpectedFault)(nil)).Elem()
}

type UnexpectedFaultFault UnexpectedFault

func init() {
	t["UnexpectedFaultFault"] = reflect.TypeOf((*UnexpectedFaultFault)(nil)).Elem()
}

// The parameters of `HostPatchManager.UninstallHostPatch_Task`.
type UninstallHostPatchRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A list of bulletin IDs to be removed.
	BulletinIds []string                                   `xml:"bulletinIds,omitempty" json:"bulletinIds,omitempty"`
	Spec        *HostPatchManagerPatchManagerOperationSpec `xml:"spec,omitempty" json:"spec,omitempty"`
}

func init() {
	t["UninstallHostPatchRequestType"] = reflect.TypeOf((*UninstallHostPatchRequestType)(nil)).Elem()
}

type UninstallHostPatch_Task UninstallHostPatchRequestType

func init() {
	t["UninstallHostPatch_Task"] = reflect.TypeOf((*UninstallHostPatch_Task)(nil)).Elem()
}

type UninstallHostPatch_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `IoFilterManager.UninstallIoFilter_Task`.
type UninstallIoFilterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// ID of the filter.
	FilterId string `xml:"filterId" json:"filterId"`
	// The compute resource to uninstall the IO Filter from.
	// "compRes" must be a cluster.
	//
	// Refers instance of `ComputeResource`.
	CompRes ManagedObjectReference `xml:"compRes" json:"compRes"`
}

func init() {
	t["UninstallIoFilterRequestType"] = reflect.TypeOf((*UninstallIoFilterRequestType)(nil)).Elem()
}

type UninstallIoFilter_Task UninstallIoFilterRequestType

func init() {
	t["UninstallIoFilter_Task"] = reflect.TypeOf((*UninstallIoFilter_Task)(nil)).Elem()
}

type UninstallIoFilter_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type UninstallService UninstallServiceRequestType

func init() {
	t["UninstallService"] = reflect.TypeOf((*UninstallService)(nil)).Elem()
}

// The parameters of `HostServiceSystem.UninstallService`.
type UninstallServiceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Service identifier
	// (`HostServiceSystem.serviceInfo*.*HostServiceInfo.service*.*HostService.key`).
	Id string `xml:"id" json:"id"`
}

func init() {
	t["UninstallServiceRequestType"] = reflect.TypeOf((*UninstallServiceRequestType)(nil)).Elem()
}

type UninstallServiceResponse struct {
}

// This event records that we have unlicensed virtual machines on the
// specified host.
//
// This can be both a (@link vim.ManagedEntity.configIssue
// configIssue) and an entry in the event log.
type UnlicensedVirtualMachinesEvent struct {
	LicenseEvent

	Unlicensed int32 `xml:"unlicensed" json:"unlicensed"`
	Available  int32 `xml:"available" json:"available"`
}

func init() {
	t["UnlicensedVirtualMachinesEvent"] = reflect.TypeOf((*UnlicensedVirtualMachinesEvent)(nil)).Elem()
}

// This event records that we discovered unlicensed virtual machines on
// the specified host.
//
// After this event is entered into the event log, we
// expect to see a corresponding (@link
// vim.event.Event.UnlicensedVirtualMachinesEvent
// UnlicensedVirtualMachinesEvent) (@link vim.ManagedEntity.configIssue
// configIssue) on the host.
type UnlicensedVirtualMachinesFoundEvent struct {
	LicenseEvent

	Available int32 `xml:"available" json:"available"`
}

func init() {
	t["UnlicensedVirtualMachinesFoundEvent"] = reflect.TypeOf((*UnlicensedVirtualMachinesFoundEvent)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UnmapVmfsVolumeEx_Task`.
type UnmapVmfsVolumeExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// each element specifies the UUID of a VMFS volume to be unmapped.
	VmfsUuid []string `xml:"vmfsUuid" json:"vmfsUuid"`
}

func init() {
	t["UnmapVmfsVolumeExRequestType"] = reflect.TypeOf((*UnmapVmfsVolumeExRequestType)(nil)).Elem()
}

type UnmapVmfsVolumeEx_Task UnmapVmfsVolumeExRequestType

func init() {
	t["UnmapVmfsVolumeEx_Task"] = reflect.TypeOf((*UnmapVmfsVolumeEx_Task)(nil)).Elem()
}

type UnmapVmfsVolumeEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type UnmarkServiceProviderEntities UnmarkServiceProviderEntitiesRequestType

func init() {
	t["UnmarkServiceProviderEntities"] = reflect.TypeOf((*UnmarkServiceProviderEntities)(nil)).Elem()
}

// The parameters of `TenantTenantManager.UnmarkServiceProviderEntities`.
type UnmarkServiceProviderEntitiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// an array of management entities.
	//
	// Required privileges: TenantManager.Update
	//
	// Refers instances of `ManagedEntity`.
	Entity []ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["UnmarkServiceProviderEntitiesRequestType"] = reflect.TypeOf((*UnmarkServiceProviderEntitiesRequestType)(nil)).Elem()
}

type UnmarkServiceProviderEntitiesResponse struct {
}

// The parameters of `HostVsanSystem.UnmountDiskMapping_Task`.
type UnmountDiskMappingRequestType struct {
	This    ManagedObjectReference `xml:"_this" json:"-"`
	Mapping []VsanHostDiskMapping  `xml:"mapping" json:"mapping"`
}

func init() {
	t["UnmountDiskMappingRequestType"] = reflect.TypeOf((*UnmountDiskMappingRequestType)(nil)).Elem()
}

type UnmountDiskMapping_Task UnmountDiskMappingRequestType

func init() {
	t["UnmountDiskMapping_Task"] = reflect.TypeOf((*UnmountDiskMapping_Task)(nil)).Elem()
}

type UnmountDiskMapping_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type UnmountForceMountedVmfsVolume UnmountForceMountedVmfsVolumeRequestType

func init() {
	t["UnmountForceMountedVmfsVolume"] = reflect.TypeOf((*UnmountForceMountedVmfsVolume)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UnmountForceMountedVmfsVolume`.
type UnmountForceMountedVmfsVolumeRequestType struct {
	This     ManagedObjectReference `xml:"_this" json:"-"`
	VmfsUuid string                 `xml:"vmfsUuid" json:"vmfsUuid"`
}

func init() {
	t["UnmountForceMountedVmfsVolumeRequestType"] = reflect.TypeOf((*UnmountForceMountedVmfsVolumeRequestType)(nil)).Elem()
}

type UnmountForceMountedVmfsVolumeResponse struct {
}

type UnmountToolsInstaller UnmountToolsInstallerRequestType

func init() {
	t["UnmountToolsInstaller"] = reflect.TypeOf((*UnmountToolsInstaller)(nil)).Elem()
}

type UnmountToolsInstallerRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["UnmountToolsInstallerRequestType"] = reflect.TypeOf((*UnmountToolsInstallerRequestType)(nil)).Elem()
}

type UnmountToolsInstallerResponse struct {
}

type UnmountVffsVolume UnmountVffsVolumeRequestType

func init() {
	t["UnmountVffsVolume"] = reflect.TypeOf((*UnmountVffsVolume)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UnmountVffsVolume`.
type UnmountVffsVolumeRequestType struct {
	This     ManagedObjectReference `xml:"_this" json:"-"`
	VffsUuid string                 `xml:"vffsUuid" json:"vffsUuid"`
}

func init() {
	t["UnmountVffsVolumeRequestType"] = reflect.TypeOf((*UnmountVffsVolumeRequestType)(nil)).Elem()
}

type UnmountVffsVolumeResponse struct {
}

type UnmountVmfsVolume UnmountVmfsVolumeRequestType

func init() {
	t["UnmountVmfsVolume"] = reflect.TypeOf((*UnmountVmfsVolume)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UnmountVmfsVolumeEx_Task`.
type UnmountVmfsVolumeExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// each element specifies the UUID of a VMFS volume to be unmounted.
	VmfsUuid []string `xml:"vmfsUuid" json:"vmfsUuid"`
}

func init() {
	t["UnmountVmfsVolumeExRequestType"] = reflect.TypeOf((*UnmountVmfsVolumeExRequestType)(nil)).Elem()
}

type UnmountVmfsVolumeEx_Task UnmountVmfsVolumeExRequestType

func init() {
	t["UnmountVmfsVolumeEx_Task"] = reflect.TypeOf((*UnmountVmfsVolumeEx_Task)(nil)).Elem()
}

type UnmountVmfsVolumeEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `HostStorageSystem.UnmountVmfsVolume`.
type UnmountVmfsVolumeRequestType struct {
	This     ManagedObjectReference `xml:"_this" json:"-"`
	VmfsUuid string                 `xml:"vmfsUuid" json:"vmfsUuid"`
}

func init() {
	t["UnmountVmfsVolumeRequestType"] = reflect.TypeOf((*UnmountVmfsVolumeRequestType)(nil)).Elem()
}

type UnmountVmfsVolumeResponse struct {
}

// A UnrecognizedHost is thrown if the VirtualCenter server fails to
// validate the identity of the host using host-key.
//
// If a reconnect is attempted on a host and if the host-key of the host
// has changed since the last successful connection attempt,
// (might be changed by another instance of VirtualCenter), VirtualCenter
// server will fail to recognize the host.
type UnrecognizedHost struct {
	VimFault

	// Host in the VirtualCenter inventory which failed the identity
	// validation.
	HostName string `xml:"hostName" json:"hostName"`
}

func init() {
	t["UnrecognizedHost"] = reflect.TypeOf((*UnrecognizedHost)(nil)).Elem()
}

type UnrecognizedHostFault UnrecognizedHost

func init() {
	t["UnrecognizedHostFault"] = reflect.TypeOf((*UnrecognizedHostFault)(nil)).Elem()
}

type UnregisterAndDestroyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["UnregisterAndDestroyRequestType"] = reflect.TypeOf((*UnregisterAndDestroyRequestType)(nil)).Elem()
}

type UnregisterAndDestroy_Task UnregisterAndDestroyRequestType

func init() {
	t["UnregisterAndDestroy_Task"] = reflect.TypeOf((*UnregisterAndDestroy_Task)(nil)).Elem()
}

type UnregisterAndDestroy_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type UnregisterExtension UnregisterExtensionRequestType

func init() {
	t["UnregisterExtension"] = reflect.TypeOf((*UnregisterExtension)(nil)).Elem()
}

// The parameters of `ExtensionManager.UnregisterExtension`.
type UnregisterExtensionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Unique name of extension to unregister.
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
}

func init() {
	t["UnregisterExtensionRequestType"] = reflect.TypeOf((*UnregisterExtensionRequestType)(nil)).Elem()
}

type UnregisterExtensionResponse struct {
}

type UnregisterHealthUpdateProvider UnregisterHealthUpdateProviderRequestType

func init() {
	t["UnregisterHealthUpdateProvider"] = reflect.TypeOf((*UnregisterHealthUpdateProvider)(nil)).Elem()
}

// The parameters of `HealthUpdateManager.UnregisterHealthUpdateProvider`.
type UnregisterHealthUpdateProviderRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The provider id.
	ProviderId string `xml:"providerId" json:"providerId"`
}

func init() {
	t["UnregisterHealthUpdateProviderRequestType"] = reflect.TypeOf((*UnregisterHealthUpdateProviderRequestType)(nil)).Elem()
}

type UnregisterHealthUpdateProviderResponse struct {
}

type UnregisterKmsCluster UnregisterKmsClusterRequestType

func init() {
	t["UnregisterKmsCluster"] = reflect.TypeOf((*UnregisterKmsCluster)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.UnregisterKmsCluster`.
type UnregisterKmsClusterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMS cluster ID to unregister.
	ClusterId KeyProviderId `xml:"clusterId" json:"clusterId"`
}

func init() {
	t["UnregisterKmsClusterRequestType"] = reflect.TypeOf((*UnregisterKmsClusterRequestType)(nil)).Elem()
}

type UnregisterKmsClusterResponse struct {
}

type UnregisterVM UnregisterVMRequestType

func init() {
	t["UnregisterVM"] = reflect.TypeOf((*UnregisterVM)(nil)).Elem()
}

type UnregisterVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["UnregisterVMRequestType"] = reflect.TypeOf((*UnregisterVMRequestType)(nil)).Elem()
}

type UnregisterVMResponse struct {
}

// The compute resource and virtual machine configurations for swapfile
// placement would require the virtual machine swapfile to change location for
// this VMotion; however the host does not support this.
type UnsharedSwapVMotionNotSupported struct {
	MigrationFeatureNotSupported
}

func init() {
	t["UnsharedSwapVMotionNotSupported"] = reflect.TypeOf((*UnsharedSwapVMotionNotSupported)(nil)).Elem()
}

type UnsharedSwapVMotionNotSupportedFault UnsharedSwapVMotionNotSupported

func init() {
	t["UnsharedSwapVMotionNotSupportedFault"] = reflect.TypeOf((*UnsharedSwapVMotionNotSupportedFault)(nil)).Elem()
}

// The virtual machine is not supported on the target datastore.
//
// This fault is
// thrown by provisioning operations when an attempt is made to create a virtual
// machine on an unsupported datastore (for example, creating a non-legacy
// virtual machine on a legacy datastore).
type UnsupportedDatastore struct {
	VmConfigFault

	// The invalid datastore for this virtual machine.
	//
	// Refers instance of `Datastore`.
	Datastore *ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty"`
}

func init() {
	t["UnsupportedDatastore"] = reflect.TypeOf((*UnsupportedDatastore)(nil)).Elem()
}

type UnsupportedDatastoreFault BaseUnsupportedDatastore

func init() {
	t["UnsupportedDatastoreFault"] = reflect.TypeOf((*UnsupportedDatastoreFault)(nil)).Elem()
}

// The specified guest operating system is not supported on the host
// that is the target of the operation.
type UnsupportedGuest struct {
	InvalidVmConfig

	// The guest OS ID for the unsupported guest.
	UnsupportedGuestOS string `xml:"unsupportedGuestOS" json:"unsupportedGuestOS"`
}

func init() {
	t["UnsupportedGuest"] = reflect.TypeOf((*UnsupportedGuest)(nil)).Elem()
}

type UnsupportedGuestFault UnsupportedGuest

func init() {
	t["UnsupportedGuestFault"] = reflect.TypeOf((*UnsupportedGuestFault)(nil)).Elem()
}

// This exception will be thrown if a client tries to connect with a unsupported version
// of the Vim API.
type UnsupportedVimApiVersion struct {
	VimFault

	Version string `xml:"version,omitempty" json:"version,omitempty"`
}

func init() {
	t["UnsupportedVimApiVersion"] = reflect.TypeOf((*UnsupportedVimApiVersion)(nil)).Elem()
}

type UnsupportedVimApiVersionFault UnsupportedVimApiVersion

func init() {
	t["UnsupportedVimApiVersionFault"] = reflect.TypeOf((*UnsupportedVimApiVersionFault)(nil)).Elem()
}

// ESX 3 Server products requires the .vmx file to be stored
// on NAS or VMFS3 storage.
//
// If attempting to power on a virtual
// machine with the .vmx file stored on the service console, this
// fault will be thrown.
type UnsupportedVmxLocation struct {
	VmConfigFault
}

func init() {
	t["UnsupportedVmxLocation"] = reflect.TypeOf((*UnsupportedVmxLocation)(nil)).Elem()
}

type UnsupportedVmxLocationFault UnsupportedVmxLocation

func init() {
	t["UnsupportedVmxLocationFault"] = reflect.TypeOf((*UnsupportedVmxLocationFault)(nil)).Elem()
}

// Specifies SSL policy for untrusted SSL certificate.
//
// This option allows to explicitly disable SSL certificate verification.
type UntrustedCertificate struct {
	IoFilterManagerSslTrust
}

func init() {
	t["UntrustedCertificate"] = reflect.TypeOf((*UntrustedCertificate)(nil)).Elem()
	minAPIVersionForType["UntrustedCertificate"] = "8.0.3.0"
}

// The unused disk blocks of the specified virtual disk have not been
// scrubbed on the file system.
//
// Typically, this fault is returned as part of a parent fault like
// `VmConfigIncompatibleForFaultTolerance`, indicating that the
// unused blocks of the virtual disk must be zeroed-out on the file system before
// before fault tolerance can be enabled on the associated virtual machine.
type UnusedVirtualDiskBlocksNotScrubbed struct {
	DeviceBackingNotSupported
}

func init() {
	t["UnusedVirtualDiskBlocksNotScrubbed"] = reflect.TypeOf((*UnusedVirtualDiskBlocksNotScrubbed)(nil)).Elem()
}

type UnusedVirtualDiskBlocksNotScrubbedFault UnusedVirtualDiskBlocksNotScrubbed

func init() {
	t["UnusedVirtualDiskBlocksNotScrubbedFault"] = reflect.TypeOf((*UnusedVirtualDiskBlocksNotScrubbedFault)(nil)).Elem()
}

// The parameters of `HostProfileManager.UpdateAnswerFile_Task`.
type UpdateAnswerFileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Host with which the answer file is associated.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Host-specific configuration data. If the configuration
	// specification does not contain any host-specific user input
	// (<code>configSpec</code>.`AnswerFileOptionsCreateSpec.userInput`),
	// the method does not perform any operation on the answer file.
	ConfigSpec BaseAnswerFileCreateSpec `xml:"configSpec,typeattr" json:"configSpec"`
}

func init() {
	t["UpdateAnswerFileRequestType"] = reflect.TypeOf((*UpdateAnswerFileRequestType)(nil)).Elem()
}

type UpdateAnswerFile_Task UpdateAnswerFileRequestType

func init() {
	t["UpdateAnswerFile_Task"] = reflect.TypeOf((*UpdateAnswerFile_Task)(nil)).Elem()
}

type UpdateAnswerFile_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type UpdateAssignableHardwareConfig UpdateAssignableHardwareConfigRequestType

func init() {
	t["UpdateAssignableHardwareConfig"] = reflect.TypeOf((*UpdateAssignableHardwareConfig)(nil)).Elem()
}

// The parameters of `HostAssignableHardwareManager.UpdateAssignableHardwareConfig`.
type UpdateAssignableHardwareConfigRequestType struct {
	This   ManagedObjectReference       `xml:"_this" json:"-"`
	Config HostAssignableHardwareConfig `xml:"config" json:"config"`
}

func init() {
	t["UpdateAssignableHardwareConfigRequestType"] = reflect.TypeOf((*UpdateAssignableHardwareConfigRequestType)(nil)).Elem()
}

type UpdateAssignableHardwareConfigResponse struct {
}

type UpdateAssignedLicense UpdateAssignedLicenseRequestType

func init() {
	t["UpdateAssignedLicense"] = reflect.TypeOf((*UpdateAssignedLicense)(nil)).Elem()
}

// The parameters of `LicenseAssignmentManager.UpdateAssignedLicense`.
type UpdateAssignedLicenseRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// ID of the entity. E.g. HostSystem.
	Entity string `xml:"entity" json:"entity"`
	// A license.
	LicenseKey string `xml:"licenseKey" json:"licenseKey"`
	// Display name for the entity
	EntityDisplayName string `xml:"entityDisplayName,omitempty" json:"entityDisplayName,omitempty"`
}

func init() {
	t["UpdateAssignedLicenseRequestType"] = reflect.TypeOf((*UpdateAssignedLicenseRequestType)(nil)).Elem()
}

type UpdateAssignedLicenseResponse struct {
	Returnval LicenseManagerLicenseInfo `xml:"returnval" json:"returnval"`
}

type UpdateAuthorizationRole UpdateAuthorizationRoleRequestType

func init() {
	t["UpdateAuthorizationRole"] = reflect.TypeOf((*UpdateAuthorizationRole)(nil)).Elem()
}

// The parameters of `AuthorizationManager.UpdateAuthorizationRole`.
type UpdateAuthorizationRoleRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the role that is updated.
	RoleId int32 `xml:"roleId" json:"roleId"`
	// The new name for the role.
	NewName string `xml:"newName" json:"newName"`
	// The new set of privileges to assign to the role.
	PrivIds []string `xml:"privIds,omitempty" json:"privIds,omitempty"`
}

func init() {
	t["UpdateAuthorizationRoleRequestType"] = reflect.TypeOf((*UpdateAuthorizationRoleRequestType)(nil)).Elem()
}

type UpdateAuthorizationRoleResponse struct {
}

type UpdateBootDevice UpdateBootDeviceRequestType

func init() {
	t["UpdateBootDevice"] = reflect.TypeOf((*UpdateBootDevice)(nil)).Elem()
}

// The parameters of `HostBootDeviceSystem.UpdateBootDevice`.
type UpdateBootDeviceRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The `HostBootDevice.key` of the
	// `HostBootDevice` from which the host will boot.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["UpdateBootDeviceRequestType"] = reflect.TypeOf((*UpdateBootDeviceRequestType)(nil)).Elem()
}

type UpdateBootDeviceResponse struct {
}

type UpdateChildResourceConfiguration UpdateChildResourceConfigurationRequestType

func init() {
	t["UpdateChildResourceConfiguration"] = reflect.TypeOf((*UpdateChildResourceConfiguration)(nil)).Elem()
}

// The parameters of `ResourcePool.UpdateChildResourceConfiguration`.
type UpdateChildResourceConfigurationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Spec []ResourceConfigSpec   `xml:"spec" json:"spec"`
}

func init() {
	t["UpdateChildResourceConfigurationRequestType"] = reflect.TypeOf((*UpdateChildResourceConfigurationRequestType)(nil)).Elem()
}

type UpdateChildResourceConfigurationResponse struct {
}

type UpdateClusterProfile UpdateClusterProfileRequestType

func init() {
	t["UpdateClusterProfile"] = reflect.TypeOf((*UpdateClusterProfile)(nil)).Elem()
}

// The parameters of `ClusterProfile.UpdateClusterProfile`.
type UpdateClusterProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specification which describes the changes.
	Config BaseClusterProfileConfigSpec `xml:"config,typeattr" json:"config"`
}

func init() {
	t["UpdateClusterProfileRequestType"] = reflect.TypeOf((*UpdateClusterProfileRequestType)(nil)).Elem()
}

type UpdateClusterProfileResponse struct {
}

type UpdateConfig UpdateConfigRequestType

func init() {
	t["UpdateConfig"] = reflect.TypeOf((*UpdateConfig)(nil)).Elem()
}

// The parameters of `ResourcePool.UpdateConfig`.
type UpdateConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If set, then the new name of the resource pool.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// If set, then the new resource allocation for this
	// resource pool.
	Config *ResourceConfigSpec `xml:"config,omitempty" json:"config,omitempty"`
}

func init() {
	t["UpdateConfigRequestType"] = reflect.TypeOf((*UpdateConfigRequestType)(nil)).Elem()
}

type UpdateConfigResponse struct {
}

type UpdateConsoleIpRouteConfig UpdateConsoleIpRouteConfigRequestType

func init() {
	t["UpdateConsoleIpRouteConfig"] = reflect.TypeOf((*UpdateConsoleIpRouteConfig)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.UpdateConsoleIpRouteConfig`.
type UpdateConsoleIpRouteConfigRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	Config BaseHostIpRouteConfig  `xml:"config,typeattr" json:"config"`
}

func init() {
	t["UpdateConsoleIpRouteConfigRequestType"] = reflect.TypeOf((*UpdateConsoleIpRouteConfigRequestType)(nil)).Elem()
}

type UpdateConsoleIpRouteConfigResponse struct {
}

type UpdateCounterLevelMapping UpdateCounterLevelMappingRequestType

func init() {
	t["UpdateCounterLevelMapping"] = reflect.TypeOf((*UpdateCounterLevelMapping)(nil)).Elem()
}

// The parameters of `PerformanceManager.UpdateCounterLevelMapping`.
type UpdateCounterLevelMappingRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// An array of `PerformanceManagerCounterLevelMapping` objects. The
	// levels for the counters passed in are changed to the passed in values. If
	// the optional aggregateLevel field is left unset then only the
	// perDeviceLevel is configured. If the optional perDeviceLevel is left
	// unset then only the aggregateLevel is configured. If there are multiple
	// entries in the passed in array for the same counterId being updated then
	// the last entry containing the counterId takes effect.
	CounterLevelMap []PerformanceManagerCounterLevelMapping `xml:"counterLevelMap" json:"counterLevelMap"`
}

func init() {
	t["UpdateCounterLevelMappingRequestType"] = reflect.TypeOf((*UpdateCounterLevelMappingRequestType)(nil)).Elem()
}

type UpdateCounterLevelMappingResponse struct {
}

// The parameters of `DistributedVirtualSwitch.UpdateDVSHealthCheckConfig_Task`.
type UpdateDVSHealthCheckConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The health check configuration.
	HealthCheckConfig []BaseDVSHealthCheckConfig `xml:"healthCheckConfig,typeattr" json:"healthCheckConfig"`
}

func init() {
	t["UpdateDVSHealthCheckConfigRequestType"] = reflect.TypeOf((*UpdateDVSHealthCheckConfigRequestType)(nil)).Elem()
}

type UpdateDVSHealthCheckConfig_Task UpdateDVSHealthCheckConfigRequestType

func init() {
	t["UpdateDVSHealthCheckConfig_Task"] = reflect.TypeOf((*UpdateDVSHealthCheckConfig_Task)(nil)).Elem()
}

type UpdateDVSHealthCheckConfig_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VmwareDistributedVirtualSwitch.UpdateDVSLacpGroupConfig_Task`.
type UpdateDVSLacpGroupConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The Link Aggregation Control Protocol groups to be configured.
	LacpGroupSpec []VMwareDvsLacpGroupSpec `xml:"lacpGroupSpec" json:"lacpGroupSpec"`
}

func init() {
	t["UpdateDVSLacpGroupConfigRequestType"] = reflect.TypeOf((*UpdateDVSLacpGroupConfigRequestType)(nil)).Elem()
}

type UpdateDVSLacpGroupConfig_Task UpdateDVSLacpGroupConfigRequestType

func init() {
	t["UpdateDVSLacpGroupConfig_Task"] = reflect.TypeOf((*UpdateDVSLacpGroupConfig_Task)(nil)).Elem()
}

type UpdateDVSLacpGroupConfig_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type UpdateDateTime UpdateDateTimeRequestType

func init() {
	t["UpdateDateTime"] = reflect.TypeOf((*UpdateDateTime)(nil)).Elem()
}

type UpdateDateTimeConfig UpdateDateTimeConfigRequestType

func init() {
	t["UpdateDateTimeConfig"] = reflect.TypeOf((*UpdateDateTimeConfig)(nil)).Elem()
}

// The parameters of `HostDateTimeSystem.UpdateDateTimeConfig`.
type UpdateDateTimeConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The new DateTime configuration information.
	Config HostDateTimeConfig `xml:"config" json:"config"`
}

func init() {
	t["UpdateDateTimeConfigRequestType"] = reflect.TypeOf((*UpdateDateTimeConfigRequestType)(nil)).Elem()
}

type UpdateDateTimeConfigResponse struct {
}

// The parameters of `HostDateTimeSystem.UpdateDateTime`.
type UpdateDateTimeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// DateTime to update the host to.
	DateTime time.Time `xml:"dateTime" json:"dateTime"`
}

func init() {
	t["UpdateDateTimeRequestType"] = reflect.TypeOf((*UpdateDateTimeRequestType)(nil)).Elem()
}

type UpdateDateTimeResponse struct {
}

type UpdateDefaultPolicy UpdateDefaultPolicyRequestType

func init() {
	t["UpdateDefaultPolicy"] = reflect.TypeOf((*UpdateDefaultPolicy)(nil)).Elem()
}

// The parameters of `HostFirewallSystem.UpdateDefaultPolicy`.
type UpdateDefaultPolicyRequestType struct {
	This          ManagedObjectReference    `xml:"_this" json:"-"`
	DefaultPolicy HostFirewallDefaultPolicy `xml:"defaultPolicy" json:"defaultPolicy"`
}

func init() {
	t["UpdateDefaultPolicyRequestType"] = reflect.TypeOf((*UpdateDefaultPolicyRequestType)(nil)).Elem()
}

type UpdateDefaultPolicyResponse struct {
}

type UpdateDiskPartitions UpdateDiskPartitionsRequestType

func init() {
	t["UpdateDiskPartitions"] = reflect.TypeOf((*UpdateDiskPartitions)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpdateDiskPartitions`.
type UpdateDiskPartitionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the device path for the specific disk.
	DevicePath string `xml:"devicePath" json:"devicePath"`
	// A data object that describes the disk partition table
	// specification used to configure the partitions on a disk.
	Spec HostDiskPartitionSpec `xml:"spec" json:"spec"`
}

func init() {
	t["UpdateDiskPartitionsRequestType"] = reflect.TypeOf((*UpdateDiskPartitionsRequestType)(nil)).Elem()
}

type UpdateDiskPartitionsResponse struct {
}

type UpdateDnsConfig UpdateDnsConfigRequestType

func init() {
	t["UpdateDnsConfig"] = reflect.TypeOf((*UpdateDnsConfig)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.UpdateDnsConfig`.
type UpdateDnsConfigRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	Config BaseHostDnsConfig      `xml:"config,typeattr" json:"config"`
}

func init() {
	t["UpdateDnsConfigRequestType"] = reflect.TypeOf((*UpdateDnsConfigRequestType)(nil)).Elem()
}

type UpdateDnsConfigResponse struct {
}

type UpdateDvsCapability UpdateDvsCapabilityRequestType

func init() {
	t["UpdateDvsCapability"] = reflect.TypeOf((*UpdateDvsCapability)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.UpdateDvsCapability`.
type UpdateDvsCapabilityRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The capability of the switch.
	Capability DVSCapability `xml:"capability" json:"capability"`
}

func init() {
	t["UpdateDvsCapabilityRequestType"] = reflect.TypeOf((*UpdateDvsCapabilityRequestType)(nil)).Elem()
}

type UpdateDvsCapabilityResponse struct {
}

type UpdateExtension UpdateExtensionRequestType

func init() {
	t["UpdateExtension"] = reflect.TypeOf((*UpdateExtension)(nil)).Elem()
}

// The parameters of `ExtensionManager.UpdateExtension`.
type UpdateExtensionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Updated extension description.
	Extension Extension `xml:"extension" json:"extension"`
}

func init() {
	t["UpdateExtensionRequestType"] = reflect.TypeOf((*UpdateExtensionRequestType)(nil)).Elem()
}

type UpdateExtensionResponse struct {
}

type UpdateFlags UpdateFlagsRequestType

func init() {
	t["UpdateFlags"] = reflect.TypeOf((*UpdateFlags)(nil)).Elem()
}

// The parameters of `HostSystem.UpdateFlags`.
type UpdateFlagsRequestType struct {
	This     ManagedObjectReference `xml:"_this" json:"-"`
	FlagInfo HostFlagInfo           `xml:"flagInfo" json:"flagInfo"`
}

func init() {
	t["UpdateFlagsRequestType"] = reflect.TypeOf((*UpdateFlagsRequestType)(nil)).Elem()
}

type UpdateFlagsResponse struct {
}

type UpdateGraphicsConfig UpdateGraphicsConfigRequestType

func init() {
	t["UpdateGraphicsConfig"] = reflect.TypeOf((*UpdateGraphicsConfig)(nil)).Elem()
}

// The parameters of `HostGraphicsManager.UpdateGraphicsConfig`.
type UpdateGraphicsConfigRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	Config HostGraphicsConfig     `xml:"config" json:"config"`
}

func init() {
	t["UpdateGraphicsConfigRequestType"] = reflect.TypeOf((*UpdateGraphicsConfigRequestType)(nil)).Elem()
}

type UpdateGraphicsConfigResponse struct {
}

type UpdateHostImageAcceptanceLevel UpdateHostImageAcceptanceLevelRequestType

func init() {
	t["UpdateHostImageAcceptanceLevel"] = reflect.TypeOf((*UpdateHostImageAcceptanceLevel)(nil)).Elem()
}

// The parameters of `HostImageConfigManager.UpdateHostImageAcceptanceLevel`.
type UpdateHostImageAcceptanceLevelRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// the new AcceptanceLevel to set.
	NewAcceptanceLevel string `xml:"newAcceptanceLevel" json:"newAcceptanceLevel"`
}

func init() {
	t["UpdateHostImageAcceptanceLevelRequestType"] = reflect.TypeOf((*UpdateHostImageAcceptanceLevelRequestType)(nil)).Elem()
}

type UpdateHostImageAcceptanceLevelResponse struct {
}

type UpdateHostProfile UpdateHostProfileRequestType

func init() {
	t["UpdateHostProfile"] = reflect.TypeOf((*UpdateHostProfile)(nil)).Elem()
}

// The parameters of `HostProfile.UpdateHostProfile`.
type UpdateHostProfileRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specification containing the new data.
	Config BaseHostProfileConfigSpec `xml:"config,typeattr" json:"config"`
}

func init() {
	t["UpdateHostProfileRequestType"] = reflect.TypeOf((*UpdateHostProfileRequestType)(nil)).Elem()
}

type UpdateHostProfileResponse struct {
}

type UpdateHostSpecification UpdateHostSpecificationRequestType

func init() {
	t["UpdateHostSpecification"] = reflect.TypeOf((*UpdateHostSpecification)(nil)).Elem()
}

// The parameters of `HostSpecificationManager.UpdateHostSpecification`.
type UpdateHostSpecificationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The host whose specification will be updated.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The new host specification to be updated with.
	HostSpec HostSpecification `xml:"hostSpec" json:"hostSpec"`
}

func init() {
	t["UpdateHostSpecificationRequestType"] = reflect.TypeOf((*UpdateHostSpecificationRequestType)(nil)).Elem()
}

type UpdateHostSpecificationResponse struct {
}

type UpdateHostSubSpecification UpdateHostSubSpecificationRequestType

func init() {
	t["UpdateHostSubSpecification"] = reflect.TypeOf((*UpdateHostSubSpecification)(nil)).Elem()
}

// The parameters of `HostSpecificationManager.UpdateHostSubSpecification`.
type UpdateHostSubSpecificationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The host whose specification will be updated.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// The data object for the new host sub specification.
	HostSubSpec HostSubSpecification `xml:"hostSubSpec" json:"hostSubSpec"`
}

func init() {
	t["UpdateHostSubSpecificationRequestType"] = reflect.TypeOf((*UpdateHostSubSpecificationRequestType)(nil)).Elem()
}

type UpdateHostSubSpecificationResponse struct {
}

type UpdateHppMultipathLunPolicy UpdateHppMultipathLunPolicyRequestType

func init() {
	t["UpdateHppMultipathLunPolicy"] = reflect.TypeOf((*UpdateHppMultipathLunPolicy)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpdateHppMultipathLunPolicy`.
type UpdateHppMultipathLunPolicyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The logical unit ID
	LunId string `xml:"lunId" json:"lunId"`
	// A data object that describes a path selection policy and
	// its configuration for the logical unit.
	Policy HostMultipathInfoHppLogicalUnitPolicy `xml:"policy" json:"policy"`
}

func init() {
	t["UpdateHppMultipathLunPolicyRequestType"] = reflect.TypeOf((*UpdateHppMultipathLunPolicyRequestType)(nil)).Elem()
}

type UpdateHppMultipathLunPolicyResponse struct {
}

type UpdateInternetScsiAdvancedOptions UpdateInternetScsiAdvancedOptionsRequestType

func init() {
	t["UpdateInternetScsiAdvancedOptions"] = reflect.TypeOf((*UpdateInternetScsiAdvancedOptions)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpdateInternetScsiAdvancedOptions`.
type UpdateInternetScsiAdvancedOptionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device of the Internet SCSI HBA adapter.
	IScsiHbaDevice string `xml:"iScsiHbaDevice" json:"iScsiHbaDevice"`
	// The set the targets to configure. If not provided,
	// the settings will be applied to the host bus adapter itself.
	TargetSet *HostInternetScsiHbaTargetSet `xml:"targetSet,omitempty" json:"targetSet,omitempty"`
	// The list of options to set.
	Options []HostInternetScsiHbaParamValue `xml:"options" json:"options"`
}

func init() {
	t["UpdateInternetScsiAdvancedOptionsRequestType"] = reflect.TypeOf((*UpdateInternetScsiAdvancedOptionsRequestType)(nil)).Elem()
}

type UpdateInternetScsiAdvancedOptionsResponse struct {
}

type UpdateInternetScsiAlias UpdateInternetScsiAliasRequestType

func init() {
	t["UpdateInternetScsiAlias"] = reflect.TypeOf((*UpdateInternetScsiAlias)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpdateInternetScsiAlias`.
type UpdateInternetScsiAliasRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device of the Internet SCSI HBA adapter.
	IScsiHbaDevice string `xml:"iScsiHbaDevice" json:"iScsiHbaDevice"`
	// The new value for the alias of the adapter.
	IScsiAlias string `xml:"iScsiAlias" json:"iScsiAlias"`
}

func init() {
	t["UpdateInternetScsiAliasRequestType"] = reflect.TypeOf((*UpdateInternetScsiAliasRequestType)(nil)).Elem()
}

type UpdateInternetScsiAliasResponse struct {
}

type UpdateInternetScsiAuthenticationProperties UpdateInternetScsiAuthenticationPropertiesRequestType

func init() {
	t["UpdateInternetScsiAuthenticationProperties"] = reflect.TypeOf((*UpdateInternetScsiAuthenticationProperties)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpdateInternetScsiAuthenticationProperties`.
type UpdateInternetScsiAuthenticationPropertiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device of the Internet SCSI HBA adapter.
	// associated with the target.
	IScsiHbaDevice string `xml:"iScsiHbaDevice" json:"iScsiHbaDevice"`
	// The data object that represents
	// the authentication settings to set.
	AuthenticationProperties HostInternetScsiHbaAuthenticationProperties `xml:"authenticationProperties" json:"authenticationProperties"`
	// The set the targets to configure. Optional,
	// when obmitted will configura the authentication properties
	// for the adapter instead.
	TargetSet *HostInternetScsiHbaTargetSet `xml:"targetSet,omitempty" json:"targetSet,omitempty"`
}

func init() {
	t["UpdateInternetScsiAuthenticationPropertiesRequestType"] = reflect.TypeOf((*UpdateInternetScsiAuthenticationPropertiesRequestType)(nil)).Elem()
}

type UpdateInternetScsiAuthenticationPropertiesResponse struct {
}

type UpdateInternetScsiDigestProperties UpdateInternetScsiDigestPropertiesRequestType

func init() {
	t["UpdateInternetScsiDigestProperties"] = reflect.TypeOf((*UpdateInternetScsiDigestProperties)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpdateInternetScsiDigestProperties`.
type UpdateInternetScsiDigestPropertiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device of the Internet SCSI HBA adapter.
	IScsiHbaDevice string `xml:"iScsiHbaDevice" json:"iScsiHbaDevice"`
	// The set the targets to configure. If not provided,
	// the settings will be applied to the host bus adapter itself.
	TargetSet *HostInternetScsiHbaTargetSet `xml:"targetSet,omitempty" json:"targetSet,omitempty"`
	// The data object that represents the digest
	// settings to set.
	DigestProperties HostInternetScsiHbaDigestProperties `xml:"digestProperties" json:"digestProperties"`
}

func init() {
	t["UpdateInternetScsiDigestPropertiesRequestType"] = reflect.TypeOf((*UpdateInternetScsiDigestPropertiesRequestType)(nil)).Elem()
}

type UpdateInternetScsiDigestPropertiesResponse struct {
}

type UpdateInternetScsiDiscoveryProperties UpdateInternetScsiDiscoveryPropertiesRequestType

func init() {
	t["UpdateInternetScsiDiscoveryProperties"] = reflect.TypeOf((*UpdateInternetScsiDiscoveryProperties)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpdateInternetScsiDiscoveryProperties`.
type UpdateInternetScsiDiscoveryPropertiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device of the Internet SCSI HBA adapter.
	IScsiHbaDevice string `xml:"iScsiHbaDevice" json:"iScsiHbaDevice"`
	// The discovery settings for this host bus adapter.
	DiscoveryProperties HostInternetScsiHbaDiscoveryProperties `xml:"discoveryProperties" json:"discoveryProperties"`
}

func init() {
	t["UpdateInternetScsiDiscoveryPropertiesRequestType"] = reflect.TypeOf((*UpdateInternetScsiDiscoveryPropertiesRequestType)(nil)).Elem()
}

type UpdateInternetScsiDiscoveryPropertiesResponse struct {
}

type UpdateInternetScsiIPProperties UpdateInternetScsiIPPropertiesRequestType

func init() {
	t["UpdateInternetScsiIPProperties"] = reflect.TypeOf((*UpdateInternetScsiIPProperties)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpdateInternetScsiIPProperties`.
type UpdateInternetScsiIPPropertiesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The device of the Internet SCSI HBA adapter.
	IScsiHbaDevice string `xml:"iScsiHbaDevice" json:"iScsiHbaDevice"`
	// A data object representing the IP properties
	// for the host bus adapter
	IpProperties HostInternetScsiHbaIPProperties `xml:"ipProperties" json:"ipProperties"`
}

func init() {
	t["UpdateInternetScsiIPPropertiesRequestType"] = reflect.TypeOf((*UpdateInternetScsiIPPropertiesRequestType)(nil)).Elem()
}

type UpdateInternetScsiIPPropertiesResponse struct {
}

type UpdateInternetScsiName UpdateInternetScsiNameRequestType

func init() {
	t["UpdateInternetScsiName"] = reflect.TypeOf((*UpdateInternetScsiName)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpdateInternetScsiName`.
type UpdateInternetScsiNameRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The current name of the Internet SCSI HBA adapter.
	IScsiHbaDevice string `xml:"iScsiHbaDevice" json:"iScsiHbaDevice"`
	// The new name for the Internet SCSI HBA adapter
	IScsiName string `xml:"iScsiName" json:"iScsiName"`
}

func init() {
	t["UpdateInternetScsiNameRequestType"] = reflect.TypeOf((*UpdateInternetScsiNameRequestType)(nil)).Elem()
}

type UpdateInternetScsiNameResponse struct {
}

type UpdateIpConfig UpdateIpConfigRequestType

func init() {
	t["UpdateIpConfig"] = reflect.TypeOf((*UpdateIpConfig)(nil)).Elem()
}

// The parameters of `HostVMotionSystem.UpdateIpConfig`.
type UpdateIpConfigRequestType struct {
	This     ManagedObjectReference `xml:"_this" json:"-"`
	IpConfig HostIpConfig           `xml:"ipConfig" json:"ipConfig"`
}

func init() {
	t["UpdateIpConfigRequestType"] = reflect.TypeOf((*UpdateIpConfigRequestType)(nil)).Elem()
}

type UpdateIpConfigResponse struct {
}

type UpdateIpPool UpdateIpPoolRequestType

func init() {
	t["UpdateIpPool"] = reflect.TypeOf((*UpdateIpPool)(nil)).Elem()
}

// The parameters of `IpPoolManager.UpdateIpPool`.
type UpdateIpPoolRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The datacenter on which to look up the pool.
	//
	// Required privileges: Datacenter.IpPoolConfig
	//
	// Refers instance of `Datacenter`.
	Dc ManagedObjectReference `xml:"dc" json:"dc"`
	// The IP pool to update on the server
	Pool IpPool `xml:"pool" json:"pool"`
}

func init() {
	t["UpdateIpPoolRequestType"] = reflect.TypeOf((*UpdateIpPoolRequestType)(nil)).Elem()
}

type UpdateIpPoolResponse struct {
}

type UpdateIpRouteConfig UpdateIpRouteConfigRequestType

func init() {
	t["UpdateIpRouteConfig"] = reflect.TypeOf((*UpdateIpRouteConfig)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.UpdateIpRouteConfig`.
type UpdateIpRouteConfigRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	Config BaseHostIpRouteConfig  `xml:"config,typeattr" json:"config"`
}

func init() {
	t["UpdateIpRouteConfigRequestType"] = reflect.TypeOf((*UpdateIpRouteConfigRequestType)(nil)).Elem()
}

type UpdateIpRouteConfigResponse struct {
}

type UpdateIpRouteTableConfig UpdateIpRouteTableConfigRequestType

func init() {
	t["UpdateIpRouteTableConfig"] = reflect.TypeOf((*UpdateIpRouteTableConfig)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.UpdateIpRouteTableConfig`.
type UpdateIpRouteTableConfigRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	Config HostIpRouteTableConfig `xml:"config" json:"config"`
}

func init() {
	t["UpdateIpRouteTableConfigRequestType"] = reflect.TypeOf((*UpdateIpRouteTableConfigRequestType)(nil)).Elem()
}

type UpdateIpRouteTableConfigResponse struct {
}

type UpdateIpmi UpdateIpmiRequestType

func init() {
	t["UpdateIpmi"] = reflect.TypeOf((*UpdateIpmi)(nil)).Elem()
}

// The parameters of `HostSystem.UpdateIpmi`.
type UpdateIpmiRequestType struct {
	This     ManagedObjectReference `xml:"_this" json:"-"`
	IpmiInfo HostIpmiInfo           `xml:"ipmiInfo" json:"ipmiInfo"`
}

func init() {
	t["UpdateIpmiRequestType"] = reflect.TypeOf((*UpdateIpmiRequestType)(nil)).Elem()
}

type UpdateIpmiResponse struct {
}

type UpdateKmipServer UpdateKmipServerRequestType

func init() {
	t["UpdateKmipServer"] = reflect.TypeOf((*UpdateKmipServer)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.UpdateKmipServer`.
type UpdateKmipServerRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP server connection information.
	// When update a KMIP server settings, changes to
	// `KmipServerSpec#defaultKeyType` and
	// `KmipServerSpec#wrappingKeySpec`
	// will apply to all servers.
	Server KmipServerSpec `xml:"server" json:"server"`
}

func init() {
	t["UpdateKmipServerRequestType"] = reflect.TypeOf((*UpdateKmipServerRequestType)(nil)).Elem()
}

type UpdateKmipServerResponse struct {
}

type UpdateKmsSignedCsrClientCert UpdateKmsSignedCsrClientCertRequestType

func init() {
	t["UpdateKmsSignedCsrClientCert"] = reflect.TypeOf((*UpdateKmsSignedCsrClientCert)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.UpdateKmsSignedCsrClientCert`.
type UpdateKmsSignedCsrClientCertRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP cluster.
	Cluster KeyProviderId `xml:"cluster" json:"cluster"`
	// \[in\] Client certificate.
	Certificate string `xml:"certificate" json:"certificate"`
}

func init() {
	t["UpdateKmsSignedCsrClientCertRequestType"] = reflect.TypeOf((*UpdateKmsSignedCsrClientCertRequestType)(nil)).Elem()
}

type UpdateKmsSignedCsrClientCertResponse struct {
}

type UpdateLicense UpdateLicenseRequestType

func init() {
	t["UpdateLicense"] = reflect.TypeOf((*UpdateLicense)(nil)).Elem()
}

type UpdateLicenseLabel UpdateLicenseLabelRequestType

func init() {
	t["UpdateLicenseLabel"] = reflect.TypeOf((*UpdateLicenseLabel)(nil)).Elem()
}

// The parameters of `LicenseManager.UpdateLicenseLabel`.
type UpdateLicenseLabelRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A license.
	LicenseKey string `xml:"licenseKey" json:"licenseKey"`
	// A label key.
	LabelKey string `xml:"labelKey" json:"labelKey"`
	// Value for the label.
	LabelValue string `xml:"labelValue" json:"labelValue"`
}

func init() {
	t["UpdateLicenseLabelRequestType"] = reflect.TypeOf((*UpdateLicenseLabelRequestType)(nil)).Elem()
}

type UpdateLicenseLabelResponse struct {
}

// The parameters of `LicenseManager.UpdateLicense`.
type UpdateLicenseRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// A license. E.g. a serial license.
	LicenseKey string `xml:"licenseKey" json:"licenseKey"`
	// array of key-value labels.
	Labels []KeyValue `xml:"labels,omitempty" json:"labels,omitempty"`
}

func init() {
	t["UpdateLicenseRequestType"] = reflect.TypeOf((*UpdateLicenseRequestType)(nil)).Elem()
}

type UpdateLicenseResponse struct {
	Returnval LicenseManagerLicenseInfo `xml:"returnval" json:"returnval"`
}

type UpdateLinkedChildren UpdateLinkedChildrenRequestType

func init() {
	t["UpdateLinkedChildren"] = reflect.TypeOf((*UpdateLinkedChildren)(nil)).Elem()
}

// The parameters of `VirtualApp.UpdateLinkedChildren`.
type UpdateLinkedChildrenRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// a set of LinkInfo objects that either add a new link
	// or modify an exisiting link.
	AddChangeSet []VirtualAppLinkInfo `xml:"addChangeSet,omitempty" json:"addChangeSet,omitempty"`
	// a set of entities that should no longer link to this vApp.
	//
	// Refers instances of `ManagedEntity`.
	RemoveSet []ManagedObjectReference `xml:"removeSet,omitempty" json:"removeSet,omitempty"`
}

func init() {
	t["UpdateLinkedChildrenRequestType"] = reflect.TypeOf((*UpdateLinkedChildrenRequestType)(nil)).Elem()
}

type UpdateLinkedChildrenResponse struct {
}

type UpdateLocalSwapDatastore UpdateLocalSwapDatastoreRequestType

func init() {
	t["UpdateLocalSwapDatastore"] = reflect.TypeOf((*UpdateLocalSwapDatastore)(nil)).Elem()
}

// The parameters of `HostDatastoreSystem.UpdateLocalSwapDatastore`.
type UpdateLocalSwapDatastoreRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The selected datastore. If this argument is unset, then
	// the `localSwapDatastore`
	// property becomes unset. Otherwise, the host must have read/write
	// access to the indicated datastore.
	//
	// Refers instance of `Datastore`.
	Datastore *ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty"`
}

func init() {
	t["UpdateLocalSwapDatastoreRequestType"] = reflect.TypeOf((*UpdateLocalSwapDatastoreRequestType)(nil)).Elem()
}

type UpdateLocalSwapDatastoreResponse struct {
}

type UpdateLockdownExceptions UpdateLockdownExceptionsRequestType

func init() {
	t["UpdateLockdownExceptions"] = reflect.TypeOf((*UpdateLockdownExceptions)(nil)).Elem()
}

// The parameters of `HostAccessManager.UpdateLockdownExceptions`.
type UpdateLockdownExceptionsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// the new list of lockdown mode exceptions.
	Users []string `xml:"users,omitempty" json:"users,omitempty"`
}

func init() {
	t["UpdateLockdownExceptionsRequestType"] = reflect.TypeOf((*UpdateLockdownExceptionsRequestType)(nil)).Elem()
}

type UpdateLockdownExceptionsResponse struct {
}

type UpdateModuleOptionString UpdateModuleOptionStringRequestType

func init() {
	t["UpdateModuleOptionString"] = reflect.TypeOf((*UpdateModuleOptionString)(nil)).Elem()
}

// The parameters of `HostKernelModuleSystem.UpdateModuleOptionString`.
type UpdateModuleOptionStringRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Module name.
	Name string `xml:"name" json:"name"`
	// Option string to be passed to the kernel module at
	// load time.
	Options string `xml:"options" json:"options"`
}

func init() {
	t["UpdateModuleOptionStringRequestType"] = reflect.TypeOf((*UpdateModuleOptionStringRequestType)(nil)).Elem()
}

type UpdateModuleOptionStringResponse struct {
}

type UpdateNetworkConfig UpdateNetworkConfigRequestType

func init() {
	t["UpdateNetworkConfig"] = reflect.TypeOf((*UpdateNetworkConfig)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.UpdateNetworkConfig`.
type UpdateNetworkConfigRequestType struct {
	This       ManagedObjectReference `xml:"_this" json:"-"`
	Config     HostNetworkConfig      `xml:"config" json:"config"`
	ChangeMode string                 `xml:"changeMode" json:"changeMode"`
}

func init() {
	t["UpdateNetworkConfigRequestType"] = reflect.TypeOf((*UpdateNetworkConfigRequestType)(nil)).Elem()
}

type UpdateNetworkConfigResponse struct {
	Returnval HostNetworkConfigResult `xml:"returnval" json:"returnval"`
}

type UpdateNetworkResourcePool UpdateNetworkResourcePoolRequestType

func init() {
	t["UpdateNetworkResourcePool"] = reflect.TypeOf((*UpdateNetworkResourcePool)(nil)).Elem()
}

// The parameters of `DistributedVirtualSwitch.UpdateNetworkResourcePool`.
type UpdateNetworkResourcePoolRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The network resource pool configuration specification.
	ConfigSpec []DVSNetworkResourcePoolConfigSpec `xml:"configSpec" json:"configSpec"`
}

func init() {
	t["UpdateNetworkResourcePoolRequestType"] = reflect.TypeOf((*UpdateNetworkResourcePoolRequestType)(nil)).Elem()
}

type UpdateNetworkResourcePoolResponse struct {
}

type UpdateOptions UpdateOptionsRequestType

func init() {
	t["UpdateOptions"] = reflect.TypeOf((*UpdateOptions)(nil)).Elem()
}

// The parameters of `OptionManager.UpdateOptions`.
type UpdateOptionsRequestType struct {
	This         ManagedObjectReference `xml:"_this" json:"-"`
	ChangedValue []BaseOptionValue      `xml:"changedValue,typeattr" json:"changedValue"`
}

func init() {
	t["UpdateOptionsRequestType"] = reflect.TypeOf((*UpdateOptionsRequestType)(nil)).Elem()
}

type UpdateOptionsResponse struct {
}

type UpdatePassthruConfig UpdatePassthruConfigRequestType

func init() {
	t["UpdatePassthruConfig"] = reflect.TypeOf((*UpdatePassthruConfig)(nil)).Elem()
}

// The parameters of `HostPciPassthruSystem.UpdatePassthruConfig`.
type UpdatePassthruConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The new PciPassthru configuration information.
	Config []BaseHostPciPassthruConfig `xml:"config,typeattr" json:"config"`
}

func init() {
	t["UpdatePassthruConfigRequestType"] = reflect.TypeOf((*UpdatePassthruConfigRequestType)(nil)).Elem()
}

type UpdatePassthruConfigResponse struct {
}

type UpdatePerfInterval UpdatePerfIntervalRequestType

func init() {
	t["UpdatePerfInterval"] = reflect.TypeOf((*UpdatePerfInterval)(nil)).Elem()
}

// The parameters of `PerformanceManager.UpdatePerfInterval`.
type UpdatePerfIntervalRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The *historical interval* being modified, a
	// complete data object comprising values for `PerfInterval.enabled`, *interval ID*,
	// `PerfInterval.length` of time to maintain statistics for this
	// interval in the database, `PerfInterval.level`, `PerfInterval.name`, and `PerfInterval.samplingPeriod`
	// properties.
	Interval PerfInterval `xml:"interval" json:"interval"`
}

func init() {
	t["UpdatePerfIntervalRequestType"] = reflect.TypeOf((*UpdatePerfIntervalRequestType)(nil)).Elem()
}

type UpdatePerfIntervalResponse struct {
}

type UpdatePhysicalNicLinkSpeed UpdatePhysicalNicLinkSpeedRequestType

func init() {
	t["UpdatePhysicalNicLinkSpeed"] = reflect.TypeOf((*UpdatePhysicalNicLinkSpeed)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.UpdatePhysicalNicLinkSpeed`.
type UpdatePhysicalNicLinkSpeedRequestType struct {
	This      ManagedObjectReference `xml:"_this" json:"-"`
	Device    string                 `xml:"device" json:"device"`
	LinkSpeed *PhysicalNicLinkInfo   `xml:"linkSpeed,omitempty" json:"linkSpeed,omitempty"`
}

func init() {
	t["UpdatePhysicalNicLinkSpeedRequestType"] = reflect.TypeOf((*UpdatePhysicalNicLinkSpeedRequestType)(nil)).Elem()
}

type UpdatePhysicalNicLinkSpeedResponse struct {
}

type UpdatePortGroup UpdatePortGroupRequestType

func init() {
	t["UpdatePortGroup"] = reflect.TypeOf((*UpdatePortGroup)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.UpdatePortGroup`.
type UpdatePortGroupRequestType struct {
	This    ManagedObjectReference `xml:"_this" json:"-"`
	PgName  string                 `xml:"pgName" json:"pgName"`
	Portgrp HostPortGroupSpec      `xml:"portgrp" json:"portgrp"`
}

func init() {
	t["UpdatePortGroupRequestType"] = reflect.TypeOf((*UpdatePortGroupRequestType)(nil)).Elem()
}

type UpdatePortGroupResponse struct {
}

// The parameters of `HostSystem.UpdateProductLockerLocation_Task`.
type UpdateProductLockerLocationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The absolute path for the VMware Tools repository
	// on the host. It should have "/vmfs/volumes/" prefix and
	// it should be a valid existing path, or it could be
	// empty to restore to default value.
	Path string `xml:"path" json:"path"`
}

func init() {
	t["UpdateProductLockerLocationRequestType"] = reflect.TypeOf((*UpdateProductLockerLocationRequestType)(nil)).Elem()
}

type UpdateProductLockerLocation_Task UpdateProductLockerLocationRequestType

func init() {
	t["UpdateProductLockerLocation_Task"] = reflect.TypeOf((*UpdateProductLockerLocation_Task)(nil)).Elem()
}

type UpdateProductLockerLocation_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type UpdateProgress UpdateProgressRequestType

func init() {
	t["UpdateProgress"] = reflect.TypeOf((*UpdateProgress)(nil)).Elem()
}

// The parameters of `Task.UpdateProgress`.
type UpdateProgressRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Percentage to set for this task
	PercentDone int32 `xml:"percentDone" json:"percentDone"`
}

func init() {
	t["UpdateProgressRequestType"] = reflect.TypeOf((*UpdateProgressRequestType)(nil)).Elem()
}

type UpdateProgressResponse struct {
}

type UpdateReferenceHost UpdateReferenceHostRequestType

func init() {
	t["UpdateReferenceHost"] = reflect.TypeOf((*UpdateReferenceHost)(nil)).Elem()
}

// The parameters of `HostProfile.UpdateReferenceHost`.
type UpdateReferenceHostRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Reference host to use. If unset, the `HostProfile.referenceHost`
	// property is cleared.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["UpdateReferenceHostRequestType"] = reflect.TypeOf((*UpdateReferenceHostRequestType)(nil)).Elem()
}

type UpdateReferenceHostResponse struct {
}

type UpdateRuleset UpdateRulesetRequestType

func init() {
	t["UpdateRuleset"] = reflect.TypeOf((*UpdateRuleset)(nil)).Elem()
}

// The parameters of `HostFirewallSystem.UpdateRuleset`.
type UpdateRulesetRequestType struct {
	This ManagedObjectReference         `xml:"_this" json:"-"`
	Id   string                         `xml:"id" json:"id"`
	Spec HostFirewallRulesetRulesetSpec `xml:"spec" json:"spec"`
}

func init() {
	t["UpdateRulesetRequestType"] = reflect.TypeOf((*UpdateRulesetRequestType)(nil)).Elem()
}

type UpdateRulesetResponse struct {
}

type UpdateScsiLunDisplayName UpdateScsiLunDisplayNameRequestType

func init() {
	t["UpdateScsiLunDisplayName"] = reflect.TypeOf((*UpdateScsiLunDisplayName)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpdateScsiLunDisplayName`.
type UpdateScsiLunDisplayNameRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The uuid of the ScsiLun to update.
	LunUuid string `xml:"lunUuid" json:"lunUuid"`
	// The new name to assign to the ScsiLun object.
	DisplayName string `xml:"displayName" json:"displayName"`
}

func init() {
	t["UpdateScsiLunDisplayNameRequestType"] = reflect.TypeOf((*UpdateScsiLunDisplayNameRequestType)(nil)).Elem()
}

type UpdateScsiLunDisplayNameResponse struct {
}

type UpdateSelfSignedClientCert UpdateSelfSignedClientCertRequestType

func init() {
	t["UpdateSelfSignedClientCert"] = reflect.TypeOf((*UpdateSelfSignedClientCert)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.UpdateSelfSignedClientCert`.
type UpdateSelfSignedClientCertRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP cluster.
	Cluster KeyProviderId `xml:"cluster" json:"cluster"`
	// \[in\] Client certificate.
	Certificate string `xml:"certificate" json:"certificate"`
}

func init() {
	t["UpdateSelfSignedClientCertRequestType"] = reflect.TypeOf((*UpdateSelfSignedClientCertRequestType)(nil)).Elem()
}

type UpdateSelfSignedClientCertResponse struct {
}

type UpdateServiceConsoleVirtualNic UpdateServiceConsoleVirtualNicRequestType

func init() {
	t["UpdateServiceConsoleVirtualNic"] = reflect.TypeOf((*UpdateServiceConsoleVirtualNic)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.UpdateServiceConsoleVirtualNic`.
type UpdateServiceConsoleVirtualNicRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	Device string                 `xml:"device" json:"device"`
	Nic    HostVirtualNicSpec     `xml:"nic" json:"nic"`
}

func init() {
	t["UpdateServiceConsoleVirtualNicRequestType"] = reflect.TypeOf((*UpdateServiceConsoleVirtualNicRequestType)(nil)).Elem()
}

type UpdateServiceConsoleVirtualNicResponse struct {
}

type UpdateServiceMessage UpdateServiceMessageRequestType

func init() {
	t["UpdateServiceMessage"] = reflect.TypeOf((*UpdateServiceMessage)(nil)).Elem()
}

// The parameters of `SessionManager.UpdateServiceMessage`.
type UpdateServiceMessageRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The message to send. Newline characters may be included.
	Message string `xml:"message" json:"message"`
}

func init() {
	t["UpdateServiceMessageRequestType"] = reflect.TypeOf((*UpdateServiceMessageRequestType)(nil)).Elem()
}

type UpdateServiceMessageResponse struct {
}

type UpdateServicePolicy UpdateServicePolicyRequestType

func init() {
	t["UpdateServicePolicy"] = reflect.TypeOf((*UpdateServicePolicy)(nil)).Elem()
}

// The parameters of `HostServiceSystem.UpdateServicePolicy`.
type UpdateServicePolicyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Service identifier
	// (`HostServiceSystem.serviceInfo*.*HostServiceInfo.service*.*HostService.key`).
	Id string `xml:"id" json:"id"`
	// Specifies the condition for service activation.
	// Use one of the `HostServicePolicy_enum` values.
	Policy string `xml:"policy" json:"policy"`
}

func init() {
	t["UpdateServicePolicyRequestType"] = reflect.TypeOf((*UpdateServicePolicyRequestType)(nil)).Elem()
}

type UpdateServicePolicyResponse struct {
}

// A set of updates that represent the changes since a prior call to `PropertyCollector.CheckForUpdates`, `PropertyCollector.WaitForUpdates`, or `PropertyCollector.WaitForUpdatesEx`.
type UpdateSet struct {
	DynamicData

	// New data version to pass in the next call to `PropertyCollector.CheckForUpdates`,
	// `PropertyCollector.WaitForUpdates`, or `PropertyCollector.WaitForUpdatesEx`.
	//
	// These versions,
	// although they are opaque, are strongly ordered in the sense that passing
	// a version to `PropertyCollector.WaitForUpdates`, `PropertyCollector.CheckForUpdates` or
	// `PropertyCollector.WaitForUpdatesEx` requests updates that reflect changes in the
	// objects selected by the Filter that happened after the specified version.
	Version string `xml:"version" json:"version"`
	// Set of managed object updates detected by specific filters.
	//
	// Updates
	// are reported in sets. Each set is associated with a reference to a
	// filter that detected the updates in the set.
	FilterSet []PropertyFilterUpdate `xml:"filterSet,omitempty" json:"filterSet,omitempty"`
	// If true, this `UpdateSet` contains results
	// from a suspended change calculation, which places restrictions on the
	// use of version.
	//
	// The `PropertyCollector` may suspend a calculation due to server
	// policy or if the total number of `ObjectUpdate` entries summed across every `PropertyFilterUpdate` reached the maximum specified in
	// `WaitOptions.maxObjectUpdates`. The client
	// can pass the "truncated data version" to `PropertyCollector.WaitForUpdatesEx` to
	// resume the update calculation, which will start on the filter where it
	// left off. A truncated data version cannot be used more than once and
	// may not be passed to `PropertyCollector.CheckForUpdates` or `PropertyCollector.WaitForUpdates`. `UpdateSet.truncated` will
	// never be true in an `UpdateSet` returned from
	// `PropertyCollector.CheckForUpdates` or `PropertyCollector.WaitForUpdates`.
	//
	// If false, this `UpdateSet` contains a
	// complete change calculation or the last part of a series of suspended
	// change calculations. The version may be passed to `PropertyCollector.CheckForUpdates`, `PropertyCollector.WaitForUpdates`, or `PropertyCollector.WaitForUpdatesEx` more than once. Re-using a version allows a client
	// to recover a change sequence after a transient failure on a previous
	// call.
	Truncated *bool `xml:"truncated" json:"truncated,omitempty"`
}

func init() {
	t["UpdateSet"] = reflect.TypeOf((*UpdateSet)(nil)).Elem()
}

type UpdateSoftwareInternetScsiEnabled UpdateSoftwareInternetScsiEnabledRequestType

func init() {
	t["UpdateSoftwareInternetScsiEnabled"] = reflect.TypeOf((*UpdateSoftwareInternetScsiEnabled)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpdateSoftwareInternetScsiEnabled`.
type UpdateSoftwareInternetScsiEnabledRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// True to enable the iSCSI; false to disable it
	Enabled bool `xml:"enabled" json:"enabled"`
}

func init() {
	t["UpdateSoftwareInternetScsiEnabledRequestType"] = reflect.TypeOf((*UpdateSoftwareInternetScsiEnabledRequestType)(nil)).Elem()
}

type UpdateSoftwareInternetScsiEnabledResponse struct {
}

type UpdateSystemResources UpdateSystemResourcesRequestType

func init() {
	t["UpdateSystemResources"] = reflect.TypeOf((*UpdateSystemResources)(nil)).Elem()
}

// The parameters of `HostSystem.UpdateSystemResources`.
type UpdateSystemResourcesRequestType struct {
	This         ManagedObjectReference `xml:"_this" json:"-"`
	ResourceInfo HostSystemResourceInfo `xml:"resourceInfo" json:"resourceInfo"`
}

func init() {
	t["UpdateSystemResourcesRequestType"] = reflect.TypeOf((*UpdateSystemResourcesRequestType)(nil)).Elem()
}

type UpdateSystemResourcesResponse struct {
}

type UpdateSystemSwapConfiguration UpdateSystemSwapConfigurationRequestType

func init() {
	t["UpdateSystemSwapConfiguration"] = reflect.TypeOf((*UpdateSystemSwapConfiguration)(nil)).Elem()
}

// The parameters of `HostSystem.UpdateSystemSwapConfiguration`.
type UpdateSystemSwapConfigurationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Contains a list of system swap options that
	// configure the system swap functionality.
	SysSwapConfig HostSystemSwapConfiguration `xml:"sysSwapConfig" json:"sysSwapConfig"`
}

func init() {
	t["UpdateSystemSwapConfigurationRequestType"] = reflect.TypeOf((*UpdateSystemSwapConfigurationRequestType)(nil)).Elem()
}

type UpdateSystemSwapConfigurationResponse struct {
}

type UpdateSystemUsers UpdateSystemUsersRequestType

func init() {
	t["UpdateSystemUsers"] = reflect.TypeOf((*UpdateSystemUsers)(nil)).Elem()
}

// The parameters of `HostAccessManager.UpdateSystemUsers`.
type UpdateSystemUsersRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// the new list of local system users.
	Users []string `xml:"users,omitempty" json:"users,omitempty"`
}

func init() {
	t["UpdateSystemUsersRequestType"] = reflect.TypeOf((*UpdateSystemUsersRequestType)(nil)).Elem()
}

type UpdateSystemUsersResponse struct {
}

type UpdateUser UpdateUserRequestType

func init() {
	t["UpdateUser"] = reflect.TypeOf((*UpdateUser)(nil)).Elem()
}

// The parameters of `HostLocalAccountManager.UpdateUser`.
type UpdateUserRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Specification of user being updated.
	User BaseHostAccountSpec `xml:"user,typeattr" json:"user"`
}

func init() {
	t["UpdateUserRequestType"] = reflect.TypeOf((*UpdateUserRequestType)(nil)).Elem()
}

type UpdateUserResponse struct {
}

type UpdateVAppConfig UpdateVAppConfigRequestType

func init() {
	t["UpdateVAppConfig"] = reflect.TypeOf((*UpdateVAppConfig)(nil)).Elem()
}

// The parameters of `VirtualApp.UpdateVAppConfig`.
type UpdateVAppConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// contains the updates to the current configuration. Any set element,
	// is changed. All values in the spec that is left unset, will not be
	// modified.
	Spec VAppConfigSpec `xml:"spec" json:"spec"`
}

func init() {
	t["UpdateVAppConfigRequestType"] = reflect.TypeOf((*UpdateVAppConfigRequestType)(nil)).Elem()
}

type UpdateVAppConfigResponse struct {
}

// The parameters of `VcenterVStorageObjectManager.UpdateVStorageInfrastructureObjectPolicy_Task`.
type UpdateVStorageInfrastructureObjectPolicyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// specification to assign a SPBM policy to virtual storage
	// infrastructure object.
	Spec VslmInfrastructureObjectPolicySpec `xml:"spec" json:"spec"`
}

func init() {
	t["UpdateVStorageInfrastructureObjectPolicyRequestType"] = reflect.TypeOf((*UpdateVStorageInfrastructureObjectPolicyRequestType)(nil)).Elem()
}

type UpdateVStorageInfrastructureObjectPolicy_Task UpdateVStorageInfrastructureObjectPolicyRequestType

func init() {
	t["UpdateVStorageInfrastructureObjectPolicy_Task"] = reflect.TypeOf((*UpdateVStorageInfrastructureObjectPolicy_Task)(nil)).Elem()
}

type UpdateVStorageInfrastructureObjectPolicy_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VcenterVStorageObjectManager.UpdateVStorageObjectCrypto_Task`.
type UpdateVStorageObjectCryptoRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual storage object is
	// located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// New profile requirement on the virtual storage object.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
	// The crypto information of each disk on the chain.
	DisksCrypto *DiskCryptoSpec `xml:"disksCrypto,omitempty" json:"disksCrypto,omitempty"`
}

func init() {
	t["UpdateVStorageObjectCryptoRequestType"] = reflect.TypeOf((*UpdateVStorageObjectCryptoRequestType)(nil)).Elem()
}

type UpdateVStorageObjectCrypto_Task UpdateVStorageObjectCryptoRequestType

func init() {
	t["UpdateVStorageObjectCrypto_Task"] = reflect.TypeOf((*UpdateVStorageObjectCrypto_Task)(nil)).Elem()
}

type UpdateVStorageObjectCrypto_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VcenterVStorageObjectManager.UpdateVStorageObjectPolicy_Task`.
type UpdateVStorageObjectPolicyRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual storage object is
	// located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// New profile requirement on the virtual storage object.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
}

func init() {
	t["UpdateVStorageObjectPolicyRequestType"] = reflect.TypeOf((*UpdateVStorageObjectPolicyRequestType)(nil)).Elem()
}

type UpdateVStorageObjectPolicy_Task UpdateVStorageObjectPolicyRequestType

func init() {
	t["UpdateVStorageObjectPolicy_Task"] = reflect.TypeOf((*UpdateVStorageObjectPolicy_Task)(nil)).Elem()
}

type UpdateVStorageObjectPolicy_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `Datastore.UpdateVVolVirtualMachineFiles_Task`.
type UpdateVVolVirtualMachineFilesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Mapping of source to target storage container
	// as well as source to target VVol IDs.
	FailoverPair []DatastoreVVolContainerFailoverPair `xml:"failoverPair,omitempty" json:"failoverPair,omitempty"`
}

func init() {
	t["UpdateVVolVirtualMachineFilesRequestType"] = reflect.TypeOf((*UpdateVVolVirtualMachineFilesRequestType)(nil)).Elem()
}

type UpdateVVolVirtualMachineFiles_Task UpdateVVolVirtualMachineFilesRequestType

func init() {
	t["UpdateVVolVirtualMachineFiles_Task"] = reflect.TypeOf((*UpdateVVolVirtualMachineFiles_Task)(nil)).Elem()
}

type UpdateVVolVirtualMachineFiles_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `Datastore.UpdateVirtualMachineFiles_Task`.
type UpdateVirtualMachineFilesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Old mount path to datastore mapping.
	MountPathDatastoreMapping []DatastoreMountPathDatastorePair `xml:"mountPathDatastoreMapping" json:"mountPathDatastoreMapping"`
}

func init() {
	t["UpdateVirtualMachineFilesRequestType"] = reflect.TypeOf((*UpdateVirtualMachineFilesRequestType)(nil)).Elem()
}

// UpdateVirtualMachineFilesResult is the result returned
// to the `Datastore.UpdateVirtualMachineFiles_Task` method.
type UpdateVirtualMachineFilesResult struct {
	DynamicData

	// The list of virtual machines files the server has attempted
	// to update but failed to update.
	FailedVmFile []UpdateVirtualMachineFilesResultFailedVmFileInfo `xml:"failedVmFile,omitempty" json:"failedVmFile,omitempty"`
}

func init() {
	t["UpdateVirtualMachineFilesResult"] = reflect.TypeOf((*UpdateVirtualMachineFilesResult)(nil)).Elem()
}

type UpdateVirtualMachineFilesResultFailedVmFileInfo struct {
	DynamicData

	// The file path
	VmFile string `xml:"vmFile" json:"vmFile"`
	// The reason why the update failed.
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["UpdateVirtualMachineFilesResultFailedVmFileInfo"] = reflect.TypeOf((*UpdateVirtualMachineFilesResultFailedVmFileInfo)(nil)).Elem()
}

type UpdateVirtualMachineFiles_Task UpdateVirtualMachineFilesRequestType

func init() {
	t["UpdateVirtualMachineFiles_Task"] = reflect.TypeOf((*UpdateVirtualMachineFiles_Task)(nil)).Elem()
}

type UpdateVirtualMachineFiles_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type UpdateVirtualNic UpdateVirtualNicRequestType

func init() {
	t["UpdateVirtualNic"] = reflect.TypeOf((*UpdateVirtualNic)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.UpdateVirtualNic`.
type UpdateVirtualNicRequestType struct {
	This   ManagedObjectReference `xml:"_this" json:"-"`
	Device string                 `xml:"device" json:"device"`
	Nic    HostVirtualNicSpec     `xml:"nic" json:"nic"`
}

func init() {
	t["UpdateVirtualNicRequestType"] = reflect.TypeOf((*UpdateVirtualNicRequestType)(nil)).Elem()
}

type UpdateVirtualNicResponse struct {
}

type UpdateVirtualSwitch UpdateVirtualSwitchRequestType

func init() {
	t["UpdateVirtualSwitch"] = reflect.TypeOf((*UpdateVirtualSwitch)(nil)).Elem()
}

// The parameters of `HostNetworkSystem.UpdateVirtualSwitch`.
type UpdateVirtualSwitchRequestType struct {
	This        ManagedObjectReference `xml:"_this" json:"-"`
	VswitchName string                 `xml:"vswitchName" json:"vswitchName"`
	Spec        HostVirtualSwitchSpec  `xml:"spec" json:"spec"`
}

func init() {
	t["UpdateVirtualSwitchRequestType"] = reflect.TypeOf((*UpdateVirtualSwitchRequestType)(nil)).Elem()
}

type UpdateVirtualSwitchResponse struct {
}

type UpdateVmfsUnmapBandwidth UpdateVmfsUnmapBandwidthRequestType

func init() {
	t["UpdateVmfsUnmapBandwidth"] = reflect.TypeOf((*UpdateVmfsUnmapBandwidth)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpdateVmfsUnmapBandwidth`.
type UpdateVmfsUnmapBandwidthRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The VMFS UUID.
	VmfsUuid string `xml:"vmfsUuid" json:"vmfsUuid"`
	// Unmap bandwidth specification. See
	// `VmfsUnmapBandwidthSpec`
	UnmapBandwidthSpec VmfsUnmapBandwidthSpec `xml:"unmapBandwidthSpec" json:"unmapBandwidthSpec"`
}

func init() {
	t["UpdateVmfsUnmapBandwidthRequestType"] = reflect.TypeOf((*UpdateVmfsUnmapBandwidthRequestType)(nil)).Elem()
}

type UpdateVmfsUnmapBandwidthResponse struct {
}

type UpdateVmfsUnmapPriority UpdateVmfsUnmapPriorityRequestType

func init() {
	t["UpdateVmfsUnmapPriority"] = reflect.TypeOf((*UpdateVmfsUnmapPriority)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpdateVmfsUnmapPriority`.
type UpdateVmfsUnmapPriorityRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The VMFS UUID.
	VmfsUuid string `xml:"vmfsUuid" json:"vmfsUuid"`
	// Unmap priority. The supported values are defined in
	// `HostVmfsVolumeUnmapPriority_enum`.
	UnmapPriority string `xml:"unmapPriority" json:"unmapPriority"`
}

func init() {
	t["UpdateVmfsUnmapPriorityRequestType"] = reflect.TypeOf((*UpdateVmfsUnmapPriorityRequestType)(nil)).Elem()
}

type UpdateVmfsUnmapPriorityResponse struct {
}

// The parameters of `HostVsanSystem.UpdateVsan_Task`.
type UpdateVsanRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// host configuration settings to use for the VSAN service.
	Config VsanHostConfigInfo `xml:"config" json:"config"`
}

func init() {
	t["UpdateVsanRequestType"] = reflect.TypeOf((*UpdateVsanRequestType)(nil)).Elem()
}

type UpdateVsan_Task UpdateVsanRequestType

func init() {
	t["UpdateVsan_Task"] = reflect.TypeOf((*UpdateVsan_Task)(nil)).Elem()
}

type UpdateVsan_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This event records that the agent has been patched and will be
// restarted.
type UpdatedAgentBeingRestartedEvent struct {
	HostEvent
}

func init() {
	t["UpdatedAgentBeingRestartedEvent"] = reflect.TypeOf((*UpdatedAgentBeingRestartedEvent)(nil)).Elem()
}

// These event types represent events converted from VirtualCenter 1.x.
//
// All upgraded events are converted to string values.
type UpgradeEvent struct {
	Event

	// The formatted message from the upgrade.
	Message string `xml:"message" json:"message"`
}

func init() {
	t["UpgradeEvent"] = reflect.TypeOf((*UpgradeEvent)(nil)).Elem()
}

// The parameters of `IoFilterManager.UpgradeIoFilter_Task`.
type UpgradeIoFilterRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The filter to be upgraded.
	FilterId string `xml:"filterId" json:"filterId"`
	// The compute resource that the filter is installed on.
	// "compRes" must be a cluster.
	//
	// Refers instance of `ComputeResource`.
	CompRes ManagedObjectReference `xml:"compRes" json:"compRes"`
	// The URL that points to the new IO Filter VIB package.
	VibUrl string `xml:"vibUrl" json:"vibUrl"`
	// This specifies SSL trust policy `IoFilterManagerSslTrust`
	// for the given VIB URL. If unset, the server certificate is
	// validated against the trusted root certificates.
	VibSslTrust BaseIoFilterManagerSslTrust `xml:"vibSslTrust,omitempty,typeattr" json:"vibSslTrust,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["UpgradeIoFilterRequestType"] = reflect.TypeOf((*UpgradeIoFilterRequestType)(nil)).Elem()
}

type UpgradeIoFilter_Task UpgradeIoFilterRequestType

func init() {
	t["UpgradeIoFilter_Task"] = reflect.TypeOf((*UpgradeIoFilter_Task)(nil)).Elem()
}

type UpgradeIoFilter_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.UpgradeTools_Task`.
type UpgradeToolsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// Command line options passed to the installer to modify
	// the installation procedure for tools.
	InstallerOptions string `xml:"installerOptions,omitempty" json:"installerOptions,omitempty"`
}

func init() {
	t["UpgradeToolsRequestType"] = reflect.TypeOf((*UpgradeToolsRequestType)(nil)).Elem()
}

type UpgradeTools_Task UpgradeToolsRequestType

func init() {
	t["UpgradeTools_Task"] = reflect.TypeOf((*UpgradeTools_Task)(nil)).Elem()
}

type UpgradeTools_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualMachine.UpgradeVM_Task`.
type UpgradeVMRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// If specified, upgrade to that specified version. If not specified,
	// upgrade to the most current virtual hardware supported on the host.
	Version string `xml:"version,omitempty" json:"version,omitempty"`
}

func init() {
	t["UpgradeVMRequestType"] = reflect.TypeOf((*UpgradeVMRequestType)(nil)).Elem()
}

type UpgradeVM_Task UpgradeVMRequestType

func init() {
	t["UpgradeVM_Task"] = reflect.TypeOf((*UpgradeVM_Task)(nil)).Elem()
}

type UpgradeVM_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type UpgradeVmLayout UpgradeVmLayoutRequestType

func init() {
	t["UpgradeVmLayout"] = reflect.TypeOf((*UpgradeVmLayout)(nil)).Elem()
}

type UpgradeVmLayoutRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["UpgradeVmLayoutRequestType"] = reflect.TypeOf((*UpgradeVmLayoutRequestType)(nil)).Elem()
}

type UpgradeVmLayoutResponse struct {
}

type UpgradeVmfs UpgradeVmfsRequestType

func init() {
	t["UpgradeVmfs"] = reflect.TypeOf((*UpgradeVmfs)(nil)).Elem()
}

// The parameters of `HostStorageSystem.UpgradeVmfs`.
type UpgradeVmfsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The path of the VMFS.
	VmfsPath string `xml:"vmfsPath" json:"vmfsPath"`
}

func init() {
	t["UpgradeVmfsRequestType"] = reflect.TypeOf((*UpgradeVmfsRequestType)(nil)).Elem()
}

type UpgradeVmfsResponse struct {
}

type UpgradeVsanObjects UpgradeVsanObjectsRequestType

func init() {
	t["UpgradeVsanObjects"] = reflect.TypeOf((*UpgradeVsanObjects)(nil)).Elem()
}

// The parameters of `HostVsanInternalSystem.UpgradeVsanObjects`.
type UpgradeVsanObjectsRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The array of objects' UUID which will be upgraded.
	Uuids []string `xml:"uuids" json:"uuids"`
	// The new version will be applied to objects.
	NewVersion int32 `xml:"newVersion" json:"newVersion"`
}

func init() {
	t["UpgradeVsanObjectsRequestType"] = reflect.TypeOf((*UpgradeVsanObjectsRequestType)(nil)).Elem()
}

type UpgradeVsanObjectsResponse struct {
	Returnval []HostVsanInternalSystemVsanObjectOperationResult `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// Mtu health check status of an uplink port is changed, and in the latest mtu health check,
// not all the vlans' MTU setting on physical switch allows vSphere Distributed Switch
// max MTU size packets passing.
type UplinkPortMtuNotSupportEvent struct {
	DvsHealthStatusChangeEvent
}

func init() {
	t["UplinkPortMtuNotSupportEvent"] = reflect.TypeOf((*UplinkPortMtuNotSupportEvent)(nil)).Elem()
}

// Mtu health check status of an uplink port is changed, and in the latest mtu health check,
// all the vlans' MTU setting on physical switch allows vSphere Distributed Switch
// max MTU size packets passing.
type UplinkPortMtuSupportEvent struct {
	DvsHealthStatusChangeEvent
}

func init() {
	t["UplinkPortMtuSupportEvent"] = reflect.TypeOf((*UplinkPortMtuSupportEvent)(nil)).Elem()
}

// Vlans health check status of an uplink port is changed, and in the latest vlan health check,
// all the vlans are trunked by the physical switch connected to the uplink port.
type UplinkPortVlanTrunkedEvent struct {
	DvsHealthStatusChangeEvent
}

func init() {
	t["UplinkPortVlanTrunkedEvent"] = reflect.TypeOf((*UplinkPortVlanTrunkedEvent)(nil)).Elem()
}

// Vlans health check status of an uplink port is changed, and in the latest vlan health check,
// not all the vlans are trunked by the physical switch connected to the uplink port.
type UplinkPortVlanUntrunkedEvent struct {
	DvsHealthStatusChangeEvent
}

func init() {
	t["UplinkPortVlanUntrunkedEvent"] = reflect.TypeOf((*UplinkPortVlanUntrunkedEvent)(nil)).Elem()
}

type UploadClientCert UploadClientCertRequestType

func init() {
	t["UploadClientCert"] = reflect.TypeOf((*UploadClientCert)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.UploadClientCert`.
type UploadClientCertRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP cluster.
	Cluster KeyProviderId `xml:"cluster" json:"cluster"`
	// \[in\] Client certificate.
	Certificate string `xml:"certificate" json:"certificate"`
	// \[in\] Private key.
	PrivateKey string `xml:"privateKey" json:"privateKey"`
}

func init() {
	t["UploadClientCertRequestType"] = reflect.TypeOf((*UploadClientCertRequestType)(nil)).Elem()
}

type UploadClientCertResponse struct {
}

type UploadKmipServerCert UploadKmipServerCertRequestType

func init() {
	t["UploadKmipServerCert"] = reflect.TypeOf((*UploadKmipServerCert)(nil)).Elem()
}

// The parameters of `CryptoManagerKmip.UploadKmipServerCert`.
type UploadKmipServerCertRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// \[in\] KMIP cluster.
	Cluster KeyProviderId `xml:"cluster" json:"cluster"`
	// \[in\] Server certificate in PEM encoding.
	Certificate string `xml:"certificate" json:"certificate"`
}

func init() {
	t["UploadKmipServerCertRequestType"] = reflect.TypeOf((*UploadKmipServerCertRequestType)(nil)).Elem()
}

type UploadKmipServerCertResponse struct {
}

// This data object contains information about which USB HID codes
// to send to the Virtual Machine's keyboard.
type UsbScanCodeSpec struct {
	DynamicData

	KeyEvents []UsbScanCodeSpecKeyEvent `xml:"keyEvents" json:"keyEvents"`
}

func init() {
	t["UsbScanCodeSpec"] = reflect.TypeOf((*UsbScanCodeSpec)(nil)).Elem()
}

type UsbScanCodeSpecKeyEvent struct {
	DynamicData

	// USB HID code of the event
	UsbHidCode int32 `xml:"usbHidCode" json:"usbHidCode"`
	// Modifiers to apply to the USB HID code
	Modifiers *UsbScanCodeSpecModifierType `xml:"modifiers,omitempty" json:"modifiers,omitempty"`
}

func init() {
	t["UsbScanCodeSpecKeyEvent"] = reflect.TypeOf((*UsbScanCodeSpecKeyEvent)(nil)).Elem()
}

// The types of key modifiers to apply to each code.
type UsbScanCodeSpecModifierType struct {
	DynamicData

	// Left control key
	LeftControl *bool `xml:"leftControl" json:"leftControl,omitempty"`
	// Left shift key
	LeftShift *bool `xml:"leftShift" json:"leftShift,omitempty"`
	// Left alt key
	LeftAlt *bool `xml:"leftAlt" json:"leftAlt,omitempty"`
	// Left gui key
	LeftGui *bool `xml:"leftGui" json:"leftGui,omitempty"`
	// Right control key
	RightControl *bool `xml:"rightControl" json:"rightControl,omitempty"`
	// Right shift key
	RightShift *bool `xml:"rightShift" json:"rightShift,omitempty"`
	// Right alt key
	RightAlt *bool `xml:"rightAlt" json:"rightAlt,omitempty"`
	// Right gui key
	RightGui *bool `xml:"rightGui" json:"rightGui,omitempty"`
}

func init() {
	t["UsbScanCodeSpecModifierType"] = reflect.TypeOf((*UsbScanCodeSpecModifierType)(nil)).Elem()
}

// This event records that a user account membership was added to a group.
type UserAssignedToGroup struct {
	HostEvent

	UserLogin string `xml:"userLogin" json:"userLogin"`
	Group     string `xml:"group" json:"group"`
}

func init() {
	t["UserAssignedToGroup"] = reflect.TypeOf((*UserAssignedToGroup)(nil)).Elem()
}

// The `UserGroupProfile` data object represents a user group.
//
// Use the `ApplyProfile.policy` list for access to configuration data
// for the user group profile. Use the `ApplyProfile.property` list for access
// to subprofile configuration data, if any.
type UserGroupProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["UserGroupProfile"] = reflect.TypeOf((*UserGroupProfile)(nil)).Elem()
}

// The `UserInputRequiredParameterMetadata` data object represents policy option metadata
// information for configuration data.
//
// The Profile Engine saves configuration
// data from the user input options in the host `AnswerFile`.
// See the `HostProfile.ExecuteHostProfile` and
// `HostProfileManager.ApplyHostConfig_Task` methods.
type UserInputRequiredParameterMetadata struct {
	ProfilePolicyOptionMetadata

	// Metadata for user input options.
	UserInputParameter []ProfileParameterMetadata `xml:"userInputParameter,omitempty" json:"userInputParameter,omitempty"`
}

func init() {
	t["UserInputRequiredParameterMetadata"] = reflect.TypeOf((*UserInputRequiredParameterMetadata)(nil)).Elem()
}

// This event records a user logon.
type UserLoginSessionEvent struct {
	SessionEvent

	// The IP address of the peer that initiated the connection.
	//
	// This may
	// be the client that originated the session, or it may be an intervening
	// proxy if the binding uses a protocol that supports proxies, such as HTTP.
	IpAddress string `xml:"ipAddress" json:"ipAddress"`
	// The user agent or application
	UserAgent string `xml:"userAgent,omitempty" json:"userAgent,omitempty"`
	// The locale of the session.
	Locale string `xml:"locale" json:"locale"`
	// The unique identifier for the session.
	SessionId string `xml:"sessionId" json:"sessionId"`
}

func init() {
	t["UserLoginSessionEvent"] = reflect.TypeOf((*UserLoginSessionEvent)(nil)).Elem()
}

// This event records a user logoff, disconnection, or session timeout.
type UserLogoutSessionEvent struct {
	SessionEvent

	// The IP address of client
	IpAddress string `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
	// The user agent or application
	UserAgent string `xml:"userAgent,omitempty" json:"userAgent,omitempty"`
	// Number of API invocations made by the session
	CallCount int64 `xml:"callCount,omitempty" json:"callCount,omitempty"`
	// The unique identifier for the session.
	SessionId string `xml:"sessionId,omitempty" json:"sessionId,omitempty"`
	// Timestamp when the user logged on for this session.
	LoginTime *time.Time `xml:"loginTime" json:"loginTime,omitempty"`
}

func init() {
	t["UserLogoutSessionEvent"] = reflect.TypeOf((*UserLogoutSessionEvent)(nil)).Elem()
}

// Thrown when the request refers to a user or group name that could not
// be resolved.
type UserNotFound struct {
	VimFault

	// Principal value that failed lookup.
	Principal string `xml:"principal" json:"principal"`
	// Flag to indicate whether or not the lookup was unsuccessful.
	//
	// A false value indicates that the user does not exist in the directory. A true
	// value indicates that the directory could not be contacted, possibly due to a
	// network error.
	Unresolved bool `xml:"unresolved" json:"unresolved"`
}

func init() {
	t["UserNotFound"] = reflect.TypeOf((*UserNotFound)(nil)).Elem()
}

type UserNotFoundFault UserNotFound

func init() {
	t["UserNotFoundFault"] = reflect.TypeOf((*UserNotFoundFault)(nil)).Elem()
}

// This event records that a user password changed.
type UserPasswordChanged struct {
	HostEvent

	UserLogin string `xml:"userLogin" json:"userLogin"`
}

func init() {
	t["UserPasswordChanged"] = reflect.TypeOf((*UserPasswordChanged)(nil)).Elem()
}

// This class is used to provide the list of effective privileges
// set on a given managed entity for a user.
type UserPrivilegeResult struct {
	DynamicData

	// The entity on which privileges are retrieved.
	//
	// Refers instance of `ManagedEntity`.
	Entity ManagedObjectReference `xml:"entity" json:"entity"`
	// A list of privileges set on the entity.
	Privileges []string `xml:"privileges,omitempty" json:"privileges,omitempty"`
}

func init() {
	t["UserPrivilegeResult"] = reflect.TypeOf((*UserPrivilegeResult)(nil)).Elem()
}

// The `UserProfile` data object represents a user.
//
// Use the `ApplyProfile.policy` list for access to configuration data
// for the user profile. Use the `ApplyProfile.property` list for access
// to subprofile configuration data, if any.
type UserProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
}

func init() {
	t["UserProfile"] = reflect.TypeOf((*UserProfile)(nil)).Elem()
}

// When searching for users, the search results in
// some additional information.
//
// This object describes
// the additional information.
type UserSearchResult struct {
	DynamicData

	// Login name of a user or the name of a group.
	//
	// This key is
	// the user within the searched domain.
	Principal string `xml:"principal" json:"principal"`
	// Full name of the user found by the search, or the description
	// of a group, if available.
	FullName string `xml:"fullName,omitempty" json:"fullName,omitempty"`
	// If this is true, then the result is a group.
	//
	// If this is false, then the
	// result is a user.
	Group bool `xml:"group" json:"group"`
}

func init() {
	t["UserSearchResult"] = reflect.TypeOf((*UserSearchResult)(nil)).Elem()
}

// Information about a current user session.
type UserSession struct {
	DynamicData

	// A unique identifier for this session,
	// also known as the session ID.
	Key string `xml:"key" json:"key"`
	// The user name represented by this session.
	UserName string `xml:"userName" json:"userName"`
	// The full name of the user, if available.
	FullName string `xml:"fullName" json:"fullName"`
	// Timestamp when the user last logged on to the server.
	LoginTime time.Time `xml:"loginTime" json:"loginTime"`
	// Timestamp when the user last executed a command.
	LastActiveTime time.Time `xml:"lastActiveTime" json:"lastActiveTime"`
	// The locale for the session used for data formatting and preferred for messages.
	Locale string `xml:"locale" json:"locale"`
	// The locale used for messages for the session.
	//
	// If there are no localized messages for the user-specified locale, then
	// the server determines this locale.
	MessageLocale string `xml:"messageLocale" json:"messageLocale"`
	// Whether or not this session belongs to a VC Extension.
	ExtensionSession *bool `xml:"extensionSession" json:"extensionSession,omitempty"`
	// The client identity.
	//
	// It could be IP address, or pipe name depended
	// on client binding
	IpAddress string `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
	// The name of user agent or application
	UserAgent string `xml:"userAgent,omitempty" json:"userAgent,omitempty"`
	// Number of API invocations since the session started
	CallCount int64 `xml:"callCount,omitempty" json:"callCount,omitempty"`
}

func init() {
	t["UserSession"] = reflect.TypeOf((*UserSession)(nil)).Elem()
}

// This event records that a user account membership was removed from a group.
type UserUnassignedFromGroup struct {
	HostEvent

	UserLogin string `xml:"userLogin" json:"userLogin"`
	Group     string `xml:"group" json:"group"`
}

func init() {
	t["UserUnassignedFromGroup"] = reflect.TypeOf((*UserUnassignedFromGroup)(nil)).Elem()
}

// This event is a general user event from upgrade.
type UserUpgradeEvent struct {
	UpgradeEvent
}

func init() {
	t["UserUpgradeEvent"] = reflect.TypeOf((*UserUpgradeEvent)(nil)).Elem()
}

// Represent Storage Array
type VASAStorageArray struct {
	DynamicData

	// Name
	Name string `xml:"name" json:"name"`
	// Unique identifier
	Uuid string `xml:"uuid" json:"uuid"`
	// Vendor Id
	VendorId string `xml:"vendorId" json:"vendorId"`
	// Model Id
	ModelId string `xml:"modelId" json:"modelId"`
	// Transport information to address the array's discovery
	// service.
	DiscoverySvcInfo []VASAStorageArrayDiscoverySvcInfo `xml:"discoverySvcInfo,omitempty" json:"discoverySvcInfo,omitempty" vim:"8.0.0.0"`
}

func init() {
	t["VASAStorageArray"] = reflect.TypeOf((*VASAStorageArray)(nil)).Elem()
}

// Discovery service information of the array with FC
// transport.
type VASAStorageArrayDiscoveryFcTransport struct {
	DynamicData

	// Node-WWN (World Wide Name) represented in hexadecimal format.
	NodeWwn string `xml:"nodeWwn" json:"nodeWwn"`
	// Port-WWN (World Wide Name) represented in hexadecimal format.
	PortWwn string `xml:"portWwn" json:"portWwn"`
}

func init() {
	t["VASAStorageArrayDiscoveryFcTransport"] = reflect.TypeOf((*VASAStorageArrayDiscoveryFcTransport)(nil)).Elem()
	minAPIVersionForType["VASAStorageArrayDiscoveryFcTransport"] = "8.0.0.0"
}

// Discovery service information of the array with IP
// transport.
type VASAStorageArrayDiscoveryIpTransport struct {
	DynamicData

	// IP address (IPv4/v6) of the RDMA/TCP target port.
	IpAddress string `xml:"ipAddress" json:"ipAddress"`
	// Port number.
	//
	// Defaults to port 8009 (TCP) and RoCEv2
	// port 4420 (UDP).
	PortNumber string `xml:"portNumber,omitempty" json:"portNumber,omitempty"`
}

func init() {
	t["VASAStorageArrayDiscoveryIpTransport"] = reflect.TypeOf((*VASAStorageArrayDiscoveryIpTransport)(nil)).Elem()
	minAPIVersionForType["VASAStorageArrayDiscoveryIpTransport"] = "8.0.0.0"
}

// Discovery service information of storage array.
type VASAStorageArrayDiscoverySvcInfo struct {
	DynamicData

	// Port type, string as defined in `VASAStorageArrayBlockEnum_enum`.
	PortType string `xml:"portType" json:"portType"`
	// Well-known NQN of discovery service.
	SvcNqn string `xml:"svcNqn" json:"svcNqn"`
	// IP transport discovery information.
	//
	// Must be specified if
	// the discovery service is IP-based.
	IpInfo *VASAStorageArrayDiscoveryIpTransport `xml:"ipInfo,omitempty" json:"ipInfo,omitempty"`
	// FC transport discovery information.
	//
	// Must be specified if
	// the discovery service is FC-based.
	FcInfo *VASAStorageArrayDiscoveryFcTransport `xml:"fcInfo,omitempty" json:"fcInfo,omitempty"`
}

func init() {
	t["VASAStorageArrayDiscoverySvcInfo"] = reflect.TypeOf((*VASAStorageArrayDiscoverySvcInfo)(nil)).Elem()
	minAPIVersionForType["VASAStorageArrayDiscoverySvcInfo"] = "8.0.0.0"
}

// Specification for a vApp cloning operation.
type VAppCloneSpec struct {
	DynamicData

	// Location where the destination vApp must be stored
	//
	// Refers instance of `Datastore`.
	Location ManagedObjectReference `xml:"location" json:"location"`
	// The target host for the virtual machines.
	//
	// This is often not a required
	// parameter. If not specified, the behavior is as follows:
	//   - If the target pool represents a stand-alone host, that host is used.
	//   - If the target pool represents a DRS-enabled cluster, a host selected
	//     by DRS is used.
	//   - If the target pool represents a cluster without DRS enabled or a
	//     DRS-enabled cluster in manual mode, an InvalidArgument exception is
	//     thrown.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The resource configuration for the vApp.
	ResourceSpec *ResourceConfigSpec `xml:"resourceSpec,omitempty" json:"resourceSpec,omitempty"`
	// The VM Folder to associate the vApp with
	//
	// Refers instance of `Folder`.
	VmFolder *ManagedObjectReference `xml:"vmFolder,omitempty" json:"vmFolder,omitempty"`
	// Network mappings.
	//
	// See `VAppCloneSpecNetworkMappingPair`.
	NetworkMapping []VAppCloneSpecNetworkMappingPair `xml:"networkMapping,omitempty" json:"networkMapping,omitempty"`
	// A set of property values to override.
	Property []KeyValue `xml:"property,omitempty" json:"property,omitempty"`
	// The resource configuration for the cloned vApp.
	ResourceMapping []VAppCloneSpecResourceMap `xml:"resourceMapping,omitempty" json:"resourceMapping,omitempty"`
	// Specify how the VMs in the vApp should be provisioned.
	Provisioning string `xml:"provisioning,omitempty" json:"provisioning,omitempty"`
}

func init() {
	t["VAppCloneSpec"] = reflect.TypeOf((*VAppCloneSpec)(nil)).Elem()
}

// Maps one network to another as part of the clone process.
//
// Instances of this class are used in the field `VAppCloneSpec.networkMapping`
type VAppCloneSpecNetworkMappingPair struct {
	DynamicData

	// The source network
	//
	// Refers instance of `Network`.
	Source ManagedObjectReference `xml:"source" json:"source"`
	// The destination network
	//
	// Refers instance of `Network`.
	Destination ManagedObjectReference `xml:"destination" json:"destination"`
}

func init() {
	t["VAppCloneSpecNetworkMappingPair"] = reflect.TypeOf((*VAppCloneSpecNetworkMappingPair)(nil)).Elem()
}

// Maps source child entities to destination resource pools
// and resource settings.
//
// If a mapping is not specified,
// a child is copied as a direct child of the parent.
type VAppCloneSpecResourceMap struct {
	DynamicData

	// Source entity
	//
	// Refers instance of `ManagedEntity`.
	Source ManagedObjectReference `xml:"source" json:"source"`
	// Resource pool to use for the cloned entity of source.
	//
	// This must specify a
	// resource pool that is not part of the vApp. If this is specified, a linked
	// child (as opposed to a direct child) is created for the vApp.
	//
	// Refers instance of `ResourcePool`.
	Parent *ManagedObjectReference `xml:"parent,omitempty" json:"parent,omitempty"`
	// An optional resource configuration for the cloned entity of the source.
	//
	// If
	// not specified, the same resource configuration as the source is used.
	ResourceSpec *ResourceConfigSpec `xml:"resourceSpec,omitempty" json:"resourceSpec,omitempty"`
	// A client can optionally specify a datastore in the resource map to
	// override the default datastore location set in `VAppCloneSpecResourceMap.location` field.
	//
	// This
	// enables cloning to different compute resources that do not have shared
	// datastores.
	//
	// Refers instance of `Datastore`.
	Location *ManagedObjectReference `xml:"location,omitempty" json:"location,omitempty"`
}

func init() {
	t["VAppCloneSpecResourceMap"] = reflect.TypeOf((*VAppCloneSpecResourceMap)(nil)).Elem()
}

// Base for configuration / environment issues that can be thrown when powering on or
// changing the configuration of a vApp.
type VAppConfigFault struct {
	VimFault
}

func init() {
	t["VAppConfigFault"] = reflect.TypeOf((*VAppConfigFault)(nil)).Elem()
}

type VAppConfigFaultFault BaseVAppConfigFault

func init() {
	t["VAppConfigFaultFault"] = reflect.TypeOf((*VAppConfigFaultFault)(nil)).Elem()
}

// Configuration of a vApp container.
type VAppConfigInfo struct {
	VmConfigInfo

	// Configuration of sub-entities (virtual machine or vApp).
	EntityConfig []VAppEntityConfigInfo `xml:"entityConfig,omitempty" json:"entityConfig,omitempty"`
	// Description for the vApp.
	Annotation string `xml:"annotation" json:"annotation"`
	// vCenter-specific 128-bit UUID of a vApp, represented as a hexademical
	// string.
	//
	// This identifier is used by vCenter to uniquely identify all
	// vApp instances.
	InstanceUuid string `xml:"instanceUuid,omitempty" json:"instanceUuid,omitempty"`
	// Specifies that this vApp is managed by a VC Extension.
	//
	// See the
	// `managedBy` property in the
	// VAppConfigSpec for more details.
	ManagedBy *ManagedByInfo `xml:"managedBy,omitempty" json:"managedBy,omitempty"`
}

func init() {
	t["VAppConfigInfo"] = reflect.TypeOf((*VAppConfigInfo)(nil)).Elem()
}

// Configuration of a vApp
type VAppConfigSpec struct {
	VmConfigSpec

	// Configuration of sub-entities (virtual machine or vApp container).
	//
	// Reconfigure privilege: See EntityConfigInfo
	EntityConfig []VAppEntityConfigInfo `xml:"entityConfig,omitempty" json:"entityConfig,omitempty"`
	// Description for the vApp.
	//
	// Reconfigure privilege: VApp.Rename.
	Annotation string `xml:"annotation,omitempty" json:"annotation,omitempty"`
	// vCenter-specific 128-bit UUID of a vApp, represented as a hexadecimal
	// string.
	//
	// This identifier is used by vCenter to uniquely identify all
	// vApp instances in the Virtual Infrastructure environment.
	//
	// Normally, this property is not set by a client, allowing the
	// Virtual Infrastructure environment to assign or change it when
	// VirtualCenter detects an identifier conflict between vApps.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	InstanceUuid string `xml:"instanceUuid,omitempty" json:"instanceUuid,omitempty"`
	// Specifies that this vApp is managed by a VC Extension.
	//
	// This information is primarily used in the Client to show a custom icon for
	// managed vApps, and a description of the function of the vApp. If no extension
	// can be found with the extension key in the `managedBy`
	// object, or the type is not found in the
	// `managedEntityInfo` list of the
	// extension, the default vApp icon is used, and no description is shown.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	ManagedBy *ManagedByInfo `xml:"managedBy,omitempty" json:"managedBy,omitempty"`
}

func init() {
	t["VAppConfigSpec"] = reflect.TypeOf((*VAppConfigSpec)(nil)).Elem()
}

// This object type describes the behavior of an entity (virtual machine or
// sub-vApp container) in a vApp container.
//
// The auto-start/auto-stop configurations control the behavior of the
// start/stop vApp operations.
//
// An virtual machine entity can be configured to wait for a period of time before
// starting or to wait to receive a successful heartbeat from a virtual machine
// before starting the next virtual machine in the sequence.
//   - For a power-on operation, if waitForHeartbeat is true, then the power-on
//     sequence continues after the the first heartbeat has been received. If
//     waitingForGuest is false, the system waits for the specified delay and
//     then continues the power-on sequence.
//   - For a power-off operation, if delay is non-zero, the requested power-off
//     action is invoked (powerOff, suspend, guestShutdown) on the virtual
//     machine and the system waits until the number of seconds specified in the
//     delay have passed.
//
// If startAction and stopAction for an entity are both set to none, that
// entity does not participate in the sequence.
//
// The start/stop delay and waitingForGuest is not used if the entity is a
// vApp container. For a vApp the only value values for startAction is none
// or powerOn, and the valid values for stopAction is none or powerOff.
type VAppEntityConfigInfo struct {
	DynamicData

	// Entity to power on or power off.
	//
	// This can be a virtual machine or a vApp.
	//
	// Refers instance of `ManagedEntity`.
	Key *ManagedObjectReference `xml:"key,omitempty" json:"key,omitempty"`
	// Tag for entity.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Tag string `xml:"tag,omitempty" json:"tag,omitempty"`
	// Specifies the start order for this entity.
	//
	// Entities are started from lower
	// numbers to higher-numbers and reverse on shutdown. Multiple entities with the
	// same start-order can be started in parallel and the order is unspecified. This
	// value must be 0 or higher.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	StartOrder int32 `xml:"startOrder,omitempty" json:"startOrder,omitempty"`
	// Delay in seconds before continuing with the next entity in the order of entities
	// to be started.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	StartDelay int32 `xml:"startDelay,omitempty" json:"startDelay,omitempty"`
	// Determines if the virtual machine should start after receiving a heartbeat,
	// from the guest.
	//
	// When a virtual machine is next in the start
	// order, the system either waits a specified period of time for a virtual
	// machine to power on or it waits until it receives a successful heartbeat from a
	// powered on virtual machine. By default, this is set to false.
	//
	// This property has no effect for vApps.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	WaitingForGuest *bool `xml:"waitingForGuest" json:"waitingForGuest,omitempty"`
	// How to start the entity.
	//
	// Valid settings are none or powerOn. If set to none, then
	// the entity does not participate in auto-start.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	StartAction string `xml:"startAction,omitempty" json:"startAction,omitempty"`
	// Delay in seconds before continuing with the next entity in the order
	// sequence.
	//
	// This is only used if the stopAction is guestShutdown.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	StopDelay int32 `xml:"stopDelay,omitempty" json:"stopDelay,omitempty"`
	// Defines the stop action for the entity.
	//
	// Can be set to none, powerOff,
	// guestShutdown, or suspend. If set to none, then the entity does not participate in
	// auto-stop.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	StopAction string `xml:"stopAction,omitempty" json:"stopAction,omitempty"`
	// Deprecated as of vSphere API 5.1.
	//
	// Whether the entity should be removed, when this vApp is removed.
	//
	// This is only set for linked children.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	DestroyWithParent *bool `xml:"destroyWithParent" json:"destroyWithParent,omitempty"`
}

func init() {
	t["VAppEntityConfigInfo"] = reflect.TypeOf((*VAppEntityConfigInfo)(nil)).Elem()
}

// The IPAssignmentInfo class specifies how the guest software gets
// configured with IP addresses, including protocol type (IPv4 or IPv6)
// and the life-time of those IP addresses.
//
// A vApp/virtual machine can either use DHCP to acquire an IP
// configuration, or it can acquire its IP configuration through the
// use of the vSphere platform using the OVF environment's properties.
// The latter is a known as OVF-environment-assigned IP configuration.
//
// Guest software can be constructed to support DHCP , OVF assigned
// IP configuration, or both. The supportedAssignmentScheme property
// lists the supported schemes. This is typically specified by the author
// of a vApp.
//
// The deployer / operator of a vApp, specifies what IP allocation
// policy should be used:
//   - Using DHCP, if the vApp and deployed network supports it
//   - Transient Assignment, if the vApp supports OVF-assigned IP
//     configuration and the network has an IP range configured.
//   - Fixed Assignment, if the vApp supports OVF-assigned IP
//     configuration.
//   - Fixed Allocated, if the vApp supports OVF-assigned IP
//     configuration and the network has an IP range configured.
//
// Transient and fixed assignment differs in the life time of the IP
// allocation. For transient, IP addresses are automatically assigned on
// power-on and released on power-off. For fixed, the IP
// addresses are explicitly specified by the deployer and does not change
// between a power-on/power-off.
// Fixed allocated is a hybrid of transient and fixed assignment. IP
// addresses are allocated at first power-on and remain allocated on power-off.
//
// The IPAssignment settings are global to a deployment. Thus, if a vApp or
// virtual machine is part of another vApp, then the settings are ignored,
// and the ones for the top-most vApp container is used.
type VAppIPAssignmentInfo struct {
	DynamicData

	// Specifies the IP allocation schemes supported by the guest software.
	//
	// When updating this field, an empty array will be interpreted as no changes.
	// An array of the form \[""\] will clear all settings. Otherwise, the supplied
	// value will overwrite the current setting.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	SupportedAllocationScheme []string `xml:"supportedAllocationScheme,omitempty" json:"supportedAllocationScheme,omitempty"`
	// Specifies how IP allocation should be managed by the VI platform.
	//
	// This is
	// typically specified by the deployer. The set of valid options for the policy
	// is based on the capabilities of the vApp software, as specified by the
	// supportedAllocationSchemes property.
	//
	// Reconfigure privilege: VApp.InstanceConfig
	IpAllocationPolicy string `xml:"ipAllocationPolicy,omitempty" json:"ipAllocationPolicy,omitempty"`
	// Specifies the IP protocols supported by the guest software.
	//
	// When updating this field, an empty array will be interpreted as no changes.
	// An array of the form \[""\] will clear all settings. Otherwise, the supplied
	// value will overwrite the current setting.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	SupportedIpProtocol []string `xml:"supportedIpProtocol,omitempty" json:"supportedIpProtocol,omitempty"`
	// Specifies the chosen IP protocol for this deployment.
	//
	// This must be one of the
	// values in the supportedIpProtocol field.
	//
	// Reconfigure privilege: VApp.InstanceConfig
	IpProtocol string `xml:"ipProtocol,omitempty" json:"ipProtocol,omitempty"`
}

func init() {
	t["VAppIPAssignmentInfo"] = reflect.TypeOf((*VAppIPAssignmentInfo)(nil)).Elem()
}

// A virtual machine in a vApp cannot be powered on unless the
// parent vApp is running.
type VAppNotRunning struct {
	VmConfigFault
}

func init() {
	t["VAppNotRunning"] = reflect.TypeOf((*VAppNotRunning)(nil)).Elem()
}

type VAppNotRunningFault VAppNotRunning

func init() {
	t["VAppNotRunningFault"] = reflect.TypeOf((*VAppNotRunningFault)(nil)).Elem()
}

// This fault is thrown when an operation is attempted on a target where
// a vApp operation is already in progress.
//
// E.g. when trying to move a
// virtual machine from a vApp that is being powered on.
type VAppOperationInProgress struct {
	RuntimeFault
}

func init() {
	t["VAppOperationInProgress"] = reflect.TypeOf((*VAppOperationInProgress)(nil)).Elem()
}

type VAppOperationInProgressFault VAppOperationInProgress

func init() {
	t["VAppOperationInProgressFault"] = reflect.TypeOf((*VAppOperationInProgressFault)(nil)).Elem()
}

// The OvfSection encapsulates uninterpreted meta-data sections in
// an OVF descriptor.
//
// When an OVF package is imported, non-required /
// non-interpreted sections will be stored as OvfSection object. During
// the creation of an OVF package, these sections will be placed in the
// OVF descriptor.
type VAppOvfSectionInfo struct {
	DynamicData

	// A unique key to identify a section.
	Key int32 `xml:"key,omitempty" json:"key,omitempty"`
	// The namespace for the value in xsi:type attribute.
	Namespace string `xml:"namespace,omitempty" json:"namespace,omitempty"`
	// The value of the xsi:type attribute not including the namespace prefix.
	Type string `xml:"type,omitempty" json:"type,omitempty"`
	// Whether this is a global envelope section
	AtEnvelopeLevel *bool `xml:"atEnvelopeLevel" json:"atEnvelopeLevel,omitempty"`
	// The XML fragment including the top-level &lt;Section...&gt; element.
	//
	// The
	// fragment is self-contained will all required namespace definitions.
	Contents string `xml:"contents,omitempty" json:"contents,omitempty"`
}

func init() {
	t["VAppOvfSectionInfo"] = reflect.TypeOf((*VAppOvfSectionInfo)(nil)).Elem()
}

// An incremental update to the OvfSection list.
type VAppOvfSectionSpec struct {
	ArrayUpdateSpec

	Info *VAppOvfSectionInfo `xml:"info,omitempty" json:"info,omitempty"`
}

func init() {
	t["VAppOvfSectionSpec"] = reflect.TypeOf((*VAppOvfSectionSpec)(nil)).Elem()
}

// Information that describes what product a vApp contains, for example,
// the software that is installed in the contained virtual machines.
type VAppProductInfo struct {
	DynamicData

	// A unique key for the product section
	Key int32 `xml:"key" json:"key"`
	// Class name for this attribute.
	//
	// Valid values for classId:
	// Any string except any white-space characters.
	ClassId string `xml:"classId,omitempty" json:"classId,omitempty"`
	// Class name for this attribute.
	//
	// Valid values for instanceId:
	// Any string except any white-space characters.
	InstanceId string `xml:"instanceId,omitempty" json:"instanceId,omitempty"`
	// Name of the product.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// Vendor of the product.
	Vendor string `xml:"vendor,omitempty" json:"vendor,omitempty"`
	// Short version of the product, for example, 1.0.
	Version string `xml:"version,omitempty" json:"version,omitempty"`
	// Full-version of the product, for example, 1.0-build 12323.
	FullVersion string `xml:"fullVersion,omitempty" json:"fullVersion,omitempty"`
	// URL to vendor homepage.
	VendorUrl string `xml:"vendorUrl,omitempty" json:"vendorUrl,omitempty"`
	// URL to product homepage.
	ProductUrl string `xml:"productUrl,omitempty" json:"productUrl,omitempty"`
	// URL to entry-point for application.
	//
	// This is often specified using
	// a macro, for example, http://${app.ip}/, where app.ip is a defined property
	// on the virtual machine or vApp container.
	AppUrl string `xml:"appUrl,omitempty" json:"appUrl,omitempty"`
}

func init() {
	t["VAppProductInfo"] = reflect.TypeOf((*VAppProductInfo)(nil)).Elem()
}

// An incremental update to the Product information list.
type VAppProductSpec struct {
	ArrayUpdateSpec

	Info *VAppProductInfo `xml:"info,omitempty" json:"info,omitempty"`
}

func init() {
	t["VAppProductSpec"] = reflect.TypeOf((*VAppProductSpec)(nil)).Elem()
}

// The base fault for all vApp property configuration issues
type VAppPropertyFault struct {
	VmConfigFault

	// The fully-qualified id of the property, including instance and class
	// identifiers.
	Id string `xml:"id" json:"id"`
	// The user-readable category
	Category string `xml:"category" json:"category"`
	// The user-readable label
	Label string `xml:"label" json:"label"`
	// The type specified for the property
	Type string `xml:"type" json:"type"`
	// The value of the property
	Value string `xml:"value" json:"value"`
}

func init() {
	t["VAppPropertyFault"] = reflect.TypeOf((*VAppPropertyFault)(nil)).Elem()
}

type VAppPropertyFaultFault BaseVAppPropertyFault

func init() {
	t["VAppPropertyFaultFault"] = reflect.TypeOf((*VAppPropertyFaultFault)(nil)).Elem()
}

// A vApp Property description, including deployment values
type VAppPropertyInfo struct {
	DynamicData

	// A unique integer key for the property.
	Key int32 `xml:"key" json:"key"`
	// class name for this property
	//
	// Valid values for classId:
	// Any string except any white-space characters
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	ClassId string `xml:"classId,omitempty" json:"classId,omitempty"`
	// class name for this property
	//
	// Valid values for instanceId:
	// Any string except any white-space characters
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	InstanceId string `xml:"instanceId,omitempty" json:"instanceId,omitempty"`
	// Name of property.
	//
	// In the OVF environment, the property is listed as
	// \[classId.\]id\[.instanceId\]. The \[classId.\]name\[.instanceId\] must be unique.
	//
	// This field cannot be empty for a property. Thus, it must be specified at creation
	// and cannot be set to the empty string.
	//
	// Valid values for id:
	// Any string except any white-space characters
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Id string `xml:"id,omitempty" json:"id,omitempty"`
	// A user-visible description the category the property belongs to.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Category string `xml:"category,omitempty" json:"category,omitempty"`
	// The display name for the property.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Label string `xml:"label,omitempty" json:"label,omitempty"`
	// Describes the valid format of the property.
	//
	// A type must be one of:
	//   - string : A generic string. Max length 65535 (64k).
	//   - string(x..) : A string with minimum character length x.
	//   - string(..y) : A string with maximum character length y.
	//   - string(x..y) : A string with minimum character length x and maximum
	//     character length y.
	//   - string\["choice1", "choice2", "choice3"\] : A set of choices. " inside a choice
	//     must be either \\" or ' e.g "start\\"middle\\"end" or "start'middle'end" and
	//     a \\ inside a string choice must be encoded as \\\\ e.g. "start\\\\end".
	//   - int : An integer value. Is semantically equivalent to
	//     int(-2147483648..2147483647) e.g. signed int32.
	//   - int(x..y): An integer value with a minimum size x and a maximum size y.
	//     For example int(0..255) is a number between 0 and 255 both incl. This is
	//     also a way to specify that the number must be a uint8. There is always a lower
	//     and lower bound. Max number of digits is 100 including any sign. If exported to OVF the
	//     value will be truncated to max of uint64 or int64.
	//   - real : IEEE 8-byte floating-point value.
	//   - real(x..y) : IEEE 8-byte floating-point value with a minimum size x and a
	//     maximum size y. For example real(-1.5..1.5) must be a number between -1.5 and 1.5.
	//     Because of the nature of float some conversions can truncate the value.
	//     Real must be encoded according to CIM:
	//     RealValue = \[ "+" | "-" } \*decimalDigit "." 1\*decimalDigit
	//     \[ ("e" | "E" ) \[ "+" | "-" \] 1\*decimalDigit \] \]
	//   - boolean : A boolean. The value can be True or False
	//   - password : A generic string. Max length 65535 (64k).
	//   - password(x..) : A string with minimum character length x.
	//   - password(..y) : A string with maximum character length y.
	//   - password(x..y) : A string with minimum character length x and maximum
	//     character length y.
	//   - ip : An IPv4 address in dot-decimal notation or an IPv6 address in
	//     colon-hexadecimal notation.
	//   - ip:network : An IP address in dot-notation (IPv4) and colon-hexadecimal (IPv6)
	//     on a particular network. The behavior of this type depends on the
	//     ipAllocationPolicy. See below.
	//   - expression: The default value specifies an expression that is calculated
	//     by the system.
	//
	// For properties of type 'password', the value field and default value field will
	// always be returned as an empty string when queried. Thus, it is a write-only property.
	// Typically, a client application will also render these as a text field with hidden
	// text and double prompting.
	//
	// An expression follows the general patterns of either ${arg} or ${cmd:arg}. The
	// list of supported expressions are listed below:
	//   - ${&lt;name&gt;} : This expression evaluates to the same value as the named
	//     property in the parent vApp. A parent vApp is the
	//     first vApp in the ancestry chain (resource pools are
	//     skipped). If no parent vApp exists or the property is
	//     not defined on the parent vApp, the expression
	//     evaluates to the empty value.
	//   - ${subnet:&lt;network&gt;} : The subnet value of the given network.
	//   - ${netmask:&lt;network&gt;} : The netmask value of the given network.
	//   - ${gateway:&lt;network&gt;} : The gateway value of the given network.
	//   - ${autoIp:&lt;network&gt;} : An auto-assigned network address on the given
	//     network
	//   - ${net:&lt;network&gt;} : The name of the network
	//   - ${domainName:&lt;network&gt;} : The DNS domain name, e.g., vmware.com, of
	//     the given network.
	//   - ${searchPath:&lt;network&gt;} : The DNS search path, e.g.,
	//     eng.vmware.com;vmware.com, of the given
	//     network.
	//   - ${hostPrefix:&lt;network&gt;}: The host prefix on a given network, e.g.,
	//     "voe-"
	//   - ${dns:network}: A comma-separated string of configured network addresses
	//   - ${httpProxy:network}: The hostname:port for a proxy on the network
	//   - ${vimIp:} : The IP address of the VIM API provider server. This would
	//     typical be an ESX Server or VirtualCenter Server.
	//
	// A vApp will fail to start if any of the properties cannot be computed. For
	// example, if a property reference a gateway on a network, for which is has not
	// been specified. The value of the computed computation is assigned to the 'value'
	// field upon start of the vApp or virtual machine. The value is cleared once
	// the vApp or virtual machine is not-running.
	//
	// The system provides three ways of specifying IP addresses:
	//   - ip,
	//   - ip:network type,
	//   - ${ip:network} expression.
	//
	// The _ip_ types are typically used to specify an IP addressed to an
	// external system. Thus, these are not used by a virtual ethernet adapter
	// within the guest itself. Both the ip:network expression and the ${ip:network}
	// expression are intended as a way to obtain an IP address for a virtual machine
	// in a vApp.
	//
	// The behavior of ip:network type is controlled by the ipAssignPolicy, as
	// described in the following table:
	// <table>
	// <tr>
	// <td>`*Policy*`</td>
	// <td>ip:&lt;network&gt; type</td>
	// </tr>
	// <tr>
	// <td>DHCP</td>
	// <td>The user is not prompted to enter a value. The variable is set to the
	// empty string during power-on, and later updated with the IP value reported
	// by the guest software.
	// </td>
	// </tr>
	// <tr>
	// <td>Transient</td>
	// <td>The user is not prompted to enter a value. An IP address is allocated by
	// the platform and is assigned to the variable which is available to the
	// guest. The IP address is released at power-off.</td>
	// </tr>
	// <tr>
	// <td>Fixed</td>
	// <td>The user is prompted to enter a value. This value is available to the
	// guest.</td>
	// </tr>
	// <tr>
	// <td>Fixed Allocated</td>
	// <td>The user is not prompted to enter a value. An IP address is allocated by
	// the platform and is assigned to the variable which is available to the
	// guest. The IP address remains allocated at power-off, and are only
	// released if the property is deleted or the vApp is destroyed.</td>
	// </tr>
	// </table>
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Type string `xml:"type,omitempty" json:"type,omitempty"`
	// Contains extra configuration data depending on the property type.
	//
	// For types that
	// refer to network names the type reference is the managed object reference
	// of the network.
	TypeReference string `xml:"typeReference,omitempty" json:"typeReference,omitempty"`
	// Whether the property is user-configurable or a system property.
	//
	// This is not used
	// if the type is expression.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	UserConfigurable *bool `xml:"userConfigurable" json:"userConfigurable,omitempty"`
	// This either contains the default value of a field (used if value is empty
	// string), or the expression if the type is "expression".
	//
	// See comment for the
	DefaultValue string `xml:"defaultValue,omitempty" json:"defaultValue,omitempty"`
	// The value of the field at deployment time.
	//
	// For expressions, this will contain
	// the value that has been computed.
	//
	// Reconfigure privilege: VApp.InstanceConfig
	Value string `xml:"value,omitempty" json:"value,omitempty"`
	// A description of the field.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Description string `xml:"description,omitempty" json:"description,omitempty"`
}

func init() {
	t["VAppPropertyInfo"] = reflect.TypeOf((*VAppPropertyInfo)(nil)).Elem()
}

// An incremental update to the Property list.
type VAppPropertySpec struct {
	ArrayUpdateSpec

	Info *VAppPropertyInfo `xml:"info,omitempty" json:"info,omitempty"`
}

func init() {
	t["VAppPropertySpec"] = reflect.TypeOf((*VAppPropertySpec)(nil)).Elem()
}

// A specialized TaskInProgress when an operation is performed
// on a VM and it is failed due to a vApp-level operation
// is in progress.
//
// For example, while the power-on sequence is
// executed on a vApp, individual power-on's of child VMs are
// failed.
type VAppTaskInProgress struct {
	TaskInProgress
}

func init() {
	t["VAppTaskInProgress"] = reflect.TypeOf((*VAppTaskInProgress)(nil)).Elem()
}

type VAppTaskInProgressFault VAppTaskInProgress

func init() {
	t["VAppTaskInProgressFault"] = reflect.TypeOf((*VAppTaskInProgressFault)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.VCenterUpdateVStorageObjectMetadataEx_Task`.
type VCenterUpdateVStorageObjectMetadataExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore to query for the virtual storage objects.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// array of key/value strings. (keys must be unique
	// within the list)
	Metadata []KeyValue `xml:"metadata,omitempty" json:"metadata,omitempty"`
	// array of keys need to be deleted
	DeleteKeys []string `xml:"deleteKeys,omitempty" json:"deleteKeys,omitempty"`
}

func init() {
	t["VCenterUpdateVStorageObjectMetadataExRequestType"] = reflect.TypeOf((*VCenterUpdateVStorageObjectMetadataExRequestType)(nil)).Elem()
	minAPIVersionForType["VCenterUpdateVStorageObjectMetadataExRequestType"] = "7.0.2.0"
}

type VCenterUpdateVStorageObjectMetadataEx_Task VCenterUpdateVStorageObjectMetadataExRequestType

func init() {
	t["VCenterUpdateVStorageObjectMetadataEx_Task"] = reflect.TypeOf((*VCenterUpdateVStorageObjectMetadataEx_Task)(nil)).Elem()
}

type VCenterUpdateVStorageObjectMetadataEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// VFlash cache hot-configuration on a VMDK is not supported.
type VFlashCacheHotConfigNotSupported struct {
	VmConfigFault
}

func init() {
	t["VFlashCacheHotConfigNotSupported"] = reflect.TypeOf((*VFlashCacheHotConfigNotSupported)(nil)).Elem()
}

type VFlashCacheHotConfigNotSupportedFault VFlashCacheHotConfigNotSupported

func init() {
	t["VFlashCacheHotConfigNotSupportedFault"] = reflect.TypeOf((*VFlashCacheHotConfigNotSupportedFault)(nil)).Elem()
}

// vFlash module is not supported due to its configuration is not
// supported by the host.
type VFlashModuleNotSupported struct {
	VmConfigFault

	// VM name
	VmName string `xml:"vmName" json:"vmName"`
	// The vFlash module name.
	ModuleName string `xml:"moduleName" json:"moduleName"`
	// Message of reason.
	Reason string `xml:"reason" json:"reason"`
	// Host name
	HostName string `xml:"hostName" json:"hostName"`
}

func init() {
	t["VFlashModuleNotSupported"] = reflect.TypeOf((*VFlashModuleNotSupported)(nil)).Elem()
}

type VFlashModuleNotSupportedFault VFlashModuleNotSupported

func init() {
	t["VFlashModuleNotSupportedFault"] = reflect.TypeOf((*VFlashModuleNotSupportedFault)(nil)).Elem()
}

// The vFlash module version of the vFlash cache asscociated with the
// virtual disk of a VM is not compatible with the supported versions of
// the specified vFlash module on the host.
type VFlashModuleVersionIncompatible struct {
	VimFault

	// The vFlash module name.
	ModuleName string `xml:"moduleName" json:"moduleName"`
	// The VM request module version.
	VmRequestModuleVersion string `xml:"vmRequestModuleVersion" json:"vmRequestModuleVersion"`
	// The minimum supported version of the specified module on the host.
	HostMinSupportedVerson string `xml:"hostMinSupportedVerson" json:"hostMinSupportedVerson"`
	// The verson of the specified module on the host.
	HostModuleVersion string `xml:"hostModuleVersion" json:"hostModuleVersion"`
}

func init() {
	t["VFlashModuleVersionIncompatible"] = reflect.TypeOf((*VFlashModuleVersionIncompatible)(nil)).Elem()
}

type VFlashModuleVersionIncompatibleFault VFlashModuleVersionIncompatible

func init() {
	t["VFlashModuleVersionIncompatibleFault"] = reflect.TypeOf((*VFlashModuleVersionIncompatibleFault)(nil)).Elem()
}

// This event records when a VMFS datastore is created.
type VMFSDatastoreCreatedEvent struct {
	HostEvent

	// The associated datastore.
	Datastore DatastoreEventArgument `xml:"datastore" json:"datastore"`
	// Url of the associated datastore.
	DatastoreUrl string `xml:"datastoreUrl,omitempty" json:"datastoreUrl,omitempty"`
}

func init() {
	t["VMFSDatastoreCreatedEvent"] = reflect.TypeOf((*VMFSDatastoreCreatedEvent)(nil)).Elem()
}

// This event records when a datastore is expanded.
type VMFSDatastoreExpandedEvent struct {
	HostEvent

	// The associated datastore.
	Datastore DatastoreEventArgument `xml:"datastore" json:"datastore"`
}

func init() {
	t["VMFSDatastoreExpandedEvent"] = reflect.TypeOf((*VMFSDatastoreExpandedEvent)(nil)).Elem()
}

// This event records when a datastore is extended.
type VMFSDatastoreExtendedEvent struct {
	HostEvent

	// The associated datastore.
	Datastore DatastoreEventArgument `xml:"datastore" json:"datastore"`
}

func init() {
	t["VMFSDatastoreExtendedEvent"] = reflect.TypeOf((*VMFSDatastoreExtendedEvent)(nil)).Elem()
}

// The virtual machine is configured to use a VMI ROM, which is not
// supported on the host.
type VMINotSupported struct {
	DeviceNotSupported
}

func init() {
	t["VMINotSupported"] = reflect.TypeOf((*VMINotSupported)(nil)).Elem()
}

type VMINotSupportedFault VMINotSupported

func init() {
	t["VMINotSupportedFault"] = reflect.TypeOf((*VMINotSupportedFault)(nil)).Elem()
}

// The virtual machine is using a conflict DVPort, which is a temporary port created
// to avoid conflict with another port.
//
// Conflict DVPort cannot be moved.
type VMOnConflictDVPort struct {
	CannotAccessNetwork
}

func init() {
	t["VMOnConflictDVPort"] = reflect.TypeOf((*VMOnConflictDVPort)(nil)).Elem()
}

type VMOnConflictDVPortFault VMOnConflictDVPort

func init() {
	t["VMOnConflictDVPortFault"] = reflect.TypeOf((*VMOnConflictDVPortFault)(nil)).Elem()
}

// The virtual machine is using a "virtual intranet", a virtual network
// that exists only within a single host.
//
// If returned as part of a migration check, this
// is an error if the virtual machine is currently connected to the network and a
// warning otherwise.
type VMOnVirtualIntranet struct {
	CannotAccessNetwork
}

func init() {
	t["VMOnVirtualIntranet"] = reflect.TypeOf((*VMOnVirtualIntranet)(nil)).Elem()
}

type VMOnVirtualIntranetFault VMOnVirtualIntranet

func init() {
	t["VMOnVirtualIntranetFault"] = reflect.TypeOf((*VMOnVirtualIntranetFault)(nil)).Elem()
}

// An operation on a powered-on virtual machine requests a change of
// networks, but the host does not have that capability.
type VMotionAcrossNetworkNotSupported struct {
	MigrationFeatureNotSupported
}

func init() {
	t["VMotionAcrossNetworkNotSupported"] = reflect.TypeOf((*VMotionAcrossNetworkNotSupported)(nil)).Elem()
}

type VMotionAcrossNetworkNotSupportedFault VMotionAcrossNetworkNotSupported

func init() {
	t["VMotionAcrossNetworkNotSupportedFault"] = reflect.TypeOf((*VMotionAcrossNetworkNotSupportedFault)(nil)).Elem()
}

// A VMotion interface has a problem.
//
// This may be an error or warning depending
// on the specific fault subclass. This is an error or warning only when
// migrating a powered-on virtual machine.
type VMotionInterfaceIssue struct {
	MigrationFault

	// Whether this error is for the source host.
	AtSourceHost bool `xml:"atSourceHost" json:"atSourceHost"`
	// The name of the host with the bad interface.
	FailedHost string `xml:"failedHost" json:"failedHost"`
	// The host with the bad interface.
	//
	// Refers instance of `HostSystem`.
	FailedHostEntity *ManagedObjectReference `xml:"failedHostEntity,omitempty" json:"failedHostEntity,omitempty"`
}

func init() {
	t["VMotionInterfaceIssue"] = reflect.TypeOf((*VMotionInterfaceIssue)(nil)).Elem()
}

type VMotionInterfaceIssueFault BaseVMotionInterfaceIssue

func init() {
	t["VMotionInterfaceIssueFault"] = reflect.TypeOf((*VMotionInterfaceIssueFault)(nil)).Elem()
}

// This event records an expired VMotion license.
type VMotionLicenseExpiredEvent struct {
	LicenseEvent
}

func init() {
	t["VMotionLicenseExpiredEvent"] = reflect.TypeOf((*VMotionLicenseExpiredEvent)(nil)).Elem()
}

// The VMotion interface does not have the recommended capacity to support
// VMotion.
//
// VMotion is supported on links that have a speed of at least 1000
// Mbps and are full duplex. This is a warning for migrating powered-on virtual
// machines.
type VMotionLinkCapacityLow struct {
	VMotionInterfaceIssue

	// Name of the network being used for the VMotion interface.
	Network string `xml:"network" json:"network"`
}

func init() {
	t["VMotionLinkCapacityLow"] = reflect.TypeOf((*VMotionLinkCapacityLow)(nil)).Elem()
}

type VMotionLinkCapacityLowFault VMotionLinkCapacityLow

func init() {
	t["VMotionLinkCapacityLowFault"] = reflect.TypeOf((*VMotionLinkCapacityLowFault)(nil)).Elem()
}

// The VMotion interface does not have any operational physical links
// associated with it.
//
// This is an error for migrating powered-on virtual
// machines.
type VMotionLinkDown struct {
	VMotionInterfaceIssue

	// Name of the network being used for the VMotion interface.
	Network string `xml:"network" json:"network"`
}

func init() {
	t["VMotionLinkDown"] = reflect.TypeOf((*VMotionLinkDown)(nil)).Elem()
}

type VMotionLinkDownFault VMotionLinkDown

func init() {
	t["VMotionLinkDownFault"] = reflect.TypeOf((*VMotionLinkDownFault)(nil)).Elem()
}

// A VMotion interface is not configured (or is misconfigured) on
// either the source or destination host.
//
// This is an error only
// when migrating a powered-on virtual machine.
type VMotionNotConfigured struct {
	VMotionInterfaceIssue
}

func init() {
	t["VMotionNotConfigured"] = reflect.TypeOf((*VMotionNotConfigured)(nil)).Elem()
}

type VMotionNotConfiguredFault VMotionNotConfigured

func init() {
	t["VMotionNotConfiguredFault"] = reflect.TypeOf((*VMotionNotConfiguredFault)(nil)).Elem()
}

// VMotion is not licensed on a source or destination host.
//
// It must be licensed on both
// hosts.
type VMotionNotLicensed struct {
	VMotionInterfaceIssue
}

func init() {
	t["VMotionNotLicensed"] = reflect.TypeOf((*VMotionNotLicensed)(nil)).Elem()
}

type VMotionNotLicensedFault VMotionNotLicensed

func init() {
	t["VMotionNotLicensedFault"] = reflect.TypeOf((*VMotionNotLicensedFault)(nil)).Elem()
}

// The source or the destination host does not support VMotion.
//
// This is an
// error only when migrating a powered-on virtual machine.
type VMotionNotSupported struct {
	VMotionInterfaceIssue
}

func init() {
	t["VMotionNotSupported"] = reflect.TypeOf((*VMotionNotSupported)(nil)).Elem()
}

type VMotionNotSupportedFault VMotionNotSupported

func init() {
	t["VMotionNotSupportedFault"] = reflect.TypeOf((*VMotionNotSupportedFault)(nil)).Elem()
}

// VMotion protocol version incompatibility prevents VMotion from the
// virtual machine's current host to the requested destination host.
//
// (VMotion in the other direction may or may not be supported.)
type VMotionProtocolIncompatible struct {
	MigrationFault
}

func init() {
	t["VMotionProtocolIncompatible"] = reflect.TypeOf((*VMotionProtocolIncompatible)(nil)).Elem()
}

type VMotionProtocolIncompatibleFault VMotionProtocolIncompatible

func init() {
	t["VMotionProtocolIncompatibleFault"] = reflect.TypeOf((*VMotionProtocolIncompatibleFault)(nil)).Elem()
}

// This class defines the VMware specific configuration for
// DistributedVirtualSwitch.
type VMwareDVSConfigInfo struct {
	DVSConfigInfo

	// The Distributed Port Mirroring sessions in the switch.
	VspanSession []VMwareVspanSession `xml:"vspanSession,omitempty" json:"vspanSession,omitempty"`
	// The PVLAN configured in the switch.
	PvlanConfig []VMwareDVSPvlanMapEntry `xml:"pvlanConfig,omitempty" json:"pvlanConfig,omitempty"`
	// The maximum MTU in the switch.
	MaxMtu int32 `xml:"maxMtu" json:"maxMtu"`
	// See `LinkDiscoveryProtocolConfig`.
	LinkDiscoveryProtocolConfig *LinkDiscoveryProtocolConfig `xml:"linkDiscoveryProtocolConfig,omitempty" json:"linkDiscoveryProtocolConfig,omitempty"`
	// Configuration for ipfix monitoring of the switch traffic.
	//
	// This must be
	// set before ipfix monitoring can be enabled for the switch, or for any
	// portgroup or port of the switch.
	//
	// See also `VMwareDVSPortSetting.ipfixEnabled`.
	IpfixConfig *VMwareIpfixConfig `xml:"ipfixConfig,omitempty" json:"ipfixConfig,omitempty"`
	// The Link Aggregation Control Protocol groups in the switch.
	LacpGroupConfig []VMwareDvsLacpGroupConfig `xml:"lacpGroupConfig,omitempty" json:"lacpGroupConfig,omitempty"`
	// The Link Aggregation Control Protocol group version in the switch.
	//
	// See `VMwareDvsLacpApiVersion_enum` for valid values.
	LacpApiVersion string `xml:"lacpApiVersion,omitempty" json:"lacpApiVersion,omitempty"`
	// The Multicast Filtering mode in the switch.
	//
	// See `VMwareDvsMulticastFilteringMode_enum` for valid values.
	MulticastFilteringMode string `xml:"multicastFilteringMode,omitempty" json:"multicastFilteringMode,omitempty"`
	// Indicate the ID of NetworkOffloadSpec used in the switch.
	//
	// ID "None" means that network offload is not allowed in the switch.
	NetworkOffloadSpecId string `xml:"networkOffloadSpecId,omitempty" json:"networkOffloadSpecId,omitempty" vim:"8.0.0.1"`
	// The network offload specific configuration of the switch.
	//
	// It is only set when network offload is allowed
	// (`VMwareDVSConfigInfo.networkOffloadSpecId`
	// is not "None").
	NetworkOffloadConfig *VmwareDistributedVirtualSwitchNetworkOffloadConfig `xml:"networkOffloadConfig,omitempty" json:"networkOffloadConfig,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["VMwareDVSConfigInfo"] = reflect.TypeOf((*VMwareDVSConfigInfo)(nil)).Elem()
}

// This class defines the VMware specific configuration for
// DistributedVirtualSwitch.
type VMwareDVSConfigSpec struct {
	DVSConfigSpec

	// The PVLAN configuration specification.
	//
	// A `VMwareDVSPvlanMapEntry`
	// that has the same value for
	// `VMwareDVSPvlanMapEntry.primaryVlanId` and
	// `VMwareDVSPvlanMapEntry.secondaryVlanId`
	// is referred to as a primary PVLAN entry.
	// Otherwise, the `VMwareDVSPvlanMapEntry`
	// is referred to as a secondary PVLAN entry.
	//
	// The `VMwareDVSPvlanMapEntry.pvlanType`
	// of a primary PVLAN entry must be
	// `promiscuous`.
	// A secondary PVLAN entry can have a
	// `VMwareDVSPvlanMapEntry.pvlanType`
	// of either
	// `community` or
	// `isolated`.
	//
	// Primary PVLAN entries must be explicitly added.
	// If there is no primary PVLAN entry corresponding to the
	// `VMwareDVSPvlanMapEntry.primaryVlanId`
	// of a secondary PVLAN entry, a fault is thrown.
	//
	// While deleting a primary PVLAN entry, any associated secondary PVLAN
	// entries must be explicitly deleted.
	PvlanConfigSpec []VMwareDVSPvlanConfigSpec `xml:"pvlanConfigSpec,omitempty" json:"pvlanConfigSpec,omitempty"`
	// The Distributed Port Mirroring configuration specification.
	//
	// The VSPAN
	// sessions in the array cannot be of the same key.
	VspanConfigSpec []VMwareDVSVspanConfigSpec `xml:"vspanConfigSpec,omitempty" json:"vspanConfigSpec,omitempty"`
	// The maximum MTU in the switch.
	MaxMtu int32 `xml:"maxMtu,omitempty" json:"maxMtu,omitempty"`
	// See `LinkDiscoveryProtocolConfig`.
	LinkDiscoveryProtocolConfig *LinkDiscoveryProtocolConfig `xml:"linkDiscoveryProtocolConfig,omitempty" json:"linkDiscoveryProtocolConfig,omitempty"`
	// Configuration for ipfix monitoring of the switch traffic.
	//
	// This must be
	// set before ipfix monitoring can be enabled for the switch, or for any
	// portgroup or port of the switch.
	//
	// See also `VMwareDVSPortSetting.ipfixEnabled`.
	IpfixConfig *VMwareIpfixConfig `xml:"ipfixConfig,omitempty" json:"ipfixConfig,omitempty"`
	// The Link Aggregation Control Protocol group version in the switch.
	//
	// See `VMwareDvsLacpApiVersion_enum` for valid values.
	LacpApiVersion string `xml:"lacpApiVersion,omitempty" json:"lacpApiVersion,omitempty"`
	// The Multicast Filtering mode in the switch.
	//
	// See `VMwareDvsMulticastFilteringMode_enum` for valid values.
	MulticastFilteringMode string `xml:"multicastFilteringMode,omitempty" json:"multicastFilteringMode,omitempty"`
	// Indicate the ID of NetworkOffloadSpec used in the switch.
	//
	// Unset it when network offload is not allowed when creating a switch.
	// Use ID "None" to change network offload from allowed to not allowed.
	NetworkOffloadSpecId string `xml:"networkOffloadSpecId,omitempty" json:"networkOffloadSpecId,omitempty" vim:"8.0.0.1"`
	// The network offload specific configuration of the switch.
	//
	// This can be set only when network offload is allowed
	// (`VMwareDVSConfigInfo.networkOffloadSpecId`
	// is not "None").
	NetworkOffloadConfig *VmwareDistributedVirtualSwitchNetworkOffloadConfig `xml:"networkOffloadConfig,omitempty" json:"networkOffloadConfig,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["VMwareDVSConfigSpec"] = reflect.TypeOf((*VMwareDVSConfigSpec)(nil)).Elem()
}

// Indicators of support for version-specific DVS features that are only
// available on a VMware-class switch.
type VMwareDVSFeatureCapability struct {
	DVSFeatureCapability

	// Flag to indicate whether vspan(DVMirror) is supported on the
	// vSphere Distributed Switch.
	//
	// Distributed Port Mirroring is supported in vSphere Distributed Switch Version 5.0 or later.
	VspanSupported *bool `xml:"vspanSupported" json:"vspanSupported,omitempty"`
	// Flag to indicate whether LLDP(Link Layer Discovery Protocol) is supported on the
	// vSphere Distributed Switch.
	//
	// LLDP is supported in vSphere Distributed Switch Version 5.0 or later.
	LldpSupported *bool `xml:"lldpSupported" json:"lldpSupported,omitempty"`
	// Deprecated as of vSphere API 6.0, use `VMwareDvsIpfixCapability`.
	//
	// Flag to indicate whether IPFIX(NetFlow) is supported on the
	// vSphere Distributed Switch.
	//
	// IPFIX is supported in vSphere Distributed Switch Version 5.0 or later.
	IpfixSupported *bool `xml:"ipfixSupported" json:"ipfixSupported,omitempty"`
	// The support for version-specific IPFIX(NetFlow).
	IpfixCapability *VMwareDvsIpfixCapability `xml:"ipfixCapability,omitempty" json:"ipfixCapability,omitempty"`
	// Flag to indicate whether multicast snooping(IGMP/MLD Snooping)
	// is supported on the vSphere Distributed Switch.
	//
	// IGMP/MLD Snooping is supported in vSphere Distributed Switch Version 6.0 or later.
	MulticastSnoopingSupported *bool `xml:"multicastSnoopingSupported" json:"multicastSnoopingSupported,omitempty"`
	// The support for version-specific Distributed Port Mirroring sessions.
	VspanCapability *VMwareDVSVspanCapability `xml:"vspanCapability,omitempty" json:"vspanCapability,omitempty"`
	// The support for version-specific Link Aggregation Control Protocol.
	LacpCapability *VMwareDvsLacpCapability `xml:"lacpCapability,omitempty" json:"lacpCapability,omitempty"`
	// The support for version-specific DPU(SmartNic).
	DpuCapability *VMwareDvsDpuCapability `xml:"dpuCapability,omitempty" json:"dpuCapability,omitempty" vim:"8.0.0.1"`
	// Flag to indicate whether NSX is supported on the
	// vSphere Distributed Switch.
	//
	// NSX is supported in vSphere Distributed Switch Version 7.0 or later.
	NsxSupported *bool `xml:"nsxSupported" json:"nsxSupported,omitempty"`
	// The support for version-specific supported MTU.
	MtuCapability *VMwareDvsMtuCapability `xml:"mtuCapability,omitempty" json:"mtuCapability,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["VMwareDVSFeatureCapability"] = reflect.TypeOf((*VMwareDVSFeatureCapability)(nil)).Elem()
}

// The feature capabilities of health check supported by the
// vSphere Distributed Switch
type VMwareDVSHealthCheckCapability struct {
	DVSHealthCheckCapability

	// Flag to indicate whether vlan/mtu health check is supported on the
	// vSphere Distributed Switch.
	VlanMtuSupported bool `xml:"vlanMtuSupported" json:"vlanMtuSupported"`
	// Flag to indicate whether teaming health check is supported on the
	// vSphere Distributed Switch.
	TeamingSupported bool `xml:"teamingSupported" json:"teamingSupported"`
}

func init() {
	t["VMwareDVSHealthCheckCapability"] = reflect.TypeOf((*VMwareDVSHealthCheckCapability)(nil)).Elem()
}

// This class defines health check configuration for
// VMware vSphere Distributed Switch.
type VMwareDVSHealthCheckConfig struct {
	DVSHealthCheckConfig
}

func init() {
	t["VMwareDVSHealthCheckConfig"] = reflect.TypeOf((*VMwareDVSHealthCheckConfig)(nil)).Elem()
}

// This class defines MTU health check result of an uplink port
// in the VMware vSphered Distributed Switch.
type VMwareDVSMtuHealthCheckResult struct {
	HostMemberUplinkHealthCheckResult

	// True if the MTU configured in the vSphere Distributed Switch is different from
	// the value configured in the Physical NIC, else false.
	//
	// If it is true,
	// MTU health check is stopped. In this case, `VMwareDVSMtuHealthCheckResult.vlanSupportSwitchMtu` and
	// `VMwareDVSMtuHealthCheckResult.vlanNotSupportSwitchMtu` will not have values.
	MtuMismatch bool `xml:"mtuMismatch" json:"mtuMismatch"`
	// The vlan's MTU setting on physical switch allows vSphere Distributed Switch
	// max MTU size packets passing.
	//
	// If the vlan is not a range, but a single Id,
	// both start and end have the same value with the single vlan Id.
	VlanSupportSwitchMtu []NumericRange `xml:"vlanSupportSwitchMtu,omitempty" json:"vlanSupportSwitchMtu,omitempty"`
	// The vlan's MTU setting on physical switch does not allow
	// vSphere Distributed Switch max MTU size packets passing.
	//
	// If the vlan is not a range, but a single Id,
	// both start and end have the same value with the single vlan Id.
	VlanNotSupportSwitchMtu []NumericRange `xml:"vlanNotSupportSwitchMtu,omitempty" json:"vlanNotSupportSwitchMtu,omitempty"`
}

func init() {
	t["VMwareDVSMtuHealthCheckResult"] = reflect.TypeOf((*VMwareDVSMtuHealthCheckResult)(nil)).Elem()
}

// This class defines the VMware specific configuration for
// DistributedVirtualPort.
type VMwareDVSPortSetting struct {
	DVPortSetting

	// The VLAN Specification of the port.
	Vlan BaseVmwareDistributedVirtualSwitchVlanSpec `xml:"vlan,omitempty,typeattr" json:"vlan,omitempty"`
	// Deprecated as of vSphere API 5.0.
	//
	// The Quality Of Service tagging of the port.
	QosTag *IntPolicy `xml:"qosTag,omitempty" json:"qosTag,omitempty"`
	// The uplink teaming policy.
	//
	// This property is ignored for uplink
	// ports.
	UplinkTeamingPolicy *VmwareUplinkPortTeamingPolicy `xml:"uplinkTeamingPolicy,omitempty" json:"uplinkTeamingPolicy,omitempty"`
	// Deprecated as of vSphere API 6.7, use
	// `DVSMacManagementPolicy`
	// instead to specify the security policy.
	//
	// The security policy.
	SecurityPolicy *DVSSecurityPolicy `xml:"securityPolicy,omitempty" json:"securityPolicy,omitempty"`
	// True if ipfix monitoring is enabled.
	//
	// To successfully enable ipfix
	// monitoring, the switch must have an assigned
	// *IP address*
	// and an appropriately populated
	// *ipfix configuration*
	// that specifies a collector IP address and port.
	IpfixEnabled *BoolPolicy `xml:"ipfixEnabled,omitempty" json:"ipfixEnabled,omitempty"`
	// If true, a copy of packets sent to the switch will always be forwarded to
	// an uplink in addition to the regular packet forwarded done by the switch.
	TxUplink *BoolPolicy `xml:"txUplink,omitempty" json:"txUplink,omitempty"`
	// Deprecated as of vSphere API 5.5, use
	// `VmwareDistributedVirtualSwitch.UpdateDVSLacpGroupConfig_Task` and
	// `VMwareDVSConfigInfo.lacpGroupConfig`
	// instead.
	//
	// Link Aggregation Control Protocol policy.
	//
	// This policy is ignored on non-uplink portgroups.
	// Setting this policy at port level is not supported.
	LacpPolicy *VMwareUplinkLacpPolicy `xml:"lacpPolicy,omitempty" json:"lacpPolicy,omitempty"`
	// The MAC learning policy.
	MacManagementPolicy *DVSMacManagementPolicy `xml:"macManagementPolicy,omitempty" json:"macManagementPolicy,omitempty"`
	// The VNI number of overlay logical switch, which is used by
	// NSX portgroup.
	VNI *IntPolicy `xml:"VNI,omitempty" json:"VNI,omitempty"`
}

func init() {
	t["VMwareDVSPortSetting"] = reflect.TypeOf((*VMwareDVSPortSetting)(nil)).Elem()
}

// This class defines the VMware specific configuration for
// DistributedVirtualPort.
type VMwareDVSPortgroupPolicy struct {
	DVPortgroupPolicy

	// Allow the setting of
	// `VmwareDistributedVirtualSwitchVlanIdSpec.vlanId`, trunk
	// `VmwareDistributedVirtualSwitchTrunkVlanSpec.vlanId`, or
	// `VmwareDistributedVirtualSwitchPvlanSpec.pvlanId`
	// for an individual port to override the setting in
	// `DVPortgroupConfigInfo.defaultPortConfig` of
	// a portgroup.
	VlanOverrideAllowed bool `xml:"vlanOverrideAllowed" json:"vlanOverrideAllowed"`
	// Allow the setting of
	// `VMwareDVSPortSetting.uplinkTeamingPolicy`
	// for an individual port to override the setting in
	// `DVPortgroupConfigInfo.defaultPortConfig` of
	// a portgroup.
	UplinkTeamingOverrideAllowed bool `xml:"uplinkTeamingOverrideAllowed" json:"uplinkTeamingOverrideAllowed"`
	// Deprecated as of vSphere API 6.7.1, use
	// `VMwareDVSPortgroupPolicy.macManagementOverrideAllowed` instead.
	//
	// Allow the setting of
	// `VMwareDVSPortSetting.securityPolicy`
	// for an individual port to override the setting in
	// `DVPortgroupConfigInfo.defaultPortConfig` of
	// a portgroup.
	SecurityPolicyOverrideAllowed bool `xml:"securityPolicyOverrideAllowed" json:"securityPolicyOverrideAllowed"`
	// Allow the setting of
	// `VMwareDVSPortSetting.ipfixEnabled`
	// for an individual port to override the setting in
	// `DVPortgroupConfigInfo.defaultPortConfig` of
	// a portgroup.
	IpfixOverrideAllowed *bool `xml:"ipfixOverrideAllowed" json:"ipfixOverrideAllowed,omitempty"`
	// Allow the setting of
	// `VMwareDVSPortSetting.macManagementPolicy`
	// for an individual port to override the setting in
	// `DVPortgroupConfigInfo.defaultPortConfig` of
	// a portgroup.
	MacManagementOverrideAllowed *bool `xml:"macManagementOverrideAllowed" json:"macManagementOverrideAllowed,omitempty"`
}

func init() {
	t["VMwareDVSPortgroupPolicy"] = reflect.TypeOf((*VMwareDVSPortgroupPolicy)(nil)).Elem()
}

// This class defines the configuration of a PVLAN map entry
type VMwareDVSPvlanConfigSpec struct {
	DynamicData

	// The PVLAN entry to be added or removed.
	PvlanEntry VMwareDVSPvlanMapEntry `xml:"pvlanEntry" json:"pvlanEntry"`
	// Operation type.
	//
	// See
	// `ConfigSpecOperation_enum` for valid values,
	// except for the "edit" value, which is not supported.
	Operation string `xml:"operation" json:"operation"`
}

func init() {
	t["VMwareDVSPvlanConfigSpec"] = reflect.TypeOf((*VMwareDVSPvlanConfigSpec)(nil)).Elem()
}

// The class represents a PVLAN id.
type VMwareDVSPvlanMapEntry struct {
	DynamicData

	// The primary VLAN ID.
	//
	// The VLAN IDs of 0 and 4095 are reserved
	// and cannot be used in this property.
	PrimaryVlanId int32 `xml:"primaryVlanId" json:"primaryVlanId"`
	// The secondary VLAN ID.
	//
	// The VLAN IDs of 0 and 4095 are reserved
	// and cannot be used in this property.
	SecondaryVlanId int32 `xml:"secondaryVlanId" json:"secondaryVlanId"`
	// The type of PVLAN.
	//
	// See `VmwareDistributedVirtualSwitchPvlanPortType_enum`
	// for valid values.
	PvlanType string `xml:"pvlanType" json:"pvlanType"`
}

func init() {
	t["VMwareDVSPvlanMapEntry"] = reflect.TypeOf((*VMwareDVSPvlanMapEntry)(nil)).Elem()
}

// This class defines the teaming health check configuration.
//
// Teaming health check is used to check whether the teaming policy configuration
// of the vSphere Distributed Switch matches the physical switch.
type VMwareDVSTeamingHealthCheckConfig struct {
	VMwareDVSHealthCheckConfig
}

func init() {
	t["VMwareDVSTeamingHealthCheckConfig"] = reflect.TypeOf((*VMwareDVSTeamingHealthCheckConfig)(nil)).Elem()
}

// This class defines teaming health check result of a host that
// joined the VMware vSphered Distributed Switch.
type VMwareDVSTeamingHealthCheckResult struct {
	HostMemberHealthCheckResult

	// Teaming check status.
	//
	// See `VMwareDVSTeamingMatchStatus_enum`
	// for valid values.
	TeamingStatus string `xml:"teamingStatus" json:"teamingStatus"`
}

func init() {
	t["VMwareDVSTeamingHealthCheckResult"] = reflect.TypeOf((*VMwareDVSTeamingHealthCheckResult)(nil)).Elem()
}

// This class defines Vlan health check result of an uplink port
// in the VMware vSphered Distributed Switch.
type VMwareDVSVlanHealthCheckResult struct {
	HostMemberUplinkHealthCheckResult

	// The vlans which are trunked by the physical switch connected to the uplink port.
	//
	// If the vlan is not a range, but a single Id,
	// both start and end have the same value with the single vlan Id.
	TrunkedVlan []NumericRange `xml:"trunkedVlan,omitempty" json:"trunkedVlan,omitempty"`
	// The vlans which are not trunked by the physical switch connected to the uplink port.
	//
	// If the vlan is not a range, but a single Id,
	// both start and end have the same value with the single vlan Id.
	UntrunkedVlan []NumericRange `xml:"untrunkedVlan,omitempty" json:"untrunkedVlan,omitempty"`
}

func init() {
	t["VMwareDVSVlanHealthCheckResult"] = reflect.TypeOf((*VMwareDVSVlanHealthCheckResult)(nil)).Elem()
}

// This class defines the vlan and mtu health check configuration.
//
// Vlan health check is used to check whether vlans are trunked by the physical
// switch connected to the uplink ports.
// MTU health check is used to verify current MTU setting workable on all uplink ports of
// the vSphere Distributed Switch.
type VMwareDVSVlanMtuHealthCheckConfig struct {
	VMwareDVSHealthCheckConfig
}

func init() {
	t["VMwareDVSVlanMtuHealthCheckConfig"] = reflect.TypeOf((*VMwareDVSVlanMtuHealthCheckConfig)(nil)).Elem()
}

// Indicators of support for version-specific Distributed Port Mirroring sessions.
type VMwareDVSVspanCapability struct {
	DynamicData

	// Flag to indicate whether mixed dest mirror session is supported on the
	// vSphere Distributed Switch.
	MixedDestSupported bool `xml:"mixedDestSupported" json:"mixedDestSupported"`
	// Flag to indicate whether dvport mirror session is supported on the
	// vSphere Distributed Switch.
	DvportSupported bool `xml:"dvportSupported" json:"dvportSupported"`
	// Flag to indicate whether remote mirror source session is supported on the
	// vSphere Distributed Switch.
	RemoteSourceSupported bool `xml:"remoteSourceSupported" json:"remoteSourceSupported"`
	// Flag to indicate whether remote mirror destination session is supported on the
	// vSphere Distributed Switch.
	RemoteDestSupported bool `xml:"remoteDestSupported" json:"remoteDestSupported"`
	// Flag to indicate whether encapsulated remote mirror source session is supported on the
	// vSphere Distributed Switch.
	EncapRemoteSourceSupported bool `xml:"encapRemoteSourceSupported" json:"encapRemoteSourceSupported"`
	// Flag to indicate whether ERSPAN protocol encapsulation is supported
	// on the vSphere Distributed Switch.
	ErspanProtocolSupported *bool `xml:"erspanProtocolSupported" json:"erspanProtocolSupported,omitempty"`
	// Flag to indicate whether dvport mirror can be configured to use a
	// dedicated network stack instance.
	MirrorNetstackSupported *bool `xml:"mirrorNetstackSupported" json:"mirrorNetstackSupported,omitempty"`
}

func init() {
	t["VMwareDVSVspanCapability"] = reflect.TypeOf((*VMwareDVSVspanCapability)(nil)).Elem()
}

// This class defines the configuration of a Distributed Port Mirroring session.
//
// A Distributed Port Mirroring session
type VMwareDVSVspanConfigSpec struct {
	DynamicData

	// The Distributed Port Mirroring session to be reconfigured.
	VspanSession VMwareVspanSession `xml:"vspanSession" json:"vspanSession"`
	// Operation type, see
	// `ConfigSpecOperation_enum` for valid values.
	Operation string `xml:"operation" json:"operation"`
}

func init() {
	t["VMwareDVSVspanConfigSpec"] = reflect.TypeOf((*VMwareDVSVspanConfigSpec)(nil)).Elem()
}

// The feature capabilities of Dpu Features supported by the
// vSphere Distributed Switch.
type VMwareDvsDpuCapability struct {
	DynamicData

	// Flag to indicate whether network offloading is supported on the
	// vSphere Distributed Switch.
	NetworkOffloadSupported *bool `xml:"networkOffloadSupported" json:"networkOffloadSupported,omitempty"`
	// Flag to indicate whether the vSphere Distributed Switch supports
	// connecting two DPUs to an offloading VDS and operating in an
	// active-standby mode.
	//
	// If not set, the feature is not supported.
	ActiveStandbyModeSupported *bool `xml:"activeStandbyModeSupported" json:"activeStandbyModeSupported,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["VMwareDvsDpuCapability"] = reflect.TypeOf((*VMwareDvsDpuCapability)(nil)).Elem()
	minAPIVersionForType["VMwareDvsDpuCapability"] = "8.0.0.1"
}

// The feature capabilities of Ipfix supported by the vSphere Distributed Switch.
type VMwareDvsIpfixCapability struct {
	DynamicData

	// Flag to indicate whether IPFIX(NetFlow) is supported on the
	// vSphere Distributed Switch.
	//
	// IPFIX is supported in vSphere Distributed Switch Version 5.0 or later.
	IpfixSupported *bool `xml:"ipfixSupported" json:"ipfixSupported,omitempty"`
	// Flag to indicate whether IPv6 for IPFIX(NetFlow) is supported on the
	// vSphere Distributed Switch.
	//
	// IPv6 for IPFIX is supported in vSphere Distributed Switch Version 6.0 or later.
	Ipv6ForIpfixSupported *bool `xml:"ipv6ForIpfixSupported" json:"ipv6ForIpfixSupported,omitempty"`
	// Flag to indicate whether Observation Domain Id for IPFIX is supported
	// on the vSphere Distributed Switch.
	//
	// Observation Domain Id is supported in vSphere Distributed Switch Version 6.0 or later.
	ObservationDomainIdSupported *bool `xml:"observationDomainIdSupported" json:"observationDomainIdSupported,omitempty"`
}

func init() {
	t["VMwareDvsIpfixCapability"] = reflect.TypeOf((*VMwareDvsIpfixCapability)(nil)).Elem()
}

// The feature capabilities of Link Aggregation Control Protocol supported by the
// vSphere Distributed Switch.
type VMwareDvsLacpCapability struct {
	DynamicData

	// Flag to indicate whether Link Aggregation Control Protocol is supported on the
	// vSphere Distributed Switch.
	LacpSupported *bool `xml:"lacpSupported" json:"lacpSupported,omitempty"`
	// Flag to indicate whether the vSphere Distributed Switch supports more
	// than one Link Aggregation Control Protocol group to be configured.
	//
	// It is suppported in vSphere Distributed Switch Version 5.5 or later.
	MultiLacpGroupSupported *bool `xml:"multiLacpGroupSupported" json:"multiLacpGroupSupported,omitempty"`
	// Flag to indicate whether LACP Fast Mode is supported on the
	// vSphere Distributed Switch.
	//
	// LACP Fast Mode is supported in vSphere Distributed Switch Version 7.0 or later.
	LacpFastModeSupported *bool `xml:"lacpFastModeSupported" json:"lacpFastModeSupported,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["VMwareDvsLacpCapability"] = reflect.TypeOf((*VMwareDvsLacpCapability)(nil)).Elem()
}

// This class defines VMware specific multiple IEEE 802.3ad
// Dynamic Link Aggregation Control Protocol groups.
type VMwareDvsLacpGroupConfig struct {
	DynamicData

	// The generated key as the identifier for the Link Aggregation group.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// The display name.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// The mode of Link Aggregation Control Protocol.
	//
	// See `VMwareUplinkLacpMode_enum` for valid values.
	Mode string `xml:"mode,omitempty" json:"mode,omitempty"`
	// The number of uplink ports.
	UplinkNum int32 `xml:"uplinkNum,omitempty" json:"uplinkNum,omitempty"`
	// Load balance policy.
	//
	// See `VMwareDvsLacpLoadBalanceAlgorithm_enum` for valid values.
	LoadbalanceAlgorithm string `xml:"loadbalanceAlgorithm,omitempty" json:"loadbalanceAlgorithm,omitempty"`
	// The VLAN Specification of the Uplink Ports in the Link Aggregation group.
	Vlan *VMwareDvsLagVlanConfig `xml:"vlan,omitempty" json:"vlan,omitempty"`
	// Ipfix configuration of the Link Aggregation
	// Control Protocol group.
	Ipfix *VMwareDvsLagIpfixConfig `xml:"ipfix,omitempty" json:"ipfix,omitempty"`
	// Names for the Uplink Ports in the group.
	//
	// This property is ignored in an update operation.
	UplinkName []string `xml:"uplinkName,omitempty" json:"uplinkName,omitempty"`
	// Keys for the Uplink Ports in the group.
	//
	// This property is ignored in an update operation.
	UplinkPortKey []string `xml:"uplinkPortKey,omitempty" json:"uplinkPortKey,omitempty"`
	// The timeout mode of LACP group.
	//
	// See `VMwareUplinkLacpTimeoutMode_enum` for valid values.
	TimeoutMode string `xml:"timeoutMode,omitempty" json:"timeoutMode,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["VMwareDvsLacpGroupConfig"] = reflect.TypeOf((*VMwareDvsLacpGroupConfig)(nil)).Elem()
}

// This class defines the configuration of a Link Aggregation
// Control Protocol group.
type VMwareDvsLacpGroupSpec struct {
	DynamicData

	// The Link Aggregation Control Protocol group to be configured.
	LacpGroupConfig VMwareDvsLacpGroupConfig `xml:"lacpGroupConfig" json:"lacpGroupConfig"`
	// Operation type, see
	// `ConfigSpecOperation_enum` for valid values.
	Operation string `xml:"operation" json:"operation"`
}

func init() {
	t["VMwareDvsLacpGroupSpec"] = reflect.TypeOf((*VMwareDvsLacpGroupSpec)(nil)).Elem()
}

// This class defines the ipfix configuration of the Link Aggregation
// Control Protocol group.
type VMwareDvsLagIpfixConfig struct {
	DynamicData

	// True if ipfix monitoring is enabled in the Link Aggregation Control Protocol group.
	//
	// If set, this property will override the ipfix configuration of Uplink Ports
	// in the Link Aggregation Control Protocol group.
	// Thus they are no longer inheriting ipfix configuration from their Uplink Port Group.
	// Setting this property would require
	// `VMwareDVSPortgroupPolicy.ipfixOverrideAllowed`
	// of all the Uplink Port Groups to be true,
	// otherwise ConflictingConfiguration fault will be raised.
	IpfixEnabled *bool `xml:"ipfixEnabled" json:"ipfixEnabled,omitempty"`
}

func init() {
	t["VMwareDvsLagIpfixConfig"] = reflect.TypeOf((*VMwareDvsLagIpfixConfig)(nil)).Elem()
}

// This class defines the vlan configuration of the Link Aggregation
// Control Protocol group.
type VMwareDvsLagVlanConfig struct {
	DynamicData

	// The VlanId range for the Uplink Ports in the Link Aggregation
	// Control Protocol group.
	//
	// The valid VlanId range is from 0 to 4094. Overlapping ranges are allowed.
	// If set, this property will override the VLAN configuration of Uplink Ports
	// in the Link Aggregation Control Protocol group.
	// Thus they are no longer inheriting VLAN configuration from their Uplink Port Group.
	// Setting this property would require
	// `VMwareDVSPortgroupPolicy.vlanOverrideAllowed`
	// of all the Uplink Port Groups to be true,
	// otherwise ConflictingConfiguration fault will be raised.
	VlanId []NumericRange `xml:"vlanId,omitempty" json:"vlanId,omitempty"`
}

func init() {
	t["VMwareDvsLagVlanConfig"] = reflect.TypeOf((*VMwareDvsLagVlanConfig)(nil)).Elem()
}

// Indicators of support for version-specific supported MTU.
type VMwareDvsMtuCapability struct {
	DynamicData

	// Minimum supported MTU on VDS.
	MinMtuSupported int32 `xml:"minMtuSupported" json:"minMtuSupported"`
	// Maximum supported MTU on VDS.
	MaxMtuSupported int32 `xml:"maxMtuSupported" json:"maxMtuSupported"`
}

func init() {
	t["VMwareDvsMtuCapability"] = reflect.TypeOf((*VMwareDvsMtuCapability)(nil)).Elem()
	minAPIVersionForType["VMwareDvsMtuCapability"] = "7.0.2.0"
}

// Configuration for IPFIX monitoring of distributed virtual switch traffic.
//
// IPFIX monitoring must be enabled to use this capability. See
// `VMwareDVSPortSetting*.*VMwareDVSPortSetting.ipfixEnabled`.
type VMwareIpfixConfig struct {
	DynamicData

	// IP address for the ipfix collector, using IPv4 or IPv6.
	//
	// IPv6 is supported in vSphere Distributed Switch Version 6.0 or later.
	// This must be set before ipfix monitoring can be enabled for the
	// switch, or for any portgroup or port of the switch.
	CollectorIpAddress string `xml:"collectorIpAddress,omitempty" json:"collectorIpAddress,omitempty"`
	// Port for the ipfix collector.
	//
	// This must be set before ipfix monitoring
	// can be enabled for the switch, or for any portgroup or port of the
	// switch. Legal value range is 0-65535.
	CollectorPort int32 `xml:"collectorPort,omitempty" json:"collectorPort,omitempty"`
	// Observation Domain Id for the ipfix collector.
	//
	// Observation Domain Id is supported
	// in vSphere Distributed Switch Version 6.0 or later.
	// Legal value range is 0-((2^32)-1)
	ObservationDomainId int64 `xml:"observationDomainId,omitempty" json:"observationDomainId,omitempty"`
	// The number of seconds after which "active" flows are forced to be
	// exported to the collector.
	//
	// Legal value range is 60-3600. Default: 60.
	ActiveFlowTimeout int32 `xml:"activeFlowTimeout" json:"activeFlowTimeout"`
	// The number of seconds after which "idle" flows are forced to be
	// exported to the collector.
	//
	// Legal value range is 10-600. Default: 15.
	IdleFlowTimeout int32 `xml:"idleFlowTimeout" json:"idleFlowTimeout"`
	// The ratio of total number of packets to the number of packets
	// analyzed.
	//
	// Set to 0 to disable sampling. Legal value range is 0-16384.
	// Default: 4096.
	SamplingRate int32 `xml:"samplingRate" json:"samplingRate"`
	// Whether to limit analysis to traffic that has both source and
	// destination served by the same host.
	//
	// Default: false.
	InternalFlowsOnly bool `xml:"internalFlowsOnly" json:"internalFlowsOnly"`
}

func init() {
	t["VMwareIpfixConfig"] = reflect.TypeOf((*VMwareIpfixConfig)(nil)).Elem()
}

// Deprecated as of vSphere API 5.5.
//
// This class defines VMware specific Link Aggregation Control Protocol
// policy.
type VMwareUplinkLacpPolicy struct {
	InheritablePolicy

	// The flag to indicate whether or not
	// Link Aggregation Control Protocol is enabled.
	//
	// It can be set to true if the value of
	// `VMwareDVSConfigInfo.lacpApiVersion`
	// is `singleLag`,
	// else an exception ConflictingConfiguration will be thrown.
	Enable *BoolPolicy `xml:"enable,omitempty" json:"enable,omitempty"`
	// The mode of Link Aggregation Control Protocol.
	//
	// See `VMwareUplinkLacpMode_enum` for valid values.
	Mode *StringPolicy `xml:"mode,omitempty" json:"mode,omitempty"`
}

func init() {
	t["VMwareUplinkLacpPolicy"] = reflect.TypeOf((*VMwareUplinkLacpPolicy)(nil)).Elem()
}

// This data object type describes uplink port ordering policy for a
// distributed virtual port.
//
// A uplink port can be in the active
// list, the standby list, or neither. It cannot be in both lists.
type VMwareUplinkPortOrderPolicy struct {
	InheritablePolicy

	// List of active uplink ports used for load balancing.
	ActiveUplinkPort []string `xml:"activeUplinkPort,omitempty" json:"activeUplinkPort,omitempty"`
	// Standby uplink ports used for failover.
	StandbyUplinkPort []string `xml:"standbyUplinkPort,omitempty" json:"standbyUplinkPort,omitempty"`
}

func init() {
	t["VMwareUplinkPortOrderPolicy"] = reflect.TypeOf((*VMwareUplinkPortOrderPolicy)(nil)).Elem()
}

// This class defines the ports, uplink ports name, vlans and IP addresses participating in a
// Distributed Port Mirroring session.
//
// See `VMwareVspanSession`.
type VMwareVspanPort struct {
	DynamicData

	// Individual ports to participate in the Distributed Port Mirroring session.
	PortKey []string `xml:"portKey,omitempty" json:"portKey,omitempty"`
	// Uplink ports used as destination ports to participate in the Distributed Port Mirroring session.
	//
	// A fault will be raised if uplinkPortName is used as source ports
	// in any Distributed Port Mirroring session.
	UplinkPortName []string `xml:"uplinkPortName,omitempty" json:"uplinkPortName,omitempty"`
	// Wild card specification for source ports participating in the Distributed Port Mirroring session.
	//
	// See `DistributedVirtualSwitchPortConnecteeConnecteeType_enum` for valid values.
	// Any port that has a connectee of the specified type has its receive traffic
	// mirrored. A fault will be raised if wildcards are specified as destination
	// ports or source ports mirroring traffic on the transmit side.
	// It is to be not used.
	WildcardPortConnecteeType []string `xml:"wildcardPortConnecteeType,omitempty" json:"wildcardPortConnecteeType,omitempty"`
	// Vlan Ids for ingress source of Remote Mirror destination
	// session.
	Vlans []int32 `xml:"vlans,omitempty" json:"vlans,omitempty"`
	// IP address for the destination of encapsulated remote mirror source session,
	// IPv4 address is specified using dotted decimal notation.
	//
	// For example, "192.0.2.1".
	// IPv6 addresses are 128-bit addresses represented as eight fields
	// of up to four hexadecimal digits.
	// A colon separates each field (:). For example,
	// 2001:DB8:101::230:6eff:fe04:d9ff.
	IpAddress []string `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
}

func init() {
	t["VMwareVspanPort"] = reflect.TypeOf((*VMwareVspanPort)(nil)).Elem()
}

// The `VMwareVspanSession` data object
// defines the configuration of a VLAN Services and Protocols for Advanced Networks
// (VSPAN) session.
//
// You use a VSPAN session for the following operations:
//   - To mirror network traffic (inbound/outbound) from a set of source
//     entities to a set of destination entities.
//   - To assist in troubleshooting.
//   - As input for security and other network analysis appliances.
//
// The type of entities that you can specify as source or destination is determined
// by the session type. You can use uplink distributed virtual ports only for
// mixed destination mirror VSPAN sessions (mixedDestMirror).
// For all sessions except mixedDestMirror sessions, you cannot
// use uplink distributed virtual ports as destination ports.
// sessionType is required for vSphere Distributed Switch 5.1 and later,
// ignored for prior version if set.
// <table>
// <thead>
// <tr>
// <th>Session Type</th>
// <th>Source</th>
// <th>Destination </th>
// </tr>
// </thead>
// <tbody>
// <tr>
// <td>mixedDestMirror</td>
// <td>Distributed Ports</td>
// <td>Distributed Ports + Uplink Ports Name</td>
// </tr>
// <tr>
// <td>dvPortMirror</td>
// <td>Distributed Ports</td>
// <td>Distributed Ports</td>
// </tr>
// <tr>
// <td>remoteMirrorSource</td>
// <td>Distributed Ports</td>
// <td>Uplink Ports Name</td>
// </tr>
// <tr>
// <td>remoteMirrorDest</td>
// <td>VLAN</td>
// <td>Distributed Ports</td>
// </tr>
// <tr>
// <td>encapRemoteMirrorSource</td>
// <td>Distributed Ports</td>
// <td>IP address</td>
// </tr>
// </tbody>
// </table>
type VMwareVspanSession struct {
	DynamicData

	// The generated key as the identifier for the session.
	Key string `xml:"key,omitempty" json:"key,omitempty"`
	// The display name.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// The description for the session.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// Whether the session is enabled.
	Enabled bool `xml:"enabled" json:"enabled"`
	// Source ports for which transmitted packets are mirrored.
	SourcePortTransmitted *VMwareVspanPort `xml:"sourcePortTransmitted,omitempty" json:"sourcePortTransmitted,omitempty"`
	// Source ports for which received packets are mirrored.
	SourcePortReceived *VMwareVspanPort `xml:"sourcePortReceived,omitempty" json:"sourcePortReceived,omitempty"`
	// Destination ports that received the mirrored packets.
	//
	// You cannot use wild card ports as destination ports. If `VMwareVspanPort.wildcardPortConnecteeType`
	// is set in the value, the reconfigure
	// operation will raise a fault. Also any port designated in the value of
	// this property can not match the wild card source port in any of the
	// Distributed Port Mirroring session.
	DestinationPort *VMwareVspanPort `xml:"destinationPort,omitempty" json:"destinationPort,omitempty"`
	// VLAN ID used to encapsulate the mirrored traffic.
	EncapsulationVlanId int32 `xml:"encapsulationVlanId,omitempty" json:"encapsulationVlanId,omitempty"`
	// Whether to strip the original VLAN tag.
	//
	// if false, the original VLAN tag
	// will be preserved on the mirrored traffic. If `VMwareVspanSession.encapsulationVlanId`
	// has been set and this property is false, the frames will be double tagged
	// with the original VLAN ID as the inner tag.
	StripOriginalVlan bool `xml:"stripOriginalVlan" json:"stripOriginalVlan"`
	// An integer that describes how much of each frame to mirror.
	//
	// If unset, all
	// of the frame would be mirrored. Setting this property to a smaller value
	// is useful when the consumer will look only at the headers.
	// The value cannot be less than 60.
	MirroredPacketLength int32 `xml:"mirroredPacketLength,omitempty" json:"mirroredPacketLength,omitempty"`
	// Whether or not destination ports can send and receive "normal" traffic.
	//
	// Setting this to false will make mirror ports be used solely for mirroring
	// and not double as normal access ports.
	NormalTrafficAllowed bool `xml:"normalTrafficAllowed" json:"normalTrafficAllowed"`
	// Type of the session.
	//
	// See
	// `VMwareDVSVspanSessionType_enum`
	// for valid values.
	// Default value is mixedDestMirror if unspecified in a VSPAN create operation.
	SessionType string `xml:"sessionType,omitempty" json:"sessionType,omitempty"`
	// Sampling rate of the session.
	//
	// If its value is n, one of every n
	// packets is mirrored.
	// Valid values are between 1 to 65535, and default value is 1.
	SamplingRate int32 `xml:"samplingRate,omitempty" json:"samplingRate,omitempty"`
	// Encapsulation type of the session.
	//
	// See
	// `VMwareDVSVspanSessionEncapType_enum`
	// for valid values.
	// Default value is encapProtocolGRE if unspecified in a
	// VSPAN create operation.
	EncapType string `xml:"encapType,omitempty" json:"encapType,omitempty"`
	// ERSPAN ID of the session.
	//
	// Valid values are between 0 to 0x3ff, and default value is 0.
	// This value is applicable only if encaptType is
	// `erspan2` or
	// `erspan3`
	ErspanId int32 `xml:"erspanId,omitempty" json:"erspanId,omitempty"`
	// Class of Service of the monitored frame.
	//
	// Valid values are between 0 to 7, and default value is 0.
	// This value is applicable only if encaptType is
	// `erspan2` or
	// `erspan3`
	ErspanCOS int32 `xml:"erspanCOS,omitempty" json:"erspanCOS,omitempty"`
	// Timestamp Granularity.
	//
	// If the value is false, timestamp-granularity will be microsecond.
	// Otherwise the timestamp-granularity will be nanosecond
	// This value is applicable only if encaptType is
	// `erspan3`
	ErspanGraNanosec *bool `xml:"erspanGraNanosec" json:"erspanGraNanosec,omitempty"`
	// Netstack instance of the session.
	Netstack string `xml:"netstack,omitempty" json:"netstack,omitempty"`
}

func init() {
	t["VMwareVspanSession"] = reflect.TypeOf((*VMwareVspanSession)(nil)).Elem()
}

// This data object type describes a virtual storage object.
type VStorageObject struct {
	DynamicData

	// Virtual storage object configuration
	Config VStorageObjectConfigInfo `xml:"config" json:"config"`
}

func init() {
	t["VStorageObject"] = reflect.TypeOf((*VStorageObject)(nil)).Elem()
}

// This data object is a key-value pair whose key is the virtual storage
// object id, and value is the vm association information.
type VStorageObjectAssociations struct {
	DynamicData

	// ID of this virtual storage object.
	Id ID `xml:"id" json:"id"`
	// Array of vm associations related to the virtual storage object.
	VmDiskAssociations []VStorageObjectAssociationsVmDiskAssociations `xml:"vmDiskAssociations,omitempty" json:"vmDiskAssociations,omitempty"`
	// Received error while generating associations.
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["VStorageObjectAssociations"] = reflect.TypeOf((*VStorageObjectAssociations)(nil)).Elem()
}

// This data object contains infomation of a VM Disk associations.
type VStorageObjectAssociationsVmDiskAssociations struct {
	DynamicData

	// ID of the virtual machine.
	VmId string `xml:"vmId" json:"vmId"`
	// Device key of the disk attached to the VM.
	DiskKey int32 `xml:"diskKey" json:"diskKey"`
}

func init() {
	t["VStorageObjectAssociationsVmDiskAssociations"] = reflect.TypeOf((*VStorageObjectAssociationsVmDiskAssociations)(nil)).Elem()
}

// Data object specifies Virtual storage object configuration
type VStorageObjectConfigInfo struct {
	BaseConfigInfo

	// The descriptor version of this object
	DescriptorVersion int32 `xml:"descriptorVersion,omitempty" json:"descriptorVersion,omitempty" vim:"8.0.1.0"`
	// The size in MB of this object.
	CapacityInMB int64 `xml:"capacityInMB" json:"capacityInMB"`
	// Consumption type of this object.
	//
	// See also `VStorageObjectConsumptionType_enum`.
	ConsumptionType []string `xml:"consumptionType,omitempty" json:"consumptionType,omitempty"`
	// IDs of the consumer objects which consume this vstorage object.
	//
	// For a virtual disk, this can be VM ID(s).
	ConsumerId []ID `xml:"consumerId,omitempty" json:"consumerId,omitempty"`
}

func init() {
	t["VStorageObjectConfigInfo"] = reflect.TypeOf((*VStorageObjectConfigInfo)(nil)).Elem()
}

// The parameters of `VStorageObjectManagerBase.VStorageObjectCreateSnapshotEx_Task`.
type VStorageObjectCreateSnapshotExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// A short description to be associated with the snapshot.
	Description string `xml:"description" json:"description"`
}

func init() {
	t["VStorageObjectCreateSnapshotExRequestType"] = reflect.TypeOf((*VStorageObjectCreateSnapshotExRequestType)(nil)).Elem()
	minAPIVersionForType["VStorageObjectCreateSnapshotExRequestType"] = "8.0.2.0"
}

type VStorageObjectCreateSnapshotEx_Task VStorageObjectCreateSnapshotExRequestType

func init() {
	t["VStorageObjectCreateSnapshotEx_Task"] = reflect.TypeOf((*VStorageObjectCreateSnapshotEx_Task)(nil)).Elem()
}

type VStorageObjectCreateSnapshotEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VcenterVStorageObjectManager.VStorageObjectCreateSnapshot_Task`.
type VStorageObjectCreateSnapshotRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// A short description to be associated with the snapshot.
	Description string `xml:"description" json:"description"`
}

func init() {
	t["VStorageObjectCreateSnapshotRequestType"] = reflect.TypeOf((*VStorageObjectCreateSnapshotRequestType)(nil)).Elem()
}

type VStorageObjectCreateSnapshot_Task VStorageObjectCreateSnapshotRequestType

func init() {
	t["VStorageObjectCreateSnapshot_Task"] = reflect.TypeOf((*VStorageObjectCreateSnapshot_Task)(nil)).Elem()
}

type VStorageObjectCreateSnapshot_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VStorageObjectManagerBase.VStorageObjectDeleteSnapshotEx_Task`.
type VStorageObjectDeleteSnapshotExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The ID of the snapshot of a virtual storage object.
	SnapshotId ID `xml:"snapshotId" json:"snapshotId"`
}

func init() {
	t["VStorageObjectDeleteSnapshotExRequestType"] = reflect.TypeOf((*VStorageObjectDeleteSnapshotExRequestType)(nil)).Elem()
	minAPIVersionForType["VStorageObjectDeleteSnapshotExRequestType"] = "8.0.2.0"
}

type VStorageObjectDeleteSnapshotEx_Task VStorageObjectDeleteSnapshotExRequestType

func init() {
	t["VStorageObjectDeleteSnapshotEx_Task"] = reflect.TypeOf((*VStorageObjectDeleteSnapshotEx_Task)(nil)).Elem()
}

type VStorageObjectDeleteSnapshotEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `VStorageObjectManagerBase.VStorageObjectExtendDiskEx_Task`.
type VStorageObjectExtendDiskExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual disk to be extended.
	Id ID `xml:"id" json:"id"`
	// The datastore where the virtual disk is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The new capacity of the virtual disk in MB.
	NewCapacityInMB int64 `xml:"newCapacityInMB" json:"newCapacityInMB"`
}

func init() {
	t["VStorageObjectExtendDiskExRequestType"] = reflect.TypeOf((*VStorageObjectExtendDiskExRequestType)(nil)).Elem()
	minAPIVersionForType["VStorageObjectExtendDiskExRequestType"] = "8.0.2.0"
}

type VStorageObjectExtendDiskEx_Task VStorageObjectExtendDiskExRequestType

func init() {
	t["VStorageObjectExtendDiskEx_Task"] = reflect.TypeOf((*VStorageObjectExtendDiskEx_Task)(nil)).Elem()
}

type VStorageObjectExtendDiskEx_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// This data object type contains ID and VClock details of a virtual disk snapshot.
type VStorageObjectSnapshot struct {
	DynamicData

	// ID of this snapshot object.
	Id ID `xml:"id" json:"id"`
	// VClock associated with the FCD when the operation completes.
	Vclock VslmVClockInfo `xml:"vclock" json:"vclock"`
}

func init() {
	t["VStorageObjectSnapshot"] = reflect.TypeOf((*VStorageObjectSnapshot)(nil)).Elem()
	minAPIVersionForType["VStorageObjectSnapshot"] = "8.0.2.0"
}

// This data object type provides details of a vstorage object snapshot
type VStorageObjectSnapshotDetails struct {
	DynamicData

	// Path of the snaphost object
	Path string `xml:"path,omitempty" json:"path,omitempty"`
	// Changed block tracking ID of the snapshot
	ChangedBlockTrackingId string `xml:"changedBlockTrackingId,omitempty" json:"changedBlockTrackingId,omitempty"`
}

func init() {
	t["VStorageObjectSnapshotDetails"] = reflect.TypeOf((*VStorageObjectSnapshotDetails)(nil)).Elem()
}

// This data object type contains the brief information of a
// virtual storage snapshot.
type VStorageObjectSnapshotInfo struct {
	DynamicData

	// An array of snapshots
	Snapshots []VStorageObjectSnapshotInfoVStorageObjectSnapshot `xml:"snapshots,omitempty" json:"snapshots,omitempty"`
}

func init() {
	t["VStorageObjectSnapshotInfo"] = reflect.TypeOf((*VStorageObjectSnapshotInfo)(nil)).Elem()
}

type VStorageObjectSnapshotInfoVStorageObjectSnapshot struct {
	DynamicData

	// ID of the snapshot object.
	Id *ID `xml:"id,omitempty" json:"id,omitempty"`
	// Backing object ID
	BackingObjectId string `xml:"backingObjectId,omitempty" json:"backingObjectId,omitempty"`
	// The date and time this object was created.
	CreateTime time.Time `xml:"createTime" json:"createTime"`
	// Short description of the snapshot
	Description string `xml:"description" json:"description"`
}

func init() {
	t["VStorageObjectSnapshotInfoVStorageObjectSnapshot"] = reflect.TypeOf((*VStorageObjectSnapshotInfoVStorageObjectSnapshot)(nil)).Elem()
}

// Contains information of a virtual storage object state.
//
// NOTE: The information obtained with this object is dynamic and it could
// change during the lifetime of the object. For performance purposes some
// of the data may not reflect the immediate state of the object, also there
// is not guarantee that it will be provided.
type VStorageObjectStateInfo struct {
	DynamicData

	// If set this flag indicates that the object currently is part of
	// provisioning operation or the last operation has not finished gracefully.
	//
	// There are maintenance procedures that are working on resolving that
	// tentative state. Note that this might result in the object to be removed.
	Tentative *bool `xml:"tentative" json:"tentative,omitempty"`
}

func init() {
	t["VStorageObjectStateInfo"] = reflect.TypeOf((*VStorageObjectStateInfo)(nil)).Elem()
}

type VVolHostPE struct {
	DynamicData

	// The host associated with this volume.
	//
	// Refers instance of `HostSystem`.
	Key ManagedObjectReference `xml:"key" json:"key"`
	// Host-specific information about the ProtocolEndpoint.
	ProtocolEndpoint []HostProtocolEndpoint `xml:"protocolEndpoint" json:"protocolEndpoint"`
}

func init() {
	t["VVolHostPE"] = reflect.TypeOf((*VVolHostPE)(nil)).Elem()
}

// VVolVmConfigFileUpdateResult is the result returned
// by the `Datastore.UpdateVVolVirtualMachineFiles_Task` method.
type VVolVmConfigFileUpdateResult struct {
	DynamicData

	// Mapping of target config VVol IDs to the target virtual machine
	// config file paths which are successfully updated.
	SucceededVmConfigFile []KeyValue `xml:"succeededVmConfigFile,omitempty" json:"succeededVmConfigFile,omitempty"`
	// The list of virtual machines config files the server has attempted,
	// but failed to update.
	FailedVmConfigFile []VVolVmConfigFileUpdateResultFailedVmConfigFileInfo `xml:"failedVmConfigFile,omitempty" json:"failedVmConfigFile,omitempty"`
}

func init() {
	t["VVolVmConfigFileUpdateResult"] = reflect.TypeOf((*VVolVmConfigFileUpdateResult)(nil)).Elem()
}

// Information of the failed update on the virtual machine config
// file.
type VVolVmConfigFileUpdateResultFailedVmConfigFileInfo struct {
	DynamicData

	// The target virtual machine config VVol ID
	TargetConfigVVolId string `xml:"targetConfigVVolId" json:"targetConfigVVolId"`
	// Datastore path for the virtual machine that failed to recover
	DsPath string `xml:"dsPath,omitempty" json:"dsPath,omitempty"`
	// The reason why the update failed.
	Fault LocalizedMethodFault `xml:"fault" json:"fault"`
}

func init() {
	t["VVolVmConfigFileUpdateResultFailedVmConfigFileInfo"] = reflect.TypeOf((*VVolVmConfigFileUpdateResultFailedVmConfigFileInfo)(nil)).Elem()
}

type ValidateCredentialsInGuest ValidateCredentialsInGuestRequestType

func init() {
	t["ValidateCredentialsInGuest"] = reflect.TypeOf((*ValidateCredentialsInGuest)(nil)).Elem()
}

// The parameters of `GuestAuthManager.ValidateCredentialsInGuest`.
type ValidateCredentialsInGuestRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// MoRef of the VM to perform the operation on.
	//
	// Required privileges: VirtualMachine.GuestOperations.Query
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// The guest authentication data. See
	// `GuestAuthentication`.
	Auth BaseGuestAuthentication `xml:"auth,typeattr" json:"auth"`
}

func init() {
	t["ValidateCredentialsInGuestRequestType"] = reflect.TypeOf((*ValidateCredentialsInGuestRequestType)(nil)).Elem()
}

type ValidateCredentialsInGuestResponse struct {
}

type ValidateHCIConfiguration ValidateHCIConfigurationRequestType

func init() {
	t["ValidateHCIConfiguration"] = reflect.TypeOf((*ValidateHCIConfiguration)(nil)).Elem()
}

// The parameters of `ClusterComputeResource.ValidateHCIConfiguration`.
type ValidateHCIConfigurationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The `ClusterComputeResourceHCIConfigSpec`
	// to be used for validating the hosts. If not specified, the
	// existing `ClusterComputeResourceHCIConfigInfo` of the
	// cluster will be used.
	// Note:- This param must be omitted for post-configure validation.
	HciConfigSpec *ClusterComputeResourceHCIConfigSpec `xml:"hciConfigSpec,omitempty" json:"hciConfigSpec,omitempty"`
	// The set of hosts to be validated. If not specified, the set
	// of existing hosts in the cluster will be used.
	// Note:- This param must be omitted for post-configure validation.
	//
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts,omitempty" json:"hosts,omitempty"`
}

func init() {
	t["ValidateHCIConfigurationRequestType"] = reflect.TypeOf((*ValidateHCIConfigurationRequestType)(nil)).Elem()
}

type ValidateHCIConfigurationResponse struct {
	Returnval []BaseClusterComputeResourceValidationResultBase `xml:"returnval,omitempty,typeattr" json:"returnval,omitempty"`
}

type ValidateHost ValidateHostRequestType

func init() {
	t["ValidateHost"] = reflect.TypeOf((*ValidateHost)(nil)).Elem()
}

// The parameters of `HostProfileManager.ValidateHostProfileComposition_Task`.
type ValidateHostProfileCompositionRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The source host profile of the configurations for
	// composition.
	//
	// Refers instance of `Profile`.
	Source ManagedObjectReference `xml:"source" json:"source"`
	// The array of target host profiles that the configurations
	// composite into.
	//
	// Refers instances of `Profile`.
	Targets []ManagedObjectReference `xml:"targets,omitempty" json:"targets,omitempty"`
	// A `HostApplyProfile` object
	// contains the sub profiles that will be merged from the source to
	// the target host profiles, and all the ancestors of these sub
	// profiles. For singleton sub profile, it will be added into a
	// target host profile if it doesn't exist in the target; otherwise,
	// it replaces the one in the target.
	// The member variable
	// `ApplyProfile.toBeMerged` of these sub profiles
	// should have a value of <code>true</code>. The member variables
	// `ApplyProfile.toBeMerged`
	// `ApplyProfile.toReplaceWith`,
	// `ApplyProfile.toBeDeleted`
	// of the ancestors should have a value of <code>false</code>.
	ToBeMerged *HostApplyProfile `xml:"toBeMerged,omitempty" json:"toBeMerged,omitempty"`
	// A `HostApplyProfile` object
	// contains the sub profiles that will be used to replace the array
	// in the target host profiles, and all the ancestors of these sub
	// profiles.
	// Similar to above except that the member variable
	// `ApplyProfile.toReplaceWith`
	// is turned on.
	ToReplaceWith *HostApplyProfile `xml:"toReplaceWith,omitempty" json:"toReplaceWith,omitempty"`
	// A `HostApplyProfile` object
	// contains the sub profiles that will be deleted from the source
	// `*and*` the target host profiles, and all the ancestors of
	// these sub profiles.
	// Similar to above except that the member variable
	// `ApplyProfile.toBeDeleted`
	// is turned on.
	ToBeDeleted *HostApplyProfile `xml:"toBeDeleted,omitempty" json:"toBeDeleted,omitempty"`
	// A `HostApplyProfile`
	// object contains the sub profiles that the member variable
	// `ApplyProfile.enabled` will be copied from the
	// source host profile to all the target host profiles, and all the
	// ancestors of these sub profiles.
	// The member variable
	// `ApplyProfile.copyEnableStatus`
	// of these sub profiles is turned on. The member variable
	// `ApplyProfile.copyEnableStatus` of the
	// `ApplyProfile.copyEnableStatus` of the
	// ancestors should have a value of <code>false</code>.
	EnableStatusToBeCopied *HostApplyProfile `xml:"enableStatusToBeCopied,omitempty" json:"enableStatusToBeCopied,omitempty"`
	// Indicates that the validation result for each target
	// don't contain the source-target difference.
	ErrorOnly *bool `xml:"errorOnly" json:"errorOnly,omitempty"`
}

func init() {
	t["ValidateHostProfileCompositionRequestType"] = reflect.TypeOf((*ValidateHostProfileCompositionRequestType)(nil)).Elem()
}

type ValidateHostProfileComposition_Task ValidateHostProfileCompositionRequestType

func init() {
	t["ValidateHostProfileComposition_Task"] = reflect.TypeOf((*ValidateHostProfileComposition_Task)(nil)).Elem()
}

type ValidateHostProfileComposition_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

// The parameters of `OvfManager.ValidateHost`.
type ValidateHostRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The OVF descriptor to examine.
	OvfDescriptor string `xml:"ovfDescriptor" json:"ovfDescriptor"`
	// The host to validate against.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Additional parameters for validateHost, wrapped in a ValidateHostParams
	// instance.
	Vhp OvfValidateHostParams `xml:"vhp" json:"vhp"`
}

func init() {
	t["ValidateHostRequestType"] = reflect.TypeOf((*ValidateHostRequestType)(nil)).Elem()
}

type ValidateHostResponse struct {
	Returnval OvfValidateHostResult `xml:"returnval" json:"returnval"`
}

type ValidateMigration ValidateMigrationRequestType

func init() {
	t["ValidateMigration"] = reflect.TypeOf((*ValidateMigration)(nil)).Elem()
}

// The parameters of `ServiceInstance.ValidateMigration`.
type ValidateMigrationRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The set of virtual machines intended for migration.
	//
	// Refers instances of `VirtualMachine`.
	Vm []ManagedObjectReference `xml:"vm" json:"vm"`
	// The power state that the virtual machines must have. If
	// this argument is not set, each virtual machine is evaluated
	// according to its current power state.
	State VirtualMachinePowerState `xml:"state,omitempty" json:"state,omitempty"`
	// The set of tests to run. If this argument is not set, all
	// tests will be run.
	TestType []string `xml:"testType,omitempty" json:"testType,omitempty"`
	// The target resource pool for the virtual machines. If the
	// pool parameter is left unset, the target pool for each particular
	// virtual machine's migration will be that virtual machine's current
	// pool. If the virtual machine is a template then either this
	// parameter or the host parameter must be set; additionally if
	// resource tests are requested then this parameter is required.
	//
	// Refers instance of `ResourcePool`.
	Pool *ManagedObjectReference `xml:"pool,omitempty" json:"pool,omitempty"`
	// The target host on which the virtual machines will run. The host
	// parameter may be left unset if the compute resource associated with
	// the target pool represents a stand-alone host or a DRS-enabled
	// cluster. In the former case the stand-alone host is used as the
	// target host. In the latter case, each connected host in the cluster
	// that is not in maintenance mode is tested as a target host.
	// If the virtual machine is a template then either this
	// parameter or the pool parameter must be set.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
}

func init() {
	t["ValidateMigrationRequestType"] = reflect.TypeOf((*ValidateMigrationRequestType)(nil)).Elem()
}

type ValidateMigrationResponse struct {
	Returnval []BaseEvent `xml:"returnval,omitempty,typeattr" json:"returnval,omitempty"`
}

type ValidateStoragePodConfig ValidateStoragePodConfigRequestType

func init() {
	t["ValidateStoragePodConfig"] = reflect.TypeOf((*ValidateStoragePodConfig)(nil)).Elem()
}

// The parameters of `StorageResourceManager.ValidateStoragePodConfig`.
type ValidateStoragePodConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The storage pod.
	//
	// Refers instance of `StoragePod`.
	Pod ManagedObjectReference `xml:"pod" json:"pod"`
	// A set of storage Drs configuration changes to apply to
	// the storage pod.
	Spec StorageDrsConfigSpec `xml:"spec" json:"spec"`
}

func init() {
	t["ValidateStoragePodConfigRequestType"] = reflect.TypeOf((*ValidateStoragePodConfigRequestType)(nil)).Elem()
}

type ValidateStoragePodConfigResponse struct {
	Returnval *LocalizedMethodFault `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// Represents a VASA provider and its related datastores.
type VasaProviderContainerSpec struct {
	DynamicData

	// VASA Providers that manage this volume
	VasaProviderInfo []VimVasaProviderInfo `xml:"vasaProviderInfo,omitempty" json:"vasaProviderInfo,omitempty"`
	// Vendor specified Storage Container ID
	ScId string `xml:"scId" json:"scId"`
	// Indicates whether the container got deleted
	Deleted bool `xml:"deleted" json:"deleted"`
	// Indicates whether container is stretched
	Stretched *bool `xml:"stretched" json:"stretched,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["VasaProviderContainerSpec"] = reflect.TypeOf((*VasaProviderContainerSpec)(nil)).Elem()
}

// This event records when the VirtualCenter agent on a host failed to uninstall.
type VcAgentUninstallFailedEvent struct {
	HostEvent

	// The reason why the uninstall failed, if known.
	//
	// See `AgentInstallFailedReason_enum`
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["VcAgentUninstallFailedEvent"] = reflect.TypeOf((*VcAgentUninstallFailedEvent)(nil)).Elem()
}

// This event records when the VirtualCenter agent on a host is uninstalled.
type VcAgentUninstalledEvent struct {
	HostEvent
}

func init() {
	t["VcAgentUninstalledEvent"] = reflect.TypeOf((*VcAgentUninstalledEvent)(nil)).Elem()
}

// This event records when the VirtualCenter agent on a host failed to upgrade.
type VcAgentUpgradeFailedEvent struct {
	HostEvent

	// The reason why the upgrade failed, if known.
	//
	// See `AgentInstallFailedReason_enum`
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["VcAgentUpgradeFailedEvent"] = reflect.TypeOf((*VcAgentUpgradeFailedEvent)(nil)).Elem()
}

// This event records when the VirtualCenter agent on a host upgraded.
type VcAgentUpgradedEvent struct {
	HostEvent
}

func init() {
	t["VcAgentUpgradedEvent"] = reflect.TypeOf((*VcAgentUpgradedEvent)(nil)).Elem()
}

// The VchaClusterConfigInfo class contains
// configuration information of the three nodes of a VCHA
// Cluster.
type VchaClusterConfigInfo struct {
	DynamicData

	// Node configuration information for the VCHA Cluster
	FailoverNodeInfo1 *FailoverNodeInfo `xml:"failoverNodeInfo1,omitempty" json:"failoverNodeInfo1,omitempty"`
	// Node configuration information for the VCHA Cluster
	FailoverNodeInfo2 *FailoverNodeInfo `xml:"failoverNodeInfo2,omitempty" json:"failoverNodeInfo2,omitempty"`
	// Node configuration information for the VCHA Cluster
	WitnessNodeInfo *WitnessNodeInfo `xml:"witnessNodeInfo,omitempty" json:"witnessNodeInfo,omitempty"`
	// Current state of VCHA Cluster.
	//
	// `VchaState_enum` lists all
	// possible states.
	// If the state is invalid or notConfigured, the other fields in this
	// object will be unset.
	State string `xml:"state" json:"state"`
}

func init() {
	t["VchaClusterConfigInfo"] = reflect.TypeOf((*VchaClusterConfigInfo)(nil)).Elem()
}

// The VchaClusterConfigSpec class contains IP addresses of
// Passive and Witness nodes to configure and form the VCHA Cluster.
//
// Passive and Witness nodes are assumed to be pre-configured
// to allow access to them over the specified IP addresses.
// Active Node IP address is not required as it is retrieved from
// the already configured interface on VCHA Cluster network.
type VchaClusterConfigSpec struct {
	DynamicData

	// IP Address of Passive node in the VCHA Cluster network.
	PassiveIp string `xml:"passiveIp" json:"passiveIp"`
	// IP Address of Witness node in the VCHA Cluster network.
	WitnessIp string `xml:"witnessIp" json:"witnessIp"`
}

func init() {
	t["VchaClusterConfigSpec"] = reflect.TypeOf((*VchaClusterConfigSpec)(nil)).Elem()
}

// The VchaClusterDeploymentSpec class contains
// deployment information for creating and configuring a VCHA Cluster.
type VchaClusterDeploymentSpec struct {
	DynamicData

	// Deployment spec for the Passive node
	PassiveDeploymentSpec PassiveNodeDeploymentSpec `xml:"passiveDeploymentSpec" json:"passiveDeploymentSpec"`
	// Deployment spec for the Witness node
	WitnessDeploymentSpec BaseNodeDeploymentSpec `xml:"witnessDeploymentSpec,typeattr" json:"witnessDeploymentSpec"`
	// Active vCenter Server specification required to deploy
	// VCHA Cluster.
	ActiveVcSpec SourceNodeSpec `xml:"activeVcSpec" json:"activeVcSpec"`
	// The Cluster network config spec allows creation and configuration of
	// the second Network adapter of the Active or Source VCenter.
	//
	// The second network adapter is used for communication between
	// the nodes of a VCHA cluster.
	ActiveVcNetworkConfig *ClusterNetworkConfigSpec `xml:"activeVcNetworkConfig,omitempty" json:"activeVcNetworkConfig,omitempty"`
}

func init() {
	t["VchaClusterDeploymentSpec"] = reflect.TypeOf((*VchaClusterDeploymentSpec)(nil)).Elem()
}

// The VchaClusterHealth class describes the overall
// VCHA Cluster health.
//
// Health information include the last known runtime
// information about the VCHA Cluster along with health messages and any
// additional information applicable to the current VCHA Cluster health.
// If the cluster state is healthy, there will not be any health messages
// or additional information provided.
type VchaClusterHealth struct {
	DynamicData

	// Runtime information of the VCHA Cluster
	RuntimeInfo VchaClusterRuntimeInfo `xml:"runtimeInfo" json:"runtimeInfo"`
	// A collection of Messages describing the reason for a non-healthy
	// Cluster.
	HealthMessages []LocalizableMessage `xml:"healthMessages,omitempty" json:"healthMessages,omitempty"`
	// A collection of additional information regarding the health messages.
	AdditionalInformation []LocalizableMessage `xml:"additionalInformation,omitempty" json:"additionalInformation,omitempty"`
}

func init() {
	t["VchaClusterHealth"] = reflect.TypeOf((*VchaClusterHealth)(nil)).Elem()
}

// The VchaClusterNetworkSpec class contains network
// configuration information for a VCHA Cluster.
type VchaClusterNetworkSpec struct {
	DynamicData

	// Network spec for the Witness node.
	WitnessNetworkSpec BaseNodeNetworkSpec `xml:"witnessNetworkSpec,typeattr" json:"witnessNetworkSpec"`
	// Network spec for the Passive node.
	PassiveNetworkSpec PassiveNodeNetworkSpec `xml:"passiveNetworkSpec" json:"passiveNetworkSpec"`
}

func init() {
	t["VchaClusterNetworkSpec"] = reflect.TypeOf((*VchaClusterNetworkSpec)(nil)).Elem()
}

// The VchaClusterRuntimeInfo class describes the
// runtime information of a VCHA Cluster.
//
// This includes the last known
// state of the cluster and last known states of each node.
type VchaClusterRuntimeInfo struct {
	DynamicData

	// Last known state of the VCHA Cluster.
	//
	// `VchaClusterState` lists all possible states.
	ClusterState string `xml:"clusterState" json:"clusterState"`
	// Runtime information for each node in the VCHA Cluster.
	NodeInfo []VchaNodeRuntimeInfo `xml:"nodeInfo,omitempty" json:"nodeInfo,omitempty"`
	// Operational mode of the VCHA Cluster.
	//
	// `VchaClusterMode`
	// lists all possible modes.
	ClusterMode string `xml:"clusterMode" json:"clusterMode"`
}

func init() {
	t["VchaClusterRuntimeInfo"] = reflect.TypeOf((*VchaClusterRuntimeInfo)(nil)).Elem()
}

// The VchaNodeRuntimeInfo class describes a node's
// runtime information in a VCHA Cluster.
type VchaNodeRuntimeInfo struct {
	DynamicData

	// Last known state of the node.
	//
	// `VchaNodeState`
	// lists all possible states.
	NodeState string `xml:"nodeState" json:"nodeState"`
	// Last known role of the node.
	//
	// `VchaNodeRole`
	// lists all possible roles.
	NodeRole string `xml:"nodeRole" json:"nodeRole"`
	// IP address for the node in the replication network.
	NodeIp string `xml:"nodeIp" json:"nodeIp"`
}

func init() {
	t["VchaNodeRuntimeInfo"] = reflect.TypeOf((*VchaNodeRuntimeInfo)(nil)).Elem()
}

// Password for the Vim account user on the host has been changed.
//
// This is an account created by VirtualCenter and used to manage the host.
type VimAccountPasswordChangedEvent struct {
	HostEvent
}

func init() {
	t["VimAccountPasswordChangedEvent"] = reflect.TypeOf((*VimAccountPasswordChangedEvent)(nil)).Elem()
}

// The common base type for all virtual infrastructure management
// exceptions.
type VimFault struct {
	MethodFault
}

func init() {
	t["VimFault"] = reflect.TypeOf((*VimFault)(nil)).Elem()
}

type VimFaultFault BaseVimFault

func init() {
	t["VimFaultFault"] = reflect.TypeOf((*VimFaultFault)(nil)).Elem()
}

// Data object representing VASA Provider.
type VimVasaProvider struct {
	DynamicData

	// Provider UID.
	//
	// This is populated with namespace prefixed to providerId,
	// which uniquely identifies a VASA Provider. Both namespace and providerId
	// are sourced from Vasa Provider and available within SMS. This field
	// helps in preventing a regeneration of duplicate VASA Provider within
	// vvold when a user attempts to register the same VP using different names
	// or alternative urls.
	Uid string `xml:"uid,omitempty" json:"uid,omitempty"`
	// VASA Provider URL.
	//
	// In VirtualHost based MultiVC setup,
	// this is set to default virtual host's URL.
	Url string `xml:"url" json:"url"`
	// Name
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// Self-signed certificate of VASA provider.
	//
	// In VirtualHost based MultiVC setup,
	// this is set to default virtual host's self-signed certificate.
	SelfSignedCertificate string `xml:"selfSignedCertificate,omitempty" json:"selfSignedCertificate,omitempty"`
	// Virtual host configuration for VASA Provider when it supports MultiVC
	// through VirtualHosts.
	VhostConfig *VimVasaProviderVirtualHostConfig `xml:"vhostConfig,omitempty" json:"vhostConfig,omitempty" vim:"8.0.1.0"`
	// SMS supported VASA provider versionId.
	//
	// i-e if versionX corresponds to VASA version supported
	// by SMS, then X needs to be set here.
	// versionX corresponds to SMS supported VASA versions are, 1.0-&gt;version1, 1.5-&gt;version2,
	// 2.0-&gt;version3, 3.0-&gt;version4, 3.5-&gt;version5, 4.0-&gt;version6, 5.0-&gt;version7, etc.
	// For example: If SMS is connecting to VASA 5.0, the this field should be set to 7.
	VersionId int32 `xml:"versionId,omitempty" json:"versionId,omitempty" vim:"8.0.1.0"`
}

func init() {
	t["VimVasaProvider"] = reflect.TypeOf((*VimVasaProvider)(nil)).Elem()
}

// Data object representing VASA Provider information.
type VimVasaProviderInfo struct {
	DynamicData

	// Vasa provider
	Provider VimVasaProvider `xml:"provider" json:"provider"`
	// Per-array State
	ArrayState []VimVasaProviderStatePerArray `xml:"arrayState,omitempty" json:"arrayState,omitempty"`
}

func init() {
	t["VimVasaProviderInfo"] = reflect.TypeOf((*VimVasaProviderInfo)(nil)).Elem()
}

// Per Storage Array VP status.
type VimVasaProviderStatePerArray struct {
	DynamicData

	// Priority of the provider for the given array
	Priority int32 `xml:"priority" json:"priority"`
	// Storage Array object Id
	ArrayId string `xml:"arrayId" json:"arrayId"`
	// Indicates whether a VASA Provider (`VimVasaProvider.url`) is active
	// for the specified storage array.
	Active bool `xml:"active" json:"active"`
}

func init() {
	t["VimVasaProviderStatePerArray"] = reflect.TypeOf((*VimVasaProviderStatePerArray)(nil)).Elem()
}

// Holds VirtualHost configuration information when VASA 5.0 or greater VVOL VASA Provider
// supports MultiVC through VirtualHosts.
type VimVasaProviderVirtualHostConfig struct {
	DynamicData

	// Virtual Host FQDN on VASA Provider.
	//
	// If set, it's
	// used as SNI hostname in outgoing VASA Provider connection.
	VhostName string `xml:"vhostName,omitempty" json:"vhostName,omitempty"`
	// IP address where Virtual Host is running
	ServiceHost string `xml:"serviceHost" json:"serviceHost"`
	// Dedicated port for the virtual host.
	//
	// If not specified, default VirtualHost port is used to
	// communicate with VASA Provider.
	ServicePort int32 `xml:"servicePort,omitempty" json:"servicePort,omitempty"`
}

func init() {
	t["VimVasaProviderVirtualHostConfig"] = reflect.TypeOf((*VimVasaProviderVirtualHostConfig)(nil)).Elem()
	minAPIVersionForType["VimVasaProviderVirtualHostConfig"] = "8.0.1.0"
}

// The VirtualAHCIController data object type represents
// an AHCI SATA controller in a virtual machine.
type VirtualAHCIController struct {
	VirtualSATAController
}

func init() {
	t["VirtualAHCIController"] = reflect.TypeOf((*VirtualAHCIController)(nil)).Elem()
}

// VirtualAHCIControllerOption is the data object that contains
// the options for an AHCI SATA controller.
type VirtualAHCIControllerOption struct {
	VirtualSATAControllerOption
}

func init() {
	t["VirtualAHCIControllerOption"] = reflect.TypeOf((*VirtualAHCIControllerOption)(nil)).Elem()
}

// A VAppImportSpec is used by `ResourcePool.importVApp` when importing vApps (single VM or multi-VM).
//
// It provides all information needed to import a `VirtualApp`.
//
// See also `ImportSpec`.
type VirtualAppImportSpec struct {
	ImportSpec

	// The name of the vApp
	Name string `xml:"name" json:"name"`
	// vApp configuration
	VAppConfigSpec VAppConfigSpec `xml:"vAppConfigSpec" json:"vAppConfigSpec"`
	// Resource pool specification.
	//
	// If resourcePoolSpec.entity is specified, that resource pool is used as the parent
	// resource pool and the vApp will be made a linked child to the parent vApp. This
	// field is ignored for the root node in an ImportSpec tree.
	// Use of resourcePoolSpec.entity for creating linked children is deprecated as of
	// vSphere API 5.1.
	ResourcePoolSpec ResourceConfigSpec `xml:"resourcePoolSpec" json:"resourcePoolSpec"`
	// Contains a list of children (`VirtualMachine`s and
	// `VirtualApp`s).
	Child []BaseImportSpec `xml:"child,omitempty,typeattr" json:"child,omitempty"`
}

func init() {
	t["VirtualAppImportSpec"] = reflect.TypeOf((*VirtualAppImportSpec)(nil)).Elem()
}

// Deprecated as of vSphere API 5.1.
//
// Linked child information.
type VirtualAppLinkInfo struct {
	DynamicData

	// The key contains a reference to the entity that is linked to this vApp
	//
	// Refers instance of `ManagedEntity`.
	Key ManagedObjectReference `xml:"key" json:"key"`
	// Whether the entity should be removed, when this vApp is removed
	DestroyWithParent *bool `xml:"destroyWithParent" json:"destroyWithParent,omitempty"`
}

func init() {
	t["VirtualAppLinkInfo"] = reflect.TypeOf((*VirtualAppLinkInfo)(nil)).Elem()
}

// This data object type encapsulates a typical set of resource
// pool information that is useful for list views and summary pages.
type VirtualAppSummary struct {
	ResourcePoolSummary

	// Product information.
	//
	// References to properties in the URLs are expanded.
	Product *VAppProductInfo `xml:"product,omitempty" json:"product,omitempty"`
	// Whether the vApp is running
	VAppState VirtualAppVAppState `xml:"vAppState,omitempty" json:"vAppState,omitempty"`
	// Whether a vApp is suspended, in the process of being suspended, or in the
	// process of being resumed.
	//
	// A stopped vApp is marked as suspended
	// under the following conditions:
	//   - All child virtual machines are either suspended or powered-off.
	//   - There is at least one suspended virtual machine for which the
	//     stop action is not "suspend".
	//
	// If the vAppState property is "stopped", the value is set to true if the vApp is
	// suspended (according the the above definition).
	//
	// If the vAppState property is "stopping" or "starting" and the suspend flag is set to
	// true, then the vApp is either in the process of being suspended or resumed
	// from a suspended state, respectively.
	//
	// If the vAppState property is "started", then the suspend flag is set to false.
	Suspended *bool `xml:"suspended" json:"suspended,omitempty"`
	// Whether one or more VMs in this vApp require a reboot to finish
	// installation.
	InstallBootRequired *bool `xml:"installBootRequired" json:"installBootRequired,omitempty"`
	// vCenter-specific UUID of the vApp
	InstanceUuid string `xml:"instanceUuid,omitempty" json:"instanceUuid,omitempty"`
}

func init() {
	t["VirtualAppSummary"] = reflect.TypeOf((*VirtualAppSummary)(nil)).Elem()
}

// VirtualBusLogicController is the data object that represents
// a BusLogic SCSI controller.
type VirtualBusLogicController struct {
	VirtualSCSIController
}

func init() {
	t["VirtualBusLogicController"] = reflect.TypeOf((*VirtualBusLogicController)(nil)).Elem()
}

// This data object contains
// the options for a BusLogic SCSI controller.
type VirtualBusLogicControllerOption struct {
	VirtualSCSIControllerOption
}

func init() {
	t["VirtualBusLogicControllerOption"] = reflect.TypeOf((*VirtualBusLogicControllerOption)(nil)).Elem()
}

// The VirtualCdrom data object type describes the configuration of a CD-ROM device
// in a virtual machine.
type VirtualCdrom struct {
	VirtualDevice
}

func init() {
	t["VirtualCdrom"] = reflect.TypeOf((*VirtualCdrom)(nil)).Elem()
}

// The VirtualCdrom.AtapiBackingInfo data object type
// represents an ATAPI device backing for a virtual CD-ROM.
type VirtualCdromAtapiBackingInfo struct {
	VirtualDeviceDeviceBackingInfo
}

func init() {
	t["VirtualCdromAtapiBackingInfo"] = reflect.TypeOf((*VirtualCdromAtapiBackingInfo)(nil)).Elem()
}

// The VirtualCdromOption.AtapiBackingOption data object type
// contains the options for the ATAPI CD-ROM device backing.
type VirtualCdromAtapiBackingOption struct {
	VirtualDeviceDeviceBackingOption
}

func init() {
	t["VirtualCdromAtapiBackingOption"] = reflect.TypeOf((*VirtualCdromAtapiBackingOption)(nil)).Elem()
}

// The VirtualCdrom.IsoBackingInfo data class represents
// an ISO backing for a virtual CD-ROM.
type VirtualCdromIsoBackingInfo struct {
	VirtualDeviceFileBackingInfo
}

func init() {
	t["VirtualCdromIsoBackingInfo"] = reflect.TypeOf((*VirtualCdromIsoBackingInfo)(nil)).Elem()
}

// The VirtualCdromOption.IsoBackingOption data object type contains
// the options for an ISO image backing.
type VirtualCdromIsoBackingOption struct {
	VirtualDeviceFileBackingOption
}

func init() {
	t["VirtualCdromIsoBackingOption"] = reflect.TypeOf((*VirtualCdromIsoBackingOption)(nil)).Elem()
}

// The VirtualCdromOption data object type contains the options for the
// virtual CD-ROM class.
type VirtualCdromOption struct {
	VirtualDeviceOption
}

func init() {
	t["VirtualCdromOption"] = reflect.TypeOf((*VirtualCdromOption)(nil)).Elem()
}

// The VirtualCdrom.PassthroughBackingInfo data class
// represents a device pass-through backing for a
// virtual CD-ROM.
type VirtualCdromPassthroughBackingInfo struct {
	VirtualDeviceDeviceBackingInfo

	// Flag to indicate whether or not the virtual machine has
	// exclusive CD-ROM device access.
	Exclusive bool `xml:"exclusive" json:"exclusive"`
}

func init() {
	t["VirtualCdromPassthroughBackingInfo"] = reflect.TypeOf((*VirtualCdromPassthroughBackingInfo)(nil)).Elem()
}

// The VirtualCdromOption.PassthroughBackingOption data object type
// contains the options for a pass-through CD-ROM device backing.
type VirtualCdromPassthroughBackingOption struct {
	VirtualDeviceDeviceBackingOption

	// Flag to indicate whether or not exclusive CD-ROM device access is supported.
	Exclusive BoolOption `xml:"exclusive" json:"exclusive"`
}

func init() {
	t["VirtualCdromPassthroughBackingOption"] = reflect.TypeOf((*VirtualCdromPassthroughBackingOption)(nil)).Elem()
}

// The VirtualCdrom.RemoteAtapiBackingInfo data class
// represents a remote ATAPI device backing for a virtual CD-ROM.
type VirtualCdromRemoteAtapiBackingInfo struct {
	VirtualDeviceRemoteDeviceBackingInfo
}

func init() {
	t["VirtualCdromRemoteAtapiBackingInfo"] = reflect.TypeOf((*VirtualCdromRemoteAtapiBackingInfo)(nil)).Elem()
}

// The VirtualCdromOption.RemoteAtapiBackingOption data object type
// contains the options for the remote ATAPI CD-ROM device backing.
//
// Note that the server cannot present a list of valid remote backing devices
// because it is unable to scan remote hosts.
type VirtualCdromRemoteAtapiBackingOption struct {
	VirtualDeviceDeviceBackingOption
}

func init() {
	t["VirtualCdromRemoteAtapiBackingOption"] = reflect.TypeOf((*VirtualCdromRemoteAtapiBackingOption)(nil)).Elem()
}

// The VirtualCdrom.RemotePassthroughBackingInfo data object type
// contains the information to specify a remote pass-through device
// backing of a virtual CD-ROM.
type VirtualCdromRemotePassthroughBackingInfo struct {
	VirtualDeviceRemoteDeviceBackingInfo

	// Flag to indicate whether or not the virtual machine
	// has exclusive access to the CD-ROM device.
	Exclusive bool `xml:"exclusive" json:"exclusive"`
}

func init() {
	t["VirtualCdromRemotePassthroughBackingInfo"] = reflect.TypeOf((*VirtualCdromRemotePassthroughBackingInfo)(nil)).Elem()
}

// The VirtualCdromOption.RemotePassthroughBackingOption data object type
// contains the options for a remote pass-through CD-ROM device backing.
//
// Note that the server cannot present a list of valid remote backing devices
// because it is unable to scan remote hosts.
type VirtualCdromRemotePassthroughBackingOption struct {
	VirtualDeviceRemoteDeviceBackingOption

	// Flag to indicate whether or not exclusive CD-ROM device access is supported.
	Exclusive BoolOption `xml:"exclusive" json:"exclusive"`
}

func init() {
	t["VirtualCdromRemotePassthroughBackingOption"] = reflect.TypeOf((*VirtualCdromRemotePassthroughBackingOption)(nil)).Elem()
}

// VirtualController is the base data object type for a device controller in
// a virtual machine.
//
// VirtualController extends
// `VirtualDevice` to inherit
// general information about a controller (such as name and description), and to allow
// controllers to appear in a generic list of virtual devices.
type VirtualController struct {
	VirtualDevice

	// Bus number associated with this controller.
	BusNumber int32 `xml:"busNumber" json:"busNumber"`
	// List of devices currently controlled by this controller.
	//
	// Each entry contains the `VirtualDevice.key` property of the
	// corresponding device object.
	Device []int32 `xml:"device,omitempty" json:"device,omitempty"`
}

func init() {
	t["VirtualController"] = reflect.TypeOf((*VirtualController)(nil)).Elem()
}

// The VirtualControllerOption data object type contains information about
// a virtual controller type.
type VirtualControllerOption struct {
	VirtualDeviceOption

	// The minimum and maximum number of devices this controller can control
	// at run time.
	Devices IntOption `xml:"devices" json:"devices"`
	// Array of supported device options for this controller.
	SupportedDevice []string `xml:"supportedDevice,omitempty" json:"supportedDevice,omitempty"`
}

func init() {
	t["VirtualControllerOption"] = reflect.TypeOf((*VirtualControllerOption)(nil)).Elem()
}

// VirtualDevice is the base data object type for devices in a virtual machine.
//
// This type contains enough information about a virtual device to allow clients
// to display devices they do not recognize. For example, a client with an
// older version than the server to which it connects may see a device
// without knowing what it is.
type VirtualDevice struct {
	DynamicData

	// A unique key that distinguishes this device from other
	// devices in the same virtual machine.
	//
	// Keys are immutable but may be
	// recycled; that is, a key does not change as long as the device is
	// associated with a particular virtual machine. However, once a device is
	// removed, its key may be used when another device is added.
	//
	// This property is not read-only, but the client cannot control its value.
	// Persistent device keys are always assigned and managed by the server, which
	// guarantees that all devices will have non-negative key values.
	//
	// When adding new devices, it may be necessary for a client to assign keys
	// temporarily in order to associate controllers with devices in
	// configuring a virtual machine. However, the server does not allow a
	// client to reassign a device key, and the server may assign a different
	// value from the one passed during configuration. Clients should ensure
	// that existing device keys are not reused as temporary key values for the
	// new device to be added (for example, by using unique negative integers as
	// temporary keys).
	//
	// When editing or deleting a device, clients must use the server-provided key
	// to refer to an existing device.
	Key int32 `xml:"key" json:"key"`
	// Provides a label and summary information for the device.
	DeviceInfo BaseDescription `xml:"deviceInfo,omitempty,typeattr" json:"deviceInfo,omitempty"`
	// Information about the backing of this virtual device presented
	// in the context of the virtual machine's environment.
	//
	// Not all devices are required to have backing information.
	//
	// See also `VirtualMachineConfigOption`.
	Backing BaseVirtualDeviceBackingInfo `xml:"backing,omitempty,typeattr" json:"backing,omitempty"`
	// Provides information about restrictions on removing this device while
	// a virtual machine is running.
	//
	// If the device is not removable, then
	// this property is null.
	Connectable *VirtualDeviceConnectInfo `xml:"connectable,omitempty" json:"connectable,omitempty"`
	// Information about the bus slot of a device in a virtual machine.
	SlotInfo BaseVirtualDeviceBusSlotInfo `xml:"slotInfo,omitempty,typeattr" json:"slotInfo,omitempty"`
	// Object key for the controller object for this device.
	//
	// This property contains the key property value of the controller device
	// object.
	ControllerKey int32 `xml:"controllerKey,omitempty" json:"controllerKey,omitempty"`
	// The unit number of this device on its controller.
	//
	// This property is null if
	// the controller property is null (for example, when the device is not
	// attached to a specific controller object).
	//
	// Normally, two devices on the same controller
	// may not be assigned the same unit number. If
	// multiple devices could exist on a controller,
	// then unit number has to be specified to
	// configure respective devices.
	UnitNumber *int32 `xml:"unitNumber" json:"unitNumber,omitempty"`
	// The virtual NUMA node.
	//
	// A negative number means there is no
	// affinity for the device. A positive number is a vNUMA node.
	// An unset value of numaNode is status-quo during Reconfigure time.
	// If numaNode is unset during ConfigInfo, then it means there is no
	// affinity for the device.
	NumaNode int32 `xml:"numaNode,omitempty" json:"numaNode,omitempty" vim:"8.0.0.1"`
	// Information about device group device is part of.
	//
	// Devices in the device group cannot be added/removed individually,
	// whole group has to be added/removed at once. Value can be set
	// during device add, it cannot be modified later.
	DeviceGroupInfo *VirtualDeviceDeviceGroupInfo `xml:"deviceGroupInfo,omitempty" json:"deviceGroupInfo,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VirtualDevice"] = reflect.TypeOf((*VirtualDevice)(nil)).Elem()
}

// <code>`VirtualDeviceBackingInfo`</code> is a base data object type
// for information about the backing of a device in a virtual machine.
//
// This base type does not define any properties. It is used as a namespace
// for general-purpose subtypes. Specific devices are represented by subtypes
// which define properties for device-specific backing information.
type VirtualDeviceBackingInfo struct {
	DynamicData
}

func init() {
	t["VirtualDeviceBackingInfo"] = reflect.TypeOf((*VirtualDeviceBackingInfo)(nil)).Elem()
}

// The `VirtualDeviceBackingOption` data class
// defines options for device-specific virtual backing objects.
type VirtualDeviceBackingOption struct {
	DynamicData

	// The name of the class the client should use to instantiate backing
	// for the virtual device.
	Type string `xml:"type" json:"type"`
}

func init() {
	t["VirtualDeviceBackingOption"] = reflect.TypeOf((*VirtualDeviceBackingOption)(nil)).Elem()
}

// <code>`VirtualDeviceBusSlotInfo`</code> is a base data object type
// for information about device connection to its bus.
//
// This base type does not
// define any properties. It is used as a namespace for general-purpose subtypes.
// Specific devices types are represented by subtypes which define properties for
// device-specific backing information.
type VirtualDeviceBusSlotInfo struct {
	DynamicData
}

func init() {
	t["VirtualDeviceBusSlotInfo"] = reflect.TypeOf((*VirtualDeviceBusSlotInfo)(nil)).Elem()
}

// The `VirtualDeviceBusSlotOption` data class
// defines options for device-specific bus slot objects.
type VirtualDeviceBusSlotOption struct {
	DynamicData

	// The name of the class the client should use to instantiate bus slot
	// object for the virtual device.
	Type string `xml:"type" json:"type"`
}

func init() {
	t["VirtualDeviceBusSlotOption"] = reflect.TypeOf((*VirtualDeviceBusSlotOption)(nil)).Elem()
}

// The VirtualDeviceSpec data object type encapsulates change
// specifications for an individual virtual device.
//
// The virtual
// device being added or modified must be fully specified.
type VirtualDeviceConfigSpec struct {
	DynamicData

	// Type of operation being performed on the specified virtual device.
	//
	// If no operation is specified, the spec. is ignored.
	Operation VirtualDeviceConfigSpecOperation `xml:"operation,omitempty" json:"operation,omitempty"`
	// Type of operation being performed on the backing
	// of the specified virtual device.
	//
	// If no file operation is specified in the VirtualDeviceSpec,
	// then any backing filenames in the
	// `VirtualDevice`
	// must refer to files that already exist.
	// The "replace" and "delete" values for this property are only
	// applicable to virtual disk backing files.
	FileOperation VirtualDeviceConfigSpecFileOperation `xml:"fileOperation,omitempty" json:"fileOperation,omitempty"`
	// Device specification, with all necessary properties set.
	Device BaseVirtualDevice `xml:"device,typeattr" json:"device"`
	// Virtual Device Profile requirement.
	//
	// Profiles are solution specifics.
	// Storage Profile Based Management(SPBM) is a vSphere server extension.
	// The API users who want to provision VMs using Storage Profiles, need to
	// interact with SPBM service.
	// This is an optional parameter and if user doesn't specify profile,
	// the default behavior will apply.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
	// BackingInfo configuration options.
	//
	// Each BackingSpec corresponds to a BackingInfo object. The member
	// `VirtualDeviceConfigSpec.backing` refers to the
	// `VirtualDeviceConfigSpec.device*.*VirtualDevice.backing`.
	Backing *VirtualDeviceConfigSpecBackingSpec `xml:"backing,omitempty" json:"backing,omitempty"`
	// List of independent filters `VirtualMachineIndependentFilterSpec`
	// to configure on the virtual device.
	FilterSpec []BaseVirtualMachineBaseIndependentFilterSpec `xml:"filterSpec,omitempty,typeattr" json:"filterSpec,omitempty" vim:"7.0.2.1"`
	// The change mode of the device.
	//
	// The values of the mode will be one of `VirtualDeviceConfigSpecChangeMode_enum` enumerations.
	// On unset, default to 'fail'.
	ChangeMode string `xml:"changeMode,omitempty" json:"changeMode,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VirtualDeviceConfigSpec"] = reflect.TypeOf((*VirtualDeviceConfigSpec)(nil)).Elem()
}

// <code>`VirtualDeviceConfigSpecBackingSpec`</code> is a data object
// type for information about configuration of the backing of a device
// in a virtual machine.
//
// The member `VirtualDeviceConfigSpecBackingSpec.parent` refers the parent in the chain of
// `VirtualDeviceBackingInfo` objects.
type VirtualDeviceConfigSpecBackingSpec struct {
	DynamicData

	Parent *VirtualDeviceConfigSpecBackingSpec `xml:"parent,omitempty" json:"parent,omitempty"`
	Crypto BaseCryptoSpec                      `xml:"crypto,omitempty,typeattr" json:"crypto,omitempty"`
}

func init() {
	t["VirtualDeviceConfigSpecBackingSpec"] = reflect.TypeOf((*VirtualDeviceConfigSpecBackingSpec)(nil)).Elem()
}

// The <code>`VirtualDeviceConnectInfo`</code> data object type
// contains information about connectable virtual devices.
type VirtualDeviceConnectInfo struct {
	DynamicData

	// Specifies whether the virtual machine should override the
	// virtual device connection state upon the completion of a
	// migration.
	//
	// At this time, this property is only applicable to instant
	// clone operations, and will be ignored for other migration
	// types. The property is also only valid with
	// VirtualEthernetCards, and any attempt to set this property
	// on an unsupported device will result in an error.
	// This property will persist only until the virtual machine
	// undergoes a supported migration, at which point it will be
	// consumed and unset on the destination virtual machine,
	// preventing the property from affecting future migrations.
	// The migration's success is not dependent on whether the device
	// reaches the desired connection state.
	// The set of possible values are described in
	// `VirtualDeviceConnectInfoMigrateConnectOp_enum`.
	MigrateConnect string `xml:"migrateConnect,omitempty" json:"migrateConnect,omitempty"`
	// Specifies whether or not to connect the device
	// when the virtual machine starts.
	StartConnected bool `xml:"startConnected" json:"startConnected"`
	// Enables guest control over whether the connectable device is
	// connected.
	AllowGuestControl bool `xml:"allowGuestControl" json:"allowGuestControl"`
	// Indicates whether the device is currently connected.
	//
	// Valid only while the virtual machine is running.
	Connected bool `xml:"connected" json:"connected"`
	// Indicates the current status of the connectable device.
	//
	// Valid only while the
	// virtual machine is running. The set of possible values is described in
	// `VirtualDeviceConnectInfoStatus_enum`
	Status string `xml:"status,omitempty" json:"status,omitempty"`
}

func init() {
	t["VirtualDeviceConnectInfo"] = reflect.TypeOf((*VirtualDeviceConnectInfo)(nil)).Elem()
}

// The ConnectOption data object type contains information about options for
// connectable virtual devices.
type VirtualDeviceConnectOption struct {
	DynamicData

	// Flag to indicate whether or not the device supports
	// the startConnected feature.
	StartConnected BoolOption `xml:"startConnected" json:"startConnected"`
	// Flag to indicate whether or not the device can be
	// connected and disconnected from within the guest operating system.
	AllowGuestControl BoolOption `xml:"allowGuestControl" json:"allowGuestControl"`
}

func init() {
	t["VirtualDeviceConnectOption"] = reflect.TypeOf((*VirtualDeviceConnectOption)(nil)).Elem()
}

// The <code>`VirtualDeviceDeviceBackingInfo`</code> data object type
// defines information about a host device or resource that backs a device
// in a virtual machine.
type VirtualDeviceDeviceBackingInfo struct {
	VirtualDeviceBackingInfo

	// The name of the device on the host system.
	DeviceName string `xml:"deviceName" json:"deviceName"`
	// Indicates whether the device should be auto detected
	// instead of directly specified.
	//
	// If this value is set to TRUE,
	// deviceName is ignored.
	UseAutoDetect *bool `xml:"useAutoDetect" json:"useAutoDetect,omitempty"`
}

func init() {
	t["VirtualDeviceDeviceBackingInfo"] = reflect.TypeOf((*VirtualDeviceDeviceBackingInfo)(nil)).Elem()
}

// The DeviceBackingOption data class contains device-specific backing options.
type VirtualDeviceDeviceBackingOption struct {
	VirtualDeviceBackingOption

	// Flag to indicate whether the specific instance of this device can
	// be auto-detected on the host instead of having to specify a
	// particular physical device.
	AutoDetectAvailable BoolOption `xml:"autoDetectAvailable" json:"autoDetectAvailable"`
}

func init() {
	t["VirtualDeviceDeviceBackingOption"] = reflect.TypeOf((*VirtualDeviceDeviceBackingOption)(nil)).Elem()
}

// <code>`VirtualDeviceDeviceGroupInfo`</code> contains information
// about the device group device is assigned to.
type VirtualDeviceDeviceGroupInfo struct {
	DynamicData

	// Device group instance key from
	// <code>`VirtualMachineVirtualDeviceGroupsDeviceGroup`</code>.
	GroupInstanceKey int32 `xml:"groupInstanceKey" json:"groupInstanceKey"`
	// Device sequence in the group.
	//
	// Small unique positive integer obtained
	// from <code>`VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo.device`</code>
	// template.
	SequenceId int32 `xml:"sequenceId" json:"sequenceId"`
}

func init() {
	t["VirtualDeviceDeviceGroupInfo"] = reflect.TypeOf((*VirtualDeviceDeviceGroupInfo)(nil)).Elem()
	minAPIVersionForType["VirtualDeviceDeviceGroupInfo"] = "8.0.0.1"
}

// <code>`VirtualDeviceFileBackingInfo`</code> is a data object type
// for information about file backing for a device in a virtual machine.
type VirtualDeviceFileBackingInfo struct {
	VirtualDeviceBackingInfo

	// Filename for the host file used in this backing.
	FileName string `xml:"fileName" json:"fileName"`
	// Reference to the datastore managed object where this file is stored.
	//
	// If the file is not located on a datastore, then this reference is null.
	// This is not used for configuration.
	//
	// Refers instance of `Datastore`.
	Datastore *ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty"`
	// Backing object's durable and unmutable identifier.
	//
	// Each backing object has a unique identifier which is not settable.
	BackingObjectId string `xml:"backingObjectId,omitempty" json:"backingObjectId,omitempty"`
}

func init() {
	t["VirtualDeviceFileBackingInfo"] = reflect.TypeOf((*VirtualDeviceFileBackingInfo)(nil)).Elem()
}

// The FileBackingOption data class contains file-specific backing options.
type VirtualDeviceFileBackingOption struct {
	VirtualDeviceBackingOption

	// Valid filename extension for the filename.
	//
	// If no extensions are present, any file extension is acceptable.
	FileNameExtensions *ChoiceOption `xml:"fileNameExtensions,omitempty" json:"fileNameExtensions,omitempty"`
}

func init() {
	t["VirtualDeviceFileBackingOption"] = reflect.TypeOf((*VirtualDeviceFileBackingOption)(nil)).Elem()
}

// The VirtualDeviceOption data object type contains information about
// a virtual device type, the options for configuring the virtual device,
// and the relationship between this virtual device and other devices.
//
// The vSphere API groups device configurations that are mutually exclusive
// into different configuration objects; each of these configuration objects
// may define subtypes for virtual device backing options
// that are independent of the virtual device.
// Backing-dependent options should appear in a subtype of
// `VirtualDeviceBackingOption`.
type VirtualDeviceOption struct {
	DynamicData

	// The name of the run-time class the client should instantiate
	// to create a run-time instance of this device.
	Type string `xml:"type" json:"type"`
	// If the device is connectable, then the connectOption
	// describes the connect options and defaults.
	ConnectOption *VirtualDeviceConnectOption `xml:"connectOption,omitempty" json:"connectOption,omitempty"`
	// If the device can use a bus slot configuration, then the busSlotOption
	// describes the bus slot options.
	BusSlotOption *VirtualDeviceBusSlotOption `xml:"busSlotOption,omitempty" json:"busSlotOption,omitempty"`
	// Data object type that denotes the controller option object that is
	// valid for controlling this device.
	ControllerType string `xml:"controllerType,omitempty" json:"controllerType,omitempty"`
	// Flag to indicate whether or not this device will be auto-assigned a controller
	// if one is required.
	//
	// If this is true, then a client need not explicitly create
	// the controller that this device will plug into.
	AutoAssignController *BoolOption `xml:"autoAssignController,omitempty" json:"autoAssignController,omitempty"`
	// A list of backing options that can be used to map the virtual
	// device to the host.
	//
	// The list is optional, since some devices exist only within
	// the virtual machine; for example, a VirtualController.
	BackingOption []BaseVirtualDeviceBackingOption `xml:"backingOption,omitempty,typeattr" json:"backingOption,omitempty"`
	// Index into the backingOption list, indicating the default backing.
	DefaultBackingOptionIndex int32 `xml:"defaultBackingOptionIndex,omitempty" json:"defaultBackingOptionIndex,omitempty"`
	// List of property names enforced by a licensing restriction
	// of the underlying product.
	//
	// For example, a limit that is not
	// derived based on the product or hardware features; the
	// property name "numCPU".
	LicensingLimit []string `xml:"licensingLimit,omitempty" json:"licensingLimit,omitempty"`
	// Indicates whether this device is deprecated.
	//
	// Hence, if set the device
	// cannot be used when creating a new virtual machine or be added to an existing
	// virtual machine. However, the device is still supported by the platform.
	Deprecated bool `xml:"deprecated" json:"deprecated"`
	// Indicates if this type of device can be hot-added to the virtual machine
	// via a reconfigure operation when the virtual machine is powered on.
	PlugAndPlay bool `xml:"plugAndPlay" json:"plugAndPlay"`
	// Indicates if this type of device can be hot-removed from the virtual machine
	// via a reconfigure operation when the virtual machine is powered on.
	HotRemoveSupported *bool `xml:"hotRemoveSupported" json:"hotRemoveSupported,omitempty"`
	NumaSupported      *bool `xml:"numaSupported" json:"numaSupported,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VirtualDeviceOption"] = reflect.TypeOf((*VirtualDeviceOption)(nil)).Elem()
}

// The <code>`VirtualDevicePciBusSlotInfo`</code> data object type
// defines information about a pci bus slot of pci device in a virtual machine.
type VirtualDevicePciBusSlotInfo struct {
	VirtualDeviceBusSlotInfo

	// The pci slot number of the virtual device.
	//
	// The pci slot number assignment should generally be left to the system.
	// If assigned a value, and the value is invalid or duplicated, it will
	// automatically be reassigned. This will not cause an error.
	//
	// Generally, the PCI slot numbers should never be specified in an
	// Reconfigure operation, and only in a CreateVM operation if i) they
	// are specified for all devices, and ii) the numbers have been
	// determined by looking at an existing VM configuration of similar
	// hardware version. In other words, when the virtual hardware configuration
	// is duplicated.
	PciSlotNumber int32 `xml:"pciSlotNumber" json:"pciSlotNumber"`
}

func init() {
	t["VirtualDevicePciBusSlotInfo"] = reflect.TypeOf((*VirtualDevicePciBusSlotInfo)(nil)).Elem()
}

// The <code>`VirtualDevicePipeBackingInfo`</code> data object type
// defines information for using a named pipe as backing for a device
// in a virtual machine.
type VirtualDevicePipeBackingInfo struct {
	VirtualDeviceBackingInfo

	// Pipe name for the host pipe associated with this backing.
	PipeName string `xml:"pipeName" json:"pipeName"`
}

func init() {
	t["VirtualDevicePipeBackingInfo"] = reflect.TypeOf((*VirtualDevicePipeBackingInfo)(nil)).Elem()
}

// The <code>`VirtualDevicePipeBackingOption`</code> data object type contains options
// specific to pipe backings.
type VirtualDevicePipeBackingOption struct {
	VirtualDeviceBackingOption
}

func init() {
	t["VirtualDevicePipeBackingOption"] = reflect.TypeOf((*VirtualDevicePipeBackingOption)(nil)).Elem()
}

// <code>`VirtualDeviceRemoteDeviceBackingInfo`</code> is a data object type
// for information
// about a remote device backing used by a device in a virtual machine.
//
// The primary difference between a remote device backing and a
// local device backing is that the VirtualCenter server cannot provide a list
// of remote host devices available for this virtual device backing.
type VirtualDeviceRemoteDeviceBackingInfo struct {
	VirtualDeviceBackingInfo

	// The name of the device on the remote system.
	DeviceName string `xml:"deviceName" json:"deviceName"`
	// Indicates whether the device should be auto detected
	// instead of directly specified.
	//
	// If this value is set to TRUE,
	// <code>deviceName</code> is ignored.
	UseAutoDetect *bool `xml:"useAutoDetect" json:"useAutoDetect,omitempty"`
}

func init() {
	t["VirtualDeviceRemoteDeviceBackingInfo"] = reflect.TypeOf((*VirtualDeviceRemoteDeviceBackingInfo)(nil)).Elem()
}

// VirtualDeviceOption.RemoteDeviceBackingOption describes the options
// for a remote device backing.
//
// The primary difference
// between a remote device backing and a local device backing is that
// the VirtualCenter server cannot provide a list of remote host devices
// available for this virtual device backing.
type VirtualDeviceRemoteDeviceBackingOption struct {
	VirtualDeviceBackingOption

	// Flag to indicate whether the specific instance of this device can
	// be auto-detected on the host instead of having to specify a
	// particular physical device.
	AutoDetectAvailable BoolOption `xml:"autoDetectAvailable" json:"autoDetectAvailable"`
}

func init() {
	t["VirtualDeviceRemoteDeviceBackingOption"] = reflect.TypeOf((*VirtualDeviceRemoteDeviceBackingOption)(nil)).Elem()
}

// The <code>`VirtualDeviceURIBackingInfo`</code> data object type
// defines information for using a network socket as backing for a virtual device.
type VirtualDeviceURIBackingInfo struct {
	VirtualDeviceBackingInfo

	// Identifies the local host or a system on the network,
	// depending on the value of <code>`VirtualDeviceURIBackingInfo.direction`</code>.
	//   - If you use the virtual machine as a server, the URI identifies
	//     the host on which the virtual machine runs. In this case,
	//     the host name part of the URI should be empty, or it should
	//     specify the address of the local host.
	//   - If you use the virtual machine as a client, the URI identifies
	//     the remote system on the network.
	ServiceURI string `xml:"serviceURI" json:"serviceURI"`
	// The direction of the connection.
	//
	// For possible values see
	// `VirtualDeviceURIBackingOptionDirection_enum`
	Direction string `xml:"direction" json:"direction"`
	// Identifies a proxy service that provides network access to the
	// <code>`VirtualDeviceURIBackingInfo.serviceURI`</code>.
	//
	// If you specify a proxy URI, the virtual machine initiates
	// a connection with the proxy service and forwards the
	// `VirtualDeviceURIBackingInfo.serviceURI` and `VirtualDeviceURIBackingInfo.direction` to the proxy.
	ProxyURI string `xml:"proxyURI,omitempty" json:"proxyURI,omitempty"`
}

func init() {
	t["VirtualDeviceURIBackingInfo"] = reflect.TypeOf((*VirtualDeviceURIBackingInfo)(nil)).Elem()
}

// The `VirtualDeviceURIBackingOption` data object type describes network communication
// options for virtual devices.
//
// When establishing a connection with a remote system on the network,
// the virtual machine can act as a server or a client.
// When the virtual machine acts as a server, it accepts a connection.
// When the virtual machine acts as a client, it initiates the connection.
type VirtualDeviceURIBackingOption struct {
	VirtualDeviceBackingOption

	// List of possible directions.
	//
	// Valid directions are:
	//   - `server`
	//   - `client`
	Directions ChoiceOption `xml:"directions" json:"directions"`
}

func init() {
	t["VirtualDeviceURIBackingOption"] = reflect.TypeOf((*VirtualDeviceURIBackingOption)(nil)).Elem()
}

// This data object type contains information about a disk in a virtual machine.
//
// The virtual disk backing object types describe the different virtual disk backings
// available.
// The disk format version in each case describes
// the version of the format that is used.
//
// Supported virtual disk backings:
// <dl>
// <dt>Sparse disk format, version 1 and 2</dt>
// <dd>The virtual disk backing grows when needed.
// Supported only for VMware Server.</dd>
// <dt>Flat disk format, version 1 and 2</dt>
// <dd>The virtual disk backing is preallocated.
// Version 1 is supported only for VMware Server.</dd>
// <dt>Space efficient sparse disk format</dt>
// <dd>The virtual disk backing grows on demand and
// incorporates additional space optimizations.</dd>
// <dt>Raw disk format, version 2</dt>
// <dd>The virtual disk backing uses a full physical disk drive
// to back the virtual disk. Supported only for VMware Server.</dd>
// <dt>Partitioned raw disk format, version 2</dt>
// <dd>The virtual disk backing uses one or more partitions on a
// physical disk drive to back a virtual disk. Supported only for VMware Server.</dd>
// <dt>Raw disk mapping, version 1</dt>
// <dd>The virtual disk backing uses a raw device mapping to back the virtual disk.
// Supported for ESX Server 2.5 and 3.x.</dd>
// </dl>
type VirtualDisk struct {
	VirtualDevice

	// Deprecated as of vSphere API 5.5, use `VirtualDisk.capacityInBytes`.
	//
	// Capacity of this virtual disk in kilobytes.
	//
	// Information might be lost when actual disk size is rounded off to kilobytes.
	// If the disk is on a Virtual Volume datastore the disk size must be a multiple
	// of a megabyte.
	CapacityInKB int64 `xml:"capacityInKB" json:"capacityInKB"`
	// Capacity of this virtual disk in bytes.
	//
	// Server will always populate this property. Clients must initialize it when
	// creating a new non -RDM disk or in case they want to change the current
	// capacity of an existing virtual disk, but can omit it otherwise.
	// If the disk is on a Virtual Volume datastore the disk size must be a multiple
	// of a megabyte.
	CapacityInBytes int64 `xml:"capacityInBytes,omitempty" json:"capacityInBytes,omitempty"`
	// Deprecated as of vSphere API 4.1, use
	// `StorageIOAllocationInfo.shares`.
	//
	// Disk shares, used for resource scheduling.
	Shares *SharesInfo `xml:"shares,omitempty" json:"shares,omitempty"`
	// Deprecated as of vSphere API 6.5, use.
	//
	// Resource allocation for storage I/O.
	StorageIOAllocation *StorageIOAllocationInfo `xml:"storageIOAllocation,omitempty" json:"storageIOAllocation,omitempty"`
	// Deprecated as of vSphere API 6.5, use `VirtualDisk.vDiskId`.
	//
	// Virtual disk durable and unmutable identifier.
	//
	// Virtual disk has a UUID field but that can be set through
	// VirtualDiskManager APIs.
	// This identifier is a universally unique identifier which is not settable.
	// VirtualDisk can remain in existence even if it is not associated with VM.
	DiskObjectId string `xml:"diskObjectId,omitempty" json:"diskObjectId,omitempty"`
	// Deprecated since vSphere 7.0 because vFlash Read Cache
	// end of availability.
	//
	// vFlash cache configuration supported on this virtual disk.
	VFlashCacheConfigInfo *VirtualDiskVFlashCacheConfigInfo `xml:"vFlashCacheConfigInfo,omitempty" json:"vFlashCacheConfigInfo,omitempty"`
	// IDs of the IO Filters associated with the virtual disk.
	//
	// See `IoFilterInfo.id`. This information
	// is provided when retrieving configuration information for
	// an existing virtual machine. The client cannot modify this information
	// on a virtual machine.
	Iofilter []string `xml:"iofilter,omitempty" json:"iofilter,omitempty"`
	// ID of the virtual disk object as the first class entity.
	//
	// See `ID`
	// The ID is a universally unique identifier for the disk lifecycle,
	// even if the virtual disk is not associated with VM.
	VDiskId *ID `xml:"vDiskId,omitempty" json:"vDiskId,omitempty"`
	// Disk descriptor version of the virtual disk.
	VDiskVersion int32 `xml:"vDiskVersion,omitempty" json:"vDiskVersion,omitempty" vim:"8.0.1.0"`
	// Indicates whether a disk with
	// `VirtualDiskFlatVer2BackingInfo` backing is a linked
	// clone from an unmanaged delta disk and hence the
	// `VirtualDiskFlatVer2BackingInfo.parent` chain to
	// this delta disk will not be available.
	NativeUnmanagedLinkedClone *bool `xml:"nativeUnmanagedLinkedClone" json:"nativeUnmanagedLinkedClone,omitempty"`
	// The IDs of the independent filters associated with the virtual disk.
	//
	// This information is provided when retrieving configuration information for
	// an existing virtual machine. The client cannot modify this information on
	// a virtual machine.
	IndependentFilters []BaseVirtualMachineBaseIndependentFilterSpec `xml:"independentFilters,omitempty,typeattr" json:"independentFilters,omitempty" vim:"7.0.2.1"`
	// Flag to indicate whether a disk should be presented to the guest
	// in read-only mode (limited by choice of adapter).
	GuestReadOnly *bool `xml:"guestReadOnly" json:"guestReadOnly,omitempty" vim:"8.0.2.0"`
}

func init() {
	t["VirtualDisk"] = reflect.TypeOf((*VirtualDisk)(nil)).Elem()
}

// Pod-wide anit-affinity rule for virtual disks.
//
// The set of virtual disks should
// be placed on different datastores.
type VirtualDiskAntiAffinityRuleSpec struct {
	ClusterRuleInfo

	// The list of virtual disks.
	DiskId []int32 `xml:"diskId" json:"diskId"`
}

func init() {
	t["VirtualDiskAntiAffinityRuleSpec"] = reflect.TypeOf((*VirtualDiskAntiAffinityRuleSpec)(nil)).Elem()
}

// The disk blocks of the specified virtual disk have not been fully
// provisioned on the file system.
//
// Typically, this fault is returned as part of a parent fault like
// `VmConfigIncompatibleForFaultTolerance`, indicating that the
// disk blocks of the virtual disk must be fully provisioned on the file system
// before fault tolerance can be enabled on the associated virtual machine.
type VirtualDiskBlocksNotFullyProvisioned struct {
	DeviceBackingNotSupported
}

func init() {
	t["VirtualDiskBlocksNotFullyProvisioned"] = reflect.TypeOf((*VirtualDiskBlocksNotFullyProvisioned)(nil)).Elem()
}

type VirtualDiskBlocksNotFullyProvisionedFault VirtualDiskBlocksNotFullyProvisioned

func init() {
	t["VirtualDiskBlocksNotFullyProvisionedFault"] = reflect.TypeOf((*VirtualDiskBlocksNotFullyProvisionedFault)(nil)).Elem()
}

// The VirtualDiskSpec data object type encapsulates change
// specifications for an individual virtual disk device.
//
// The virtual
// disk being added or modified must be fully specified.
type VirtualDiskConfigSpec struct {
	VirtualDeviceConfigSpec

	// Manner in which to move the virtual disk to the target datastore.
	//
	// The set of possible values is described in
	// `VirtualMachineRelocateDiskMoveOptions_enum`.
	//
	// This property can only be set if `HostCapability.deltaDiskBackingsSupported` is true.
	//
	// If left unset then `moveAllDiskBackingsAndDisallowSharing`
	// is assumed.
	DiskMoveType string `xml:"diskMoveType,omitempty" json:"diskMoveType,omitempty"`
	// Deprecated since vSphere 7.0 because vFlash Read Cache
	// end of availability.
	//
	// Manner in which to transfer the cache associated with the virtual disk to the
	// target host.
	//
	// If left unset then migrate is used when virtual flash resource on the source host
	// is accessible and when the backing vFlash module version is compatible with the
	// specific vFalsh module on the target host; otherwise flush is used for write back
	// cache, or a no-op for write through cache. This setting can avoid VM migration failure
	// due to incompatibility.
	// If true then migrate is always used. VM migration may fail if the backing vFlash module
	// version is incompatible with the module on the target host.
	// If false then flush is used for write back cache. It is a no-op for write through
	// cache. This setting can avoid VM migration failure due to incompatibility, but cache
	// files have to be rebuilt on the target host.
	// Default is unset.
	//
	// See also `HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption`.
	MigrateCache *bool `xml:"migrateCache" json:"migrateCache,omitempty"`
}

func init() {
	t["VirtualDiskConfigSpec"] = reflect.TypeOf((*VirtualDiskConfigSpec)(nil)).Elem()
}

// Delta disk format supported for each datastore type.
type VirtualDiskDeltaDiskFormatsSupported struct {
	DynamicData

	// Datastore type name
	DatastoreType string `xml:"datastoreType" json:"datastoreType"`
	// Delta disk formats supported.
	//
	// Valid values are:
	//   - `redoLogFormat`
	//   - `nativeFormat`
	DeltaDiskFormat ChoiceOption `xml:"deltaDiskFormat" json:"deltaDiskFormat"`
}

func init() {
	t["VirtualDiskDeltaDiskFormatsSupported"] = reflect.TypeOf((*VirtualDiskDeltaDiskFormatsSupported)(nil)).Elem()
}

// This data object type contains information about backing a virtual disk by
// using a virtual disk file on the host, in the flat file format used by
// GSX Server 2.x.
//
// Flat disks are allocated when created, unlike sparse disks, which
// grow as needed.
type VirtualDiskFlatVer1BackingInfo struct {
	VirtualDeviceFileBackingInfo

	// The disk persistence mode.
	//
	// Valid modes are:
	//   - `persistent`
	//   - `nonpersistent`
	//   - `undoable`
	//
	// See also `VirtualDiskMode_enum`.
	DiskMode string `xml:"diskMode" json:"diskMode"`
	// Flag to indicate the type of virtual disk file: split or monolithic.
	//
	// If true, the virtual disk is stored in multiple files, each 2GB.
	Split *bool `xml:"split" json:"split,omitempty"`
	// Flag to indicate whether writes should go directly to the file system
	// or should be buffered.
	WriteThrough *bool `xml:"writeThrough" json:"writeThrough,omitempty"`
	// Content ID of the virtual disk file, if available.
	//
	// A content ID indicates the logical contents of the disk backing and its parents.
	//
	// This property is only guaranteed to be up to date if this disk backing is not
	// currently being written to by any virtual machine.
	//
	// The only supported operation is comparing if two content IDs are equal or not.
	// The guarantee provided by the content ID is that if two disk backings have the
	// same content ID and are not currently being written to, then reads issued from
	// the guest operating system to those disk backings will return the same data.
	ContentId string `xml:"contentId,omitempty" json:"contentId,omitempty"`
	// The parent of this virtual disk file, if this is a delta disk backing.
	//
	// This will be unset if this is not a delta disk backing.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time. A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent). After a delta
	// disk backing is added, all writes go to the delta disk backing. All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// A delta disk backing can be added to a disk either implicitly during
	// snapshot operations, or explicitly during create or reconfigure of the virtual
	// machine.
	//
	// Note that the type of the backing is consistent throughout the chain; any new
	// delta disk backing which is added is of the same type as the original disk .
	// Also note that since the parent backing is not being written to,
	// it is possible that the parent backing may be shared among multiple
	// disks belonging to multiple virtual machines.
	//
	// During virtual machine `creation` and
	// `reconfiguration` this property is
	// only checked if the `VirtualDeviceConfigSpec` specifies
	// an *add operation* with a
	// *create file operation*.
	// In this case, a new delta disk backing is created which points to the parent
	// disk backing. Only the `fileName`
	// property is important; all other properties will be ignored. The parent backing
	// is assumed to exist and will not be recursively created.
	//
	// This property may only be set if
	// `deltaDiskBackingsSupported`
	// is true.
	Parent *VirtualDiskFlatVer1BackingInfo `xml:"parent,omitempty" json:"parent,omitempty"`
}

func init() {
	t["VirtualDiskFlatVer1BackingInfo"] = reflect.TypeOf((*VirtualDiskFlatVer1BackingInfo)(nil)).Elem()
}

// This data object type contains the available options when backing a virtual disk
// using a host file with the flat file format from GSX Server 2.x.
//
// Flat disks are pre-allocated, whereas sparse disks are grown as needed.
type VirtualDiskFlatVer1BackingOption struct {
	VirtualDeviceFileBackingOption

	// The disk mode.
	//
	// Valid disk modes are:
	//   - `persistent`
	//   - `nonpersistent`
	//   - `undoable`
	//   - `independent_persistent`
	//   - `independent_nonpersistent`
	//   - `append`
	//
	// See also `VirtualDiskMode_enum`.
	DiskMode ChoiceOption `xml:"diskMode" json:"diskMode"`
	// Flag to indicate whether or not the host supports
	// allowing the client to select whether or not a disk
	// should be split.
	Split BoolOption `xml:"split" json:"split"`
	// Flag to indicate whether or not the host supports
	// allowing the client to select "writethrough" as a mode for
	// virtual disks.
	//
	// Typically, this is available only for GSX Server Linux hosts.
	WriteThrough BoolOption `xml:"writeThrough" json:"writeThrough"`
	// Flag to indicate whether this backing can have its size changed.
	Growable bool `xml:"growable" json:"growable"`
}

func init() {
	t["VirtualDiskFlatVer1BackingOption"] = reflect.TypeOf((*VirtualDiskFlatVer1BackingOption)(nil)).Elem()
}

// This data object type contains information about backing a virtual disk using a
// virtual disk file on the host, in the flat file format used by VMware Server,
// ESX Server 2.x, and ESX Server 3.x.
//
// Flat disks are allocated when created, unlike sparse disks, which
// grow as needed.
type VirtualDiskFlatVer2BackingInfo struct {
	VirtualDeviceFileBackingInfo

	// The disk persistence mode.
	//
	// Valid modes are:
	//   - `persistent`
	//   - `independent_persistent`
	//   - `independent_nonpersistent`
	//   - `nonpersistent`
	//   - `undoable`
	//   - `append`
	//
	// See also `VirtualDiskMode_enum`.
	DiskMode string `xml:"diskMode" json:"diskMode"`
	// Flag to indicate the type of virtual disk file: split or monolithic.
	//
	// If true, the virtual disk is stored in multiple files, each 2GB.
	// On ESX this property is ignored when creating new disks or
	// editing existing disks. This property is always false for disks
	// created on ESX.
	// When an existing split disk such as those created by VMware
	// Server is added to a virtual machine on ESX, the property will
	// be set to true when retrieved from `VirtualMachineConfigInfo`.
	Split *bool `xml:"split" json:"split,omitempty"`
	// Flag to indicate whether writes should go directly to the file system
	// or should be buffered.
	WriteThrough *bool `xml:"writeThrough" json:"writeThrough,omitempty"`
	// Flag to indicate to the underlying filesystem, whether the
	// virtual disk backing file should be allocated lazily (using
	// thin provisioning). This flag is only used for file systems
	// that support configuring the provisioning policy on a per file
	// basis, such as VMFS3.
	//
	// When specified as part of a `VirtualMachineConfigSpec`, this
	// property applies only when creating a new virtual disk; it is
	// ignored when editing an existing virtual disk.
	//
	// see `DatastoreCapability.perFileThinProvisioningSupported`
	ThinProvisioned *bool `xml:"thinProvisioned" json:"thinProvisioned,omitempty"`
	// Flag to indicate to the underlying filesystem whether the
	// virtual disk backing file should be scrubbed completely at
	// this time.
	//
	// Virtual disks on some filesystems like VMFS3 are zeroed-out
	// lazily so that disk creation time doesn't take too long.
	// However, clustering applications and features like
	// Fault Tolerance require that the virtual disk be
	// completely scrubbed. This setting allows controlling the
	// scrubbing policy on a per-disk basis.
	//
	// If this flag is unset or set to false when creating a new disk,
	// the disk scrubbing policy will be decided by the filesystem. If
	// this flag is unset or set to false when editing an existing disk,
	// it is ignored.
	// When returned as part of a `VirtualMachineConfigInfo`, this
	// property may be unset if its value is unknown.
	EagerlyScrub *bool `xml:"eagerlyScrub" json:"eagerlyScrub,omitempty"`
	// Disk UUID for the virtual disk, if available.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// Content ID of the virtual disk file, if available.
	//
	// A content ID indicates the logical contents of the disk backing and its parents.
	//
	// This property is only guaranteed to be up to date if this disk backing is not
	// currently being written to by any virtual machine.
	//
	// The only supported operation is comparing if two content IDs are equal or not.
	// The guarantee provided by the content ID is that if two disk backings have the
	// same content ID and are not currently being written to, then reads issued from
	// the guest operating system to those disk backings will return the same data.
	ContentId string `xml:"contentId,omitempty" json:"contentId,omitempty"`
	// The change ID of the virtual disk for the corresponding
	// snapshot or virtual machine.
	//
	// This can be used to track
	// incremental changes to a virtual disk. See
	// `VirtualMachine.QueryChangedDiskAreas`.
	ChangeId string `xml:"changeId,omitempty" json:"changeId,omitempty"`
	// The parent of this virtual disk file, if this is a delta disk backing.
	//
	// This will be unset if this is not a delta disk backing.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time. A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent). After a delta
	// disk backing is added, all writes go to the delta disk backing. All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// A delta disk backing can be added to a disk either implicitly during
	// snapshot operations, or explicitly during create or reconfigure of the virtual
	// machine.
	//
	// Note that the type of the backing is consistent throughout the chain; any new
	// delta disk backing which is added is of the same type as the original disk .
	// Also note that since the parent backing is not being written to,
	// it is possible that the parent backing may be shared among multiple
	// disks belonging to multiple virtual machines.
	//
	// During virtual machine `creation` and
	// `reconfiguration` this property is
	// only checked if the `VirtualDeviceConfigSpec` specifies
	// an *add operation* with a
	// *create file operation*.
	// In this case, a new delta disk backing is created which points to the parent
	// disk backing. Only the `fileName`
	// property is important; all other properties will be ignored. The parent backing
	// is assumed to exist and will not be recursively created.
	//
	// This property may only be set if
	// `deltaDiskBackingsSupported`
	// is true.
	Parent *VirtualDiskFlatVer2BackingInfo `xml:"parent,omitempty" json:"parent,omitempty"`
	// The format of the delta disk.
	//
	// This field is valid only for a delta disk.
	//
	// See `DeltaDiskFormat` for the
	// supported formats. If not specified, the default value used is
	// `redoLogFormat`.
	//
	// If `nativeFormat`
	// is specified and the datastore does not support this format or the parent is
	// on a different datastore,
	// `DeltaDiskFormatNotSupported` is
	// thrown.
	//
	// vSphere server does not support relocation of virtual machines with
	// `nativeFormat`.
	// An exception is thrown for such requests.
	DeltaDiskFormat string `xml:"deltaDiskFormat,omitempty" json:"deltaDiskFormat,omitempty"`
	// Indicates whether the disk backing has digest file enabled.
	DigestEnabled *bool `xml:"digestEnabled" json:"digestEnabled,omitempty"`
	// Grain size in kB for a delta disk of format type seSparseFormat.
	//
	// The default
	// size is 4 kB.
	// This setting is used to specify the grain size of
	// `Flex-SE` delta disks
	// when the base disk is of type FlatVer2BackingInfo.
	// The `DeltaDiskFormat` must also
	// be set to seSparseFormat.
	DeltaGrainSize int32 `xml:"deltaGrainSize,omitempty" json:"deltaGrainSize,omitempty"`
	// The delta disk format variant, if applicable.
	//
	// This field is valid only for a delta disk and may specify more detailed
	// information for the delta disk format specified in
	// `deltaDiskFormat`.
	//
	// If `redoLogFormat` is
	// specified for the
	// `deltaDiskFormat`,
	// see `DeltaDiskFormatVariant` for the
	// supported formats. If this is not specified for
	// `redoLogFormat`,
	// the default value used is
	// `vmfsSparseVariant`.
	//
	// For other delta disk formats, this currently remains unspecified.
	DeltaDiskFormatVariant string `xml:"deltaDiskFormatVariant,omitempty" json:"deltaDiskFormatVariant,omitempty"`
	// The sharing mode of the virtual disk.
	//
	// See `VirtualDiskSharing_enum`. The default value is
	// no sharing.
	Sharing string `xml:"sharing,omitempty" json:"sharing,omitempty"`
	// Virtual Disk Backing encryption options.
	//
	// On modification operations the value is ignored, use the specification
	// `VirtualDeviceConfigSpecBackingSpec.crypto` in
	// `VirtualDeviceConfigSpec.backing`.
	KeyId *CryptoKeyId `xml:"keyId,omitempty" json:"keyId,omitempty"`
}

func init() {
	t["VirtualDiskFlatVer2BackingInfo"] = reflect.TypeOf((*VirtualDiskFlatVer2BackingInfo)(nil)).Elem()
}

// This data object type contains the available options when backing a virtual
// disk using a host file with the flat file format used in VMware Server and
// in ESX Server 2.x and greater.
//
// Flat disks are pre-allocated, whereas sparse disks are grown as needed.
type VirtualDiskFlatVer2BackingOption struct {
	VirtualDeviceFileBackingOption

	// The disk mode.
	//
	// Valid disk modes are:
	//   - `persistent`
	//   - `independent_persistent`
	//   - `independent_nonpersistent`
	//
	// See also `VirtualDiskMode_enum`.
	DiskMode ChoiceOption `xml:"diskMode" json:"diskMode"`
	// Flag to indicate whether or not the host supports
	// allowing the client to select whether or not a disk
	// should be split.
	Split BoolOption `xml:"split" json:"split"`
	// Flag to indicate whether or not the host supports
	// allowing the client to select "writethrough" as a mode for
	// virtual disks.
	//
	// Typically, this is available only for VMware Server Linux hosts.
	WriteThrough BoolOption `xml:"writeThrough" json:"writeThrough"`
	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation.
	//
	// If set to true, reconfiguring this virtual disk
	// with a `VirtualDisk.capacityInKB` value greater
	// than its current value will grow the disk to the newly specified size.
	Growable bool `xml:"growable" json:"growable"`
	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation while
	// the virtual machine is powered on.
	//
	// If set to true, reconfiguring this virtual disk
	// with a `VirtualDisk.capacityInKB` value greater
	// than its current value will grow the disk to the newly specified size
	// while the virtual machine is powered on.
	HotGrowable bool `xml:"hotGrowable" json:"hotGrowable"`
	// Flag to indicate whether this backing supports disk UUID property.
	Uuid bool `xml:"uuid" json:"uuid"`
	// Flag to indicate if this backing supports thin-provisioned disks.
	//
	// When creating a thin-provisioned disk (or converting an existing disk to
	// to a thin-provisioned one), both the target datastore and the
	// host accessing it must support thin-provisioning. This flag indicates only
	// the host capability. See `DatastoreCapability.perFileThinProvisioningSupported`
	// for datastore capability.
	ThinProvisioned *BoolOption `xml:"thinProvisioned,omitempty" json:"thinProvisioned,omitempty"`
	// Flag to indicate if this backing supports eager scrubbing.
	EagerlyScrub *BoolOption `xml:"eagerlyScrub,omitempty" json:"eagerlyScrub,omitempty"`
	// Deprecated as of vSphere API 5.1, please use
	// `VirtualDiskFlatVer2BackingOption.deltaDiskFormatsSupported`.
	//
	// Delta disk formats supported.
	//
	// Valid values are:
	//   - `redoLogFormat`
	//   - `nativeFormat`
	DeltaDiskFormat *ChoiceOption `xml:"deltaDiskFormat,omitempty" json:"deltaDiskFormat,omitempty"`
	// Delta disk formats supported for each datastore type.
	DeltaDiskFormatsSupported []VirtualDiskDeltaDiskFormatsSupported `xml:"deltaDiskFormatsSupported,omitempty" json:"deltaDiskFormatsSupported,omitempty"`
}

func init() {
	t["VirtualDiskFlatVer2BackingOption"] = reflect.TypeOf((*VirtualDiskFlatVer2BackingOption)(nil)).Elem()
}

// Identifier for a virtual disk.
type VirtualDiskId struct {
	DynamicData

	// Virtual machine reference.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Device ID `VirtualDevice.key` of the virtual disk.
	DiskId int32 `xml:"diskId" json:"diskId"`
}

func init() {
	t["VirtualDiskId"] = reflect.TypeOf((*VirtualDiskId)(nil)).Elem()
}

// This data object type contains information about backing a virtual disk
// using non-volatile memory technologies (persistent memory).
//
// Supported for ESX Server 6.5 and later.
type VirtualDiskLocalPMemBackingInfo struct {
	VirtualDeviceFileBackingInfo

	// The disk persistence mode.
	//
	// See also `VirtualDiskMode_enum`.
	DiskMode string `xml:"diskMode" json:"diskMode"`
	// Disk UUID for the virtual disk, if available.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// Persistent memory volume UUID - UUID which associates this
	// virtual disk with a specific host.
	//
	// This is read only property.
	//
	// See also `HostPersistentMemoryInfo.volumeUUID`.
	VolumeUUID string `xml:"volumeUUID,omitempty" json:"volumeUUID,omitempty"`
	// Content ID of the virtual disk file, if available.
	//
	// A content ID indicates the logical contents of the disk backing and
	// its parents.
	//
	// This property is only guaranteed to be up to date if this disk backing
	// is not currently being written to by any virtual machine.
	//
	// The only supported operation is comparing if two content IDs are equal
	// or not. The guarantee provided by the content ID is that if two disk
	// backings have the same content ID and are not currently being written
	// to, then reads issued from the guest operating system to those disk
	// backings will return the same data.
	ContentId string `xml:"contentId,omitempty" json:"contentId,omitempty"`
}

func init() {
	t["VirtualDiskLocalPMemBackingInfo"] = reflect.TypeOf((*VirtualDiskLocalPMemBackingInfo)(nil)).Elem()
}

// This data object type contains the available options when backing
// a virtualdisk using persistent memory.
type VirtualDiskLocalPMemBackingOption struct {
	VirtualDeviceFileBackingOption

	// The disk mode.
	//
	// See also `VirtualDiskMode_enum`.
	DiskMode ChoiceOption `xml:"diskMode" json:"diskMode"`
	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation.
	//
	// If set to true, reconfiguring this virtual disk
	// with a `VirtualDisk.capacityInKB` value greater
	// than its current value will grow the disk to the newly specified size.
	Growable bool `xml:"growable" json:"growable"`
	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation while
	// the virtual machine is powered on.
	//
	// If set to true, reconfiguring this virtual disk
	// with a `VirtualDisk.capacityInKB` value greater
	// than its current value will grow the disk to the newly specified size
	// while the virtual machine is powered on.
	HotGrowable bool `xml:"hotGrowable" json:"hotGrowable"`
	// Flag to indicate whether this backing supports disk UUID property.
	Uuid bool `xml:"uuid" json:"uuid"`
}

func init() {
	t["VirtualDiskLocalPMemBackingOption"] = reflect.TypeOf((*VirtualDiskLocalPMemBackingOption)(nil)).Elem()
}

// The disk mode of the specified virtual disk is not supported.
//
// Typically, this fault is returned as part of a parent fault like
// `VmConfigIncompatibleForFaultTolerance`, indicating that the
// virtual disk's mode needs to be changed before fault tolerance can be
// enabled on the associated virtual machine.
type VirtualDiskModeNotSupported struct {
	DeviceNotSupported

	// Disk mode that is not supported
	Mode string `xml:"mode" json:"mode"`
}

func init() {
	t["VirtualDiskModeNotSupported"] = reflect.TypeOf((*VirtualDiskModeNotSupported)(nil)).Elem()
}

type VirtualDiskModeNotSupportedFault VirtualDiskModeNotSupported

func init() {
	t["VirtualDiskModeNotSupportedFault"] = reflect.TypeOf((*VirtualDiskModeNotSupportedFault)(nil)).Elem()
}

// The VirtualDiskOption data class contains the options for the
// virtual disk data object type.
type VirtualDiskOption struct {
	VirtualDeviceOption

	// Minimum, maximum, and default capacity of the disk.
	CapacityInKB LongOption `xml:"capacityInKB" json:"capacityInKB"`
	// Deprecated as of vSphere8.0 U3, and there is no replacement for it.
	//
	// Minimum, maximum, and default values for Storage I/O allocation.
	//
	// See also `StorageIOAllocationInfo`.
	IoAllocationOption *StorageIOAllocationOption `xml:"ioAllocationOption,omitempty" json:"ioAllocationOption,omitempty"`
	// Deprecated since vSphere 7.0 because vFlash Read Cache
	// end of availability.
	//
	// vFlash cache configuration on the disk.
	VFlashCacheConfigOption *VirtualDiskOptionVFlashCacheConfigOption `xml:"vFlashCacheConfigOption,omitempty" json:"vFlashCacheConfigOption,omitempty"`
}

func init() {
	t["VirtualDiskOption"] = reflect.TypeOf((*VirtualDiskOption)(nil)).Elem()
}

// Deprecated since vSphere 7.0 because vFlash Read Cache
// end of availability.
//
// Options for vFlash cache configuration.
type VirtualDiskOptionVFlashCacheConfigOption struct {
	DynamicData

	// Cache data consistency type.
	//
	// See `VirtualDiskVFlashCacheConfigInfoCacheConsistencyType_enum`
	CacheConsistencyType ChoiceOption `xml:"cacheConsistencyType" json:"cacheConsistencyType"`
	// Cache mode
	// See `VirtualDiskVFlashCacheConfigInfoCacheMode_enum`
	CacheMode ChoiceOption `xml:"cacheMode" json:"cacheMode"`
	// Cache reservation
	ReservationInMB LongOption `xml:"reservationInMB" json:"reservationInMB"`
	// Cache block size
	BlockSizeInKB LongOption `xml:"blockSizeInKB" json:"blockSizeInKB"`
}

func init() {
	t["VirtualDiskOptionVFlashCacheConfigOption"] = reflect.TypeOf((*VirtualDiskOptionVFlashCacheConfigOption)(nil)).Elem()
}

// This data object type contains information about backing a virtual disk
// using one or more partitions on a physical disk device.
//
// This type of
// backing is supported for VMware Server.
type VirtualDiskPartitionedRawDiskVer2BackingInfo struct {
	VirtualDiskRawDiskVer2BackingInfo

	// Array of partition indexes.
	//
	// This array identifies the
	// partitions that are used on the physical disk drive.
	Partition []int32 `xml:"partition" json:"partition"`
}

func init() {
	t["VirtualDiskPartitionedRawDiskVer2BackingInfo"] = reflect.TypeOf((*VirtualDiskPartitionedRawDiskVer2BackingInfo)(nil)).Elem()
}

// The VirtualDiskOption.PartitionedRawDiskVer2BackingOption object
// type contains the available options when backing a virtual disk
// using one or more partitions on a physical disk device.
//
// This
// backing is supported in VMware Server.
type VirtualDiskPartitionedRawDiskVer2BackingOption struct {
	VirtualDiskRawDiskVer2BackingOption
}

func init() {
	t["VirtualDiskPartitionedRawDiskVer2BackingOption"] = reflect.TypeOf((*VirtualDiskPartitionedRawDiskVer2BackingOption)(nil)).Elem()
}

// This data object type contains information about backing a virtual disk using a
// raw device mapping.
//
// Supported for ESX Server 2.5 and 3.x.
type VirtualDiskRawDiskMappingVer1BackingInfo struct {
	VirtualDeviceFileBackingInfo

	// Unique identifier of the LUN accessed by the raw disk mapping.
	LunUuid string `xml:"lunUuid,omitempty" json:"lunUuid,omitempty"`
	// The host-specific device the LUN is being accessed through.
	//
	// If the
	// target LUN is not available on the host then it is empty. For example, this
	// could happen if it has accidentally been masked out.
	DeviceName string `xml:"deviceName,omitempty" json:"deviceName,omitempty"`
	// The compatibility mode of the raw disk mapping (RDM).
	//
	// This must be specified
	// when a new virtual disk with an RDM backing is created. On subsequent virtual
	// machine reconfigurations, this property should be handled as follows,
	// depending on the version of the host:
	//
	// On ESX Server 2.5, the compatibility mode of an RDM backing is a
	// characteristic of the virtual machine's configuration. When reconfiguring
	// a virtual machine that currently uses a virtual disk backed by an RDM,
	// the compatibility mode of that backing may be modified. When reconfiguring a
	// virtual machine to add an existing virtual disk backed by an RDM, the
	// compatibility mode of that backing may be specified. If left unspecified it
	// defaults to "physicalMode".
	//
	// On ESX Server 3.x, the compatibility mode of an RDM backing is a
	// characteristic of the RDM itself. Once the RDM is created, its compatibility
	// mode cannot be changed by reconfiguring the virtual machine. When
	// reconfiguring a virtual machine to add an existing virtual disk backed by an
	// RDM, the compatibility mode of that backing must be left unspecified.
	//
	// See also `VirtualDiskCompatibilityMode_enum`.
	CompatibilityMode string `xml:"compatibilityMode,omitempty" json:"compatibilityMode,omitempty"`
	// The disk mode.
	//
	// Valid values are:
	//   - `persistent`
	//   - `independent_persistent`
	//   - `independent_nonpersistent`
	//   - `nonpersistent`
	//   - `undoable`
	//   - `append`
	//
	// Disk modes are only supported when the raw disk mapping is using virtual
	// compatibility mode.
	//
	// See also `VirtualDiskMode_enum`.
	DiskMode string `xml:"diskMode,omitempty" json:"diskMode,omitempty"`
	// Disk UUID for the virtual disk, if available.
	//
	// Disk UUID is not available if
	// the raw disk mapping is in physical compatibility mode.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// Content ID of the virtual disk file, if available.
	//
	// A content ID indicates the logical contents of the disk backing and its parents.
	//
	// This property is only guaranteed to be up to date if this disk backing is not
	// currently being written to by any virtual machine.
	//
	// The only supported operation is comparing if two content IDs are equal or not.
	// The guarantee provided by the content ID is that if two disk backings have the
	// same content ID and are not currently being written to, then reads issued from
	// the guest operating system to those disk backings will return the same data.
	ContentId string `xml:"contentId,omitempty" json:"contentId,omitempty"`
	// The change ID of the virtual disk for the corresponding
	// snapshot or virtual machine.
	//
	// This can be used to track
	// incremental changes to a virtual disk. See
	// `VirtualMachine.QueryChangedDiskAreas`.
	ChangeId string `xml:"changeId,omitempty" json:"changeId,omitempty"`
	// The parent of this virtual disk file, if this is a delta disk backing.
	//
	// This will be unset if this is not a delta disk backing.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time. A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent). After a delta
	// disk backing is added, all writes go to the delta disk backing. All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// A delta disk backing can be added to a disk either implicitly during
	// snapshot operations, or explicitly during create or reconfigure of the virtual
	// machine.
	//
	// Note that the type of the backing is consistent throughout the chain; any new
	// delta disk backing which is added is of the same type as the original disk .
	// Also note that since the parent backing is not being written to,
	// it is possible that the parent backing may be shared among multiple
	// disks belonging to multiple virtual machines.
	//
	// During virtual machine `creation` and
	// `reconfiguration` this property is
	// only checked if the `VirtualDeviceConfigSpec` specifies
	// an *add operation* with a
	// *create file operation*.
	// In this case, a new delta disk backing is created which points to the parent
	// disk backing. Only the `fileName`
	// property is important; all other properties will be ignored. The parent backing
	// is assumed to exist and will not be recursively created.
	//
	// Only raw disk mappings in *virtual compatibility mode* can have parents.
	//
	// This property may only be set if
	// `deltaDiskBackingsSupported`
	// is true.
	Parent *VirtualDiskRawDiskMappingVer1BackingInfo `xml:"parent,omitempty" json:"parent,omitempty"`
	// The format of the delta disk.
	//
	// This field is valid only for a delta disk.
	//
	// See `DeltaDiskFormat` for the
	// supported formats. The default value used for VM with hardware
	// version 8 and lower is
	// `redoLogFormat`.
	// The default value used for VM with hardware
	// version 9 and higher is
	// `seSparseFormat`.
	//
	// `nativeFormat` is not
	// supported for bask disk of type RawDiskMappingVer1BackingInfo.
	DeltaDiskFormat string `xml:"deltaDiskFormat,omitempty" json:"deltaDiskFormat,omitempty"`
	// Grain size in kB for a delta disk of format type seSparseFormat.
	//
	// The default
	// size is 4 kB.
	// The grain size of
	// `Flex-SE` delta disks
	// when the base disk is of type RawDiskMappingVer1BackingInfo.
	// The `DeltaDiskFormat` must also
	// be set to seSparseFormat.
	DeltaGrainSize int32 `xml:"deltaGrainSize,omitempty" json:"deltaGrainSize,omitempty"`
	// The sharing mode of the virtual disk.
	//
	// See `VirtualDiskSharing_enum`. The default value is
	// no sharing.
	Sharing string `xml:"sharing,omitempty" json:"sharing,omitempty"`
}

func init() {
	t["VirtualDiskRawDiskMappingVer1BackingInfo"] = reflect.TypeOf((*VirtualDiskRawDiskMappingVer1BackingInfo)(nil)).Elem()
}

// The VirtualDiskOption.RawDiskMappingVer1BackingOption object type
// contains the available options when backing a virtual disk using
// a raw device mapping on ESX Server 2.5 or 3.x.
type VirtualDiskRawDiskMappingVer1BackingOption struct {
	VirtualDeviceDeviceBackingOption

	// Valid extensions for the filename of the optional
	// raw disk mapping descriptor file.
	//
	// This is present only for ESX Server 3.x and greater hosts.
	DescriptorFileNameExtensions *ChoiceOption `xml:"descriptorFileNameExtensions,omitempty" json:"descriptorFileNameExtensions,omitempty"`
	// The supported raw disk mapping compatibility modes.
	//
	// See also `VirtualDiskCompatibilityMode_enum`.
	CompatibilityMode ChoiceOption `xml:"compatibilityMode" json:"compatibilityMode"`
	// The disk mode.
	//
	// Valid values are:
	//   - `persistent`
	//   - `independent_persistent`
	//   - `independent_nonpersistent`
	//
	// See also `VirtualDiskMode_enum`.
	DiskMode ChoiceOption `xml:"diskMode" json:"diskMode"`
	// Flag to indicate whether this backing supports disk UUID property.
	Uuid bool `xml:"uuid" json:"uuid"`
}

func init() {
	t["VirtualDiskRawDiskMappingVer1BackingOption"] = reflect.TypeOf((*VirtualDiskRawDiskMappingVer1BackingOption)(nil)).Elem()
}

// This data object type contains information about backing a virtual disk by
// using a host device, as used by VMware Server.
type VirtualDiskRawDiskVer2BackingInfo struct {
	VirtualDeviceDeviceBackingInfo

	// The name of the raw disk descriptor file.
	DescriptorFileName string `xml:"descriptorFileName" json:"descriptorFileName"`
	// Disk UUID for the virtual disk, if available.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// The change ID of the virtual disk for the corresponding
	// snapshot or virtual machine.
	//
	// This can be used to track
	// incremental changes to a virtual disk. See
	// `VirtualMachine.QueryChangedDiskAreas`.
	ChangeId string `xml:"changeId,omitempty" json:"changeId,omitempty"`
	// The sharing mode of the virtual disk.
	//
	// See `VirtualDiskSharing_enum`. The default value is
	// no sharing.
	Sharing string `xml:"sharing,omitempty" json:"sharing,omitempty"`
}

func init() {
	t["VirtualDiskRawDiskVer2BackingInfo"] = reflect.TypeOf((*VirtualDiskRawDiskVer2BackingInfo)(nil)).Elem()
}

// The VirtualDiskOption.RawDiskVer2BackingOption object type
// contains the available options when backing a virtual disk
// using a host device on VMware Server.
type VirtualDiskRawDiskVer2BackingOption struct {
	VirtualDeviceDeviceBackingOption

	// Valid extensions for the filename of the raw disk descriptor
	// file.
	DescriptorFileNameExtensions ChoiceOption `xml:"descriptorFileNameExtensions" json:"descriptorFileNameExtensions"`
	// Flag to indicate whether this backing supports disk UUID property.
	Uuid bool `xml:"uuid" json:"uuid"`
}

func init() {
	t["VirtualDiskRawDiskVer2BackingOption"] = reflect.TypeOf((*VirtualDiskRawDiskVer2BackingOption)(nil)).Elem()
}

// The set of virtual disks that are currently disabled
type VirtualDiskRuleSpec struct {
	ClusterRuleInfo

	// Type of the virtual disks rule.
	//
	// The set of possible values are described
	// in `VirtualDiskRuleSpecRuleType_enum`
	DiskRuleType string `xml:"diskRuleType" json:"diskRuleType"`
	// The list of virtual disks for this rule.
	DiskId []int32 `xml:"diskId,omitempty" json:"diskId,omitempty"`
}

func init() {
	t["VirtualDiskRuleSpec"] = reflect.TypeOf((*VirtualDiskRuleSpec)(nil)).Elem()
}

// Backing type for virtual disks that use the space efficient
// sparse format.
//
// Space for space efficient sparse disks is allocated on
// demand and optimizations are applied to achieve additional
// space savings. The effective space usage of such a disk can
// be obtained from `VirtualMachineFileLayoutEx`.
type VirtualDiskSeSparseBackingInfo struct {
	VirtualDeviceFileBackingInfo

	// The disk persistence mode.
	//
	// Valid modes are:
	//   - `persistent`
	//   - `independent_persistent`
	//   - `independent_nonpersistent`
	//   - `nonpersistent`
	//   - `undoable`
	//   - `append`
	//
	// See also `VirtualDiskMode_enum`.
	DiskMode string `xml:"diskMode" json:"diskMode"`
	// Flag to indicate whether writes should go directly to the file system
	// or should be buffered.
	WriteThrough *bool `xml:"writeThrough" json:"writeThrough,omitempty"`
	// Disk UUID for the virtual disk, if available.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// Content ID of the virtual disk file, if available.
	//
	// A content ID indicates the logical contents of the disk backing and its parents.
	//
	// This property is only guaranteed to be up to date if this disk backing is not
	// currently being written to by any virtual machine.
	//
	// The only supported operation is comparing if two content IDs are equal or not.
	// The guarantee provided by the content ID is that if two disk backings have the
	// same content ID and are not currently being written to, then reads issued from
	// the guest operating system to those disk backings will return the same data.
	ContentId string `xml:"contentId,omitempty" json:"contentId,omitempty"`
	// The change ID of the virtual disk for the corresponding
	// snapshot or virtual machine.
	//
	// This can be used to track
	// incremental changes to a virtual disk. See `VirtualMachine.QueryChangedDiskAreas`.
	ChangeId string `xml:"changeId,omitempty" json:"changeId,omitempty"`
	// The parent of this virtual disk file, if this is a delta disk backing.
	//
	// This will be unset if this is not a delta disk backing.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time. A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent). After a delta
	// disk backing is added, all writes go to the delta disk backing. All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// A delta disk backing can be added to a disk either implicitly during
	// snapshot operations, or explicitly during create or reconfigure of the virtual
	// machine.
	//
	// Note that the type of the backing is consistent throughout the chain; any new
	// delta disk backing which is added is of the same type as the original disk .
	// Also note that since the parent backing is not being written to,
	// it is possible that the parent backing may be shared among multiple
	// disks belonging to multiple virtual machines.
	//
	// During virtual machine `creation` and
	// `reconfiguration` this property is
	// only checked if the `VirtualDeviceConfigSpec` specifies
	// an *add operation* with a
	// *create file operation*.
	// In this case, a new delta disk backing is created which points to the parent
	// disk backing. Only the `fileName`
	// property is important; all other properties will be ignored. The parent backing
	// is assumed to exist and will not be recursively created.
	//
	// This property may only be set if
	// `deltaDiskBackingsSupported`
	// is true.
	Parent *VirtualDiskSeSparseBackingInfo `xml:"parent,omitempty" json:"parent,omitempty"`
	// The format of the delta disk.
	//
	// This field is valid only for a delta disk.
	//
	// See `DeltaDiskFormat` for the
	// supported formats. If not specified, the default value used is
	// `redoLogFormat`.
	DeltaDiskFormat string `xml:"deltaDiskFormat,omitempty" json:"deltaDiskFormat,omitempty"`
	// Indicates whether the disk backing has digest file enabled.
	DigestEnabled *bool `xml:"digestEnabled" json:"digestEnabled,omitempty"`
	// Specify the grain size in kB.
	//
	// The default size is 4 kB.
	GrainSize int32 `xml:"grainSize,omitempty" json:"grainSize,omitempty"`
	// Virtual Disk Backing encryption options.
	//
	// On modification operations the value is ignored, use the specification
	// `VirtualDeviceConfigSpecBackingSpec.crypto` in
	// `VirtualDeviceConfigSpec.backing`.
	KeyId *CryptoKeyId `xml:"keyId,omitempty" json:"keyId,omitempty"`
}

func init() {
	t["VirtualDiskSeSparseBackingInfo"] = reflect.TypeOf((*VirtualDiskSeSparseBackingInfo)(nil)).Elem()
}

// Backing options for virtual disks that use the space
// efficient sparse format.
//
// Space for Flex-SE disks is allocated on demand and
// optimizations are applied to achieve additional
// space savings.
type VirtualDiskSeSparseBackingOption struct {
	VirtualDeviceFileBackingOption

	// The disk mode.
	//
	// Valid disk modes are:
	//   - `persistent`
	//   - `independent_persistent`
	//   - `independent_nonpersistent`
	//
	// See also `VirtualDiskMode_enum`.
	DiskMode ChoiceOption `xml:"diskMode" json:"diskMode"`
	// Flag to indicate whether or not the host supports
	// allowing the client to select "writethrough" as a mode for
	// virtual disks.
	//
	// Typically, this is available only for VMware Server Linux hosts.
	WriteThrough BoolOption `xml:"writeThrough" json:"writeThrough"`
	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation.
	//
	// If set to true, reconfiguring this virtual disk
	// with a `VirtualDisk.capacityInKB` value greater
	// than its current value will grow the disk to the newly specified size.
	Growable bool `xml:"growable" json:"growable"`
	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation while
	// the virtual machine is powered on.
	//
	// If set to true, reconfiguring this virtual disk
	// with a `VirtualDisk.capacityInKB` value greater
	// than its current value will grow the disk to the newly specified size
	// while the virtual machine is powered on.
	HotGrowable bool `xml:"hotGrowable" json:"hotGrowable"`
	// Flag to indicate whether this backing supports disk UUID property.
	Uuid bool `xml:"uuid" json:"uuid"`
	// Delta disk formats supported for each datastore type.
	DeltaDiskFormatsSupported []VirtualDiskDeltaDiskFormatsSupported `xml:"deltaDiskFormatsSupported" json:"deltaDiskFormatsSupported"`
}

func init() {
	t["VirtualDiskSeSparseBackingOption"] = reflect.TypeOf((*VirtualDiskSeSparseBackingOption)(nil)).Elem()
}

// This data object type contains information about backing a virtual disk by
// using a virtual disk file on the host, in the sparse disk format used by
// GSX Server 2.x.
type VirtualDiskSparseVer1BackingInfo struct {
	VirtualDeviceFileBackingInfo

	// The disk persistence mode.
	//
	// Valid values are:
	//   - `persistent`
	//   - `nonpersistent`
	//   - `undoable`
	//   - `independent_persistent`
	//   - `independent_nonpersistent`
	//   - `append`
	//
	// See also `VirtualDiskMode_enum`.
	DiskMode string `xml:"diskMode" json:"diskMode"`
	// Flag to indicate the type of virtual disk file: split or monolithic.
	//
	// If true, the virtual disk is stored in multiple files, each 2GB.
	Split *bool `xml:"split" json:"split,omitempty"`
	// Flag to indicate whether writes should go directly to the file system
	// or should be buffered.
	WriteThrough *bool `xml:"writeThrough" json:"writeThrough,omitempty"`
	// The space in use for this sparse disk.
	//
	// This information is provided
	// when retrieving configuration information for an existing virtual
	// machine. The client cannot modify this information using reconfigure
	// on a virtual machine.
	SpaceUsedInKB int64 `xml:"spaceUsedInKB,omitempty" json:"spaceUsedInKB,omitempty"`
	// Content ID of the virtual disk file, if available.
	//
	// A content ID indicates the logical contents of the disk backing and its parents.
	//
	// This property is only guaranteed to be up to date if this disk backing is not
	// currently being written to by any virtual machine.
	//
	// The only supported operation is comparing if two content IDs are equal or not.
	// The guarantee provided by the content ID is that if two disk backings have the
	// same content ID and are not currently being written to, then reads issued from
	// the guest operating system to those disk backings will return the same data.
	ContentId string `xml:"contentId,omitempty" json:"contentId,omitempty"`
	// The parent of this virtual disk file, if this is a delta disk backing.
	//
	// This will be unset if this is not a delta disk backing.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time. A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent). After a delta
	// disk backing is added, all writes go to the delta disk backing. All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// A delta disk backing can be added to a disk either implicitly during
	// snapshot operations, or explicitly during create or reconfigure of the virtual
	// machine.
	//
	// Note that the type of the backing is consistent throughout the chain; any new
	// delta disk backing which is added is of the same type as the original disk .
	// Also note that since the parent backing is not being written to,
	// it is possible that the parent backing may be shared among multiple
	// disks belonging to multiple virtual machines.
	//
	// During virtual machine `creation` and
	// `reconfiguration` this property is
	// only checked if the `VirtualDeviceConfigSpec` specifies
	// an *add operation* with a
	// *create file operation*.
	// In this case, a new delta disk backing is created which points to the parent
	// disk backing. Only the `fileName`
	// property is important; all other properties will be ignored. The parent backing
	// is assumed to exist and will not be recursively created.
	//
	// This property may only be set if
	// `deltaDiskBackingsSupported`
	// is true.
	Parent *VirtualDiskSparseVer1BackingInfo `xml:"parent,omitempty" json:"parent,omitempty"`
}

func init() {
	t["VirtualDiskSparseVer1BackingInfo"] = reflect.TypeOf((*VirtualDiskSparseVer1BackingInfo)(nil)).Elem()
}

// This data object type contains the available options when backing a virtual
// disk using a host file with the sparse file format from GSX Server 2.x.
type VirtualDiskSparseVer1BackingOption struct {
	VirtualDeviceFileBackingOption

	// The disk mode.
	//
	// Valid disk modes are:
	//   - `persistent`
	//   - `nonpersistent`
	//   - `undoable`
	//   - `independent_persistent`
	//   - `independent_nonpersistent`
	//   - `append`
	//
	// See also `VirtualDiskMode_enum`.
	DiskModes ChoiceOption `xml:"diskModes" json:"diskModes"`
	// Flag to indicate whether or not the host supports
	// allowing the client to select whether or not a sparse disk
	// should be split.
	Split BoolOption `xml:"split" json:"split"`
	// Flag to indicate whether or not the host supports
	// allowing the client to select "writethrough" as a mode for
	// virtual disks.
	//
	// Typically, this is available only for VMware Server Linux hosts.
	WriteThrough BoolOption `xml:"writeThrough" json:"writeThrough"`
	// Flag to indicate whether this backing can have its size changed.
	Growable bool `xml:"growable" json:"growable"`
}

func init() {
	t["VirtualDiskSparseVer1BackingOption"] = reflect.TypeOf((*VirtualDiskSparseVer1BackingOption)(nil)).Elem()
}

// This data object type contains information about backing a virtual disk by
// using a virtual disk file on the host, in the sparse disk format used by
// VMware Server.
type VirtualDiskSparseVer2BackingInfo struct {
	VirtualDeviceFileBackingInfo

	// The disk persistence mode.
	//
	// Valid modes are:
	//   - `persistent`
	//   - `independent_persistent`
	//   - `independent_nonpersistent`
	//
	// See also `VirtualDiskMode_enum`.
	DiskMode string `xml:"diskMode" json:"diskMode"`
	// Flag to indicate the type of virtual disk file: split or monolithic.
	//
	// If true, the virtual disk is stored in multiple files, each 2GB.
	Split *bool `xml:"split" json:"split,omitempty"`
	// Flag to indicate whether writes should go directly to the file system
	// or should be buffered.
	WriteThrough *bool `xml:"writeThrough" json:"writeThrough,omitempty"`
	// The space in use for this sparse disk.
	//
	// This information is provided
	// when retrieving configuration information for an exisiting virtual
	// machine. The client cannot modify this information using reconfigure
	// on a virtual machine.
	SpaceUsedInKB int64 `xml:"spaceUsedInKB,omitempty" json:"spaceUsedInKB,omitempty"`
	// Disk UUID for the virtual disk, if available.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// Content ID of the virtual disk file, if available.
	//
	// A content ID indicates the logical contents of the disk backing and its parents.
	//
	// This property is only guaranteed to be up to date if this disk backing is not
	// currently being written to by any virtual machine.
	//
	// The only supported operation is comparing if two content IDs are equal or not.
	// The guarantee provided by the content ID is that if two disk backings have the
	// same content ID and are not currently being written to, then reads issued from
	// the guest operating system to those disk backings will return the same data.
	ContentId string `xml:"contentId,omitempty" json:"contentId,omitempty"`
	// The change ID of the virtual disk for the corresponding
	// snapshot or virtual machine.
	//
	// This can be used to track
	// incremental changes to a virtual disk. See
	// `VirtualMachine.QueryChangedDiskAreas`.
	ChangeId string `xml:"changeId,omitempty" json:"changeId,omitempty"`
	// The parent of this virtual disk file, if this is a delta disk backing.
	//
	// This will be unset if this is not a delta disk backing.
	//
	// A delta disk backing is a way to preserve a virtual disk backing
	// at some point in time. A delta disk backing is a file backing which in
	// turn points to the original virtual disk backing (the parent). After a delta
	// disk backing is added, all writes go to the delta disk backing. All reads
	// first try the delta disk backing and then try the parent backing if needed.
	//
	// A delta disk backing can be added to a disk either implicitly during
	// snapshot operations, or explicitly during create or reconfigure of the virtual
	// machine.
	//
	// Note that the type of the backing is consistent throughout the chain; any new
	// delta disk backing which is added is of the same type as the original disk .
	// Also note that since the parent backing is not being written to,
	// it is possible that the parent backing may be shared among multiple
	// disks belonging to multiple virtual machines.
	//
	// During virtual machine `creation` and
	// `reconfiguration` this property is
	// only checked if the `VirtualDeviceConfigSpec` specifies
	// an *add operation* with a
	// *create file operation*.
	// In this case, a new delta disk backing is created which points to the parent
	// disk backing. Only the `fileName`
	// property is important; all other properties will be ignored. The parent backing
	// is assumed to exist and will not be recursively created.
	//
	// This property may only be set if
	// `deltaDiskBackingsSupported`
	// is true.
	Parent *VirtualDiskSparseVer2BackingInfo `xml:"parent,omitempty" json:"parent,omitempty"`
	// Virtual Disk Backing encryption options.
	//
	// On modification operations the value is ignored, use the specification
	// `VirtualDeviceConfigSpecBackingSpec.crypto` in
	// `VirtualDeviceConfigSpec.backing`.
	KeyId *CryptoKeyId `xml:"keyId,omitempty" json:"keyId,omitempty"`
}

func init() {
	t["VirtualDiskSparseVer2BackingInfo"] = reflect.TypeOf((*VirtualDiskSparseVer2BackingInfo)(nil)).Elem()
}

// This data object type contains the options available when backing a virtual
// disk using a host file with the sparse file format from VMware Server.
type VirtualDiskSparseVer2BackingOption struct {
	VirtualDeviceFileBackingOption

	// The disk mode.
	//
	// Valid disk modes are:
	//   - `persistent`
	//   - `nonpersistent`
	//   - `undoable`
	//   - `independent_persistent`
	//   - `independent_nonpersistent`
	//   - `append`
	//
	// See also `VirtualDiskMode_enum`.
	DiskMode ChoiceOption `xml:"diskMode" json:"diskMode"`
	// Flag to indicate whether or not the host supports
	// allowing the client to select whether or not a sparse disk
	// should be split.
	Split BoolOption `xml:"split" json:"split"`
	// Flag to indicate whether or not the host supports
	// allowing the client to select "writethrough" as a mode for
	// virtual disks.
	//
	// Typically, this is available only for VMware Server Linux hosts.
	WriteThrough BoolOption `xml:"writeThrough" json:"writeThrough"`
	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation.
	//
	// If set to true, reconfiguring this virtual disk
	// with a `VirtualDisk.capacityInKB` value greater
	// than its current value will grow the disk to the newly specified size.
	Growable bool `xml:"growable" json:"growable"`
	// Indicates whether or not this disk backing can be
	// extended to larger sizes through a reconfigure operation while
	// the virtual machine is powered on.
	//
	// If set to true, reconfiguring this virtual disk
	// with a `VirtualDisk.capacityInKB` value greater
	// than its current value will grow the disk to the newly specified size
	// while the virtual machine is powered on.
	HotGrowable bool `xml:"hotGrowable" json:"hotGrowable"`
	// Flag to indicate whether this backing supports disk UUID property.
	Uuid bool `xml:"uuid" json:"uuid"`
}

func init() {
	t["VirtualDiskSparseVer2BackingOption"] = reflect.TypeOf((*VirtualDiskSparseVer2BackingOption)(nil)).Elem()
}

// Specification used to create or clone a virtual disk
type VirtualDiskSpec struct {
	DynamicData

	// The type of the new virtual disk.
	//
	// See also `VirtualDiskType_enum`.
	DiskType string `xml:"diskType" json:"diskType"`
	// The type of the virtual disk adapter for the new virtual disk.
	//
	// See also `VirtualDiskAdapterType_enum`.
	AdapterType string `xml:"adapterType" json:"adapterType"`
}

func init() {
	t["VirtualDiskSpec"] = reflect.TypeOf((*VirtualDiskSpec)(nil)).Elem()
}

// Data object describes the vFlash cache configuration on this virtual disk.
type VirtualDiskVFlashCacheConfigInfo struct {
	DynamicData

	// Deprecated since vSphere 7.0 because vFlash Read Cache
	// end of availability.
	//
	// Name of vFlash module which manages the cache.
	//
	// If not specified, default setting
	// `HostVFlashManagerVFlashCacheConfigSpec.defaultVFlashModule`
	// will be used.
	VFlashModule string `xml:"vFlashModule,omitempty" json:"vFlashModule,omitempty"`
	// Deprecated since vSphere 7.0 because vFlash Read Cache
	// end of availability.
	//
	// Amount of vFlash resource that is guaranteed available to the cache.
	//
	// If not specified,
	// default reservation will be used.
	ReservationInMB int64 `xml:"reservationInMB,omitempty" json:"reservationInMB,omitempty"`
	// Deprecated since vSphere 7.0 because vFlash Read Cache
	// end of availability.
	//
	// Cache data consistency types after a crash.
	//
	// See `VirtualDiskVFlashCacheConfigInfoCacheConsistencyType_enum`
	// for supported types. If not specified, the default value used is
	// `strong`
	CacheConsistencyType string `xml:"cacheConsistencyType,omitempty" json:"cacheConsistencyType,omitempty"`
	// Deprecated since vSphere 7.0 because vFlash Read Cache
	// end of availability.
	//
	// Cache modes.
	//
	// See `VirtualDiskVFlashCacheConfigInfoCacheMode_enum`
	// for supported modes. If not specified, the default value used is
	// `write_thru`.
	CacheMode string `xml:"cacheMode,omitempty" json:"cacheMode,omitempty"`
	// Deprecated since vSphere 7.0 because vFlash Read Cache
	// end of availability.
	//
	// Cache block size.
	//
	// This parameter allows the user to control how much
	// data gets cached on a single access to the VMDK. Max block size is 1MB.
	// Default is 4KB.
	BlockSizeInKB int64 `xml:"blockSizeInKB,omitempty" json:"blockSizeInKB,omitempty"`
}

func init() {
	t["VirtualDiskVFlashCacheConfigInfo"] = reflect.TypeOf((*VirtualDiskVFlashCacheConfigInfo)(nil)).Elem()
}

// The VirtualE1000 data object type represents an instance
// of the E1000 virtual Ethernet adapter attached to a virtual machine.
type VirtualE1000 struct {
	VirtualEthernetCard
}

func init() {
	t["VirtualE1000"] = reflect.TypeOf((*VirtualE1000)(nil)).Elem()
}

// The VirtualE1000 option data object type contains the options for the
// `VirtualE1000` data object type.
type VirtualE1000Option struct {
	VirtualEthernetCardOption
}

func init() {
	t["VirtualE1000Option"] = reflect.TypeOf((*VirtualE1000Option)(nil)).Elem()
}

// The VirtualE1000e data object type represents an instance
// of the E1000e virtual Ethernet adapter attached to a virtual machine.
type VirtualE1000e struct {
	VirtualEthernetCard
}

func init() {
	t["VirtualE1000e"] = reflect.TypeOf((*VirtualE1000e)(nil)).Elem()
}

// The VirtualE1000e option data object type contains the options for the
// `VirtualE1000e` data object type.
type VirtualE1000eOption struct {
	VirtualEthernetCardOption
}

func init() {
	t["VirtualE1000eOption"] = reflect.TypeOf((*VirtualE1000eOption)(nil)).Elem()
}

// The VirtualEnsoniq1371 data object type represents an Ensoniq 1371
// sound card in a virtual machine.
type VirtualEnsoniq1371 struct {
	VirtualSoundCard
}

func init() {
	t["VirtualEnsoniq1371"] = reflect.TypeOf((*VirtualEnsoniq1371)(nil)).Elem()
}

// The VirtualEnsoniq1371Option data object type contains the options for the
// virtual Ensoniq 1371 sound card.
type VirtualEnsoniq1371Option struct {
	VirtualSoundCardOption
}

func init() {
	t["VirtualEnsoniq1371Option"] = reflect.TypeOf((*VirtualEnsoniq1371Option)(nil)).Elem()
}

// The `VirtualEthernetCard` data object contains the properties
// of an Ethernet adapter attached to a virtual machine.
type VirtualEthernetCard struct {
	VirtualDevice

	// MAC address type.
	//
	// Valid values for address type are:
	// <dl>
	// <dt>Manual</dt>
	// <dd>Statically assigned MAC address.</dd>
	// <dt>Generated</dt>
	// <dd>Automatically generated MAC address.</dd>
	// <dt>Assigned</dt>
	// <dd>MAC address assigned by VirtualCenter.</dd>
	// </dl>
	AddressType string `xml:"addressType,omitempty" json:"addressType,omitempty"`
	// MAC address assigned to the virtual network adapter.
	//
	// Clients can
	// set this property to any of the allowed address types. The server might
	// override the specified value for "Generated" or "Assigned" if it does not
	// fall in the right ranges or is determined to be a duplicate.
	MacAddress string `xml:"macAddress,omitempty" json:"macAddress,omitempty"`
	// Indicates whether wake-on-LAN is enabled on this virtual network adapter.
	//
	// Clients
	// can set this property to selectively enable or disable wake-on-LAN.
	WakeOnLanEnabled *bool `xml:"wakeOnLanEnabled" json:"wakeOnLanEnabled,omitempty"`
	// Resource requirements of the virtual network adapter
	ResourceAllocation *VirtualEthernetCardResourceAllocation `xml:"resourceAllocation,omitempty" json:"resourceAllocation,omitempty"`
	// An ID assigned to the virtual network adapter by external management plane or
	// controller.
	//
	// The value and format of this property is determined by external
	// management plane or controller, and vSphere doesn't do any validation. It's
	// also up to external management plane or controller to set, unset or maintain
	// this property. Setting this property with an empty string value will unset the
	// property.
	ExternalId string `xml:"externalId,omitempty" json:"externalId,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
	// there is no replacement.
	//
	// Indicates whether UPT(Universal Pass-through) compatibility is enabled
	// on this network adapter.
	//
	// UPT is only compatible for Vmxnet3 adapter.
	// Clients can set this property enabled or disabled if ethernet
	// virtual device is Vmxnet3.
	UptCompatibilityEnabled *bool `xml:"uptCompatibilityEnabled" json:"uptCompatibilityEnabled,omitempty"`
}

func init() {
	t["VirtualEthernetCard"] = reflect.TypeOf((*VirtualEthernetCard)(nil)).Elem()
}

// This data object type contains the options for using a distributed
// virtual port virtual network card backing data object type.
type VirtualEthernetCardDVPortBackingOption struct {
	VirtualDeviceBackingOption
}

func init() {
	t["VirtualEthernetCardDVPortBackingOption"] = reflect.TypeOf((*VirtualEthernetCardDVPortBackingOption)(nil)).Elem()
}

// The `VirtualEthernetCardDistributedVirtualPortBackingInfo`
// data object defines backing for a virtual Ethernet card that connects
// to a distributed virtual switch port or portgroup.
type VirtualEthernetCardDistributedVirtualPortBackingInfo struct {
	VirtualDeviceBackingInfo

	// `DistributedVirtualPort` or `DistributedVirtualPortgroup`
	// connection.
	//
	// To specify a port connection, set the
	// `DistributedVirtualSwitchPortConnection.portKey` property.
	// To specify a portgroup connection, set the
	// `DistributedVirtualSwitchPortConnection.portgroupKey` property.
	//
	// This property will be unset during Virtual Machine or template cloning
	// operation unless it's set to a `DistributedVirtualSwitchPortConnection`
	// object and the portgroup is a late binding portgroup.
	Port DistributedVirtualSwitchPortConnection `xml:"port" json:"port"`
}

func init() {
	t["VirtualEthernetCardDistributedVirtualPortBackingInfo"] = reflect.TypeOf((*VirtualEthernetCardDistributedVirtualPortBackingInfo)(nil)).Elem()
}

// The `VirtualEthernetCardLegacyNetworkBackingInfo` data object
// provides legacy backing for a virtual Ethernet card.
type VirtualEthernetCardLegacyNetworkBackingInfo struct {
	VirtualDeviceDeviceBackingInfo
}

func init() {
	t["VirtualEthernetCardLegacyNetworkBackingInfo"] = reflect.TypeOf((*VirtualEthernetCardLegacyNetworkBackingInfo)(nil)).Elem()
}

// This data object type contains the options
// for using a legacy virtual network card backing data object type.
type VirtualEthernetCardLegacyNetworkBackingOption struct {
	VirtualDeviceDeviceBackingOption
}

func init() {
	t["VirtualEthernetCardLegacyNetworkBackingOption"] = reflect.TypeOf((*VirtualEthernetCardLegacyNetworkBackingOption)(nil)).Elem()
}

// The `VirtualEthernetCardNetworkBackingInfo` data object
// defines network backing for a virtual Ethernet card.
type VirtualEthernetCardNetworkBackingInfo struct {
	VirtualDeviceDeviceBackingInfo

	// Reference to the network managed object to which this backing applies.
	//
	// This is not used during configuration.
	//
	// Refers instance of `Network`.
	Network *ManagedObjectReference `xml:"network,omitempty" json:"network,omitempty"`
	// Deprecated as of vSphere API 4.0, this property is not supported.
	// &nbsp;.
	//
	// &nbsp;
	InPassthroughMode *bool `xml:"inPassthroughMode" json:"inPassthroughMode,omitempty"`
}

func init() {
	t["VirtualEthernetCardNetworkBackingInfo"] = reflect.TypeOf((*VirtualEthernetCardNetworkBackingInfo)(nil)).Elem()
}

// This data object type contains the options for
// the virtual network card backing data object type.
type VirtualEthernetCardNetworkBackingOption struct {
	VirtualDeviceDeviceBackingOption
}

func init() {
	t["VirtualEthernetCardNetworkBackingOption"] = reflect.TypeOf((*VirtualEthernetCardNetworkBackingOption)(nil)).Elem()
}

// The virtual machine's virtual ethernet card is not supported.
type VirtualEthernetCardNotSupported struct {
	DeviceNotSupported
}

func init() {
	t["VirtualEthernetCardNotSupported"] = reflect.TypeOf((*VirtualEthernetCardNotSupported)(nil)).Elem()
}

type VirtualEthernetCardNotSupportedFault VirtualEthernetCardNotSupported

func init() {
	t["VirtualEthernetCardNotSupportedFault"] = reflect.TypeOf((*VirtualEthernetCardNotSupportedFault)(nil)).Elem()
}

// This class defines backing for a virtual Ethernet card that connects
// to an opaque network.
type VirtualEthernetCardOpaqueNetworkBackingInfo struct {
	VirtualDeviceBackingInfo

	// The opaque network ID
	OpaqueNetworkId string `xml:"opaqueNetworkId" json:"opaqueNetworkId"`
	// The opaque network type
	OpaqueNetworkType string `xml:"opaqueNetworkType" json:"opaqueNetworkType"`
}

func init() {
	t["VirtualEthernetCardOpaqueNetworkBackingInfo"] = reflect.TypeOf((*VirtualEthernetCardOpaqueNetworkBackingInfo)(nil)).Elem()
}

// This data object type contains the options for
// the virtual network card backing data object type.
type VirtualEthernetCardOpaqueNetworkBackingOption struct {
	VirtualDeviceBackingOption
}

func init() {
	t["VirtualEthernetCardOpaqueNetworkBackingOption"] = reflect.TypeOf((*VirtualEthernetCardOpaqueNetworkBackingOption)(nil)).Elem()
}

// This data object type contains the options for the
// virtual ethernet card data object type.
type VirtualEthernetCardOption struct {
	VirtualDeviceOption

	// The valid Organizational Unique Identifiers (OUIs)
	// supported by this virtual Ethernet card.
	//
	// <dl>
	// <dt>Supported OUIs for statically assigned MAC addresses:</dt>
	// <dd>"00:50:56"</dd>
	// </dl>
	SupportedOUI ChoiceOption `xml:"supportedOUI" json:"supportedOUI"`
	// The supported MAC address types.
	MacType ChoiceOption `xml:"macType" json:"macType"`
	// Flag to indicate whether or not wake-on-LAN is settable on this device.
	WakeOnLanEnabled BoolOption `xml:"wakeOnLanEnabled" json:"wakeOnLanEnabled"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
	// there is no replacement.
	//
	// Flag to indicate whether VMDirectPath Gen 2 is available on this device.
	VmDirectPathGen2Supported *bool `xml:"vmDirectPathGen2Supported" json:"vmDirectPathGen2Supported,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
	// there is no replacement.
	//
	// Flag to indicate whether Universal Pass-through(UPT) is settable on this device.
	UptCompatibilityEnabled *BoolOption `xml:"uptCompatibilityEnabled,omitempty" json:"uptCompatibilityEnabled,omitempty"`
}

func init() {
	t["VirtualEthernetCardOption"] = reflect.TypeOf((*VirtualEthernetCardOption)(nil)).Elem()
}

// This class specifies the network resource requirement.
type VirtualEthernetCardResourceAllocation struct {
	DynamicData

	// Amount of network bandwidth that is guaranteed to the
	// virtual network adapter.
	//
	// If utilization is less than reservation, the resource can be used by
	// other virtual network adapters. Reservation is not allowed to exceed the
	// value of `VirtualEthernetCardResourceAllocation.limit` if
	// `VirtualEthernetCardResourceAllocation.limit` is set.
	// Units in Mbits/sec.
	Reservation *int64 `xml:"reservation" json:"reservation,omitempty"`
	// Network share.
	//
	// The value is used as a relative weight in
	// competing for shared bandwidth, in case of resource contention.
	Share SharesInfo `xml:"share" json:"share"`
	// The bandwidth limit for the virtual network adapter.
	//
	// The utilization of the virtual network adapter will not
	// exceed this limit, even if there are available resources.
	// To clear the value of this property and revert it to unset,
	// set the vaule to "-1" in an update operation.
	// Units in Mbits/sec.
	Limit *int64 `xml:"limit" json:"limit,omitempty"`
}

func init() {
	t["VirtualEthernetCardResourceAllocation"] = reflect.TypeOf((*VirtualEthernetCardResourceAllocation)(nil)).Elem()
}

// The VirtualFloppy data object type contains information about a floppy drive
// in a virtual machine.
type VirtualFloppy struct {
	VirtualDevice
}

func init() {
	t["VirtualFloppy"] = reflect.TypeOf((*VirtualFloppy)(nil)).Elem()
}

// The data object type for device backing of a virtual floppy drive.
type VirtualFloppyDeviceBackingInfo struct {
	VirtualDeviceDeviceBackingInfo
}

func init() {
	t["VirtualFloppyDeviceBackingInfo"] = reflect.TypeOf((*VirtualFloppyDeviceBackingInfo)(nil)).Elem()
}

// The DeviceBackingOption data object type contains the options
// for the floppy device backing type.
type VirtualFloppyDeviceBackingOption struct {
	VirtualDeviceDeviceBackingOption
}

func init() {
	t["VirtualFloppyDeviceBackingOption"] = reflect.TypeOf((*VirtualFloppyDeviceBackingOption)(nil)).Elem()
}

// The data object type for file image backing of a virtual floppy drive.
type VirtualFloppyImageBackingInfo struct {
	VirtualDeviceFileBackingInfo
}

func init() {
	t["VirtualFloppyImageBackingInfo"] = reflect.TypeOf((*VirtualFloppyImageBackingInfo)(nil)).Elem()
}

// The ImageBackingOption data object type contains the options
// for the floppy image backing type.
type VirtualFloppyImageBackingOption struct {
	VirtualDeviceFileBackingOption
}

func init() {
	t["VirtualFloppyImageBackingOption"] = reflect.TypeOf((*VirtualFloppyImageBackingOption)(nil)).Elem()
}

// The VirtualFloppyOption data class contains the options for the
// virtual floppy data object type.
type VirtualFloppyOption struct {
	VirtualDeviceOption
}

func init() {
	t["VirtualFloppyOption"] = reflect.TypeOf((*VirtualFloppyOption)(nil)).Elem()
}

// The data object type for remote device backing of a virtual floppy drive.
type VirtualFloppyRemoteDeviceBackingInfo struct {
	VirtualDeviceRemoteDeviceBackingInfo
}

func init() {
	t["VirtualFloppyRemoteDeviceBackingInfo"] = reflect.TypeOf((*VirtualFloppyRemoteDeviceBackingInfo)(nil)).Elem()
}

// The RemoteDeviceBackingOption data object type contains the options
// for the floppy remote device backing type.
type VirtualFloppyRemoteDeviceBackingOption struct {
	VirtualDeviceRemoteDeviceBackingOption
}

func init() {
	t["VirtualFloppyRemoteDeviceBackingOption"] = reflect.TypeOf((*VirtualFloppyRemoteDeviceBackingOption)(nil)).Elem()
}

// The VirtualHardware data object type contains the complete configuration
// of the hardware in a virtual machine.
type VirtualHardware struct {
	DynamicData

	// Number of virtual CPUs present in this virtual machine.
	NumCPU int32 `xml:"numCPU" json:"numCPU"`
	// Number of cores used to distribute virtual CPUs among sockets
	// in this virtual machine.
	//
	// This field should be ignored for powered off VM with
	// autoCoresPerSocket equals TRUE, because the virtual socket size
	// will be assigned during power-on.
	// This field could be unset for releases prior to 7.0 U3, and it
	// implies numCoresPerSocket is 1.
	// In other cases, this field represents the actual virtual socket
	// size seen by the virtual machine.
	NumCoresPerSocket int32 `xml:"numCoresPerSocket,omitempty" json:"numCoresPerSocket,omitempty"`
	// Cores per socket is automatically determined.
	AutoCoresPerSocket *bool `xml:"autoCoresPerSocket" json:"autoCoresPerSocket,omitempty" vim:"8.0.0.1"`
	// Memory size, in MB.
	MemoryMB int32 `xml:"memoryMB" json:"memoryMB"`
	// Does this virtual machine have Virtual Intel I/O Controller Hub 7
	VirtualICH7MPresent *bool `xml:"virtualICH7MPresent" json:"virtualICH7MPresent,omitempty"`
	// Does this virtual machine have System Management Controller
	VirtualSMCPresent *bool `xml:"virtualSMCPresent" json:"virtualSMCPresent,omitempty"`
	// The set of virtual devices belonging to the virtual machine.
	//
	// This list is unordered.
	Device []BaseVirtualDevice `xml:"device,omitempty,typeattr" json:"device,omitempty"`
	// One of motherboardLayout choices.
	//
	// Default is i440bxHostBridge. See
	// `VirtualHardware.motherboardLayout`
	MotherboardLayout string `xml:"motherboardLayout,omitempty" json:"motherboardLayout,omitempty" vim:"8.0.0.1"`
	// Number of SMT (Simultaneous multithreading) threads.
	//
	// If unset, then system defaults are in use.
	SimultaneousThreads int32 `xml:"simultaneousThreads,omitempty" json:"simultaneousThreads,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VirtualHardware"] = reflect.TypeOf((*VirtualHardware)(nil)).Elem()
}

// There is a problem with the compatibility between the intended execution host
// and the virtual machine.
//
// This may be an error or warning depending on
// the specific fault subclass.
type VirtualHardwareCompatibilityIssue struct {
	VmConfigFault
}

func init() {
	t["VirtualHardwareCompatibilityIssue"] = reflect.TypeOf((*VirtualHardwareCompatibilityIssue)(nil)).Elem()
}

type VirtualHardwareCompatibilityIssueFault BaseVirtualHardwareCompatibilityIssue

func init() {
	t["VirtualHardwareCompatibilityIssueFault"] = reflect.TypeOf((*VirtualHardwareCompatibilityIssueFault)(nil)).Elem()
}

// The VirtualHardwareOption data object contains the options available
// for all virtual devices.
type VirtualHardwareOption struct {
	DynamicData

	// The virtual hardware version.
	HwVersion int32 `xml:"hwVersion" json:"hwVersion"`
	// Array of virtual device options valid for this virtual
	// machine configuration.
	//
	// The list is unordered.
	VirtualDeviceOption []BaseVirtualDeviceOption `xml:"virtualDeviceOption,typeattr" json:"virtualDeviceOption"`
	// Whether the set of virtual devices can be changed, e.g., can devices
	// be added or removed.
	//
	// This does not preclude changing devices.
	DeviceListReadonly bool `xml:"deviceListReadonly" json:"deviceListReadonly"`
	// List of acceptable values for the number of CPUs supported by this
	// `ConfigOption`.
	//
	// This is usually superceded by the information available in the
	// guest operating system descriptors.
	// The guest operating system descriptor describes a maximum CPU
	// count, but the acceptable values are still constrained to the
	// set specified here. The default value is stored at index 0 in the list.
	NumCPU []int32 `xml:"numCPU" json:"numCPU"`
	// The minimum, maximum and default number of cores per socket that
	// can be used when distributing virtual CPUs.
	NumCoresPerSocket *IntOption `xml:"numCoresPerSocket,omitempty" json:"numCoresPerSocket,omitempty"`
	// Whether auto cores per socket is supported.
	AutoCoresPerSocket *BoolOption `xml:"autoCoresPerSocket,omitempty" json:"autoCoresPerSocket,omitempty" vim:"8.0.0.1"`
	// Can the number of virtual CPUs be changed
	NumCpuReadonly bool `xml:"numCpuReadonly" json:"numCpuReadonly"`
	// The minimum, maximum, and default memory options, in MB, per virtual machine,
	// for this VirtualHardwareOption.
	//
	// These
	// values are typically overruled by the supported and recommended
	// values specified in the `GuestOsDescriptor` class.
	MemoryMB LongOption `xml:"memoryMB" json:"memoryMB"`
	// The minimum, maximum, and default number of PCI controllers for
	// this virtual machine configuration.
	NumPCIControllers IntOption `xml:"numPCIControllers" json:"numPCIControllers"`
	// The minimum, maximum, and default number of IDE controllers for
	// this virtual machine configuration.
	//
	// Note: SCSI controllers sit
	// on the PCI controller so their options (minimum, maximum, and default values)
	// are contained inside the
	// `VirtualPCIControllerOption`
	// class.
	NumIDEControllers IntOption `xml:"numIDEControllers" json:"numIDEControllers"`
	// The minimum, maximum, and default number of USB controllers for
	// this virtual machine configuration.
	NumUSBControllers IntOption `xml:"numUSBControllers" json:"numUSBControllers"`
	// The minimum, maximum, and default number of XHCI (USB 3.0) controllers for
	// this virtual machine configuration.
	NumUSBXHCIControllers *IntOption `xml:"numUSBXHCIControllers,omitempty" json:"numUSBXHCIControllers,omitempty"`
	// The minimum, maximum, and default number of SIO controllers for
	// this virtual machine configuration.
	NumSIOControllers IntOption `xml:"numSIOControllers" json:"numSIOControllers"`
	// The minimum, maximum, and default number of PS2 controllers for
	// this virtual machine configuration.
	NumPS2Controllers IntOption `xml:"numPS2Controllers" json:"numPS2Controllers"`
	// List of propery names which limits are given be a licensing
	// restriction of the underlying product, e.g., a limit that is
	// not derived based on the product or hardware features.
	//
	// For example, the property name "numCPU"
	LicensingLimit []string `xml:"licensingLimit,omitempty" json:"licensingLimit,omitempty"`
	// The minimum, maximum and default number of NPIV WorldWideNode names
	// supported for this virtual machine configuration.
	NumSupportedWwnPorts *IntOption `xml:"numSupportedWwnPorts,omitempty" json:"numSupportedWwnPorts,omitempty"`
	// The minimum, maximum and default number of NPIV WorldWidePort names
	// supported for this virtual machine configuration.
	NumSupportedWwnNodes *IntOption `xml:"numSupportedWwnNodes,omitempty" json:"numSupportedWwnNodes,omitempty"`
	// Default value and value range for `ResourceConfigOption`
	ResourceConfigOption *ResourceConfigOption `xml:"resourceConfigOption,omitempty" json:"resourceConfigOption,omitempty"`
	// The minimum, maximum and default number of virtual NVDIMM controllers
	// for this virtual machine configuration.
	NumNVDIMMControllers *IntOption `xml:"numNVDIMMControllers,omitempty" json:"numNVDIMMControllers,omitempty"`
	// The minimum, maximum, and default number of virtual TPMs.
	NumTPMDevices *IntOption `xml:"numTPMDevices,omitempty" json:"numTPMDevices,omitempty"`
	// The minimum, maximum, and default number of virtual watchdog timers.
	NumWDTDevices *IntOption `xml:"numWDTDevices,omitempty" json:"numWDTDevices,omitempty"`
	// The minimum, maximum and default number of PrecisionClock devices.
	NumPrecisionClockDevices *IntOption `xml:"numPrecisionClockDevices,omitempty" json:"numPrecisionClockDevices,omitempty"`
	// The minimum, maximum and default value of Intel's Secure Guard Extensions
	// Enclave Page Cache (EPC) memory.
	EpcMemoryMB *LongOption `xml:"epcMemoryMB,omitempty" json:"epcMemoryMB,omitempty"`
	// Empty for HWv17 &amp; older, \["efi"\] for HWv18.
	AcpiHostBridgesFirmware []string `xml:"acpiHostBridgesFirmware,omitempty" json:"acpiHostBridgesFirmware,omitempty" vim:"8.0.0.1"`
	// The minimum, maximum and default number of CPU simultaneous threads.
	NumCpuSimultaneousThreads *IntOption `xml:"numCpuSimultaneousThreads,omitempty" json:"numCpuSimultaneousThreads,omitempty" vim:"8.0.0.1"`
	// The minimum, maximum and default number of NUMA nodes.
	NumNumaNodes *IntOption `xml:"numNumaNodes,omitempty" json:"numNumaNodes,omitempty" vim:"8.0.0.1"`
	// Maximum number of device groups.
	NumDeviceGroups *IntOption `xml:"numDeviceGroups,omitempty" json:"numDeviceGroups,omitempty" vim:"8.0.0.1"`
	// Supported device group types.
	DeviceGroupTypes []string `xml:"deviceGroupTypes,omitempty" json:"deviceGroupTypes,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VirtualHardwareOption"] = reflect.TypeOf((*VirtualHardwareOption)(nil)).Elem()
}

// The virtual machine's virtual hardware version is not supported on the host.
type VirtualHardwareVersionNotSupported struct {
	VirtualHardwareCompatibilityIssue

	HostName string `xml:"hostName" json:"hostName"`
	// The host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
}

func init() {
	t["VirtualHardwareVersionNotSupported"] = reflect.TypeOf((*VirtualHardwareVersionNotSupported)(nil)).Elem()
}

type VirtualHardwareVersionNotSupportedFault VirtualHardwareVersionNotSupported

func init() {
	t["VirtualHardwareVersionNotSupportedFault"] = reflect.TypeOf((*VirtualHardwareVersionNotSupportedFault)(nil)).Elem()
}

// The VirtualHdAudioCard data object type represents a HD Audio
// sound card in a virtual machine.
type VirtualHdAudioCard struct {
	VirtualSoundCard
}

func init() {
	t["VirtualHdAudioCard"] = reflect.TypeOf((*VirtualHdAudioCard)(nil)).Elem()
}

// The VirtualHdAudioCardOption data object type contains the options for a
// virtual HD Audio sound card.
type VirtualHdAudioCardOption struct {
	VirtualSoundCardOption
}

func init() {
	t["VirtualHdAudioCardOption"] = reflect.TypeOf((*VirtualHdAudioCardOption)(nil)).Elem()
}

// The VirtualIDEController data object type specifies a virtual IDE controller.
type VirtualIDEController struct {
	VirtualController
}

func init() {
	t["VirtualIDEController"] = reflect.TypeOf((*VirtualIDEController)(nil)).Elem()
}

// The VirtualIDEControllerOption data object type contains the options
// for a virtual IDE controller.
type VirtualIDEControllerOption struct {
	VirtualControllerOption

	// The minimum, maximum, and default number of IDE VirtualDisk instances you can
	// have, at any given time, in the IDE controller.
	//
	// The number is further constrained
	// by the number of available slots in the virtual IDE controller.
	NumIDEDisks IntOption `xml:"numIDEDisks" json:"numIDEDisks"`
	// The minimum, maximum, and default number of IDE VirtualCdrom instances you can
	// have, at any given time, in the IDE controller.
	//
	// The number is further constrained
	// by the number of available slots in the virtual IDE controller.
	NumIDECdroms IntOption `xml:"numIDECdroms" json:"numIDECdroms"`
}

func init() {
	t["VirtualIDEControllerOption"] = reflect.TypeOf((*VirtualIDEControllerOption)(nil)).Elem()
}

// This data object type contains information about
// the keyboard on a virtual machine.
type VirtualKeyboard struct {
	VirtualDevice
}

func init() {
	t["VirtualKeyboard"] = reflect.TypeOf((*VirtualKeyboard)(nil)).Elem()
}

// The VirtualKeyboardOption data object type contains the options for the
// virtual keyboard class.
type VirtualKeyboardOption struct {
	VirtualDeviceOption
}

func init() {
	t["VirtualKeyboardOption"] = reflect.TypeOf((*VirtualKeyboardOption)(nil)).Elem()
}

// VirtualLsiLogicController is the data object that represents
// a LSI Logic SCSI controller.
type VirtualLsiLogicController struct {
	VirtualSCSIController
}

func init() {
	t["VirtualLsiLogicController"] = reflect.TypeOf((*VirtualLsiLogicController)(nil)).Elem()
}

// VirtualLsiLogicControllerOption is the data object that contains
// the options for a LSI Logic SCSI controller.
type VirtualLsiLogicControllerOption struct {
	VirtualSCSIControllerOption
}

func init() {
	t["VirtualLsiLogicControllerOption"] = reflect.TypeOf((*VirtualLsiLogicControllerOption)(nil)).Elem()
}

// VirtualLsiLogicSASController is the data object that represents
// a LSI Logic SAS SCSI controller.
type VirtualLsiLogicSASController struct {
	VirtualSCSIController
}

func init() {
	t["VirtualLsiLogicSASController"] = reflect.TypeOf((*VirtualLsiLogicSASController)(nil)).Elem()
}

// VirtualLsiLogicSASControllerOption is the data object that contains
// the options for a LSI Logic SAS SCSI controller.
type VirtualLsiLogicSASControllerOption struct {
	VirtualSCSIControllerOption
}

func init() {
	t["VirtualLsiLogicSASControllerOption"] = reflect.TypeOf((*VirtualLsiLogicSASControllerOption)(nil)).Elem()
}

// Specification of scheduling affinity.
//
// Scheduling affinity is used for explicitly specifying which
// processors or NUMA nodes may be used by a virtual machine.
type VirtualMachineAffinityInfo struct {
	DynamicData

	// List of nodes (processors for CPU, NUMA nodes for memory) that
	// may be used by the virtual machine.
	//
	// If the array is empty when
	// modifying the affinity setting, then any existing affinity is removed.
	AffinitySet []int32 `xml:"affinitySet" json:"affinitySet"`
}

func init() {
	t["VirtualMachineAffinityInfo"] = reflect.TypeOf((*VirtualMachineAffinityInfo)(nil)).Elem()
}

// The BaseIndependentFilterSpec is base class for two different types
// of independent filter specs `VirtualMachineIndependentFilterSpec`
// and `VirtualMachineEmptyIndependentFilterSpec` which are used to specify
// independent filters to be attached/removed on VMs virtual disk.
type VirtualMachineBaseIndependentFilterSpec struct {
	DynamicData
}

func init() {
	t["VirtualMachineBaseIndependentFilterSpec"] = reflect.TypeOf((*VirtualMachineBaseIndependentFilterSpec)(nil)).Elem()
	minAPIVersionForType["VirtualMachineBaseIndependentFilterSpec"] = "7.0.2.1"
}

// The `VirtualMachineBootOptions` data object defines the boot-time
// behavior of a virtual machine.
//
// You can use the delay options to specify a time interval
// during which you can enter the virtual machine BIOS setup.
// These options provide a solution for the situation that occurs
// when the console attaches to the virtual machine after
// the boot sequence has passed the BIOS setup entry point.
type VirtualMachineBootOptions struct {
	DynamicData

	// Delay in milliseconds before starting the boot sequence.
	//
	// The boot delay specifies a time interval between virtual machine
	// power on or restart and the beginning of the boot sequence.
	BootDelay int64 `xml:"bootDelay,omitempty" json:"bootDelay,omitempty"`
	// If set to <code>true</code>, the virtual machine
	// automatically enters BIOS setup the next time it boots.
	//
	// The virtual machine resets this flag to <code>false</code>
	// so that subsequent boots proceed normally.
	EnterBIOSSetup *bool `xml:"enterBIOSSetup" json:"enterBIOSSetup,omitempty"`
	// If set to <code>true</code>, the virtual machine's firmware will
	// perform signature checks of any EFI images loaded during startup, and
	// will refuse to start any images which do not pass those signature
	// checks.
	//
	// When creating a new VM:
	// \- If vim.vm.FlagInfo.vbsEnabled is set to <code>true</code>,
	// and this flag is set to <code>false</code> error is returned.
	// \- If this flag is unset and vim.vm.FlagInfo.vbsEnabled is set to
	// <code>true</code>, the value of this flag is set to <code>true</code>.
	EfiSecureBootEnabled *bool `xml:"efiSecureBootEnabled" json:"efiSecureBootEnabled,omitempty"`
	// If set to <code>true</code>, a virtual machine that fails
	// to boot will try again after the `VirtualMachineBootOptions.bootRetryDelay`
	// time period has expired.
	//
	// When <code>false</code>,
	// the virtual machine waits indefinitely for you to initiate
	// boot retry.
	BootRetryEnabled *bool `xml:"bootRetryEnabled" json:"bootRetryEnabled,omitempty"`
	// Delay in milliseconds before a boot retry.
	//
	// The boot retry delay
	// specifies a time interval between virtual machine boot failure
	// and the subsequent attempt to boot again. The virtual machine
	// uses this value only if `VirtualMachineBootOptions.bootRetryEnabled` is true.
	BootRetryDelay int64 `xml:"bootRetryDelay,omitempty" json:"bootRetryDelay,omitempty"`
	// Boot order.
	//
	// Listed devices are used for booting. After list
	// is exhausted, default BIOS boot device algorithm is used for
	// booting.
	// Note that order of the entries in the list is important:
	// device listed first is used for boot first, if that one
	// fails second entry is used, and so on.
	// Platform may have some internal limit on the number of devices
	// it supports. If bootable device is not reached before platform's
	// limit is hit, boot will fail. At least single entry is supported
	// by all products supporting boot order settings.
	BootOrder []BaseVirtualMachineBootOptionsBootableDevice `xml:"bootOrder,omitempty,typeattr" json:"bootOrder,omitempty"`
	// Protocol to attempt during PXE network boot or NetBoot.
	//
	// See also `VirtualMachineBootOptionsNetworkBootProtocolType_enum`.
	NetworkBootProtocol string `xml:"networkBootProtocol,omitempty" json:"networkBootProtocol,omitempty"`
}

func init() {
	t["VirtualMachineBootOptions"] = reflect.TypeOf((*VirtualMachineBootOptions)(nil)).Elem()
}

// Bootable CDROM.
//
// First CDROM with bootable media found is used.
type VirtualMachineBootOptionsBootableCdromDevice struct {
	VirtualMachineBootOptionsBootableDevice
}

func init() {
	t["VirtualMachineBootOptionsBootableCdromDevice"] = reflect.TypeOf((*VirtualMachineBootOptionsBootableCdromDevice)(nil)).Elem()
}

// Bootable device.
type VirtualMachineBootOptionsBootableDevice struct {
	DynamicData
}

func init() {
	t["VirtualMachineBootOptionsBootableDevice"] = reflect.TypeOf((*VirtualMachineBootOptionsBootableDevice)(nil)).Elem()
}

// Bootable disk.
type VirtualMachineBootOptionsBootableDiskDevice struct {
	VirtualMachineBootOptionsBootableDevice

	// `Key`
	// property of the bootable harddisk.
	DeviceKey int32 `xml:"deviceKey" json:"deviceKey"`
}

func init() {
	t["VirtualMachineBootOptionsBootableDiskDevice"] = reflect.TypeOf((*VirtualMachineBootOptionsBootableDiskDevice)(nil)).Elem()
}

// Bootable ethernet adapter.
//
// PXE boot is attempted from the device.
type VirtualMachineBootOptionsBootableEthernetDevice struct {
	VirtualMachineBootOptionsBootableDevice

	// `Key`
	// property of the bootable ethernet adapter.
	DeviceKey int32 `xml:"deviceKey" json:"deviceKey"`
}

func init() {
	t["VirtualMachineBootOptionsBootableEthernetDevice"] = reflect.TypeOf((*VirtualMachineBootOptionsBootableEthernetDevice)(nil)).Elem()
}

// Bootable floppy disk.
type VirtualMachineBootOptionsBootableFloppyDevice struct {
	VirtualMachineBootOptionsBootableDevice
}

func init() {
	t["VirtualMachineBootOptionsBootableFloppyDevice"] = reflect.TypeOf((*VirtualMachineBootOptionsBootableFloppyDevice)(nil)).Elem()
}

// This data object type contains information about the
// operation/capabilities of a virtual machine
type VirtualMachineCapability struct {
	DynamicData

	// Indicates whether or not a virtual machine supports snapshot operations.
	SnapshotOperationsSupported bool `xml:"snapshotOperationsSupported" json:"snapshotOperationsSupported"`
	// Indicates whether or not a virtual machine supports multiple snapshots.
	//
	// This value is not set when the virtual machine is unavailable, for instance,
	// when it is being created or deleted.
	MultipleSnapshotsSupported bool `xml:"multipleSnapshotsSupported" json:"multipleSnapshotsSupported"`
	// Indicates whether or not a virtual machine supports snapshot config.
	SnapshotConfigSupported bool `xml:"snapshotConfigSupported" json:"snapshotConfigSupported"`
	// Indicates whether or not a virtual machine supports snapshot operations in
	// poweredOff state.
	//
	// This flag doesn't affect vim.VirtualMachine.GetSnapshot,
	// which is always supported.
	PoweredOffSnapshotsSupported bool `xml:"poweredOffSnapshotsSupported" json:"poweredOffSnapshotsSupported"`
	// Indicates whether or not a virtual machine supports memory snapshots.
	MemorySnapshotsSupported bool `xml:"memorySnapshotsSupported" json:"memorySnapshotsSupported"`
	// Indicates whether or not a virtual machine supports reverting to a snapshot.
	RevertToSnapshotSupported bool `xml:"revertToSnapshotSupported" json:"revertToSnapshotSupported"`
	// Indicates whether or not a virtual machine supports quiesced snapshots.
	QuiescedSnapshotsSupported bool `xml:"quiescedSnapshotsSupported" json:"quiescedSnapshotsSupported"`
	// Deprecated as of vSphere API 4.0. The value returned from the server is
	// always false.
	//
	// Indicates whether or not snapshots can be disabled.
	DisableSnapshotsSupported bool `xml:"disableSnapshotsSupported" json:"disableSnapshotsSupported"`
	// Indicates whether or not the snapshot tree can be locked.
	LockSnapshotsSupported bool `xml:"lockSnapshotsSupported" json:"lockSnapshotsSupported"`
	// Indicates whether console preferences can be set for this virtual machine.
	ConsolePreferencesSupported bool `xml:"consolePreferencesSupported" json:"consolePreferencesSupported"`
	// Indicates whether CPU feature requirements masks can be set for this
	// virtual machine.
	//
	// Masking for hardware version 9 and newer virtual
	// machines is controlled by `VirtualMachineCapability.featureRequirementSupported`.
	CpuFeatureMaskSupported bool `xml:"cpuFeatureMaskSupported" json:"cpuFeatureMaskSupported"`
	// Indicates whether or not a virtual machine supports ACPI S1 settings management.
	S1AcpiManagementSupported bool `xml:"s1AcpiManagementSupported" json:"s1AcpiManagementSupported"`
	// Indicates whether of not this virtual machine supports
	// setting the screen resolution of the console window.
	//
	// This capability depends on the guest operating system
	// configured for this virtual machine.
	SettingScreenResolutionSupported bool `xml:"settingScreenResolutionSupported" json:"settingScreenResolutionSupported"`
	// Supports tools auto-update.
	ToolsAutoUpdateSupported bool `xml:"toolsAutoUpdateSupported" json:"toolsAutoUpdateSupported"`
	// Supports virtual machine NPIV WWN.
	VmNpivWwnSupported bool `xml:"vmNpivWwnSupported" json:"vmNpivWwnSupported"`
	// Supports assigning NPIV WWN to virtual machines that don't have RDM disks.
	NpivWwnOnNonRdmVmSupported bool `xml:"npivWwnOnNonRdmVmSupported" json:"npivWwnOnNonRdmVmSupported"`
	// Indicates whether the NPIV disabling operation is supported the virtual machine.
	VmNpivWwnDisableSupported *bool `xml:"vmNpivWwnDisableSupported" json:"vmNpivWwnDisableSupported,omitempty"`
	// Indicates whether the update of NPIV WWNs are supported on the virtual machine.
	VmNpivWwnUpdateSupported *bool `xml:"vmNpivWwnUpdateSupported" json:"vmNpivWwnUpdateSupported,omitempty"`
	// Flag indicating whether the virtual machine has a configurable
	// *swapfile placement policy*.
	SwapPlacementSupported bool `xml:"swapPlacementSupported" json:"swapPlacementSupported"`
	// Indicates whether asking tools to sync time with the host is supported.
	ToolsSyncTimeSupported bool `xml:"toolsSyncTimeSupported" json:"toolsSyncTimeSupported"`
	// Indicates whether or not the use of nested page table hardware support
	// can be explicitly set.
	VirtualMmuUsageSupported bool `xml:"virtualMmuUsageSupported" json:"virtualMmuUsageSupported"`
	// Indicates whether resource settings for disks can be
	// applied to this virtual machine.
	DiskSharesSupported bool `xml:"diskSharesSupported" json:"diskSharesSupported"`
	// Indicates whether boot options can be configured
	// for this virtual machine.
	BootOptionsSupported bool `xml:"bootOptionsSupported" json:"bootOptionsSupported"`
	// Indicates whether automatic boot retry can be
	// configured for this virtual machine.
	BootRetryOptionsSupported *bool `xml:"bootRetryOptionsSupported" json:"bootRetryOptionsSupported,omitempty"`
	// Flag indicating whether the video ram size of this virtual machine
	// can be configured.
	SettingVideoRamSizeSupported bool `xml:"settingVideoRamSizeSupported" json:"settingVideoRamSizeSupported"`
	// Indicates whether of not this virtual machine supports
	// setting the display topology of the console window.
	//
	// This capability depends on the guest operating system
	// configured for this virtual machine.
	SettingDisplayTopologySupported *bool `xml:"settingDisplayTopologySupported" json:"settingDisplayTopologySupported,omitempty"`
	// Deprecated as of vSphere API 6.0.
	//
	// Indicates whether record and replay functionality is supported on this
	// virtual machine.
	RecordReplaySupported *bool `xml:"recordReplaySupported" json:"recordReplaySupported,omitempty"`
	// Indicates that change tracking is supported for virtual disks of this
	// virtual machine.
	//
	// However, even if change tracking is supported, it might
	// not be available for all disks of the virtual machine. For example,
	// passthru raw disk mappings or disks backed by any Ver1BackingInfo cannot
	// be tracked.
	ChangeTrackingSupported *bool `xml:"changeTrackingSupported" json:"changeTrackingSupported,omitempty"`
	// Indicates whether multiple virtual cores per socket is supported on this VM.
	MultipleCoresPerSocketSupported *bool `xml:"multipleCoresPerSocketSupported" json:"multipleCoresPerSocketSupported,omitempty"`
	// Indicates that host based replication is supported on this virtual
	// machine.
	//
	// However, even if host based replication is supported,
	// it might not be available for all disk types. For example, passthru
	// raw disk mappings can not be replicated.
	HostBasedReplicationSupported *bool `xml:"hostBasedReplicationSupported" json:"hostBasedReplicationSupported,omitempty"`
	// Indicates whether features like guest OS auto-lock and MKS connection
	// controls are supported for this virtual machine.
	GuestAutoLockSupported *bool `xml:"guestAutoLockSupported" json:"guestAutoLockSupported,omitempty"`
	// Indicates whether
	// `memoryReservationLockedToMax`
	// may be set to true for this virtual machine.
	MemoryReservationLockSupported *bool `xml:"memoryReservationLockSupported" json:"memoryReservationLockSupported,omitempty"`
	// Indicates whether featureRequirement feature is supported.
	FeatureRequirementSupported *bool `xml:"featureRequirementSupported" json:"featureRequirementSupported,omitempty"`
	// Indicates whether a monitor type change is supported while this virtual
	// machine is in the poweredOn state.
	PoweredOnMonitorTypeChangeSupported *bool `xml:"poweredOnMonitorTypeChangeSupported" json:"poweredOnMonitorTypeChangeSupported,omitempty"`
	// Indicates whether this virtual machine supports the Flex-SE
	// (space-efficient, sparse) format for virtual disks.
	SeSparseDiskSupported *bool `xml:"seSparseDiskSupported" json:"seSparseDiskSupported,omitempty"`
	// Indicates whether this virtual machine supports nested hardware-assisted
	// virtualization.
	NestedHVSupported *bool `xml:"nestedHVSupported" json:"nestedHVSupported,omitempty"`
	// Indicates whether this virtual machine supports virtualized CPU performance
	// counters.
	VPMCSupported *bool `xml:"vPMCSupported" json:"vPMCSupported,omitempty"`
	// Indicates whether secureBoot is supported for this virtual machine.
	SecureBootSupported *bool `xml:"secureBootSupported" json:"secureBootSupported,omitempty"`
	// Indicates whether this virtual machine supports Per-VM EVC mode.
	PerVmEvcSupported *bool `xml:"perVmEvcSupported" json:"perVmEvcSupported,omitempty"`
	// Indicates that `VirtualMachineFlagInfo.virtualMmuUsage` is
	// ignored by this virtual machine, always operating as if "on" was selected.
	VirtualMmuUsageIgnored *bool `xml:"virtualMmuUsageIgnored" json:"virtualMmuUsageIgnored,omitempty"`
	// Indicates that `VirtualMachineFlagInfo.virtualExecUsage` is
	// ignored by this virtual machine, always operating as if "hvOn" was selected.
	VirtualExecUsageIgnored *bool `xml:"virtualExecUsageIgnored" json:"virtualExecUsageIgnored,omitempty"`
	// Indicates whether this virtual machine supports creating disk-only snapshots
	// in suspended state.
	//
	// If this capability is not set, the snapshot of a
	// virtual machine in suspended state will always include memory.
	DiskOnlySnapshotOnSuspendedVMSupported *bool `xml:"diskOnlySnapshotOnSuspendedVMSupported" json:"diskOnlySnapshotOnSuspendedVMSupported,omitempty"`
	// Indicates whether this virtual machine supports suspending to memory.
	SuspendToMemorySupported *bool `xml:"suspendToMemorySupported" json:"suspendToMemorySupported,omitempty" vim:"7.0.2.0"`
	// Indicates support for allowing or disallowing all tools time
	// sync with host.
	ToolsSyncTimeAllowSupported *bool `xml:"toolsSyncTimeAllowSupported" json:"toolsSyncTimeAllowSupported,omitempty" vim:"7.0.1.0"`
	// Indicates support for AMD-SEV (Secure Encrypted Virtualization).
	//
	// SEV is
	// supported when set to true, and unsupported otherwise.
	SevSupported *bool `xml:"sevSupported" json:"sevSupported,omitempty" vim:"7.0.1.0"`
	// Indicates support for failover to a dfferent host on VM's with pmem.
	//
	// Failover is supported when set to true, and unsupported otherwise.
	PmemFailoverSupported *bool `xml:"pmemFailoverSupported" json:"pmemFailoverSupported,omitempty" vim:"7.0.2.0"`
	// Whether the VM supports requiring SGX remote attestation.
	RequireSgxAttestationSupported *bool `xml:"requireSgxAttestationSupported" json:"requireSgxAttestationSupported,omitempty" vim:"8.0.0.1"`
	// Indicates support for change mode on virtual disks
	ChangeModeDisksSupported *bool `xml:"changeModeDisksSupported" json:"changeModeDisksSupported,omitempty" vim:"8.0.0.1"`
	// Indicates support for Vendor Device Groups
	VendorDeviceGroupSupported *bool `xml:"vendorDeviceGroupSupported" json:"vendorDeviceGroupSupported,omitempty" vim:"8.0.1.0"`
}

func init() {
	t["VirtualMachineCapability"] = reflect.TypeOf((*VirtualMachineCapability)(nil)).Elem()
}

// CdromInfo class contains information about a physical CD-ROM drive on the host.
type VirtualMachineCdromInfo struct {
	VirtualMachineTargetInfo

	// Description of the physical device.
	//
	// This is set only by the server.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
}

func init() {
	t["VirtualMachineCdromInfo"] = reflect.TypeOf((*VirtualMachineCdromInfo)(nil)).Elem()
}

// Describes a single certificate thumbprint that can be used to verify
// the identity of the host before connecting to a running virtual machine.
type VirtualMachineCertThumbprint struct {
	DynamicData

	// The thumbprint of the certificate of the host to which we are
	// connecting.
	Thumbprint string `xml:"thumbprint" json:"thumbprint"`
	// The hash algorithm used to generate the thumbprint.
	//
	// `VirtualMachineCertThumbprintHashAlgorithm_enum` lists the set of supported values.
	HashAlgorithm string `xml:"hashAlgorithm,omitempty" json:"hashAlgorithm,omitempty"`
}

func init() {
	t["VirtualMachineCertThumbprint"] = reflect.TypeOf((*VirtualMachineCertThumbprint)(nil)).Elem()
	minAPIVersionForType["VirtualMachineCertThumbprint"] = "7.0.3.1"
}

// Specification for a virtual machine cloning operation.
type VirtualMachineCloneSpec struct {
	DynamicData

	// A type of RelocateSpec that specifies the location of resources the
	// newly cloned virtual machine will use.
	//
	// The location specifies:
	//   - A datastore where the virtual machine will be located on physical
	//     storage.
	//     This is always provided because it indicates where the newly
	//     created clone will be copied.
	//   - a resource pool and optionally a host. The resource pool
	//     determines what compute resources will be available to the clone
	//     and the host indicates which machine will host the clone.
	Location VirtualMachineRelocateSpec `xml:"location" json:"location"`
	// Specifies whether or not the new virtual machine should be marked as a
	// template.
	Template bool `xml:"template" json:"template"`
	// An optional specification of changes to the virtual hardware.
	//
	// For example, this can be used to, (but not limited to) reconfigure the
	// networks the virtual switches are hooked up to in the cloned virtual
	// machine.
	// Use `VirtualMachineRelocateSpec.deviceChange` in
	// `VirtualMachineCloneSpec.location`
	// for specifying any virtual device changes for disks and networks.
	Config *VirtualMachineConfigSpec `xml:"config,omitempty" json:"config,omitempty"`
	// An optional guest operating system customization specification.
	//
	// This value is ignored if a template is being created.
	Customization *CustomizationSpec `xml:"customization,omitempty" json:"customization,omitempty"`
	// Specifies whether or not the new VirtualMachine should be powered on
	// after creation.
	//
	// As part of a customization, this flag is normally set
	// to true, since the first power-on operation completes the customization
	// process. This flag is ignored if a template is being created.
	PowerOn bool `xml:"powerOn" json:"powerOn"`
	// Snapshot reference from which to base the clone.
	//
	// If this parameter is set, the clone is based off of the snapshot
	// point. This means that the newly created virtual machine will
	// have the same configuration as the virtual machine at the time
	// the snapshot was taken.
	//
	// If this property is not set then the clone is based off of the
	// virtual machine's current configuration.
	//
	// Setting this is only supported if the host this virtual machine
	// is currently residing on
	// *supports cloning from a snapshot point*. Such support does not need to
	// exist on the destination host for the clone.
	//
	// Setting this is only supported if the virtual machine supports
	// reporting snapshot configuration information. See `VirtualMachineCapability.snapshotConfigSupported`. Such support does not need
	// to exist on the destination host for the clone.
	//
	// Refers instance of `VirtualMachineSnapshot`.
	Snapshot *ManagedObjectReference `xml:"snapshot,omitempty" json:"snapshot,omitempty"`
	// Flag indicating whether to retain a copy of the source virtual machine's
	// memory state in the clone.
	//
	// Retaining the memory state during
	// clone results in a clone in suspended state with all network adapters
	// removed to avoid network conflicts, except those with a
	// VirtualEthernetCard.addressType of "manual".
	// Users of this flag should take special care so that, when adding a network
	// adapter back to the clone, the VM is not resumed on the same VM network
	// as the source VM, or else MAC address conflicts could occur.
	// When cloning between two hosts with different CPUs outside an EVC cluster,
	// users of this flag should be aware that vCenter does not verify
	// CPU compatibility between the clone's memory state and the target host
	// prior to the clone operation, so the clone may fail to resume
	// until it is migrated to a host with a compatible CPU.
	//
	// This flag is ignored if the snapshot parameter is unset. This flag
	// only applies for a snapshot taken on a running or suspended
	// virtual machine with the 'memory' parameter set to true, because otherwise
	// the snapshot has no memory state. This flag defaults to false.
	Memory *bool `xml:"memory" json:"memory,omitempty"`
	// Provisioning policy for virtual TPM devices during VM clone operations.
	//
	// The list of supported values is defined in `VirtualMachineCloneSpecTpmProvisionPolicy_enum`.
	//
	// If unset - a globally defined policy is used, which by default is set to
	// 'copy'.
	TpmProvisionPolicy string `xml:"tpmProvisionPolicy,omitempty" json:"tpmProvisionPolicy,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VirtualMachineCloneSpec"] = reflect.TypeOf((*VirtualMachineCloneSpec)(nil)).Elem()
}

// The ConfigInfo data object type encapsulates the configuration settings and
// virtual hardware for a virtual machine.
//
// This type holds all the information
// that is present in the .vmx configuration file for the virtual machine.
type VirtualMachineConfigInfo struct {
	DynamicData

	// The changeVersion is a unique identifier for a given version
	// of the configuration.
	//
	// Each change to the configuration
	// updates this value. This is typically implemented as an ever
	// increasing count or a time-stamp. However, a client should
	// always treat this as an opaque string.
	ChangeVersion string `xml:"changeVersion" json:"changeVersion"`
	// Last time a virtual machine's configuration was modified.
	Modified time.Time `xml:"modified" json:"modified"`
	// Display name of the virtual machine.
	//
	// Any / (slash), \\ (backslash), character used in this
	// name element is escaped. Similarly, any % (percent) character used in
	// this name element is escaped, unless it is used to start an escape
	// sequence. A slash is escaped as %2F or %2f. A backslash is escaped as %5C or
	// %5c, and a percent is escaped as %25.
	Name string `xml:"name" json:"name"`
	// This is the full name of the guest operating system for the virtual machine.
	//
	// For example: Windows 2000 Professional.
	//
	// See also `VirtualMachineConfigInfo.alternateGuestName`.
	GuestFullName string `xml:"guestFullName" json:"guestFullName"`
	// The version string for this virtual machine.
	Version string `xml:"version" json:"version"`
	// 128-bit SMBIOS UUID of a virtual machine represented as a hexadecimal string
	// in "12345678-abcd-1234-cdef-123456789abc" format.
	Uuid string `xml:"uuid" json:"uuid"`
	// Time the virtual machine's configuration was created.
	CreateDate *time.Time `xml:"createDate" json:"createDate,omitempty"`
	// VirtualCenter-specific 128-bit UUID of a virtual machine, represented
	// as a hexademical string.
	//
	// This identifier is used by VirtualCenter to
	// uniquely identify all virtual machine instances, including those that
	// may share the same SMBIOS UUID.
	InstanceUuid string `xml:"instanceUuid,omitempty" json:"instanceUuid,omitempty"`
	// A 64-bit node WWN (World Wide Name).
	//
	// These WWNs are paired with the
	// `VirtualMachineConfigInfo.npivPortWorldWideName` to be used by the NPIV VPORTs instantiated for the
	// virtual machine on the physical HBAs of the host. A pair of node and port WWNs
	// serves as a unique identifier in accessing a LUN, so that it can be monitored or
	// controlled by the storage administrator.
	//
	// If this property contains a single node WWN, the same node WWN is used to pair
	// with all port WWNs listed in `VirtualMachineConfigInfo.npivPortWorldWideName`. If this property or
	// `VirtualMachineConfigInfo.npivPortWorldWideName` is empty or unset, NPIV WWN is disabled for the
	// virtual machine.
	NpivNodeWorldWideName []int64 `xml:"npivNodeWorldWideName,omitempty" json:"npivNodeWorldWideName,omitempty"`
	// A 64-bit port WWN (World Wide Name).
	//
	// For detail description on WWN, see
	// `VirtualMachineConfigInfo.npivNodeWorldWideName`.
	NpivPortWorldWideName []int64 `xml:"npivPortWorldWideName,omitempty" json:"npivPortWorldWideName,omitempty"`
	// The source that provides/generates the assigned WWNs.
	//
	// See also `VirtualMachineConfigInfoNpivWwnType_enum`.
	NpivWorldWideNameType string `xml:"npivWorldWideNameType,omitempty" json:"npivWorldWideNameType,omitempty"`
	// The NPIV node WWNs to be extended from the original list of WWN nummbers.
	//
	// This
	// property should be set to desired number which is an aggregate of existing
	// plus new numbers. Desired Node WWNs should always be greater than the existing
	// number of node WWNs
	NpivDesiredNodeWwns int16 `xml:"npivDesiredNodeWwns,omitempty" json:"npivDesiredNodeWwns,omitempty"`
	// The NPIV port WWNs to be extended from the original list of WWN nummbers.
	//
	// This
	// property should be set to desired number which is an aggregate of existing
	// plus new numbers. Desired Node WWNs should always be greater than the existing
	// number of port WWNs
	NpivDesiredPortWwns int16 `xml:"npivDesiredPortWwns,omitempty" json:"npivDesiredPortWwns,omitempty"`
	// This property is used to enable or disable the NPIV capability on a desired
	// virtual machine on a temporary basis.
	//
	// When this property is set NPIV Vport
	// will not be instantiated by the VMX process of the Virtual Machine. When this
	// property is set port WWNs and node WWNs in the VM configuration are preserved.
	NpivTemporaryDisabled *bool `xml:"npivTemporaryDisabled" json:"npivTemporaryDisabled,omitempty"`
	// This property is used to check whether the NPIV can be enabled on the Virtual
	// machine with non-rdm disks in the configuration, so this is potentially not
	// enabling npiv on vmfs disks.
	//
	// Also this property is used to check whether RDM
	// is required to generate WWNs for a virtual machine.
	NpivOnNonRdmDisks *bool `xml:"npivOnNonRdmDisks" json:"npivOnNonRdmDisks,omitempty"`
	// Hash incorporating the virtual machine's config file location
	// and the UUID of the host assigned to run the virtual machine.
	LocationId string `xml:"locationId,omitempty" json:"locationId,omitempty"`
	// Flag indicating whether or not a virtual machine is a template.
	Template bool `xml:"template" json:"template"`
	// Guest operating system configured on a virtual machine.
	//
	// This is a guest identifier that can be used to access the
	// `GuestOsDescriptor`
	// list for information about default configuration.
	// For more information on possible values, see
	// `VirtualMachineGuestOsIdentifier`.
	GuestId string `xml:"guestId" json:"guestId"`
	// Used as display name for the operating system if guestId is `other`
	// or `other-64`.
	//
	// See also `VirtualMachineConfigInfo.guestFullName`.
	AlternateGuestName string `xml:"alternateGuestName" json:"alternateGuestName"`
	// Description for the virtual machine.
	Annotation string `xml:"annotation,omitempty" json:"annotation,omitempty"`
	// Information about the files associated with a virtual machine.
	//
	// This information does not include files for specific virtual disks or
	// snapshots.
	Files VirtualMachineFileInfo `xml:"files" json:"files"`
	// Configuration of VMware Tools running in the guest operating system.
	Tools *ToolsConfigInfo `xml:"tools,omitempty" json:"tools,omitempty"`
	// Additional flags for a virtual machine.
	Flags VirtualMachineFlagInfo `xml:"flags" json:"flags"`
	// Legacy console viewer preferences when doing power operations.
	ConsolePreferences *VirtualMachineConsolePreferences `xml:"consolePreferences,omitempty" json:"consolePreferences,omitempty"`
	// Configuration of default power operations.
	DefaultPowerOps VirtualMachineDefaultPowerOpInfo `xml:"defaultPowerOps" json:"defaultPowerOps"`
	// Whether the next reboot will result in a power off.
	RebootPowerOff *bool `xml:"rebootPowerOff" json:"rebootPowerOff,omitempty" vim:"8.0.0.1"`
	// Processor, memory, and virtual devices for a virtual machine.
	Hardware VirtualHardware `xml:"hardware" json:"hardware"`
	// Vcpu configuration.
	//
	// The <code>vcpuConfig</code> array is indexed
	// by vcpu number.
	VcpuConfig []VirtualMachineVcpuConfig `xml:"vcpuConfig,omitempty" json:"vcpuConfig,omitempty"`
	// Resource limits for CPU.
	CpuAllocation *ResourceAllocationInfo `xml:"cpuAllocation,omitempty" json:"cpuAllocation,omitempty"`
	// Resource limits for memory.
	MemoryAllocation *ResourceAllocationInfo `xml:"memoryAllocation,omitempty" json:"memoryAllocation,omitempty"`
	// The latency-sensitivity of the virtual machine.
	LatencySensitivity *LatencySensitivity `xml:"latencySensitivity,omitempty" json:"latencySensitivity,omitempty"`
	// Whether memory can be added while this virtual machine is running.
	MemoryHotAddEnabled *bool `xml:"memoryHotAddEnabled" json:"memoryHotAddEnabled,omitempty"`
	// Whether virtual processors can be added while this
	// virtual machine is running.
	CpuHotAddEnabled *bool `xml:"cpuHotAddEnabled" json:"cpuHotAddEnabled,omitempty"`
	// Whether virtual processors can be removed while this
	// virtual machine is running.
	CpuHotRemoveEnabled *bool `xml:"cpuHotRemoveEnabled" json:"cpuHotRemoveEnabled,omitempty"`
	// The maximum amount of memory, in MB, than can be added to a
	// running virtual machine.
	//
	// This value is determined by the
	// virtual machine and is specified only if
	// `VirtualMachineConfigInfo.memoryHotAddEnabled`
	// is set to true.
	HotPlugMemoryLimit int64 `xml:"hotPlugMemoryLimit,omitempty" json:"hotPlugMemoryLimit,omitempty"`
	// Memory, in MB that can be added to a running virtual machine
	// must be in increments of this value and needs be a
	// multiple of this value.
	//
	// This value is determined by the virtual machine and is specified
	// only if `VirtualMachineConfigSpec.memoryHotAddEnabled`
	// has been set to true.
	HotPlugMemoryIncrementSize int64 `xml:"hotPlugMemoryIncrementSize,omitempty" json:"hotPlugMemoryIncrementSize,omitempty"`
	// Affinity settings for CPU.
	CpuAffinity *VirtualMachineAffinityInfo `xml:"cpuAffinity,omitempty" json:"cpuAffinity,omitempty"`
	// Deprecated since vSphere 6.0.
	//
	// Affinity settings for memory.
	MemoryAffinity *VirtualMachineAffinityInfo `xml:"memoryAffinity,omitempty" json:"memoryAffinity,omitempty"`
	// Deprecated from vSphere 5.5, shaping policy on VM is not supported.
	//
	// Resource limits for network.
	NetworkShaper *VirtualMachineNetworkShaperInfo `xml:"networkShaper,omitempty" json:"networkShaper,omitempty"`
	// Additional configuration information for the virtual machine.
	ExtraConfig []BaseOptionValue `xml:"extraConfig,omitempty,typeattr" json:"extraConfig,omitempty"`
	// Specifies CPU feature compatibility masks that override the
	// defaults from the `GuestOsDescriptor`
	// of the virtual machine's guest OS.
	//
	// As of vSphere API 6.5 `FeatureMask`
	// is the recommended method for masking virtual machines with
	// hardware version 9 and above (newer). They can be viewed via
	// `featureMask`.
	CpuFeatureMask []HostCpuIdInfo `xml:"cpuFeatureMask,omitempty" json:"cpuFeatureMask,omitempty"`
	// Enumerates the set of datastores that this virtual machine is
	// stored on, as well as the URL identification for each of these.
	//
	// Changes to datastores do not generate property updates on this
	// property. However, when this property is retrieved it returns the
	// current datastore information.
	DatastoreUrl []VirtualMachineConfigInfoDatastoreUrlPair `xml:"datastoreUrl,omitempty" json:"datastoreUrl,omitempty"`
	// Virtual machine swapfile placement policy.
	//
	// This will be unset if the
	// virtual machine's
	// `swapPlacementSupported`
	// capability is false. If swapPlacementSupported is true, the default
	// policy is "inherit".
	//
	// See also `VirtualMachineConfigInfoSwapPlacementType_enum`.
	SwapPlacement string `xml:"swapPlacement,omitempty" json:"swapPlacement,omitempty"`
	// Configuration options for the boot behavior of the virtual machine.
	BootOptions *VirtualMachineBootOptions `xml:"bootOptions,omitempty" json:"bootOptions,omitempty"`
	// Fault Tolerance settings for this virtual machine.
	FtInfo BaseFaultToleranceConfigInfo `xml:"ftInfo,omitempty,typeattr" json:"ftInfo,omitempty"`
	// vSphere Replication settings for this virtual machine.
	//
	// Note this may become deprecated in the future releases. We discourage
	// any unnecessary dependency on this field.
	RepConfig *ReplicationConfigSpec `xml:"repConfig,omitempty" json:"repConfig,omitempty"`
	// vApp meta-data for the virtual machine
	VAppConfig BaseVmConfigInfo `xml:"vAppConfig,omitempty,typeattr" json:"vAppConfig,omitempty"`
	// Indicates whether user-configured virtual asserts will be
	// triggered during virtual machine replay.
	VAssertsEnabled *bool `xml:"vAssertsEnabled" json:"vAssertsEnabled,omitempty"`
	// Indicates whether changed block tracking for this VM's disks
	// is active.
	ChangeTrackingEnabled *bool `xml:"changeTrackingEnabled" json:"changeTrackingEnabled,omitempty"`
	// Information about firmware type for this Virtual Machine.
	//
	// Possible values are described in
	// `GuestOsDescriptorFirmwareType_enum`
	// When creating a new VM:
	// \- If vim.vm.FlagInfo.vbsEnabled is set to <code>true</code> and
	// this property is set to <code>bios</code>, error is returned.
	// \- If this property is unset and vim.vm.FlagInfo.vbsEnabled is set
	// to <code>true</code>, this property is set to <code>efi</code>.
	Firmware string `xml:"firmware,omitempty" json:"firmware,omitempty"`
	// Indicates the maximum number of active remote display connections
	// that the virtual machine will support.
	MaxMksConnections int32 `xml:"maxMksConnections,omitempty" json:"maxMksConnections,omitempty"`
	// Indicates whether the guest operating system will logout any active
	// sessions whenever there are no remote display connections open to
	// the virtual machine.
	GuestAutoLockEnabled *bool `xml:"guestAutoLockEnabled" json:"guestAutoLockEnabled,omitempty"`
	// Specifies that this VM is managed by a VC Extension.
	//
	// See the
	// `managedBy` property in the ConfigSpec
	// for more details.
	ManagedBy *ManagedByInfo `xml:"managedBy,omitempty" json:"managedBy,omitempty"`
	// If set true, memory resource reservation for this virtual machine will always be
	// equal to the virtual machine's memory size; increases in memory size will be
	// rejected when a corresponding reservation increase is not possible.
	MemoryReservationLockedToMax *bool `xml:"memoryReservationLockedToMax" json:"memoryReservationLockedToMax,omitempty"`
	// Set of values to be used only to perform admission control when
	// determining if a host has sufficient resources for the virtual
	// machine to power on.
	InitialOverhead *VirtualMachineConfigInfoOverheadInfo `xml:"initialOverhead,omitempty" json:"initialOverhead,omitempty"`
	// Indicates whether this VM is configured to use nested
	// hardware-assisted virtualization.
	NestedHVEnabled *bool `xml:"nestedHVEnabled" json:"nestedHVEnabled,omitempty"`
	// Indicates whether this VM have vurtual CPU performance counters
	// enabled.
	VPMCEnabled *bool `xml:"vPMCEnabled" json:"vPMCEnabled,omitempty"`
	// Configuration of scheduled hardware upgrades and result from last
	// attempt to run scheduled hardware upgrade.
	//
	// See also `ScheduledHardwareUpgradeInfo`.
	ScheduledHardwareUpgradeInfo *ScheduledHardwareUpgradeInfo `xml:"scheduledHardwareUpgradeInfo,omitempty" json:"scheduledHardwareUpgradeInfo,omitempty"`
	// Fork configuration of this virtual machines.
	//
	// If unset, this virtual machine
	// is not configured for fork.
	//
	// See also `VirtualMachineForkConfigInfo`.
	ForkConfigInfo *VirtualMachineForkConfigInfo `xml:"forkConfigInfo,omitempty" json:"forkConfigInfo,omitempty"`
	// Deprecated since vSphere 7.0 because vFlash Read Cache
	// end of availability.
	//
	// Specifies the total vFlash resource reservation for the vFlash caches associated
	// with this VM's virtual disks, in bytes.
	//
	// This reservation must be allocated to power on the VM.
	// See `VirtualMachineRuntimeInfo.vFlashCacheAllocation` for allocated
	// reservation when VM is powered on.
	VFlashCacheReservation int64 `xml:"vFlashCacheReservation,omitempty" json:"vFlashCacheReservation,omitempty"`
	// A checksum of vmx config file.
	VmxConfigChecksum []byte `xml:"vmxConfigChecksum,omitempty" json:"vmxConfigChecksum,omitempty"`
	// Whether to allow tunneling of clients from the guest VM into the
	// common message bus on the host network.
	MessageBusTunnelEnabled *bool `xml:"messageBusTunnelEnabled" json:"messageBusTunnelEnabled,omitempty"`
	// Virtual Machine Object Identifier.
	//
	// With Object-based Storage systems, Virtual Machine home directory
	// is backed by an object.
	// This identifier will be set only if VM directory resided on
	// object-based storage systems.
	VmStorageObjectId string `xml:"vmStorageObjectId,omitempty" json:"vmStorageObjectId,omitempty"`
	// Virtual Machine Swap Object Identifier.
	//
	// With Object-based Storage systems, VM's Swap is backed by an object.
	// This identifier will be set only if VM swap resided on
	// object-based storage systems.
	SwapStorageObjectId string `xml:"swapStorageObjectId,omitempty" json:"swapStorageObjectId,omitempty"`
	// Virtual Machine cryptographic options.
	KeyId *CryptoKeyId `xml:"keyId,omitempty" json:"keyId,omitempty"`
	// Guest integrity platform configuration
	GuestIntegrityInfo *VirtualMachineGuestIntegrityInfo `xml:"guestIntegrityInfo,omitempty" json:"guestIntegrityInfo,omitempty"`
	// An enum describing whether encrypted vMotion is required for this VM.
	//
	// See `VirtualMachineConfigSpecEncryptedVMotionModes_enum` for allowed values.
	// This defaults to opportunistic for a regular VM, and will be set to
	// required for an encrypted VM.
	MigrateEncryption string `xml:"migrateEncryption,omitempty" json:"migrateEncryption,omitempty"`
	// Configuration of SGX, Software Guard Extensions for the VM.
	SgxInfo *VirtualMachineSgxInfo `xml:"sgxInfo,omitempty" json:"sgxInfo,omitempty"`
	// Content Library Item info.
	ContentLibItemInfo *VirtualMachineContentLibraryItemInfo `xml:"contentLibItemInfo,omitempty" json:"contentLibItemInfo,omitempty"`
	// An enum describing whether encrypted Fault Tolerance is required for this
	// VM.
	//
	// See `VirtualMachineConfigSpecEncryptedFtModes_enum` for allowed values.
	// \- This defaults to opportunistic for a regular VM, and will be set to
	// required for an encrypted VM.
	// \- If this property is unset, the mode of encrypted Fault Tolerance
	// will be set to opportunistic.
	FtEncryptionMode string `xml:"ftEncryptionMode,omitempty" json:"ftEncryptionMode,omitempty" vim:"7.0.2.0"`
	// GMM configuration
	GuestMonitoringModeInfo *VirtualMachineGuestMonitoringModeInfo `xml:"guestMonitoringModeInfo,omitempty" json:"guestMonitoringModeInfo,omitempty"`
	// SEV (Secure Encrypted Virtualization) enabled or not.
	//
	// SEV is enabled
	// when set to true, and disabled otherwise.
	SevEnabled *bool `xml:"sevEnabled" json:"sevEnabled,omitempty" vim:"7.0.1.0"`
	// vNUMA info.
	NumaInfo *VirtualMachineVirtualNumaInfo `xml:"numaInfo,omitempty" json:"numaInfo,omitempty" vim:"8.0.0.1"`
	// Property to indicate PMem HA failover configuration.
	//
	// \- When set to TRUE, VMs configured to use PMem
	// will be failed over to other hosts by HA, but the data
	// in NVDIMM is not persistent.
	// \- When set to FALSE, VMs configured to use PMem will not
	// be failed over to other hosts by HA.
	// Property is currently only applicable to VMs with NVDimms and
	// will fail to set True if vPMem disks are present.
	PmemFailoverEnabled *bool `xml:"pmemFailoverEnabled" json:"pmemFailoverEnabled,omitempty" vim:"7.0.2.0"`
	// Indicates whether VMXStats Collection is enabled/disabled.
	//
	// \- If TRUE, VMXStats is enabled for the VM and a scoreboard
	// file is created to store stats for various VMX components.
	// \- If FALSE, VMXStats is disabled for the VM and there is
	// no scoreboard file created.
	VmxStatsCollectionEnabled *bool `xml:"vmxStatsCollectionEnabled" json:"vmxStatsCollectionEnabled,omitempty" vim:"7.0.3.1"`
	// Indicates whether operation notification to applications is
	// enabled/disabled.
	//
	// \- When set to TRUE, application running inside the VM will be
	// notified of operations for which they have registered.
	// \- If unset or FALSE, new applications are not allowed to register
	// for notifications and RPCs will no longer be supported from
	// already registered applications.
	VmOpNotificationToAppEnabled *bool `xml:"vmOpNotificationToAppEnabled" json:"vmOpNotificationToAppEnabled,omitempty" vim:"7.0.3.0"`
	// Operation notification timeout in seconds.
	//
	// \- Specifies the maximum time the application can take to
	// prepare for the operation after its been notified. This value is used
	// only if `VirtualMachineConfigInfo.vmOpNotificationToAppEnabled` is set to TRUE.
	// \- If `VirtualMachineConfigInfo.vmOpNotificationTimeout` is unset, then it defaults to
	// cluster/host timeout.
	VmOpNotificationTimeout int64 `xml:"vmOpNotificationTimeout,omitempty" json:"vmOpNotificationTimeout,omitempty" vim:"8.0.0.1"`
	// Status of the device swap operation.
	DeviceSwap *VirtualMachineVirtualDeviceSwap `xml:"deviceSwap,omitempty" json:"deviceSwap,omitempty" vim:"8.0.0.1"`
	// Virtual persistent memory info.
	Pmem *VirtualMachineVirtualPMem `xml:"pmem,omitempty" json:"pmem,omitempty" vim:"7.0.3.0"`
	// Assignable hardware device groups.
	DeviceGroups *VirtualMachineVirtualDeviceGroups `xml:"deviceGroups,omitempty" json:"deviceGroups,omitempty" vim:"8.0.0.1"`
	// Indicates whether support to add and remove fixed passthrough
	// devices when the VM is running is enabled.
	//
	// When the virtual machine is powered on, this indicates if
	// support for hot adding and removing fixed passthrough devices
	// was enabled prior to power on. Otherwise, it indicates whether
	// it will be enabled when the VM is powered on.
	// NOTE: When setting this to true, the memory reservation should
	// be equal to the guest memory size or the option to reserve all
	// guest memory should be selected. If unset, the current value is
	// left unchanged.
	FixedPassthruHotPlugEnabled *bool `xml:"fixedPassthruHotPlugEnabled" json:"fixedPassthruHotPlugEnabled,omitempty" vim:"8.0.1.0"`
	// Indicates whether FT Metro Cluster is enabled/disabled.
	//
	// \- If TRUE, FT Metro Cluster is enabled for the VM. An implicit
	// Anti-HostGroup will be generated from HostGroup defined for FT
	// primary, then affine the primary with one HostGroup and affine the
	// secondary with another HostGroup.
	// \- If FALSE or unset, FT Metro Cluster is disabled for the VM. Both FT
	// primary and secondary will be put in the same HostGroup.
	MetroFtEnabled *bool `xml:"metroFtEnabled" json:"metroFtEnabled,omitempty" vim:"8.0.3.0"`
	// Indicate the Host Group (`ClusterHostGroup`) for FT
	// Metro Cluster enabled Virtual Machine.
	//
	// Based on the selected Host Group, FT can divide the hosts in the cluster
	// into two groups and ensure to place FT primary and FT secondary in
	// different groups.
	MetroFtHostGroup string `xml:"metroFtHostGroup,omitempty" json:"metroFtHostGroup,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["VirtualMachineConfigInfo"] = reflect.TypeOf((*VirtualMachineConfigInfo)(nil)).Elem()
}

// Contains the name of a datastore, and its local file path on the host
// currently affiliated with this virtual machine.
type VirtualMachineConfigInfoDatastoreUrlPair struct {
	DynamicData

	Name string `xml:"name" json:"name"`
	Url  string `xml:"url" json:"url"`
}

func init() {
	t["VirtualMachineConfigInfoDatastoreUrlPair"] = reflect.TypeOf((*VirtualMachineConfigInfoDatastoreUrlPair)(nil)).Elem()
}

// Information about virtualization overhead required to power on the
// virtual machine on the registered host.
type VirtualMachineConfigInfoOverheadInfo struct {
	DynamicData

	// Memory overhead required for virtual machine to be powered on (in bytes).
	InitialMemoryReservation int64 `xml:"initialMemoryReservation,omitempty" json:"initialMemoryReservation,omitempty"`
	// Disk space required for virtual machine to be powered on (in bytes).
	//
	// This space is used by virtualization infrastructure to swap out
	// virtual machine process memory. Location of the file is specified by
	// sched.swap.vmxSwapDir virtual machinge advanced config option or
	// in case it is not specified - current virtual machine home directory
	// is being used.
	InitialSwapReservation int64 `xml:"initialSwapReservation,omitempty" json:"initialSwapReservation,omitempty"`
}

func init() {
	t["VirtualMachineConfigInfoOverheadInfo"] = reflect.TypeOf((*VirtualMachineConfigInfoOverheadInfo)(nil)).Elem()
}

// This configuration data object type contains information about the execution
// environment for a virtual machine.
//
// This includes information about which features are
// supported, such as:
//   - Which guest operating systems are supported.
//   - How devices are emulated. For example, that a CD-ROM drive can be emulated
//     with a file or that a serial port can be emulated with a pipe.
//
// VirtualCenter can provide a broader environment than any single physical host. This
// is a departure from traditional virtualization approaches, which rely on the host
// system to define the environment for virtual machines. This data object describes
// environment capabilities and is used by VirtualCenter to choose hosts on which to run
// virtual machines.
type VirtualMachineConfigOption struct {
	DynamicData

	// The version corresponding to this configOption.
	Version string `xml:"version" json:"version"`
	// A description string for this configOption.
	Description string `xml:"description" json:"description"`
	// List of supported guest operating systems.
	//
	// The choice of guest operating system may limit the set of valid devices.
	// For example, you cannot select Vmxnet with all guest operating systems.
	GuestOSDescriptor []GuestOsDescriptor `xml:"guestOSDescriptor" json:"guestOSDescriptor"`
	// Index into guestOsDescriptor array denoting the default guest
	// operating system.
	GuestOSDefaultIndex int32 `xml:"guestOSDefaultIndex" json:"guestOSDefaultIndex"`
	// Processor, memory, and virtual device options for a virtual machine.
	HardwareOptions VirtualHardwareOption `xml:"hardwareOptions" json:"hardwareOptions"`
	// Capabilities supported by a virtual machine.
	Capabilities VirtualMachineCapability `xml:"capabilities" json:"capabilities"`
	// The datastore options for this virtual machine.
	Datastore DatastoreOption `xml:"datastore" json:"datastore"`
	// The list of virtual devices that are created on a virtual machine by default.
	//
	// Clients should not create these devices.
	DefaultDevice []BaseVirtualDevice `xml:"defaultDevice,omitempty,typeattr" json:"defaultDevice,omitempty"`
	// The monitor types supported by a host.
	//
	// The acceptable monitor types
	// are enumerated by `VirtualMachineFlagInfoMonitorType_enum`.
	SupportedMonitorType []string `xml:"supportedMonitorType" json:"supportedMonitorType"`
	// Specifies the supported property transports that are
	// available for the OVF environment
	SupportedOvfEnvironmentTransport []string `xml:"supportedOvfEnvironmentTransport,omitempty" json:"supportedOvfEnvironmentTransport,omitempty"`
	// Specifies the supported transports for the OVF
	// installation phase.
	SupportedOvfInstallTransport []string `xml:"supportedOvfInstallTransport,omitempty" json:"supportedOvfInstallTransport,omitempty"`
	// The relations between the properties of the virtual
	// machine config spec.
	PropertyRelations []VirtualMachinePropertyRelation `xml:"propertyRelations,omitempty" json:"propertyRelations,omitempty"`
}

func init() {
	t["VirtualMachineConfigOption"] = reflect.TypeOf((*VirtualMachineConfigOption)(nil)).Elem()
}

// Contains the definition of a unique key that can be used to
// retrieve a configOption object.
type VirtualMachineConfigOptionDescriptor struct {
	DynamicData

	// A unique key used to identify a configOption object in this
	// `EnvironmentBrowser`.
	Key string `xml:"key" json:"key"`
	// A description of the configOption object.
	Description string `xml:"description,omitempty" json:"description,omitempty"`
	// List of hosts to which this descriptor applies.
	//
	// List of hosts is not set when descriptor is returned
	// from `Datacenter.queryDatacenterConfigOptionDescriptor`.
	//
	// Refers instances of `HostSystem`.
	Host []ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// Indicates whether the associated set of configuration options
	// can be used for virtual machine creation on a given host or
	// cluster.
	CreateSupported *bool `xml:"createSupported" json:"createSupported,omitempty"`
	// Indicates whether the associated set of virtual machine
	// configuration options is the default one for a given host or
	// cluster.
	//
	// Latest version is marked as default unless
	// other version is specified via
	// `ComputeResourceConfigInfo.defaultHardwareVersionKey`
	// or `DatacenterConfigInfo.defaultHardwareVersionKey`.
	// If this setting is TRUE, virtual machine creates will use the
	// associated set of configuration options, unless a config version is
	// explicitly specified in the `ConfigSpec`.
	DefaultConfigOption *bool `xml:"defaultConfigOption" json:"defaultConfigOption,omitempty"`
	// Indicates whether the associated set of configuration options
	// can be used to power on a virtual machine on a given host or
	// cluster.
	RunSupported *bool `xml:"runSupported" json:"runSupported,omitempty"`
	// Indicates whether the associated set of configuration options
	// can be used as a virtual hardware upgrade target.
	UpgradeSupported *bool `xml:"upgradeSupported" json:"upgradeSupported,omitempty"`
}

func init() {
	t["VirtualMachineConfigOptionDescriptor"] = reflect.TypeOf((*VirtualMachineConfigOptionDescriptor)(nil)).Elem()
}

// This data object type encapsulates configuration settings
// when creating or reconfiguring a virtual machine.
//
// To support incremental changes,
// these properties are all optional. If an optional property is unset,
// or any nested optional property is unset, the property will not
// be changed unless 'unset' is a valid value for the property. To determine
// whether 'unset' is a valid value for a particular property, refer to
// the documentation for that property.
type VirtualMachineConfigSpec struct {
	DynamicData

	// If specified, the changes are only applied if the current changeVersion matches
	// the specified changeVersion.
	//
	// This field can be used to guard against updates that
	// have happened between when configInfo is read and when it is applied.
	//
	// For more information about how configurations are uniquely identified, see
	// `VirtualMachineConfigInfo.changeVersion`.
	ChangeVersion string `xml:"changeVersion,omitempty" json:"changeVersion,omitempty"`
	// Display name of the virtual machine.
	//
	// Any % (percent) character used in this name parameter must be escaped, unless it
	// is used to start an escape sequence. Clients may also escape any other characters
	// in this name parameter. Snapshots of virtual machines that have spaces in their
	// names and are associated with ESX 2.x servers are not supported. Therefore, if you
	// want the option to take snapshots of this virtual machine and you are associating
	// it with an ESX 2.x server, do not use spaces in the name.
	//
	// Reconfigure privilege: VirtualMachine.Config.Rename
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// The version string for this virtual machine.
	//
	// This is used only while
	// creating a new virtual machine, and can be updated by invoking
	// `VirtualMachine.UpgradeVM_Task` for this virtual
	// machine.
	Version string `xml:"version,omitempty" json:"version,omitempty"`
	// Creation date of a virtual machine represented in DateTime format.
	//
	// This property is populated by the vCenter Server with the date
	// and time of creation of the virtual machine. Values provided by the
	// client will be ignored.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	CreateDate *time.Time `xml:"createDate" json:"createDate,omitempty"`
	// 128-bit SMBIOS UUID of a virtual machine represented as a hexadecimal string
	// in "12345678-abcd-1234-cdef-123456789abc" format.
	//
	// Normally, this property is not set by a client, allowing the
	// Virtual Infrastructure environment to assign a UUID when
	// the virtual machine is created. However, in some rare cases,
	// such as a manual copy of a virtual machine, it may be necessary
	// to set this property.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// VirtualCenter-specific 128-bit UUID of a virtual machine, represented
	// as a hexadecimal string.
	//
	// This identifier is used by VirtalCenter
	// to uniquely identify all virtual machine instances in the Virtual
	// Infrastructure environment, including those that may share the same
	// SMBIOS UUID.
	//
	// Normally, this property is not set by a client, allowing the
	// Virtual Infrastructure environment to assign or change it when
	// VirtualCenter detects an identifier conflict between virtual
	// machines. This identifier can be modified even when a virtual
	// machine is powered on. Clients can specify that vCenter Server
	// reassign a new identifier by a providing an empty string. Reassigning
	// the identifer is not allowed for Fault Tolerance virtual machines.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	InstanceUuid string `xml:"instanceUuid,omitempty" json:"instanceUuid,omitempty"`
	// The NPIV node WWN to be assigned to a virtual machine.
	//
	// This property should only
	// be used or set when the value of `VirtualMachineConfigSpec.npivWorldWideNameOp` property is "set".
	// Otherwise, an `InvalidVmConfig` fault will be thrown. If the
	// specified node WWN is currently being used by another virtual machine, a
	// `VmWwnConflict` fault will be thrown.
	//
	// For detail description on WWN, see `VirtualMachineConfigInfo.npivNodeWorldWideName`.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings.
	NpivNodeWorldWideName []int64 `xml:"npivNodeWorldWideName,omitempty" json:"npivNodeWorldWideName,omitempty"`
	// The NPIV port WWN to be assigned to a virtual machine.
	//
	// This property should only
	// be used or set when the value of `VirtualMachineConfigSpec.npivWorldWideNameOp` property is "set".
	// Otherwise, an `InvalidVmConfig` fault will be thrown. If the
	// specified port WWN is currently being used by another virtual machine, a
	// `VmWwnConflict` fault will be thrown.
	//
	// For detail description on WWN, see `VirtualMachineConfigInfo.npivPortWorldWideName`.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings.
	NpivPortWorldWideName []int64 `xml:"npivPortWorldWideName,omitempty" json:"npivPortWorldWideName,omitempty"`
	// This property is used internally in the communication between the
	// VirtualCenter server and ESX Server to indicate the source for
	// `VirtualMachineConfigSpec.npivNodeWorldWideName` and
	// `VirtualMachineConfigSpec.npivPortWorldWideName` when `VirtualMachineConfigSpec.npivWorldWideNameOp` is "set".
	//
	// This property should only be set by the VirtualCenter server.
	//
	// If this property is set in a call to a VirtualCenter server,
	// an `InvalidVmConfig` fault will always be thrown. In a
	// call to an ESX Server host, an `InvalidVmConfig`
	// fault will be thrown if the value of `VirtualMachineConfigSpec.npivWorldWideNameOp` is not set to
	// "set".
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings.
	NpivWorldWideNameType string `xml:"npivWorldWideNameType,omitempty" json:"npivWorldWideNameType,omitempty"`
	// The NPIV node WWNs to be extended from the original list of WWN nummbers.
	//
	// This
	// property should be set to desired number which is an aggregate of existing
	// plus new numbers. Desired Node WWNs should always be greater than the existing
	// number of node WWNs
	NpivDesiredNodeWwns int16 `xml:"npivDesiredNodeWwns,omitempty" json:"npivDesiredNodeWwns,omitempty"`
	// The NPIV port WWNs to be extended from the original list of WWN nummbers.
	//
	// This
	// property should be set to desired number which is an aggregate of existing
	// plus new numbers. Desired Node WWNs should always be greater than the existing
	// number of port WWNs
	NpivDesiredPortWwns int16 `xml:"npivDesiredPortWwns,omitempty" json:"npivDesiredPortWwns,omitempty"`
	// This property is used to enable or disable the NPIV capability on a desired
	// virtual machine on a temporary basis.
	//
	// When this property is set NPIV Vport
	// will not be instantiated by the VMX process of the Virtual Machine. When this
	// property is set port WWNs and node WWNs in the VM configuration are preserved.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings.
	NpivTemporaryDisabled *bool `xml:"npivTemporaryDisabled" json:"npivTemporaryDisabled,omitempty"`
	// This property is used to check whether the NPIV can be enabled on the Virtual
	// machine with non-rdm disks in the configuration, so this is potentially not
	// enabling npiv on vmfs disks.
	//
	// Also this property is used to check whether RDM
	// is required to generate WWNs for a virtual machine.
	NpivOnNonRdmDisks *bool `xml:"npivOnNonRdmDisks" json:"npivOnNonRdmDisks,omitempty"`
	// The flag to indicate what type of NPIV WWN operation is going to be performed
	// on the virtual machine.
	//
	// If unset, it indicates no change to existing NPIV WWN
	// assignment (or not assigned) in the virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings.
	//
	// See also `VirtualMachineConfigSpecNpivWwnOp_enum`.
	NpivWorldWideNameOp string `xml:"npivWorldWideNameOp,omitempty" json:"npivWorldWideNameOp,omitempty"`
	// 128-bit hash based on the virtual machine's configuration file location
	// and the UUID of the host assigned to run the virtual machine.
	//
	// Normally, this property is not set by a client, allowing the
	// Virtual Infrastructure environment to assign a location ID when
	// the virtual machine is created. However, if the virtual machine's
	// configuration file has been manually moved, it may be desirable to clear this
	// property, setting it to an empty string, so the property is regenerated.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	LocationId string `xml:"locationId,omitempty" json:"locationId,omitempty"`
	// Short guest operating system identifier.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	GuestId string `xml:"guestId,omitempty" json:"guestId,omitempty"`
	// Full name for guest, if guestId is specified as `other`
	// or `other-64`.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	AlternateGuestName string `xml:"alternateGuestName,omitempty" json:"alternateGuestName,omitempty"`
	// User-provided description of the virtual machine.
	//
	// Because this property
	// is optional in the virtual machine configuration, it is necessary
	// to pass an explicit empty string in a ConfigSpec object to remove an annotation
	// that is already present in the `VirtualMachineConfigInfo`
	// for a virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.Rename
	Annotation string `xml:"annotation,omitempty" json:"annotation,omitempty"`
	// Information about virtual machine files.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	Files *VirtualMachineFileInfo `xml:"files,omitempty" json:"files,omitempty"`
	// Configuration of VMware Tools running in the guest operating system.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	Tools *ToolsConfigInfo `xml:"tools,omitempty" json:"tools,omitempty"`
	// Additional flags for a virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	Flags *VirtualMachineFlagInfo `xml:"flags,omitempty" json:"flags,omitempty"`
	// Legacy console viewer preferences that are used with power operations.
	//
	// For
	// example, power on.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	ConsolePreferences *VirtualMachineConsolePreferences `xml:"consolePreferences,omitempty" json:"consolePreferences,omitempty"`
	// Configuration for default power operations.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	PowerOpInfo *VirtualMachineDefaultPowerOpInfo `xml:"powerOpInfo,omitempty" json:"powerOpInfo,omitempty"`
	// Whether the next reboot will result in a power off.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	RebootPowerOff *bool `xml:"rebootPowerOff" json:"rebootPowerOff,omitempty" vim:"8.0.0.1"`
	// Number of virtual processors in a virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.CpuCount
	NumCPUs int32 `xml:"numCPUs,omitempty" json:"numCPUs,omitempty"`
	// Vcpu configuration.
	//
	// The <code>vcpuConfig</code> array is indexed
	// by vcpu number.
	VcpuConfig []VirtualMachineVcpuConfig `xml:"vcpuConfig,omitempty" json:"vcpuConfig,omitempty"`
	// Number of cores among which to distribute
	// CPUs in this virtual machine.
	//
	// Set "numCoresPerSocket" with a non-zero value
	// to manually configure coresPerSocket size.
	// Set "numCoresPerSocket" with zero to remove any manual size
	// if present, and use default coresPerSocket behavior.
	// Leave "numCoresPerSocket" unset to continue with existing
	// configuration (either manual or default).
	NumCoresPerSocket int32 `xml:"numCoresPerSocket,omitempty" json:"numCoresPerSocket,omitempty"`
	// Size of a virtual machine's memory, in MB.
	//
	// Reconfigure privilege: VirtualMachine.Config.Memory
	MemoryMB int64 `xml:"memoryMB,omitempty" json:"memoryMB,omitempty"`
	// Indicates whether or not memory can be added to the virtual
	// machine while it is running.
	//
	// This attribute can only be set when the virtual machine is
	// powered-off.
	//
	// Reconfigure privilege: VirtualMachine.Config.Memory
	MemoryHotAddEnabled *bool `xml:"memoryHotAddEnabled" json:"memoryHotAddEnabled,omitempty"`
	// Indicates whether or not virtual processors can be added to
	// the virtual machine while it is running.
	//
	// This attribute can only be set when the virtual machine is
	// powered-off.
	//
	// Reconfigure privilege: VirtualMachine.Config.CpuCount
	CpuHotAddEnabled *bool `xml:"cpuHotAddEnabled" json:"cpuHotAddEnabled,omitempty"`
	// Indicates whether or not virtual processors can be removed
	// from the virtual machine while it is running.
	//
	// This attribute can only be set when the virtual machine is
	// powered-off.
	//
	// Reconfigure privilege: VirtualMachine.Config.CpuCount
	CpuHotRemoveEnabled *bool `xml:"cpuHotRemoveEnabled" json:"cpuHotRemoveEnabled,omitempty"`
	// Does this virtual machine have Virtual Intel I/O Controller Hub 7
	VirtualICH7MPresent *bool `xml:"virtualICH7MPresent" json:"virtualICH7MPresent,omitempty"`
	// Does this virtual machine have System Management Controller
	VirtualSMCPresent *bool `xml:"virtualSMCPresent" json:"virtualSMCPresent,omitempty"`
	// Set of virtual devices being modified by the configuration operation.
	//
	// Reconfigure privileges:
	//   - VirtualMachine.Config.Resource if setting the "shares" property of
	//     a new or existing VirtualDisk device
	//   - VirtualMachine.Config.RawDevice if adding, removing, or modifying a
	//     raw device (also required when creating a virtual machine)
	//   - VirtualMachine.Config.HostUSBDevice if adding, removing, or
	//     modifying a VirtualUSB device backed by a host USB device (also
	//     required when creating a virtual machine).
	//   - VirtualMachine.Interact.DeviceConnection if setting the "connectable"
	//     property of a connectable device
	//   - VirtualMachine.Interact.SetCDMedia if setting the "backing" property
	//     of a VirtualCdrom device
	//   - VirtualMachine.Interact.SetFloppyMedia if setting the "backing" property
	//     of a VirtualFloppy device
	//   - VirtualMachine.Config.EditDevice if setting any property of a
	//     non-CDROM non-Floppy device
	//   - VirtualMachine.Config.AddExistingDisk if adding a VirtualDisk, and
	//     the fileOperation is unset (also required when creating a virtual machine)
	//   - VirtualMachine.Config.AddNewDisk if adding a VirtualDisk and the
	//     fileOperation is set (also required when creating a virtual machine)
	//   - VirtualMachine.Config.RemoveDisk if removing a VirtualDisk device
	//   - VirtualMachine.Config.AddRemoveDevice if adding or removing any
	//     device other than disk, raw, or USB device.
	//   - Network.Assign if if setting the "backing" property of a
	//     VirtualEthernetCard device.
	DeviceChange []BaseVirtualDeviceConfigSpec `xml:"deviceChange,omitempty,typeattr" json:"deviceChange,omitempty"`
	// Resource limits for CPU.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	CpuAllocation *ResourceAllocationInfo `xml:"cpuAllocation,omitempty" json:"cpuAllocation,omitempty"`
	// Resource limits for memory.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	MemoryAllocation *ResourceAllocationInfo `xml:"memoryAllocation,omitempty" json:"memoryAllocation,omitempty"`
	// The latency-sensitivity setting of the virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	LatencySensitivity *LatencySensitivity `xml:"latencySensitivity,omitempty" json:"latencySensitivity,omitempty"`
	// Affinity settings for CPU.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	CpuAffinity *VirtualMachineAffinityInfo `xml:"cpuAffinity,omitempty" json:"cpuAffinity,omitempty"`
	// Deprecated since vSphere 6.0.
	//
	// Affinity settings for memory.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	MemoryAffinity *VirtualMachineAffinityInfo `xml:"memoryAffinity,omitempty" json:"memoryAffinity,omitempty"`
	// Deprecated from vSphere 5.5, shaping policy on VM is not supported.
	//
	// Resource limits for network.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	NetworkShaper *VirtualMachineNetworkShaperInfo `xml:"networkShaper,omitempty" json:"networkShaper,omitempty"`
	// Specifies the CPU feature compatibility masks.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	// As of vSphere API 6.5 `FeatureMask`
	// is the recommended method for masking virtual machines with
	// hardware version 9 and above (newer).
	CpuFeatureMask []VirtualMachineCpuIdInfoSpec `xml:"cpuFeatureMask,omitempty" json:"cpuFeatureMask,omitempty"`
	// Additional configuration information for the virtual machine.
	//
	// This describes a set of modifications to the additional options. If the key is
	// already present, it will be reset with the new value provided. Otherwise, a new
	// option is added. Keys with empty values will be removed.
	//
	// Configuration keys that would conflict with parameters that are explicitly
	// configurable through other fields in the ConfigSpec object are silently ignored.
	//
	// Reconfigure privilege: VirtualMachine.Config.AdvancedConfig
	// (also required when setting this property while creating a virtual machine)
	ExtraConfig []BaseOptionValue `xml:"extraConfig,omitempty,typeattr" json:"extraConfig,omitempty"`
	// Virtual machine swapfile placement policy.
	//
	// This may only be set if the
	// `swapPlacementSupported`
	// capability is true for this virtual machine. Any change to this policy
	// will take effect the next time the virtual machine powers on, resumes
	// from a suspended state, or migrates while powered on.
	//
	// Reconfigure privilege: VirtualMachine.Config.SwapPlacement
	// (also required when setting this property while creating a virtual machine)
	//
	// See also `VirtualMachineConfigInfoSwapPlacementType_enum`.
	SwapPlacement string `xml:"swapPlacement,omitempty" json:"swapPlacement,omitempty"`
	// Settings that control the boot behavior of the virtual
	// machine.
	//
	// These settings take effect during the next power-on
	// of the virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	BootOptions *VirtualMachineBootOptions `xml:"bootOptions,omitempty" json:"bootOptions,omitempty"`
	// Configuration of vApp meta-data for a virtual machine
	VAppConfig BaseVmConfigSpec `xml:"vAppConfig,omitempty,typeattr" json:"vAppConfig,omitempty"`
	// Fault Tolerance settings for this virtual machine.
	FtInfo BaseFaultToleranceConfigInfo `xml:"ftInfo,omitempty,typeattr" json:"ftInfo,omitempty"`
	// vSphere Replication settings.
	//
	// Note this may become deprecated in the future releases. We
	// discourage any unnecessary dependency on this field.
	RepConfig *ReplicationConfigSpec `xml:"repConfig,omitempty" json:"repConfig,omitempty"`
	// Set to true, if the vApp configuration should be removed
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	VAppConfigRemoved *bool `xml:"vAppConfigRemoved" json:"vAppConfigRemoved,omitempty"`
	// Indicates whether user-configured virtual asserts will be
	// triggered during virtual machine replay.
	//
	// This setting takes
	// effect during the next replay of the virtual machine.
	//
	// Enabling this functionality can potentially cause some
	// performance overhead during virtual machine execution.
	VAssertsEnabled *bool `xml:"vAssertsEnabled" json:"vAssertsEnabled,omitempty"`
	// Setting to control enabling/disabling changed block tracking for
	// the virtual disks of this VM.
	//
	// This may only be set if the
	// `changeTrackingSupported`
	// capability is true for this virtual machine. Any change to this property
	// will take effect the next time the virtual machine powers on, resumes
	// from a suspended state, performs a snapshot create/delete/revert operation
	// or migrates while powered on.
	//
	// Reconfigure privilege: VirtualMachine.Config.ChangeTracking
	// (also required when setting this property while creating a virtual machine)
	ChangeTrackingEnabled *bool `xml:"changeTrackingEnabled" json:"changeTrackingEnabled,omitempty"`
	// Set the desired firmware type for this Virtual Machine.
	//
	// Possible values are described in
	// `GuestOsDescriptorFirmwareType_enum`
	Firmware string `xml:"firmware,omitempty" json:"firmware,omitempty"`
	// If set, this setting limits the maximum number of active remote
	// display connections that the virtual machine will support to
	// the specified value.
	//
	// Reconfigure privilege: VirtualMachine.Config.MksControl
	MaxMksConnections int32 `xml:"maxMksConnections,omitempty" json:"maxMksConnections,omitempty"`
	// If set to True, this causes the guest operating system to automatically
	// logout any active sessions whenever there are no remote display
	// connections open to the virtual machine.
	//
	// Reconfigure privilege: VirtualMachine.Config.MksControl
	GuestAutoLockEnabled *bool `xml:"guestAutoLockEnabled" json:"guestAutoLockEnabled,omitempty"`
	// Specifies that this VM is managed by a VC Extension.
	//
	// This information is primarily used in the Client to show a custom icon for
	// managed virtual machines, and a description of the function of the virtual
	// machine. If no extension can be found with the extension key in the
	// `managedBy` object, or the type is not found
	// in the `managedEntityInfo` list of the
	// extension, the default virtual machine icon is used, and no description is
	// shown.
	// To unset this field pass a `ManagedByInfo` object with an
	// empty `extensionKey`.
	//
	// Reconfigure privilege: VirtualMachine.Config.ManagedBy
	ManagedBy *ManagedByInfo `xml:"managedBy,omitempty" json:"managedBy,omitempty"`
	// If set true, memory resource reservation for this virtual machine will always be
	// equal to the virtual machine's memory size; increases in memory size will be
	// rejected when a corresponding reservation increase is not possible.
	//
	// This feature
	// may only be enabled if it is currently possible to reserve all of the virtual machine's memory.
	//
	// Reconfigure privilege: VirtualMachine.Config.Resource
	MemoryReservationLockedToMax *bool `xml:"memoryReservationLockedToMax" json:"memoryReservationLockedToMax,omitempty"`
	// Specifies that this VM will use nested hardware-assisted virtualization.
	//
	// When creating a new VM:
	// \- If vim.vm.FlagInfo.vbsEnabled is set to <code>true</code>,
	// and this flag is set to <code>false</code> error is returned.
	// \- If this flag is unset and vim.vm.FlagInfo.vbsEnabled is set to
	// <code>true</code>, the value of this flag is set to <code>true</code>.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	NestedHVEnabled *bool `xml:"nestedHVEnabled" json:"nestedHVEnabled,omitempty"`
	// Specifies that this VM will have virtual CPU performance counters
	// enabled.
	//
	// Reconfigure privilege: VirtualMachine.Config.Settings
	VPMCEnabled *bool `xml:"vPMCEnabled" json:"vPMCEnabled,omitempty"`
	// Configuration of scheduled hardware upgrades.
	//
	// Reconfigure privilege: VirtualMachine.Config.UpgradeVirtualHardware
	//
	// See also `ScheduledHardwareUpgradeInfo`.
	ScheduledHardwareUpgradeInfo *ScheduledHardwareUpgradeInfo `xml:"scheduledHardwareUpgradeInfo,omitempty" json:"scheduledHardwareUpgradeInfo,omitempty"`
	// Virtual Machine Profile requirement.
	//
	// Profiles are solution specific.
	// Profile Based Storage Management is a vSphere server extension.
	// API users who want to provision VMs using Storage Profiles, need to
	// interact with it.
	// This is an optional parameter and if user doesn't specify profile,
	// the default behavior will apply.
	VmProfile []BaseVirtualMachineProfileSpec `xml:"vmProfile,omitempty,typeattr" json:"vmProfile,omitempty"`
	// Whether to allow tunneling of clients from the guest VM into the
	// common message bus on the host network.
	MessageBusTunnelEnabled *bool `xml:"messageBusTunnelEnabled" json:"messageBusTunnelEnabled,omitempty"`
	// Virtual Machine cryptographic options.
	//
	// The cryptographic options are inherited to all disks of the VM.
	// The cryptographic options for a disk can be different by setting
	// its CryptoSpec.
	Crypto BaseCryptoSpec `xml:"crypto,omitempty,typeattr" json:"crypto,omitempty"`
	// An enum describing whether encrypted vMotion is required for this VM.
	//
	// Supported values are listed in `VirtualMachineConfigSpecEncryptedVMotionModes_enum`.
	// This defaults to opportunistic for a regular VM, and will be set to
	// required for an encrypted VM.
	MigrateEncryption string `xml:"migrateEncryption,omitempty" json:"migrateEncryption,omitempty"`
	// Configuration of SGX, Software Guard Extensions for the VM.
	SgxInfo *VirtualMachineSgxInfo `xml:"sgxInfo,omitempty" json:"sgxInfo,omitempty"`
	// An enum describing whether encrypted Fault Tolerance is required
	// for this VM.
	//
	// Supported values are listed in `VirtualMachineConfigSpecEncryptedFtModes_enum`.
	// \- This defaults to opportunistic for a regular VM, and will be set to
	// required for an encrypted VM.
	// \- If this property is unset, the mode of encrypted Fault Tolerance
	// will be set to opportunistic.
	FtEncryptionMode string `xml:"ftEncryptionMode,omitempty" json:"ftEncryptionMode,omitempty" vim:"7.0.2.0"`
	// Configuration of GMM, Guest Monitoring Mode for the VM.
	GuestMonitoringModeInfo *VirtualMachineGuestMonitoringModeInfo `xml:"guestMonitoringModeInfo,omitempty" json:"guestMonitoringModeInfo,omitempty"`
	// SEV (Secure Encrypted Virtualization) enabled or not.
	//
	// SEV is enabled when
	// set to true, and disabled otherwise.
	SevEnabled *bool `xml:"sevEnabled" json:"sevEnabled,omitempty" vim:"7.0.1.0"`
	// Virtual NUMA information for this VM.
	VirtualNuma *VirtualMachineVirtualNuma `xml:"virtualNuma,omitempty" json:"virtualNuma,omitempty" vim:"8.0.0.1"`
	// One of motherboardLayout choices.
	//
	// Default is i440bxHostBridge. See
	// `VirtualHardware.motherboardLayout`
	MotherboardLayout string `xml:"motherboardLayout,omitempty" json:"motherboardLayout,omitempty" vim:"8.0.0.1"`
	// Property to enable/disable PMem HA failover.
	//
	// \- When set to TRUE, VMs configured to use PMem
	// will be failed over to other hosts by HA, but the data
	// in NVDIMM is not persistent.
	// \- When set to FALSE, VMs configured to use PMem will not
	// be failed over to other hosts by HA.
	// Property is currently only applicable to VMs with NVDimms and
	// will fail to set True if vPMem disks are present.
	PmemFailoverEnabled *bool `xml:"pmemFailoverEnabled" json:"pmemFailoverEnabled,omitempty" vim:"7.0.2.0"`
	// Property to enable/disable VMXStats Collection.
	//
	// \- Setting this property is only allowed when the VM is powered off
	// and will fail otherwise.
	// \- When set to TRUE, VMs will be configured to create a
	// scoreboard file to store certain stats for various VMX
	// components.
	VmxStatsCollectionEnabled *bool `xml:"vmxStatsCollectionEnabled" json:"vmxStatsCollectionEnabled,omitempty" vim:"7.0.3.1"`
	// Property to enable/disable operation notification to applications.
	//
	// \- When set to TRUE, application running inside the VM will be
	// notified of operations for which they have registered.
	// \- If unset defaults to FALSE, no notifications are sent to the
	// application.
	VmOpNotificationToAppEnabled *bool `xml:"vmOpNotificationToAppEnabled" json:"vmOpNotificationToAppEnabled,omitempty" vim:"7.0.3.0"`
	// Operation notification timeout in seconds.
	//
	// \- Specifies the maximum time duration the applications may take to
	// prepare for the operation after its been notified. This value is used
	// only if `VirtualMachineConfigSpec.vmOpNotificationToAppEnabled` is set to TRUE.
	// \- Timeout has to be a non-zero positive value for applications to
	// be able to register and get notifications.
	VmOpNotificationTimeout int64 `xml:"vmOpNotificationTimeout,omitempty" json:"vmOpNotificationTimeout,omitempty" vim:"8.0.0.1"`
	// Status of the device swap operation.
	DeviceSwap *VirtualMachineVirtualDeviceSwap `xml:"deviceSwap,omitempty" json:"deviceSwap,omitempty" vim:"8.0.0.1"`
	// Number of SMT (Simultaneous multithreading) threads.
	//
	// \- Set "simultaneousThreads" with a non-zero value to configure threads.
	// \- If unset, then use system defaults.
	SimultaneousThreads int32 `xml:"simultaneousThreads,omitempty" json:"simultaneousThreads,omitempty" vim:"8.0.0.1"`
	// Configuration for virtual persistent memory.
	Pmem *VirtualMachineVirtualPMem `xml:"pmem,omitempty" json:"pmem,omitempty" vim:"7.0.3.0"`
	// Assignable hardware device groups.
	DeviceGroups *VirtualMachineVirtualDeviceGroups `xml:"deviceGroups,omitempty" json:"deviceGroups,omitempty" vim:"8.0.0.1"`
	// Indicates whether support to add and remove fixed passthrough
	// devices when the VM is running should be enabled.
	//
	// This property can only be set when the VM is powered off. If set,
	// additional setup will be performed when the VM is powered on
	// so that hot adding and removing fixed passthrough devices will
	// be possible.
	// NOTE: When setting this to true, the memory reservation should
	// be equal to the guest memory size or the option to reserve all
	// guest memory should be selected. If unset, the current value
	// is left unchanged.
	FixedPassthruHotPlugEnabled *bool `xml:"fixedPassthruHotPlugEnabled" json:"fixedPassthruHotPlugEnabled,omitempty" vim:"8.0.1.0"`
	// Indicates whether FT Metro Cluster is enabled/disabled.
	//
	// \- If TRUE, FT Metro Cluster is enabled for the VM. An implicit
	// Anti-HostGroup will be generated from HostGroup defined for FT
	// primary, then affine the primary with one HostGroup and affine the
	// secondary with another HostGroup.
	// \- If FALSE or unset, FT Metro Cluster is disabled for the VM. Both FT
	// primary and secondary will be put in the same HostGroup.
	MetroFtEnabled *bool `xml:"metroFtEnabled" json:"metroFtEnabled,omitempty" vim:"8.0.3.0"`
	// Indicate the Host Group (`ClusterHostGroup`) for FT
	// Metro Cluster enabled Virtual Machine.
	//
	// Based on the selected Host Group, FT can divide the hosts in the cluster
	// into two groups and ensure to place FT primary and FT secondary in
	// different groups.
	MetroFtHostGroup string `xml:"metroFtHostGroup,omitempty" json:"metroFtHostGroup,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["VirtualMachineConfigSpec"] = reflect.TypeOf((*VirtualMachineConfigSpec)(nil)).Elem()
}

// A subset of virtual machine configuration.
type VirtualMachineConfigSummary struct {
	DynamicData

	// Name of the virtual machine.
	Name string `xml:"name" json:"name"`
	// Flag to determine whether or not this virtual machine is a template.
	Template bool `xml:"template" json:"template"`
	// Path name to the configuration file for the virtual machine
	VmPathName string `xml:"vmPathName" json:"vmPathName"`
	// Memory size of the virtual machine, in megabytes.
	MemorySizeMB int32 `xml:"memorySizeMB,omitempty" json:"memorySizeMB,omitempty"`
	// Configured CPU reservation in MHz
	CpuReservation int32 `xml:"cpuReservation,omitempty" json:"cpuReservation,omitempty"`
	// Configured Memory reservation in MB
	MemoryReservation int32 `xml:"memoryReservation,omitempty" json:"memoryReservation,omitempty"`
	// Number of processors in the virtual machine.
	NumCpu int32 `xml:"numCpu,omitempty" json:"numCpu,omitempty"`
	// Number of virtual network adapters.
	NumEthernetCards int32 `xml:"numEthernetCards,omitempty" json:"numEthernetCards,omitempty"`
	// Number of virtual disks attached to the virtual machine.
	NumVirtualDisks int32 `xml:"numVirtualDisks,omitempty" json:"numVirtualDisks,omitempty"`
	// Virtual machine BIOS identification.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// VC-specific identifier of the virtual machine
	InstanceUuid string `xml:"instanceUuid,omitempty" json:"instanceUuid,omitempty"`
	// Guest operating system identifier (short name).
	GuestId string `xml:"guestId,omitempty" json:"guestId,omitempty"`
	// Guest operating system name configured on the virtual machine.
	GuestFullName string `xml:"guestFullName,omitempty" json:"guestFullName,omitempty"`
	// Description for the virtual machine.
	Annotation string `xml:"annotation,omitempty" json:"annotation,omitempty"`
	// Product information.
	//
	// References to properties in the URLs are expanded.
	Product *VAppProductInfo `xml:"product,omitempty" json:"product,omitempty"`
	// Whether the VM requires a reboot to finish installation.
	//
	// False if no vApp
	// meta-data is configured.
	InstallBootRequired *bool `xml:"installBootRequired" json:"installBootRequired,omitempty"`
	// Fault Tolerance settings for this virtual machine.
	//
	// This property will be populated only for fault tolerance virtual
	// machines and will be left unset for all other virtual machines.
	// See `FaultToleranceConfigInfo` for a description.
	FtInfo BaseFaultToleranceConfigInfo `xml:"ftInfo,omitempty,typeattr" json:"ftInfo,omitempty"`
	// Specifies that this VM is managed by a VC Extension.
	//
	// See the
	// `managedBy` property in the ConfigSpec
	// for more details.
	ManagedBy *ManagedByInfo `xml:"managedBy,omitempty" json:"managedBy,omitempty"`
	// Is TPM present in a VM?
	TpmPresent *bool `xml:"tpmPresent" json:"tpmPresent,omitempty"`
	// Number of VMIOP backed devices attached to the virtual machine.
	NumVmiopBackings int32 `xml:"numVmiopBackings,omitempty" json:"numVmiopBackings,omitempty"`
	// The hardware version string for this virtual machine.
	HwVersion string `xml:"hwVersion,omitempty" json:"hwVersion,omitempty"`
}

func init() {
	t["VirtualMachineConfigSummary"] = reflect.TypeOf((*VirtualMachineConfigSummary)(nil)).Elem()
}

// The `VirtualMachineConnection` object describes a connection to the virtual
// machine.
type VirtualMachineConnection struct {
	DynamicData

	// The unique identifier associated with the connection.
	//
	// The label is a UTF-8 string which specifies a unique identifier for
	// a connection.
	Label string `xml:"label" json:"label"`
	// The client identifer.
	//
	// This identifier is a UTF-8 string which is semantically meaningful
	// for the connection. Examples of the client identifier are an IP
	// address (V4 or V6) with or without a port specification, a machine
	// name that requires a DNS lookup, or any other network oriented
	// identification scheme.
	Client string `xml:"client" json:"client"`
	// The name of the user authorizing the connection.
	//
	// This is used for auditing.
	UserName string `xml:"userName" json:"userName"`
}

func init() {
	t["VirtualMachineConnection"] = reflect.TypeOf((*VirtualMachineConnection)(nil)).Elem()
	minAPIVersionForType["VirtualMachineConnection"] = "7.0.1.0"
}

// Preferences for the legacy console application that affect the way it behaves during power
// operations on the virtual machine.
type VirtualMachineConsolePreferences struct {
	DynamicData

	// Power on the virtual machine when it is opened in the console.
	PowerOnWhenOpened *bool `xml:"powerOnWhenOpened" json:"powerOnWhenOpened,omitempty"`
	// Enter full screen mode when this virtual machine is powered on.
	EnterFullScreenOnPowerOn *bool `xml:"enterFullScreenOnPowerOn" json:"enterFullScreenOnPowerOn,omitempty"`
	// Close the console application when the virtual machine is powered off
	// or suspended.
	CloseOnPowerOffOrSuspend *bool `xml:"closeOnPowerOffOrSuspend" json:"closeOnPowerOffOrSuspend,omitempty"`
}

func init() {
	t["VirtualMachineConsolePreferences"] = reflect.TypeOf((*VirtualMachineConsolePreferences)(nil)).Elem()
}

// Describes the content library item information
// associated with the virtual machine.
type VirtualMachineContentLibraryItemInfo struct {
	DynamicData

	// The content library item UUID
	ContentLibraryItemUuid string `xml:"contentLibraryItemUuid" json:"contentLibraryItemUuid"`
	// The content library item version is determined and
	// managed by content library and this field stamps the version
	// provided by CL to the VM.
	ContentLibraryItemVersion string `xml:"contentLibraryItemVersion,omitempty" json:"contentLibraryItemVersion,omitempty"`
}

func init() {
	t["VirtualMachineContentLibraryItemInfo"] = reflect.TypeOf((*VirtualMachineContentLibraryItemInfo)(nil)).Elem()
}

// Wrapper class to support incremental updates of the cpuFeatureMask.
//
// As of vSphere API 6.5 `VirtualMachineConfigSpec.extraConfig` is the recommended method
// for setting the mask for a virtual machine with hardware version 9 and
// above (newer). They can be viewed via
// `featureMask`.
type VirtualMachineCpuIdInfoSpec struct {
	ArrayUpdateSpec

	Info *HostCpuIdInfo `xml:"info,omitempty" json:"info,omitempty"`
}

func init() {
	t["VirtualMachineCpuIdInfoSpec"] = reflect.TypeOf((*VirtualMachineCpuIdInfoSpec)(nil)).Elem()
}

// DatastoreInfo describes a datastore that a virtual disk can be
// stored on.
type VirtualMachineDatastoreInfo struct {
	VirtualMachineTargetInfo

	// Information about the datastore
	Datastore DatastoreSummary `xml:"datastore" json:"datastore"`
	// Information about the datastore capabilities
	Capability DatastoreCapability `xml:"capability" json:"capability"`
	// The maximum size of a file that can reside on this datastore.
	MaxFileSize int64 `xml:"maxFileSize" json:"maxFileSize"`
	// The maximum capacity of a virtual disk which can be created on this volume
	MaxVirtualDiskCapacity int64 `xml:"maxVirtualDiskCapacity,omitempty" json:"maxVirtualDiskCapacity,omitempty"`
	// Maximum raw device mapping size (physical compatibility)
	MaxPhysicalRDMFileSize int64 `xml:"maxPhysicalRDMFileSize,omitempty" json:"maxPhysicalRDMFileSize,omitempty"`
	// Maximum raw device mapping size (virtual compatibility)
	MaxVirtualRDMFileSize int64 `xml:"maxVirtualRDMFileSize,omitempty" json:"maxVirtualRDMFileSize,omitempty"`
	// Access mode for this datastore.
	//
	// This is either
	// readOnly or readWrite. A virtual disk needs to be
	// stored on readWrite datastore. ISOs can be read
	// from a readOnly datastore.
	//
	// See also `HostMountMode_enum`.
	Mode string `xml:"mode" json:"mode"`
	// Indicate the states of vStorage hardware acceleration
	// support for this datastore.
	//
	// In the case of a cluster compute resource, this property
	// is aggregated from the values reported by individual hosts
	// as follows:
	//   - If at least one host reports
	//     `vStorageSupported`,
	//     then it is set to
	//     `vStorageSupported`.
	//   - Else if at least one host reports
	//     `vStorageUnknown`,
	//     it is set to
	//     `vStorageUnknown`.
	//   - Else if at least one host reports
	//     `vStorageUnsupported`,
	//     it is set to
	//     `vStorageUnsupported`.
	//   - Else it is unset.
	//
	// See also `FileSystemMountInfoVStorageSupportStatus_enum`.
	VStorageSupport string `xml:"vStorageSupport,omitempty" json:"vStorageSupport,omitempty"`
}

func init() {
	t["VirtualMachineDatastoreInfo"] = reflect.TypeOf((*VirtualMachineDatastoreInfo)(nil)).Elem()
}

// This data object type describes a file system volume option for this
// virtual machine.
type VirtualMachineDatastoreVolumeOption struct {
	DynamicData

	// The type name of the file system volume information object for this
	// option.
	//
	// See also `HostFileSystemVolumeInfo`.
	FileSystemType string `xml:"fileSystemType" json:"fileSystemType"`
	// The major version of the file system volume information for this
	// option.
	//
	// If not specified, all versions of this file system are included
	// in this option. Currently, this value is set only for VMFS volumes.
	MajorVersion int32 `xml:"majorVersion,omitempty" json:"majorVersion,omitempty"`
}

func init() {
	t["VirtualMachineDatastoreVolumeOption"] = reflect.TypeOf((*VirtualMachineDatastoreVolumeOption)(nil)).Elem()
}

// The DefaultPowerOpInfo data object type holds the configured defaults for the power
// operations on a virtual machine.
//
// The properties indicated whether to do a "soft"
// or guest initiated operation, or a "hard" operation.
type VirtualMachineDefaultPowerOpInfo struct {
	DynamicData

	// Describes the default power off type for this virtual machine.
	//
	// The possible values are specified by the PowerOpType.
	//   - hard - Perform power off by using the PowerOff method.
	//   - soft - Perform power off by using the ShutdownGuest method.
	//   - preset - The preset value is specified in the defaultPowerOffType
	//     section.
	//
	// This setting is advisory and clients can choose to ignore it.
	PowerOffType string `xml:"powerOffType,omitempty" json:"powerOffType,omitempty"`
	// Describes the default suspend type for this virtual machine.
	//
	// The possible values are specified by the PowerOpType.
	//   - hard - Perform suspend by using the Suspend method.
	//   - soft - Perform suspend by using the StandbyGuest method.
	//   - preset - The preset value is specified in the defaultSuspendType
	//     section.
	//
	// This setting is advisory and clients can choose to ignore it.
	SuspendType string `xml:"suspendType,omitempty" json:"suspendType,omitempty"`
	// Describes the default reset type for this virtual machine.
	//
	// The possible values are specified by the PowerOpType.
	//   - hard - Perform reset by using the Reset method.
	//   - soft - Perform reset by using the RebootGuest method.
	//   - preset - The preset value is specified in the defaultResetType
	//     section.
	//
	// This setting is advisory and clients can choose to ignore it.
	ResetType string `xml:"resetType,omitempty" json:"resetType,omitempty"`
	// Default operation for power off: soft or hard
	DefaultPowerOffType string `xml:"defaultPowerOffType,omitempty" json:"defaultPowerOffType,omitempty"`
	// Default operation for suspend: soft or hard
	DefaultSuspendType string `xml:"defaultSuspendType,omitempty" json:"defaultSuspendType,omitempty"`
	// Default operation for reset: soft or hard
	DefaultResetType string `xml:"defaultResetType,omitempty" json:"defaultResetType,omitempty"`
	// Behavior of virtual machine when it receives the S1 ACPI call.
	StandbyAction string `xml:"standbyAction,omitempty" json:"standbyAction,omitempty"`
}

func init() {
	t["VirtualMachineDefaultPowerOpInfo"] = reflect.TypeOf((*VirtualMachineDefaultPowerOpInfo)(nil)).Elem()
}

// Used to indicate that the Default Storage Policy of the target datastore
// be used for a Virtual Machine Home or a Virtual Disk object.
//
// Neither the association nor the policy data is persisted in Virtual Machine
// configuration. This data is managed by an extension of Virtual Center
// (Storage Policy Based Management).
type VirtualMachineDefaultProfileSpec struct {
	VirtualMachineProfileSpec
}

func init() {
	t["VirtualMachineDefaultProfileSpec"] = reflect.TypeOf((*VirtualMachineDefaultProfileSpec)(nil)).Elem()
}

// Policy specification that carries a pre-defined Storage Policy to be associated
// with a Virtual Machine Home or a Virtual Disk object.
//
// Such a pre-defined
// policy can be either be vSphere Storage Administrator defined or may come
// from a set of pre-defined policies from Storage Vendor.
//
// Neither the association nor the policy data is persisted in Virtual Machine
// configuration. This data is managed by the an extension of Virtual Center
// (Storage Policy Based Management).
type VirtualMachineDefinedProfileSpec struct {
	VirtualMachineProfileSpec

	// Storage Policy Profile identification - Should be
	// pbm.profileId but for implementation reasons, could not be.
	ProfileId string `xml:"profileId" json:"profileId"`
	// Specification containing replication related parameters, sent to the Replication Data Service
	// provider.
	ReplicationSpec *ReplicationSpec `xml:"replicationSpec,omitempty" json:"replicationSpec,omitempty"`
	// Profile data sent to the Storage Backend by vSphere.
	//
	// This data is provided by the SPBM component of the vSphere platform.
	// This field should not be set by Virtual Center users.
	ProfileData *VirtualMachineProfileRawData `xml:"profileData,omitempty" json:"profileData,omitempty"`
	// Parameterized Storage Profiles
	// Extra configuration that is not expressed as a capability in the Profile
	// definition.
	ProfileParams []KeyValue `xml:"profileParams,omitempty" json:"profileParams,omitempty"`
}

func init() {
	t["VirtualMachineDefinedProfileSpec"] = reflect.TypeOf((*VirtualMachineDefinedProfileSpec)(nil)).Elem()
}

// The DeviceRuntimeInfo data object type provides information about
// the execution state of a single virtual device.
type VirtualMachineDeviceRuntimeInfo struct {
	DynamicData

	// The device runtime state.
	RuntimeState BaseVirtualMachineDeviceRuntimeInfoDeviceRuntimeState `xml:"runtimeState,typeattr" json:"runtimeState"`
	// The device key.
	Key int32 `xml:"key" json:"key"`
}

func init() {
	t["VirtualMachineDeviceRuntimeInfo"] = reflect.TypeOf((*VirtualMachineDeviceRuntimeInfo)(nil)).Elem()
}

// Runtime state of a device.
//
// Subclassed for information that is specific
// to certain device types.
type VirtualMachineDeviceRuntimeInfoDeviceRuntimeState struct {
	DynamicData
}

func init() {
	t["VirtualMachineDeviceRuntimeInfoDeviceRuntimeState"] = reflect.TypeOf((*VirtualMachineDeviceRuntimeInfoDeviceRuntimeState)(nil)).Elem()
}

// Runtime state of a virtual ethernet card device.
type VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState struct {
	VirtualMachineDeviceRuntimeInfoDeviceRuntimeState

	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer
	// supported and there is no replacement.
	//
	// Flag to indicate whether VMDirectPath Gen 2 is active on this device.
	//
	// If false, the reason(s) for inactivity will be provided in one or
	// more of `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.vmDirectPathGen2InactiveReasonVm`,
	// `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.vmDirectPathGen2InactiveReasonOther`,
	// and `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.vmDirectPathGen2InactiveReasonExtended`.
	VmDirectPathGen2Active *bool `xml:"vmDirectPathGen2Active" json:"vmDirectPathGen2Active,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer
	// supported and there is no replacement.
	//
	// If `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.vmDirectPathGen2Active` is false, this array will be
	// populated with reasons for the inactivity that are related to virtual
	// machine state or configuration (chosen from
	// `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_enum`).
	//
	// Other reasons for
	// inactivity will be provided in
	// `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.vmDirectPathGen2InactiveReasonOther`. If there is a reason
	// for inactivity that cannot be described by the available constants,
	// `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.vmDirectPathGen2InactiveReasonExtended` will be populated
	// with an additional explanation provided by the platform.
	//
	// Note that this list of reasons is not guaranteed to be exhaustive.
	VmDirectPathGen2InactiveReasonVm []string `xml:"vmDirectPathGen2InactiveReasonVm,omitempty" json:"vmDirectPathGen2InactiveReasonVm,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer
	// supported and there is no replacement.
	//
	// If `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.vmDirectPathGen2Active` is false, this array will be
	// populated with reasons for the inactivity that are not related to
	// virtual machine state or configuration (chosen from
	// `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther_enum`).
	//
	// Virtual machine
	// related reasons for inactivity will be provided in
	// `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.vmDirectPathGen2InactiveReasonVm`. If there is a reason
	// for inactivity that cannot be described by the available constants,
	// `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.vmDirectPathGen2InactiveReasonExtended` will be populated
	// with an additional explanation provided by the platform.
	//
	// Note that this list of reasons is not guaranteed to be exhaustive.
	//
	// See also `HostCapability.vmDirectPathGen2Supported`.
	VmDirectPathGen2InactiveReasonOther []string `xml:"vmDirectPathGen2InactiveReasonOther,omitempty" json:"vmDirectPathGen2InactiveReasonOther,omitempty"`
	// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer
	// supported and there is no replacement.
	//
	// If `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.vmDirectPathGen2Active` is false, this property may
	// contain an explanation provided by the platform, beyond the reasons
	// (if any) enumerated in `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.vmDirectPathGen2InactiveReasonVm`
	// and/or `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.vmDirectPathGen2InactiveReasonOther`.
	VmDirectPathGen2InactiveReasonExtended string `xml:"vmDirectPathGen2InactiveReasonExtended,omitempty" json:"vmDirectPathGen2InactiveReasonExtended,omitempty"`
	// Flag to indicate whether UPTv2(Uniform Pass-through version 2) is active
	// on this device.
	//
	// If true, the network adapter works in the pass-through mode.
	// If false, the network adapter still has the network connectivity but
	// works in emulated mode and pass-through is not enabled.
	// The reason for inactivity is provided in `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.uptv2InactiveReasonVm`
	// and/or `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.uptv2InactiveReasonOther`.
	// This flag is unset if not applicable. It indicates network adapter is not a
	// vmxnet3 adapter or `VirtualVmxnet3.uptv2Enabled` of it
	// is not set to true.
	Uptv2Active *bool `xml:"uptv2Active" json:"uptv2Active,omitempty" vim:"8.0.0.1"`
	// When `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.uptv2Active` is false, this field will be
	// populated with reasons for the inactivity that are related to virtual
	// machine state or configuration (chosen from
	// `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm_enum`).
	//
	// Other reasons for
	// inactivity will be provided in `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.uptv2InactiveReasonOther`.
	// This field will be unset if `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.uptv2Active` is true or unset.
	//
	// Note that this field of reasons is not guaranteed to be exhaustive.
	Uptv2InactiveReasonVm []string `xml:"uptv2InactiveReasonVm,omitempty" json:"uptv2InactiveReasonVm,omitempty" vim:"8.0.0.1"`
	// When `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.uptv2Active` is false, this field will be
	// populated with reasons for the inactivity that are not related to
	// virtual machine state or configuration (chosen from
	// `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther_enum`).
	//
	// Virtual machine
	// related reasons for inactivity will be provided in
	// `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.uptv2InactiveReasonVm`.
	// This field will be unset if `VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState.uptv2Active` is true or unset.
	//
	// Note that this field of reasons is not guaranteed to be exhaustive.
	Uptv2InactiveReasonOther []string `xml:"uptv2InactiveReasonOther,omitempty" json:"uptv2InactiveReasonOther,omitempty" vim:"8.0.0.1"`
	// The status indicating whether network reservation requirement is violated
	// or not on the virtual network adapter.
	//
	// See `ManagedEntityStatus_enum`
	// for possible values.
	//
	// `red` indicates that reservation specified on the virtual
	// network adapter is not being fulfilled. This can happen if the reservation requested is
	// greater than the available capacity reserved for virtual machine traffic on the host.
	//
	// `green` indicates that the reservation specified on the
	// virtual network adapter is being fulfilled.
	ReservationStatus string `xml:"reservationStatus,omitempty" json:"reservationStatus,omitempty"`
	// The status indicating the state of virtual network adapter's attachment
	// to an opaque network.
	//
	// See `ManagedEntityStatus_enum` for possible values.
	//
	// `red` indicates that the network adapter
	// is not yet successfully attached to opaque network. This can happen if
	// corresponding attachment port is missing in the kernel.
	//
	// `green` indicates that the network
	// adapater is successfully attached to opaque network.
	AttachmentStatus string `xml:"attachmentStatus,omitempty" json:"attachmentStatus,omitempty"`
	// These network adapter requirements must have equivalent capabilities
	// on the virtual switch in order to power on or migrate to the host.
	FeatureRequirement []VirtualMachineFeatureRequirement `xml:"featureRequirement,omitempty" json:"featureRequirement,omitempty"`
}

func init() {
	t["VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState"] = reflect.TypeOf((*VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState)(nil)).Elem()
}

// The DiskDeviceInfo class contains basic information about a specific disk hardware
// device.
type VirtualMachineDiskDeviceInfo struct {
	VirtualMachineTargetInfo

	// Size of disk
	Capacity int64 `xml:"capacity,omitempty" json:"capacity,omitempty"`
	// List of known virtual machines using this physical disk as a backing
	//
	// Refers instances of `VirtualMachine`.
	Vm []ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
}

func init() {
	t["VirtualMachineDiskDeviceInfo"] = reflect.TypeOf((*VirtualMachineDiskDeviceInfo)(nil)).Elem()
}

// This data object defines a two-dimensional, rectangular
// display area.
type VirtualMachineDisplayTopology struct {
	DynamicData

	// The x co-ordinate defining the start of the display rectangle.
	X int32 `xml:"x" json:"x"`
	// The y co-ordinate defining the start of the display rectangle.
	Y int32 `xml:"y" json:"y"`
	// The width of the display rectangle.
	Width int32 `xml:"width" json:"width"`
	// The height of the display rectangle.
	Height int32 `xml:"height" json:"height"`
}

func init() {
	t["VirtualMachineDisplayTopology"] = reflect.TypeOf((*VirtualMachineDisplayTopology)(nil)).Elem()
}

// Description of a Device Virtualization Extensions (DVX) device class.
type VirtualMachineDvxClassInfo struct {
	DynamicData

	// DVX device class.
	DeviceClass BaseElementDescription `xml:"deviceClass,typeattr" json:"deviceClass"`
	// The label for the vendor name of this class.
	//
	// The value is defined by vendors of the DVX device class
	// as part of their localizable messages.
	VendorName string `xml:"vendorName" json:"vendorName"`
	// Indicates whether the devices of this class are SR-IOV NICs.
	SriovNic bool `xml:"sriovNic" json:"sriovNic"`
	// The configuration parameters for this DVX device class.
	ConfigParams []OptionDef `xml:"configParams,omitempty" json:"configParams,omitempty"`
}

func init() {
	t["VirtualMachineDvxClassInfo"] = reflect.TypeOf((*VirtualMachineDvxClassInfo)(nil)).Elem()
	minAPIVersionForType["VirtualMachineDvxClassInfo"] = "8.0.0.1"
}

// Description of a Dynamic DirectPath PCI device.
type VirtualMachineDynamicPassthroughInfo struct {
	VirtualMachineTargetInfo

	// The vendor name of this PCI device.
	VendorName string `xml:"vendorName" json:"vendorName"`
	// The device name of this PCI device.
	DeviceName string `xml:"deviceName" json:"deviceName"`
	// The custom label attached to this PCI device.
	CustomLabel string `xml:"customLabel,omitempty" json:"customLabel,omitempty"`
	// PCI vendor ID for this device.
	VendorId int32 `xml:"vendorId" json:"vendorId"`
	// PCI device ID for this device.
	DeviceId int32 `xml:"deviceId" json:"deviceId"`
}

func init() {
	t["VirtualMachineDynamicPassthroughInfo"] = reflect.TypeOf((*VirtualMachineDynamicPassthroughInfo)(nil)).Elem()
}

// The EmptyIndependentFilterSpec data object is used to specify empty independent
// filter spec.
//
// This obejct is passed during provisioning workflows to remove all
// attached independent filters.
type VirtualMachineEmptyIndependentFilterSpec struct {
	VirtualMachineBaseIndependentFilterSpec
}

func init() {
	t["VirtualMachineEmptyIndependentFilterSpec"] = reflect.TypeOf((*VirtualMachineEmptyIndependentFilterSpec)(nil)).Elem()
	minAPIVersionForType["VirtualMachineEmptyIndependentFilterSpec"] = "7.0.2.1"
}

// Specifies an empty Storage Policy for a Virtual Machine Home or a
// Virtual Disk object.
//
// The object is left without any profile association, and hence has no
// explicit policy driven requirements.
// This implies that object's policy driven SLAs are always met trivially.
type VirtualMachineEmptyProfileSpec struct {
	VirtualMachineProfileSpec
}

func init() {
	t["VirtualMachineEmptyProfileSpec"] = reflect.TypeOf((*VirtualMachineEmptyProfileSpec)(nil)).Elem()
}

// Feature requirement contains a key, featureName and an opaque value
type VirtualMachineFeatureRequirement struct {
	DynamicData

	// Accessor name to the feature requirement test
	Key string `xml:"key" json:"key"`
	// Name of the feature.
	//
	// Identical to the key.
	FeatureName string `xml:"featureName" json:"featureName"`
	// Opaque value for the feature operation.
	//
	// Operation is contained
	// in the value.
	Value string `xml:"value" json:"value"`
}

func init() {
	t["VirtualMachineFeatureRequirement"] = reflect.TypeOf((*VirtualMachineFeatureRequirement)(nil)).Elem()
}

// The FileInfo data object type contains the locations of virtual machine
// files other than the virtual disk files.
//
// The configurable parameters
// are all in the FileInfo object.
//
// The object also contains a FileLayout object that returns a complete
// list of additional files that makes up the virtual machine
// configuration. This is a read-only structure and is returned when
// the configuration is read. This is ignored during configuration and
// can be left out.
type VirtualMachineFileInfo struct {
	DynamicData

	// Path name to the configuration file for the virtual machine, e.g., the
	// .vmx file.
	//
	// This also implicitly defines the configuration directory.
	VmPathName string `xml:"vmPathName,omitempty" json:"vmPathName,omitempty"`
	// Path name of the directory that holds suspend and snapshot files
	// belonging to the virtual machine.
	//
	// Prior to vSphere 5.0, this
	// directory also holds snapshot redo files. Starting with vSphere 5.0,
	// the redo files will stay in the same directory as the snapshotted
	// disk, thus this directory will no longer hold the snapshot redo
	// files.
	//
	// This path name defaults to the same directory as the configuration
	// file.
	//
	// ESX Server requires this to indicate a VMFS volume or NAS volume
	// (for ESX Server 3).
	// In case the configuration file is not stored on VMFS or NAS, this
	// property must be set explicitly.
	SnapshotDirectory string `xml:"snapshotDirectory,omitempty" json:"snapshotDirectory,omitempty"`
	// Some products allow the suspend directory to be different than the
	// snapshot directory.
	//
	// On products where this is not possible, setting
	// of this property is ignored.
	SuspendDirectory string `xml:"suspendDirectory,omitempty" json:"suspendDirectory,omitempty"`
	// Directory to store the log files for the virtual machine.
	//
	// If not specified,
	// this defaults to the same directory as the configuration file,
	LogDirectory string `xml:"logDirectory,omitempty" json:"logDirectory,omitempty"`
	// Directory to store the fault tolerance meta data files for the
	// virtual machine.
	FtMetadataDirectory string `xml:"ftMetadataDirectory,omitempty" json:"ftMetadataDirectory,omitempty"`
}

func init() {
	t["VirtualMachineFileInfo"] = reflect.TypeOf((*VirtualMachineFileInfo)(nil)).Elem()
}

// Deprecated as of vSphere API 4.0, use `VirtualMachineFileLayoutEx` instead.
//
// Describes the set of files that makes up a virtual machine on disk.
//
// The
// file layout is broken into 4 major sections:
//   - Configuration: Files stored in the configuration directory
//   - Log: Files stored in the log directory
//   - Disk: Files stored relative to a disk configuration file
//   - Snapshot: Stored in the snapshot directory
//
// Often the same directory is used for configuration, log, disk and
// snapshots.
type VirtualMachineFileLayout struct {
	DynamicData

	// A list of files that makes up the configuration of the virtual machine
	// (excluding the .vmx file, since that file is represented in the
	// FileInfo).
	//
	// These are relative paths from the configuration directory. A
	// slash is always used as a separator. This list will typically include the
	// NVRAM file, but could also include other meta-data files.
	ConfigFile []string `xml:"configFile,omitempty" json:"configFile,omitempty"`
	// A list of files stored in the virtual machine's log directory.
	//
	// These are
	// relative paths from the logDirectory. A slash is always used as a
	// separator.
	LogFile []string `xml:"logFile,omitempty" json:"logFile,omitempty"`
	// Files making up each virtual disk.
	Disk []VirtualMachineFileLayoutDiskLayout `xml:"disk,omitempty" json:"disk,omitempty"`
	// Files of each snapshot.
	Snapshot []VirtualMachineFileLayoutSnapshotLayout `xml:"snapshot,omitempty" json:"snapshot,omitempty"`
	// The swapfile specific to this virtual machine, if any.
	//
	// This is a
	// complete datastore path, not a relative path.
	SwapFile string `xml:"swapFile,omitempty" json:"swapFile,omitempty"`
}

func init() {
	t["VirtualMachineFileLayout"] = reflect.TypeOf((*VirtualMachineFileLayout)(nil)).Elem()
}

// Enumerats the set of files for each virtual disk.
type VirtualMachineFileLayoutDiskLayout struct {
	DynamicData

	// Identification of the disk in `config`.
	Key int32 `xml:"key" json:"key"`
	// List of files that makes up the virtual disk.
	//
	// At least one entry
	// always exists in this array. The first entry is the main
	// descriptor of the virtual disk (the one used when adding the
	// disk to a virtual machine). These are complete datastore paths, not
	// relative paths.
	DiskFile []string `xml:"diskFile" json:"diskFile"`
}

func init() {
	t["VirtualMachineFileLayoutDiskLayout"] = reflect.TypeOf((*VirtualMachineFileLayoutDiskLayout)(nil)).Elem()
}

// Detailed description of files that make up a virtual machine on disk.
//
// The
// file layout is broken into 4 major sections:
//   - Configuration: Files stored in the configuration directory
//   - Log: Files stored in the log directory
//   - Disk: Files stored relative to a disk configuration file
//   - Snapshot: Stored in the snapshot directory
//
// Often the same directory is used for configuration, log, disk and
// snapshots.
type VirtualMachineFileLayoutEx struct {
	DynamicData

	// Information about all the files that constitute the virtual machine
	// including configuration files, disks, swap file, suspend file, log files,
	// core files, memory file etc.
	//
	// `VirtualMachineFileLayoutExFileType_enum` lists the
	// different file-types that make a virtual machine.
	File []VirtualMachineFileLayoutExFileInfo `xml:"file,omitempty" json:"file,omitempty"`
	// Layout of each virtual disk attached to the virtual machine.
	//
	// For a virtual machine with snaphots, this property gives only those disks
	// that are attached to it at the current point of running.
	Disk []VirtualMachineFileLayoutExDiskLayout `xml:"disk,omitempty" json:"disk,omitempty"`
	// Layout of each snapshot of the virtual machine.
	Snapshot []VirtualMachineFileLayoutExSnapshotLayout `xml:"snapshot,omitempty" json:"snapshot,omitempty"`
	// Time when values in this structure were last updated.
	Timestamp time.Time `xml:"timestamp" json:"timestamp"`
}

func init() {
	t["VirtualMachineFileLayoutEx"] = reflect.TypeOf((*VirtualMachineFileLayoutEx)(nil)).Elem()
}

// Layout of a virtual disk, including the base- and delta- disks.
//
// A virtual disk typically is made up of a chain of disk-units.
type VirtualMachineFileLayoutExDiskLayout struct {
	DynamicData

	// Identifier for the virtual disk in `VirtualHardware.device`.
	Key int32 `xml:"key" json:"key"`
	// The disk-unit chain that makes up this virtual disk.
	Chain []VirtualMachineFileLayoutExDiskUnit `xml:"chain,omitempty" json:"chain,omitempty"`
}

func init() {
	t["VirtualMachineFileLayoutExDiskLayout"] = reflect.TypeOf((*VirtualMachineFileLayoutExDiskLayout)(nil)).Elem()
}

// Information about a single unit of a virtual disk, such as
// the base-disk or a delta-disk.
//
// A disk-unit consists of at least one descriptor
// file, and zero or more extent files.
//
// Sometimes, a disk-unit is also referred to as a _backing_.
type VirtualMachineFileLayoutExDiskUnit struct {
	DynamicData

	// Array of keys of the files that make up the disk unit.
	//
	// Values here
	// correspond to property `VirtualMachineFileLayoutExFileInfo.key` in
	// `VirtualMachineFileLayoutEx.file`.
	//
	// At least one entry always exists in this array. Property
	// `VirtualMachineFileLayoutExFileInfo.type` of the referenced file
	// can be used to distinguish the disk descriptor (type `diskDescriptor`) from the extents.
	FileKey []int32 `xml:"fileKey" json:"fileKey"`
}

func init() {
	t["VirtualMachineFileLayoutExDiskUnit"] = reflect.TypeOf((*VirtualMachineFileLayoutExDiskUnit)(nil)).Elem()
}

// Basic information about a file.
type VirtualMachineFileLayoutExFileInfo struct {
	DynamicData

	// Key to reference this file.
	Key int32 `xml:"key" json:"key"`
	// Name of the file, including the complete datastore path.
	Name string `xml:"name" json:"name"`
	// Type of the file.
	//
	// `VirtualMachineFileLayoutExFileType_enum` lists
	// all valid values.
	Type string `xml:"type" json:"type"`
	// Size of the file in bytes.
	Size int64 `xml:"size" json:"size"`
	// Size of the file in bytes corresponding to the file blocks
	// that were allocated uniquely.
	//
	// In other words, if the underlying
	// storage supports sharing of file blocks across disk files, the
	// property corresponds to the size of the file blocks that were
	// allocated only in context of this file, i.e. it does not include
	// shared blocks that were allocated in other files.
	// This property will be unset if the underlying implementation
	// is unable to compute this information. One example of this
	// is when the file resides on a NAS datastore whose underlying
	// storage doesn't support this metric. In some cases the field
	// might be set but the value could be over-estimated due to
	// the inability of the NAS based storage to provide an
	// accurate value.
	UniqueSize int64 `xml:"uniqueSize,omitempty" json:"uniqueSize,omitempty"`
	// Backing object's durable and unmutable identifier.
	//
	// Each backing object has a unique identifier which is not settable.
	// This property is applied to the file backed by a storage object,
	// such as vvol.
	BackingObjectId string `xml:"backingObjectId,omitempty" json:"backingObjectId,omitempty"`
	// Flag which indicates the accessibility of the file
	// when the file info object was created.
	Accessible *bool `xml:"accessible" json:"accessible,omitempty"`
}

func init() {
	t["VirtualMachineFileLayoutExFileInfo"] = reflect.TypeOf((*VirtualMachineFileLayoutExFileInfo)(nil)).Elem()
}

// Layout of a snapshot.
type VirtualMachineFileLayoutExSnapshotLayout struct {
	DynamicData

	// Reference to the snapshot.
	//
	// Refers instance of `VirtualMachineSnapshot`.
	Key ManagedObjectReference `xml:"key" json:"key"`
	// Key to the snapshot data file in `VirtualMachineFileLayoutEx.file`.
	DataKey int32 `xml:"dataKey" json:"dataKey"`
	// Key to the snapshot memory file in `VirtualMachineFileLayoutEx.file`.
	//
	// Powered off snapshots do not have a memory component and in some cases
	// the memory component is combined with the data component. When a memory
	// component does not exist, the value is initialized to -1.
	MemoryKey int32 `xml:"memoryKey,omitempty" json:"memoryKey,omitempty"`
	// Layout of each virtual disk of the virtual machine when the
	// snapshot was taken.
	Disk []VirtualMachineFileLayoutExDiskLayout `xml:"disk,omitempty" json:"disk,omitempty"`
}

func init() {
	t["VirtualMachineFileLayoutExSnapshotLayout"] = reflect.TypeOf((*VirtualMachineFileLayoutExSnapshotLayout)(nil)).Elem()
}

// Enumerates the set of files that make up a snapshot or redo-point
type VirtualMachineFileLayoutSnapshotLayout struct {
	DynamicData

	// Identification of the snapshot
	//
	// Refers instance of `VirtualMachineSnapshot`.
	Key ManagedObjectReference `xml:"key" json:"key"`
	// A list of files that make up the snapshot state.
	//
	// These are relative
	// paths from the snapshotDirectory. A slash is always used as a
	// separator.
	SnapshotFile []string `xml:"snapshotFile" json:"snapshotFile"`
}

func init() {
	t["VirtualMachineFileLayoutSnapshotLayout"] = reflect.TypeOf((*VirtualMachineFileLayoutSnapshotLayout)(nil)).Elem()
}

// The FlagInfo data object type encapsulates the flag settings
// for a virtual machine.
//
// These properties are optional since the same structure
// is used to change the values during an edit or create operation.
type VirtualMachineFlagInfo struct {
	DynamicData

	// Flag to turn off video acceleration for a virtual machine console window.
	DisableAcceleration *bool `xml:"disableAcceleration" json:"disableAcceleration,omitempty"`
	// Flag to enable logging for a virtual machine.
	EnableLogging *bool `xml:"enableLogging" json:"enableLogging,omitempty"`
	// Flag to specify whether or not to use TOE (TCP/IP Offloading).
	UseToe *bool `xml:"useToe" json:"useToe,omitempty"`
	// Deprecated as of VI API 2.5, use `VirtualMachineFlagInfo.monitorType`.
	//
	// Flag to specify whether or not to run in debug mode.
	RunWithDebugInfo *bool `xml:"runWithDebugInfo" json:"runWithDebugInfo,omitempty"`
	// vmx process type.
	//
	// See `VirtualMachineFlagInfoMonitorType_enum`
	// for possible values for this property.
	MonitorType string `xml:"monitorType,omitempty" json:"monitorType,omitempty"`
	// Deprecated as of vSphere API 6.7.
	//
	// Specifies how the VCPUs of a virtual machine are allowed to
	// share physical cores on a hyperthreaded system.
	//
	// Two VCPUs are
	// "sharing" a core if they are both running on logical CPUs of
	// the core at the same time.
	//
	// See also `VirtualMachineHtSharing_enum`.
	HtSharing string `xml:"htSharing,omitempty" json:"htSharing,omitempty"`
	// Deprecated as of vSphere API 4.0. The flag is ignored by the server.
	//
	// Flag to specify whether snapshots are disabled for this virtual
	// machine.
	SnapshotDisabled *bool `xml:"snapshotDisabled" json:"snapshotDisabled,omitempty"`
	// Flag to specify whether the snapshot tree is locked for this virtual machine.
	SnapshotLocked *bool `xml:"snapshotLocked" json:"snapshotLocked,omitempty"`
	// Indicates whether disk UUIDs are being used by this virtual machine.
	//
	// If this flag is set to false, disk UUIDs are not exposed to the guest.
	//
	// Since products before ESX 3.1 do not support disk UUIDs, moving virtual
	// machines from a platform that supports UUID to a platform that does
	// not support UUIDs could result in unspecified guest behavior. For
	// virtual machines where the ability to move to older platforms is
	// important, this flag should be set to false. If the value is unset,
	// the behavior 'false' will be used.
	DiskUuidEnabled *bool `xml:"diskUuidEnabled" json:"diskUuidEnabled,omitempty"`
	// Indicates whether or not the system will try to use nested page
	// table hardware support, if available.
	//
	// By default, VMware software will determine whether or not
	// to use nested page table hardware support based on various factors such
	// as the guest operating system type and the physical hardware.
	// Certain workloads can benefit from explicitly turning
	// nested page table hardware support on or off; this can be set using
	// nptUsage flag.
	// If the value is unset, the value will default to automatic.
	//
	// `VirtualMachineFlagInfoVirtualMmuUsage_enum` represents the set of
	// possible values.
	VirtualMmuUsage string `xml:"virtualMmuUsage,omitempty" json:"virtualMmuUsage,omitempty"`
	// Indicates whether or not the system will try to use Hardware
	// Virtualization (HV) support for instruction virtualization,
	// if available.
	//
	// By default, VMware software will determine whether or not
	// to use hardware virtualization support based on various factors such
	// as the guest operating system type and the physical hardware.
	// Certain workloads can benefit from explicitly turning
	// hardware virtualization support on or off.
	// If the value is unset, the value will default to hvAuto.
	//
	// `VirtualMachineFlagInfoVirtualExecUsage_enum` represents the set of
	// possible values.
	//
	// New processors can enable two hardware acceleration technologies
	// for virtualization, one for instruction virtualization and the
	// other for MMU virtualization. Intel names its hardware-assisted
	// instruction virtualization as VT, and its hardware-assisted
	// MMU virtualization as EPT. AMD calls them as AMD-V and RVI,
	// respectively. For details on these technologies, please refer
	// to documents from the processor vendors.
	//
	// `VirtualMachineFlagInfo.virtualExecUsage` controls instruction
	// virtualization; while `VirtualMachineFlagInfo.virtualMmuUsage`
	// controls MMU virtualization. "On" allows hardware acceleration,
	// while "off" only allows software solution.
	//
	// There are four meaningful combinations.
	//
	// (hvAuto, automatic) - The host chooses which feature to use.
	// (hvOn, on) - Use both VT/AMD-V and EPT/RVI.
	// (hvOn, off) - Use VT/AMD-V but do not use EPT/RVI.
	// (hvOff, off) - Do not use any of these hardware acceleration technologies.
	VirtualExecUsage string `xml:"virtualExecUsage,omitempty" json:"virtualExecUsage,omitempty"`
	// Specifies the power-off behavior for a virtual machine that has
	// a snapshot.
	//
	// If the value is unset, the behavior 'powerOff' will
	// be used.
	//
	// See also `VirtualMachinePowerOffBehavior_enum`.
	SnapshotPowerOffBehavior string `xml:"snapshotPowerOffBehavior,omitempty" json:"snapshotPowerOffBehavior,omitempty"`
	// Deprecated as of vSphere API 6.0.
	//
	// Flag to specify whether record and replay operations are
	// allowed for this virtual machine.
	//
	// If this flag is set to 'true', instruction virtualization
	// will use hardware virtualization (HV) support. I.e.,
	// virtualExecUsage will be set to 'hvOn'.
	// If this flag is set to 'false' for a virtual machine that
	// already has a recording, replay will be disallowed, though
	// the recording will be preserved.
	// If the value is unset, the behavior 'false' will be used.
	RecordReplayEnabled *bool `xml:"recordReplayEnabled" json:"recordReplayEnabled,omitempty"`
	// Indicates the type of fault tolerance type the virtual machine is
	// configured to use.
	//
	// `VirtualMachineFaultToleranceType_enum` represents the set of
	// possible values.
	FaultToleranceType string `xml:"faultToleranceType,omitempty" json:"faultToleranceType,omitempty"`
	// Flag to specify whether common CBRC digest cache is enabled for this
	// virtual machine.
	//
	// The common CBRC cache is shared between the hot added disks in the VM.
	// If this flag is set to 'true' the VM will allocate a commont digest
	// cache on power on.
	CbrcCacheEnabled *bool `xml:"cbrcCacheEnabled" json:"cbrcCacheEnabled,omitempty"`
	// Flag to specify if Intel Virtualization Technology for Directed I/O
	// is enabled for this virtual machine.
	//
	// When creating a new VM:
	// \- If vim.vm.FlagInfo.vbsEnabled is set to <code>true</code>,
	// and this flag is set to <code>false</code> error is returned.
	// \- If this flag is unset and vim.vm.FlagInfo.vbsEnabled is set to
	// <code>true</code>, the value of this flag is set to <code>true</code>.
	VvtdEnabled *bool `xml:"vvtdEnabled" json:"vvtdEnabled,omitempty"`
	// Flag to specify if Virtualization-based security
	// is enabled for this virtual machine.
	//
	// If set to <code>true</code> when creating a new VM, the following VM
	// properties might be modified automatically:
	// \- If vim.vm.FlagInfo.vvtdEnabled is not set to <code>false</code>,
	// it is set to <code>true</code>. Else error is returned.
	// \- If vim.vm.ConfigSpec.nestedHVEnabled is not set to <code>false</code>,
	// it is set to <code>true</code>. Else error is returned.
	// \- If vim.vm.BootOptions.efiSecureBootEnabled is not set to
	// <code>false</code>, it is set to <code>true</code>. Else error is
	// returned.
	// \- If vim.vm.firmware is not set to <code>bios</code>, it is set
	// to <code>efi</code>. Else error is returned.
	VbsEnabled *bool `xml:"vbsEnabled" json:"vbsEnabled,omitempty"`
}

func init() {
	t["VirtualMachineFlagInfo"] = reflect.TypeOf((*VirtualMachineFlagInfo)(nil)).Elem()
}

// FloppyInfo class contains information about a physical floppy
// drive on the host.
type VirtualMachineFloppyInfo struct {
	VirtualMachineTargetInfo
}

func init() {
	t["VirtualMachineFloppyInfo"] = reflect.TypeOf((*VirtualMachineFloppyInfo)(nil)).Elem()
}

// This data object describes the fork configuration of this
// virtual machine.
type VirtualMachineForkConfigInfo struct {
	DynamicData

	// Flag to indicate whether this virtual machine is a parent enabled
	// virtual machine.
	//
	// If this vm is not a parent enabled vm this
	// property will be unset.
	// When set into the vim.vm.ConfigSpec this flag will be ignored.
	ParentEnabled *bool `xml:"parentEnabled" json:"parentEnabled,omitempty"`
	// The fork group ID identifies the parent group of which this child
	// VirtualMachine is a child.
	//
	// Applicable for child VirtualMachines only.
	ChildForkGroupId string `xml:"childForkGroupId,omitempty" json:"childForkGroupId,omitempty"`
	// The fork group ID identifies the parent group which this VirtualMachine
	// belongs to.
	//
	// Applicable for parent VirtualMachines only.
	ParentForkGroupId string `xml:"parentForkGroupId,omitempty" json:"parentForkGroupId,omitempty"`
	// The flag to indicate the fork child type.
	//
	// For a persistent child
	// virtual machine, once it is powered on, it will become a linked
	// clone of its parent and this flag will be set to 'none'.
	//
	// See also `VirtualMachineForkConfigInfoChildType_enum`.
	ChildType string `xml:"childType,omitempty" json:"childType,omitempty"`
}

func init() {
	t["VirtualMachineForkConfigInfo"] = reflect.TypeOf((*VirtualMachineForkConfigInfo)(nil)).Elem()
}

// This data object describes the guest integrity platform configuration of
// this virtual machine.
type VirtualMachineGuestIntegrityInfo struct {
	DynamicData

	// Flag to indicate whether guest integrity platform feature is enabled for
	// this virtual machine.
	//
	// Guest integrity adds capabilities in the virtual
	// platform to detect attacks on the guest OS kernel
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
}

func init() {
	t["VirtualMachineGuestIntegrityInfo"] = reflect.TypeOf((*VirtualMachineGuestIntegrityInfo)(nil)).Elem()
}

// This data object describes the GMM (Guest Mode Monitoring) configuration
// of this virtual machine.
type VirtualMachineGuestMonitoringModeInfo struct {
	DynamicData

	GmmFile      string `xml:"gmmFile,omitempty" json:"gmmFile,omitempty"`
	GmmAppliance string `xml:"gmmAppliance,omitempty" json:"gmmAppliance,omitempty"`
}

func init() {
	t["VirtualMachineGuestMonitoringModeInfo"] = reflect.TypeOf((*VirtualMachineGuestMonitoringModeInfo)(nil)).Elem()
}

// This data object type encapsulates configuration settings
// when creating a virtual machine quiesced snapshot.
type VirtualMachineGuestQuiesceSpec struct {
	DynamicData

	// The property to indicate maximum time in minutes for snapshot operation
	// to be performed on the virtual machine.
	//
	// The timeout can not be less than 5 minutes or more than 240 minutes.
	Timeout int32 `xml:"timeout,omitempty" json:"timeout,omitempty"`
}

func init() {
	t["VirtualMachineGuestQuiesceSpec"] = reflect.TypeOf((*VirtualMachineGuestQuiesceSpec)(nil)).Elem()
}

// A subset of virtual machine guest information.
type VirtualMachineGuestSummary struct {
	DynamicData

	// Guest operating system identifier (short name), if known.
	GuestId string `xml:"guestId,omitempty" json:"guestId,omitempty"`
	// Guest operating system name configured on the virtual machine.
	GuestFullName string `xml:"guestFullName,omitempty" json:"guestFullName,omitempty"`
	// Deprecated as of vSphere API 5.0 use `VirtualMachineGuestSummary.toolsVersionStatus2` and
	// `VirtualMachineGuestSummary.toolsRunningStatus`.
	//
	// Current status of VMware Tools in the guest operating system, if known.
	ToolsStatus VirtualMachineToolsStatus `xml:"toolsStatus,omitempty" json:"toolsStatus,omitempty"`
	// Deprecated as of vSphere API 5.0 use `VirtualMachineGuestSummary.toolsVersionStatus2`.
	//
	// Current version status of VMware Tools in the guest operating system,
	// if known.
	ToolsVersionStatus string `xml:"toolsVersionStatus,omitempty" json:"toolsVersionStatus,omitempty"`
	// Current version status of VMware Tools in the guest operating system,
	// if known.
	ToolsVersionStatus2 string `xml:"toolsVersionStatus2,omitempty" json:"toolsVersionStatus2,omitempty"`
	// Current running status of VMware Tools in the guest operating system,
	// if known.
	ToolsRunningStatus string `xml:"toolsRunningStatus,omitempty" json:"toolsRunningStatus,omitempty"`
	// Hostname of the guest operating system, if known.
	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
	// Primary IP address assigned to the guest operating system, if known.
	IpAddress string `xml:"ipAddress,omitempty" json:"ipAddress,omitempty"`
	// The hardware version string for this virtual machine.
	HwVersion string `xml:"hwVersion,omitempty" json:"hwVersion,omitempty"`
}

func init() {
	t["VirtualMachineGuestSummary"] = reflect.TypeOf((*VirtualMachineGuestSummary)(nil)).Elem()
}

// The IdeDiskDeviceInfo class contains detailed information about a specific
// IDE disk hardware device.
//
// These devices are for the
// vim.vm.device.VirtualDisk.RawDiskVer2BackingInfo and
// vim.vm.device.VirtualDisk.PartitionedRawDiskVer2BackingInfo backings.
type VirtualMachineIdeDiskDeviceInfo struct {
	VirtualMachineDiskDeviceInfo

	PartitionTable []VirtualMachineIdeDiskDevicePartitionInfo `xml:"partitionTable,omitempty" json:"partitionTable,omitempty"`
}

func init() {
	t["VirtualMachineIdeDiskDeviceInfo"] = reflect.TypeOf((*VirtualMachineIdeDiskDeviceInfo)(nil)).Elem()
}

// Describes the partition sizes
type VirtualMachineIdeDiskDevicePartitionInfo struct {
	DynamicData

	// Identification of the partition
	Id int32 `xml:"id" json:"id"`
	// Size of partition
	Capacity int32 `xml:"capacity" json:"capacity"`
}

func init() {
	t["VirtualMachineIdeDiskDevicePartitionInfo"] = reflect.TypeOf((*VirtualMachineIdeDiskDevicePartitionInfo)(nil)).Elem()
}

// A VmImportSpec is used by `ResourcePool.importVApp` when importing entities.
//
// It provides all information needed to import a `VirtualMachine`. So far,
// this coincides with `VirtualMachineConfigSpec`.
//
// A VmImportSpec can be contained in a `VirtualAppImportSpec` as part of
// the ImportSpec for an entity.
//
// See also `ImportSpec`.
type VirtualMachineImportSpec struct {
	ImportSpec

	// Configuration for the virtual machine.
	ConfigSpec VirtualMachineConfigSpec `xml:"configSpec" json:"configSpec"`
	// Deprecated as of vSphere API 5.1.
	//
	// If specified, this resource pool will be used as the parent resource pool and the
	// virtual machine will be made a linked child to the parent vApp.
	//
	// This field is ignored
	// for the root node in an ImportSpec tree.
	//
	// Refers instance of `ResourcePool`.
	ResPoolEntity *ManagedObjectReference `xml:"resPoolEntity,omitempty" json:"resPoolEntity,omitempty"`
}

func init() {
	t["VirtualMachineImportSpec"] = reflect.TypeOf((*VirtualMachineImportSpec)(nil)).Elem()
}

// The IndependentFilterSpec data object is used to specify the independent
// filters to be associated with virtual machine disks.
type VirtualMachineIndependentFilterSpec struct {
	VirtualMachineBaseIndependentFilterSpec

	// Name/id of the IO filter.
	FilterName string `xml:"filterName" json:"filterName"`
	// IO filter class.
	FilterClass string `xml:"filterClass,omitempty" json:"filterClass,omitempty"`
	// Capabilities defined by the above filter.
	//
	// Basically this key value pair define the configurable properties
	// of the independent filters. Users can specify desired values.
	FilterCapabilities []KeyValue `xml:"filterCapabilities,omitempty" json:"filterCapabilities,omitempty"`
}

func init() {
	t["VirtualMachineIndependentFilterSpec"] = reflect.TypeOf((*VirtualMachineIndependentFilterSpec)(nil)).Elem()
	minAPIVersionForType["VirtualMachineIndependentFilterSpec"] = "7.0.2.1"
}

// Specification for creating an Instant Clone of a powered-on virtual machine.
type VirtualMachineInstantCloneSpec struct {
	DynamicData

	// The name of the cloned virtual machine.
	Name string `xml:"name" json:"name"`
	// A type of `VirtualMachineRelocateSpec` that specifies the location of
	// resources the newly created virtual machine will use.
	//
	// The location might be empty or specify:
	//   - The folder where the virtual machine should be located. If not
	//     specified, the root VM folder of the source VM will be used.
	//   - A datastore where the InstantCloned virtual machine will be located
	//     on the physical storage.
	//   - A resource pool determines where compute resources will be
	//     available to the clone.
	//   - A device change specification. The only allowed device changes
	//     are edits of VirtualEthernetCard and filebacked Serial/Parallel
	//     ports.
	//
	// All other settings are NOT supported.
	Location VirtualMachineRelocateSpec `xml:"location" json:"location"`
	// A list of key value pairs that will be passed to the destination VM.
	//
	// These pairs should be used to provide user-defined customization to
	// differentiate the destination VM from the source VM. Values will be
	// queryable via destination VM's `VirtualMachineConfigInfo.extraConfig`.
	Config []BaseOptionValue `xml:"config,omitempty,typeattr" json:"config,omitempty"`
	// 128-bit SMBIOS UUID of a virtual machine represented as a hexadecimal string
	// in "12345678-abcd-1234-cdef-123456789abc" format.
	BiosUuid string `xml:"biosUuid,omitempty" json:"biosUuid,omitempty"`
}

func init() {
	t["VirtualMachineInstantCloneSpec"] = reflect.TypeOf((*VirtualMachineInstantCloneSpec)(nil)).Elem()
}

// The LegacyNetworkSwitchInfo data object type contains information about
// the legacy network switches available on the host.
//   - VMware Server - Options available for the "custom" NetworkBackingType.
//   - ESX Server - The "esxnet" NetworkBackingType.
type VirtualMachineLegacyNetworkSwitchInfo struct {
	DynamicData

	// The name of the network switch.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["VirtualMachineLegacyNetworkSwitchInfo"] = reflect.TypeOf((*VirtualMachineLegacyNetworkSwitchInfo)(nil)).Elem()
}

// The VirtualMachineReservationInfo data object type describes the
// amount of memory that is being reserved for virtual machines on
// the host, and how additional memory may be acquired.
type VirtualMachineMemoryReservationInfo struct {
	DynamicData

	// The minimum amount of memory reserved for all running virtual machines,
	// in bytes.
	VirtualMachineMin int64 `xml:"virtualMachineMin" json:"virtualMachineMin"`
	// The maximum amount of memory reserved for all running virtual machines,
	// in bytes.
	VirtualMachineMax int64 `xml:"virtualMachineMax" json:"virtualMachineMax"`
	// The amount of memory reserved for all running virtual machines,
	// in bytes.
	VirtualMachineReserved int64 `xml:"virtualMachineReserved" json:"virtualMachineReserved"`
	// Policy for allocating additional memory for virtual machines.
	//
	// See also `VirtualMachineMemoryAllocationPolicy_enum`.
	AllocationPolicy string `xml:"allocationPolicy" json:"allocationPolicy"`
}

func init() {
	t["VirtualMachineMemoryReservationInfo"] = reflect.TypeOf((*VirtualMachineMemoryReservationInfo)(nil)).Elem()
}

// The VirtualMachineReservationSpec data object specifies
// configurable parameters for virtual machine memory reservation.
type VirtualMachineMemoryReservationSpec struct {
	DynamicData

	// The amount of memory reserved for all running virtual machines, in
	// bytes.
	VirtualMachineReserved int64 `xml:"virtualMachineReserved,omitempty" json:"virtualMachineReserved,omitempty"`
	// Policy for allocating additional memory for virtual machines.
	//
	// See also `VirtualMachineMemoryAllocationPolicy_enum`.
	AllocationPolicy string `xml:"allocationPolicy,omitempty" json:"allocationPolicy,omitempty"`
}

func init() {
	t["VirtualMachineMemoryReservationSpec"] = reflect.TypeOf((*VirtualMachineMemoryReservationSpec)(nil)).Elem()
}

// Message data which is intended to be displayed according
// to the locale of a client.
//
// A `VirtualMachineMessage` contains both a formatted, localized version of the
// text and the data needed to perform localization in conjunction
// with localization catalogs.
//
// Clients of the VIM API may use
// `SessionManager*.*SessionManager.SetLocale`
// to cause the server to emit localized `VirtualMachineMessage.text`, or may perform
// client-side localization based on message catalogs provided by the
// `LocalizationManager`.
//
// Message variables are always integers, e.g. {1} and {2}, which are
// 1-based indexes into `VirtualMachineMessage.argument`.
//   - The corresponding argument may be a recursive lookup:
//   - `VirtualMachineMessage.argument` = \["button.cancel", "msg.revert"\]
//   - CATALOG(locmsg, `VirtualMachineMessage.id`) = "Select '{1}' to {2}"
//   - CATALOG(locmsg, button.cancel) = "Cancel"
//   - CATALOG(locmsg, msg.revert) = "revert"
//   - \==&gt; `VirtualMachineMessage.text` = "Select 'Cancel' to revert"
//   - If the recursive lookup fails, the argument is a plain string.
//   - `VirtualMachineMessage.argument` = \["127.0.0.1"\]
//   - CATALOG(locmsg, `VirtualMachineMessage.id`) = "IP address is {1}"
//   - \==&gt; `VirtualMachineMessage.text` "IP address is 127.0.0.1"
//
// See also `LocalizationManager`.
type VirtualMachineMessage struct {
	DynamicData

	// A unique identifier for this particular message.
	//
	// This field is a key for looking up format strings in the locmsg
	// catalog.
	Id string `xml:"id" json:"id"`
	// Substitution arguments for variables in the localized message.
	//
	// Substitution variables in the format string identified by `VirtualMachineMessage.id`
	// are 1-based indexes into this array. Substitution variable {1}
	// corresponds to argument\[0\], etc.
	Argument []AnyType `xml:"argument,omitempty,typeattr" json:"argument,omitempty"`
	// Text in session locale.
	//
	// Use `SessionManager*.*SessionManager.SetLocale` to
	// change the session locale.
	Text string `xml:"text,omitempty" json:"text,omitempty"`
}

func init() {
	t["VirtualMachineMessage"] = reflect.TypeOf((*VirtualMachineMessage)(nil)).Elem()
}

// VmMetadata is a pair of VM ID and opaque metadata.
type VirtualMachineMetadataManagerVmMetadata struct {
	DynamicData

	// Datastore URL-based ID for VM, for example,
	// "\[datastore1\] SomeVM/SomeVM.vmx".
	VmId string `xml:"vmId" json:"vmId"`
	// Opaque metadata for the VM identified by vmId.
	//
	// If no
	// value is supplied, the entry for this VM is removed.
	Metadata string `xml:"metadata,omitempty" json:"metadata,omitempty"`
}

func init() {
	t["VirtualMachineMetadataManagerVmMetadata"] = reflect.TypeOf((*VirtualMachineMetadataManagerVmMetadata)(nil)).Elem()
}

// VmMetadataInput specifies the operation and metadata for a
// specific VM.
type VirtualMachineMetadataManagerVmMetadataInput struct {
	DynamicData

	// The input operation type.
	//
	// The values come from `VirtualMachineMetadataManagerVmMetadataOp_enum`
	Operation string `xml:"operation" json:"operation"`
	// the VM and optional metadata
	VmMetadata VirtualMachineMetadataManagerVmMetadata `xml:"vmMetadata" json:"vmMetadata"`
}

func init() {
	t["VirtualMachineMetadataManagerVmMetadataInput"] = reflect.TypeOf((*VirtualMachineMetadataManagerVmMetadataInput)(nil)).Elem()
}

// VmMetadataOwner defines the namespace for an owner
type VirtualMachineMetadataManagerVmMetadataOwner struct {
	DynamicData

	// A string representing the owner.
	//
	// Valid values come
	// from `VirtualMachineMetadataManagerVmMetadataOwnerOwner_enum` for vSAN datastores. Otherwise, the
	// owner field is interpreted by the implementation based on
	// the datastore type.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["VirtualMachineMetadataManagerVmMetadataOwner"] = reflect.TypeOf((*VirtualMachineMetadataManagerVmMetadataOwner)(nil)).Elem()
}

// A list of VmMetadataResults are returned for successful and
// non-successful results of an update or retrieve operation.
//
// See also `VirtualMachineMetadataManager.UpdateMetadata`, `VirtualMachineMetadataManager.RetrieveMetadata`, `VirtualMachineMetadataManager.RetrieveAllMetadata`, `VirtualMachineMetadataManager.ClearMetadata`.
type VirtualMachineMetadataManagerVmMetadataResult struct {
	DynamicData

	// The VM-specific metadata
	VmMetadata VirtualMachineMetadataManagerVmMetadata `xml:"vmMetadata" json:"vmMetadata"`
	// MethodFault set for errors in getting or setting
	// the VmMetadata.
	Error *LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
}

func init() {
	t["VirtualMachineMetadataManagerVmMetadataResult"] = reflect.TypeOf((*VirtualMachineMetadataManagerVmMetadataResult)(nil)).Elem()
}

// The `VirtualMachineMksConnection` object describes an MKS style connection
// to the virtual machine.
type VirtualMachineMksConnection struct {
	VirtualMachineConnection
}

func init() {
	t["VirtualMachineMksConnection"] = reflect.TypeOf((*VirtualMachineMksConnection)(nil)).Elem()
	minAPIVersionForType["VirtualMachineMksConnection"] = "7.0.1.0"
}

// Deprecated as of vSphere API 4.1, use `VirtualMachineTicket`
// instead.
//
// This data object contains the information needed to establish an MKS
// (mouse-keyboard-screen) connection to a running virtual machine.
type VirtualMachineMksTicket struct {
	DynamicData

	// The ticket name.
	//
	// This is used as the username and password for the MKS
	// connection.
	Ticket string `xml:"ticket" json:"ticket"`
	// The name of the configuration file for the virtual machine.
	CfgFile string `xml:"cfgFile" json:"cfgFile"`
	// The host with which to establish a connection.
	//
	// If the host is not specified,
	// it is assumed that the requesting entity knows the appropriate host with which
	// to connect.
	Host string `xml:"host,omitempty" json:"host,omitempty"`
	// The port number to use.
	//
	// If the port is not specified,
	// it is assumed that the requesting entity knows the appropriate port to
	// use when making a new connection.
	Port int32 `xml:"port,omitempty" json:"port,omitempty"`
	// The expected thumbprint of the SSL cert of the host to which
	// we are connecting.
	SslThumbprint string `xml:"sslThumbprint,omitempty" json:"sslThumbprint,omitempty"`
}

func init() {
	t["VirtualMachineMksTicket"] = reflect.TypeOf((*VirtualMachineMksTicket)(nil)).Elem()
}

// NetworkInfo describes a network that a device backing
// can attached to.
type VirtualMachineNetworkInfo struct {
	VirtualMachineTargetInfo

	// Information about the network
	Network BaseNetworkSummary `xml:"network,typeattr" json:"network"`
	// Key of parent vSwitch of the network
	Vswitch string `xml:"vswitch,omitempty" json:"vswitch,omitempty"`
}

func init() {
	t["VirtualMachineNetworkInfo"] = reflect.TypeOf((*VirtualMachineNetworkInfo)(nil)).Elem()
}

// Network traffic shaping specification.
//
// Traffic shaping is used to configure the network utilization
// characteristics of a virtual machine.
type VirtualMachineNetworkShaperInfo struct {
	DynamicData

	// Is the shaper enabled?
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Peak bandwidth, in bits per second.
	PeakBps int64 `xml:"peakBps,omitempty" json:"peakBps,omitempty"`
	// Average bandwidth, in bits per second.
	AverageBps int64 `xml:"averageBps,omitempty" json:"averageBps,omitempty"`
	// Burst size, in bytes.
	BurstSize int64 `xml:"burstSize,omitempty" json:"burstSize,omitempty"`
}

func init() {
	t["VirtualMachineNetworkShaperInfo"] = reflect.TypeOf((*VirtualMachineNetworkShaperInfo)(nil)).Elem()
}

// ParallelInfo class contains information about a physical parallel
// drive on the host.
type VirtualMachineParallelInfo struct {
	VirtualMachineTargetInfo
}

func init() {
	t["VirtualMachineParallelInfo"] = reflect.TypeOf((*VirtualMachineParallelInfo)(nil)).Elem()
}

// Description of a generic PCI device that can be attached to a virtual machine.
type VirtualMachinePciPassthroughInfo struct {
	VirtualMachineTargetInfo

	// Details of the PCI device, including vendor, class and
	// device identification information.
	PciDevice HostPciDevice `xml:"pciDevice" json:"pciDevice"`
	// The ID of the system the PCI device is attached to.
	SystemId string `xml:"systemId" json:"systemId"`
}

func init() {
	t["VirtualMachinePciPassthroughInfo"] = reflect.TypeOf((*VirtualMachinePciPassthroughInfo)(nil)).Elem()
}

// Description of a gpu PCI device that can be shared with a virtual machine.
type VirtualMachinePciSharedGpuPassthroughInfo struct {
	VirtualMachineTargetInfo

	// The VGPU corresponding to this GPU passthrough device.
	Vgpu string `xml:"vgpu" json:"vgpu"`
}

func init() {
	t["VirtualMachinePciSharedGpuPassthroughInfo"] = reflect.TypeOf((*VirtualMachinePciSharedGpuPassthroughInfo)(nil)).Elem()
}

// The PrecisionClockInfo data object type describes available host
// clock resources, which can be used as backing reference for
// virtual precision clock devices.
type VirtualMachinePrecisionClockInfo struct {
	VirtualMachineTargetInfo

	// The currrent host system clock synchronization protocol.
	//
	// Used for specifying protocol in
	// `VirtualPrecisionClockSystemClockBackingInfo`.
	SystemClockProtocol string `xml:"systemClockProtocol,omitempty" json:"systemClockProtocol,omitempty"`
}

func init() {
	t["VirtualMachinePrecisionClockInfo"] = reflect.TypeOf((*VirtualMachinePrecisionClockInfo)(nil)).Elem()
}

// The `VirtualMachineProfileDetails` data object type provides details of the policy
// associated with a virtual machine and it's virtual disks.
type VirtualMachineProfileDetails struct {
	DynamicData

	// Storage profile associated with Virtual Machine's home directory.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
	// An optional list that allows specifying details of the policy associated
	// with virutual disks.
	DiskProfileDetails []VirtualMachineProfileDetailsDiskProfileDetails `xml:"diskProfileDetails,omitempty" json:"diskProfileDetails,omitempty"`
}

func init() {
	t["VirtualMachineProfileDetails"] = reflect.TypeOf((*VirtualMachineProfileDetails)(nil)).Elem()
}

// Details of the policies associated with Virtual Disks.
type VirtualMachineProfileDetailsDiskProfileDetails struct {
	DynamicData

	// Virtual disk ID.
	DiskId int32 `xml:"diskId" json:"diskId"`
	// Storage profile associated with the Virtual Disk.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
}

func init() {
	t["VirtualMachineProfileDetailsDiskProfileDetails"] = reflect.TypeOf((*VirtualMachineProfileDetailsDiskProfileDetails)(nil)).Elem()
}

// The extensible data object type encapsulates additional data specific
// to Virtual Machine and its devices.
//
// This data is provided by vSphere Extensions which are integral part
// of vSphere.
//
// The data is not persisted in Virtual Machine configuration file but is
// stored and managed by extensions.
//
// Storage Profile Based Management (SPBM) will be one of the consumers of
// this data structure. SPBM will provide detailed information about
// Virtual Machine storage requirements.
type VirtualMachineProfileRawData struct {
	DynamicData

	// vSphere Extension Identifier
	ExtensionKey string `xml:"extensionKey" json:"extensionKey"`
	// Extension-specific additional data to be associated
	// with Virtual machine and its devices.
	ObjectData string `xml:"objectData,omitempty" json:"objectData,omitempty"`
}

func init() {
	t["VirtualMachineProfileRawData"] = reflect.TypeOf((*VirtualMachineProfileRawData)(nil)).Elem()
}

// The ProfileSpec data object is used to specify the Storage Policy to be
// associated with a Virtual Machine Home or a Virtual Disk.
type VirtualMachineProfileSpec struct {
	DynamicData
}

func init() {
	t["VirtualMachineProfileSpec"] = reflect.TypeOf((*VirtualMachineProfileSpec)(nil)).Elem()
}

// Data object which represents relations between a
// property and its target value and the required values
// of any other properties in the vm configuration so
// that the target value can be set.
type VirtualMachinePropertyRelation struct {
	DynamicData

	// The target property and its value
	Key DynamicProperty `xml:"key" json:"key"`
	// The related properties and their values
	Relations []DynamicProperty `xml:"relations,omitempty" json:"relations,omitempty"`
}

func init() {
	t["VirtualMachinePropertyRelation"] = reflect.TypeOf((*VirtualMachinePropertyRelation)(nil)).Elem()
}

// This data object type describes the question that is currently
// blocking a virtual machine.
type VirtualMachineQuestionInfo struct {
	DynamicData

	// Identifier with an opaque value that specifies the pending question.
	Id string `xml:"id" json:"id"`
	// Text that describes the pending question.
	Text string `xml:"text" json:"text"`
	// List of key-value pairs that specify possible answers.
	Choice ChoiceOption `xml:"choice" json:"choice"`
	// The message data for the individual messages that comprise the question.
	//
	// Only available on servers that support localization.
	Message []VirtualMachineMessage `xml:"message,omitempty" json:"message,omitempty"`
}

func init() {
	t["VirtualMachineQuestionInfo"] = reflect.TypeOf((*VirtualMachineQuestionInfo)(nil)).Elem()
}

// A set of statistics that are typically updated with near real-time regularity.
//
// This data object type does not support notification, for scalability reasons.
// Therefore, changes in QuickStats do not generate property collector updates. To
// monitor statistics values, use the statistics and alarms modules instead.
type VirtualMachineQuickStats struct {
	DynamicData

	// Basic CPU performance statistics, in MHz.
	//
	// Valid while the virtual machine is running.
	OverallCpuUsage int32 `xml:"overallCpuUsage,omitempty" json:"overallCpuUsage,omitempty"`
	// Basic CPU performance statistics, in MHz.
	//
	// Valid while the virtual machine is running.
	OverallCpuDemand int32 `xml:"overallCpuDemand,omitempty" json:"overallCpuDemand,omitempty"`
	// Percentage of time that the virtual machine was ready, but could not
	// get scheduled to run on the physical CPU.
	//
	// Valid while the virtual machine is running.
	OverallCpuReadiness int32 `xml:"overallCpuReadiness,omitempty" json:"overallCpuReadiness,omitempty"`
	// Guest memory utilization statistics, in MB.
	//
	// This
	// is also known as active guest memory. The number
	// can be between 0 and the configured memory size of
	// the virtual machine. Valid while the virtual machine is
	// running.
	GuestMemoryUsage int32 `xml:"guestMemoryUsage,omitempty" json:"guestMemoryUsage,omitempty"`
	// Host memory utilization statistics, in MB.
	//
	// This
	// is also known as consumed host memory. This is between 0 and
	// the configured resource limit. Valid while the virtual machine is
	// running. This includes the overhead memory of the VM.
	HostMemoryUsage int32 `xml:"hostMemoryUsage,omitempty" json:"hostMemoryUsage,omitempty"`
	// Guest operating system heartbeat metric.
	//
	// See `VirtualMachine.guestHeartbeatStatus` for a description.
	GuestHeartbeatStatus ManagedEntityStatus `xml:"guestHeartbeatStatus" json:"guestHeartbeatStatus"`
	// This is the amount of CPU resource, in MHz, that this VM is entitled to, as
	// calculated by DRS.
	//
	// Valid only for a VM managed by DRS.
	DistributedCpuEntitlement int32 `xml:"distributedCpuEntitlement,omitempty" json:"distributedCpuEntitlement,omitempty"`
	// This is the amount of memory, in MB, that this VM is entitled to, as
	// calculated by DRS.
	//
	// Valid only for a VM managed by DRS.
	DistributedMemoryEntitlement int32 `xml:"distributedMemoryEntitlement,omitempty" json:"distributedMemoryEntitlement,omitempty"`
	// The static CPU resource entitlement for a virtual machine.
	//
	// This value is
	// calculated based on this virtual machine's resource reservations, shares
	// and limit, and doesn't take into account current usage. This is the worst
	// case CPU allocation for this virtual machine, that is, the amount of CPU
	// resource this virtual machine would receive if all virtual machines running
	// in the cluster went to maximum consumption. Units are MHz.
	StaticCpuEntitlement int32 `xml:"staticCpuEntitlement,omitempty" json:"staticCpuEntitlement,omitempty"`
	// The static memory resource entitlement for a virtual machine.
	//
	// This value is
	// calculated based on this virtual machine's resource reservations, shares
	// and limit, and doesn't take into account current usage. This is the worst
	// case memory allocation for this virtual machine, that is, the amount of
	// memory this virtual machine would receive if all virtual machines running
	// in the cluster went to maximum consumption. Units are MB.
	StaticMemoryEntitlement int32 `xml:"staticMemoryEntitlement,omitempty" json:"staticMemoryEntitlement,omitempty"`
	// Amount of host physical memory that is mapped for a virtual machine,
	// in MB.
	//
	// The number can be between 0 and the configured memory size of
	// the virtual machine. Valid while the virtual machine is running.
	GrantedMemory int32 `xml:"grantedMemory,omitempty" json:"grantedMemory,omitempty"`
	// The portion of memory, in MB, that is granted to this VM from non-shared
	// host memory.
	PrivateMemory int32 `xml:"privateMemory,omitempty" json:"privateMemory,omitempty"`
	// The portion of memory, in MB, that is granted to this VM from host memory
	// that is shared between VMs.
	SharedMemory int32 `xml:"sharedMemory,omitempty" json:"sharedMemory,omitempty"`
	// The portion of memory, in MB, that is granted to this VM from the host's swap
	// space.
	//
	// This is a sign that there is memory pressure on the host.
	SwappedMemory int32 `xml:"swappedMemory,omitempty" json:"swappedMemory,omitempty"`
	// The size of the balloon driver in the VM, in MB.
	//
	// The host will inflate the
	// balloon driver to reclaim physical memory from the VM. This is a sign that
	// there is memory pressure on the host.
	BalloonedMemory int32 `xml:"balloonedMemory,omitempty" json:"balloonedMemory,omitempty"`
	// The amount of consumed overhead memory, in MB, for this VM.
	ConsumedOverheadMemory int32 `xml:"consumedOverheadMemory,omitempty" json:"consumedOverheadMemory,omitempty"`
	// The network bandwidth used for logging between the
	// primary and secondary fault tolerance VMs.
	//
	// The unit is kilobytes per second.
	FtLogBandwidth int32 `xml:"ftLogBandwidth,omitempty" json:"ftLogBandwidth,omitempty"`
	// The amount of time in wallclock that the VCPU of the secondary fault
	// tolerance VM is behind the VCPU of the primary VM.
	//
	// The unit is millisecond.
	FtSecondaryLatency int32 `xml:"ftSecondaryLatency,omitempty" json:"ftSecondaryLatency,omitempty"`
	// The latency status of the fault tolerance VM.
	//
	// ftLatencyStatus is determined by the value of ftSecondaryLatency.
	// ftLatencyStatus is:
	// green, if ftSecondaryLatency is less than or equal to 2 seconds;
	// yellow, if ftSecondaryLatency is greater than 2 seconds,
	// and less than or equal to 6 seconds;
	// red, if ftSecondaryLatency is greater than 6 seconds;
	// gray, if ftSecondaryLatency is unknown.
	FtLatencyStatus ManagedEntityStatus `xml:"ftLatencyStatus,omitempty" json:"ftLatencyStatus,omitempty"`
	// The amount of compressed memory currently consumed by VM, in Kb.
	CompressedMemory int64 `xml:"compressedMemory,omitempty" json:"compressedMemory,omitempty"`
	// The system uptime of the VM in seconds.
	UptimeSeconds int32 `xml:"uptimeSeconds,omitempty" json:"uptimeSeconds,omitempty"`
	// The amount of memory swapped to fast disk device such as
	// SSD, in KB.
	SsdSwappedMemory int64 `xml:"ssdSwappedMemory,omitempty" json:"ssdSwappedMemory,omitempty"`
	// The amount of memory that was recently touched by the VM, in MB.
	ActiveMemory int32 `xml:"activeMemory,omitempty" json:"activeMemory,omitempty" vim:"7.0.3.0"`
	// Stats for each physical memory tier.
	//
	// A physical memory tier consists of one or
	// more logical memory tiers of the same `HostMemoryTierType_enum`. For
	// example, the logical tiers can be tier0 (DRAM), tier1 (DRAM), and tier2 (PMEM),
	// while the physical tiers are just DRAM and PMEM.
	MemoryTierStats []VirtualMachineQuickStatsMemoryTierStats `xml:"memoryTierStats,omitempty" json:"memoryTierStats,omitempty" vim:"7.0.3.0"`
}

func init() {
	t["VirtualMachineQuickStats"] = reflect.TypeOf((*VirtualMachineQuickStats)(nil)).Elem()
}

type VirtualMachineQuickStatsMemoryTierStats struct {
	DynamicData

	// The memory tier type.
	//
	// See `HostMemoryTierType_enum` for supported
	// values.
	MemoryTierType string `xml:"memoryTierType" json:"memoryTierType"`
	// Memory access bandwidth usage for the reads of the VM on this tier in
	// MBps.
	ReadBandwidth int64 `xml:"readBandwidth" json:"readBandwidth"`
}

func init() {
	t["VirtualMachineQuickStatsMemoryTierStats"] = reflect.TypeOf((*VirtualMachineQuickStatsMemoryTierStats)(nil)).Elem()
	minAPIVersionForType["VirtualMachineQuickStatsMemoryTierStats"] = "7.0.3.0"
}

// Specification for moving or copying a virtual machine to a different datastore
// or host.
type VirtualMachineRelocateSpec struct {
	DynamicData

	// The service endpoint of vCenter where the virtual machine should be
	// located.
	//
	// If not specified, the current vCenter service is used. If the
	// virtual machine is relocated to a different vCenter service, the
	// destination host, pool, and datastore parameters have to be explicitly
	// specified by default when the task is submitted.
	Service *ServiceLocator `xml:"service,omitempty" json:"service,omitempty"`
	// The folder where the virtual machine should be located.
	//
	// If not specified,
	// the root VM folder of the destination datacenter will be used.
	//
	// Refers instance of `Folder`.
	Folder *ManagedObjectReference `xml:"folder,omitempty" json:"folder,omitempty"`
	// The datastore where the virtual machine should be located.
	//
	// If
	// not specified, the current datastore is used.
	//
	// Refers instance of `Datastore`.
	Datastore *ManagedObjectReference `xml:"datastore,omitempty" json:"datastore,omitempty"`
	// Manner in which to move the virtual disk to the *target datastore*.
	//
	// The set of possible values is described in
	// `VirtualMachineRelocateDiskMoveOptions_enum`.
	//
	// This property applies to all the disks which the virtual machine has,
	// but can be overridden on a per-disk basis using
	// `VirtualMachineRelocateSpecDiskLocator.diskMoveType` prior to vSphere
	// API 6.0 or using
	// `VirtualDiskConfigSpec.diskMoveType` in vSphere API
	// 6.0 and later.
	//
	// This property can only be set if
	// `HostCapability.deltaDiskBackingsSupported` is true.
	//
	// If left unset then
	// `moveAllDiskBackingsAndDisallowSharing`
	// is assumed.
	DiskMoveType string `xml:"diskMoveType,omitempty" json:"diskMoveType,omitempty"`
	// The resource pool to which this virtual machine should be attached.
	//   - For a relocate or clone operation to a virtual machine, if the
	//     argument is not supplied, the current resource pool of virtual
	//     machine is used.
	//   - For a clone operation from a template to a virtual machine,
	//     this argument is required.
	//   - If the virtual machine is relocated to a different vCenter service,
	//     and a resource pool is not specified, the destination host must be
	//     specified.
	//   - If a resource pool is specified, the virtual machine is powered
	//     on, and the target pool represents a cluster without DRS enabled,
	//     an InvalidArgument exception is thrown.
	//   - If the virtual machine is relocated to a different datacenter
	//     within the vCenter service, the resource pool has to be specified
	//     and cannot be unset.
	//
	// Refers instance of `ResourcePool`.
	Pool *ManagedObjectReference `xml:"pool,omitempty" json:"pool,omitempty"`
	// The target host for the virtual machine.
	//
	// If not specified,
	//   - if resource pool is not specified, current host is used.
	//   - if resource pool is specified, and the target pool represents
	//     a stand-alone host, the host is used.
	//   - if resource pool is specified, the virtual machine is powered on,
	//     and the target pool represents a DRS-enabled cluster, a host
	//     selected by DRS is used.
	//   - if resource pool is specified, the virtual machine is powered on,
	//     and the target pool represents a cluster without DRS enabled,
	//     an InvalidArgument exception is thrown.
	//   - if a resource pool is specified, the target pool represents a
	//     cluster, and this is a clone or the virtual machine is powered
	//     off, a random compatible host is chosen.
	//   - A destination host must be specified if the virtual machine is
	//     relocated to a different vCenter service, and a resource pool is
	//     not specified.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// An optional list that allows specifying the datastore location
	// for each virtual disk.
	Disk []VirtualMachineRelocateSpecDiskLocator `xml:"disk,omitempty" json:"disk,omitempty"`
	// Deprecated as of vSphere API 5.0. Use
	// `VirtualMachineRelocateSpecDiskLocator.diskBackingInfo` instead for
	// disk format conversions. This setting will be ignored for
	// disks with the above property set.
	//
	// Transformation to perform on the disks.
	//
	// The backend is free to ignore
	// this hint if it is not valid for the current operation. This can be
	// used by clients, for example, to create sparse disks for templates.
	//
	// See also `VirtualMachineRelocateTransformation_enum`.
	Transform VirtualMachineRelocateTransformation `xml:"transform,omitempty" json:"transform,omitempty"`
	// An optional list of virtual device specs that allow specifying the new
	// device locations for the relocate operation.
	//
	// The supported device changes are:
	//   - For `VirtualEthernetCard`, it has to be used
	//     in `VirtualDeviceConfigSpec.device` to specify the
	//     target network backing.
	//   - For `VirtualDisk`, it can be used to specify
	//     vFlash cache configuration, or the storage profile for destination
	//     disks. The storage profiles are used to either upgrade the virtual
	//     disk's storage to a persistent memory, or keep the virtual disk
	//     in persistent memory when moving the virtual machine's overall
	//     storage.
	//   - All other specification are ignored.
	DeviceChange []BaseVirtualDeviceConfigSpec `xml:"deviceChange,omitempty,typeattr" json:"deviceChange,omitempty"`
	// Storage profile requirement for Virtual Machine's home directory.
	//
	// Profiles are solution specific.
	// Storage Profile Based Management(SPBM) is a vSphere server extension.
	// The API users who want to provision VMs using Storage Profiles, need to
	// interact with SPBM.
	// This is an optional parameter and if user doesn't specify profile,
	// the default behavior will apply.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
	// Virtual Machine cryptographic options.
	//
	// Encryption requirement for the virtual machine's metadata
	// files (non-disk files).
	CryptoSpec BaseCryptoSpec `xml:"cryptoSpec,omitempty,typeattr" json:"cryptoSpec,omitempty"`
}

func init() {
	t["VirtualMachineRelocateSpec"] = reflect.TypeOf((*VirtualMachineRelocateSpec)(nil)).Elem()
}

// The DiskLocator data object type specifies a virtual disk device (by ID) and
// a datastore locator for the disk's storage.
type VirtualMachineRelocateSpecDiskLocator struct {
	DynamicData

	// Device ID of the virtual disk.
	DiskId int32 `xml:"diskId" json:"diskId"`
	// Target datastore.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// Manner in which to move the virtual disk to the *target datastore*.
	//
	// The set of possible values is described
	// in `VirtualMachineRelocateDiskMoveOptions_enum`.
	//
	// This property can only be set if `HostCapability.deltaDiskBackingsSupported` is true.
	//
	// If left unset then `moveAllDiskBackingsAndDisallowSharing`
	// is assumed.
	DiskMoveType string `xml:"diskMoveType,omitempty" json:"diskMoveType,omitempty"`
	// Backing information for the virtual disk at the destination.
	//
	// This can be used, for instance, to change the format of the
	// virtual disk. If the specified backing is invalid or not
	// supported at the destination, `InvalidDeviceBacking` is thrown. Specific property
	// changes may be ignored if they are not supported.
	//
	// Supported BackingInfo types and properties:
	//   - `VirtualDiskFlatVer2BackingInfo`
	//   - thinProvisioned
	//   - eagerlyScrub
	//   - `VirtualDiskSeSparseBackingInfo`
	//     (ESX 5.1 or later)
	DiskBackingInfo BaseVirtualDeviceBackingInfo `xml:"diskBackingInfo,omitempty,typeattr" json:"diskBackingInfo,omitempty"`
	// Virtual Disk Profile requirement.
	//
	// Profiles are solution specific.
	// Profile Based Storage Management is a vSphere server extension.
	// The API users who want to provision VMs using Storage Profiles, need to
	// interact with it.
	// This is an optional parameter and if user doesn't specify profile,
	// the default behavior will apply.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
	// Cryptographic option of the current disk.
	Backing *VirtualMachineRelocateSpecDiskLocatorBackingSpec `xml:"backing,omitempty" json:"backing,omitempty"`
	// List of independent filters `VirtualMachineIndependentFilterSpec`
	// to be configured on the virtual disk after the relocate.
	FilterSpec []BaseVirtualMachineBaseIndependentFilterSpec `xml:"filterSpec,omitempty,typeattr" json:"filterSpec,omitempty" vim:"7.0.2.1"`
}

func init() {
	t["VirtualMachineRelocateSpecDiskLocator"] = reflect.TypeOf((*VirtualMachineRelocateSpecDiskLocator)(nil)).Elem()
}

// <code>`VirtualMachineRelocateSpecDiskLocatorBackingSpec`</code> is a data
// object type for crytographic information about the backing of a
// device.
//
// The member `VirtualMachineRelocateSpecDiskLocatorBackingSpec.parent` refers the parent in the chain of
// `VirtualDeviceBackingInfo` objects.
type VirtualMachineRelocateSpecDiskLocatorBackingSpec struct {
	DynamicData

	Parent *VirtualMachineRelocateSpecDiskLocatorBackingSpec `xml:"parent,omitempty" json:"parent,omitempty"`
	Crypto BaseCryptoSpec                                    `xml:"crypto,omitempty,typeattr" json:"crypto,omitempty"`
}

func init() {
	t["VirtualMachineRelocateSpecDiskLocatorBackingSpec"] = reflect.TypeOf((*VirtualMachineRelocateSpecDiskLocatorBackingSpec)(nil)).Elem()
}

// The RuntimeInfo data object type provides information about
// the execution state and history of a virtual machine.
type VirtualMachineRuntimeInfo struct {
	DynamicData

	// Per-device runtime info.
	//
	// This array will be empty if the host
	// software does not provide runtime info for any of the device
	// types currently in use by the virtual machine.
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	Device []VirtualMachineDeviceRuntimeInfo `xml:"device,omitempty" json:"device,omitempty"`
	// The host that is responsible for running a virtual machine.
	//
	// This property is null if the virtual machine is not running and is
	// not assigned to run on a particular host.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// Indicates whether or not the virtual machine is available for management.
	ConnectionState VirtualMachineConnectionState `xml:"connectionState" json:"connectionState"`
	// The current power state of the virtual machine.
	PowerState VirtualMachinePowerState `xml:"powerState" json:"powerState"`
	// Represents if the vm is currently being failed over by FDM
	VmFailoverInProgress *bool `xml:"vmFailoverInProgress" json:"vmFailoverInProgress,omitempty" vim:"7.0.2.0"`
	// The fault tolerance state of the virtual machine.
	FaultToleranceState VirtualMachineFaultToleranceState `xml:"faultToleranceState,omitempty" json:"faultToleranceState,omitempty"`
	// The vSphere HA protection state for a virtual machine.
	//
	// Property
	// is unset if vSphere HA is not enabled.
	DasVmProtection *VirtualMachineRuntimeInfoDasProtectionState `xml:"dasVmProtection,omitempty" json:"dasVmProtection,omitempty"`
	// Flag to indicate whether or not the VMware Tools installer
	// is mounted as a CD-ROM.
	ToolsInstallerMounted bool `xml:"toolsInstallerMounted" json:"toolsInstallerMounted"`
	// The timestamp when the virtual machine was most recently suspended.
	//
	// This property is updated every time the virtual machine is suspended.
	SuspendTime *time.Time `xml:"suspendTime" json:"suspendTime,omitempty"`
	// The timestamp when the virtual machine was most recently powered on.
	//
	// This property is updated when the virtual machine is powered on
	// from the poweredOff state, and is cleared when the virtual machine is
	// powered off. This property is not updated when a virtual machine is resumed
	// from a suspended state.
	BootTime *time.Time `xml:"bootTime" json:"bootTime,omitempty"`
	// The total time the virtual machine has been suspended
	// since it was initially powered on.
	//
	// This time excludes the current period,
	// if the virtual machine is currently suspended. This property is updated
	// when the virtual machine resumes, and is reset to zero when the virtual machine
	// is powered off.
	SuspendInterval int64 `xml:"suspendInterval,omitempty" json:"suspendInterval,omitempty"`
	// The current question, if any, that is blocking the virtual machine's execution.
	Question *VirtualMachineQuestionInfo `xml:"question,omitempty" json:"question,omitempty"`
	// Deprecated as of vSphere API 4.1, use the `PerformanceManager`
	// memory overhead counter to get this value.
	//
	// The amount of memory resource (in bytes) that will be used by
	// the virtual machine above its guest memory requirements.
	//
	// This value is set if and only if the virtual machine is registered
	// on a host that supports memory resource allocation features.
	//
	// For powered off VMs, this is the minimum overhead required to
	// power on the VM on the registered host.
	//
	// For powered on VMs, this is the current overhead reservation, a
	// value which is almost always larger than the minimum overhead, and
	// which grows with time.
	//
	// See also `HostSystem.QueryMemoryOverheadEx`.
	MemoryOverhead int64 `xml:"memoryOverhead,omitempty" json:"memoryOverhead,omitempty"`
	// Current upper-bound on CPU usage.
	//
	// The upper-bound is based on the host
	// the virtual machine is current running on, as well as limits configured
	// on the virtual machine itself or any parent resource pool.
	// Valid while the virtual machine is running.
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	MaxCpuUsage int32 `xml:"maxCpuUsage,omitempty" json:"maxCpuUsage,omitempty"`
	// Current upper-bound on memory usage.
	//
	// The upper-bound is based on memory
	// configuration of the virtual machine, as well as limits configured
	// on the virtual machine itself or any parent resource pool.
	// Valid while the virtual machine is running.
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	MaxMemoryUsage int32 `xml:"maxMemoryUsage,omitempty" json:"maxMemoryUsage,omitempty"`
	// Number of active MKS connections to this virtual machine.
	NumMksConnections int32 `xml:"numMksConnections" json:"numMksConnections"`
	// Deprecated as of vSphere API 6.0.
	//
	// Record / replay state of this virtual machine.
	RecordReplayState VirtualMachineRecordReplayState `xml:"recordReplayState,omitempty" json:"recordReplayState,omitempty"`
	// For a powered off virtual machine, indicates whether the virtual
	// machine's last shutdown was an orderly power off or not.
	//
	// Unset if
	// the virtual machine is running or suspended.
	CleanPowerOff *bool `xml:"cleanPowerOff" json:"cleanPowerOff,omitempty"`
	// If set, indicates the reason the virtual machine needs a secondary.
	NeedSecondaryReason string `xml:"needSecondaryReason,omitempty" json:"needSecondaryReason,omitempty"`
	// This property indicates whether the guest has gone into one of the
	// s1, s2 or s3 standby modes, false indicates the guest is awake.
	OnlineStandby *bool `xml:"onlineStandby" json:"onlineStandby,omitempty"`
	// For a powered-on or suspended virtual machine in a cluster with Enhanced
	// VMotion Compatibility (EVC) enabled, this identifies the least-featured
	// EVC mode (among those for the appropriate CPU vendor) that could admit
	// the virtual machine.
	//
	// See `EVCMode`. Until vSphere 6.5, this
	// property will be unset if the virtual machine is powered off or is not in
	// an EVC cluster.
	//
	// This property may be used as a general indicator of the CPU feature
	// baseline currently in use by the virtual machine. However, the virtual
	// machine may be suppressing some of the features present in the CPU
	// feature baseline of the indicated mode, either explicitly (in the
	// virtual machine's configured
	// `cpuFeatureMask`) or implicitly
	// (in the default masks for the
	// `GuestOsDescriptor` appropriate for the
	// virtual machine's configured guest OS).
	MinRequiredEVCModeKey string `xml:"minRequiredEVCModeKey,omitempty" json:"minRequiredEVCModeKey,omitempty"`
	// Whether any disk of the virtual machine requires consolidation.
	//
	// This can happen for example when a snapshot is deleted but its
	// associated disk is not committed back to the base disk.
	// Use `VirtualMachine.ConsolidateVMDisks_Task` to consolidate if
	// needed.
	ConsolidationNeeded *bool `xml:"consolidationNeeded" json:"consolidationNeeded,omitempty"`
	// These requirements must have equivalent host capabilities
	// `HostConfigInfo.featureCapability` in order to power on.
	OfflineFeatureRequirement []VirtualMachineFeatureRequirement `xml:"offlineFeatureRequirement,omitempty" json:"offlineFeatureRequirement,omitempty"`
	// These requirements must have equivalent host capabilities
	// `HostConfigInfo.featureCapability` in order to power on,
	// resume, or migrate to the host.
	FeatureRequirement []VirtualMachineFeatureRequirement `xml:"featureRequirement,omitempty" json:"featureRequirement,omitempty"`
	// The masks applied to an individual virtual machine as a result of its
	// configuration.
	FeatureMask []HostFeatureMask `xml:"featureMask,omitempty" json:"featureMask,omitempty"`
	// Deprecated since vSphere 7.0 because vFlash Read Cache
	// end of availability.
	//
	// Specifies the total allocated vFlash resource for the vFlash caches associated with VM's
	// VMDKs when VM is powered on, in bytes.
	VFlashCacheAllocation int64 `xml:"vFlashCacheAllocation,omitempty" json:"vFlashCacheAllocation,omitempty"`
	// Whether the virtual machine is paused, or not.
	Paused *bool `xml:"paused" json:"paused,omitempty"`
	// Whether a snapshot operation is in progress in the background, or not.
	SnapshotInBackground *bool `xml:"snapshotInBackground" json:"snapshotInBackground,omitempty"`
	// This flag indicates whether a parent virtual machine is in a fork ready
	// state.
	//
	// A persistent instant clone child can be created only when this flag
	// is true. While a non-persistent instant clone child can be created
	// independent of this flag, it can only be powered on if this flag is true.
	QuiescedForkParent *bool `xml:"quiescedForkParent" json:"quiescedForkParent,omitempty"`
	// Whether the virtual machine is frozen for instant clone, or not.
	InstantCloneFrozen *bool `xml:"instantCloneFrozen" json:"instantCloneFrozen,omitempty"`
	// Encryption state of the virtual machine.
	//
	// Valid values are enumerated by the
	// `CryptoState` type.
	CryptoState string `xml:"cryptoState,omitempty" json:"cryptoState,omitempty"`
	// Whether the virtual machine is suspended to memory, or not.
	SuspendedToMemory *bool `xml:"suspendedToMemory" json:"suspendedToMemory,omitempty" vim:"7.0.2.0"`
	// Operation notification timeout in seconds.
	//
	// Specifies the maximum time duration the application may take to
	// prepare for the operation after it has been notified.
	// This property is set only for powered on VMs.
	OpNotificationTimeout int64 `xml:"opNotificationTimeout,omitempty" json:"opNotificationTimeout,omitempty" vim:"8.0.0.1"`
	// Indicates whether there is active IOMMU domain in the current VM.
	IommuActive *bool `xml:"iommuActive" json:"iommuActive,omitempty" vim:"8.0.1.0"`
}

func init() {
	t["VirtualMachineRuntimeInfo"] = reflect.TypeOf((*VirtualMachineRuntimeInfo)(nil)).Elem()
}

// The `VirtualMachineRuntimeInfoDasProtectionState` object describes the
// vSphere HA protection state of a virtual machine (VM).
type VirtualMachineRuntimeInfoDasProtectionState struct {
	DynamicData

	// Whether vSphere HA is protecting a virtual machine (VM).
	//
	// If a
	// VM is protected, vSphere HA will enforce any availability
	// features that have been enabled for this VM. For
	// example, if the VM is running on a host
	// that fails and the VM is configured to be restarted on a failure,
	// then vSphere HA will attempt to restart the VM on another host.
	// Similarly, if you enable VM/Application Health Monitoring
	// for this VM, vSphere HA will monitor the heartbeats of the
	// VM and reset the VM when needed, as dictated by the configured
	// policy settings.
	DasProtected bool `xml:"dasProtected" json:"dasProtected"`
}

func init() {
	t["VirtualMachineRuntimeInfoDasProtectionState"] = reflect.TypeOf((*VirtualMachineRuntimeInfoDasProtectionState)(nil)).Elem()
}

// The ScsiDiskDeviceInfo class contains detailed information about a specific
// scsi disk hardware device.
//
// These devices are for the
// vim.vm.device.VirtualDisk.RawDiskMappingVer1BackingInfo.
type VirtualMachineScsiDiskDeviceInfo struct {
	VirtualMachineDiskDeviceInfo

	// Detailed information about the disk.
	Disk *HostScsiDisk `xml:"disk,omitempty" json:"disk,omitempty"`
	// Transport identifier hint used to identify the device.
	//
	// To definitively
	// correlate this device with a host physical disk, use the disk property.
	// This identifier is intended as a hint to end users to identify the
	// disk device.
	TransportHint string `xml:"transportHint,omitempty" json:"transportHint,omitempty"`
	// LUN number hint used to identify the SCSI device.
	//
	// To definitively
	// correlate this device with a host physical disk, use the disk property.
	// This identifier is intended as a hint to end users to identify the
	// disk device.
	LunNumber int32 `xml:"lunNumber,omitempty" json:"lunNumber,omitempty"`
}

func init() {
	t["VirtualMachineScsiDiskDeviceInfo"] = reflect.TypeOf((*VirtualMachineScsiDiskDeviceInfo)(nil)).Elem()
}

// Description of a generic SCSI device, including information about
// the device ID.
type VirtualMachineScsiPassthroughInfo struct {
	VirtualMachineTargetInfo

	// The class of the generic SCSI device.
	ScsiClass string `xml:"scsiClass" json:"scsiClass"`
	// The vendor name.
	Vendor string `xml:"vendor" json:"vendor"`
	// Unit number of the generic device on the physical host.
	PhysicalUnitNumber int32 `xml:"physicalUnitNumber" json:"physicalUnitNumber"`
}

func init() {
	t["VirtualMachineScsiPassthroughInfo"] = reflect.TypeOf((*VirtualMachineScsiPassthroughInfo)(nil)).Elem()
}

// SerialInfo class contains information about a physical serial
// drive on the host.
type VirtualMachineSerialInfo struct {
	VirtualMachineTargetInfo
}

func init() {
	t["VirtualMachineSerialInfo"] = reflect.TypeOf((*VirtualMachineSerialInfo)(nil)).Elem()
}

// This data object describes the virtual software guard extension (vSGX)
// configuration of this virtual machine.
type VirtualMachineSgxInfo struct {
	DynamicData

	// Size of vEPC, in megabytes.
	EpcSize int64 `xml:"epcSize" json:"epcSize"`
	// FLC mode for the virtual machine.
	//
	// The set of possible values are
	// described in `VirtualMachineSgxInfoFlcModes_enum`. If no value is specified,
	// then "unlocked" will be used.
	FlcMode string `xml:"flcMode,omitempty" json:"flcMode,omitempty"`
	// Public key hash of the provider launch enclave.
	//
	// This is the SHA256
	// digest of the SIGSTRUCT.MODULUS(MR\_SIGNER) of the provider launch
	// enclave. This hash must only be provided when the launch enclave mode is
	// "locked", for the other cases the hash is ignored.
	LePubKeyHash string `xml:"lePubKeyHash,omitempty" json:"lePubKeyHash,omitempty"`
	// Indicates whether or not a virtual machine requires remote
	// attestation.
	RequireAttestation *bool `xml:"requireAttestation" json:"requireAttestation,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VirtualMachineSgxInfo"] = reflect.TypeOf((*VirtualMachineSgxInfo)(nil)).Elem()
}

// Description of Intel Software Guard Extensions information.
type VirtualMachineSgxTargetInfo struct {
	VirtualMachineTargetInfo

	// Maximum size, in bytes, of EPC available on the compute resource.
	MaxEpcSize int64 `xml:"maxEpcSize" json:"maxEpcSize"`
	// FLC modes available in the compute resource.
	//
	// The set of possible values
	// are described in `VirtualMachineSgxInfoFlcModes_enum`.
	FlcModes []string `xml:"flcModes,omitempty" json:"flcModes,omitempty"`
	// Public key hashes of the provider launch enclaves available in the
	// compute resource.
	LePubKeyHashes []string `xml:"lePubKeyHashes,omitempty" json:"lePubKeyHashes,omitempty"`
	// Whether the host/cluster supports requiring SGX remote attestation.
	RequireAttestationSupported *bool `xml:"requireAttestationSupported" json:"requireAttestationSupported,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VirtualMachineSgxTargetInfo"] = reflect.TypeOf((*VirtualMachineSgxTargetInfo)(nil)).Elem()
}

// The SnapshotInfo data object type provides all the information about the
// hierarchy of snapshots in a virtual machine.
type VirtualMachineSnapshotInfo struct {
	DynamicData

	// Current snapshot of the virtual machine
	//
	// This property is set by calling
	// `Snapshot.revert` or
	// `VirtualMachine.createSnapshot`.
	// This property will be empty when the working snapshot is at the root
	// of the snapshot tree.
	//
	// Refers instance of `VirtualMachineSnapshot`.
	CurrentSnapshot *ManagedObjectReference `xml:"currentSnapshot,omitempty" json:"currentSnapshot,omitempty"`
	// Data for the entire set of snapshots for one virtual machine.
	RootSnapshotList []VirtualMachineSnapshotTree `xml:"rootSnapshotList" json:"rootSnapshotList"`
}

func init() {
	t["VirtualMachineSnapshotInfo"] = reflect.TypeOf((*VirtualMachineSnapshotInfo)(nil)).Elem()
}

// SnapshotTree encapsulates all the read-only data produced by the snapshot.
type VirtualMachineSnapshotTree struct {
	DynamicData

	// The managed object for this snapshot.
	//
	// Refers instance of `VirtualMachineSnapshot`.
	Snapshot ManagedObjectReference `xml:"snapshot" json:"snapshot"`
	// The virtual machine for which the snapshot was taken.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
	// Name of the snapshot.
	Name string `xml:"name" json:"name"`
	// Description of the snapshot.
	Description string `xml:"description" json:"description"`
	// The unique identifier that distinguishes this snapshot from
	// other snapshots of the virtual machine.
	Id int32 `xml:"id,omitempty" json:"id,omitempty"`
	// The date and time the snapshot was taken.
	CreateTime time.Time `xml:"createTime" json:"createTime"`
	// The power state of the virtual machine when this snapshot was taken.
	State VirtualMachinePowerState `xml:"state" json:"state"`
	// Flag to indicate whether or not the snapshot was created with
	// the "quiesce" option, ensuring a consistent state of the file system.
	Quiesced bool `xml:"quiesced" json:"quiesced"`
	// The relative path from the snapshotDirectory pointing to the backup
	// manifest.
	//
	// Available for certain quiesced snapshots only.
	BackupManifest string `xml:"backupManifest,omitempty" json:"backupManifest,omitempty"`
	// The snapshot data for all snapshots for which this snapshot is the parent.
	ChildSnapshotList []VirtualMachineSnapshotTree `xml:"childSnapshotList,omitempty" json:"childSnapshotList,omitempty"`
	// Deprecated as of vSphere API 6.0.
	//
	// Flag to indicate whether this snapshot is associated with a recording
	// session on the virtual machine that can be replayed.
	ReplaySupported *bool `xml:"replaySupported" json:"replaySupported,omitempty"`
}

func init() {
	t["VirtualMachineSnapshotTree"] = reflect.TypeOf((*VirtualMachineSnapshotTree)(nil)).Elem()
}

// SoundInfo class contains information about a physical sound
// card on the host.
type VirtualMachineSoundInfo struct {
	VirtualMachineTargetInfo
}

func init() {
	t["VirtualMachineSoundInfo"] = reflect.TypeOf((*VirtualMachineSoundInfo)(nil)).Elem()
}

type VirtualMachineSriovDevicePoolInfo struct {
	DynamicData

	// To be used for extending to other device types
	Key string `xml:"key" json:"key"`
}

func init() {
	t["VirtualMachineSriovDevicePoolInfo"] = reflect.TypeOf((*VirtualMachineSriovDevicePoolInfo)(nil)).Elem()
}

// Description of a SRIOV device that can be attached to a virtual machine.
type VirtualMachineSriovInfo struct {
	VirtualMachinePciPassthroughInfo

	// Indicates whether corresponding PCI device is a virtual function
	// instantiated by a SR-IOV capable device.
	VirtualFunction bool `xml:"virtualFunction" json:"virtualFunction"`
	// The name of the physical nic that is represented by a SR-IOV
	// capable physical function.
	Pnic string `xml:"pnic,omitempty" json:"pnic,omitempty"`
	// SRIOV DevicePool information
	DevicePool BaseVirtualMachineSriovDevicePoolInfo `xml:"devicePool,omitempty,typeattr" json:"devicePool,omitempty"`
}

func init() {
	t["VirtualMachineSriovInfo"] = reflect.TypeOf((*VirtualMachineSriovInfo)(nil)).Elem()
}

// This class is networking specific SR-IOV device pool info
type VirtualMachineSriovNetworkDevicePoolInfo struct {
	VirtualMachineSriovDevicePoolInfo

	// vSwitch key
	SwitchKey string `xml:"switchKey,omitempty" json:"switchKey,omitempty"`
	// DVSwitch Uuid
	SwitchUuid string `xml:"switchUuid,omitempty" json:"switchUuid,omitempty"`
}

func init() {
	t["VirtualMachineSriovNetworkDevicePoolInfo"] = reflect.TypeOf((*VirtualMachineSriovNetworkDevicePoolInfo)(nil)).Elem()
}

// Information about the amount of storage used by a virtual machine across
// datastores that it is located on.
type VirtualMachineStorageInfo struct {
	DynamicData

	// Storage space used by this virtual machine on all datastores that it
	// is located on.
	//
	// Total storage space committed to this virtual machine across all datastores is
	// simply an aggregate of the property
	// `VirtualMachineUsageOnDatastore.committed`.
	//
	// See also `VirtualMachineStorageSummary.committed`.
	PerDatastoreUsage []VirtualMachineUsageOnDatastore `xml:"perDatastoreUsage,omitempty" json:"perDatastoreUsage,omitempty"`
	// Time when values in this structure were last updated.
	Timestamp time.Time `xml:"timestamp" json:"timestamp"`
}

func init() {
	t["VirtualMachineStorageInfo"] = reflect.TypeOf((*VirtualMachineStorageInfo)(nil)).Elem()
}

// A subset of the storage information of this virtual machine.
//
// See `VirtualMachineStorageInfo` for a detailed storage break-up.
type VirtualMachineStorageSummary struct {
	DynamicData

	// Total storage space, in bytes, committed to this virtual machine across
	// all datastores.
	//
	// Essentially an aggregate of the property
	// `VirtualMachineUsageOnDatastore.committed` across all
	// datastores that this virtual machine is located on.
	Committed int64 `xml:"committed" json:"committed"`
	// Additional storage space, in bytes, potentially used by this virtual machine
	// on all datastores.
	//
	// Essentially an aggregate of the property
	// `VirtualMachineUsageOnDatastore.uncommitted` across all
	// datastores that this virtual machine is located on.
	Uncommitted int64 `xml:"uncommitted" json:"uncommitted"`
	// Total storage space, in bytes, occupied by the virtual machine across
	// all datastores, that is not shared with any other virtual machine.
	Unshared int64 `xml:"unshared" json:"unshared"`
	// Time when values in this structure were last updated.
	Timestamp time.Time `xml:"timestamp" json:"timestamp"`
}

func init() {
	t["VirtualMachineStorageSummary"] = reflect.TypeOf((*VirtualMachineStorageSummary)(nil)).Elem()
}

// The summary data object type encapsulates a typical set of virtual machine
// information that is useful for list views and summary pages.
//
// VirtualCenter can retrieve this information very efficiently,
// even for large sets of virtual machines.
type VirtualMachineSummary struct {
	DynamicData

	// Reference to the virtual machine managed object.
	//
	// Refers instance of `VirtualMachine`.
	Vm *ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
	// Runtime and state information of a running virtual machine.
	//
	// Most of this information is also available when a virtual machine is powered off.
	// In that case, it contains information from the last run, if available.
	Runtime VirtualMachineRuntimeInfo `xml:"runtime" json:"runtime"`
	// Guest operating system and VMware Tools information.
	//
	// See `VirtualMachine.guest` for more information.
	Guest *VirtualMachineGuestSummary `xml:"guest,omitempty" json:"guest,omitempty"`
	// Basic configuration information about the virtual machine.
	//
	// This information
	// is not available when the virtual machine is unavailable, for instance, when
	// it is being created or deleted.
	Config VirtualMachineConfigSummary `xml:"config" json:"config"`
	// Storage information of the virtual machine.
	//
	// It can be explicitly refreshed
	// with the `VirtualMachine.RefreshStorageInfo` operation.
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	Storage *VirtualMachineStorageSummary `xml:"storage,omitempty" json:"storage,omitempty"`
	// A set of statistics that are typically updated with near real-time regularity.
	//
	// This data object type does not support notification, for scalability reasons.
	// Therefore, changes in QuickStats do not generate property collector updates. To
	// monitor statistics values, use the statistics and alarms modules instead.
	QuickStats VirtualMachineQuickStats `xml:"quickStats" json:"quickStats"`
	// Overall alarm status on this node.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	OverallStatus ManagedEntityStatus `xml:"overallStatus" json:"overallStatus"`
	// Custom field values.
	CustomValue []BaseCustomFieldValue `xml:"customValue,omitempty,typeattr" json:"customValue,omitempty"`
}

func init() {
	t["VirtualMachineSummary"] = reflect.TypeOf((*VirtualMachineSummary)(nil)).Elem()
}

// The TargetInfo specified a value that can be used in the device backings to
// connect the virtual machine to a physical (or logical) host device.
type VirtualMachineTargetInfo struct {
	DynamicData

	// The identification of the endpoint on the host.
	//
	// The format of this depends
	// on the kind of virtual device this endpoints is used for. For example,
	// for a VirtualEthernetCard this would be a networkname, and for a VirtualCDROM
	// it would be a device name.
	Name string `xml:"name" json:"name"`
	// List of configurations that this device is available for.
	//
	// This is only filled
	// out if more than one configuration is requested.
	ConfigurationTag []string `xml:"configurationTag,omitempty" json:"configurationTag,omitempty"`
}

func init() {
	t["VirtualMachineTargetInfo"] = reflect.TypeOf((*VirtualMachineTargetInfo)(nil)).Elem()
}

// This data object contains the information needed to establish a
// connection to a running virtual machine.
type VirtualMachineTicket struct {
	DynamicData

	// The ticket name.
	//
	// This is used as the username and password for the MKS
	// connection.
	Ticket string `xml:"ticket" json:"ticket"`
	// The name of the configuration file for the virtual machine.
	CfgFile string `xml:"cfgFile" json:"cfgFile"`
	// The host with which to establish a connection.
	//
	// If the host is not specified,
	// it is assumed that the requesting entity knows the appropriate host with which
	// to connect.
	Host string `xml:"host,omitempty" json:"host,omitempty"`
	// The port number to use.
	//
	// If the port is not specified,
	// it is assumed that the requesting entity knows the appropriate port to
	// use when making a new connection.
	Port int32 `xml:"port,omitempty" json:"port,omitempty"`
	// The expected SHA1 thumbprint of the SSL cert of the host to which we
	// are connecting.
	//
	// This field can be enabled or disabled on the host.
	SslThumbprint string `xml:"sslThumbprint,omitempty" json:"sslThumbprint,omitempty"`
	// List of expected thumbprints of the certificate of the host to
	// which we are connecting.
	//
	// The list can be configured on the host
	// to include only certain hash types. The default configuration
	// includes all hash types that are considered secure. See vmware.com
	// for the current security standards.
	CertThumbprintList []VirtualMachineCertThumbprint `xml:"certThumbprintList,omitempty" json:"certThumbprintList,omitempty" vim:"7.0.3.1"`
	// Websocket URL.
	//
	// Some tickets are "websocket" tickets and are best expressed
	// as a URL.
	Url string `xml:"url,omitempty" json:"url,omitempty"`
}

func init() {
	t["VirtualMachineTicket"] = reflect.TypeOf((*VirtualMachineTicket)(nil)).Elem()
}

// Storage space used by this virtual machine on a particular datastore.
type VirtualMachineUsageOnDatastore struct {
	DynamicData

	// Reference to datastore for which information is being provided.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// Storage space, in bytes, on this datastore that is actually being used by
	// the virtual machine.
	//
	// It includes space actually occupied by disks, logs, snapshots,
	// configuration files etc. Files of the virtual machine which are present
	// on a different datastore (e.g. a virtual disk on another datastore) are not
	// included here. `VirtualMachineFileLayoutEx` provides a detailed
	// break-up of the committed space.
	Committed int64 `xml:"committed" json:"committed"`
	// Additional storage space, in bytes, potentially used by the virtual machine
	// on this datastore.
	//
	// Additional space may be needed for example when lazily allocated disks grow,
	// or storage for swap is allocated when powering on the virtual machine.
	//
	// If the virtual machine is running off delta disks (for example because
	// a snapshot was taken), then only the potential growth of the currently
	// used delta-disks is considered.
	Uncommitted int64 `xml:"uncommitted" json:"uncommitted"`
	// Storage space, in bytes, occupied by the virtual machine on this datastore
	// that is not shared with any other virtual machine.
	Unshared int64 `xml:"unshared" json:"unshared"`
}

func init() {
	t["VirtualMachineUsageOnDatastore"] = reflect.TypeOf((*VirtualMachineUsageOnDatastore)(nil)).Elem()
}

// This data object contains information about a physical USB device
// on the host.
type VirtualMachineUsbInfo struct {
	VirtualMachineTargetInfo

	// A user visible name of the USB device.
	Description string `xml:"description" json:"description"`
	// The vendor ID of the USB device.
	Vendor int32 `xml:"vendor" json:"vendor"`
	// The product ID of the USB device.
	Product int32 `xml:"product" json:"product"`
	// An autoconnect pattern which describes the device's physical
	// path.
	//
	// This is the path to the specific port on the host where the
	// USB device is attached.
	PhysicalPath string `xml:"physicalPath" json:"physicalPath"`
	// The device class families.
	//
	// For possible values see
	// `VirtualMachineUsbInfoFamily_enum`
	Family []string `xml:"family,omitempty" json:"family,omitempty"`
	// The possible device speeds detected by server.
	//
	// For possible values see
	// `VirtualMachineUsbInfoSpeed_enum`
	Speed []string `xml:"speed,omitempty" json:"speed,omitempty"`
	// Summary information about the virtual machine that is currently
	// using this device, if any.
	Summary *VirtualMachineSummary `xml:"summary,omitempty" json:"summary,omitempty"`
}

func init() {
	t["VirtualMachineUsbInfo"] = reflect.TypeOf((*VirtualMachineUsbInfo)(nil)).Elem()
}

// VFlashModuleInfo class contains information about a vFlash module
// on the host.
type VirtualMachineVFlashModuleInfo struct {
	VirtualMachineTargetInfo

	// Information about the vFlash module
	VFlashModule HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption `xml:"vFlashModule" json:"vFlashModule"`
}

func init() {
	t["VirtualMachineVFlashModuleInfo"] = reflect.TypeOf((*VirtualMachineVFlashModuleInfo)(nil)).Elem()
}

// The `VirtualMachineVMCIDevice` data object represents
// a virtual communication device that supports the VMCI
// (Virtual Machine Communication Interface).
//
// Each virtual machine has a VMCI device that handles
// interprocess socket-based communication.
// VMCI device information is available in the virtual machine
// hardware device list
// (`VirtualMachine*.*VirtualMachine.config*.*VirtualMachineConfigInfo.hardware*.*VirtualHardware.device`\[\]).
//
// An application running on a virtual machine uses the VMCI Sockets API
// for communication with other virtual machines on the same host
// (communication between virtual machines is not supported on vSphere
// 5.1 and later platforms as described for
// VirtualVMCIDevice.`VirtualMachineVMCIDevice.allowUnrestrictedCommunication`),
// or for communication with the host.
// For information about using the vSphere VMCI Sockets API,
// see the _VMCI Sockets Programming Guide_.
type VirtualMachineVMCIDevice struct {
	VirtualDevice

	// Unique identifier for VMCI socket access to this virtual machine.
	//
	// Use this value to identify this virtual machine in calls to the
	// VMCI Sockets API. Applications running on other virtual machines on this
	// host will use this value to connect to this virtual machine.
	// You can cast this value to a 32-bit unsigned integer.
	//
	// The vSphere Server sets this value when a virtual machine
	// powers on. The Server may change this value after power
	// operations such as vMotion or restoring a virtual machine
	// from a snapshot. If you have saved a VMCI device identifier,
	// check to see if the value is still valid after power
	// operations.
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`
	// Deprecated as of vSphere API 5.1. On vSphere 5.1 and later
	// platforms, the VMCI device does not support communication with
	// other virtual machines. Therefore, this property has no effect
	// on these platforms.
	//
	// Determines the extent of VMCI communication with this virtual
	// machine.
	//
	// Set this property to true to allow VMCI communication
	// with all virtual machines on the host and with trusted services.
	// Set this property to false to allow VMCI communication only
	// with trusted services such as the hypervisor on the host.
	//
	// If unset, communication is restricted to trusted services only.
	AllowUnrestrictedCommunication *bool `xml:"allowUnrestrictedCommunication" json:"allowUnrestrictedCommunication,omitempty"`
	// Determines if filtering of VMCI communication is enabled for this virtual
	// machine.
	//
	// Set this property to enable or disable filter rules as specified
	// in `VirtualMachineVMCIDevice.filterInfo`.
	FilterEnable *bool `xml:"filterEnable" json:"filterEnable,omitempty"`
	// Specify a `VirtualMachineVMCIDeviceFilterInfo` data object that controls the extent of
	// VMCI communication with this virtual machine.
	FilterInfo *VirtualMachineVMCIDeviceFilterInfo `xml:"filterInfo,omitempty" json:"filterInfo,omitempty"`
}

func init() {
	t["VirtualMachineVMCIDevice"] = reflect.TypeOf((*VirtualMachineVMCIDevice)(nil)).Elem()
}

// The `VirtualMachineVMCIDeviceFilterInfo` data object contains an array of filters.
//
// To
// clear all existing filters, leave filters unset or specify an empty
// array.
type VirtualMachineVMCIDeviceFilterInfo struct {
	DynamicData

	Filters []VirtualMachineVMCIDeviceFilterSpec `xml:"filters,omitempty" json:"filters,omitempty"`
}

func init() {
	t["VirtualMachineVMCIDeviceFilterInfo"] = reflect.TypeOf((*VirtualMachineVMCIDeviceFilterInfo)(nil)).Elem()
}

// The `VirtualMachineVMCIDeviceFilterSpec` data object describes a filter based on protocol,
// direction and port or port-range.
type VirtualMachineVMCIDeviceFilterSpec struct {
	DynamicData

	// Long value representing filter rank.
	//
	// This is the rank of this filter. Filters are guaranteed to be
	// processed in ascending rank order, that is, if rank1 &lt; rank2, then
	// rank1 is processed before rank2. The ranks within an array of
	// filters should be unique.
	Rank int64 `xml:"rank" json:"rank"`
	// String value from `VirtualMachineVMCIDeviceAction_enum` enum object.
	Action string `xml:"action" json:"action"`
	// String value from `VirtualMachineVMCIDeviceProtocol_enum` enum object
	Protocol string `xml:"protocol" json:"protocol"`
	// String value from `VirtualMachineVMCIDeviceDirection_enum` enum object.
	Direction string `xml:"direction" json:"direction"`
	// Long value representing the lower destination port boundary.
	//
	// If unset, the lower destination port boundary is default to the
	// lowest port number supported by the given protocol.
	//
	// To specify a single port, both lowerDstPortBoundary and
	// upperDstPortBoundary shall be set to the same value.
	LowerDstPortBoundary int64 `xml:"lowerDstPortBoundary,omitempty" json:"lowerDstPortBoundary,omitempty"`
	// Long value representing the upper destination port range.
	//
	// If unset, the upper destination port boundary is default to the
	// highest port number supported by the given protocol.
	//
	// To specify a single port, both lowerDstPortBoundary and
	// upperDstPortBoundary shall be set to the same value.
	UpperDstPortBoundary int64 `xml:"upperDstPortBoundary,omitempty" json:"upperDstPortBoundary,omitempty"`
}

func init() {
	t["VirtualMachineVMCIDeviceFilterSpec"] = reflect.TypeOf((*VirtualMachineVMCIDeviceFilterSpec)(nil)).Elem()
}

// The `VirtualMachineVMCIDeviceOption` data object contains the options
// for the virtual VMCI device (`VirtualMachineVMCIDevice`).
type VirtualMachineVMCIDeviceOption struct {
	VirtualDeviceOption

	// Indicates support for VMCI communication and specifies the default
	// operation.
	//
	// If `BoolOption.defaultValue` is set to true,
	// the virtual machine can participate in VMCI communication with all other
	// virtual machines on the host. Otherwise, VMCI communication will be
	// restricted to trusted services such as the hypervisor on the host.
	// On vSphere 5.1 and later platforms, the VMCI device does not support
	// communication with other virtual machines. Therefore, this property has
	// no effect on these platforms.
	AllowUnrestrictedCommunication BoolOption `xml:"allowUnrestrictedCommunication" json:"allowUnrestrictedCommunication"`
	// Filter specification options.
	FilterSpecOption *VirtualMachineVMCIDeviceOptionFilterSpecOption `xml:"filterSpecOption,omitempty" json:"filterSpecOption,omitempty"`
	// Indicates support for VMCI firewall filters and specifies the default
	// operation.
	//
	// If `BoolOption.supported` is set to true,
	// then firewall filtering can be used for this virtual machine to allow
	// or deny traffic over VMCI.
	FilterSupported *BoolOption `xml:"filterSupported,omitempty" json:"filterSupported,omitempty"`
}

func init() {
	t["VirtualMachineVMCIDeviceOption"] = reflect.TypeOf((*VirtualMachineVMCIDeviceOption)(nil)).Elem()
}

// Filter specification options.
//
// Indicates options for each filter
// specification, as defined by
// `VirtualMachineVMCIDeviceFilterSpec`.
type VirtualMachineVMCIDeviceOptionFilterSpecOption struct {
	DynamicData

	// Available actions.
	Action ChoiceOption `xml:"action" json:"action"`
	// Available protocols.
	Protocol ChoiceOption `xml:"protocol" json:"protocol"`
	// Available directions.
	Direction ChoiceOption `xml:"direction" json:"direction"`
	// Minimum, maximum and default values for lower destination port
	// boundary.
	LowerDstPortBoundary LongOption `xml:"lowerDstPortBoundary" json:"lowerDstPortBoundary"`
	// Minimum, maximum and default values for upper destination port
	// boundary.
	UpperDstPortBoundary LongOption `xml:"upperDstPortBoundary" json:"upperDstPortBoundary"`
}

func init() {
	t["VirtualMachineVMCIDeviceOptionFilterSpecOption"] = reflect.TypeOf((*VirtualMachineVMCIDeviceOptionFilterSpecOption)(nil)).Elem()
}

// Deprecated as of vSphere API 6.0. On vSphere 6.0 and later
// platforms, the VMIROM device does not provide any functionality.
//
// The VirtualVMIROM data object type represents the ROM on the
// virtual machine's PCI bus that provides support for VMI.
type VirtualMachineVMIROM struct {
	VirtualDevice
}

func init() {
	t["VirtualMachineVMIROM"] = reflect.TypeOf((*VirtualMachineVMIROM)(nil)).Elem()
}

// Description of VMotion Stun Time.
type VirtualMachineVMotionStunTimeInfo struct {
	VirtualMachineTargetInfo

	// Migration bandwidth in Mbps
	MigrationBW int64 `xml:"migrationBW" json:"migrationBW"`
	// Stun Time in seconds
	StunTime int64 `xml:"stunTime" json:"stunTime"`
}

func init() {
	t["VirtualMachineVMotionStunTimeInfo"] = reflect.TypeOf((*VirtualMachineVMotionStunTimeInfo)(nil)).Elem()
	minAPIVersionForType["VirtualMachineVMotionStunTimeInfo"] = "8.0.2.0"
}

// Vcpu configuration.
type VirtualMachineVcpuConfig struct {
	DynamicData

	// Latency sensitivity specification for this vcpu.
	//
	// The latency sensitivity can be configured per-vcpu only when the VM
	// `latencySensitivity` is
	// configured to `high`
	// in the same ConfigSpec.
	// Setting `latencySensitivity`,
	// but not setting the vcpu's LatencySensitivity would apply the VM's
	// latency sensitivity level to all the vcpus of the VM.
	// The latency sensitivity of the vcpu should not exceed the
	// latency sensivity level of the VM.
	// The only allowed levels for vcpu Latency sensitivity
	// are `high` or
	// `normal`
	LatencySensitivity *LatencySensitivity `xml:"latencySensitivity,omitempty" json:"latencySensitivity,omitempty"`
}

func init() {
	t["VirtualMachineVcpuConfig"] = reflect.TypeOf((*VirtualMachineVcpuConfig)(nil)).Elem()
}

// Description of a PCI vendor device group device.
type VirtualMachineVendorDeviceGroupInfo struct {
	VirtualMachineTargetInfo

	// Name of Vendor Device Group.
	DeviceGroupName string `xml:"deviceGroupName" json:"deviceGroupName"`
	// Description of Vendor Device Group.
	DeviceGroupDescription string `xml:"deviceGroupDescription,omitempty" json:"deviceGroupDescription,omitempty"`
	// Array describing component devices of this Vendor Device Group.
	//
	// There is one entry per componentDevice in the deviceGroupSpec.
	ComponentDeviceInfo []VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo `xml:"componentDeviceInfo,omitempty" json:"componentDeviceInfo,omitempty"`
}

func init() {
	t["VirtualMachineVendorDeviceGroupInfo"] = reflect.TypeOf((*VirtualMachineVendorDeviceGroupInfo)(nil)).Elem()
	minAPIVersionForType["VirtualMachineVendorDeviceGroupInfo"] = "8.0.0.1"
}

// Class describing a component device within this vendor device group.
type VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo struct {
	DynamicData

	// Type of this component.
	//
	// See `VirtualMachineVendorDeviceGroupInfoComponentDeviceInfoComponentType_enum` for supported types.
	Type string `xml:"type" json:"type"`
	// Name of component device vendor.
	VendorName string `xml:"vendorName" json:"vendorName"`
	// Name of component device.
	DeviceName string `xml:"deviceName" json:"deviceName"`
	// True if this device may be configured by user or UI.
	IsConfigurable bool `xml:"isConfigurable" json:"isConfigurable"`
	// VirtualDevice template for this device.
	Device BaseVirtualDevice `xml:"device,typeattr" json:"device"`
}

func init() {
	t["VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo"] = reflect.TypeOf((*VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo)(nil)).Elem()
	minAPIVersionForType["VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo"] = "8.0.0.1"
}

// Description of PCI vGPU device and its capabilities.
type VirtualMachineVgpuDeviceInfo struct {
	VirtualMachineTargetInfo

	// The vGPU device name.
	DeviceName string `xml:"deviceName" json:"deviceName"`
	// A well-known unique identifier for the device.
	//
	// It concatenates the
	// 16-bit PCI vendor id in lower bits followed by 16-bit PCI device id.
	DeviceVendorId int64 `xml:"deviceVendorId" json:"deviceVendorId"`
	// The maximum framebuffer size in gibibytes.
	MaxFbSizeInGib int64 `xml:"maxFbSizeInGib" json:"maxFbSizeInGib"`
	// Indicate whether device is time-sliced capable.
	TimeSlicedCapable bool `xml:"timeSlicedCapable" json:"timeSlicedCapable"`
	// Indicate whether device is Multiple Instance GPU capable.
	MigCapable bool `xml:"migCapable" json:"migCapable"`
	// Indicate whether device is compute profile capable.
	ComputeProfileCapable bool `xml:"computeProfileCapable" json:"computeProfileCapable"`
	// Indicate whether device is quadro profile capable.
	QuadroProfileCapable bool `xml:"quadroProfileCapable" json:"quadroProfileCapable"`
}

func init() {
	t["VirtualMachineVgpuDeviceInfo"] = reflect.TypeOf((*VirtualMachineVgpuDeviceInfo)(nil)).Elem()
	minAPIVersionForType["VirtualMachineVgpuDeviceInfo"] = "7.0.3.0"
}

// Description of PCI vGPU profile and its attributes.
type VirtualMachineVgpuProfileInfo struct {
	VirtualMachineTargetInfo

	// The vGPU profile name.
	ProfileName string `xml:"profileName" json:"profileName"`
	// A well-known unique identifier for the device that supports this
	// profile.
	//
	// It concatenates the 16-bit PCI vendor id in lower bits
	// followed by 16-bit PCI device id.
	DeviceVendorId int64 `xml:"deviceVendorId" json:"deviceVendorId"`
	// The profile framebuffer size in gibibytes.
	FbSizeInGib int64 `xml:"fbSizeInGib" json:"fbSizeInGib"`
	// Indicate how this profile is shared within device.
	ProfileSharing string `xml:"profileSharing" json:"profileSharing"`
	// Indicate class for this profile.
	ProfileClass string `xml:"profileClass" json:"profileClass"`
	// VMotion stun time information for this profile.
	StunTimeEstimates []VirtualMachineVMotionStunTimeInfo `xml:"stunTimeEstimates,omitempty" json:"stunTimeEstimates,omitempty" vim:"8.0.2.0"`
}

func init() {
	t["VirtualMachineVgpuProfileInfo"] = reflect.TypeOf((*VirtualMachineVgpuProfileInfo)(nil)).Elem()
	minAPIVersionForType["VirtualMachineVgpuProfileInfo"] = "7.0.3.0"
}

// The VirtualVideoCard data object type represents a video card in
// a virtual machine.
type VirtualMachineVideoCard struct {
	VirtualDevice

	// The size of the framebuffer for a virtual machine.
	VideoRamSizeInKB int64 `xml:"videoRamSizeInKB,omitempty" json:"videoRamSizeInKB,omitempty"`
	// Indicates the number of supported monitors.
	//
	// The number of displays X the maximum resolution of each display is
	// bounded by the video RAM size of the virtual video card.
	// This property can only be updated when the virtual machine is
	// powered off.
	NumDisplays int32 `xml:"numDisplays,omitempty" json:"numDisplays,omitempty"`
	// Flag to indicate whether the display settings of the host on which the
	// virtual machine is running should be used to automatically determine
	// the display settings of the virtual machine's video card.
	//
	// This setting takes effect at virtual machine power-on time. If this
	// value is set to TRUE, numDisplays will be ignored.
	UseAutoDetect *bool `xml:"useAutoDetect" json:"useAutoDetect,omitempty"`
	// Flag to indicate whether the virtual video card supports 3D functions.
	//
	// This property can only be updated when the virtual machine is powered
	// off.
	Enable3DSupport *bool `xml:"enable3DSupport" json:"enable3DSupport,omitempty"`
	// Indicate how the virtual video device renders 3D graphics.
	//
	// The virtual video device can use hardware acceleration and software
	// rendering. By default, VMware products determine whether or not to
	// use hardware acceleration based on the availability of physical graphics
	// devices. Certain workloads can benefit from explicitly specifying if
	// hardware acceleration is required. For example, 3D intensive workloads
	// may indicate to run on systems with graphics hardware.
	//
	// There are three settings.
	//
	// (automatic) - The virtual device chooses how to render 3D graphics (default).
	// (software) - The virtual device will use software rendering and
	// will not attempt to use hardware acceleration.
	// (hardware) - The virtual device will use hardware acceleration and
	// will not activate without it.
	Use3dRenderer string `xml:"use3dRenderer,omitempty" json:"use3dRenderer,omitempty"`
	// The size of graphics memory.
	//
	// If 3d support is enabled this setting gives the amount of guest memory
	// used for graphics resources.
	// This property can only be updated when the virtual machine is
	// powered off.
	GraphicsMemorySizeInKB int64 `xml:"graphicsMemorySizeInKB,omitempty" json:"graphicsMemorySizeInKB,omitempty"`
}

func init() {
	t["VirtualMachineVideoCard"] = reflect.TypeOf((*VirtualMachineVideoCard)(nil)).Elem()
}

// The VirtualDeviceGroups data object
// type contains information about the backing that maps the
// virtual device onto a physical device for a Vendor Device Group device.
//
// Vendor Device Groups allow third-parties to define collections of
// devices that must be allocated to a virtual machine as a unit.
// Typically, this is because the set of devices are related in
// a some way, e.g. a physical link connects the devices.
type VirtualMachineVirtualDeviceGroups struct {
	DynamicData

	// Information about device groups used by this VM.
	//
	// When adding a group, all devices that form the group
	// must be added in the same request.
	// When removing group, also all devices participating
	// in the group must be removed.
	// Modifying existing device group membership is not allowed.
	DeviceGroup []BaseVirtualMachineVirtualDeviceGroupsDeviceGroup `xml:"deviceGroup,omitempty,typeattr" json:"deviceGroup,omitempty"`
}

func init() {
	t["VirtualMachineVirtualDeviceGroups"] = reflect.TypeOf((*VirtualMachineVirtualDeviceGroups)(nil)).Elem()
	minAPIVersionForType["VirtualMachineVirtualDeviceGroups"] = "8.0.0.1"
}

// Base device group type.
type VirtualMachineVirtualDeviceGroupsDeviceGroup struct {
	DynamicData

	// Group instance key.
	//
	// Unique integer referencing
	// device group. During group creation client should
	// use a temporary negative number. Once group is
	// added to the virtual machine, server generates non-negative
	// integer that stays constant during group lifetime.
	// See `VirtualDevice.key` for details.
	GroupInstanceKey int32 `xml:"groupInstanceKey" json:"groupInstanceKey"`
	// Provides a label and summary information for the device.
	DeviceInfo BaseDescription `xml:"deviceInfo,omitempty,typeattr" json:"deviceInfo,omitempty"`
}

func init() {
	t["VirtualMachineVirtualDeviceGroupsDeviceGroup"] = reflect.TypeOf((*VirtualMachineVirtualDeviceGroupsDeviceGroup)(nil)).Elem()
}

// Vendor device group.
//
// These groups are defined in the
// <code>`VirtualMachineVendorDeviceGroupInfo`</code>.
// When this group is added, all devices that form the group
// must be added in the same request.
// Modification of membership in the group is not allowed,
// devices cannot be added or removed.
// When group is removed, all devices that form the group
// must be removed in the same request.
type VirtualMachineVirtualDeviceGroupsVendorDeviceGroup struct {
	VirtualMachineVirtualDeviceGroupsDeviceGroup

	// The name of the vendor device group from
	// <code>`VirtualMachineVendorDeviceGroupInfo`</code>.
	DeviceGroupName string `xml:"deviceGroupName" json:"deviceGroupName"`
}

func init() {
	t["VirtualMachineVirtualDeviceGroupsVendorDeviceGroup"] = reflect.TypeOf((*VirtualMachineVirtualDeviceGroupsVendorDeviceGroup)(nil)).Elem()
}

// Device Swap: Report current status of device swap feature.
type VirtualMachineVirtualDeviceSwap struct {
	DynamicData

	LsiToPvscsi *VirtualMachineVirtualDeviceSwapDeviceSwapInfo `xml:"lsiToPvscsi,omitempty" json:"lsiToPvscsi,omitempty"`
}

func init() {
	t["VirtualMachineVirtualDeviceSwap"] = reflect.TypeOf((*VirtualMachineVirtualDeviceSwap)(nil)).Elem()
	minAPIVersionForType["VirtualMachineVirtualDeviceSwap"] = "8.0.0.1"
}

// Information for the device swap operation.
type VirtualMachineVirtualDeviceSwapDeviceSwapInfo struct {
	DynamicData

	// Is the swap operation enabled for this virtual machine.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Is the swap operation applicable to this virtual machine?
	// Operation is applicable if it is enabled for the virtual
	// machine, for the host or cluster in which virtual machine
	// resides, operating system supports device swap, and
	// virtual machine has controllers that need to be replaced.
	//
	// This field is read-only and cannot be modified.
	Applicable *bool `xml:"applicable" json:"applicable,omitempty"`
	// Status of the operation.
	//
	// One of
	// `VirtualMachineVirtualDeviceSwapDeviceSwapStatus_enum`
	// This field is read-only and cannot be modified.
	Status string `xml:"status,omitempty" json:"status,omitempty"`
}

func init() {
	t["VirtualMachineVirtualDeviceSwapDeviceSwapInfo"] = reflect.TypeOf((*VirtualMachineVirtualDeviceSwapDeviceSwapInfo)(nil)).Elem()
	minAPIVersionForType["VirtualMachineVirtualDeviceSwapDeviceSwapInfo"] = "8.0.0.1"
}

// This data object describes the virtual NUMA configuration for
// this virtual machine and configured through ConfigSpec.
type VirtualMachineVirtualNuma struct {
	DynamicData

	// Cores per vNUMA node for this VM.
	//
	// The number of vNUMA nodes is
	// calculated by total number of cores divided by corePerNumaNode.
	// If set to be zero, it clears any manual override and autosize
	// vNUMA node.
	// If set to be non zero, VM uses the value as vNUMA node size.
	// If unset, the VM continue to follow the behavior in last poweron.
	CoresPerNumaNode *int32 `xml:"coresPerNumaNode" json:"coresPerNumaNode,omitempty"`
	// Capability to expose virtual NUMA when CPU hotadd is enabled.
	//
	// If set to true, ESXi will consider exposing virtual NUMA to
	// the VM when CPU hotadd is enabled.
	// If set to false, ESXi will enforce the VM to have single
	// virtual NUMA node when CPU hotadd is enabled.
	// If unset, the VM continue to follow the behavior in last poweron.
	ExposeVnumaOnCpuHotadd *bool `xml:"exposeVnumaOnCpuHotadd" json:"exposeVnumaOnCpuHotadd,omitempty"`
}

func init() {
	t["VirtualMachineVirtualNuma"] = reflect.TypeOf((*VirtualMachineVirtualNuma)(nil)).Elem()
	minAPIVersionForType["VirtualMachineVirtualNuma"] = "8.0.0.1"
}

// vNUMA: This is read-only data for ConfigInfo since this portion is
// not configurable.
type VirtualMachineVirtualNumaInfo struct {
	DynamicData

	// Cores per NUMA node.
	//
	// When this virtual machine is powered off and "autoCoresPerNumaNode"
	// is True, coresPerNumaNode will be assigned during power-on and this
	// field should be ignored.
	// In other cases, this field represents the virtual NUMA node size
	// seen by the guest.
	CoresPerNumaNode *int32 `xml:"coresPerNumaNode" json:"coresPerNumaNode,omitempty"`
	// Whether coresPerNode is determined automatically.
	AutoCoresPerNumaNode *bool `xml:"autoCoresPerNumaNode" json:"autoCoresPerNumaNode,omitempty"`
	// Whether virtual NUMA topology is exposed when CPU hotadd is
	// enabled.
	VnumaOnCpuHotaddExposed *bool `xml:"vnumaOnCpuHotaddExposed" json:"vnumaOnCpuHotaddExposed,omitempty"`
}

func init() {
	t["VirtualMachineVirtualNumaInfo"] = reflect.TypeOf((*VirtualMachineVirtualNumaInfo)(nil)).Elem()
	minAPIVersionForType["VirtualMachineVirtualNumaInfo"] = "8.0.0.1"
}

// Virtual Persistent Memory configuration for the VM.
type VirtualMachineVirtualPMem struct {
	DynamicData

	// An enum describing behavior of NVDIMM devices when a VM snapshot is taken
	// and restored.
	//
	// If unset, taking a VM snapshot will fail when the VM is
	// configured with NVDIMMs. See `VirtualMachineVirtualPMemSnapshotMode_enum` for supported values.
	// The snapshot mode applies to all NVDIMMs configured for the VM.
	// Property is currently only applicable to VMs with virtual NVDIMMs and not
	// applicable to vPMem disks.
	// Setting this property will fail if the VM has existing snapshots.
	SnapshotMode string `xml:"snapshotMode,omitempty" json:"snapshotMode,omitempty"`
}

func init() {
	t["VirtualMachineVirtualPMem"] = reflect.TypeOf((*VirtualMachineVirtualPMem)(nil)).Elem()
	minAPIVersionForType["VirtualMachineVirtualPMem"] = "7.0.3.0"
}

// This data object type encapsulates configuration settings
// when creating a virtual machine quiesced snapshot.
type VirtualMachineWindowsQuiesceSpec struct {
	VirtualMachineGuestQuiesceSpec

	// The property to indicate what type of VSS backup operation is going
	// to be performed on the virtual machine.
	//
	// See VSS\_BACKUP\_TYPE on MSDN:
	// https://msdn.microsoft.com/en-us/library/aa384679(v=vs.85).aspx
	VssBackupType int32 `xml:"vssBackupType,omitempty" json:"vssBackupType,omitempty"`
	// The property to indicate if a bootable system state during VSS backup
	// to be performed on the virtual machine.
	VssBootableSystemState *bool `xml:"vssBootableSystemState" json:"vssBootableSystemState,omitempty"`
	// The property to indicate if partial file support is enabled during VSS
	// backup to be performed on the virtual machine.
	VssPartialFileSupport *bool `xml:"vssPartialFileSupport" json:"vssPartialFileSupport,omitempty"`
	// The property to indicate what context of VSS backup operation to be
	// performed on the virtual machine.
	//
	// For the list of supported values,
	// see `VirtualMachineWindowsQuiesceSpecVssBackupContext_enum`
	VssBackupContext string `xml:"vssBackupContext,omitempty" json:"vssBackupContext,omitempty"`
}

func init() {
	t["VirtualMachineWindowsQuiesceSpec"] = reflect.TypeOf((*VirtualMachineWindowsQuiesceSpec)(nil)).Elem()
}

// Data structure used by wipeDisk to return the amount of disk space that
// can be saved on an Flex-SE disk if a subsequent shrinkDisk API is invoked
// on that disk.
type VirtualMachineWipeResult struct {
	DynamicData

	// The disk id for the disk that was wiped.
	DiskId int32 `xml:"diskId" json:"diskId"`
	// The amount of shrinkable disk space in kB.
	ShrinkableDiskSpace int64 `xml:"shrinkableDiskSpace" json:"shrinkableDiskSpace"`
}

func init() {
	t["VirtualMachineWipeResult"] = reflect.TypeOf((*VirtualMachineWipeResult)(nil)).Elem()
}

// The Virtual NVDIMM device.
type VirtualNVDIMM struct {
	VirtualDevice

	// NVDIMM backing size in MiB.
	//
	// If backing is inaccessible, then
	// capacity is reported as 0.
	CapacityInMB int64 `xml:"capacityInMB" json:"capacityInMB"`
	// NVDIMM device's configured size in MiB.
	ConfiguredCapacityInMB int64 `xml:"configuredCapacityInMB,omitempty" json:"configuredCapacityInMB,omitempty" vim:"7.0.2.0"`
}

func init() {
	t["VirtualNVDIMM"] = reflect.TypeOf((*VirtualNVDIMM)(nil)).Elem()
}

// The <code>`VirtualNVDIMMBackingInfo`</code> data object type
// defines information about a resource that backs a device
// in a virtual machine.
type VirtualNVDIMMBackingInfo struct {
	VirtualDeviceFileBackingInfo

	// Parent object in snapshot chain.
	Parent *VirtualNVDIMMBackingInfo `xml:"parent,omitempty" json:"parent,omitempty"`
	// The change ID of the virtual NVDIMM for the corresponding
	// snapshot of virtual machine.
	//
	// This can be used to track
	// incremental changes.
	// See `VirtualMachine.QueryChangedDiskAreas`.
	ChangeId string `xml:"changeId,omitempty" json:"changeId,omitempty"`
}

func init() {
	t["VirtualNVDIMMBackingInfo"] = reflect.TypeOf((*VirtualNVDIMMBackingInfo)(nil)).Elem()
}

// The Virtual NVDIMM controller.
type VirtualNVDIMMController struct {
	VirtualController
}

func init() {
	t["VirtualNVDIMMController"] = reflect.TypeOf((*VirtualNVDIMMController)(nil)).Elem()
}

// VirtualNVDIMMControllerOption is the data object that contains
// the options for a virtual NVDIMM controller.
type VirtualNVDIMMControllerOption struct {
	VirtualControllerOption

	// Minimum, maximum and default number of virtual NVDIMM controllers.
	NumNVDIMMControllers IntOption `xml:"numNVDIMMControllers" json:"numNVDIMMControllers"`
}

func init() {
	t["VirtualNVDIMMControllerOption"] = reflect.TypeOf((*VirtualNVDIMMControllerOption)(nil)).Elem()
}

// The VirtualNVDIMMOption contains information about
// a virtual NVDIMM capacity limits and rules for
// capacity growth operations.
type VirtualNVDIMMOption struct {
	VirtualDeviceOption

	// Minimum and maximum capacity in MB.
	CapacityInMB LongOption `xml:"capacityInMB" json:"capacityInMB"`
	// Option to show if device capacity growth is supported for
	// powered off VMs.
	Growable bool `xml:"growable" json:"growable"`
	// Option to show if device capacity growth is supported for
	// powered on VMs.
	HotGrowable bool `xml:"hotGrowable" json:"hotGrowable"`
	// Option to show capacity growth granularity if growth operation
	// is supported in MB.
	GranularityInMB int64 `xml:"granularityInMB" json:"granularityInMB"`
}

func init() {
	t["VirtualNVDIMMOption"] = reflect.TypeOf((*VirtualNVDIMMOption)(nil)).Elem()
}

// The Virtual NVME controller.
type VirtualNVMEController struct {
	VirtualController

	// Mode for sharing the SCSI bus.
	//
	// The modes are physicalSharing,
	// and noSharing. See the
	// `Sharing`
	// data object type for an explanation of these modes.
	SharedBus string `xml:"sharedBus,omitempty" json:"sharedBus,omitempty" vim:"8.0.2.0"`
}

func init() {
	t["VirtualNVMEController"] = reflect.TypeOf((*VirtualNVMEController)(nil)).Elem()
}

// VirtualNVMEControllerOption is the data object that contains
// the options for a virtual NVME controller.
type VirtualNVMEControllerOption struct {
	VirtualControllerOption

	// Three properties (numNVMEDisks.min, numNVMEDisks.max, and
	// numNVMEDisks.defaultValue) define the minimum, maximum, and default
	// number of NVME VirtualDisk instances available at any given time in the
	// NVME controller.
	//
	// The number of NVME VirtualDisk instances is
	// also limited by the number of available namespaces in the NVME controller.
	NumNVMEDisks IntOption `xml:"numNVMEDisks" json:"numNVMEDisks"`
	// Supported shared bus modes.
	//
	// See `VirtualNVMEControllerSharing_enum` for the list of available modes.
	Sharing []string `xml:"sharing,omitempty" json:"sharing,omitempty" vim:"8.0.2.0"`
}

func init() {
	t["VirtualNVMEControllerOption"] = reflect.TypeOf((*VirtualNVMEControllerOption)(nil)).Elem()
}

// The NetConfig data object type contains the networking
// configuration.
type VirtualNicManagerNetConfig struct {
	DynamicData

	// The NicType of this NetConfig.
	NicType string `xml:"nicType" json:"nicType"`
	// Whether multiple nics can be selected for this nicType.
	MultiSelectAllowed bool `xml:"multiSelectAllowed" json:"multiSelectAllowed"`
	// List of VirtualNic objects that may be used.
	//
	// This will be a subset of the list of VirtualNics in
	// `HostNetworkInfo.vnic`.
	CandidateVnic []HostVirtualNic `xml:"candidateVnic,omitempty" json:"candidateVnic,omitempty"`
	// List of VirtualNic objects that are selected for use.
	SelectedVnic []string `xml:"selectedVnic,omitempty" json:"selectedVnic,omitempty"`
}

func init() {
	t["VirtualNicManagerNetConfig"] = reflect.TypeOf((*VirtualNicManagerNetConfig)(nil)).Elem()
}

// The VirtualPCIController data object type defines a virtual PCI
// controller.
type VirtualPCIController struct {
	VirtualController
}

func init() {
	t["VirtualPCIController"] = reflect.TypeOf((*VirtualPCIController)(nil)).Elem()
}

// This data object type contains the options
// for a virtual PCI Controller.
type VirtualPCIControllerOption struct {
	VirtualControllerOption

	// Defines the minimum, maximum, and
	// default number of VirtualSCSIController instances available
	// at any given time in the PCI controller.
	//
	// The number of
	// VirtualSCSIController instances is also limited by the number of
	// available slots in the PCI controller.
	NumSCSIControllers IntOption `xml:"numSCSIControllers" json:"numSCSIControllers"`
	// Defines the minimum, maximum, and
	// default number of VirtualEthernetCard instances available,
	// at any given time, in the PCI controller.
	//
	// The number of
	// VirtualEthernetCard instances is also limited by the number of
	// available slots in the PCI controller.
	NumEthernetCards IntOption `xml:"numEthernetCards" json:"numEthernetCards"`
	// Defines the minimum, maximum, and default
	// number of VirtualVideoCard instances available,
	// at any given time, in the PCI controller.
	//
	// The number of
	// VirtualVideoCard instances is also limited by the number of
	// available slots in the PCI controller.
	NumVideoCards IntOption `xml:"numVideoCards" json:"numVideoCards"`
	// Defines the minimum, maximum, and default
	// number of VirtualSoundCard instances available,
	// at any given time, in the PCI controller.
	//
	// The number of
	// VirtualSoundCard instances is also limited by the number of
	// available slots in the PCI controller.
	NumSoundCards IntOption `xml:"numSoundCards" json:"numSoundCards"`
	// Defines the minimum, maximum, and default
	// number of VirtualVMIROM instances available,
	// at any given time, in the PCI controller.
	//
	// This is also limited
	// by the number of available slots in the PCI controller.
	NumVmiRoms IntOption `xml:"numVmiRoms" json:"numVmiRoms"`
	// Defines the minimum, maximum, and default
	// number of VirtualVMCIDevice instances available,
	// at any given time, in the PCI controller.
	//
	// This is also limited
	// by the number of available slots in the PCI controller.
	NumVmciDevices *IntOption `xml:"numVmciDevices,omitempty" json:"numVmciDevices,omitempty"`
	// Defines the minimum, maximum, and default
	// number of VirtualPCIPassthrough instances available,
	// at any given time, in the PCI controller.
	//
	// This is also limited
	// by the number of available PCI Express slots in the PCI controller.
	NumPCIPassthroughDevices *IntOption `xml:"numPCIPassthroughDevices,omitempty" json:"numPCIPassthroughDevices,omitempty"`
	// Defines the minimum, maximum, and default
	// number of VirtualLsiLogicSASController instances available,
	// at any given time, in the PCI controller.
	//
	// This is also limited
	// by the number of available PCI Express slots in the PCI controller
	// as well as the total number of supported SCSI controllers.
	NumSasSCSIControllers *IntOption `xml:"numSasSCSIControllers,omitempty" json:"numSasSCSIControllers,omitempty"`
	// Defines the minimum, maximum, and default
	// number of VirtualVmxnet3 ethernet card instances available,
	// at any given time, in the PCI controller.
	//
	// This is also limited
	// by the number of available PCI Express slots in the PCI controller
	// as well as the total number of supported ethernet cards.
	NumVmxnet3EthernetCards *IntOption `xml:"numVmxnet3EthernetCards,omitempty" json:"numVmxnet3EthernetCards,omitempty"`
	// Defines the minimum, maximum, and default
	// number of ParaVirtualScsiController instances available,
	// at any given time, in the PCI controller.
	//
	// This is also limited
	// by the number of available PCI Express slots in the PCI controller
	// as well as the total number of supported SCSI controllers.
	NumParaVirtualSCSIControllers *IntOption `xml:"numParaVirtualSCSIControllers,omitempty" json:"numParaVirtualSCSIControllers,omitempty"`
	// Defines the minimum, maximum, and default
	// number of VirtualSATAController instances available,
	// at any given time, in the PCI controller.
	//
	// This is also limited
	// by the number of available PCI Express slots in the PCI controller
	// as well as the total number of supported SATA controllers.
	NumSATAControllers *IntOption `xml:"numSATAControllers,omitempty" json:"numSATAControllers,omitempty"`
	// Defines the minimum, maximum, and default
	// number of VirtualNVMEController instances available,
	// at any given time, in the PCI controller.
	//
	// This is also limited
	// by the number of available PCI Express slots in the PCI controller
	// as well as the total number of supported NVME controllers.
	NumNVMEControllers *IntOption `xml:"numNVMEControllers,omitempty" json:"numNVMEControllers,omitempty"`
	// Defines the minimum, maximum, and default
	// number of VirtualVmxnet3Vrdma ethernet card instances available,
	// at any given time, in the PCI controller.
	//
	// This is also limited
	// by the number of available PCI Express slots in the PCI controller
	// as well as the total number of supported ethernet cards.
	NumVmxnet3VrdmaEthernetCards *IntOption `xml:"numVmxnet3VrdmaEthernetCards,omitempty" json:"numVmxnet3VrdmaEthernetCards,omitempty"`
}

func init() {
	t["VirtualPCIControllerOption"] = reflect.TypeOf((*VirtualPCIControllerOption)(nil)).Elem()
}

// The VirtualPCIPassthrough data object type contains information about a
// PCI device on the virtual machine that is being backed by
// a generic PCI device on the host via passthrough.
type VirtualPCIPassthrough struct {
	VirtualDevice
}

func init() {
	t["VirtualPCIPassthrough"] = reflect.TypeOf((*VirtualPCIPassthrough)(nil)).Elem()
}

// A tuple of vendorId and deviceId indicating an allowed device
// for a Dynamic DirectPath device.
type VirtualPCIPassthroughAllowedDevice struct {
	DynamicData

	// The vendor ID for this PCI device.
	//
	// You must use the vendor ID
	// retrieved from the vSphere host or cluster.
	VendorId int32 `xml:"vendorId" json:"vendorId"`
	// The device ID of this PCI device.
	//
	// You must use the device ID
	// retrieved from the vSphere host or cluster.
	DeviceId int32 `xml:"deviceId" json:"deviceId"`
	// The subVendor ID for this PCI device.
	//
	// If specified, you must use
	// the subVendor ID retrieved from the vSphere host or cluster.
	// Range of legal values is 0x0 to 0xFFFF.
	SubVendorId int32 `xml:"subVendorId,omitempty" json:"subVendorId,omitempty"`
	// The subDevice ID of this PCI device.
	//
	// If specified, you must use
	// the subDevice ID retrieved from the vSphere host or cluster.
	// Range of legal values is 0x0 to 0xFFFF.
	SubDeviceId int32 `xml:"subDeviceId,omitempty" json:"subDeviceId,omitempty"`
	// The revision ID of this PCI device.
	//
	// If specified, you must use
	// the revision ID retrieved from the vSphere host or cluster.
	// Range of legal values is 0x0 to 0xFF.
	RevisionId int16 `xml:"revisionId,omitempty" json:"revisionId,omitempty"`
}

func init() {
	t["VirtualPCIPassthroughAllowedDevice"] = reflect.TypeOf((*VirtualPCIPassthroughAllowedDevice)(nil)).Elem()
}

// The VirtualPCIPassthrough.DeviceBackingInfo data object type
// contains information about the backing that maps the
// virtual device onto a physical device.
type VirtualPCIPassthroughDeviceBackingInfo struct {
	VirtualDeviceDeviceBackingInfo

	// The name ID of this PCI, composed of "bus:slot.function".
	Id string `xml:"id" json:"id"`
	// The device ID of this PCI.
	//
	// You must use the device ID retrieved
	// from the vSphere host (`HostPciDevice`.deviceId), converted
	// as is to a string.
	DeviceId string `xml:"deviceId" json:"deviceId"`
	// The ID of the system the PCI device is attached to.
	SystemId string `xml:"systemId" json:"systemId"`
	// The vendor ID for this PCI device.
	//
	// You must use the vendor ID retrieved
	// from the vSphere host (`HostPciDevice`.vendorId).
	VendorId int16 `xml:"vendorId" json:"vendorId"`
}

func init() {
	t["VirtualPCIPassthroughDeviceBackingInfo"] = reflect.TypeOf((*VirtualPCIPassthroughDeviceBackingInfo)(nil)).Elem()
}

// This data object type describes the options for the
// `VirtualPCIPassthroughDeviceBackingInfo` data object type.
type VirtualPCIPassthroughDeviceBackingOption struct {
	VirtualDeviceDeviceBackingOption
}

func init() {
	t["VirtualPCIPassthroughDeviceBackingOption"] = reflect.TypeOf((*VirtualPCIPassthroughDeviceBackingOption)(nil)).Elem()
}

// DVX Device specific information.
type VirtualPCIPassthroughDvxBackingInfo struct {
	VirtualDeviceBackingInfo

	// The device class that backs this DVX device.
	//
	// During add operations, this value must be a non-empty string.
	// During edit operations, if this value is not set or is an empty
	// string, the current device class remains unchanged.
	DeviceClass string `xml:"deviceClass,omitempty" json:"deviceClass,omitempty"`
	// The configuration parameters for this device class.
	//
	// All required configuration parameters must be provided for both add
	// and edit operations. The provided configuration parameters replace
	// the previous ones. In particular, passing an empty array will unset
	// all existing configuration parameters.
	ConfigParams []BaseOptionValue `xml:"configParams,omitempty,typeattr" json:"configParams,omitempty"`
}

func init() {
	t["VirtualPCIPassthroughDvxBackingInfo"] = reflect.TypeOf((*VirtualPCIPassthroughDvxBackingInfo)(nil)).Elem()
	minAPIVersionForType["VirtualPCIPassthroughDvxBackingInfo"] = "8.0.0.1"
}

// Describes the options for
// `VirtualPCIPassthroughDvxBackingInfo`.
type VirtualPCIPassthroughDvxBackingOption struct {
	VirtualDeviceBackingOption
}

func init() {
	t["VirtualPCIPassthroughDvxBackingOption"] = reflect.TypeOf((*VirtualPCIPassthroughDvxBackingOption)(nil)).Elem()
	minAPIVersionForType["VirtualPCIPassthroughDvxBackingOption"] = "8.0.0.1"
}

// The VirtualPCIPassthrough.DynamicBackingInfo data object type
// contains information about the backing that maps the
// virtual device onto a physical device for a Dynamic DirectPath
// device.
type VirtualPCIPassthroughDynamicBackingInfo struct {
	VirtualDeviceDeviceBackingInfo

	// The list of allowed devices for use with a Dynamic DirectPath
	// device.
	AllowedDevice []VirtualPCIPassthroughAllowedDevice `xml:"allowedDevice,omitempty" json:"allowedDevice,omitempty"`
	// An optional label.
	//
	// If set, the device must also have the same
	// customLabel attribute set.
	CustomLabel string `xml:"customLabel,omitempty" json:"customLabel,omitempty"`
	// The id of the device assigned when the VM is powered on.
	//
	// This value
	// is unset when the VM is powered off.
	AssignedId string `xml:"assignedId,omitempty" json:"assignedId,omitempty"`
}

func init() {
	t["VirtualPCIPassthroughDynamicBackingInfo"] = reflect.TypeOf((*VirtualPCIPassthroughDynamicBackingInfo)(nil)).Elem()
}

// This data object type describes the options for the
// `VirtualPCIPassthroughDynamicBackingInfo` data object type.
type VirtualPCIPassthroughDynamicBackingOption struct {
	VirtualDeviceDeviceBackingOption
}

func init() {
	t["VirtualPCIPassthroughDynamicBackingOption"] = reflect.TypeOf((*VirtualPCIPassthroughDynamicBackingOption)(nil)).Elem()
}

// The VirtualPCIPassthroughOption data object type describes the options
// for the
// `VirtualPCIPassthrough`
// data object type.
type VirtualPCIPassthroughOption struct {
	VirtualDeviceOption
}

func init() {
	t["VirtualPCIPassthroughOption"] = reflect.TypeOf((*VirtualPCIPassthroughOption)(nil)).Elem()
}

// The VirtualPCIPassthrough.PluginBackingInfo is a base data object type
// for encoding plugin-specific information.
//
// This base type does not define
// any properties. Specific plugin types are represented by subtypes which
// define properties for subtype-specific backing information.
type VirtualPCIPassthroughPluginBackingInfo struct {
	VirtualDeviceBackingInfo
}

func init() {
	t["VirtualPCIPassthroughPluginBackingInfo"] = reflect.TypeOf((*VirtualPCIPassthroughPluginBackingInfo)(nil)).Elem()
}

// This data object type describes the options for the
// `VirtualPCIPassthroughPluginBackingInfo` data object type.
type VirtualPCIPassthroughPluginBackingOption struct {
	VirtualDeviceBackingOption
}

func init() {
	t["VirtualPCIPassthroughPluginBackingOption"] = reflect.TypeOf((*VirtualPCIPassthroughPluginBackingOption)(nil)).Elem()
}

// The VirtualPCIPassthrough.VmiopBackingInfo data object type
// contains information about the plugin that emulates the
// virtual device via the VMIOP plugin interface.
//
// At present, this interface is only used to implement vGPU.
type VirtualPCIPassthroughVmiopBackingInfo struct {
	VirtualPCIPassthroughPluginBackingInfo

	// The vGPU configuration type exposed by a VMIOP plugin.
	Vgpu string `xml:"vgpu,omitempty" json:"vgpu,omitempty"`
	// The expected size of the vGPU device state during migration.
	VgpuMigrateDataSizeMB int32 `xml:"vgpuMigrateDataSizeMB,omitempty" json:"vgpuMigrateDataSizeMB,omitempty" vim:"8.0.0.1"`
	// Indicates whether the vGPU device is migration capable or not.
	MigrateSupported *bool `xml:"migrateSupported" json:"migrateSupported,omitempty" vim:"7.0.2.0"`
	// Indicates whether the vGPU has enhanced migration features for
	// sub-second downtime.
	EnhancedMigrateCapability *bool `xml:"enhancedMigrateCapability" json:"enhancedMigrateCapability,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VirtualPCIPassthroughVmiopBackingInfo"] = reflect.TypeOf((*VirtualPCIPassthroughVmiopBackingInfo)(nil)).Elem()
}

// This data object type describes the options for the
// `VirtualPCIPassthroughVmiopBackingInfo` data object type.
type VirtualPCIPassthroughVmiopBackingOption struct {
	VirtualPCIPassthroughPluginBackingOption

	// Parameter indicating which GPU profile the plugin should emulate.
	//
	// See also `ConfigTarget.sharedGpuPassthroughTypes`.
	Vgpu StringOption `xml:"vgpu" json:"vgpu"`
	// Maximum number of instances of this backing type allowed
	// per virtual machine.
	//
	// This is a parameter of the plugin
	// itself, which may support only a limited number of
	// instances per virtual machine.
	MaxInstances int32 `xml:"maxInstances" json:"maxInstances"`
}

func init() {
	t["VirtualPCIPassthroughVmiopBackingOption"] = reflect.TypeOf((*VirtualPCIPassthroughVmiopBackingOption)(nil)).Elem()
}

// This data object type defines the properties
// of an AMD Lance PCNet32 Ethernet card attached to a virtual machine.
type VirtualPCNet32 struct {
	VirtualEthernetCard
}

func init() {
	t["VirtualPCNet32"] = reflect.TypeOf((*VirtualPCNet32)(nil)).Elem()
}

// The VirtualPCNet32Option data object type defines the options for the
// VirtualPCNet32 data object type.
//
// Except for the boolean
// supportsMorphing option, the options are inherited from the
// `VirtualEthernetCardOption` data
// object type.
type VirtualPCNet32Option struct {
	VirtualEthernetCardOption

	// Indicates that this Ethernet card supports morphing into vmxnet when
	// appropriate.
	//
	// This means that, if supportsMorphing="true", the virtual
	// AMD Lance PCNet32 Ethernet card becomes a vmxnet Ethernet card
	// with its added performance capabilities when appropriate.
	SupportsMorphing bool `xml:"supportsMorphing" json:"supportsMorphing"`
}

func init() {
	t["VirtualPCNet32Option"] = reflect.TypeOf((*VirtualPCNet32Option)(nil)).Elem()
}

// The VirtualPS2Controller data object type represents a controller
// for keyboards and mice.
type VirtualPS2Controller struct {
	VirtualController
}

func init() {
	t["VirtualPS2Controller"] = reflect.TypeOf((*VirtualPS2Controller)(nil)).Elem()
}

// The VirtualPS2ControllerOption data object type contains the options
// for a virtual PS/2 controller for keyboards and mice.
//
// In addition to
// the options defined in the `VirtualControllerOption` data object type, these options include the
// number of keyboards and mice.
type VirtualPS2ControllerOption struct {
	VirtualControllerOption

	// The minimum, maximum, and default number of keyboards you can
	// have at any given time.
	//
	// This is further constrained by the number
	// of available slots in the PS/2 controller. The minimum, maximum,
	// and default are integers defined by three properties:
	//   - `*numKeyBoards.min*`: the minimum.
	//   - `*numKeyBoards.max*`: the maximum.
	//   - `*numKeyBoards.defaultValue*`: the default number.
	NumKeyboards IntOption `xml:"numKeyboards" json:"numKeyboards"`
	// The minimum, maximum, and default number of mice you can
	// have at any given time.
	//
	// The number of mice is also limited by the number
	// of available slots in the PS/2 controller. The minimum, maximum, and
	// default are integers defined by three properties:
	//   - `*numPointingDevices.min*`: the minimum.
	//   - `*numPointingDevices.max*`: the maximum.
	//   - `*numPointingDevices.defaultValue*`: the default number.
	NumPointingDevices IntOption `xml:"numPointingDevices" json:"numPointingDevices"`
}

func init() {
	t["VirtualPS2ControllerOption"] = reflect.TypeOf((*VirtualPS2ControllerOption)(nil)).Elem()
}

// This data object type represents a parallel port
// in a virtual machine.
type VirtualParallelPort struct {
	VirtualDevice
}

func init() {
	t["VirtualParallelPort"] = reflect.TypeOf((*VirtualParallelPort)(nil)).Elem()
}

// The data object type for a device backing of a virtual parallel port.
type VirtualParallelPortDeviceBackingInfo struct {
	VirtualDeviceDeviceBackingInfo
}

func init() {
	t["VirtualParallelPortDeviceBackingInfo"] = reflect.TypeOf((*VirtualParallelPortDeviceBackingInfo)(nil)).Elem()
}

// Data object type that represents the options for a device backing
// of a virtual parallel port.
type VirtualParallelPortDeviceBackingOption struct {
	VirtualDeviceDeviceBackingOption
}

func init() {
	t["VirtualParallelPortDeviceBackingOption"] = reflect.TypeOf((*VirtualParallelPortDeviceBackingOption)(nil)).Elem()
}

// The data object type for a file backing of a virtual parallel port.
type VirtualParallelPortFileBackingInfo struct {
	VirtualDeviceFileBackingInfo
}

func init() {
	t["VirtualParallelPortFileBackingInfo"] = reflect.TypeOf((*VirtualParallelPortFileBackingInfo)(nil)).Elem()
}

// Data object type that represents the options for a file backing
// of a virtual parallel port.
type VirtualParallelPortFileBackingOption struct {
	VirtualDeviceFileBackingOption
}

func init() {
	t["VirtualParallelPortFileBackingOption"] = reflect.TypeOf((*VirtualParallelPortFileBackingOption)(nil)).Elem()
}

// This data object type contains the options for the
// virtual parallel port class.
type VirtualParallelPortOption struct {
	VirtualDeviceOption
}

func init() {
	t["VirtualParallelPortOption"] = reflect.TypeOf((*VirtualParallelPortOption)(nil)).Elem()
}

// The VirtualPointingDevice data object type contains information about
// the mouse type on a virtual machine.
type VirtualPointingDevice struct {
	VirtualDevice
}

func init() {
	t["VirtualPointingDevice"] = reflect.TypeOf((*VirtualPointingDevice)(nil)).Elem()
}

// The DeviceBackingOption data object type represents
// the options for a pointing device backing a
// VirtualPointingDevice data object type.
type VirtualPointingDeviceBackingOption struct {
	VirtualDeviceDeviceBackingOption

	// This object defines the supported mouse types, including the default
	// supported mouse type, with the following properties:
	//   - `*hostPointingDevices.value*`: This array defines the
	//     supported mouse types.
	//   - `*hostPointingDevices.choiceDescription*`: This array
	//     provides the descriptions for the supported mouse types defined by
	//     hostPointingDevices.value.
	//   - `*hostPointingDevices.defaultIndex*`: This integer points
	//     to an index in the hostPointingDevices.value array. This is the
	//     mouse type supported by default.
	HostPointingDevice ChoiceOption `xml:"hostPointingDevice" json:"hostPointingDevice"`
}

func init() {
	t["VirtualPointingDeviceBackingOption"] = reflect.TypeOf((*VirtualPointingDeviceBackingOption)(nil)).Elem()
}

// The VirtualPointingDevice.DeviceBackingInfo provides information about
// the physical mouse backing the VirtualPointingDevice data object
// type.
type VirtualPointingDeviceDeviceBackingInfo struct {
	VirtualDeviceDeviceBackingInfo

	// This optional property defines the mouse type (two-button,
	// three-button, and so on).
	//
	// The mouse type
	// determines how the user interacts with the host mouse.
	// The valid values are specified in the
	// `VirtualPointingDeviceHostChoice_enum` list.
	//
	// `*Note*`: The value specified by this property must be
	// one of the supported types listed in the hostPointingDevices.value
	// array in the `VirtualPointingDeviceOption` data object type. If this property is
	// not set, then the property defaults to the
	// hostPointingDevices.defaultIndex property in the same data
	// object type.
	HostPointingDevice string `xml:"hostPointingDevice" json:"hostPointingDevice"`
}

func init() {
	t["VirtualPointingDeviceDeviceBackingInfo"] = reflect.TypeOf((*VirtualPointingDeviceDeviceBackingInfo)(nil)).Elem()
}

// The VirtualPointingDeviceOption data object type contains the options
// for the host mouse type defined in the
// `VirtualPointingDevice` data object type.
//
// These options include the valid selections for the mouse type, the supported
// mouse types, and the default mouse type.
type VirtualPointingDeviceOption struct {
	VirtualDeviceOption
}

func init() {
	t["VirtualPointingDeviceOption"] = reflect.TypeOf((*VirtualPointingDeviceOption)(nil)).Elem()
}

// This data object type represents a virtual clock device providing
// precision time in a virtual machine.
type VirtualPrecisionClock struct {
	VirtualDevice
}

func init() {
	t["VirtualPrecisionClock"] = reflect.TypeOf((*VirtualPrecisionClock)(nil)).Elem()
}

// The VirtualPrecisionClockOption data object type describes the
// options for the `VirtualPrecisionClock` data
// object type.
type VirtualPrecisionClockOption struct {
	VirtualDeviceOption
}

func init() {
	t["VirtualPrecisionClockOption"] = reflect.TypeOf((*VirtualPrecisionClockOption)(nil)).Elem()
}

// The `VirtualPrecisionClockSystemClockBackingInfo`
// data object contains information about using host system clock as the
// backing reference clock for this virtual device.
type VirtualPrecisionClockSystemClockBackingInfo struct {
	VirtualDeviceBackingInfo

	// The time synchronization protocol used to discipline system clock.
	//
	// See `HostDateTimeInfoProtocol_enum` for valid values.
	Protocol string `xml:"protocol,omitempty" json:"protocol,omitempty"`
}

func init() {
	t["VirtualPrecisionClockSystemClockBackingInfo"] = reflect.TypeOf((*VirtualPrecisionClockSystemClockBackingInfo)(nil)).Elem()
}

// This data object type describes the options for the
// `VirtualPrecisionClockSystemClockBackingInfo`
// VirtualPrecisionClockSystemClockBackingInfo} data object type.
type VirtualPrecisionClockSystemClockBackingOption struct {
	VirtualDeviceBackingOption

	// Parameter indicating the protocol used to discipline the
	// host system clock.
	Protocol ChoiceOption `xml:"protocol" json:"protocol"`
}

func init() {
	t["VirtualPrecisionClockSystemClockBackingOption"] = reflect.TypeOf((*VirtualPrecisionClockSystemClockBackingOption)(nil)).Elem()
}

// The VirtualSATAController data object type represents
// a SATA controller in a virtual machine.
type VirtualSATAController struct {
	VirtualController
}

func init() {
	t["VirtualSATAController"] = reflect.TypeOf((*VirtualSATAController)(nil)).Elem()
}

// The VirtualSATAControllerOption data object type contains the options
// for a virtual SATA controller defined by the
// `VirtualSATAController`
// data object type.
type VirtualSATAControllerOption struct {
	VirtualControllerOption

	// Three properties (numSATADisks.min, numSATADisks.max, and
	// numSATADisks.defaultValue) define the minimum, maximum, and default
	// number of SATA VirtualDisk instances available at any given time in the
	// SATA controller.
	//
	// The number of SATA VirtualDisk instances is
	// also limited by the number of available slots in the SATA controller.
	NumSATADisks IntOption `xml:"numSATADisks" json:"numSATADisks"`
	// Three properties (numSATACdroms.min, numSATACdroms.max, and
	// numSATACdroms.defaultValue) define the minimum, maximum, and default
	// number of SATA VirtualCdrom instances available
	// in the SATA controller.
	//
	// The number of SATA VirtualCdrom instances is
	// also limited by the number of available slots in the SATA controller.
	NumSATACdroms IntOption `xml:"numSATACdroms" json:"numSATACdroms"`
}

func init() {
	t["VirtualSATAControllerOption"] = reflect.TypeOf((*VirtualSATAControllerOption)(nil)).Elem()
}

// The VirtualSCSIController data object type represents
// a SCSI controller in a virtual machine.
type VirtualSCSIController struct {
	VirtualController

	// All SCSI controllers support hot adding and removing of devices.
	//
	// This
	// support can't be toggled in the current implementation. Therefore, this
	// option is ignored when reconfiguring a SCSI controller and is always set
	// to "true" when reading an existing configuration.
	HotAddRemove *bool `xml:"hotAddRemove" json:"hotAddRemove,omitempty"`
	// Mode for sharing the SCSI bus.
	//
	// The modes are physicalSharing,
	// virtualSharing, and noSharing. See the
	// `Sharing`
	// data object type for an explanation of these modes.
	SharedBus VirtualSCSISharing `xml:"sharedBus" json:"sharedBus"`
	// The unit number of the SCSI controller.
	//
	// The SCSI controller sits on its
	// own bus, so this field defines which slot the controller is using.
	ScsiCtlrUnitNumber int32 `xml:"scsiCtlrUnitNumber,omitempty" json:"scsiCtlrUnitNumber,omitempty"`
}

func init() {
	t["VirtualSCSIController"] = reflect.TypeOf((*VirtualSCSIController)(nil)).Elem()
}

// The VirtualSCSIControllerOption data object type contains the options
// for a virtual SCSI controller defined by the
// `VirtualSCSIController`
// data object type.
type VirtualSCSIControllerOption struct {
	VirtualControllerOption

	// Three properties (numSCSIDisks.min, numSCSIDisks.max, and
	// numSCSIDisks.defaultValue) define the minimum, maximum, and default
	// number of SCSI VirtualDisk instances available at any given time in the
	// SCSI controller.
	//
	// The number of SCSI VirtualDisk instances is
	// also limited by the number of available slots in the SCSI controller.
	NumSCSIDisks IntOption `xml:"numSCSIDisks" json:"numSCSIDisks"`
	// Three properties (numSCSICdroms.min, numSCSICdroms.max, and
	// numSCSICdroms.defaultValue) define the minimum, maximum, and default
	// number of SCSI VirtualCdrom instances available
	// in the SCSI controller.
	//
	// The number of SCSI VirtualCdrom instances is
	// also limited by the number of available slots in the SCSI controller.
	NumSCSICdroms IntOption `xml:"numSCSICdroms" json:"numSCSICdroms"`
	// Three properties (numSCSIPassthrough.min, numSCSIPassthrough.max, and
	// numSCSIPassthrough.defaultValue) define the minimum, maximum, and
	// default number of VirtualSCSIPassthrough instances available
	// have at any given time in the SCSI controller.
	//
	// The number of
	// VirtualSCSIPassthrough instances is also limited by the number of
	// available slots in the SCSI controller.
	NumSCSIPassthrough IntOption `xml:"numSCSIPassthrough" json:"numSCSIPassthrough"`
	// Supported shared bus modes.
	Sharing []VirtualSCSISharing `xml:"sharing" json:"sharing"`
	// Index into sharing array specifying the default value.
	DefaultSharedIndex int32 `xml:"defaultSharedIndex" json:"defaultSharedIndex"`
	// All SCSI controllers support hot adding and removing of devices.
	//
	// This
	// support can't be toggled in the current implementation. Therefore, this
	// option is ignored when reconfiguring a SCSI controller and is always set
	// to "true" when reading an existing configuration.
	HotAddRemove BoolOption `xml:"hotAddRemove" json:"hotAddRemove"`
	// The unit number of the SCSI controller.
	//
	// The SCSI controller sits on its
	// own bus, so that this field defines which slot the controller will use.
	ScsiCtlrUnitNumber int32 `xml:"scsiCtlrUnitNumber" json:"scsiCtlrUnitNumber"`
}

func init() {
	t["VirtualSCSIControllerOption"] = reflect.TypeOf((*VirtualSCSIControllerOption)(nil)).Elem()
}

// The VirtualSCSIPassthrough data object type contains information about a
// SCSI device on the virtual machine that is being backed by
// a generic SCSI device on the host via passthrough.
type VirtualSCSIPassthrough struct {
	VirtualDevice
}

func init() {
	t["VirtualSCSIPassthrough"] = reflect.TypeOf((*VirtualSCSIPassthrough)(nil)).Elem()
}

// The VirtualSCSIPassthrough.DeviceBackingInfo data object type
// contains information about the backing that maps the
// virtual device onto a physical device.
type VirtualSCSIPassthroughDeviceBackingInfo struct {
	VirtualDeviceDeviceBackingInfo
}

func init() {
	t["VirtualSCSIPassthroughDeviceBackingInfo"] = reflect.TypeOf((*VirtualSCSIPassthroughDeviceBackingInfo)(nil)).Elem()
}

// This data object type describes
// the options for the
// `VirtualSCSIPassthroughDeviceBackingInfo` data object type.
type VirtualSCSIPassthroughDeviceBackingOption struct {
	VirtualDeviceDeviceBackingOption
}

func init() {
	t["VirtualSCSIPassthroughDeviceBackingOption"] = reflect.TypeOf((*VirtualSCSIPassthroughDeviceBackingOption)(nil)).Elem()
}

// The VirtualSCSIPassthroughOption data object type describes the options
// for the
// `VirtualSCSIPassthrough`
// data object type.
type VirtualSCSIPassthroughOption struct {
	VirtualDeviceOption
}

func init() {
	t["VirtualSCSIPassthroughOption"] = reflect.TypeOf((*VirtualSCSIPassthroughOption)(nil)).Elem()
}

// This data object type defines a
// Super IO Controller for floppy drives, parallel ports,
// and serial ports.
type VirtualSIOController struct {
	VirtualController
}

func init() {
	t["VirtualSIOController"] = reflect.TypeOf((*VirtualSIOController)(nil)).Elem()
}

// The VirtualSIOControllerOption data object type contains the options
// for a virtual Super IO Controller.
type VirtualSIOControllerOption struct {
	VirtualControllerOption

	// Three properties (numFloppyDrives.min, numFloppyDrives.max, and
	// numFloppyDrives.defaultValue) define the minimum, maximum, and default
	// number of floppy drives you can have at any given time in the Super IO
	// Controller.
	//
	// This is further constrained by the number of available
	// slots in the Super IO Controller.
	NumFloppyDrives IntOption `xml:"numFloppyDrives" json:"numFloppyDrives"`
	// Three properties (numSerialPorts.min, numSerialPorts.max, and
	// numSerialPorts.defaultValue) define the minimum, maximum, and default
	// number of serial ports you can
	// have at any given time in the Super IO Controller.
	//
	// This is further
	// constrained by the number of available slots in the Super IO
	// Controller.
	NumSerialPorts IntOption `xml:"numSerialPorts" json:"numSerialPorts"`
	// Three properties (numParallelPorts.min, numParallelPorts.max, and
	// numParallelPorts.defaultValue) define the minimum, maximum, and default
	// number of parallel ports you can
	// have at any given time in the Super IO controller.
	//
	// This is further
	// constrained by the number of available slots in the Super IO
	// Controller.
	NumParallelPorts IntOption `xml:"numParallelPorts" json:"numParallelPorts"`
}

func init() {
	t["VirtualSIOControllerOption"] = reflect.TypeOf((*VirtualSIOControllerOption)(nil)).Elem()
}

// The <code>`VirtualSerialPort`</code> data object represents a serial port
// on a virtual machine.
//
// A virtual serial port uses one of the following backing types to specify
// how the virtual machine performs serial port operations.
//   - Network backing (<code>`VirtualSerialPortURIBackingInfo`</code>)
//     supports a connection between the virtual machine and a resource
//     on the network. The virtual machine can initiate a connection with
//     the network resource, or it can listen for connections originating
//     from the network.
//   - Pipe backing (<code>`VirtualSerialPortPipeBackingInfo`</code>)
//     supports I/O through a named pipe. The pipe connects the virtual machine
//     to a host application or a virtual machine on the same host.
//   - File backing (<code>`VirtualSerialPortFileBackingInfo`</code>)
//     supports output through the virtual serial port to a file on the same host.
//   - Physical serial port backing
//     (<code>`VirtualSerialPortDeviceBackingInfo`</code>)
//     supports a connection between the virtual machine and a
//     device that is connected to a physical serial port on the host.
//   - ThinPrint backing (<code>`VirtualSerialPortThinPrintBackingInfo`</code>)
//     provides driver-free printing.
//
// When you use network backing, you can also configure a virtual serial port
// to use a virtual serial port concentrator. The virtual machine initiates
// a telnet connection with the concentrator, and the concentrator acts
// as a proxy between the virtual machine and a system on the network.
// By using a virtual serial port concentrator, you can maintain the connection
// between the virtual machine and the network resource
// when a vMotion event moves the virtual machine from one host to another.
// Without a virtual serial port concentrator, the connection would be lost.
// For information about using a serial port concentrator,
// see _Using a Proxy with vSphere Virtual Serial Ports_.
//
// You can configure a virtual serial port when you create or reconfigure
// a virtual machine. For example, to create a virtual serial port
// with network backing, use the following sequence of operations.
// In this procedure, the virtual serial port uses a proxy and will accept
// a network connection.
//
//  1. Use the <code>`EnvironmentBrowser.QueryConfigOption`</code> method
//     to determine the backing options that are available on a host.
//     The method returns a <code>`VirtualMachineConfigOption`</code> data object.
//     The virtual machine configuration data includes a list of backing options
//     (<code>`VirtualDeviceOption.backingOption`</code>).
//     The following pseudocode shows the path to the backing options.
//
//     &nbsp;&nbsp;&nbsp;&nbsp;<code>`VirtualMachineConfigOption`.hardwareOptions.VirtualDeviceOption\[\].backingOption\[\]</code>
//
//     The array of virtual device options can include a virtual serial port
//     (<code>`VirtualSerialPortOption`</code>). The array of serial port
//     backing options can include URI, file, pipe, or device backing options.
//
//  2. Use the <code>`Folder.CreateVM_Task`</code> method
//     (or the <code>`ResourcePool.CreateChildVM_Task`</code> method)
//     to create the virtual machine and configure the virtual serial port backing.
//     Create a <code>`VirtualMachineConfigSpec`</code> data object and nested
//     data objects for the method's <code>config</code> parameter.
//     The following pseudocode shows the resulting path to the backing
//     information.
//
//     &nbsp;&nbsp;&nbsp;&nbsp;<code>`VirtualMachineConfigSpec`.deviceChange\[\].device.backing</code>
//
//     Set the direction property to "server" to direct the virtual machine to accept
//     a connection. Set the serviceURI property to the URI for the host on which
//     the virtual machine runs.
//
// If you use physical device backing
// (<code>`VirtualSerialPortDeviceBackingOption`</code>),
// you should also use the <code>`EnvironmentBrowser.QueryConfigTarget`</code>
// method to determine if a serial device is available before configuring device backing.
type VirtualSerialPort struct {
	VirtualDevice

	// Enables CPU yield behavior.
	//
	// If you set <code>yieldOnPoll</code> to <code>true</code>,
	// the virtual machine will periodically relinquish the processor if its sole task
	// is polling the virtual serial port. The amount of time it takes to regain
	// the processor will depend on the degree of other virtual machine activity on the host.
	//
	// To use this property, the CPU yield option must be supported. (See the
	// <code>`VirtualSerialPortOption.yieldOnPoll`</code> property for
	// the virtual serial port option object.)
	YieldOnPoll bool `xml:"yieldOnPoll" json:"yieldOnPoll"`
}

func init() {
	t["VirtualSerialPort"] = reflect.TypeOf((*VirtualSerialPort)(nil)).Elem()
}

// The <code>`VirtualSerialPortDeviceBackingInfo`</code> data object
// defines information for using a host serial port device as backing for a
// <code>`VirtualSerialPort`</code>.
//
// On a host, the first virtual machine
// to configure physical device backing for a virtual serial port will obtain
// the mapping. As long as that machine maintains the backing, any additional attempts
// to configure backing using that device will fail (a recoverable error, see
// the connection info <code>`VirtualDeviceConnectInfo.status`</code>).
type VirtualSerialPortDeviceBackingInfo struct {
	VirtualDeviceDeviceBackingInfo
}

func init() {
	t["VirtualSerialPortDeviceBackingInfo"] = reflect.TypeOf((*VirtualSerialPortDeviceBackingInfo)(nil)).Elem()
}

// The <code>`VirtualSerialPortDeviceBackingOption`</code> data object type
// contains the options for backing a serial port with a host serial port device.
type VirtualSerialPortDeviceBackingOption struct {
	VirtualDeviceDeviceBackingOption
}

func init() {
	t["VirtualSerialPortDeviceBackingOption"] = reflect.TypeOf((*VirtualSerialPortDeviceBackingOption)(nil)).Elem()
}

// The <code>`VirtualSerialPortFileBackingInfo`</code> data object provides
// information for backing a virtual serial port with a host file.
type VirtualSerialPortFileBackingInfo struct {
	VirtualDeviceFileBackingInfo
}

func init() {
	t["VirtualSerialPortFileBackingInfo"] = reflect.TypeOf((*VirtualSerialPortFileBackingInfo)(nil)).Elem()
}

// The <code>`VirtualSerialPortFileBackingOption`</code> data object type
// contains the options for backing a serial port with a host file.
type VirtualSerialPortFileBackingOption struct {
	VirtualDeviceFileBackingOption
}

func init() {
	t["VirtualSerialPortFileBackingOption"] = reflect.TypeOf((*VirtualSerialPortFileBackingOption)(nil)).Elem()
}

// The <code>`VirtualSerialPortOption`</code> data object contains the options
// for configuring the virtual serial port device defined by the
// <code>`VirtualSerialPort`</code> data object.
//
// These options include information about how the device is backed
// physically on the host: by a network socket, a host file, a host serial port device,
// or a pipe to another process.
type VirtualSerialPortOption struct {
	VirtualDeviceOption

	// Indicates whether the virtual machine supports the CPU yield option during
	// virtual serial port polling.
	//
	// When this feature is supported and enabled,
	// the virtual machine will periodically relinquish the processor if its
	// sole task is polling the virtual serial port.
	//
	// If <code>yieldOnPoll.supported</code> is <code>false</code>, the virtual
	// machine ignores the virtual serial port object setting for
	// <code>`VirtualSerialPort.yieldOnPoll`</code>.
	YieldOnPoll BoolOption `xml:"yieldOnPoll" json:"yieldOnPoll"`
}

func init() {
	t["VirtualSerialPortOption"] = reflect.TypeOf((*VirtualSerialPortOption)(nil)).Elem()
}

// The <code>`VirtualSerialPortPipeBackingInfo`</code> data object defines information
// for backing a <code>`VirtualSerialPort`</code> with a named pipe.
//
// You can use a pipe to connect a virtual serial port to a host
// application or to another virtual machine on the host computer.
// This is useful for capturing debugging information sent through
// the virtual serial port.
type VirtualSerialPortPipeBackingInfo struct {
	VirtualDevicePipeBackingInfo

	// Indicates the role the virtual machine assumes as an endpoint
	// for the pipe.
	//
	// The valid values are "client" or "server".
	Endpoint string `xml:"endpoint" json:"endpoint"`
	// Enables optimized data transfer over the pipe.
	//
	// When you use this feature,
	// the ESX server buffers data to prevent data overrun.
	// This allows the virtual machine to read
	// all of the data transferred over the pipe with no data loss.
	// To use optimized data transfer, set <code>noRxLoss</code> to <code>true</code>.
	// To disable this feature, set the property to <code>false.
	//
	// This property is optional. If this property is not set, the ESX server
	// uses the default value specified in the pipe backing options
	// (noRxLoss.defaultValue - see
	// <code>`VirtualSerialPortPipeBackingOption.noRxLoss`</code>
	// in the pipe backing option object).
	//
	// To use this property, optimized data transfer must be supported on the host.
	// (See <code>`VirtualSerialPortPipeBackingOption.noRxLoss`</code>
	// in the pipe backing option object.)
	// If the ESX server does not support the option, it ignores the
	// <code>noRxLoss</code> setting in the pipe backing information object.
	//
	// `*Note*`: You can use this feature even if the other end of the pipe
	// is not an application, but this is more likely to fail.
	NoRxLoss *bool `xml:"noRxLoss" json:"noRxLoss,omitempty"`
}

func init() {
	t["VirtualSerialPortPipeBackingInfo"] = reflect.TypeOf((*VirtualSerialPortPipeBackingInfo)(nil)).Elem()
}

// The <code>`VirtualSerialPortPipeBackingOption`</code> data object contains
// the options for backing a serial port device with a pipe to another process.
type VirtualSerialPortPipeBackingOption struct {
	VirtualDevicePipeBackingOption

	// Indicates the choices available and the default setting
	// for the pipe endpoint.
	//
	// As an endpoint, the virtual machine can act
	// as a client or a server.
	Endpoint ChoiceOption `xml:"endpoint" json:"endpoint"`
	// Indicates whether the server supports optimized data transfer
	// over the pipe and also specifies default behavior.
	//
	// When this feature is supported and enabled, the server buffers data
	// to prevent data overrun. This allows the virtual machine to read all
	// of the data transferred over the pipe with no data loss.
	//
	// If optimized data transfer is supported (<code>noRxLoss.supported</code>
	// is <code>true</code>):
	//   - You can enable (or disable) the feature explicitly by setting the
	//     <code>`VirtualSerialPortPipeBackingInfo.noRxLoss`</code>
	//     property on the pipe backing information object.
	//   - If you do not set the
	//     <code>`VirtualSerialPortPipeBackingInfo.noRxLoss`</code>
	//     property on the
	//     the pipe backing information object, the server enables
	//     optimized data transfer if the <code>noRxLoss.defaultValue</code>
	//     property on the pipe backing options object is <code>true</code>.
	//
	// If <code>noRxLoss.supported</code> is <code>false</code>, the server
	// ignores the optimization settings.
	//
	// `*Note*`: You can use this feature even if the other end of the pipe
	// is not an application, but it is more likely to fail.
	NoRxLoss BoolOption `xml:"noRxLoss" json:"noRxLoss"`
}

func init() {
	t["VirtualSerialPortPipeBackingOption"] = reflect.TypeOf((*VirtualSerialPortPipeBackingOption)(nil)).Elem()
}

// The <code>`VirtualSerialPortThinPrintBackingInfo`</code> data object defines
// information required for backing a <code>`VirtualSerialPort`</code> with a
// ThinPrint device.
type VirtualSerialPortThinPrintBackingInfo struct {
	VirtualDeviceBackingInfo
}

func init() {
	t["VirtualSerialPortThinPrintBackingInfo"] = reflect.TypeOf((*VirtualSerialPortThinPrintBackingInfo)(nil)).Elem()
}

// The <code>`VirtualSerialPortThinPrintBackingOption`</code> data
// object type contains the options for backing a serial port with a ThinPrint device.
type VirtualSerialPortThinPrintBackingOption struct {
	VirtualDeviceBackingOption
}

func init() {
	t["VirtualSerialPortThinPrintBackingOption"] = reflect.TypeOf((*VirtualSerialPortThinPrintBackingOption)(nil)).Elem()
}

// The <code>`VirtualSerialPortURIBackingInfo`</code> data object
// specifies network backing for a <code>`VirtualSerialPort`</code>.
//
// You can use URI backing to create a network serial port on the virtual machine,
// supporting connections between the virtual machine and remote systems.
//
// When a virtual machine establishes a connection with a remote system on the network,
// the virtual machine can act as a server or a client. When the virtual machine
// acts as a server, it accepts a connection. When the virtual machine acts as a client,
// it initiates the connection.
//
// You can configure the virtual serial port for communication through a
// virtual serial port concentrator that acts as a proxy between the virtual
// machine and the network. When you specify a
// <code>`VirtualDeviceURIBackingInfo.proxyURI`</code>,
// the virtual machine initiates the connection with the concentrator
// and forwards the <code>`VirtualDeviceURIBackingInfo.direction`</code>
// and <code>`VirtualDeviceURIBackingInfo.serviceURI`</code>
// to the concentrator.
// For information about using a virtual serial port concentrator,
// see _Using a Proxy with vSphere Virtual Serial Ports_.
//
// ESX hosts support different protocols depending on your virtual serial port configuration.
//
//   - If the virtual machine is handling the network connection
//     directly (no <code>`VirtualDeviceURIBackingInfo.proxyURI`</code> specified),
//     you can use telnet, TCP, and SSL protocols.
//     The <code>`VirtualDeviceURIBackingInfo.serviceURI`</code>
//     must use one of the following URI schemes:
//
//   - <code>&lt;host&gt;:&lt;port&gt;</code> - this is the equivalent of
//     <code>tcp://&lt;host&gt;:&lt;port&gt;</code>.
//
//   - <code>tcp://&lt;host&gt;:&lt;port&gt;</code> - unencrypted TCP connection
//     (IPv4 or IPv6).
//
//   - <code>tcp4://&lt;host&gt;:&lt;port&gt;</code> - unencrypted TCP connection
//     (IPv4 only).
//
//   - <code>tcp6://&lt;host&gt;:&lt;port&gt;</code> - unencrypted TCP connection
//     (IPv6 only).
//
//   - <code>ssl://&lt;host&gt;:&lt;port&gt;</code> - this is the equivalent of
//     <code>tcp+ssl://&lt;host&gt;:&lt;port&gt;</code>.
//
//   - <code>tcp+ssl://&lt;host&gt;:&lt;port&gt;</code> - encrypted SSL over TCP.
//
//   - <code>tcp4+ssl://&lt;host&gt;:&lt;port&gt;</code> - SSL over TCP over IPv4.
//
//   - <code>tcp6+ssl://&lt;host&gt;:&lt;port&gt;</code> - SSL over TCP over IPv6.
//
//   - <code>telnet://&lt;host&gt;:&lt;port&gt;</code> - telnet over TCP.
//     The virtual machine and remote system can negotiate and use SSL if the remote
//     system supports the telnet authentication option; if not, the connection
//     uses unencrypted text (plaintext).
//
//   - <code>telnets://&lt;host&gt;:&lt;port&gt;</code> - telnet over SSL over TCP.
//     In this case, SSL negotiation begins immediately and you cannot use
//     the telnet authentication option.
//
//     As of vSphere 5.1 you can specify authentication parameters to support an encrypted
//     connection with a remote system using SSL over telnet or telnets.
//     The connection will fail if the peer does not support the protocols.
//     You cannot use certificate verification when you specify
//     <code>tcp</code>, <code>tcp4</code>, or <code>tcp6</code> schemas. For information
//     about parameter specification, see <a href="#authparam">Authentication Parameters</a>
//     below.
//
//   - If you are using a <code>`VirtualDeviceURIBackingInfo.proxyURI`</code>
//     to connect to a virtual serial port concentrator, the URI scheme for
//     the communication between the remote system on the network and the concentrator
//     depends on the concentrator implementation. The connection between
//     the concentrator and the virtual serial port must use telnet or secure telnet
//     (telnets). The proxy URI must use one of the following URI schemes. You cannot
//     specify a username and password in the proxy URI.
//
//   - <code>telnet://&lt;host&gt;:&lt;port&gt;</code>- telnet over TCP.
//     The virtual machine and remote system can negotiate and use SSL if the remote
//     system supports the telnet authentication option; if not, the connection
//     uses unencrypted text (plaintext).
//
//   - <code>telnets://&lt;host&gt;:&lt;port&gt;</code> - telnet over SSL over TCP.
//     In this case, SSL negotiation starts immediately and you cannot use
//     the telnet authentication option.
//
//     As of vSphere 5.1 you can specify authentication parameters to support an encrypted
//     connection with a concentrator using SSL over telnet or telnets.
//     The connection will fail if the concentrator does not support the protocols.
//     For information about parameter specification,
//     see <a href="#authparam">Authentication Parameters</a> below.
//
// <a name="authparam"></a>
// **Authentication Parameters**
//
// For an encrypted connection, the URI includes a set of authentication
// parameters. The parameters are specified as key words or key/value pairs.
// The following syntax description uses <code>telnet</code>; you can also
// specify authentication parameters for secure telnet (<code>telnets</code>).
//
// <code>telnet://&lt;host&gt;:&lt;port&gt;&num;key\[=value\]\[&amp;key\[=value\] ...\]</code>
//
// The first parameter must have a number sign (&num;) prefix. Additional parameters
// must have an ampersand (&amp;) prefix. The following list shows the valid parameters.
//   - <code>certificate=value</code> - Specifies a certificate in PEM format
//     against which the peer certificate is compared.
//     When you specify a certificate, certificate verification is automatically enabled.
//     See the description of the <code>verify</code> parameter below.
//   - <code>thumbprint=value</code> - Specifies a certificate thumbprint against
//     which the peer certificate thumbprint is compared. When you specify a thumbprint,
//     certificate verification is automatically enabled. See the description of the
//     <code>verify</code> parameter below.
//   - <code>peerName=value</code> - Specifies the peer name that will be used
//     to validate the peer certificate. When you specify a peer name,
//     certificate verification is automatically enabled. See the description of the
//     <code>verify</code> parameter below.
//   - <code>verify</code> - Forces certificate verification. The virtual machine
//     will verify that the peer certificate subject matches the specified
//     <code>peerName</code> and that it was signed by a certificate authority
//     known to the ESXi host. Verification is automatically enabled if you specify a
//     <code>certificate</code>, <code>thumbprint</code>, or <code>peerName</code>.
//   - <code>cipherList=value</code> - Specifies a list of SSL ciphers.
//     See <a href="http://www.openssl.org/docs/apps/ciphers.html">OpenSSL ciphers</a>.
//     The ciphers are specified as a list separated by colons, spaces, or commas.
//
// For information about URI format, see
// <a href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>.
type VirtualSerialPortURIBackingInfo struct {
	VirtualDeviceURIBackingInfo
}

func init() {
	t["VirtualSerialPortURIBackingInfo"] = reflect.TypeOf((*VirtualSerialPortURIBackingInfo)(nil)).Elem()
}

// The <code>`VirtualSerialPortURIBackingOption`</code> data object type
// contains the options for using a network socket as backing for a virtual serial port.
type VirtualSerialPortURIBackingOption struct {
	VirtualDeviceURIBackingOption
}

func init() {
	t["VirtualSerialPortURIBackingOption"] = reflect.TypeOf((*VirtualSerialPortURIBackingOption)(nil)).Elem()
}

// The VirtualSoundBlaster16 data object type represents a Sound
// Blaster 16 sound card in a virtual machine.
type VirtualSoundBlaster16 struct {
	VirtualSoundCard
}

func init() {
	t["VirtualSoundBlaster16"] = reflect.TypeOf((*VirtualSoundBlaster16)(nil)).Elem()
}

// The VirtualSoundBlaster16Option data object type contains the options for a
// virtual SoundBlaster 16 sound card.
type VirtualSoundBlaster16Option struct {
	VirtualSoundCardOption
}

func init() {
	t["VirtualSoundBlaster16Option"] = reflect.TypeOf((*VirtualSoundBlaster16Option)(nil)).Elem()
}

// This data object type represents a sound card in
// a virtual machine.
type VirtualSoundCard struct {
	VirtualDevice
}

func init() {
	t["VirtualSoundCard"] = reflect.TypeOf((*VirtualSoundCard)(nil)).Elem()
}

// The sound card device backing data class.
type VirtualSoundCardDeviceBackingInfo struct {
	VirtualDeviceDeviceBackingInfo
}

func init() {
	t["VirtualSoundCardDeviceBackingInfo"] = reflect.TypeOf((*VirtualSoundCardDeviceBackingInfo)(nil)).Elem()
}

// The VirtualSoundCardBackingOption class contains the options
// for the virtual sound card backing class.
type VirtualSoundCardDeviceBackingOption struct {
	VirtualDeviceDeviceBackingOption
}

func init() {
	t["VirtualSoundCardDeviceBackingOption"] = reflect.TypeOf((*VirtualSoundCardDeviceBackingOption)(nil)).Elem()
}

// The VirtualSoundCardOption data class contains the options for the
// virtual sound card class.
type VirtualSoundCardOption struct {
	VirtualDeviceOption
}

func init() {
	t["VirtualSoundCardOption"] = reflect.TypeOf((*VirtualSoundCardOption)(nil)).Elem()
}

// The `VirtualSriovEthernetCard` data object defines the properties
// of a SR-IOV enabled Ethernet card attached to a virtual machine.
type VirtualSriovEthernetCard struct {
	VirtualEthernetCard

	// Indicates whether MTU can be changed from guest OS.
	AllowGuestOSMtuChange *bool `xml:"allowGuestOSMtuChange" json:"allowGuestOSMtuChange,omitempty"`
	// Information about SR-IOV passthrough backing of this VirtualSriovEthernetCard.
	//
	// During an edit operation, if this value is unset, no changes to the
	// SR-IOV backing will be made. During an add operation, if this is unset,
	// an automatic physical function assignment scheme as described above will be used.
	// This field is ignored and must be unset if this VirtualSriovEthernetCard
	// is a DVX device, in which case the dvxBackingInfo field is set. In other
	// words, sriovBacking and dvxBackingInfo cannot both be set at any time.
	SriovBacking *VirtualSriovEthernetCardSriovBackingInfo `xml:"sriovBacking,omitempty" json:"sriovBacking,omitempty"`
	// Information about DVX backing of this VirtualSriovEthernetCard.
	//
	// This field is set if and only if this VirtualSriovEthernetCard is a DVX
	// device.
	DvxBackingInfo *VirtualPCIPassthroughDvxBackingInfo `xml:"dvxBackingInfo,omitempty" json:"dvxBackingInfo,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VirtualSriovEthernetCard"] = reflect.TypeOf((*VirtualSriovEthernetCard)(nil)).Elem()
}

// The VirtualSriovEthernetCardOption data object contains the options for the
// VirtualSriovEthernetCard data object type.
type VirtualSriovEthernetCardOption struct {
	VirtualEthernetCardOption
}

func init() {
	t["VirtualSriovEthernetCardOption"] = reflect.TypeOf((*VirtualSriovEthernetCardOption)(nil)).Elem()
}

// The `VirtualSriovEthernetCardSriovBackingInfo`
// data object contains information about the SR-IOV physical function and
// virtual function backing for a passthrough NIC.
type VirtualSriovEthernetCardSriovBackingInfo struct {
	VirtualDeviceBackingInfo

	// Physical function backing for this device.
	//
	// A specific physical function can be assigned to the device by specifying
	// its id but the VirtualSriovNetworkCard can also be configured for automatic physical
	// function assignment by providing a special value "Automatic-0000:00:00.0"
	// as `VirtualPCIPassthroughDeviceBackingInfo.id`. This is supported if there is
	// an associated SR-IOV network device pool for the network specified in
	// `VirtualDevice.backing` - in that case a physical function from
	// the pool, if available, will be assigned to this device during power on.
	// During reconfigure, if an SR-IOV backing is provided, the physical function backing
	// may not be left unset.
	// A value of "Automatic-" followed by a valid physical function id
	// in `VirtualPCIPassthroughDeviceBackingInfo.id` indicates that assignment
	// is automatic and the physical function in question is the one that has currently
	// been assigned.
	PhysicalFunctionBacking *VirtualPCIPassthroughDeviceBackingInfo `xml:"physicalFunctionBacking,omitempty" json:"physicalFunctionBacking,omitempty"`
	// Virtual function backing for this device.
	//
	// During reconfigure, if this is unset, any currently assigned virtual function
	// will be overwritten and a new one will be selected. If
	// `VirtualPCIPassthroughDeviceBackingInfo.id` contains a valid id for
	// a virtual function of the currently assigned physical function, this acts as
	// a hint and, if possible, the specified virtual function will be the one
	// allocated for the device.
	// When a virtual function is yet to be assigned to the device (e.g. if the VM
	// has not been powered on yet), the virtual function backing will be unset.
	VirtualFunctionBacking *VirtualPCIPassthroughDeviceBackingInfo `xml:"virtualFunctionBacking,omitempty" json:"virtualFunctionBacking,omitempty"`
	VirtualFunctionIndex   int32                                   `xml:"virtualFunctionIndex,omitempty" json:"virtualFunctionIndex,omitempty"`
}

func init() {
	t["VirtualSriovEthernetCardSriovBackingInfo"] = reflect.TypeOf((*VirtualSriovEthernetCardSriovBackingInfo)(nil)).Elem()
}

// This data object contains the option for SriovBackingInfo data
// of the virtual network SR-IOV card object type.
type VirtualSriovEthernetCardSriovBackingOption struct {
	VirtualDeviceBackingOption
}

func init() {
	t["VirtualSriovEthernetCardSriovBackingOption"] = reflect.TypeOf((*VirtualSriovEthernetCardSriovBackingOption)(nil)).Elem()
}

// The `VirtualSwitchProfile` data object represents a subprofile
// for a virtual switch.
//
// If a profile plug-in defines policies or subprofiles, use the
// `ApplyProfile.policy` or `ApplyProfile.property`
// list to access the additional configuration data.
type VirtualSwitchProfile struct {
	ApplyProfile

	// Linkable identifier.
	Key string `xml:"key" json:"key"`
	// Name of the standard virtual switch(VSS).
	Name string `xml:"name" json:"name"`
	// Links that are connected to the virtual switch.
	Link LinkProfile `xml:"link" json:"link"`
	// Number of ports on the virtual switch.
	NumPorts NumPortsProfile `xml:"numPorts" json:"numPorts"`
	// Network policy/policies for the virtual switch.
	NetworkPolicy NetworkPolicyProfile `xml:"networkPolicy" json:"networkPolicy"`
}

func init() {
	t["VirtualSwitchProfile"] = reflect.TypeOf((*VirtualSwitchProfile)(nil)).Elem()
}

// The `VirtualSwitchSelectionProfile` data object represents
// the virtual switch that is connected to a port group.
//
// The `ApplyProfile.policy` property contains
// the configuration data values for the virtual switch.
type VirtualSwitchSelectionProfile struct {
	ApplyProfile
}

func init() {
	t["VirtualSwitchSelectionProfile"] = reflect.TypeOf((*VirtualSwitchSelectionProfile)(nil)).Elem()
}

// This data object type represents a TPM 2.0 module
// in a virtual machine.
type VirtualTPM struct {
	VirtualDevice

	// Endorsement Key Certificate Signing Request in DER format.
	//
	// There may be more than one - one for RSA 2048, one for ECC NIST P256,
	// and any number of other signing requests for other algorithms.
	EndorsementKeyCertificateSigningRequest [][]byte `xml:"endorsementKeyCertificateSigningRequest,omitempty" json:"endorsementKeyCertificateSigningRequest,omitempty"`
	// Endorsement Key Certificate in DER format.
	//
	// There may be more than one. Indices in this array do not match
	// indices in `VirtualTPM.endorsementKeyCertificateSigningRequest` array,
	// entries must be matched by comparing fields in DER data between
	// certificate signing requests and certificates.
	EndorsementKeyCertificate [][]byte `xml:"endorsementKeyCertificate,omitempty" json:"endorsementKeyCertificate,omitempty"`
}

func init() {
	t["VirtualTPM"] = reflect.TypeOf((*VirtualTPM)(nil)).Elem()
}

// This data object type contains the options for the
// virtual TPM class.
type VirtualTPMOption struct {
	VirtualDeviceOption

	// List of supported firmware selections, using
	// `GuestOsDescriptorFirmwareType_enum` enumeration.
	//
	// There is at least one value in this array.
	SupportedFirmware []string `xml:"supportedFirmware,omitempty" json:"supportedFirmware,omitempty"`
}

func init() {
	t["VirtualTPMOption"] = reflect.TypeOf((*VirtualTPMOption)(nil)).Elem()
}

// The `VirtualUSB` data object describes the USB device configuration
// for a virtual machine.
//
// You can attach a USB device to an ESX host.
// The device is available to only one virtual machine at a time. When you remove
// the device from the virtual machine, it becomes available to other virtual machines
// located on the host. You can add up to 20 USB devices to a virtual machine.
// Virtual USB support requires virtual machine hardware version 7 or later.
//
// The `VirtualUSB` object represents either a configuration to be applied to
// the virtual machine or the current device configuration on the virtual machine.
//
//   - To configure a USB connection for the virtual machine, add a `VirtualUSB`
//     object to the `VirtualDeviceConfigSpec`.
//     Use USB backing (`VirtualUSBUSBBackingInfo`) to establish
//     a connection with a virtual machine that will remain on the host to which
//     the USB device is attached.
//     The vSphere Server does not support vMotion for standard USB backing.
//     To configure vMotion support for a virtual machine with a USB connection,
//     use remote host backing for the USB connection
//     (`VirtualUSBRemoteHostBackingInfo`).
//
//     To configure a USB device for a virtual machine, the virtual machine
//     must have a USB controller. To add a controller, include a
//     `VirtualUSBController` object in the virtual device
//     specification for your virtual machine configuration. You can add only one
//     USB controller to a virtual machine.
//
//   - To determine USB device configuration status for the virtual machine,
//     check the virtual hardware device list
//     (`VirtualHardware*.*VirtualHardware.device`).
//     The presence of the `VirtualUSB` object in the hardware device list
//     indicates that the virtual machine is configured to use a USB device.
//     The `VirtualUSB.connected` property indicates
//     whether the virtual machine is connected to the device.
//
// To determine the USB options available on the host, use the
// `EnvironmentBrowser.QueryConfigOption` method to retrieve the virtual
// machine configuration. The presence of the `VirtualUSBOption`
// object in the retrieved configuration
// (`VirtualMachineConfigOption*.*VirtualMachineConfigOption.hardwareOptions*.*VirtualHardwareOption.virtualDeviceOption`)
// indicates that the host supports USB connections.
//
// The following operations will disconnect a USB device, losing data if data transfer
// is in progress over the USB connection.
//   - Hot add of memory, CPU, or PCI devices. A hot add operation disconnects only
//     USB devices for virtual machines that use a local connection to the device
//     (`VirtualUSBUSBBackingInfo`).
//   - Suspend and resume on a virtual machine.
//   - vMotion of a virtual machine with a USB connection,
//     if you are not using remote host USB backing.
//
// The following services do not support USB connections.
//   - Fault Tolerance virtual machines cannot use USB devices.
//   - DPM (Distributed Power Management) will put a host into standby,
//     regardless of any connections to USB devices on the host.
//   - DRS (Distributed Resource Scheduling) may power-off hosts that have
//     USB connections to virtual machines.
type VirtualUSB struct {
	VirtualDevice

	// Flag indicating whether the device is currently connected.
	//
	// The virtual machine is not connected to the device if the autoconnect pattern
	// specified in the USB device backing
	// (`VirtualDeviceDeviceBackingInfo*.*VirtualDeviceDeviceBackingInfo.deviceName`)
	// can not be satisfied, either
	// because there is no such device, or the matching device is not
	// available. Valid only while the virtual machine is running.
	Connected bool `xml:"connected" json:"connected"`
	// Vendor ID of the USB device.
	Vendor int32 `xml:"vendor,omitempty" json:"vendor,omitempty"`
	// Product ID of the USB device.
	Product int32 `xml:"product,omitempty" json:"product,omitempty"`
	// Device class families.
	//
	// For possible values see
	// `VirtualMachineUsbInfoFamily_enum`.
	Family []string `xml:"family,omitempty" json:"family,omitempty"`
	// Device speeds detected by server.
	//
	// For possible values see
	// `VirtualMachineUsbInfoSpeed_enum`.
	Speed []string `xml:"speed,omitempty" json:"speed,omitempty"`
}

func init() {
	t["VirtualUSB"] = reflect.TypeOf((*VirtualUSB)(nil)).Elem()
}

// The `VirtualUSBController` data object describes a virtual USB controller
// and contains a list of the devices connected to the controller.
//
// A virtual machine must have a virtual USB controller before you can add
// a USB device to the virtual machine configuration. To add a controller,
// include a `VirtualUSBController` object in the
// `VirtualDeviceConfigSpec` for your virtual machine configuration.
// You can add only one controller to a virtual machine.
// A virtual USB controller supports up to 20 USB device connections on the
// virtual machine.
//
// The ESX Server host must have the USB controller hardware and modules
// that support USB 2.0 and USB1.1.
// You can use a maximum of 15 USB controllers on a host. If your system
// includes an additional number of controllers with connected devices,
// the additional devices will not be available to virtual machines on the host.
//
// You must remove all USB devices from a virtual machine before you can
// remove the USB controller.
type VirtualUSBController struct {
	VirtualController

	// Flag to indicate whether or not the ability to hot plug devices
	// is enabled on this controller.
	AutoConnectDevices *bool `xml:"autoConnectDevices" json:"autoConnectDevices,omitempty"`
	// Flag to indicate whether or not enhanced host controller
	// interface (USB 2.0) is enabled on this controller.
	EhciEnabled *bool `xml:"ehciEnabled" json:"ehciEnabled,omitempty"`
}

func init() {
	t["VirtualUSBController"] = reflect.TypeOf((*VirtualUSBController)(nil)).Elem()
}

// The VirtualUSBControllerOption data object type contains the options
// for a virtual USB Host Controller Interface.
type VirtualUSBControllerOption struct {
	VirtualControllerOption

	// Flag to indicate whether or not the ability to autoconnect devices
	// is enabled for this virtual USB controller.
	AutoConnectDevices BoolOption `xml:"autoConnectDevices" json:"autoConnectDevices"`
	// Flag to indicate whether or not enhanced host controller
	// interface (USB 2.0) is available on this virtual USB controller.
	EhciSupported BoolOption `xml:"ehciSupported" json:"ehciSupported"`
	// Range of USB device speeds supported by this USB controller type.
	//
	// Acceptable values are specified at `VirtualMachineUsbInfoSpeed_enum`.
	SupportedSpeeds []string `xml:"supportedSpeeds,omitempty" json:"supportedSpeeds,omitempty"`
}

func init() {
	t["VirtualUSBControllerOption"] = reflect.TypeOf((*VirtualUSBControllerOption)(nil)).Elem()
}

// The <code>`VirtualUSBControllerPciBusSlotInfo`</code> data object type
// defines information about the pci bus slots of usb controller device
// in a virtual machine.
type VirtualUSBControllerPciBusSlotInfo struct {
	VirtualDevicePciBusSlotInfo

	// The pci slot number of eHCI controller.
	//
	// This property should be used only when the ehciEnabled property
	// is set to true.
	EhciPciSlotNumber int32 `xml:"ehciPciSlotNumber,omitempty" json:"ehciPciSlotNumber,omitempty"`
}

func init() {
	t["VirtualUSBControllerPciBusSlotInfo"] = reflect.TypeOf((*VirtualUSBControllerPciBusSlotInfo)(nil)).Elem()
}

// The `VirtualUSBOption` data object type contains options for
// USB device configuration on a virtual machine.
//
// The vSphere API supports
// the following options:
//   - Local host USB connection
//     (`VirtualUSBUSBBackingOption`)
//   - Remote host USB connection
//     (`VirtualUSBRemoteHostBackingOption`)
//
// For information about USB device configuration, see `VirtualUSB`.
type VirtualUSBOption struct {
	VirtualDeviceOption
}

func init() {
	t["VirtualUSBOption"] = reflect.TypeOf((*VirtualUSBOption)(nil)).Elem()
}

// The virtual remote client USB device backing class.
type VirtualUSBRemoteClientBackingInfo struct {
	VirtualDeviceRemoteDeviceBackingInfo

	// Hostname of the remote client where the physical USB device resides.
	Hostname string `xml:"hostname" json:"hostname"`
}

func init() {
	t["VirtualUSBRemoteClientBackingInfo"] = reflect.TypeOf((*VirtualUSBRemoteClientBackingInfo)(nil)).Elem()
}

// This data object type contains the options for
// the virtual remote USB client backing data object type.
type VirtualUSBRemoteClientBackingOption struct {
	VirtualDeviceRemoteDeviceBackingOption
}

func init() {
	t["VirtualUSBRemoteClientBackingOption"] = reflect.TypeOf((*VirtualUSBRemoteClientBackingOption)(nil)).Elem()
}

// The `VirtualUSBRemoteHostBackingInfo` data object
// identifies a host and a USB device that is attached to the host.
//
// Use this object to configure support for persistent access to the USB device
// when vMotion operations migrate a virtual machine to a different host.
// The vCenter Server will not migrate the virtual machine to a host
// that does not support the USB remote host backing capability.
//
// Specify remote host backing as part of the USB device configuration
// when you create or reconfigure a virtual machine
// (`VirtualMachineConfigSpec*.*VirtualMachineConfigSpec.deviceChange*.*VirtualDeviceConfigSpec.device*.*VirtualDevice.backing`).
//
// To identify the USB device, you specify an autoconnect pattern
// for the `VirtualDeviceDeviceBackingInfo.deviceName`.
// The virtual machine can connect to the USB device if the ESX server
// can find a USB device described by the autoconnect pattern.
// The autoconnect pattern consists of name:value pairs. You can
// use any combination of the following fields.
//   - path - USB connection path on the host
//   - pid - idProduct field in the USB device descriptor
//   - vid - idVendor field in the USB device descriptor
//   - hostId - unique ID for the host
//   - speed - device speed (low, full, or high)
//
// For example, the following pattern identifies a USB device:
//
// &nbsp;&nbsp;&nbsp;&nbsp;<code>"path:1/3/0 hostId:44\\ 45\\ 4c\\ 43\\ 00\\ 10\\ 54-80\\ 35\\ ca\\ c0\\ 4f\\ 4d\\ 37\\ 31"</code>
//
// This pattern identifies the USB device connected to port 1/3/0 on the
// host with the unique id <code>0x44454c4c430010548035cac04f4d3731</code>.
//
// Special characters for autoconnect pattern values:
//   - The name and value are separated by a colon (:).
//   - Name:value pairs are separated by spaces.
//   - The escape character is a backslash (\\). Use a single backslash to embed
//     a space in a value. Use a double blackslash to embed a single backslash
//     in the value.
type VirtualUSBRemoteHostBackingInfo struct {
	VirtualDeviceDeviceBackingInfo

	// Name of the ESX host to which the physical USB device is attached
	// (`HostSystem*.*ManagedEntity.name`).
	//
	// When you configure remote host backing, hostname must identify
	// the local host on which the virtual machine is running.
	Hostname string `xml:"hostname" json:"hostname"`
}

func init() {
	t["VirtualUSBRemoteHostBackingInfo"] = reflect.TypeOf((*VirtualUSBRemoteHostBackingInfo)(nil)).Elem()
}

// The `VirtualUSBRemoteHostBackingOption` data object
// contains options for remote host USB configuration.
//
// This backing option
// indicates support for persistent USB connections when vMotion operations
// migrate virtual machines to different hosts.
type VirtualUSBRemoteHostBackingOption struct {
	VirtualDeviceDeviceBackingOption
}

func init() {
	t["VirtualUSBRemoteHostBackingOption"] = reflect.TypeOf((*VirtualUSBRemoteHostBackingOption)(nil)).Elem()
}

// The `VirtualUSBUSBBackingInfo` data object
// identifies a USB device on the host where the virtual machine
// is located.
//
// This type of backing supports only a local connection
// where the virtual machine will remain on the host to which the
// USB device is attached.
//
// To identify the USB device, you specify an autoconnect pattern
// for the `VirtualDeviceDeviceBackingInfo.deviceName`.
// The virtual machine can connect to the USB device if the ESX server
// can find a USB device described by the autoconnect pattern.
// The autoconnect pattern consists of name:value pairs. You can
// use any combination of the following fields.
//   - path - USB connection path on the host
//   - pid - idProduct field in the USB device descriptor
//   - vid - idVendor field in the USB device descriptor
//   - hostId - unique ID for the host
//   - speed - device speed (low, full, or high)
//
// For example, the following pattern identifies a USB device:
//
// &nbsp;&nbsp;&nbsp;&nbsp;<code>"path:1/3/0 hostId:44\\ 45\\ 4c\\ 43\\ 00\\ 10\\ 54-80\\ 35\\ ca\\ c0\\ 4f\\ 4d\\ 37\\ 31"</code>
//
// This pattern identifies the USB device connected to port 1/3/0 on the
// host with the unique id <code>0x44454c4c430010548035cac04f4d3731</code>.
//
// Special characters for autoconnect pattern values:
//   - The name and value are separated by a colon (:).
//   - Name:value pairs are separated by spaces.
//   - The escape character is a backslash (\\). Use a single backslash to embed
//     a space in a value. Use a double blackslash to embed a single backslash
//     in the value.
type VirtualUSBUSBBackingInfo struct {
	VirtualDeviceDeviceBackingInfo
}

func init() {
	t["VirtualUSBUSBBackingInfo"] = reflect.TypeOf((*VirtualUSBUSBBackingInfo)(nil)).Elem()
}

// The `VirtualUSBUSBBackingOption` data object
// contains the options for virtual backing for a USB device.
//
// This backing option indicates support for a local connection where
// the virtual machine will remain on the host to which the USB device
// is attached.
type VirtualUSBUSBBackingOption struct {
	VirtualDeviceDeviceBackingOption
}

func init() {
	t["VirtualUSBUSBBackingOption"] = reflect.TypeOf((*VirtualUSBUSBBackingOption)(nil)).Elem()
}

// The `VirtualUSBXHCIController` data object describes a virtual
// USB Extensible Host Controller Interface (USB 3.0).
//
// For more informatino see `VirtualUSBController`.
type VirtualUSBXHCIController struct {
	VirtualController

	// Flag to indicate whether or not the ability to hot plug devices
	// is enabled on this controller.
	AutoConnectDevices *bool `xml:"autoConnectDevices" json:"autoConnectDevices,omitempty"`
}

func init() {
	t["VirtualUSBXHCIController"] = reflect.TypeOf((*VirtualUSBXHCIController)(nil)).Elem()
}

// The VirtualUSBXHCIControllerOption data object type contains the options
// for a virtual USB Extensible Host Controller Interface (USB 3.0).
type VirtualUSBXHCIControllerOption struct {
	VirtualControllerOption

	// Flag to indicate whether or not the ability to autoconnect devices
	// is enabled for this virtual USB controller.
	AutoConnectDevices BoolOption `xml:"autoConnectDevices" json:"autoConnectDevices"`
	// Range of USB device speeds supported by this USB controller type.
	//
	// Acceptable values are specified at `VirtualMachineUsbInfoSpeed_enum`.
	SupportedSpeeds []string `xml:"supportedSpeeds" json:"supportedSpeeds"`
}

func init() {
	t["VirtualUSBXHCIControllerOption"] = reflect.TypeOf((*VirtualUSBXHCIControllerOption)(nil)).Elem()
}

// This data object type contains the options for the
// `VirtualVMIROM` data object type.
type VirtualVMIROMOption struct {
	VirtualDeviceOption
}

func init() {
	t["VirtualVMIROMOption"] = reflect.TypeOf((*VirtualVMIROMOption)(nil)).Elem()
}

// This data object type contains the options for the
// `VirtualVideoCard` data object type.
type VirtualVideoCardOption struct {
	VirtualDeviceOption

	// Minimum, maximum and default size of the video frame buffer.
	VideoRamSizeInKB *LongOption `xml:"videoRamSizeInKB,omitempty" json:"videoRamSizeInKB,omitempty"`
	// Minimum, maximum and default value for the number of displays.
	NumDisplays *IntOption `xml:"numDisplays,omitempty" json:"numDisplays,omitempty"`
	// Flag to indicate whether the display settings of the host should
	// be used to automatically determine the display settings of the
	// virtual machine's video card.
	UseAutoDetect *BoolOption `xml:"useAutoDetect,omitempty" json:"useAutoDetect,omitempty"`
	// Flag to indicate whether the virtual video card supports 3D functions.
	Support3D *BoolOption `xml:"support3D,omitempty" json:"support3D,omitempty"`
	// Flag to indicate whether the virtual video card can specify how to render 3D graphics.
	Use3dRendererSupported *BoolOption `xml:"use3dRendererSupported,omitempty" json:"use3dRendererSupported,omitempty"`
	// The minimum, maximum, and default values for graphics memory size.
	GraphicsMemorySizeInKB *LongOption `xml:"graphicsMemorySizeInKB,omitempty" json:"graphicsMemorySizeInKB,omitempty"`
	// Flag to indicate whether the virtual video card can specify the size
	// of graphics memory.
	GraphicsMemorySizeSupported *BoolOption `xml:"graphicsMemorySizeSupported,omitempty" json:"graphicsMemorySizeSupported,omitempty"`
}

func init() {
	t["VirtualVideoCardOption"] = reflect.TypeOf((*VirtualVideoCardOption)(nil)).Elem()
}

// The VirtualVmxnet data object type represents an instance
// of the Vmxnet virtual Ethernet adapter attached to a virtual machine.
type VirtualVmxnet struct {
	VirtualEthernetCard
}

func init() {
	t["VirtualVmxnet"] = reflect.TypeOf((*VirtualVmxnet)(nil)).Elem()
}

// The VirtualVmxnet2 data object type represents an instance
// of the Vmxnet2 virtual Ethernet adapter attached to a virtual machine.
type VirtualVmxnet2 struct {
	VirtualVmxnet
}

func init() {
	t["VirtualVmxnet2"] = reflect.TypeOf((*VirtualVmxnet2)(nil)).Elem()
}

// The VirtualVmxnet2Option data object type contains the options for the
// `VirtualVmxnet2` data object type.
type VirtualVmxnet2Option struct {
	VirtualVmxnetOption
}

func init() {
	t["VirtualVmxnet2Option"] = reflect.TypeOf((*VirtualVmxnet2Option)(nil)).Elem()
}

// The VirtualVmxnet3 data object type represents an instance
// of the Vmxnet3 virtual Ethernet adapter attached to a virtual machine.
type VirtualVmxnet3 struct {
	VirtualVmxnet

	// Indicates whether UPTv2(Uniform Pass-through version 2) compatibility is
	// enabled on this network adapter.
	//
	// UPTv2 is only available on Vmxnet3
	// adapter. Clients can set this property enabled or disabled if ethernet
	// virtual device is Vmxnet3. It requires the VM hardware version is
	// compatible with ESXi version which has enabled smartnic feature.
	Uptv2Enabled *bool `xml:"uptv2Enabled" json:"uptv2Enabled,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VirtualVmxnet3"] = reflect.TypeOf((*VirtualVmxnet3)(nil)).Elem()
}

// The VirtualVmxnet3Option data object type contains the options for the
// `VirtualVmxnet3` data object type.
type VirtualVmxnet3Option struct {
	VirtualVmxnetOption

	// Flag to indicate whether UPTv2(Uniform Pass-through version 2) is
	// settable on this device.
	Uptv2Enabled *BoolOption `xml:"uptv2Enabled,omitempty" json:"uptv2Enabled,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VirtualVmxnet3Option"] = reflect.TypeOf((*VirtualVmxnet3Option)(nil)).Elem()
}

// The VirtualVmxnet3Vrdma data object type represents an instance of the
// VRDMA virtual Remote Direct Memory Access adapter attached to a virtual
// machine.
type VirtualVmxnet3Vrdma struct {
	VirtualVmxnet3

	// VRDMA Device protocol.
	//
	// See
	// `VirtualVmxnet3VrdmaOptionDeviceProtocols_enum` for more information.
	DeviceProtocol string `xml:"deviceProtocol,omitempty" json:"deviceProtocol,omitempty"`
}

func init() {
	t["VirtualVmxnet3Vrdma"] = reflect.TypeOf((*VirtualVmxnet3Vrdma)(nil)).Elem()
}

// The VirtualVmxnet3VrdmaOption data object type contains the options for the
// `VirtualVmxnet3Vrdma` data object type.
type VirtualVmxnet3VrdmaOption struct {
	VirtualVmxnet3Option

	// The supported device protocols.
	DeviceProtocol *ChoiceOption `xml:"deviceProtocol,omitempty" json:"deviceProtocol,omitempty"`
}

func init() {
	t["VirtualVmxnet3VrdmaOption"] = reflect.TypeOf((*VirtualVmxnet3VrdmaOption)(nil)).Elem()
}

// The VirtualVmxnetOption data object type contains the options for the
// `VirtualVmxnet` data object type.
type VirtualVmxnetOption struct {
	VirtualEthernetCardOption
}

func init() {
	t["VirtualVmxnetOption"] = reflect.TypeOf((*VirtualVmxnetOption)(nil)).Elem()
}

// This data object type represents a watchdog timer in a virtual machine.
type VirtualWDT struct {
	VirtualDevice

	// Flag to indicate if the virtual watchdog timer device should be
	// initialized as the Enabled/Stopped or Enabled/Running sub-state.
	//
	// If not set, the device will default to being initialized as the
	// Enabled/Stopped sub-state.
	RunOnBoot bool `xml:"runOnBoot" json:"runOnBoot"`
	// Flag to indicate if the virtual watchdog timer device is currently
	// in the Enabled/Running state.
	//
	// The guest can cause state changes,
	// which will result in this flag being either set or cleared.
	Running bool `xml:"running" json:"running"`
}

func init() {
	t["VirtualWDT"] = reflect.TypeOf((*VirtualWDT)(nil)).Elem()
}

// This data object type contains the options for the
// virtual watchdog timer class.
type VirtualWDTOption struct {
	VirtualDeviceOption

	// Flag to indicate whether or not the "run on boot" option
	// is settable on this device.
	RunOnBoot BoolOption `xml:"runOnBoot" json:"runOnBoot"`
}

func init() {
	t["VirtualWDTOption"] = reflect.TypeOf((*VirtualWDTOption)(nil)).Elem()
}

// The `VlanProfile` data object represents
// the VLAN identifier subprofile.
//
// The `ApplyProfile.policy`
// property contains the configuration data values for the VLAN identifier.
type VlanProfile struct {
	ApplyProfile
}

func init() {
	t["VlanProfile"] = reflect.TypeOf((*VlanProfile)(nil)).Elem()
}

// This event records a user successfully acquiring an MKS ticket
type VmAcquiredMksTicketEvent struct {
	VmEvent
}

func init() {
	t["VmAcquiredMksTicketEvent"] = reflect.TypeOf((*VmAcquiredMksTicketEvent)(nil)).Elem()
}

// This event records a user successfully acquiring a ticket
type VmAcquiredTicketEvent struct {
	VmEvent

	// The type of the ticket @see VirtualMachine.TicketType
	TicketType string `xml:"ticketType" json:"ticketType"`
}

func init() {
	t["VmAcquiredTicketEvent"] = reflect.TypeOf((*VmAcquiredTicketEvent)(nil)).Elem()
}

// Fault thrown when moving a standalone host between datacenters, and
// one or more of the virtual machines registered on the host are already
// registered to hosts in the target datacenter.
type VmAlreadyExistsInDatacenter struct {
	InvalidFolder

	// The target host.
	//
	// Refers instance of `HostSystem`.
	Host ManagedObjectReference `xml:"host" json:"host"`
	// Name of the target host.
	Hostname string `xml:"hostname" json:"hostname"`
	// Virtual machines in the target datacenter which have the same
	// registration information as those belonging to the target host.
	//
	// Refers instances of `VirtualMachine`.
	Vm []ManagedObjectReference `xml:"vm" json:"vm"`
}

func init() {
	t["VmAlreadyExistsInDatacenter"] = reflect.TypeOf((*VmAlreadyExistsInDatacenter)(nil)).Elem()
}

type VmAlreadyExistsInDatacenterFault VmAlreadyExistsInDatacenter

func init() {
	t["VmAlreadyExistsInDatacenterFault"] = reflect.TypeOf((*VmAlreadyExistsInDatacenterFault)(nil)).Elem()
}

// This event records that a virtual machine was automatically renamed
// because of a name conflict.
type VmAutoRenameEvent struct {
	VmEvent

	// The name of the virtual machine before renaming.
	OldName string `xml:"oldName" json:"oldName"`
	// The name of the virtual machine after renaming.
	NewName string `xml:"newName" json:"newName"`
}

func init() {
	t["VmAutoRenameEvent"] = reflect.TypeOf((*VmAutoRenameEvent)(nil)).Elem()
}

// This event records a virtual machine being cloned.
type VmBeingClonedEvent struct {
	VmCloneEvent

	// The destination folder to which the virtual machine is being cloned.
	DestFolder FolderEventArgument `xml:"destFolder" json:"destFolder"`
	// The name of the destination virtual machine.
	DestName string `xml:"destName" json:"destName"`
	// The destination host to which the virtual machine is being cloned.
	DestHost HostEventArgument `xml:"destHost" json:"destHost"`
}

func init() {
	t["VmBeingClonedEvent"] = reflect.TypeOf((*VmBeingClonedEvent)(nil)).Elem()
}

// This event records a virtual machine being cloned.
type VmBeingClonedNoFolderEvent struct {
	VmCloneEvent

	// The name of the destination virtual machine.
	DestName string `xml:"destName" json:"destName"`
	// The destination host to which the virtual machine is being cloned.
	DestHost HostEventArgument `xml:"destHost" json:"destHost"`
}

func init() {
	t["VmBeingClonedNoFolderEvent"] = reflect.TypeOf((*VmBeingClonedNoFolderEvent)(nil)).Elem()
}

// This event records a virtual machine being created.
type VmBeingCreatedEvent struct {
	VmEvent

	// The configuration specification that was used to create this virtual machine.
	ConfigSpec *VirtualMachineConfigSpec `xml:"configSpec,omitempty" json:"configSpec,omitempty"`
}

func init() {
	t["VmBeingCreatedEvent"] = reflect.TypeOf((*VmBeingCreatedEvent)(nil)).Elem()
}

// This event records a virtual machine being deployed from a template.
type VmBeingDeployedEvent struct {
	VmEvent

	// The template object from which the virtual machine is being deployed.
	SrcTemplate VmEventArgument `xml:"srcTemplate" json:"srcTemplate"`
}

func init() {
	t["VmBeingDeployedEvent"] = reflect.TypeOf((*VmBeingDeployedEvent)(nil)).Elem()
}

// This event records that a virtual machine is being hot-migrated.
type VmBeingHotMigratedEvent struct {
	VmEvent

	// The destination host to which the virtual machine is to be migrated.
	DestHost HostEventArgument `xml:"destHost" json:"destHost"`
	// The destination datacenter to which the virtual machine is being migrated
	DestDatacenter *DatacenterEventArgument `xml:"destDatacenter,omitempty" json:"destDatacenter,omitempty"`
	// The destination primary datastore to which the virtual machine is being migrated
	DestDatastore *DatastoreEventArgument `xml:"destDatastore,omitempty" json:"destDatastore,omitempty"`
}

func init() {
	t["VmBeingHotMigratedEvent"] = reflect.TypeOf((*VmBeingHotMigratedEvent)(nil)).Elem()
}

// This event records that a virtual machine is being migrated.
type VmBeingMigratedEvent struct {
	VmEvent

	// The destination host.
	DestHost HostEventArgument `xml:"destHost" json:"destHost"`
	// The destination datacenter
	DestDatacenter *DatacenterEventArgument `xml:"destDatacenter,omitempty" json:"destDatacenter,omitempty"`
	// The destination primary datastore
	DestDatastore *DatastoreEventArgument `xml:"destDatastore,omitempty" json:"destDatastore,omitempty"`
}

func init() {
	t["VmBeingMigratedEvent"] = reflect.TypeOf((*VmBeingMigratedEvent)(nil)).Elem()
}

// This event records that a virtual machine is being relocated.
type VmBeingRelocatedEvent struct {
	VmRelocateSpecEvent

	// The destination host to which the virtual machine is being relocated.
	DestHost HostEventArgument `xml:"destHost" json:"destHost"`
	// The destination datacenter to which the virtual machine is being relocated
	DestDatacenter *DatacenterEventArgument `xml:"destDatacenter,omitempty" json:"destDatacenter,omitempty"`
	// The destination primary datastore to which the virtual machine is being relocated
	DestDatastore *DatastoreEventArgument `xml:"destDatastore,omitempty" json:"destDatastore,omitempty"`
}

func init() {
	t["VmBeingRelocatedEvent"] = reflect.TypeOf((*VmBeingRelocatedEvent)(nil)).Elem()
}

// The is the base event for all clone operations.
type VmCloneEvent struct {
	VmEvent
}

func init() {
	t["VmCloneEvent"] = reflect.TypeOf((*VmCloneEvent)(nil)).Elem()
}

// This event records a failure to clone a virtual machine.
type VmCloneFailedEvent struct {
	VmCloneEvent

	// The destination folder to which the virtual machine is being cloned.
	DestFolder FolderEventArgument `xml:"destFolder" json:"destFolder"`
	// The name of the destination virtual machine.
	DestName string `xml:"destName" json:"destName"`
	// The destination host to which the virtual machine was being cloned.
	DestHost HostEventArgument `xml:"destHost" json:"destHost"`
	// The reason why this clone operation failed.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["VmCloneFailedEvent"] = reflect.TypeOf((*VmCloneFailedEvent)(nil)).Elem()
}

// This event records the completion of a virtual machine cloning operation.
type VmClonedEvent struct {
	VmCloneEvent

	// The source virtual machine for the clone operation.
	SourceVm VmEventArgument `xml:"sourceVm" json:"sourceVm"`
}

func init() {
	t["VmClonedEvent"] = reflect.TypeOf((*VmClonedEvent)(nil)).Elem()
}

// Base for configuration / environment issues that can be thrown when powering on or
// changing the configuration of a virtual machine.
//
// Subclasses of this fault is also
// used as recent why a migration can fail.
type VmConfigFault struct {
	VimFault
}

func init() {
	t["VmConfigFault"] = reflect.TypeOf((*VmConfigFault)(nil)).Elem()
}

type VmConfigFaultFault BaseVmConfigFault

func init() {
	t["VmConfigFaultFault"] = reflect.TypeOf((*VmConfigFaultFault)(nil)).Elem()
}

// The encryption information of a virtual machine configuration.
type VmConfigFileEncryptionInfo struct {
	DynamicData

	// The key identifier for an encrypted virtual machine
	// configuration file.
	//
	// If the virtual machine configuration file is encrypted, then
	// the keyId is set and indicates the identifier that can be
	// used to lookup the key material. Unset if the virtual machine
	// configuration file is not encrypted.
	KeyId *CryptoKeyId `xml:"keyId,omitempty" json:"keyId,omitempty"`
}

func init() {
	t["VmConfigFileEncryptionInfo"] = reflect.TypeOf((*VmConfigFileEncryptionInfo)(nil)).Elem()
}

// This data object type describes a virtual machine configuration file.
type VmConfigFileInfo struct {
	FileInfo

	ConfigVersion int32 `xml:"configVersion,omitempty" json:"configVersion,omitempty"`
	// The encryption information of the virtual machine
	// configuration file.
	//
	// If encryption was selected in VmConfigFileQueryFlags then this
	// field is always set. Inspect the VmConfigEncryptionInfo to
	// determine if the virtual machine configuration file is encrypted.
	Encryption *VmConfigFileEncryptionInfo `xml:"encryption,omitempty" json:"encryption,omitempty"`
}

func init() {
	t["VmConfigFileInfo"] = reflect.TypeOf((*VmConfigFileInfo)(nil)).Elem()
}

// This data object type describes query specification for the virtual machine
// configuration file.
type VmConfigFileQuery struct {
	FileQuery

	// The filter specification for the virtual machine configuration file query.
	Filter *VmConfigFileQueryFilter `xml:"filter,omitempty" json:"filter,omitempty"`
	// The details specification for the virtual machine configuration file query.
	Details *VmConfigFileQueryFlags `xml:"details,omitempty" json:"details,omitempty"`
}

func init() {
	t["VmConfigFileQuery"] = reflect.TypeOf((*VmConfigFileQuery)(nil)).Elem()
}

// The filter for the virtual machine configuration file.
type VmConfigFileQueryFilter struct {
	DynamicData

	// If this property is set, only the virtual machine configuration files that
	// match one of the specified configuration versions are selected.
	//
	// If no
	// versions are specified, this search criteria is ignored.
	MatchConfigVersion []int32 `xml:"matchConfigVersion,omitempty" json:"matchConfigVersion,omitempty"`
	// This optional property can be used to filter virtual
	// machine configuration files based on whether they are
	// encrypted or not.
	Encrypted *bool `xml:"encrypted" json:"encrypted,omitempty"`
}

func init() {
	t["VmConfigFileQueryFilter"] = reflect.TypeOf((*VmConfigFileQueryFilter)(nil)).Elem()
}

type VmConfigFileQueryFlags struct {
	DynamicData

	// The flag to indicate whether or not the configuration file version number is
	// returned.
	ConfigVersion bool `xml:"configVersion" json:"configVersion"`
	// The flag to indicate whether the encryption information of the
	// virtual machine configuration is returned.
	Encryption *bool `xml:"encryption" json:"encryption,omitempty"`
}

func init() {
	t["VmConfigFileQueryFlags"] = reflect.TypeOf((*VmConfigFileQueryFlags)(nil)).Elem()
}

// Thrown when a virtual machine's existing or requested configuration is
// incompatible for fault tolerance.
type VmConfigIncompatibleForFaultTolerance struct {
	VmConfigFault

	// Fault indicating the specific configuration issue.
	//
	// This is typically
	// a subclass of VirtualHardwareCompatibilityIssue.
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["VmConfigIncompatibleForFaultTolerance"] = reflect.TypeOf((*VmConfigIncompatibleForFaultTolerance)(nil)).Elem()
}

type VmConfigIncompatibleForFaultToleranceFault VmConfigIncompatibleForFaultTolerance

func init() {
	t["VmConfigIncompatibleForFaultToleranceFault"] = reflect.TypeOf((*VmConfigIncompatibleForFaultToleranceFault)(nil)).Elem()
}

// Deprecated as of vSphere API 6.0.
//
// Thrown when a virtual machine's existing or requested configuration is
// incompatible for record and replay.
type VmConfigIncompatibleForRecordReplay struct {
	VmConfigFault

	// Fault indicating the specific configuration issue.
	//
	// This is typically
	// a subclass of VirtualHardwareCompatibilityIssue.
	Fault *LocalizedMethodFault `xml:"fault,omitempty" json:"fault,omitempty"`
}

func init() {
	t["VmConfigIncompatibleForRecordReplay"] = reflect.TypeOf((*VmConfigIncompatibleForRecordReplay)(nil)).Elem()
}

type VmConfigIncompatibleForRecordReplayFault VmConfigIncompatibleForRecordReplay

func init() {
	t["VmConfigIncompatibleForRecordReplayFault"] = reflect.TypeOf((*VmConfigIncompatibleForRecordReplayFault)(nil)).Elem()
}

// VM Configuration.
type VmConfigInfo struct {
	DynamicData

	// Information about the package content.
	Product []VAppProductInfo `xml:"product,omitempty" json:"product,omitempty"`
	// List of properties
	Property []VAppPropertyInfo `xml:"property,omitempty" json:"property,omitempty"`
	// IP assignment policy and DHCP support configuration.
	IpAssignment VAppIPAssignmentInfo `xml:"ipAssignment" json:"ipAssignment"`
	// End User Liceses Agreements.
	Eula []string `xml:"eula,omitempty" json:"eula,omitempty"`
	// List of uninterpreted OVF meta-data sections.
	OvfSection []VAppOvfSectionInfo `xml:"ovfSection,omitempty" json:"ovfSection,omitempty"`
	// List the transports to use for properties.
	//
	// Supported values are: iso and
	// com.vmware.guestInfo.
	OvfEnvironmentTransport []string `xml:"ovfEnvironmentTransport,omitempty" json:"ovfEnvironmentTransport,omitempty"`
	// Specifies whether the VM needs an initial boot before the deployment is complete.
	//
	// Not relevant for vApps. This means that the value is always false when reading the
	// configuration and is ignored when setting the configuration.
	//
	// If a vApp requires an install boot (because one of its VMs does), this is visible
	// on the `VirtualAppSummary.installBootRequired` field of the vApp.
	InstallBootRequired bool `xml:"installBootRequired" json:"installBootRequired"`
	// Specifies the delay in seconds to wait for the VM to power off after the initial
	// boot (used only if installBootRequired is true).
	//
	// A value of 0 means wait forever.
	//
	// Not relevant for vApps. This means that the value is always false when reading the
	// configuration and is ignored when setting the configuration.
	InstallBootStopDelay int32 `xml:"installBootStopDelay" json:"installBootStopDelay"`
}

func init() {
	t["VmConfigInfo"] = reflect.TypeOf((*VmConfigInfo)(nil)).Elem()
}

// This event records if the configuration file can not be found.
type VmConfigMissingEvent struct {
	VmEvent
}

func init() {
	t["VmConfigMissingEvent"] = reflect.TypeOf((*VmConfigMissingEvent)(nil)).Elem()
}

// vApp related configuration of a VM.
type VmConfigSpec struct {
	DynamicData

	// Information about the product.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Product []VAppProductSpec `xml:"product,omitempty" json:"product,omitempty"`
	// List of properties.
	//
	// Adding and editing properties requires various privileges depending on which fields
	// are affected. See `VAppPropertyInfo` for details.
	//
	// Deleting properties requires the privilege VApp.ApplicationConfig.
	Property []VAppPropertySpec `xml:"property,omitempty" json:"property,omitempty"`
	// IP assignment policy and DHCP support configuration.
	//
	// Reconfigure privilege: See `VAppIPAssignmentInfo`
	IpAssignment *VAppIPAssignmentInfo `xml:"ipAssignment,omitempty" json:"ipAssignment,omitempty"`
	// End User Liceses Agreements.
	//
	// If this list is set, it replaces all exiting licenses. An empty list will not
	// make any changes to installed licenses. A list with a single element {""} will
	// remove all licenses and leave an empty list.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	Eula []string `xml:"eula,omitempty" json:"eula,omitempty"`
	// List of uninterpreted OVF meta-data sections.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	OvfSection []VAppOvfSectionSpec `xml:"ovfSection,omitempty" json:"ovfSection,omitempty"`
	// List the transports to use for properties.
	//
	// Supported values are: iso and
	// com.vmware.guestInfo.
	//
	// If this list is set, it replaces all exiting entries. An empty list will not make
	// any changes. A list with a single element {""} will clear the list of transports.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	OvfEnvironmentTransport []string `xml:"ovfEnvironmentTransport,omitempty" json:"ovfEnvironmentTransport,omitempty"`
	// If this is on a VirtualMachine object, it specifies whether the VM needs an
	// initial boot before the deployment is complete.
	//
	// If this is on a vApp object,
	// it indicates than one or more VMs needs an initial reboot. This flag is
	// automatically reset once the reboot has happened.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	InstallBootRequired *bool `xml:"installBootRequired" json:"installBootRequired,omitempty"`
	// Specifies the delay in seconds to wait for the VM to power off after the initial
	// boot (used only if installBootRequired is true).
	//
	// A value of 0 means wait forever.
	//
	// Reconfigure privilege: VApp.ApplicationConfig
	InstallBootStopDelay int32 `xml:"installBootStopDelay,omitempty" json:"installBootStopDelay,omitempty"`
}

func init() {
	t["VmConfigSpec"] = reflect.TypeOf((*VmConfigSpec)(nil)).Elem()
}

// This event records that a virtual machine is connected.
type VmConnectedEvent struct {
	VmEvent
}

func init() {
	t["VmConnectedEvent"] = reflect.TypeOf((*VmConnectedEvent)(nil)).Elem()
}

// This event records that a virtual machine was successfully created.
type VmCreatedEvent struct {
	VmEvent
}

func init() {
	t["VmCreatedEvent"] = reflect.TypeOf((*VmCreatedEvent)(nil)).Elem()
}

// This event records when a virtual machine is reset by
// HA VM Health Monitoring on hosts that do not support the
// create screenshot api or if the createscreenshot api fails.
type VmDasBeingResetEvent struct {
	VmEvent

	// The reason why this vm is being reset
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["VmDasBeingResetEvent"] = reflect.TypeOf((*VmDasBeingResetEvent)(nil)).Elem()
}

// This event records when a virtual machine is reset by
// HA VM Health Monitoring on hosts that support the create screenshot api
type VmDasBeingResetWithScreenshotEvent struct {
	VmDasBeingResetEvent

	// The datastore path of the screenshot taken before resetting.
	ScreenshotFilePath string `xml:"screenshotFilePath" json:"screenshotFilePath"`
}

func init() {
	t["VmDasBeingResetWithScreenshotEvent"] = reflect.TypeOf((*VmDasBeingResetWithScreenshotEvent)(nil)).Elem()
}

// This event records when HA VM Health Monitoring fails to reset
// a virtual machine after failure
type VmDasResetFailedEvent struct {
	VmEvent
}

func init() {
	t["VmDasResetFailedEvent"] = reflect.TypeOf((*VmDasResetFailedEvent)(nil)).Elem()
}

// The event records that an error occurred when updating the HA agents
// with the current state of the virtual machine.
//
// If this occurs during a
// powerOn operation, the virtual machine will not be failed over in the
// event of a host failure. If it occurs during a powerOff, the virtual
// machine will be automatically powered on if the host it was last running
// on crashes.
type VmDasUpdateErrorEvent struct {
	VmEvent
}

func init() {
	t["VmDasUpdateErrorEvent"] = reflect.TypeOf((*VmDasUpdateErrorEvent)(nil)).Elem()
}

// This event records that HA agents have been updated with the current
// state of the virtual machine.
type VmDasUpdateOkEvent struct {
	VmEvent
}

func init() {
	t["VmDasUpdateOkEvent"] = reflect.TypeOf((*VmDasUpdateOkEvent)(nil)).Elem()
}

// This event records when the VirtualCenter server date rolled back.
type VmDateRolledBackEvent struct {
	VmEvent
}

func init() {
	t["VmDateRolledBackEvent"] = reflect.TypeOf((*VmDateRolledBackEvent)(nil)).Elem()
}

// This event records a failure to deploy from a template.
type VmDeployFailedEvent struct {
	VmEvent

	// The destination datastore to which the template was being deployed.
	DestDatastore BaseEntityEventArgument `xml:"destDatastore,typeattr" json:"destDatastore"`
	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["VmDeployFailedEvent"] = reflect.TypeOf((*VmDeployFailedEvent)(nil)).Elem()
}

// This event records the completion of a virtual machine deployment operation.
type VmDeployedEvent struct {
	VmEvent

	// The template object from which the virtual machine has been deployed.
	SrcTemplate VmEventArgument `xml:"srcTemplate" json:"srcTemplate"`
}

func init() {
	t["VmDeployedEvent"] = reflect.TypeOf((*VmDeployedEvent)(nil)).Elem()
}

// This event records that a virtual machine disconnected.
type VmDisconnectedEvent struct {
	VmEvent
}

func init() {
	t["VmDisconnectedEvent"] = reflect.TypeOf((*VmDisconnectedEvent)(nil)).Elem()
}

// This event records a virtual machine discovery.
type VmDiscoveredEvent struct {
	VmEvent
}

func init() {
	t["VmDiscoveredEvent"] = reflect.TypeOf((*VmDiscoveredEvent)(nil)).Elem()
}

// This event records a failure to create a virtual disk in a virtual machine.
type VmDiskFailedEvent struct {
	VmEvent

	// The name of the virtual disk.
	Disk string `xml:"disk" json:"disk"`
	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["VmDiskFailedEvent"] = reflect.TypeOf((*VmDiskFailedEvent)(nil)).Elem()
}

// The encryption information of a virtual disk.
type VmDiskFileEncryptionInfo struct {
	DynamicData

	// The key identifier for an encrypted virtual disk.
	//
	// If the virtual disk is encrypted, then the keyId is set and
	// indicates the identifier that can be used to lookup the key
	// material. Unset if the virtual disk is not encrypted.
	KeyId *CryptoKeyId `xml:"keyId,omitempty" json:"keyId,omitempty"`
}

func init() {
	t["VmDiskFileEncryptionInfo"] = reflect.TypeOf((*VmDiskFileEncryptionInfo)(nil)).Elem()
}

// This data object type describes a virtual disk primary file.
type VmDiskFileInfo struct {
	FileInfo

	// Disk type of the virtual disk.
	//
	// The specified disk type is one of the backing information types for a virtual
	// disk.
	//
	// See also `VirtualDisk`.
	DiskType string `xml:"diskType,omitempty" json:"diskType,omitempty"`
	// The capacity of a virtual disk from the point of view of a virtual machine.
	CapacityKb int64 `xml:"capacityKb,omitempty" json:"capacityKb,omitempty"`
	// The hardware version of the virtual disk file.
	HardwareVersion int32 `xml:"hardwareVersion,omitempty" json:"hardwareVersion,omitempty"`
	// Deprecated as of vSphere API 5.0, this property is no longer
	// relevant and should not be used.
	// With the current state of emulation, we don't care about the
	// adapter type a disk is connected to, as disks may be shuffled
	// around. For example, a disk may be unplugged from a buslogic
	// controller and plugged into an lsilogic controller.
	//
	// The controller type suitable for this virtual disk.
	ControllerType string `xml:"controllerType,omitempty" json:"controllerType,omitempty"`
	// The extents of this virtual disk specified in absolute DS paths
	DiskExtents []string `xml:"diskExtents,omitempty" json:"diskExtents,omitempty"`
	// Indicates if the disk is thin-provisioned
	Thin *bool `xml:"thin" json:"thin,omitempty"`
	// The encryption information of the virtual disk.
	//
	// If encryption was selected in VmDiskFileQueryFlags then this
	// field is always set. Inspect the VmDiskEncryptionInfo to
	// determine if the virtual disk is encrypted.
	Encryption *VmDiskFileEncryptionInfo `xml:"encryption,omitempty" json:"encryption,omitempty"`
}

func init() {
	t["VmDiskFileInfo"] = reflect.TypeOf((*VmDiskFileInfo)(nil)).Elem()
}

// This data object type describes the query specification for the virtual disk
// primary file.
type VmDiskFileQuery struct {
	FileQuery

	// The filter specification for the virtual disk primary file query.
	Filter *VmDiskFileQueryFilter `xml:"filter,omitempty" json:"filter,omitempty"`
	// Details specification for the virtual disk primary file query.
	Details *VmDiskFileQueryFlags `xml:"details,omitempty" json:"details,omitempty"`
}

func init() {
	t["VmDiskFileQuery"] = reflect.TypeOf((*VmDiskFileQuery)(nil)).Elem()
}

// The filter for the virtual disk primary file.
type VmDiskFileQueryFilter struct {
	DynamicData

	// If this optional property is set, only the virtual disk primary files that
	// match one of the specified disk types are selected.
	//
	// If no disk types are
	// specified, this search criteria is ignored.
	//
	// The specified disk type is one of the backing information types for a
	// virtual disk.
	//
	// See also `VirtualDisk`.
	DiskType []string `xml:"diskType,omitempty" json:"diskType,omitempty"`
	// If this optional property is set, only virtual disk primary files that match
	// one of the specified hardware versions are selected.
	//
	// If no versions are
	// specified, this search criteria is ignored.
	MatchHardwareVersion []int32 `xml:"matchHardwareVersion,omitempty" json:"matchHardwareVersion,omitempty"`
	// Deprecated as of vSphere API 5.0, this property is no longer
	// relevant and should not be used.
	// With the current state of emulation, we don't care about the
	// adapter type a disk is connected to, as disks may be shuffled
	// around. For example, a disk may be unplugged from a buslogic
	// controller and plugged into an lsilogic controller.
	//
	// If this optional property is set, only virtual disk files that have a
	// controller type that matches one of the controller types specified
	// are returned.
	//
	// If no controller types are specified, this search criteria
	// is ignored.
	//
	// The specified controller type is one of the controller types for a
	// virtual disk.
	//
	// See also `VirtualIDEController`, `VirtualSCSIController`.
	ControllerType []string `xml:"controllerType,omitempty" json:"controllerType,omitempty"`
	// This optional property can be used to filter disks based on whether
	// they are thin-provsioned or not: if set to true, only thin-provisioned
	// disks are returned, and vice-versa.
	Thin *bool `xml:"thin" json:"thin,omitempty"`
	// This optional property can be used to filter disks based on
	// whether they are encrypted or not.
	Encrypted *bool `xml:"encrypted" json:"encrypted,omitempty"`
}

func init() {
	t["VmDiskFileQueryFilter"] = reflect.TypeOf((*VmDiskFileQueryFilter)(nil)).Elem()
}

// Details for the virtual disk primary file.
type VmDiskFileQueryFlags struct {
	DynamicData

	// The flag to indicate whether the type of the physical disk backing
	// the virtual disk is returned.
	DiskType bool `xml:"diskType" json:"diskType"`
	// The flag to indicate whether the capacity of the virtual disk from
	// the point of view of a virtual machine is returned.
	CapacityKb bool `xml:"capacityKb" json:"capacityKb"`
	// The flag to indicate whether the hardware version of the virtual disk
	// file is returned.
	HardwareVersion bool `xml:"hardwareVersion" json:"hardwareVersion"`
	// Deprecated as of vSphere API 5.0, this property is no longer
	// relevant and should not be used.
	// With the current state of emulation, we don't care about the
	// adapter type a disk is connected to, as disks may be shuffled
	// around. For example, a disk may be unplugged from a buslogic
	// controller and plugged into an lsilogic controller.
	//
	// The flag to indicate whether or not the controller type of the virtual disk
	// file is returned.
	ControllerType *bool `xml:"controllerType" json:"controllerType,omitempty"`
	// The flag to indicate whether or not the disk extents of the virtual disk
	// are returned.
	DiskExtents *bool `xml:"diskExtents" json:"diskExtents,omitempty"`
	// The flag to indicate whether the thin-ness of the disk is returned.
	Thin *bool `xml:"thin" json:"thin,omitempty"`
	// The flag to indicate whether the encryption information of the
	// virtual disk is returned.
	Encryption *bool `xml:"encryption" json:"encryption,omitempty"`
}

func init() {
	t["VmDiskFileQueryFlags"] = reflect.TypeOf((*VmDiskFileQueryFlags)(nil)).Elem()
}

// This event records a virtual machine emigration.
type VmEmigratingEvent struct {
	VmEvent
}

func init() {
	t["VmEmigratingEvent"] = reflect.TypeOf((*VmEmigratingEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 6.0.
//
// This event indicates the end of a recording session on a virtual machine.
type VmEndRecordingEvent struct {
	VmEvent
}

func init() {
	t["VmEndRecordingEvent"] = reflect.TypeOf((*VmEndRecordingEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 6.0.
//
// This event indicates the end of a replay session on a virtual machine.
type VmEndReplayingEvent struct {
	VmEvent
}

func init() {
	t["VmEndReplayingEvent"] = reflect.TypeOf((*VmEndReplayingEvent)(nil)).Elem()
}

// These are virtual machine events.
type VmEvent struct {
	Event

	// Indicates whether or not the virtual machine is marked as a template.
	Template bool `xml:"template" json:"template"`
}

func init() {
	t["VmEvent"] = reflect.TypeOf((*VmEvent)(nil)).Elem()
}

// The event argument is a VirtualMachine object.
type VmEventArgument struct {
	EntityEventArgument

	// The VirtualMachine object.
	//
	// Refers instance of `VirtualMachine`.
	Vm ManagedObjectReference `xml:"vm" json:"vm"`
}

func init() {
	t["VmEventArgument"] = reflect.TypeOf((*VmEventArgument)(nil)).Elem()
}

// This event records a failure to migrate a virtual machine.
type VmFailedMigrateEvent struct {
	VmEvent

	// The destination host.
	DestHost HostEventArgument `xml:"destHost" json:"destHost"`
	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
	// The destination datacenter
	DestDatacenter *DatacenterEventArgument `xml:"destDatacenter,omitempty" json:"destDatacenter,omitempty"`
	// The destination primary datastore
	DestDatastore *DatastoreEventArgument `xml:"destDatastore,omitempty" json:"destDatastore,omitempty"`
}

func init() {
	t["VmFailedMigrateEvent"] = reflect.TypeOf((*VmFailedMigrateEvent)(nil)).Elem()
}

// This event records a specific failure to relay out a virtual machine,
// such as a failure to access the disk.
type VmFailedRelayoutEvent struct {
	VmEvent

	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["VmFailedRelayoutEvent"] = reflect.TypeOf((*VmFailedRelayoutEvent)(nil)).Elem()
}

// This event records a failure to relay out a virtual machine
// when the virtual machine still has disks on a VMFS2 volume.
type VmFailedRelayoutOnVmfs2DatastoreEvent struct {
	VmEvent
}

func init() {
	t["VmFailedRelayoutOnVmfs2DatastoreEvent"] = reflect.TypeOf((*VmFailedRelayoutOnVmfs2DatastoreEvent)(nil)).Elem()
}

// This event records vmotion failure when starting a secondary VM.
type VmFailedStartingSecondaryEvent struct {
	VmEvent

	// The reason for the failure.
	//
	// See `VmFailedStartingSecondaryEventFailureReason_enum`
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["VmFailedStartingSecondaryEvent"] = reflect.TypeOf((*VmFailedStartingSecondaryEvent)(nil)).Elem()
}

// This event records a failure to power off a virtual machine.
type VmFailedToPowerOffEvent struct {
	VmEvent

	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["VmFailedToPowerOffEvent"] = reflect.TypeOf((*VmFailedToPowerOffEvent)(nil)).Elem()
}

// This event records a failure to power on a virtual machine.
type VmFailedToPowerOnEvent struct {
	VmEvent

	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["VmFailedToPowerOnEvent"] = reflect.TypeOf((*VmFailedToPowerOnEvent)(nil)).Elem()
}

// This event records a failure to reboot the guest on a virtual machine.
type VmFailedToRebootGuestEvent struct {
	VmEvent

	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["VmFailedToRebootGuestEvent"] = reflect.TypeOf((*VmFailedToRebootGuestEvent)(nil)).Elem()
}

// This event records a failure to reset a virtual machine.
type VmFailedToResetEvent struct {
	VmEvent

	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["VmFailedToResetEvent"] = reflect.TypeOf((*VmFailedToResetEvent)(nil)).Elem()
}

// This event records a failure to shut down the guest on a virtual machine.
type VmFailedToShutdownGuestEvent struct {
	VmEvent

	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["VmFailedToShutdownGuestEvent"] = reflect.TypeOf((*VmFailedToShutdownGuestEvent)(nil)).Elem()
}

// This event records a failure to set the guest on a virtual machine to a standby
// state.
type VmFailedToStandbyGuestEvent struct {
	VmEvent

	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["VmFailedToStandbyGuestEvent"] = reflect.TypeOf((*VmFailedToStandbyGuestEvent)(nil)).Elem()
}

// This event records a failure to suspend a virtual machine.
type VmFailedToSuspendEvent struct {
	VmEvent

	// The reason for the failure.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
}

func init() {
	t["VmFailedToSuspendEvent"] = reflect.TypeOf((*VmFailedToSuspendEvent)(nil)).Elem()
}

// This event records after a failover the new new primary failed to
// update the config of the secondary vm.
type VmFailedUpdatingSecondaryConfig struct {
	VmEvent
}

func init() {
	t["VmFailedUpdatingSecondaryConfig"] = reflect.TypeOf((*VmFailedUpdatingSecondaryConfig)(nil)).Elem()
}

// This event records when a virtual machine failover was unsuccessful.
type VmFailoverFailed struct {
	VmEvent

	// The reason for the failure
	Reason *LocalizedMethodFault `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["VmFailoverFailed"] = reflect.TypeOf((*VmFailoverFailed)(nil)).Elem()
}

// Configuration issues that can occur during operations
// related to fault tolerance protection for virtual machines.
type VmFaultToleranceConfigIssue struct {
	VmFaultToleranceIssue

	// The reason for the failure.
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
	// The entity name.
	//
	// Depending on the issue, it could
	// be virtual machine or host.
	EntityName string `xml:"entityName,omitempty" json:"entityName,omitempty"`
	// The entity
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
}

func init() {
	t["VmFaultToleranceConfigIssue"] = reflect.TypeOf((*VmFaultToleranceConfigIssue)(nil)).Elem()
}

type VmFaultToleranceConfigIssueFault VmFaultToleranceConfigIssue

func init() {
	t["VmFaultToleranceConfigIssueFault"] = reflect.TypeOf((*VmFaultToleranceConfigIssueFault)(nil)).Elem()
}

// Configuration issues that can occur during operations
// related to fault tolerance protection for virtual machines.
type VmFaultToleranceConfigIssueWrapper struct {
	VmFaultToleranceIssue

	// The entity name.
	//
	// Depending on the issue, it could
	// be virtual machine or host.
	EntityName string `xml:"entityName,omitempty" json:"entityName,omitempty"`
	// The entity
	//
	// Refers instance of `ManagedEntity`.
	Entity *ManagedObjectReference `xml:"entity,omitempty" json:"entity,omitempty"`
	// The nested error when the reason field is other
	Error *LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
}

func init() {
	t["VmFaultToleranceConfigIssueWrapper"] = reflect.TypeOf((*VmFaultToleranceConfigIssueWrapper)(nil)).Elem()
}

type VmFaultToleranceConfigIssueWrapperFault VmFaultToleranceConfigIssueWrapper

func init() {
	t["VmFaultToleranceConfigIssueWrapperFault"] = reflect.TypeOf((*VmFaultToleranceConfigIssueWrapperFault)(nil)).Elem()
}

// Indicates the file backing for some device prevents fault tolerance
// protection
type VmFaultToleranceInvalidFileBacking struct {
	VmFaultToleranceIssue

	// The device type of the file backing
	BackingType     string `xml:"backingType,omitempty" json:"backingType,omitempty"`
	BackingFilename string `xml:"backingFilename,omitempty" json:"backingFilename,omitempty"`
}

func init() {
	t["VmFaultToleranceInvalidFileBacking"] = reflect.TypeOf((*VmFaultToleranceInvalidFileBacking)(nil)).Elem()
}

type VmFaultToleranceInvalidFileBackingFault VmFaultToleranceInvalidFileBacking

func init() {
	t["VmFaultToleranceInvalidFileBackingFault"] = reflect.TypeOf((*VmFaultToleranceInvalidFileBackingFault)(nil)).Elem()
}

// Base object type for issues that can occur during operations
// related to fault tolerance protection for virtual machines.
type VmFaultToleranceIssue struct {
	VimFault
}

func init() {
	t["VmFaultToleranceIssue"] = reflect.TypeOf((*VmFaultToleranceIssue)(nil)).Elem()
}

type VmFaultToleranceIssueFault BaseVmFaultToleranceIssue

func init() {
	t["VmFaultToleranceIssueFault"] = reflect.TypeOf((*VmFaultToleranceIssueFault)(nil)).Elem()
}

// Container for a list of configuration issues that can occur during
// operations related to fault tolerance protection for virtual machines.
type VmFaultToleranceOpIssuesList struct {
	VmFaultToleranceIssue

	// A list of faults representing errors
	Errors   []LocalizedMethodFault `xml:"errors,omitempty" json:"errors,omitempty"`
	Warnings []LocalizedMethodFault `xml:"warnings,omitempty" json:"warnings,omitempty"`
}

func init() {
	t["VmFaultToleranceOpIssuesList"] = reflect.TypeOf((*VmFaultToleranceOpIssuesList)(nil)).Elem()
}

type VmFaultToleranceOpIssuesListFault VmFaultToleranceOpIssuesList

func init() {
	t["VmFaultToleranceOpIssuesListFault"] = reflect.TypeOf((*VmFaultToleranceOpIssuesListFault)(nil)).Elem()
}

// This event records a fault tolerance state change.
//
// A default alarm will be triggered upon this event, which would
// change the vm state:
// the vm state is red if the newState is needSecondary;
// the vm state is yellow if the newState is disabled;
// the vm state is green if the newState is notConfigured, starting,
// enabled or running
type VmFaultToleranceStateChangedEvent struct {
	VmEvent

	// The old fault toleeance state.
	OldState VirtualMachineFaultToleranceState `xml:"oldState" json:"oldState"`
	// The new fault tolerance state.
	NewState VirtualMachineFaultToleranceState `xml:"newState" json:"newState"`
}

func init() {
	t["VmFaultToleranceStateChangedEvent"] = reflect.TypeOf((*VmFaultToleranceStateChangedEvent)(nil)).Elem()
}

// This fault is returned when a host has more than the recommended number of
// Fault Tolerance vCPUs running on it.
type VmFaultToleranceTooManyFtVcpusOnHost struct {
	InsufficientResourcesFault

	// The name of the host
	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
	// The recommended number of FT protected vCPUs on a host.
	MaxNumFtVcpus int32 `xml:"maxNumFtVcpus" json:"maxNumFtVcpus"`
}

func init() {
	t["VmFaultToleranceTooManyFtVcpusOnHost"] = reflect.TypeOf((*VmFaultToleranceTooManyFtVcpusOnHost)(nil)).Elem()
}

type VmFaultToleranceTooManyFtVcpusOnHostFault VmFaultToleranceTooManyFtVcpusOnHost

func init() {
	t["VmFaultToleranceTooManyFtVcpusOnHostFault"] = reflect.TypeOf((*VmFaultToleranceTooManyFtVcpusOnHostFault)(nil)).Elem()
}

// This fault is returned when a host has more than the recommended number of
// Fault Tolerance VMs running on it.
type VmFaultToleranceTooManyVMsOnHost struct {
	InsufficientResourcesFault

	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
	// The recommended number of Fault Tolerance VMs running on the host.
	MaxNumFtVms int32 `xml:"maxNumFtVms" json:"maxNumFtVms"`
}

func init() {
	t["VmFaultToleranceTooManyVMsOnHost"] = reflect.TypeOf((*VmFaultToleranceTooManyVMsOnHost)(nil)).Elem()
}

type VmFaultToleranceTooManyVMsOnHostFault VmFaultToleranceTooManyVMsOnHost

func init() {
	t["VmFaultToleranceTooManyVMsOnHostFault"] = reflect.TypeOf((*VmFaultToleranceTooManyVMsOnHostFault)(nil)).Elem()
}

// This event records that all secondary virtual machines have
// been removed and fault tolerance protection turned off for
// this virtual machine.
type VmFaultToleranceTurnedOffEvent struct {
	VmEvent
}

func init() {
	t["VmFaultToleranceTurnedOffEvent"] = reflect.TypeOf((*VmFaultToleranceTurnedOffEvent)(nil)).Elem()
}

// This event records a secondary or primary VM is terminated.
//
// The reason could be : divergence, lost connection to secondary, partial
// hardware failure of secondary, or by user.
type VmFaultToleranceVmTerminatedEvent struct {
	VmEvent

	// The reason for the failure.
	//
	// see `VirtualMachineNeedSecondaryReason_enum`
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["VmFaultToleranceVmTerminatedEvent"] = reflect.TypeOf((*VmFaultToleranceVmTerminatedEvent)(nil)).Elem()
}

// This event notifies that a guest OS has crashed
type VmGuestOSCrashedEvent struct {
	VmEvent
}

func init() {
	t["VmGuestOSCrashedEvent"] = reflect.TypeOf((*VmGuestOSCrashedEvent)(nil)).Elem()
}

// This is a virtual machine guest reboot request event.
type VmGuestRebootEvent struct {
	VmEvent
}

func init() {
	t["VmGuestRebootEvent"] = reflect.TypeOf((*VmGuestRebootEvent)(nil)).Elem()
}

// This is a virtual machine guest shutdown request event.
type VmGuestShutdownEvent struct {
	VmEvent
}

func init() {
	t["VmGuestShutdownEvent"] = reflect.TypeOf((*VmGuestShutdownEvent)(nil)).Elem()
}

// This is a virtual machine guest standby request event.
type VmGuestStandbyEvent struct {
	VmEvent
}

func init() {
	t["VmGuestStandbyEvent"] = reflect.TypeOf((*VmGuestStandbyEvent)(nil)).Elem()
}

// This event records when host monitoring state has changed.
type VmHealthMonitoringStateChangedEvent struct {
	ClusterEvent

	// The service state in
	// `ClusterDasConfigInfoVmMonitoringState_enum`
	State string `xml:"state" json:"state"`
	// The previous service state in
	// `ClusterDasConfigInfoVmMonitoringState_enum`
	PrevState string `xml:"prevState,omitempty" json:"prevState,omitempty"`
}

func init() {
	t["VmHealthMonitoringStateChangedEvent"] = reflect.TypeOf((*VmHealthMonitoringStateChangedEvent)(nil)).Elem()
}

// The virtual machine if powered on or VMotioned, would violate a VM-Host affinity rule.
type VmHostAffinityRuleViolation struct {
	VmConfigFault

	// The vm that can not be powered on or VMotioned without violating a rule.
	VmName string `xml:"vmName" json:"vmName"`
	// The host that the virtual machine can not be powered on without violating a rule.
	HostName string `xml:"hostName" json:"hostName"`
}

func init() {
	t["VmHostAffinityRuleViolation"] = reflect.TypeOf((*VmHostAffinityRuleViolation)(nil)).Elem()
}

type VmHostAffinityRuleViolationFault VmHostAffinityRuleViolation

func init() {
	t["VmHostAffinityRuleViolationFault"] = reflect.TypeOf((*VmHostAffinityRuleViolationFault)(nil)).Elem()
}

// This event records the assignment of a new instance UUID
// to a virtual machine.
type VmInstanceUuidAssignedEvent struct {
	VmEvent

	// The new instance UUID.
	InstanceUuid string `xml:"instanceUuid" json:"instanceUuid"`
}

func init() {
	t["VmInstanceUuidAssignedEvent"] = reflect.TypeOf((*VmInstanceUuidAssignedEvent)(nil)).Elem()
}

// This event records a change in a virtual machine's instance UUID.
type VmInstanceUuidChangedEvent struct {
	VmEvent

	// The old instance UUID.
	OldInstanceUuid string `xml:"oldInstanceUuid" json:"oldInstanceUuid"`
	// The new instance UUID.
	NewInstanceUuid string `xml:"newInstanceUuid" json:"newInstanceUuid"`
}

func init() {
	t["VmInstanceUuidChangedEvent"] = reflect.TypeOf((*VmInstanceUuidChangedEvent)(nil)).Elem()
}

// This event records a conflict of virtual machine instance UUIDs.
type VmInstanceUuidConflictEvent struct {
	VmEvent

	// The virtual machine whose instance UUID conflicts with the
	// current virtual machine's instance UUID.
	ConflictedVm VmEventArgument `xml:"conflictedVm" json:"conflictedVm"`
	// The instance UUID in conflict.
	InstanceUuid string `xml:"instanceUuid" json:"instanceUuid"`
}

func init() {
	t["VmInstanceUuidConflictEvent"] = reflect.TypeOf((*VmInstanceUuidConflictEvent)(nil)).Elem()
}

// A VmLimitLicense fault is thrown if powering on the virtual
// machine would exceed the maximum number of running virtual
// machines allowed.
type VmLimitLicense struct {
	NotEnoughLicenses

	// The maximum number of running virtual machines
	// limit.
	Limit int32 `xml:"limit" json:"limit"`
}

func init() {
	t["VmLimitLicense"] = reflect.TypeOf((*VmLimitLicense)(nil)).Elem()
}

type VmLimitLicenseFault VmLimitLicense

func init() {
	t["VmLimitLicenseFault"] = reflect.TypeOf((*VmLimitLicenseFault)(nil)).Elem()
}

// This data object type describes a file that is logging output for a virtual
// machine.
type VmLogFileInfo struct {
	FileInfo
}

func init() {
	t["VmLogFileInfo"] = reflect.TypeOf((*VmLogFileInfo)(nil)).Elem()
}

// This data object type describes the query specification for a virtual machine log
// file file.
type VmLogFileQuery struct {
	FileQuery
}

func init() {
	t["VmLogFileQuery"] = reflect.TypeOf((*VmLogFileQuery)(nil)).Elem()
}

// This event records the assignment of a new MAC address
// to a virtual network adapter.
type VmMacAssignedEvent struct {
	VmEvent

	// The name of the virtual adapter.
	Adapter string `xml:"adapter" json:"adapter"`
	// The new MAC address.
	Mac string `xml:"mac" json:"mac"`
}

func init() {
	t["VmMacAssignedEvent"] = reflect.TypeOf((*VmMacAssignedEvent)(nil)).Elem()
}

// This event records a change in a virtual machine's MAC address.
type VmMacChangedEvent struct {
	VmEvent

	// The name of the virtual network adapter.
	Adapter string `xml:"adapter" json:"adapter"`
	// The old MAC address.
	OldMac string `xml:"oldMac" json:"oldMac"`
	// The new MAC address.
	NewMac string `xml:"newMac" json:"newMac"`
}

func init() {
	t["VmMacChangedEvent"] = reflect.TypeOf((*VmMacChangedEvent)(nil)).Elem()
}

// This event records a MAC address conflict for a virtual machine.
type VmMacConflictEvent struct {
	VmEvent

	// The virtual machine whose MAC address conflicts with
	// the current virtual machine's address.
	ConflictedVm VmEventArgument `xml:"conflictedVm" json:"conflictedVm"`
	// The MAC address that is in conflict.
	Mac string `xml:"mac" json:"mac"`
}

func init() {
	t["VmMacConflictEvent"] = reflect.TypeOf((*VmMacConflictEvent)(nil)).Elem()
}

// This event is fired when FT VM reached the max restart count
type VmMaxFTRestartCountReached struct {
	VmEvent
}

func init() {
	t["VmMaxFTRestartCountReached"] = reflect.TypeOf((*VmMaxFTRestartCountReached)(nil)).Elem()
}

// This event is fired when the VM reached the max restart count
type VmMaxRestartCountReached struct {
	VmEvent
}

func init() {
	t["VmMaxRestartCountReached"] = reflect.TypeOf((*VmMaxRestartCountReached)(nil)).Elem()
}

// This event records when an error message (consisting of a collection of "observations")
// is thrown by the virtual machine.
//
// This is a generic event for such messages.
type VmMessageErrorEvent struct {
	VmEvent

	// A raw message returned by the virtualization platform.
	Message string `xml:"message" json:"message"`
	// A set of localizable message data that comprise this event.
	//
	// Only available on servers that support localization.
	MessageInfo []VirtualMachineMessage `xml:"messageInfo,omitempty" json:"messageInfo,omitempty"`
}

func init() {
	t["VmMessageErrorEvent"] = reflect.TypeOf((*VmMessageErrorEvent)(nil)).Elem()
}

// This event records when an informational message (consisting of a collection of "observations")
// is thrown by the virtual machine.
//
// This is a generic event for such messages.
type VmMessageEvent struct {
	VmEvent

	// A raw message returned by the virtualization platform.
	Message string `xml:"message" json:"message"`
	// A set of localizable message data that comprise this event.
	//
	// Only available on servers that support localization.
	MessageInfo []VirtualMachineMessage `xml:"messageInfo,omitempty" json:"messageInfo,omitempty"`
}

func init() {
	t["VmMessageEvent"] = reflect.TypeOf((*VmMessageEvent)(nil)).Elem()
}

// This event records when a warning message (consisting of a collection of "observations")
// is thrown by the virtual machine.
//
// This is a generic event for such messages.
type VmMessageWarningEvent struct {
	VmEvent

	// A raw message returned by the virtualization platform.
	Message     string                  `xml:"message" json:"message"`
	MessageInfo []VirtualMachineMessage `xml:"messageInfo,omitempty" json:"messageInfo,omitempty"`
}

func init() {
	t["VmMessageWarningEvent"] = reflect.TypeOf((*VmMessageWarningEvent)(nil)).Elem()
}

// This fault indicates that some error has occurred during the processing of
// of a MetadataManager operation.
//
// This may be subclassed by a more specific
// fault.
type VmMetadataManagerFault struct {
	VimFault
}

func init() {
	t["VmMetadataManagerFault"] = reflect.TypeOf((*VmMetadataManagerFault)(nil)).Elem()
}

type VmMetadataManagerFaultFault VmMetadataManagerFault

func init() {
	t["VmMetadataManagerFaultFault"] = reflect.TypeOf((*VmMetadataManagerFaultFault)(nil)).Elem()
}

// This event records a virtual machine migration.
type VmMigratedEvent struct {
	VmEvent

	// The source host.
	//
	// (Because this is after a successful migration,
	// the destination host is recorded in the inherited "host" property.)
	SourceHost HostEventArgument `xml:"sourceHost" json:"sourceHost"`
	// The source datacenter
	SourceDatacenter *DatacenterEventArgument `xml:"sourceDatacenter,omitempty" json:"sourceDatacenter,omitempty"`
	// The source primary datastore
	SourceDatastore *DatastoreEventArgument `xml:"sourceDatastore,omitempty" json:"sourceDatastore,omitempty"`
}

func init() {
	t["VmMigratedEvent"] = reflect.TypeOf((*VmMigratedEvent)(nil)).Elem()
}

// Thrown when turning on Fault Tolerance protection on a running virtual machine
// if the virtual machine is running in a monitor mode that is incompatible.
type VmMonitorIncompatibleForFaultTolerance struct {
	VimFault
}

func init() {
	t["VmMonitorIncompatibleForFaultTolerance"] = reflect.TypeOf((*VmMonitorIncompatibleForFaultTolerance)(nil)).Elem()
}

type VmMonitorIncompatibleForFaultToleranceFault VmMonitorIncompatibleForFaultTolerance

func init() {
	t["VmMonitorIncompatibleForFaultToleranceFault"] = reflect.TypeOf((*VmMonitorIncompatibleForFaultToleranceFault)(nil)).Elem()
}

// This event records that no compatible host was found to place a
// secondary VM.
//
// A default alarm will be triggered upon this event, which by default
// would trigger a SNMP trap.
type VmNoCompatibleHostForSecondaryEvent struct {
	VmEvent
}

func init() {
	t["VmNoCompatibleHostForSecondaryEvent"] = reflect.TypeOf((*VmNoCompatibleHostForSecondaryEvent)(nil)).Elem()
}

// This event records a migration failure when the destination host
// is not on the same network as the source host.
type VmNoNetworkAccessEvent struct {
	VmEvent

	// The destination host.
	DestHost HostEventArgument `xml:"destHost" json:"destHost"`
}

func init() {
	t["VmNoNetworkAccessEvent"] = reflect.TypeOf((*VmNoNetworkAccessEvent)(nil)).Elem()
}

// This data object type describes a file that is a virtual machine non-volatile
// memory file.
type VmNvramFileInfo struct {
	FileInfo
}

func init() {
	t["VmNvramFileInfo"] = reflect.TypeOf((*VmNvramFileInfo)(nil)).Elem()
}

// This data object type describes the query specification for a non-volatile memory
// file.
type VmNvramFileQuery struct {
	FileQuery
}

func init() {
	t["VmNvramFileQuery"] = reflect.TypeOf((*VmNvramFileQuery)(nil)).Elem()
}

// This event records a virtual machine for which no host is responsible.
type VmOrphanedEvent struct {
	VmEvent
}

func init() {
	t["VmOrphanedEvent"] = reflect.TypeOf((*VmOrphanedEvent)(nil)).Elem()
}

// Initial VM configuration for the specified pod.
//
// This configuration will be saved to the pod config
// `StorageDrsConfigInfo`
// when the placement recommendations are applied.
type VmPodConfigForPlacement struct {
	DynamicData

	// The pod that this initial configuration applies to.
	//
	// Since there could be multiple pods in a single placement request,
	// we may need to specify multiple initial VM configurations, one per
	// pod.
	//
	// Refers instance of `StoragePod`.
	StoragePod ManagedObjectReference `xml:"storagePod" json:"storagePod"`
	// Array of PodDiskLocator objects.
	Disk []PodDiskLocator `xml:"disk,omitempty" json:"disk,omitempty"`
	// The VM configuration for the VM that is being placed.
	VmConfig *StorageDrsVmConfigInfo `xml:"vmConfig,omitempty" json:"vmConfig,omitempty"`
	// The initial interVmRules that should during placement of this
	// virtual machine.
	//
	// It may not always be possible to specify that the
	// virtual machine being placed is part of the rule because the
	// virtual machine may not have been created yet. So for simplicity,
	// we assume the virtual machine being placed is always implicitly
	// part of any rule specified. It will be explicitly added to the
	// rule before it is saved to the pod config.
	InterVmRule []BaseClusterRuleInfo `xml:"interVmRule,omitempty,typeattr" json:"interVmRule,omitempty"`
}

func init() {
	t["VmPodConfigForPlacement"] = reflect.TypeOf((*VmPodConfigForPlacement)(nil)).Elem()
}

// The `VmPortGroupProfile` data object represents the subprofile
// for a port group that will be used by virtual machines.
//
// Use the `ApplyProfile.policy` list for
// access to configuration data for the virtual machine port group profile. Use the
// `ApplyProfile.property` list for access to subprofiles, if any.
//
// vSphere Servers use `Network` managed objects to represent virtual machine port
// groups in the vSphere inventory.
type VmPortGroupProfile struct {
	PortGroupProfile
}

func init() {
	t["VmPortGroupProfile"] = reflect.TypeOf((*VmPortGroupProfile)(nil)).Elem()
}

// This event records when a virtual machine has been powered off on an isolated host
// in a HA cluster.
type VmPowerOffOnIsolationEvent struct {
	VmPoweredOffEvent

	// The isolated host on which a virtual machine is powered off.
	IsolatedHost HostEventArgument `xml:"isolatedHost" json:"isolatedHost"`
}

func init() {
	t["VmPowerOffOnIsolationEvent"] = reflect.TypeOf((*VmPowerOffOnIsolationEvent)(nil)).Elem()
}

// This exception is thrown if the power-on of a virtual machine is attempted
// when the operation is disabled on the host
type VmPowerOnDisabled struct {
	InvalidState
}

func init() {
	t["VmPowerOnDisabled"] = reflect.TypeOf((*VmPowerOnDisabled)(nil)).Elem()
}

type VmPowerOnDisabledFault VmPowerOnDisabled

func init() {
	t["VmPowerOnDisabledFault"] = reflect.TypeOf((*VmPowerOnDisabledFault)(nil)).Elem()
}

// This event records when a virtual machine finished powering off.
type VmPoweredOffEvent struct {
	VmEvent
}

func init() {
	t["VmPoweredOffEvent"] = reflect.TypeOf((*VmPoweredOffEvent)(nil)).Elem()
}

// This event records when a virtual machine finished powering on.
type VmPoweredOnEvent struct {
	VmEvent
}

func init() {
	t["VmPoweredOnEvent"] = reflect.TypeOf((*VmPoweredOnEvent)(nil)).Elem()
}

// This event records when a virtual machine was powering on using
// DVPorts with port level configuration, which might be different
// from the DVportgroup.
type VmPoweringOnWithCustomizedDVPortEvent struct {
	VmEvent

	// The list of Virtual NIC that were using the DVports.
	Vnic []VnicPortArgument `xml:"vnic" json:"vnic"`
}

func init() {
	t["VmPoweringOnWithCustomizedDVPortEvent"] = reflect.TypeOf((*VmPoweringOnWithCustomizedDVPortEvent)(nil)).Elem()
}

// This event records a fault tolerance failover.
//
// The reason could be : lost connection to primary, partial hardware failure
// of primary or by user.
type VmPrimaryFailoverEvent struct {
	VmEvent

	// The reason for the failure.
	//
	// see `VirtualMachineNeedSecondaryReason_enum`
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["VmPrimaryFailoverEvent"] = reflect.TypeOf((*VmPrimaryFailoverEvent)(nil)).Elem()
}

// This event records a reconfiguration of the virtual machine.
type VmReconfiguredEvent struct {
	VmEvent

	// The configuration specification that was used for the reconfiguration.
	ConfigSpec VirtualMachineConfigSpec `xml:"configSpec" json:"configSpec"`
	// The configuration values changed during the reconfiguration.
	ConfigChanges *ChangesInfoEventArgument `xml:"configChanges,omitempty" json:"configChanges,omitempty"`
}

func init() {
	t["VmReconfiguredEvent"] = reflect.TypeOf((*VmReconfiguredEvent)(nil)).Elem()
}

// This event records that a virtual machine was successfully registered.
type VmRegisteredEvent struct {
	VmEvent
}

func init() {
	t["VmRegisteredEvent"] = reflect.TypeOf((*VmRegisteredEvent)(nil)).Elem()
}

// This event records that a virtual machine was successfully
// converted to the new virtual machine format on a VMFS3 volume.
type VmRelayoutSuccessfulEvent struct {
	VmEvent
}

func init() {
	t["VmRelayoutSuccessfulEvent"] = reflect.TypeOf((*VmRelayoutSuccessfulEvent)(nil)).Elem()
}

// This event records that a virtual machine is already in the
// correct format.
//
// No relay out is necessary.
type VmRelayoutUpToDateEvent struct {
	VmEvent
}

func init() {
	t["VmRelayoutUpToDateEvent"] = reflect.TypeOf((*VmRelayoutUpToDateEvent)(nil)).Elem()
}

// This event records that a virtual machine was successfully reloaded from a
// new configuration path.
type VmReloadFromPathEvent struct {
	VmEvent

	ConfigPath string `xml:"configPath" json:"configPath"`
}

func init() {
	t["VmReloadFromPathEvent"] = reflect.TypeOf((*VmReloadFromPathEvent)(nil)).Elem()
}

// This event records that a virtual machine reload from a new configuration
// path failed.
type VmReloadFromPathFailedEvent struct {
	VmEvent

	ConfigPath string `xml:"configPath" json:"configPath"`
}

func init() {
	t["VmReloadFromPathFailedEvent"] = reflect.TypeOf((*VmReloadFromPathFailedEvent)(nil)).Elem()
}

// This event records a failure to relocate a virtual machine.
type VmRelocateFailedEvent struct {
	VmRelocateSpecEvent

	// The destination host to which the virtual machine is being relocated.
	DestHost HostEventArgument `xml:"destHost" json:"destHost"`
	// The reason why this relocate operation failed.
	Reason LocalizedMethodFault `xml:"reason" json:"reason"`
	// The destination datacenter to which the virtual machine was being relocated
	DestDatacenter *DatacenterEventArgument `xml:"destDatacenter,omitempty" json:"destDatacenter,omitempty"`
	// The destination primary datastore to which the virtual machine was being relocated
	DestDatastore *DatastoreEventArgument `xml:"destDatastore,omitempty" json:"destDatastore,omitempty"`
}

func init() {
	t["VmRelocateFailedEvent"] = reflect.TypeOf((*VmRelocateFailedEvent)(nil)).Elem()
}

// This event is the base event for relocate and clone base events.
type VmRelocateSpecEvent struct {
	VmEvent
}

func init() {
	t["VmRelocateSpecEvent"] = reflect.TypeOf((*VmRelocateSpecEvent)(nil)).Elem()
}

// This event records the completion of a virtual machine relocation.
type VmRelocatedEvent struct {
	VmRelocateSpecEvent

	// The source host from which the virtual machine was relocated.
	SourceHost HostEventArgument `xml:"sourceHost" json:"sourceHost"`
	// The source datacenter from which the virtual machine relocated
	SourceDatacenter *DatacenterEventArgument `xml:"sourceDatacenter,omitempty" json:"sourceDatacenter,omitempty"`
	// The source primary datastore from which the virtual machine relocated
	SourceDatastore *DatastoreEventArgument `xml:"sourceDatastore,omitempty" json:"sourceDatastore,omitempty"`
}

func init() {
	t["VmRelocatedEvent"] = reflect.TypeOf((*VmRelocatedEvent)(nil)).Elem()
}

// This event records that a remote console was connected to the VM
type VmRemoteConsoleConnectedEvent struct {
	VmEvent
}

func init() {
	t["VmRemoteConsoleConnectedEvent"] = reflect.TypeOf((*VmRemoteConsoleConnectedEvent)(nil)).Elem()
}

// This event records that a remote console was disconnected from the VM
type VmRemoteConsoleDisconnectedEvent struct {
	VmEvent
}

func init() {
	t["VmRemoteConsoleDisconnectedEvent"] = reflect.TypeOf((*VmRemoteConsoleDisconnectedEvent)(nil)).Elem()
}

// This event records a virtual machine removed from VirtualCenter management.
type VmRemovedEvent struct {
	VmEvent
}

func init() {
	t["VmRemovedEvent"] = reflect.TypeOf((*VmRemovedEvent)(nil)).Elem()
}

// This event records the renaming of a virtual machine.
type VmRenamedEvent struct {
	VmEvent

	// The old name of the virtual machine.
	OldName string `xml:"oldName" json:"oldName"`
	// The new name of the virtual machine.
	NewName string `xml:"newName" json:"newName"`
}

func init() {
	t["VmRenamedEvent"] = reflect.TypeOf((*VmRenamedEvent)(nil)).Elem()
}

// The virtual machine is using features that exceed what the
// host is capable of providing.
//
// This may occur when joining an EVC cluster
// while the virtual machine is powered on.
// The most common resolution is to power cycle the virtual machine.
type VmRequirementsExceedCurrentEVCModeEvent struct {
	VmEvent
}

func init() {
	t["VmRequirementsExceedCurrentEVCModeEvent"] = reflect.TypeOf((*VmRequirementsExceedCurrentEVCModeEvent)(nil)).Elem()
}

// This event records a virtual machine resetting.
type VmResettingEvent struct {
	VmEvent
}

func init() {
	t["VmResettingEvent"] = reflect.TypeOf((*VmResettingEvent)(nil)).Elem()
}

// This event records when a virtual machine is moved from one resource pool to another.
type VmResourcePoolMovedEvent struct {
	VmEvent

	// The old parent resourcePool of the moved virtual machine.
	OldParent ResourcePoolEventArgument `xml:"oldParent" json:"oldParent"`
	// The new parent resourcePool of the moved virtual machine.
	NewParent ResourcePoolEventArgument `xml:"newParent" json:"newParent"`
}

func init() {
	t["VmResourcePoolMovedEvent"] = reflect.TypeOf((*VmResourcePoolMovedEvent)(nil)).Elem()
}

// This event records a change in resource allocation of a virtual machine.
type VmResourceReallocatedEvent struct {
	VmEvent

	// The configuration values changed during the reconfiguration.
	ConfigChanges *ChangesInfoEventArgument `xml:"configChanges,omitempty" json:"configChanges,omitempty"`
}

func init() {
	t["VmResourceReallocatedEvent"] = reflect.TypeOf((*VmResourceReallocatedEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 5.0, the Server will generate the `EventEx` event
// with the `EventEx.eventTypeId` property set to "com.vmware.vc.ha.VmRestartedByHAEvent".
//
// This event records that the virtual machine was restarted on a host, since
// its original host had failed.
type VmRestartedOnAlternateHostEvent struct {
	VmPoweredOnEvent

	// The host that failed.
	SourceHost HostEventArgument `xml:"sourceHost" json:"sourceHost"`
}

func init() {
	t["VmRestartedOnAlternateHostEvent"] = reflect.TypeOf((*VmRestartedOnAlternateHostEvent)(nil)).Elem()
}

// This event records a virtual machine resuming.
type VmResumingEvent struct {
	VmEvent
}

func init() {
	t["VmResumingEvent"] = reflect.TypeOf((*VmResumingEvent)(nil)).Elem()
}

// This event records a secondary VM is added.
type VmSecondaryAddedEvent struct {
	VmEvent
}

func init() {
	t["VmSecondaryAddedEvent"] = reflect.TypeOf((*VmSecondaryAddedEvent)(nil)).Elem()
}

// This event records that a fault tolerance secondary VM has been
// disabled by vCenter because the VM could not be powered on.
type VmSecondaryDisabledBySystemEvent struct {
	VmEvent

	Reason *LocalizedMethodFault `xml:"reason,omitempty" json:"reason,omitempty"`
}

func init() {
	t["VmSecondaryDisabledBySystemEvent"] = reflect.TypeOf((*VmSecondaryDisabledBySystemEvent)(nil)).Elem()
}

// This event records a secondary VM is disabled.
type VmSecondaryDisabledEvent struct {
	VmEvent
}

func init() {
	t["VmSecondaryDisabledEvent"] = reflect.TypeOf((*VmSecondaryDisabledEvent)(nil)).Elem()
}

// This event records a secondary VM is enabled.
type VmSecondaryEnabledEvent struct {
	VmEvent
}

func init() {
	t["VmSecondaryEnabledEvent"] = reflect.TypeOf((*VmSecondaryEnabledEvent)(nil)).Elem()
}

// This event records a secondary VM is started successfully.
type VmSecondaryStartedEvent struct {
	VmEvent
}

func init() {
	t["VmSecondaryStartedEvent"] = reflect.TypeOf((*VmSecondaryStartedEvent)(nil)).Elem()
}

// This event records when a virtual machine has been shut down on an isolated host
// in a HA cluster.
type VmShutdownOnIsolationEvent struct {
	VmPoweredOffEvent

	// The isolated host on which a virtual machine was shutdown.
	IsolatedHost HostEventArgument `xml:"isolatedHost" json:"isolatedHost"`
	// Indicates if the shutdown was successful.
	//
	// If the shutdown failed, the virtual
	// machine was powered off. see `VmShutdownOnIsolationEventOperation_enum`
	ShutdownResult string `xml:"shutdownResult,omitempty" json:"shutdownResult,omitempty"`
}

func init() {
	t["VmShutdownOnIsolationEvent"] = reflect.TypeOf((*VmShutdownOnIsolationEvent)(nil)).Elem()
}

// This fault is returned when a host has more than the recommended number of
// SMP Fault Tolerance VMs running on it.
type VmSmpFaultToleranceTooManyVMsOnHost struct {
	InsufficientResourcesFault

	// The name of the host
	HostName string `xml:"hostName,omitempty" json:"hostName,omitempty"`
	// The recommended number of SMP-Fault Tolerance VMs running on the host.
	MaxNumSmpFtVms int32 `xml:"maxNumSmpFtVms" json:"maxNumSmpFtVms"`
}

func init() {
	t["VmSmpFaultToleranceTooManyVMsOnHost"] = reflect.TypeOf((*VmSmpFaultToleranceTooManyVMsOnHost)(nil)).Elem()
}

type VmSmpFaultToleranceTooManyVMsOnHostFault VmSmpFaultToleranceTooManyVMsOnHost

func init() {
	t["VmSmpFaultToleranceTooManyVMsOnHostFault"] = reflect.TypeOf((*VmSmpFaultToleranceTooManyVMsOnHostFault)(nil)).Elem()
}

// This data object type describes a file that is a virtual disk snapshot file.
type VmSnapshotFileInfo struct {
	FileInfo
}

func init() {
	t["VmSnapshotFileInfo"] = reflect.TypeOf((*VmSnapshotFileInfo)(nil)).Elem()
}

// This data object type describes the query specification for a virtual machine
// snapshot file.
type VmSnapshotFileQuery struct {
	FileQuery
}

func init() {
	t["VmSnapshotFileQuery"] = reflect.TypeOf((*VmSnapshotFileQuery)(nil)).Elem()
}

// Deprecated as of vSphere API 6.0.
//
// This event indicates the start of a recording session on a virtual machine.
type VmStartRecordingEvent struct {
	VmEvent
}

func init() {
	t["VmStartRecordingEvent"] = reflect.TypeOf((*VmStartRecordingEvent)(nil)).Elem()
}

// Deprecated as of vSphere API 6.0.
//
// This event indicates the start of a replay session on a virtual machine.
type VmStartReplayingEvent struct {
	VmEvent
}

func init() {
	t["VmStartReplayingEvent"] = reflect.TypeOf((*VmStartReplayingEvent)(nil)).Elem()
}

// This event records a virtual machine powering on.
type VmStartingEvent struct {
	VmEvent
}

func init() {
	t["VmStartingEvent"] = reflect.TypeOf((*VmStartingEvent)(nil)).Elem()
}

// This event records a vmotion to start a secondary VM.
type VmStartingSecondaryEvent struct {
	VmEvent
}

func init() {
	t["VmStartingSecondaryEvent"] = reflect.TypeOf((*VmStartingSecondaryEvent)(nil)).Elem()
}

// This event records a static MAC address conflict for a virtual machine.
type VmStaticMacConflictEvent struct {
	VmEvent

	// The virtual machine whose static MAC address conflicts with
	// the current virtual machine's address.
	ConflictedVm VmEventArgument `xml:"conflictedVm" json:"conflictedVm"`
	// The static MAC address that is in conflict.
	Mac string `xml:"mac" json:"mac"`
}

func init() {
	t["VmStaticMacConflictEvent"] = reflect.TypeOf((*VmStaticMacConflictEvent)(nil)).Elem()
}

// This event records a virtual machine stopping.
type VmStoppingEvent struct {
	VmEvent
}

func init() {
	t["VmStoppingEvent"] = reflect.TypeOf((*VmStoppingEvent)(nil)).Elem()
}

// This event records when a virtual machine finished suspending.
type VmSuspendedEvent struct {
	VmEvent
}

func init() {
	t["VmSuspendedEvent"] = reflect.TypeOf((*VmSuspendedEvent)(nil)).Elem()
}

// This event records a virtual machine suspending.
type VmSuspendingEvent struct {
	VmEvent
}

func init() {
	t["VmSuspendingEvent"] = reflect.TypeOf((*VmSuspendingEvent)(nil)).Elem()
}

// This event records timeout when starting a secondary VM.
//
// A default alarm will be triggered upon this event, which by default
// would trigger a SNMP trap.
type VmTimedoutStartingSecondaryEvent struct {
	VmEvent

	// The duration of the timeout in milliseconds.
	Timeout int64 `xml:"timeout,omitempty" json:"timeout,omitempty"`
}

func init() {
	t["VmTimedoutStartingSecondaryEvent"] = reflect.TypeOf((*VmTimedoutStartingSecondaryEvent)(nil)).Elem()
}

// A base fault to indicate that something went wrong when upgrading tools.
type VmToolsUpgradeFault struct {
	VimFault
}

func init() {
	t["VmToolsUpgradeFault"] = reflect.TypeOf((*VmToolsUpgradeFault)(nil)).Elem()
}

type VmToolsUpgradeFaultFault BaseVmToolsUpgradeFault

func init() {
	t["VmToolsUpgradeFaultFault"] = reflect.TypeOf((*VmToolsUpgradeFaultFault)(nil)).Elem()
}

// This event records when an unsupported guest is powering on.
type VmUnsupportedStartingEvent struct {
	VmStartingEvent

	GuestId string `xml:"guestId" json:"guestId"`
}

func init() {
	t["VmUnsupportedStartingEvent"] = reflect.TypeOf((*VmUnsupportedStartingEvent)(nil)).Elem()
}

// This event records the successful completion of an upgrade operation.
type VmUpgradeCompleteEvent struct {
	VmEvent

	// The version of the agent.
	Version string `xml:"version" json:"version"`
}

func init() {
	t["VmUpgradeCompleteEvent"] = reflect.TypeOf((*VmUpgradeCompleteEvent)(nil)).Elem()
}

// This event records a failure to upgrade virtual hardware.
type VmUpgradeFailedEvent struct {
	VmEvent
}

func init() {
	t["VmUpgradeFailedEvent"] = reflect.TypeOf((*VmUpgradeFailedEvent)(nil)).Elem()
}

// This event records the process of upgrading the virtual hardware on a
// virtual machine.
type VmUpgradingEvent struct {
	VmEvent

	// The version of the agent.
	Version string `xml:"version" json:"version"`
}

func init() {
	t["VmUpgradingEvent"] = reflect.TypeOf((*VmUpgradingEvent)(nil)).Elem()
}

// This event records the assignment of a new BIOS UUID
// to a virtual machine.
type VmUuidAssignedEvent struct {
	VmEvent

	// The new BIOS UUID.
	Uuid string `xml:"uuid" json:"uuid"`
}

func init() {
	t["VmUuidAssignedEvent"] = reflect.TypeOf((*VmUuidAssignedEvent)(nil)).Elem()
}

// This event records a change in a virtual machine's BIOS UUID.
type VmUuidChangedEvent struct {
	VmEvent

	// The old BIOS UUID.
	OldUuid string `xml:"oldUuid" json:"oldUuid"`
	// The new BIOS UUID.
	NewUuid string `xml:"newUuid" json:"newUuid"`
}

func init() {
	t["VmUuidChangedEvent"] = reflect.TypeOf((*VmUuidChangedEvent)(nil)).Elem()
}

// This event records a conflict of virtual machine BIOS UUIDs.
type VmUuidConflictEvent struct {
	VmEvent

	// The virtual machine whose UUID conflicts with the
	// current virtual machine's UUID.
	ConflictedVm VmEventArgument `xml:"conflictedVm" json:"conflictedVm"`
	// The BIOS UUID in conflict.
	Uuid string `xml:"uuid" json:"uuid"`
}

func init() {
	t["VmUuidConflictEvent"] = reflect.TypeOf((*VmUuidConflictEvent)(nil)).Elem()
}

type VmValidateMaxDevice struct {
	VimFault

	// The device
	Device string `xml:"device" json:"device"`
	// max count for the device
	Max int32 `xml:"max" json:"max"`
	// number of devices found in vim.vm.ConfigSpec
	Count int32 `xml:"count" json:"count"`
}

func init() {
	t["VmValidateMaxDevice"] = reflect.TypeOf((*VmValidateMaxDevice)(nil)).Elem()
}

type VmValidateMaxDeviceFault VmValidateMaxDevice

func init() {
	t["VmValidateMaxDeviceFault"] = reflect.TypeOf((*VmValidateMaxDeviceFault)(nil)).Elem()
}

// This event is generated when the reservations used by all
// the virtual network adapters belonging to the virtual NIC network
// resource pool goes below the reservation allocated to the resource pool
type VmVnicPoolReservationViolationClearEvent struct {
	DvsEvent

	// The key of the Virtual NIC network resource pool
	VmVnicResourcePoolKey string `xml:"vmVnicResourcePoolKey" json:"vmVnicResourcePoolKey"`
	// The name of the Virtual NIC network resource pool
	VmVnicResourcePoolName string `xml:"vmVnicResourcePoolName,omitempty" json:"vmVnicResourcePoolName,omitempty"`
}

func init() {
	t["VmVnicPoolReservationViolationClearEvent"] = reflect.TypeOf((*VmVnicPoolReservationViolationClearEvent)(nil)).Elem()
}

// This event is generated when the reservations used by all
// the virtual network adapters belonging to the virtual NIC network
// resource pool exceeds the reservation allocated to the resource pool
type VmVnicPoolReservationViolationRaiseEvent struct {
	DvsEvent

	// The key of the Virtual NIC network resource pool
	VmVnicResourcePoolKey string `xml:"vmVnicResourcePoolKey" json:"vmVnicResourcePoolKey"`
	// The name of the Virtual NIC network resource pool
	VmVnicResourcePoolName string `xml:"vmVnicResourcePoolName,omitempty" json:"vmVnicResourcePoolName,omitempty"`
}

func init() {
	t["VmVnicPoolReservationViolationRaiseEvent"] = reflect.TypeOf((*VmVnicPoolReservationViolationRaiseEvent)(nil)).Elem()
}

// This event records the assignment of a new WWN (World Wide Name)
// to a virtual machine.
type VmWwnAssignedEvent struct {
	VmEvent

	// The new node WWN.
	NodeWwns []int64 `xml:"nodeWwns" json:"nodeWwns"`
	// The new port WWN.
	PortWwns []int64 `xml:"portWwns" json:"portWwns"`
}

func init() {
	t["VmWwnAssignedEvent"] = reflect.TypeOf((*VmWwnAssignedEvent)(nil)).Elem()
}

// This event records a change in a virtual machine's WWN (World Wide Name).
type VmWwnChangedEvent struct {
	VmEvent

	// The old node WWN.
	OldNodeWwns []int64 `xml:"oldNodeWwns,omitempty" json:"oldNodeWwns,omitempty"`
	// The old port WWN.
	OldPortWwns []int64 `xml:"oldPortWwns,omitempty" json:"oldPortWwns,omitempty"`
	// The new node WWN.
	NewNodeWwns []int64 `xml:"newNodeWwns,omitempty" json:"newNodeWwns,omitempty"`
	// The new port WWN.
	NewPortWwns []int64 `xml:"newPortWwns,omitempty" json:"newPortWwns,omitempty"`
}

func init() {
	t["VmWwnChangedEvent"] = reflect.TypeOf((*VmWwnChangedEvent)(nil)).Elem()
}

// Thrown if a user attempts to assign a
// WWN that is currently being used by other virtual machine or host.
type VmWwnConflict struct {
	InvalidVmConfig

	// The virtual machine that is using the same WWN.
	//
	// Refers instance of `VirtualMachine`.
	Vm *ManagedObjectReference `xml:"vm,omitempty" json:"vm,omitempty"`
	// The host that is using the same WWN.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// The name of the virtual machine/host that is using the same WWN.
	Name string `xml:"name,omitempty" json:"name,omitempty"`
	// The WWN that is in conflict.
	Wwn int64 `xml:"wwn,omitempty" json:"wwn,omitempty"`
}

func init() {
	t["VmWwnConflict"] = reflect.TypeOf((*VmWwnConflict)(nil)).Elem()
}

// This event records a conflict of virtual machine WWNs (World Wide Name).
type VmWwnConflictEvent struct {
	VmEvent

	// The virtual machine whose WWN conflicts with the
	// current virtual machine's WWN.
	ConflictedVms []VmEventArgument `xml:"conflictedVms,omitempty" json:"conflictedVms,omitempty"`
	// The host whose physical WWN conflicts with the
	// current virtual machine's WWN.
	ConflictedHosts []HostEventArgument `xml:"conflictedHosts,omitempty" json:"conflictedHosts,omitempty"`
	// The WWN in conflict.
	Wwn int64 `xml:"wwn" json:"wwn"`
}

func init() {
	t["VmWwnConflictEvent"] = reflect.TypeOf((*VmWwnConflictEvent)(nil)).Elem()
}

type VmWwnConflictFault VmWwnConflict

func init() {
	t["VmWwnConflictFault"] = reflect.TypeOf((*VmWwnConflictFault)(nil)).Elem()
}

// A VmfsAlreadyMounted fault indicates that VMFS volume with same UUID
// is already mounted on the host.
type VmfsAlreadyMounted struct {
	VmfsMountFault
}

func init() {
	t["VmfsAlreadyMounted"] = reflect.TypeOf((*VmfsAlreadyMounted)(nil)).Elem()
}

type VmfsAlreadyMountedFault VmfsAlreadyMounted

func init() {
	t["VmfsAlreadyMountedFault"] = reflect.TypeOf((*VmfsAlreadyMountedFault)(nil)).Elem()
}

// An 'VmfsAmbiguousMount' fault occurs when ESX is unable to resolve the
// extents of a VMFS volume unambiguously.
//
// This is thrown only when a VMFS
// volume has multiple extents and multiple copies of VMFS volumes are available.
// VMFS layer will not be able to determine how to re-construct the VMFS
// volume as multiple choices are available.
type VmfsAmbiguousMount struct {
	VmfsMountFault
}

func init() {
	t["VmfsAmbiguousMount"] = reflect.TypeOf((*VmfsAmbiguousMount)(nil)).Elem()
}

type VmfsAmbiguousMountFault VmfsAmbiguousMount

func init() {
	t["VmfsAmbiguousMountFault"] = reflect.TypeOf((*VmfsAmbiguousMountFault)(nil)).Elem()
}

type VmfsConfigOption struct {
	DynamicData

	// Supported values of VMFS block size in kilobytes (KB)
	// `HostVmfsVolume.blockSize`.
	BlockSizeOption int32 `xml:"blockSizeOption" json:"blockSizeOption"`
	// Supported values of VMFS unmap granularity
	// `HostVmfsVolume.unmapGranularity`.
	//
	// The unit is KB.
	UnmapGranularityOption []int32 `xml:"unmapGranularityOption,omitempty" json:"unmapGranularityOption,omitempty"`
	// Fixed unmap bandwidth min/max/default value
	UnmapBandwidthFixedValue *LongOption `xml:"unmapBandwidthFixedValue,omitempty" json:"unmapBandwidthFixedValue,omitempty"`
	// Dynamic unmap bandwidth lower limit min/max/default value.
	UnmapBandwidthDynamicMin *LongOption `xml:"unmapBandwidthDynamicMin,omitempty" json:"unmapBandwidthDynamicMin,omitempty"`
	// Dynamic unmap bandwitdth upper limit min/max/default value.
	UnmapBandwidthDynamicMax *LongOption `xml:"unmapBandwidthDynamicMax,omitempty" json:"unmapBandwidthDynamicMax,omitempty"`
	// Increment value of unmap bandwidth
	UnmapBandwidthIncrement int64 `xml:"unmapBandwidthIncrement,omitempty" json:"unmapBandwidthIncrement,omitempty"`
	// Fixed unmap bandwidth ultra low limit value in MB/sec.
	UnmapBandwidthUltraLow int64 `xml:"unmapBandwidthUltraLow,omitempty" json:"unmapBandwidthUltraLow,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VmfsConfigOption"] = reflect.TypeOf((*VmfsConfigOption)(nil)).Elem()
}

// Datastore addition policy to use the entire disk as a single extent for
// a VMFS datastore.
//
// If there is any data on the disk, it will be
// overwritten.
type VmfsDatastoreAllExtentOption struct {
	VmfsDatastoreSingleExtentOption
}

func init() {
	t["VmfsDatastoreAllExtentOption"] = reflect.TypeOf((*VmfsDatastoreAllExtentOption)(nil)).Elem()
}

// Base class that describes a VMFS datastore provisioning option.
type VmfsDatastoreBaseOption struct {
	DynamicData

	// The partition table layout that the disk will have if this
	// provisioning option is selected.
	//
	// In releases after vSphere API 5.0, vSphere Servers might not
	// generate property collector update notifications for this property.
	// To obtain the latest value of the property, you can use
	// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
	// If you use the PropertyCollector.WaitForUpdatesEx method, specify
	// an empty string for the version parameter.
	// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
	// contain values for this property when some other property on the DataObject changes.
	// If this update is a result of a call to WaitForUpdatesEx with a non-empty
	// version parameter, the value for this property may not be current.
	Layout HostDiskPartitionLayout `xml:"layout" json:"layout"`
	// Indicates whether selecting this option will change the partition
	// format type on the disk.
	//
	// See also `HostDiskPartitionInfoPartitionFormat_enum`.
	PartitionFormatChange *bool `xml:"partitionFormatChange" json:"partitionFormatChange,omitempty"`
}

func init() {
	t["VmfsDatastoreBaseOption"] = reflect.TypeOf((*VmfsDatastoreBaseOption)(nil)).Elem()
}

// This data object type is used when creating a new VMFS datastore,
// to create a specification for the VMFS datastore.
type VmfsDatastoreCreateSpec struct {
	VmfsDatastoreSpec

	// Partitioning specification.
	Partition HostDiskPartitionSpec `xml:"partition" json:"partition"`
	// The VMFS creation specification.
	Vmfs HostVmfsSpec `xml:"vmfs" json:"vmfs"`
	// Extents to append to VMFS.
	Extent []HostScsiDiskPartition `xml:"extent,omitempty" json:"extent,omitempty"`
}

func init() {
	t["VmfsDatastoreCreateSpec"] = reflect.TypeOf((*VmfsDatastoreCreateSpec)(nil)).Elem()
}

// Specification to increase the capacity of a VMFS datastore by expanding
// (increasing the size of) an existing extent of the datastore.
type VmfsDatastoreExpandSpec struct {
	VmfsDatastoreSpec

	// Partitioning specification.
	Partition HostDiskPartitionSpec `xml:"partition" json:"partition"`
	// VMFS extent to expand.
	Extent HostScsiDiskPartition `xml:"extent" json:"extent"`
}

func init() {
	t["VmfsDatastoreExpandSpec"] = reflect.TypeOf((*VmfsDatastoreExpandSpec)(nil)).Elem()
}

// Specification to increase the capacity of a VMFS datastore by adding
// one or more new extents to the datastore.
//
// All the extents to be added
// must be on the same disk. Extension is different
// from creation in that the VMFS creation specification need not be
// specified.
type VmfsDatastoreExtendSpec struct {
	VmfsDatastoreSpec

	// Partitioning specification.
	Partition HostDiskPartitionSpec `xml:"partition" json:"partition"`
	// Extents to append to VMFS.
	Extent []HostScsiDiskPartition `xml:"extent" json:"extent"`
}

func init() {
	t["VmfsDatastoreExtendSpec"] = reflect.TypeOf((*VmfsDatastoreExtendSpec)(nil)).Elem()
}

// Information details about a VMFS datastore.
type VmfsDatastoreInfo struct {
	DatastoreInfo

	// Maximum raw device mapping size (physical compatibility)
	MaxPhysicalRDMFileSize int64 `xml:"maxPhysicalRDMFileSize,omitempty" json:"maxPhysicalRDMFileSize,omitempty"`
	// Maximum raw device mapping size (virtual compatibility)
	MaxVirtualRDMFileSize int64 `xml:"maxVirtualRDMFileSize,omitempty" json:"maxVirtualRDMFileSize,omitempty"`
	// The VMFS volume information for the datastore.
	//
	// May not be
	// available when the datastore is not accessible.
	Vmfs *HostVmfsVolume `xml:"vmfs,omitempty" json:"vmfs,omitempty"`
}

func init() {
	t["VmfsDatastoreInfo"] = reflect.TypeOf((*VmfsDatastoreInfo)(nil)).Elem()
}

// Datastore addition policy to use multiple extents on the disk for a VMFS
// datastore.
//
// Multiple extents implies that more than one disk partition
// will be created on the disk for creating or increasing the capacity of a
// VMFS datastore.
// Multiple extents are needed when unpartitioned space is fragmented in the
// existing partition layout of the disk.
type VmfsDatastoreMultipleExtentOption struct {
	VmfsDatastoreBaseOption

	// The block ranges to be used as extents in a VMFS datastore.
	//
	// The first
	// block range will be the head partition.
	VmfsExtent []HostDiskPartitionBlockRange `xml:"vmfsExtent" json:"vmfsExtent"`
}

func init() {
	t["VmfsDatastoreMultipleExtentOption"] = reflect.TypeOf((*VmfsDatastoreMultipleExtentOption)(nil)).Elem()
}

// VMFS datastore provisioning option that can be applied on a disk.
//
// VMFS
// datastores can be created or have their capacity increased using storage
// from a disk.
// There are often multiple ways in which extents can be allocated on a disk.
// Each instance of this structure represents one of the possible options
// that can be applied to provisiong VMFS datastore storage. Only options
// that follow ESX Server best practice guidelines will be presented.
type VmfsDatastoreOption struct {
	DynamicData

	// Information about this VMFS datastore provisioniing option.
	//
	// This
	// structure describes the extent allocation policy represented by
	// this option.
	Info BaseVmfsDatastoreBaseOption `xml:"info,typeattr" json:"info"`
	// Specification to create or increase the capacity of a VMFS datastore.
	//
	// This property contains a configuration specification that can be
	// applied to effect the creation or capacity increase.
	Spec BaseVmfsDatastoreSpec `xml:"spec,typeattr" json:"spec"`
}

func init() {
	t["VmfsDatastoreOption"] = reflect.TypeOf((*VmfsDatastoreOption)(nil)).Elem()
}

// Datastore addition policy to use a single extent on the disk for a VMFS
// datastore.
//
// A single extent implies that one disk partition will be
// created on the disk for creating or increasing the capacity of a VMFS datastore.
type VmfsDatastoreSingleExtentOption struct {
	VmfsDatastoreBaseOption

	// The block range to be used as an extent in a VMFS datastore.
	VmfsExtent HostDiskPartitionBlockRange `xml:"vmfsExtent" json:"vmfsExtent"`
}

func init() {
	t["VmfsDatastoreSingleExtentOption"] = reflect.TypeOf((*VmfsDatastoreSingleExtentOption)(nil)).Elem()
}

// Base class for VMFS datastore addition specification.
//
// Used as a generic
// way to point to one of the creation specifications that can be used to
// apply a specification to effect the creation or extension of a VMFS
// datastore.
type VmfsDatastoreSpec struct {
	DynamicData

	// The UUID of the SCSI disk on which the VMFS datastore is located.
	//
	// See also `HostScsiDisk`, `ScsiLun.uuid`.
	DiskUuid string `xml:"diskUuid" json:"diskUuid"`
}

func init() {
	t["VmfsDatastoreSpec"] = reflect.TypeOf((*VmfsDatastoreSpec)(nil)).Elem()
}

// This is a base class for all VMFS volume mount related faults.
type VmfsMountFault struct {
	HostConfigFault

	// Vmfs volume uuid
	Uuid string `xml:"uuid" json:"uuid"`
}

func init() {
	t["VmfsMountFault"] = reflect.TypeOf((*VmfsMountFault)(nil)).Elem()
}

type VmfsMountFaultFault BaseVmfsMountFault

func init() {
	t["VmfsMountFaultFault"] = reflect.TypeOf((*VmfsMountFaultFault)(nil)).Elem()
}

// VMFS unmap reclaims unused storage space.
//
// This data object type
// describes the specification of VMFS unmap bandwidth.
type VmfsUnmapBandwidthSpec struct {
	DynamicData

	// This property determines the unmap bandwidth policy.
	//
	// See `HostVmfsVolumeUnmapBandwidthPolicy_enum` for supported
	// values. If not specified, the default value is
	// `fixed`, which means
	// unmap is processed at a fixed rate.
	Policy string `xml:"policy" json:"policy"`
	// This property determines the bandwidth under the fixed policy.
	FixedValue int64 `xml:"fixedValue" json:"fixedValue"`
	// This property determines the lower limits of the unmap bandwidth
	// under the dynamic policy.
	DynamicMin int64 `xml:"dynamicMin" json:"dynamicMin"`
	// This property determines the upper limits of the unmap bandwidth
	// under the dynamic policy.
	DynamicMax int64 `xml:"dynamicMax" json:"dynamicMax"`
}

func init() {
	t["VmfsUnmapBandwidthSpec"] = reflect.TypeOf((*VmfsUnmapBandwidthSpec)(nil)).Elem()
}

// This fault is thrown when the Vmotion Interface on this host is not enabled.
//
// The Vmotion Interface is needed for waking up the host from standby mode.
type VmotionInterfaceNotEnabled struct {
	HostPowerOpFailed
}

func init() {
	t["VmotionInterfaceNotEnabled"] = reflect.TypeOf((*VmotionInterfaceNotEnabled)(nil)).Elem()
}

type VmotionInterfaceNotEnabledFault VmotionInterfaceNotEnabled

func init() {
	t["VmotionInterfaceNotEnabledFault"] = reflect.TypeOf((*VmotionInterfaceNotEnabledFault)(nil)).Elem()
}

// This data structure defines the failover policy for a distributed
// virtual switch when network offload is enabled, specifically
// related to the Data Processing Unit(DPU).
//
// The active and standby uplinks are expected to be backed by different
// DPUs to provide redundancy. If DPU backing active uplinks fails, then
// the standby DPU takes over to ensure uninterrupted network connectivity.
type VmwareDistributedVirtualSwitchDpuFailoverPolicy struct {
	DynamicData

	// The name of the active uplink(s).
	//
	// These uplink(s) must be backed
	// by vmnic(s) from a single DPU.
	ActiveUplink []string `xml:"activeUplink,omitempty" json:"activeUplink,omitempty"`
	// The name of the standby uplink(s).
	//
	// These uplink(s) must be backed
	// by vmnic(s) from a different DPU than the active uplink(s).
	// An empty standbyUplink indicates that no failover action will be
	// taken after the active DPU fails.
	StandbyUplink []string `xml:"standbyUplink,omitempty" json:"standbyUplink,omitempty"`
}

func init() {
	t["VmwareDistributedVirtualSwitchDpuFailoverPolicy"] = reflect.TypeOf((*VmwareDistributedVirtualSwitchDpuFailoverPolicy)(nil)).Elem()
	minAPIVersionForType["VmwareDistributedVirtualSwitchDpuFailoverPolicy"] = "8.0.3.0"
}

// This data structure defines the network offoad specific configuration of
// a distributed virtual switch.
type VmwareDistributedVirtualSwitchNetworkOffloadConfig struct {
	DynamicData

	// The DPU failover policy of the switch.
	//
	// If this property is not set, all uplink ports are active uplinks.
	DpuFailoverPolicy *VmwareDistributedVirtualSwitchDpuFailoverPolicy `xml:"dpuFailoverPolicy,omitempty" json:"dpuFailoverPolicy,omitempty"`
}

func init() {
	t["VmwareDistributedVirtualSwitchNetworkOffloadConfig"] = reflect.TypeOf((*VmwareDistributedVirtualSwitchNetworkOffloadConfig)(nil)).Elem()
	minAPIVersionForType["VmwareDistributedVirtualSwitchNetworkOffloadConfig"] = "8.0.3.0"
}

// This data type defines the configuration when PVLAN id is to be
// used for the ports.
type VmwareDistributedVirtualSwitchPvlanSpec struct {
	VmwareDistributedVirtualSwitchVlanSpec

	// The `VMwareDVSPvlanMapEntry.secondaryVlanId`.
	PvlanId int32 `xml:"pvlanId" json:"pvlanId"`
}

func init() {
	t["VmwareDistributedVirtualSwitchPvlanSpec"] = reflect.TypeOf((*VmwareDistributedVirtualSwitchPvlanSpec)(nil)).Elem()
}

// This data type specifies that the port uses trunk mode,
// which allows the guest operating system to manage its own VLAN tags.
type VmwareDistributedVirtualSwitchTrunkVlanSpec struct {
	VmwareDistributedVirtualSwitchVlanSpec

	// The VlanId range for the trunk port.
	//
	// The valid VlanId range is
	// from 0 to 4094. Overlapping ranges are allowed.
	VlanId []NumericRange `xml:"vlanId,omitempty" json:"vlanId,omitempty"`
}

func init() {
	t["VmwareDistributedVirtualSwitchTrunkVlanSpec"] = reflect.TypeOf((*VmwareDistributedVirtualSwitchTrunkVlanSpec)(nil)).Elem()
}

// This data type defines the configuration when single vlanId is used for
// the port.
type VmwareDistributedVirtualSwitchVlanIdSpec struct {
	VmwareDistributedVirtualSwitchVlanSpec

	// The VLAN ID for ports.
	//
	// Possible values:
	//   - A value of 0 specifies that you do not want the port associated
	//     with a VLAN.
	//   - A value from 1 to 4094 specifies a VLAN ID for the port.
	VlanId int32 `xml:"vlanId" json:"vlanId"`
}

func init() {
	t["VmwareDistributedVirtualSwitchVlanIdSpec"] = reflect.TypeOf((*VmwareDistributedVirtualSwitchVlanIdSpec)(nil)).Elem()
}

// Base class for Vlan Specifiation for ports.
type VmwareDistributedVirtualSwitchVlanSpec struct {
	InheritablePolicy
}

func init() {
	t["VmwareDistributedVirtualSwitchVlanSpec"] = reflect.TypeOf((*VmwareDistributedVirtualSwitchVlanSpec)(nil)).Elem()
}

// Policy for a uplink port team.
type VmwareUplinkPortTeamingPolicy struct {
	InheritablePolicy

	// Network adapter teaming policy.
	//
	// The policy defines the way traffic
	// from the clients of the team is routed through the different uplinks
	// in the team. The policies supported on the VDS platform is one of
	// `nicTeamingPolicy`.
	Policy *StringPolicy `xml:"policy,omitempty" json:"policy,omitempty"`
	// The flag to indicate whether or not the teaming policy is applied
	// to inbound frames as well.
	//
	// Also see `HostNicTeamingPolicy.reversePolicy`
	ReversePolicy *BoolPolicy `xml:"reversePolicy,omitempty" json:"reversePolicy,omitempty"`
	// Flag to specify whether or not to notify the physical switch
	// if a link fails.
	//
	// Also see `HostNicTeamingPolicy.notifySwitches`
	NotifySwitches *BoolPolicy `xml:"notifySwitches,omitempty" json:"notifySwitches,omitempty"`
	// The flag to indicate whether or not to use a rolling policy when
	// restoring links.
	//
	// Also see `HostNicTeamingPolicy.rollingOrder`
	RollingOrder *BoolPolicy `xml:"rollingOrder,omitempty" json:"rollingOrder,omitempty"`
	// Failover detection policy for the uplink port team.
	FailureCriteria *DVSFailureCriteria `xml:"failureCriteria,omitempty" json:"failureCriteria,omitempty"`
	// Failover order policy for uplink ports on the hosts.
	UplinkPortOrder *VMwareUplinkPortOrderPolicy `xml:"uplinkPortOrder,omitempty" json:"uplinkPortOrder,omitempty"`
}

func init() {
	t["VmwareUplinkPortTeamingPolicy"] = reflect.TypeOf((*VmwareUplinkPortTeamingPolicy)(nil)).Elem()
}

// This argument records a Virtual NIC device that connects to a DVPort.
type VnicPortArgument struct {
	DynamicData

	// The Virtual NIC devices that were using the DVports.
	Vnic string `xml:"vnic" json:"vnic"`
	// The DVPorts that were being used.
	Port DistributedVirtualSwitchPortConnection `xml:"port" json:"port"`
}

func init() {
	t["VnicPortArgument"] = reflect.TypeOf((*VnicPortArgument)(nil)).Elem()
}

// An error occurred in the Open Source Components applications during
// volume editing.
//
// Possibly caused by an incompatible cygwin version
// installed in the VirtualCenter server.
type VolumeEditorError struct {
	CustomizationFault
}

func init() {
	t["VolumeEditorError"] = reflect.TypeOf((*VolumeEditorError)(nil)).Elem()
}

type VolumeEditorErrorFault VolumeEditorError

func init() {
	t["VolumeEditorErrorFault"] = reflect.TypeOf((*VolumeEditorErrorFault)(nil)).Elem()
}

// A VramLimitLicense fault is thrown if executing an operation
// would result in exceeding maximum allowed vRAM amount.
//
// For example, this could happen when powering on a VM,
// hot-plugging memory into a running VMm, etc.
type VramLimitLicense struct {
	NotEnoughLicenses

	// The maximum allowed vRAM amount.
	Limit int32 `xml:"limit" json:"limit"`
}

func init() {
	t["VramLimitLicense"] = reflect.TypeOf((*VramLimitLicense)(nil)).Elem()
}

type VramLimitLicenseFault VramLimitLicense

func init() {
	t["VramLimitLicenseFault"] = reflect.TypeOf((*VramLimitLicenseFault)(nil)).Elem()
}

// The `VsanClusterConfigInfo` data object contains configuration
// data for the VSAN service in a cluster.
//
// This data object is used both for
// specifying cluster-wide settings when updating the VSAN service, and as an
// output datatype when retrieving current cluster-wide VSAN service settings.
//
// See also `ComputeResource.ReconfigureComputeResource_Task`.
type VsanClusterConfigInfo struct {
	DynamicData

	// Whether the VSAN service is enabled for the cluster.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// Default VSAN settings to use for hosts admitted to the cluster when the
	// VSAN service is enabled.
	//
	// If omitted, values will default as though the
	// fields in the `VsanClusterConfigInfoHostDefaultInfo` have been omitted.
	//
	// See also `VsanClusterConfigInfo.enabled`, `VsanClusterConfigInfoHostDefaultInfo`.
	DefaultConfig *VsanClusterConfigInfoHostDefaultInfo `xml:"defaultConfig,omitempty" json:"defaultConfig,omitempty"`
	// Whether the vSAN ESA is enabled for vSAN cluster.
	//
	// This can only be
	// enabled when vSAN is enabled on the cluster.
	VsanEsaEnabled *bool `xml:"vsanEsaEnabled" json:"vsanEsaEnabled,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VsanClusterConfigInfo"] = reflect.TypeOf((*VsanClusterConfigInfo)(nil)).Elem()
}

// Default VSAN service configuration to be used for hosts admitted
// to the cluster.
//
// See also `VsanClusterConfigInfo.defaultConfig`.
type VsanClusterConfigInfoHostDefaultInfo struct {
	DynamicData

	// VSAN service cluster UUID, in the string form
	// "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn", where n are hexadecimal
	// digits.
	//
	// When enabling the VSAN service on the cluster, this value shall
	// not be specified by the user; a suitable UUID will be generated
	// by the platform.
	// While the VSAN service is enabled, this is a read-only value.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// Deprecated as this configuration will be deprecated, autoclaim
	// will be no longer supported.
	//
	// Whether the VSAN service is configured to automatically claim local
	// storage on VSAN-enabled hosts in the cluster.
	//
	// If omitted while enabling the VSAN service, this value will default
	// to <code>true</code>.
	// Changing this value to <code>false</code> shall not affect any
	// existing disk mappings in use by hosts currently participating in
	// the VSAN service.
	// Changing this value to <code>true</code> will result in local disks
	// being automatically claimed for use by the VSAN service, for hosts
	// currently participating in the VSAN service.
	//
	// See also `VsanHostConfigInfoStorageInfo.diskMapping`, `VsanHostConfigInfoStorageInfo.autoClaimStorage`.
	AutoClaimStorage *bool `xml:"autoClaimStorage" json:"autoClaimStorage,omitempty"`
	// Whether the VSAN service is configured to enforce checksum protection.
	//
	// If omitted while enabling the VSAN service, this value will default
	// to <code>false<code>.
	// Change this value to <code>false</code> shall not affect any existing
	// disk status.
	// Changing this value to <code>true</code> shall do disk enforcement
	// check that all VSAN disks are checksum enabled.
	ChecksumEnabled *bool `xml:"checksumEnabled" json:"checksumEnabled,omitempty"`
}

func init() {
	t["VsanClusterConfigInfoHostDefaultInfo"] = reflect.TypeOf((*VsanClusterConfigInfoHostDefaultInfo)(nil)).Elem()
}

// Fault thrown for the case that an attempt is made to move a host which
// is enabled for VSAN into a `ClusterComputeResource` whose
// VSAN cluster UUID does not match.
//
// See also `CannotMoveVsanEnabledHost`.
type VsanClusterUuidMismatch struct {
	CannotMoveVsanEnabledHost

	// The VSAN cluster UUID in use by the host at hand.
	HostClusterUuid string `xml:"hostClusterUuid" json:"hostClusterUuid"`
	// The VSAN cluster UUID in use by the destination
	// `ClusterComputeResource`.
	DestinationClusterUuid string `xml:"destinationClusterUuid" json:"destinationClusterUuid"`
}

func init() {
	t["VsanClusterUuidMismatch"] = reflect.TypeOf((*VsanClusterUuidMismatch)(nil)).Elem()
}

type VsanClusterUuidMismatchFault VsanClusterUuidMismatch

func init() {
	t["VsanClusterUuidMismatchFault"] = reflect.TypeOf((*VsanClusterUuidMismatchFault)(nil)).Elem()
}

// Detailed information about a vSAN datastore.
type VsanDatastoreInfo struct {
	DatastoreInfo

	// The cluster membership identity of the datastore.
	MembershipUuid string `xml:"membershipUuid,omitempty" json:"membershipUuid,omitempty"`
	// The generation number tracking datastore accessibility.
	AccessGenNo int32 `xml:"accessGenNo,omitempty" json:"accessGenNo,omitempty"`
}

func init() {
	t["VsanDatastoreInfo"] = reflect.TypeOf((*VsanDatastoreInfo)(nil)).Elem()
	minAPIVersionForType["VsanDatastoreInfo"] = "7.0.1.0"
}

// Base exception class for VSAN disk-related faults.
type VsanDiskFault struct {
	VsanFault

	// The canonical name for the disk at hand, if applicable.
	//
	// See also `ScsiLun.canonicalName`.
	Device string `xml:"device,omitempty" json:"device,omitempty"`
}

func init() {
	t["VsanDiskFault"] = reflect.TypeOf((*VsanDiskFault)(nil)).Elem()
}

type VsanDiskFaultFault BaseVsanDiskFault

func init() {
	t["VsanDiskFaultFault"] = reflect.TypeOf((*VsanDiskFaultFault)(nil)).Elem()
}

// Base exception class for VSAN-specific faults raised for host
// or cluster operations.
//
// See also `HostVsanSystem`, `ComputeResource.ReconfigureComputeResource_Task`.
type VsanFault struct {
	VimFault
}

func init() {
	t["VsanFault"] = reflect.TypeOf((*VsanFault)(nil)).Elem()
}

type VsanFaultFault BaseVsanFault

func init() {
	t["VsanFaultFault"] = reflect.TypeOf((*VsanFaultFault)(nil)).Elem()
}

// The `VsanHostClusterStatus` data object contains a host's cluster status
// information for the VSAN service.
//
// This data object is used to represent
// read-only state whose values may change during operation.
//
// See also `HostVsanSystem.QueryHostStatus`.
type VsanHostClusterStatus struct {
	DynamicData

	// VSAN service cluster UUID.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// VSAN node UUID for this host.
	NodeUuid string `xml:"nodeUuid,omitempty" json:"nodeUuid,omitempty"`
	// VSAN health state for this host.
	//
	// See also `VsanHostHealthState_enum`.
	Health string `xml:"health" json:"health"`
	// VSAN node state for this host.
	NodeState VsanHostClusterStatusState `xml:"nodeState" json:"nodeState"`
	// List of UUIDs for VSAN nodes known to this host.
	MemberUuid []string `xml:"memberUuid,omitempty" json:"memberUuid,omitempty"`
}

func init() {
	t["VsanHostClusterStatus"] = reflect.TypeOf((*VsanHostClusterStatus)(nil)).Elem()
}

// Data object representing the VSAN node state for a host.
type VsanHostClusterStatusState struct {
	DynamicData

	// VSAN node state for this host.
	//
	// See also `VsanHostNodeState_enum`.
	State string `xml:"state" json:"state"`
	// An estimation of the completion of a node state transition; this
	// value may be populated for transitory node states.
	//
	// See also `VsanHostNodeState_enum`.
	Completion *VsanHostClusterStatusStateCompletionEstimate `xml:"completion,omitempty" json:"completion,omitempty"`
}

func init() {
	t["VsanHostClusterStatusState"] = reflect.TypeOf((*VsanHostClusterStatusState)(nil)).Elem()
}

// Estimated completion status for transitory node states.
//
// See also `VsanHostNodeState_enum`.
type VsanHostClusterStatusStateCompletionEstimate struct {
	DynamicData

	// Estimated time of completion.
	CompleteTime *time.Time `xml:"completeTime" json:"completeTime,omitempty"`
	// Estimated percent of completion as a value in the range \[0, 100\].
	PercentComplete int32 `xml:"percentComplete,omitempty" json:"percentComplete,omitempty"`
}

func init() {
	t["VsanHostClusterStatusStateCompletionEstimate"] = reflect.TypeOf((*VsanHostClusterStatusStateCompletionEstimate)(nil)).Elem()
}

// The `VsanHostConfigInfo` data object contains host-specific settings
// for the VSAN service.
//
// This data object is used both for specifying
// settings for updating the VSAN service, and as an output datatype
// when retrieving current VSAN service settings.
type VsanHostConfigInfo struct {
	DynamicData

	// Whether the VSAN service is currently enabled on this host.
	Enabled *bool `xml:"enabled" json:"enabled,omitempty"`
	// The `HostSystem` for this host.
	//
	// This argument is required when this configuration is specified as
	// an input to VC-level APIs. When this configuration is specified
	// to a host-level direct API, this argument may be omitted.
	//
	// See also `ComputeResource.ReconfigureComputeResource_Task`, `HostVsanSystem.UpdateVsan_Task`.
	//
	// Refers instance of `HostSystem`.
	HostSystem *ManagedObjectReference `xml:"hostSystem,omitempty" json:"hostSystem,omitempty"`
	// The VSAN service cluster configuration for this host.
	ClusterInfo *VsanHostConfigInfoClusterInfo `xml:"clusterInfo,omitempty" json:"clusterInfo,omitempty"`
	// The VSAN storage configuration for this host.
	//
	// VSAN storage configuration settings are independent of the
	// current value of `VsanHostConfigInfo.enabled`.
	StorageInfo *VsanHostConfigInfoStorageInfo `xml:"storageInfo,omitempty" json:"storageInfo,omitempty"`
	// The VSAN network configuration for this host.
	//
	// VSAN network configuration settings are independent of the
	// current value of `VsanHostConfigInfo.enabled`.
	NetworkInfo *VsanHostConfigInfoNetworkInfo `xml:"networkInfo,omitempty" json:"networkInfo,omitempty"`
	// The VSAN fault domain configuration for this host.
	//
	// VSAN host fault domain settings are independent of the
	// current value of `VsanHostConfigInfo.enabled`.
	FaultDomainInfo *VsanHostFaultDomainInfo `xml:"faultDomainInfo,omitempty" json:"faultDomainInfo,omitempty"`
	// Whether the vSAN ESA is enabled on this host.
	//
	// This can only be
	// enabled when vSAN is enabled on this host.
	VsanEsaEnabled *bool `xml:"vsanEsaEnabled" json:"vsanEsaEnabled,omitempty" vim:"8.0.0.1"`
}

func init() {
	t["VsanHostConfigInfo"] = reflect.TypeOf((*VsanHostConfigInfo)(nil)).Elem()
}

// Host-local VSAN cluster configuration.
//
// This data object is used
// both for specifying and retrieving cluster configuration for a
// host participating in the VSAN service.
type VsanHostConfigInfoClusterInfo struct {
	DynamicData

	// VSAN service cluster UUID, in the string form
	// "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn", where n are hexadecimal
	// digits.
	//
	// If provided while enabling the VSAN service, this value will be
	// used for the service cluster UUID. If omitted when enabling the
	// VSAN service, a suitable UUID will be generated by the platform.
	// This is a read-only value while the VSAN service is enabled.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// VSAN node UUID for this host.
	//
	// This is a read-only value which is populated upon enabling of the
	// VSAN service.
	NodeUuid string `xml:"nodeUuid,omitempty" json:"nodeUuid,omitempty"`
}

func init() {
	t["VsanHostConfigInfoClusterInfo"] = reflect.TypeOf((*VsanHostConfigInfoClusterInfo)(nil)).Elem()
}

// Host-local VSAN network configuration.
//
// This data object is used
// both for specifying and retrieving network configuration for a
// host participating in the VSAN service.
type VsanHostConfigInfoNetworkInfo struct {
	DynamicData

	// Set of PortConfig entries for use by the VSAN service, one per
	// "virtual network" as used by VSAN.
	Port []VsanHostConfigInfoNetworkInfoPortConfig `xml:"port,omitempty" json:"port,omitempty"`
}

func init() {
	t["VsanHostConfigInfoNetworkInfo"] = reflect.TypeOf((*VsanHostConfigInfoNetworkInfo)(nil)).Elem()
}

// A PortConfig represents a virtual network adapter and its
// configuration for use by the VSAN service.
//
// See also `HostVirtualNic`.
type VsanHostConfigInfoNetworkInfoPortConfig struct {
	DynamicData

	// `VsanHostIpConfig` for this PortConfig.
	IpConfig *VsanHostIpConfig `xml:"ipConfig,omitempty" json:"ipConfig,omitempty"`
	// Device name which identifies the network adapter for this
	// PortConfig.
	//
	// See also `HostVirtualNic.device`.
	Device string `xml:"device" json:"device"`
}

func init() {
	t["VsanHostConfigInfoNetworkInfoPortConfig"] = reflect.TypeOf((*VsanHostConfigInfoNetworkInfoPortConfig)(nil)).Elem()
}

// Host-local VSAN storage configuration.
//
// This data object is used
// both for specifying and retrieving storage configuration for a
// host participating in the VSAN service.
type VsanHostConfigInfoStorageInfo struct {
	DynamicData

	// Deprecated as this configuration will be deprecated, autoclaim
	// will be no longer supported.
	//
	// Whether the VSAN service is configured to automatically claim local
	// unused storage on this host.
	//
	// When set, the VSAN service will automatically format and use local
	// disks. Side effects from any disk consumption will be reflected in
	// `VsanHostConfigInfoStorageInfo.diskMapping`.
	// If this argument is specified as a host-level configuration input
	// at the VC-level (see `ClusterConfigInfoEx.vsanHostConfig`),
	// it will override that of any cluster-level default value.
	//
	// See also `VsanHostConfigInfoStorageInfo.diskMapping`, `ClusterConfigInfoEx.vsanHostConfig`, `VsanClusterConfigInfo.defaultConfig`.
	AutoClaimStorage *bool `xml:"autoClaimStorage" json:"autoClaimStorage,omitempty"`
	// Deprecated use `VsanHostConfigInfoStorageInfo.diskMapInfo` instead.
	//
	// List of `VsanHostDiskMapping` entries in use by the VSAN service.
	//
	// DiskMappings to be used by the VSAN service may be manually
	// specified using
	// `HostVsanSystem.InitializeDisks_Task`.
	//
	// See also `HostVsanSystem.InitializeDisks_Task`.
	DiskMapping []VsanHostDiskMapping `xml:"diskMapping,omitempty" json:"diskMapping,omitempty"`
	// List of `VsanHostDiskMapping` entries with runtime information from
	// the perspective of this host.
	DiskMapInfo []VsanHostDiskMapInfo `xml:"diskMapInfo,omitempty" json:"diskMapInfo,omitempty"`
	// Deprecated this attribute was originally used for indicating whether
	// hardware checksums is supported on the disks. But in vSphere 2016
	// hardware checksums are replaced with software implementation,
	// supported by all disks. This makes current field redundant,
	// and its value as an input/output is ignored.
	//
	// Whether checksum is enabled on all the disks in this host.
	//
	// If any disk is not checksum capable or 520 bps formatted,
	// we will skip it.
	ChecksumEnabled *bool `xml:"checksumEnabled" json:"checksumEnabled,omitempty"`
}

func init() {
	t["VsanHostConfigInfoStorageInfo"] = reflect.TypeOf((*VsanHostConfigInfoStorageInfo)(nil)).Elem()
}

// A `VsanHostDecommissionMode` defines an action to take upon decommissioning
// a host from use with the VSAN service.
//
// If the VSAN service DecommissionMode is omitted in a call to
// `HostSystem.EnterMaintenanceMode_Task`, the default action chosen
// will be `ensureObjectAccessibility`.
//
// See also `HostSystem.EnterMaintenanceMode_Task`, `HostMaintenanceSpec.vsanMode`.
type VsanHostDecommissionMode struct {
	DynamicData

	// Specifies an action to take with regard to the VSAN service upon
	// putting a host into maintenance mode.
	//
	// See also `VsanHostDecommissionModeObjectAction_enum`.
	ObjectAction string `xml:"objectAction" json:"objectAction"`
}

func init() {
	t["VsanHostDecommissionMode"] = reflect.TypeOf((*VsanHostDecommissionMode)(nil)).Elem()
}

// A DiskMapInfo represents a `VsanHostDiskMapping` and its
// corresponding runtime information.
//
// See also `VsanHostConfigInfoStorageInfo`, `HostVsanSystem.InitializeDisks_Task`.
type VsanHostDiskMapInfo struct {
	DynamicData

	// DiskMapping.
	Mapping VsanHostDiskMapping `xml:"mapping" json:"mapping"`
	// Indicates whether the `VsanHostDiskMapping` is mounted.
	Mounted bool `xml:"mounted" json:"mounted"`
}

func init() {
	t["VsanHostDiskMapInfo"] = reflect.TypeOf((*VsanHostDiskMapInfo)(nil)).Elem()
}

// A DiskMapResult represents the result of an operation performed
// on the set of disks in a `VsanHostDiskMapping`.
//
// See also `HostVsanSystem.InitializeDisks_Task`, `HostVsanSystem.UpdateVsan_Task`.
type VsanHostDiskMapResult struct {
	DynamicData

	// DiskMapping for this result.
	Mapping VsanHostDiskMapping `xml:"mapping" json:"mapping"`
	// List of results for each disk in the mapping.
	DiskResult []VsanHostDiskResult `xml:"diskResult,omitempty" json:"diskResult,omitempty"`
	// Error information for this result.
	//
	// See also `VsanDiskFault`.
	Error *LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
}

func init() {
	t["VsanHostDiskMapResult"] = reflect.TypeOf((*VsanHostDiskMapResult)(nil)).Elem()
}

// A `VsanHostDiskMapping` is a set of one SSD `HostScsiDisk` backed
// by a set of one or more non-SSD `HostScsiDisk`.
//
// The maximum
// allowed `VsanHostDiskMapping` for a host is 5. A maximum set
// of 7 non-SSDs `HostScsiDisk` can be added to the one
// SSD `HostScsiDisk`.
//
// See also `VsanHostConfigInfoStorageInfo`, `HostVsanSystem.InitializeDisks_Task`.
type VsanHostDiskMapping struct {
	DynamicData

	// SSD `HostScsiDisk`.
	Ssd HostScsiDisk `xml:"ssd" json:"ssd"`
	// Set of non-SSD backing `HostScsiDisk`.
	NonSsd []HostScsiDisk `xml:"nonSsd" json:"nonSsd"`
}

func init() {
	t["VsanHostDiskMapping"] = reflect.TypeOf((*VsanHostDiskMapping)(nil)).Elem()
}

// A DiskResult represents the result of VSAN configuration operation
// on a `HostScsiDisk`, and its current eligibility state for use by
// the VSAN service.
//
// See also `HostVsanSystem.QueryDisksForVsan`, `HostVsanSystem.UpdateVsan_Task`, `VsanHostDiskResultState_enum`.
type VsanHostDiskResult struct {
	DynamicData

	// Disk for this result.
	Disk HostScsiDisk `xml:"disk" json:"disk"`
	// State of the disk for this result.
	//
	// See also `VsanHostDiskResultState_enum`.
	State string `xml:"state" json:"state"`
	// VSAN disk UUID in case this disk is a VSAN disk.
	VsanUuid string `xml:"vsanUuid,omitempty" json:"vsanUuid,omitempty"`
	// Error information for this result: may be populated with additional
	// information about the disk at hand, regardless of the disk's state.
	//
	// See also `VsanDiskFault`, `VsanHostDiskResult.state`.
	Error *LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
	// Indicates whether the disk is degraded in VSAN performance.
	//
	// If set, indicates the disk performance is degraded in VSAN
	// If unset, it is unknown whether the disk performance is degraded in VSAN.
	Degraded *bool `xml:"degraded" json:"degraded,omitempty"`
}

func init() {
	t["VsanHostDiskResult"] = reflect.TypeOf((*VsanHostDiskResult)(nil)).Elem()
}

// Host-local VSAN fault domain configuration.
//
// This data object is used
// both for specifying and retrieving fault domain configuration for a
// host participating in the VSAN service.
type VsanHostFaultDomainInfo struct {
	DynamicData

	// The configured VSAN fault domain.
	//
	// The length of fault domain name should not exceed 256.
	// Empty string indicates that the default fault domain is used.
	Name string `xml:"name" json:"name"`
}

func init() {
	t["VsanHostFaultDomainInfo"] = reflect.TypeOf((*VsanHostFaultDomainInfo)(nil)).Elem()
}

// An `VsanHostIpConfig` is a pair of multicast IP addresses for use by the VSAN
// service.
//
// For VSAN there is one such IpConfig pair per "virtual network" as
// represented by `VsanHostConfigInfoNetworkInfoPortConfig`.
//
// See also `VsanHostConfigInfoNetworkInfo`, `VsanHostConfigInfoNetworkInfo.port`, `VsanHostConfigInfoNetworkInfoPortConfig`, `HostVsanSystem.UpdateVsan_Task`.
type VsanHostIpConfig struct {
	DynamicData

	// Agent-to-master multicast IP address.
	UpstreamIpAddress string `xml:"upstreamIpAddress" json:"upstreamIpAddress"`
	// Master-to-agent multicast IP address.
	DownstreamIpAddress string `xml:"downstreamIpAddress" json:"downstreamIpAddress"`
}

func init() {
	t["VsanHostIpConfig"] = reflect.TypeOf((*VsanHostIpConfig)(nil)).Elem()
}

// The `VsanHostMembershipInfo` data object contains VSAN cluster
// membership information for a single host, as observed from a
// given host.
//
// This data object is used to represent read-only
// state whose values may change during operation.
//
// See also `HostRuntimeInfo.vsanRuntimeInfo`.
type VsanHostMembershipInfo struct {
	DynamicData

	// VSAN node UUID for the host of this MembershipInfo.
	//
	// See also `VsanHostClusterStatus.nodeUuid`.
	NodeUuid string `xml:"nodeUuid" json:"nodeUuid"`
	// Hostname for the host of this MembershipInfo.
	//
	// May be the empty string "" if the hostname is unavailable.
	Hostname string `xml:"hostname" json:"hostname"`
}

func init() {
	t["VsanHostMembershipInfo"] = reflect.TypeOf((*VsanHostMembershipInfo)(nil)).Elem()
}

// This data object contains VSAN cluster runtime information from
// the perspective of the host in question.
//
// This data object is used to represent read-only state whose values
// may change during operation.
type VsanHostRuntimeInfo struct {
	DynamicData

	// This property reports host membership information.
	MembershipList []VsanHostMembershipInfo `xml:"membershipList,omitempty" json:"membershipList,omitempty"`
	// List of disk issues detected on this host.
	//
	// To retrieve more information on the issues, use
	// `HostVsanSystem.QueryDisksForVsan`.
	DiskIssues []VsanHostRuntimeInfoDiskIssue `xml:"diskIssues,omitempty" json:"diskIssues,omitempty"`
	// Generation number tracking object accessibility.
	AccessGenNo int32 `xml:"accessGenNo,omitempty" json:"accessGenNo,omitempty"`
}

func init() {
	t["VsanHostRuntimeInfo"] = reflect.TypeOf((*VsanHostRuntimeInfo)(nil)).Elem()
}

// Data structure of reporting a disk issue.
type VsanHostRuntimeInfoDiskIssue struct {
	DynamicData

	// Disk uuid, @see vim.host.ScsiLun#uuid
	DiskId string `xml:"diskId" json:"diskId"`
	// Type of issue
	//
	// See also `VsanDiskIssueType_enum`.
	Issue string `xml:"issue" json:"issue"`
}

func init() {
	t["VsanHostRuntimeInfoDiskIssue"] = reflect.TypeOf((*VsanHostRuntimeInfoDiskIssue)(nil)).Elem()
}

// A VsanDiskInfo represents the additional detailed
// information of a ScsiDisk used by VSAN,
// to map physical disk to VSAN disk.
//
// See also `HostScsiDisk`.
type VsanHostVsanDiskInfo struct {
	DynamicData

	// Disk UUID in VSAN
	VsanUuid string `xml:"vsanUuid" json:"vsanUuid"`
	// VSAN file system version number
	FormatVersion int32 `xml:"formatVersion" json:"formatVersion"`
}

func init() {
	t["VsanHostVsanDiskInfo"] = reflect.TypeOf((*VsanHostVsanDiskInfo)(nil)).Elem()
}

// Fault used for the add operation which will result in incompatible
// disk mappings.
//
// See also `HostVsanSystem.InitializeDisks_Task`.
type VsanIncompatibleDiskMapping struct {
	VsanDiskFault
}

func init() {
	t["VsanIncompatibleDiskMapping"] = reflect.TypeOf((*VsanIncompatibleDiskMapping)(nil)).Elem()
}

type VsanIncompatibleDiskMappingFault VsanIncompatibleDiskMapping

func init() {
	t["VsanIncompatibleDiskMappingFault"] = reflect.TypeOf((*VsanIncompatibleDiskMappingFault)(nil)).Elem()
}

// NewPolicyBatch --
// Structure to specify a list of object sizes and a policy for what-if
// analysis.
type VsanNewPolicyBatch struct {
	DynamicData

	// Size (in bytes) of the objects.
	Size []int64 `xml:"size,omitempty" json:"size,omitempty"`
	// New policy in SPBM or VSAN expression format.
	Policy string `xml:"policy,omitempty" json:"policy,omitempty"`
}

func init() {
	t["VsanNewPolicyBatch"] = reflect.TypeOf((*VsanNewPolicyBatch)(nil)).Elem()
}

// PolicyChangeBatch --
// Structure to specify a list of object uuids and a policy for what-if
// analysis.
type VsanPolicyChangeBatch struct {
	DynamicData

	// UUIDs of the objects.
	Uuid []string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// New policy in SPBM or VSAN expression format.
	Policy string `xml:"policy,omitempty" json:"policy,omitempty"`
}

func init() {
	t["VsanPolicyChangeBatch"] = reflect.TypeOf((*VsanPolicyChangeBatch)(nil)).Elem()
}

// PolicyCost --
// Structure to describe the cost of satisfying a policy.
type VsanPolicyCost struct {
	DynamicData

	// Change (in bytes) of size of data stored on the datastore.
	//
	// This is
	// the max of reserved and used capacity.
	ChangeDataSize int64 `xml:"changeDataSize,omitempty" json:"changeDataSize,omitempty"`
	// Size (in bytes) of data currently stored on the datastore.
	//
	// This is
	// the max of reserved and used capacity.
	CurrentDataSize int64 `xml:"currentDataSize,omitempty" json:"currentDataSize,omitempty"`
	// Size (in bytes) for temporary data that will be needed on disk if
	// new policy is applied.
	TempDataSize int64 `xml:"tempDataSize,omitempty" json:"tempDataSize,omitempty"`
	// Size (in bytes) of data we need to write to VSAN Datastore if new
	// policy is applied.
	CopyDataSize int64 `xml:"copyDataSize,omitempty" json:"copyDataSize,omitempty"`
	// Change (in bytes) of flash space reserved for read cache if new
	// policy is applied.
	ChangeFlashReadCacheSize int64 `xml:"changeFlashReadCacheSize,omitempty" json:"changeFlashReadCacheSize,omitempty"`
	// Size (in bytes) of flash space currently reserved for read cache.
	CurrentFlashReadCacheSize int64 `xml:"currentFlashReadCacheSize,omitempty" json:"currentFlashReadCacheSize,omitempty"`
	// Current ratio of physical disk space of an object to the logical VSAN
	// address space.
	//
	// For eg. an object of size 1GB with two copies of the
	// data has two 1GB replicas and so this ratio is 2.
	CurrentDiskSpaceToAddressSpaceRatio float32 `xml:"currentDiskSpaceToAddressSpaceRatio,omitempty" json:"currentDiskSpaceToAddressSpaceRatio,omitempty"`
	// Ratio of physical disk space of an object to the logical VSAN
	// address space after new policy is applied.
	//
	// For eg. an object of size
	// 1GB with two copies of the data has two 1GB replicas and so this
	// ratio is 2.
	DiskSpaceToAddressSpaceRatio float32 `xml:"diskSpaceToAddressSpaceRatio,omitempty" json:"diskSpaceToAddressSpaceRatio,omitempty"`
}

func init() {
	t["VsanPolicyCost"] = reflect.TypeOf((*VsanPolicyCost)(nil)).Elem()
}

// PolicySatisfiablity --
// Structure to describe whether a policy can be satisfied.
type VsanPolicySatisfiability struct {
	DynamicData

	// UUID of the object.
	Uuid string `xml:"uuid,omitempty" json:"uuid,omitempty"`
	// Can the policy be satisfied given the assumptions of the API that
	// queried satisfiability.
	//
	// See also `HostVsanInternalSystem.ReconfigurationSatisfiable`.
	IsSatisfiable bool `xml:"isSatisfiable" json:"isSatisfiable"`
	// Reason for not being able to satisfy the policy; This is unset if
	// policy can be satisfied.
	Reason *LocalizableMessage `xml:"reason,omitempty" json:"reason,omitempty"`
	// Cost of satisfying the new policy; This is unset if policy cannot be
	// satisfied.
	Cost *VsanPolicyCost `xml:"cost,omitempty" json:"cost,omitempty"`
}

func init() {
	t["VsanPolicySatisfiability"] = reflect.TypeOf((*VsanPolicySatisfiability)(nil)).Elem()
}

// Pre-flight check encountered a VC plumbing issue.
type VsanUpgradeSystemAPIBrokenIssue struct {
	VsanUpgradeSystemPreflightCheckIssue

	// Hosts this issue applies to.
	//
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts" json:"hosts"`
}

func init() {
	t["VsanUpgradeSystemAPIBrokenIssue"] = reflect.TypeOf((*VsanUpgradeSystemAPIBrokenIssue)(nil)).Elem()
}

// Pre-flight check encountered at least one host with auto-claim enabled.
type VsanUpgradeSystemAutoClaimEnabledOnHostsIssue struct {
	VsanUpgradeSystemPreflightCheckIssue

	// Hosts this issue applies to.
	//
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts" json:"hosts"`
}

func init() {
	t["VsanUpgradeSystemAutoClaimEnabledOnHostsIssue"] = reflect.TypeOf((*VsanUpgradeSystemAutoClaimEnabledOnHostsIssue)(nil)).Elem()
}

// Pre-flight check encountered at least one host that is disconnected
// or not responding.
type VsanUpgradeSystemHostsDisconnectedIssue struct {
	VsanUpgradeSystemPreflightCheckIssue

	// Hosts this issue applies to.
	//
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts" json:"hosts"`
}

func init() {
	t["VsanUpgradeSystemHostsDisconnectedIssue"] = reflect.TypeOf((*VsanUpgradeSystemHostsDisconnectedIssue)(nil)).Elem()
}

// Pre-flight check encountered at least one host that is part of the
// VC cluster but not the VSAN cluster.
type VsanUpgradeSystemMissingHostsInClusterIssue struct {
	VsanUpgradeSystemPreflightCheckIssue

	// Hosts this issue applies to.
	//
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts" json:"hosts"`
}

func init() {
	t["VsanUpgradeSystemMissingHostsInClusterIssue"] = reflect.TypeOf((*VsanUpgradeSystemMissingHostsInClusterIssue)(nil)).Elem()
}

// Information about a particular group of hosts making up a network partition.
type VsanUpgradeSystemNetworkPartitionInfo struct {
	DynamicData

	// Hosts that make up the network partition
	//
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts" json:"hosts"`
}

func init() {
	t["VsanUpgradeSystemNetworkPartitionInfo"] = reflect.TypeOf((*VsanUpgradeSystemNetworkPartitionInfo)(nil)).Elem()
}

// Pre-flight check encountered a network partition.
//
// Contains details
// about the discovered network partition.
type VsanUpgradeSystemNetworkPartitionIssue struct {
	VsanUpgradeSystemPreflightCheckIssue

	// List of network partitions
	Partitions []VsanUpgradeSystemNetworkPartitionInfo `xml:"partitions" json:"partitions"`
}

func init() {
	t["VsanUpgradeSystemNetworkPartitionIssue"] = reflect.TypeOf((*VsanUpgradeSystemNetworkPartitionIssue)(nil)).Elem()
}

// Pre-flight check encountered not enough free disk capacity to maintain policy compliance.
type VsanUpgradeSystemNotEnoughFreeCapacityIssue struct {
	VsanUpgradeSystemPreflightCheckIssue

	// Indicates that whether upgrade could be processed if option
	// allowReducedRedundancy is taken.
	ReducedRedundancyUpgradePossible bool `xml:"reducedRedundancyUpgradePossible" json:"reducedRedundancyUpgradePossible"`
}

func init() {
	t["VsanUpgradeSystemNotEnoughFreeCapacityIssue"] = reflect.TypeOf((*VsanUpgradeSystemNotEnoughFreeCapacityIssue)(nil)).Elem()
}

// Base class for a pre-flight check issue.
//
// Can be used directly
// but usually a derived class with a specific issue type is used.
type VsanUpgradeSystemPreflightCheckIssue struct {
	DynamicData

	// Message describing the issue.
	Msg string `xml:"msg" json:"msg"`
}

func init() {
	t["VsanUpgradeSystemPreflightCheckIssue"] = reflect.TypeOf((*VsanUpgradeSystemPreflightCheckIssue)(nil)).Elem()
}

// Captures the result of a VSAN upgrade pre-flight check.
type VsanUpgradeSystemPreflightCheckResult struct {
	DynamicData

	// Detected issues.
	//
	// In some cases, not all possible issues are captured,
	// i.e. only the first (few) issues may be captured, and only once those
	// are resolved would additional issues be reported.
	// Absence of issues means the pre-flight check passed.
	Issues []BaseVsanUpgradeSystemPreflightCheckIssue `xml:"issues,omitempty,typeattr" json:"issues,omitempty"`
	// If the upgrade process was previously interrupted, it may have
	// removed VSAN from a disk group, but not added the disk group back
	// into VSAN.
	//
	// If such a situation is detected, this field will be set
	// and contains information about this disk group.
	DiskMappingToRestore *VsanHostDiskMapping `xml:"diskMappingToRestore,omitempty" json:"diskMappingToRestore,omitempty"`
}

func init() {
	t["VsanUpgradeSystemPreflightCheckResult"] = reflect.TypeOf((*VsanUpgradeSystemPreflightCheckResult)(nil)).Elem()
}

// Pre-flight check encountered at least one host that is part of the VSAN
// cluster but not the VC cluster.
type VsanUpgradeSystemRogueHostsInClusterIssue struct {
	VsanUpgradeSystemPreflightCheckIssue

	// Host UUIDs of rogue hosts.
	Uuids []string `xml:"uuids" json:"uuids"`
}

func init() {
	t["VsanUpgradeSystemRogueHostsInClusterIssue"] = reflect.TypeOf((*VsanUpgradeSystemRogueHostsInClusterIssue)(nil)).Elem()
}

// The upgrade process removed or added VSAN from/to a disk group.
//
// Class
// provides details about the operation and the disk group.
type VsanUpgradeSystemUpgradeHistoryDiskGroupOp struct {
	VsanUpgradeSystemUpgradeHistoryItem

	// Type of the operation, e.g.
	//
	// add or remove.
	//
	// See also `VsanUpgradeSystemUpgradeHistoryDiskGroupOpType_enum`.
	Operation string `xml:"operation" json:"operation"`
	// Disk group that is being added/removed
	DiskMapping VsanHostDiskMapping `xml:"diskMapping" json:"diskMapping"`
}

func init() {
	t["VsanUpgradeSystemUpgradeHistoryDiskGroupOp"] = reflect.TypeOf((*VsanUpgradeSystemUpgradeHistoryDiskGroupOp)(nil)).Elem()
}

// Captures one "log entry" of an upgrade process.
type VsanUpgradeSystemUpgradeHistoryItem struct {
	DynamicData

	// Time stamp when the history is record.
	Timestamp time.Time `xml:"timestamp" json:"timestamp"`
	// The host a history item pertains to.
	//
	// May be unset when item related
	// to no particular host.
	//
	// Refers instance of `HostSystem`.
	Host *ManagedObjectReference `xml:"host,omitempty" json:"host,omitempty"`
	// Description of the history item.
	Message string `xml:"message" json:"message"`
	// A task associated with the history item.
	//
	// May be unset if no task is
	// associated.
	//
	// Refers instance of `Task`.
	Task *ManagedObjectReference `xml:"task,omitempty" json:"task,omitempty"`
}

func init() {
	t["VsanUpgradeSystemUpgradeHistoryItem"] = reflect.TypeOf((*VsanUpgradeSystemUpgradeHistoryItem)(nil)).Elem()
}

// Upgrade process encountered a pre-flight check failure.
//
// This leads to
// the upgrade process aborting the upgrade.
type VsanUpgradeSystemUpgradeHistoryPreflightFail struct {
	VsanUpgradeSystemUpgradeHistoryItem

	// Details about the failed preflight check.
	PreflightResult VsanUpgradeSystemPreflightCheckResult `xml:"preflightResult" json:"preflightResult"`
}

func init() {
	t["VsanUpgradeSystemUpgradeHistoryPreflightFail"] = reflect.TypeOf((*VsanUpgradeSystemUpgradeHistoryPreflightFail)(nil)).Elem()
}

// Captures the status of a VSAN cluster on-disk format upgrade.
//
// Contains
// information about progress, result, and a detailed log of operations.
type VsanUpgradeSystemUpgradeStatus struct {
	DynamicData

	// True if there is an active upgrade process.
	//
	// If true, other fields
	// are guaranteed to be populated. If false, other fields may reflect
	// a previous upgrade process run, or they may be unset.
	InProgress bool `xml:"inProgress" json:"inProgress"`
	// Log of a single upgrade task.
	//
	// Lists all operations performed by the
	// upgrade process in chronological order.
	History []BaseVsanUpgradeSystemUpgradeHistoryItem `xml:"history,omitempty,typeattr" json:"history,omitempty"`
	// Set if the upgrade process was aborted.
	Aborted *bool `xml:"aborted" json:"aborted,omitempty"`
	// Set if the upgrade process has completed successfully.
	Completed *bool `xml:"completed" json:"completed,omitempty"`
	// Progress in percent.
	Progress int32 `xml:"progress,omitempty" json:"progress,omitempty"`
}

func init() {
	t["VsanUpgradeSystemUpgradeStatus"] = reflect.TypeOf((*VsanUpgradeSystemUpgradeStatus)(nil)).Elem()
}

// Pre-flight check encountered v2 objects preventing a downgrade.
type VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue struct {
	VsanUpgradeSystemPreflightCheckIssue

	// Object UUIDs of v2 objects.
	Uuids []string `xml:"uuids" json:"uuids"`
}

func init() {
	t["VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue"] = reflect.TypeOf((*VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue)(nil)).Elem()
}

// Pre-flight check encountered at least one host with wrong ESX version.
//
// Only 6.0 is allowed.
type VsanUpgradeSystemWrongEsxVersionIssue struct {
	VsanUpgradeSystemPreflightCheckIssue

	// Hosts this issue applies to.
	//
	// Refers instances of `HostSystem`.
	Hosts []ManagedObjectReference `xml:"hosts" json:"hosts"`
}

func init() {
	t["VsanUpgradeSystemWrongEsxVersionIssue"] = reflect.TypeOf((*VsanUpgradeSystemWrongEsxVersionIssue)(nil)).Elem()
}

// Specification of cloning a virtual storage object.
type VslmCloneSpec struct {
	VslmMigrateSpec

	// Descriptive name of the cloned virtual storage object.
	Name string `xml:"name" json:"name"`
	// Choice of the deletion behavior of this virtual storage object.
	//
	// If not set, the default value is false.
	KeepAfterDeleteVm *bool `xml:"keepAfterDeleteVm" json:"keepAfterDeleteVm,omitempty"`
	// The metadata KV pairs that are supposed to be updated on the destination
	// virtual storage object.
	//
	// The clone task is atomic by design. That being
	// said, failing to update the specified metadata pairs leads to the failure
	// of the clone task. If unset, no metadata will be updated. An empty string
	// value is indicative of a vcenter tag.
	Metadata []KeyValue `xml:"metadata,omitempty" json:"metadata,omitempty"`
}

func init() {
	t["VslmCloneSpec"] = reflect.TypeOf((*VslmCloneSpec)(nil)).Elem()
}

// Specification to create a virtual storage object.
type VslmCreateSpec struct {
	DynamicData

	// Descriptive name of this virtual storage object.
	Name string `xml:"name" json:"name"`
	// Choice of the deletion behavior of this virtual storage object.
	//
	// If not set, the default value is true.
	KeepAfterDeleteVm *bool `xml:"keepAfterDeleteVm" json:"keepAfterDeleteVm,omitempty"`
	// Specification of the backings of the virtual storage object.
	BackingSpec BaseVslmCreateSpecBackingSpec `xml:"backingSpec,typeattr" json:"backingSpec"`
	// Size in MB of the virtual storage object.
	CapacityInMB int64 `xml:"capacityInMB" json:"capacityInMB"`
	// Virtual storage object Profile requirement.
	//
	// If unset,
	// the default behavior will apply.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
	// Crypto operation of the disk.
	//
	// If unset and if `VslmCreateSpec.profile` contains an encryption iofilter,
	// then crypto will be of type CryptoSpecEncrypt, and filled with
	// keyId that is automatically generated and keyProviderId that is the
	// default kms cluster.
	Crypto BaseCryptoSpec `xml:"crypto,omitempty,typeattr" json:"crypto,omitempty"`
	// The metadata KV pairs that are supposed to be created on the newly created
	// virtual storage object.
	//
	// The create task is atomic by design. That being
	// said, failing to add the specified metadata pairs leads to the failure
	// of the create task. If unset, no metadata will be added. An empty string
	// value is indicative of a vcenter tag.
	Metadata []KeyValue `xml:"metadata,omitempty" json:"metadata,omitempty"`
}

func init() {
	t["VslmCreateSpec"] = reflect.TypeOf((*VslmCreateSpec)(nil)).Elem()
}

// Specification of the backing of a virtual
// storage object.
type VslmCreateSpecBackingSpec struct {
	DynamicData

	// The datastore managed object where this backing is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// Relative location in the specified datastore where disk needs to be
	// created.
	//
	// If not specified disk gets created at the defualt
	// VStorageObject location on the specified datastore.
	Path string `xml:"path,omitempty" json:"path,omitempty"`
}

func init() {
	t["VslmCreateSpecBackingSpec"] = reflect.TypeOf((*VslmCreateSpecBackingSpec)(nil)).Elem()
}

// Specification of the disk file backing of a virtual
// storage object.
type VslmCreateSpecDiskFileBackingSpec struct {
	VslmCreateSpecBackingSpec

	// Provisioning type.
	//
	// See also `BaseConfigInfoDiskFileBackingInfoProvisioningType_enum`
	//
	// If unset, system will first look up the provisioning type specified
	// in the policy. If still not found, the default
	// `thin`
	// will be used..
	ProvisioningType string `xml:"provisioningType,omitempty" json:"provisioningType,omitempty"`
}

func init() {
	t["VslmCreateSpecDiskFileBackingSpec"] = reflect.TypeOf((*VslmCreateSpecDiskFileBackingSpec)(nil)).Elem()
}

// Specification of the rdm backing of a virtual
// storage object.
type VslmCreateSpecRawDiskMappingBackingSpec struct {
	VslmCreateSpecBackingSpec

	// Unique identifier of the LUN accessed by the raw disk mapping.
	LunUuid string `xml:"lunUuid" json:"lunUuid"`
	// The compatibility mode of the raw disk mapping (RDM).
	//
	// This must be specified
	// when a new virtual disk with an RDM backing is created.
	//
	// See also `VirtualDiskCompatibilityMode_enum`.
	CompatibilityMode string `xml:"compatibilityMode" json:"compatibilityMode"`
}

func init() {
	t["VslmCreateSpecRawDiskMappingBackingSpec"] = reflect.TypeOf((*VslmCreateSpecRawDiskMappingBackingSpec)(nil)).Elem()
}

// Base specification of moving or copying a virtual storage object.
type VslmMigrateSpec struct {
	DynamicData

	// Specification of the backings of the target virtual storage object.
	BackingSpec BaseVslmCreateSpecBackingSpec `xml:"backingSpec,typeattr" json:"backingSpec"`
	// Virtual storage object Profile requirement.
	//
	// If unset,
	// the default behavior will apply.
	Profile []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
	// Flag indicates any delta disk backings will be consolidated
	// during migration.
	//
	// If unset, delta disk backings will not be
	// consolidated.
	Consolidate *bool `xml:"consolidate" json:"consolidate,omitempty"`
	// Disk chain crypto information.
	//
	// If unset and if `VslmMigrateSpec.profile` contains an encryption iofilter and if
	// source VStorageObject is unencrypted, then disksCyrpto will be of type
	// CryptoSpecEncrypt, and filled with keyId that is automatically generated
	// and keyProviderId that is the default kms cluster. During the migration,
	// the object will be encrypted.
	// If unset and if `VslmMigrateSpec.profile` is a default policy and if source
	// VStorageObject is unenrypted, then disksCrypto is treated as
	// CryptoSpecNoOp. During migration, no cryptographic change.
	// If unset and if `VslmMigrateSpec.profile` contains an encryption iofilter and if
	// source VStorageObject is encrypted, then disksCyrpto is treated as
	// CryptoSpecNoOp. During migration, no cryptographic change.
	// If unset and if `VslmMigrateSpec.profile` is a default policy and if
	// source VStorageObject is encrypted, then disksCyrpto is treated as
	// CryptoSpecDecrypt, during migration, the object will be decrypted.
	// To recrypt the disk during migration, disksCrypto has to be present.
	DisksCrypto *DiskCryptoSpec `xml:"disksCrypto,omitempty" json:"disksCrypto,omitempty"`
	// The service endpoint of vCenter where the FCD should be located.
	//
	// If
	// not specified the current vCenter service is used.
	Service *ServiceLocator `xml:"service,omitempty" json:"service,omitempty" vim:"8.0.3.0"`
}

func init() {
	t["VslmMigrateSpec"] = reflect.TypeOf((*VslmMigrateSpec)(nil)).Elem()
}

// Specification for relocating a virtual storage object.
type VslmRelocateSpec struct {
	VslmMigrateSpec
}

func init() {
	t["VslmRelocateSpec"] = reflect.TypeOf((*VslmRelocateSpec)(nil)).Elem()
}

// Specification of the Tag-Association tuple of Dataservice Tagging package.
//
// This class is a subset of the class dataservice.taggging.TaggingEntry.
type VslmTagEntry struct {
	DynamicData

	// Associated tag name of the Tag-Association tuple
	TagName string `xml:"tagName" json:"tagName"`
	// Associated parent category name of the Tag-Association tuple
	ParentCategoryName string `xml:"parentCategoryName" json:"parentCategoryName"`
}

func init() {
	t["VslmTagEntry"] = reflect.TypeOf((*VslmTagEntry)(nil)).Elem()
}

// Thrown if a dvPort is used as destination in multiple Distributed Port Mirroring sessions.
type VspanDestPortConflict struct {
	DvsFault

	// The key of the Distributed Port Mirroring session whose destination ports include a port
	// that is also used as destination ports of other Distributed Port Mirroring sessions
	VspanSessionKey1 string `xml:"vspanSessionKey1" json:"vspanSessionKey1"`
	// The key of the Distributed Port Mirroring session whose destination ports include a port
	// that is also used as destination ports of other Distributed Port Mirroring sessions
	VspanSessionKey2 string `xml:"vspanSessionKey2" json:"vspanSessionKey2"`
	// The key of the the port that is used as destination in multiple Distributed Port Mirroring sessions
	PortKey string `xml:"portKey" json:"portKey"`
}

func init() {
	t["VspanDestPortConflict"] = reflect.TypeOf((*VspanDestPortConflict)(nil)).Elem()
}

type VspanDestPortConflictFault VspanDestPortConflict

func init() {
	t["VspanDestPortConflictFault"] = reflect.TypeOf((*VspanDestPortConflictFault)(nil)).Elem()
}

// Thrown if a DistributedVirtualPort appears in both the transmitted source and destination
// ports of any Distributed Port Mirroring session.
type VspanPortConflict struct {
	DvsFault

	// The key of the Distributed Port Mirroring session that is in conflict
	VspanSessionKey1 string `xml:"vspanSessionKey1" json:"vspanSessionKey1"`
	// The key of the Distributed Port Mirroring session that is in conflict
	VspanSessionKey2 string `xml:"vspanSessionKey2" json:"vspanSessionKey2"`
	// The key of the port that is both the transmitted source and destination.
	PortKey string `xml:"portKey" json:"portKey"`
}

func init() {
	t["VspanPortConflict"] = reflect.TypeOf((*VspanPortConflict)(nil)).Elem()
}

type VspanPortConflictFault VspanPortConflict

func init() {
	t["VspanPortConflictFault"] = reflect.TypeOf((*VspanPortConflictFault)(nil)).Elem()
}

// Thrown when moving a port used as tranmistted source or destination ports in vspan
// session to a promiscuous portgroup if this operation may change
// the non-promiscuous port to promiscuous mode.
type VspanPortMoveFault struct {
	DvsFault

	// The key of the source portgroup.
	SrcPortgroupName string `xml:"srcPortgroupName" json:"srcPortgroupName"`
	// The key of the dest portgroup.
	DestPortgroupName string `xml:"destPortgroupName" json:"destPortgroupName"`
	// The key of the port.
	PortKey string `xml:"portKey" json:"portKey"`
}

func init() {
	t["VspanPortMoveFault"] = reflect.TypeOf((*VspanPortMoveFault)(nil)).Elem()
}

type VspanPortMoveFaultFault VspanPortMoveFault

func init() {
	t["VspanPortMoveFaultFault"] = reflect.TypeOf((*VspanPortMoveFaultFault)(nil)).Elem()
}

// Thrown when changing a non-promiscuous port used as tranmistted source or dest
// ports in Distributed Port Mirroring session to promiscuous mode.
type VspanPortPromiscChangeFault struct {
	DvsFault

	// The key of the port.
	PortKey string `xml:"portKey" json:"portKey"`
}

func init() {
	t["VspanPortPromiscChangeFault"] = reflect.TypeOf((*VspanPortPromiscChangeFault)(nil)).Elem()
}

type VspanPortPromiscChangeFaultFault VspanPortPromiscChangeFault

func init() {
	t["VspanPortPromiscChangeFaultFault"] = reflect.TypeOf((*VspanPortPromiscChangeFaultFault)(nil)).Elem()
}

// Thrown when changing a non-promiscous portgroup to promiscuous mode if any port
// in this portgroup is used as tranmistted source or dest ports in vspan
// session.
type VspanPortgroupPromiscChangeFault struct {
	DvsFault

	// The key of the port.
	PortgroupName string `xml:"portgroupName" json:"portgroupName"`
}

func init() {
	t["VspanPortgroupPromiscChangeFault"] = reflect.TypeOf((*VspanPortgroupPromiscChangeFault)(nil)).Elem()
}

type VspanPortgroupPromiscChangeFaultFault VspanPortgroupPromiscChangeFault

func init() {
	t["VspanPortgroupPromiscChangeFaultFault"] = reflect.TypeOf((*VspanPortgroupPromiscChangeFaultFault)(nil)).Elem()
}

// Thrown when changing a portgroup from static/dynamic binding to
// ephemeral(no binding) if any ports in this portgroup participate in
// Distributed Port Mirroring session.
type VspanPortgroupTypeChangeFault struct {
	DvsFault

	// The name of the portgroup.
	PortgroupName string `xml:"portgroupName" json:"portgroupName"`
}

func init() {
	t["VspanPortgroupTypeChangeFault"] = reflect.TypeOf((*VspanPortgroupTypeChangeFault)(nil)).Elem()
}

type VspanPortgroupTypeChangeFaultFault VspanPortgroupTypeChangeFault

func init() {
	t["VspanPortgroupTypeChangeFaultFault"] = reflect.TypeOf((*VspanPortgroupTypeChangeFaultFault)(nil)).Elem()
}

// Thrown if a promiscuous port appears in transmitted source or destination
// ports of any Distributed Port Mirroring session.
type VspanPromiscuousPortNotSupported struct {
	DvsFault

	// The key of the Distributed Port Mirroring session in which a promiscuous port is used as
	// transmitted source or destination ports.
	VspanSessionKey string `xml:"vspanSessionKey" json:"vspanSessionKey"`
	// The key of the promiscuous port that appears in transmitted
	// source or destination ports.
	PortKey string `xml:"portKey" json:"portKey"`
}

func init() {
	t["VspanPromiscuousPortNotSupported"] = reflect.TypeOf((*VspanPromiscuousPortNotSupported)(nil)).Elem()
}

type VspanPromiscuousPortNotSupportedFault VspanPromiscuousPortNotSupported

func init() {
	t["VspanPromiscuousPortNotSupportedFault"] = reflect.TypeOf((*VspanPromiscuousPortNotSupportedFault)(nil)).Elem()
}

// Thrown if a dvPort appears in both the source and destination
// ports of the same Distributed Port Mirroring session.
type VspanSameSessionPortConflict struct {
	DvsFault

	// The key of the Distributed Port Mirroring session in which a dvPort appears in both the source and destination ports
	VspanSessionKey string `xml:"vspanSessionKey" json:"vspanSessionKey"`
	// The key of the port that appears in both the source and
	// destination ports of the same Distributed Port Mirroring session.
	PortKey string `xml:"portKey" json:"portKey"`
}

func init() {
	t["VspanSameSessionPortConflict"] = reflect.TypeOf((*VspanSameSessionPortConflict)(nil)).Elem()
}

type VspanSameSessionPortConflictFault VspanSameSessionPortConflict

func init() {
	t["VspanSameSessionPortConflictFault"] = reflect.TypeOf((*VspanSameSessionPortConflictFault)(nil)).Elem()
}

type VstorageObjectVCenterQueryChangedDiskAreas VstorageObjectVCenterQueryChangedDiskAreasRequestType

func init() {
	t["VstorageObjectVCenterQueryChangedDiskAreas"] = reflect.TypeOf((*VstorageObjectVCenterQueryChangedDiskAreas)(nil)).Elem()
}

// The parameters of `VcenterVStorageObjectManager.VstorageObjectVCenterQueryChangedDiskAreas`.
type VstorageObjectVCenterQueryChangedDiskAreasRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The ID of the virtual storage object.
	Id ID `xml:"id" json:"id"`
	// The datastore where the source virtual storage object
	// is located.
	//
	// Refers instance of `Datastore`.
	Datastore ManagedObjectReference `xml:"datastore" json:"datastore"`
	// The ID of the snapshot of a virtual storage object for
	// which changes that have been made since "changeId"
	// should be computed.
	SnapshotId ID `xml:"snapshotId" json:"snapshotId"`
	// Start Offset in bytes at which to start computing
	// changes. Typically, callers will make multiple calls
	// to this function, starting with startOffset 0 and then
	// examine the "length" property in the returned
	// DiskChangeInfo structure, repeatedly calling
	// queryChangedDiskAreas until a map for the entire
	// virtual disk has been obtained.
	StartOffset int64 `xml:"startOffset" json:"startOffset"`
	// Identifier referring to a point in the past that should
	// be used as the point in time at which to begin including
	// changes to the disk in the result. A typical use case
	// would be a backup application obtaining a changeId from
	// a virtual disk's backing info when performing a backup.
	// When a subsequent incremental backup is to be performed,
	// this change Id can be used to obtain a list of changed
	// areas on disk.
	ChangeId string `xml:"changeId" json:"changeId"`
}

func init() {
	t["VstorageObjectVCenterQueryChangedDiskAreasRequestType"] = reflect.TypeOf((*VstorageObjectVCenterQueryChangedDiskAreasRequestType)(nil)).Elem()
}

type VstorageObjectVCenterQueryChangedDiskAreasResponse struct {
	Returnval DiskChangeInfo `xml:"returnval" json:"returnval"`
}

// Detailed information about a VirtualVolume datastore.
type VvolDatastoreInfo struct {
	DatastoreInfo

	VvolDS *HostVvolVolume `xml:"vvolDS,omitempty" json:"vvolDS,omitempty"`
}

func init() {
	t["VvolDatastoreInfo"] = reflect.TypeOf((*VvolDatastoreInfo)(nil)).Elem()
}

type WaitForUpdates WaitForUpdatesRequestType

func init() {
	t["WaitForUpdates"] = reflect.TypeOf((*WaitForUpdates)(nil)).Elem()
}

type WaitForUpdatesEx WaitForUpdatesExRequestType

func init() {
	t["WaitForUpdatesEx"] = reflect.TypeOf((*WaitForUpdatesEx)(nil)).Elem()
}

// The parameters of `PropertyCollector.WaitForUpdatesEx`.
type WaitForUpdatesExRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The data version currently known to the client. The value must be
	// either
	//   - the special initial data version (an empty string),
	//   - a data version returned from `PropertyCollector.CheckForUpdates` or `PropertyCollector.WaitForUpdates`
	//   - a non-truncated data version returned from `PropertyCollector.WaitForUpdatesEx`
	//   - a truncated data version returned from the last call to `PropertyCollector.WaitForUpdatesEx` with no intervening calls to `PropertyCollector.WaitForUpdates` or `PropertyCollector.CheckForUpdates`.
	Version string `xml:"version,omitempty" json:"version,omitempty"`
	// Additional options controlling the change calculation. If omitted,
	// equivalent to an options argument with no fields set.
	Options *WaitOptions `xml:"options,omitempty" json:"options,omitempty"`
}

func init() {
	t["WaitForUpdatesExRequestType"] = reflect.TypeOf((*WaitForUpdatesExRequestType)(nil)).Elem()
}

type WaitForUpdatesExResponse struct {
	Returnval *UpdateSet `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

// The parameters of `PropertyCollector.WaitForUpdates`.
type WaitForUpdatesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The data version currently known to the client. The value
	// must be either
	//   - the special initial version (an empty string)
	//   - a data version returned from `PropertyCollector.CheckForUpdates` or `PropertyCollector.WaitForUpdates` by the same `PropertyCollector` on the same session
	//   - a non-truncated data version returned from `PropertyCollector.WaitForUpdatesEx` by the same `PropertyCollector` on the same
	//     session.
	Version string `xml:"version,omitempty" json:"version,omitempty"`
}

func init() {
	t["WaitForUpdatesRequestType"] = reflect.TypeOf((*WaitForUpdatesRequestType)(nil)).Elem()
}

type WaitForUpdatesResponse struct {
	Returnval UpdateSet `xml:"returnval" json:"returnval"`
}

// Options for `PropertyCollector.WaitForUpdatesEx`.
type WaitOptions struct {
	DynamicData

	// The number of seconds the `PropertyCollector` should wait
	// before returning null.
	//
	// Returning updates may take longer if the
	// actual calculation time exceeds `WaitOptions.maxWaitSeconds`. Additionally `PropertyCollector` policy may
	// cause it to return null sooner than `WaitOptions.maxWaitSeconds`.
	//
	// An unset value causes `PropertyCollector.WaitForUpdatesEx` to wait as
	// long as possible for updates. Policy may still cause the
	// `PropertyCollector` to return null at some point.
	//
	// A value of 0 causes `PropertyCollector.WaitForUpdatesEx` to do one update
	// calculation and return any results. This behavior is similar to `PropertyCollector.CheckForUpdates`.
	//
	// A positive value causes `PropertyCollector.WaitForUpdatesEx` to return
	// null if no updates are available within the specified number of
	// seconds. The choice of a positive value often depends on the
	// client communication stack. For example it may be helpful to
	// choose a duration shorter than a local HTTP request timeout.
	// Typically it should be no shorter than a few minutes.
	//
	// A negative value is illegal.
	MaxWaitSeconds *int32 `xml:"maxWaitSeconds" json:"maxWaitSeconds,omitempty"`
	// The maximum number of `ObjectUpdate`
	// entries that should be returned in a single result from `PropertyCollector.WaitForUpdatesEx`.
	//
	// See `UpdateSet.truncated`
	//
	// An unset value indicates that there is no maximum. In this case
	// `PropertyCollector` policy may still limit the number of objects
	// that appear in an `UpdateSet`.
	//
	// A positive value causes `PropertyCollector.WaitForUpdatesEx` to suspend
	// the update calculation when the total count of `ObjectUpdate` entries ready to return reaches
	// the specified maximum. `PropertyCollector` policy may still
	// limit the total count to something less than `WaitOptions.maxObjectUpdates`.
	//
	// A value less than or equal to 0 is illegal.
	MaxObjectUpdates int32 `xml:"maxObjectUpdates,omitempty" json:"maxObjectUpdates,omitempty"`
}

func init() {
	t["WaitOptions"] = reflect.TypeOf((*WaitOptions)(nil)).Elem()
}

// The virtual machine and at least one of its virtual NICs are configured to
// use Wake-on-LAN, but the host does not support Wake-on-LAN for the
// virtual machine's selected guest OS.
type WakeOnLanNotSupported struct {
	VirtualHardwareCompatibilityIssue
}

func init() {
	t["WakeOnLanNotSupported"] = reflect.TypeOf((*WakeOnLanNotSupported)(nil)).Elem()
}

// This fault is thrown when Wake-on-LAN isn't supported by the Vmotion NIC on the host.
type WakeOnLanNotSupportedByVmotionNIC struct {
	HostPowerOpFailed
}

func init() {
	t["WakeOnLanNotSupportedByVmotionNIC"] = reflect.TypeOf((*WakeOnLanNotSupportedByVmotionNIC)(nil)).Elem()
}

type WakeOnLanNotSupportedByVmotionNICFault WakeOnLanNotSupportedByVmotionNIC

func init() {
	t["WakeOnLanNotSupportedByVmotionNICFault"] = reflect.TypeOf((*WakeOnLanNotSupportedByVmotionNICFault)(nil)).Elem()
}

type WakeOnLanNotSupportedFault WakeOnLanNotSupported

func init() {
	t["WakeOnLanNotSupportedFault"] = reflect.TypeOf((*WakeOnLanNotSupportedFault)(nil)).Elem()
}

// This event is a general warning event from upgrade.
type WarningUpgradeEvent struct {
	UpgradeEvent
}

func init() {
	t["WarningUpgradeEvent"] = reflect.TypeOf((*WarningUpgradeEvent)(nil)).Elem()
}

// The `WeeklyTaskScheduler` data object sets the time for weekly
// task execution.
//
// You can set the schedule for task execution
// on one or more days during the week, and you complete the schedule
// by setting the inherited properties for the hour and minute.
//
// By default the scheduler executes the task according to the
// specified day(s) every week.
// If you set the interval to a value greater than 1, the task will
// execute at the specified weekly interval. (For example, an interval
// of 2 will cause the task to execute on the specified days every 2 weeks.)
type WeeklyTaskScheduler struct {
	DailyTaskScheduler

	// The day or days of the week when the scheduled task will run.
	//
	// At least one of the days must be true.
	Sunday    bool `xml:"sunday" json:"sunday"`
	Monday    bool `xml:"monday" json:"monday"`
	Tuesday   bool `xml:"tuesday" json:"tuesday"`
	Wednesday bool `xml:"wednesday" json:"wednesday"`
	Thursday  bool `xml:"thursday" json:"thursday"`
	Friday    bool `xml:"friday" json:"friday"`
	Saturday  bool `xml:"saturday" json:"saturday"`
}

func init() {
	t["WeeklyTaskScheduler"] = reflect.TypeOf((*WeeklyTaskScheduler)(nil)).Elem()
}

// This fault is reported when the execution of a storage vmotion or
// relocate operation would impact vSphere HA's ability to
// restart a VM.
//
// For storage vmotion, this fault
// is reported when HA protection will be lost after the vmotion
// completes. Consequently, HA would not restart the VM if it
// subsequently failed. For relocate, relocate is not supported on
// VMs that failed before the operation is attempted and are in the
// process of being restarted at the time the operation is performed.
type WillLoseHAProtection struct {
	MigrationFault

	// The steps the user can take to restore protection if the
	// the operation is performed.
	//
	// Values come from
	// `WillLoseHAProtectionResolution_enum`.
	Resolution string `xml:"resolution" json:"resolution"`
}

func init() {
	t["WillLoseHAProtection"] = reflect.TypeOf((*WillLoseHAProtection)(nil)).Elem()
}

type WillLoseHAProtectionFault WillLoseHAProtection

func init() {
	t["WillLoseHAProtectionFault"] = reflect.TypeOf((*WillLoseHAProtectionFault)(nil)).Elem()
}

// A virtual machine's total CPU feature requirements are determined by
// overlaying the requirements specified in its configuration (if any) on top
// of the requirements specified in the descriptor for its guest OS.
//
// It is
// therefore possible for a host change to implicitly change a virtual
// machine's CPU feature requirements. The guest OS descriptor may have
// different requirements on the new host. Or, if the virtual machine
// currently specifies requirements in its configuration, those requirements
// will be lost if the new host does not support this.
//
// This fault indicates that the virtual machine's CPU feature requirements
// would change because of a migration, and also that the destination host
// does support storing CPU feature requirements in the virtual machine's
// configuration. (If the destination host does not support such an action,
// `CannotModifyConfigCpuRequirements` is used instead of this fault.)
//
// This is a warning to notify the user that the migration process will
// adjust the virtual machine's configuration so that it will be operating
// under an unchanged set of CPU feature requirements on its new host. If the
// user wishes to expose the different guest OS requirements of the new host,
// the user will need to edit the virtual machine's configuration after the
// migration.
type WillModifyConfigCpuRequirements struct {
	MigrationFault
}

func init() {
	t["WillModifyConfigCpuRequirements"] = reflect.TypeOf((*WillModifyConfigCpuRequirements)(nil)).Elem()
}

type WillModifyConfigCpuRequirementsFault WillModifyConfigCpuRequirements

func init() {
	t["WillModifyConfigCpuRequirementsFault"] = reflect.TypeOf((*WillModifyConfigCpuRequirementsFault)(nil)).Elem()
}

// This fault is reported when the execution of a storage vmotion or
// relocate operation would reset the snapshotDirectory settings
// to its default value (VM's home/config directory).
type WillResetSnapshotDirectory struct {
	MigrationFault
}

func init() {
	t["WillResetSnapshotDirectory"] = reflect.TypeOf((*WillResetSnapshotDirectory)(nil)).Elem()
}

type WillResetSnapshotDirectoryFault WillResetSnapshotDirectory

func init() {
	t["WillResetSnapshotDirectoryFault"] = reflect.TypeOf((*WillResetSnapshotDirectoryFault)(nil)).Elem()
}

// This data object type describes the Windows-specific
// NetBIOS configuration.
type WinNetBIOSConfigInfo struct {
	NetBIOSConfigInfo

	// The IP address of the primary WINS server.
	PrimaryWINS string `xml:"primaryWINS" json:"primaryWINS"`
	// The IP address of the secondary WINS server.
	SecondaryWINS string `xml:"secondaryWINS,omitempty" json:"secondaryWINS,omitempty"`
}

func init() {
	t["WinNetBIOSConfigInfo"] = reflect.TypeOf((*WinNetBIOSConfigInfo)(nil)).Elem()
}

// This exception is thrown when VirtualMachine.wipeDisk
// encounters an error
type WipeDiskFault struct {
	VimFault
}

func init() {
	t["WipeDiskFault"] = reflect.TypeOf((*WipeDiskFault)(nil)).Elem()
}

type WipeDiskFaultFault WipeDiskFault

func init() {
	t["WipeDiskFaultFault"] = reflect.TypeOf((*WipeDiskFaultFault)(nil)).Elem()
}

// The WitnessNodeInfo class defines configuration
// information for the Witness node in the cluster
type WitnessNodeInfo struct {
	DynamicData

	// VCHA Cluster network configuration of the Witness node.
	IpSettings CustomizationIPSettings `xml:"ipSettings" json:"ipSettings"`
	// BIOS UUID for the node.
	//
	// It is set only if the VCHA Cluster was
	// formed using automatic provisioning by the deploy API.
	BiosUuid string `xml:"biosUuid,omitempty" json:"biosUuid,omitempty"`
}

func init() {
	t["WitnessNodeInfo"] = reflect.TypeOf((*WitnessNodeInfo)(nil)).Elem()
}

type XmlToCustomizationSpecItem XmlToCustomizationSpecItemRequestType

func init() {
	t["XmlToCustomizationSpecItem"] = reflect.TypeOf((*XmlToCustomizationSpecItem)(nil)).Elem()
}

// The parameters of `CustomizationSpecManager.XmlToCustomizationSpecItem`.
type XmlToCustomizationSpecItemRequestType struct {
	This        ManagedObjectReference `xml:"_this" json:"-"`
	SpecItemXml string                 `xml:"specItemXml" json:"specItemXml"`
}

func init() {
	t["XmlToCustomizationSpecItemRequestType"] = reflect.TypeOf((*XmlToCustomizationSpecItemRequestType)(nil)).Elem()
}

type XmlToCustomizationSpecItemResponse struct {
	Returnval CustomizationSpecItem `xml:"returnval" json:"returnval"`
}

// The parameters of `VirtualDiskManager.ZeroFillVirtualDisk_Task`.
type ZeroFillVirtualDiskRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	// The name of the disk, either a datastore path or a URL
	// referring to the virtual disk whose blocks should be overwritten
	// with zeroes.
	Name string `xml:"name" json:"name"`
	// If <code>name</code> is a datastore path, the datacenter for
	// that datastore path. Not needed when invoked directly on ESX.
	// If not specified on a call to VirtualCenter,
	// <code>name</code> must be a URL.
	//
	// Refers instance of `Datacenter`.
	Datacenter *ManagedObjectReference `xml:"datacenter,omitempty" json:"datacenter,omitempty"`
}

func init() {
	t["ZeroFillVirtualDiskRequestType"] = reflect.TypeOf((*ZeroFillVirtualDiskRequestType)(nil)).Elem()
}

type ZeroFillVirtualDisk_Task ZeroFillVirtualDiskRequestType

func init() {
	t["ZeroFillVirtualDisk_Task"] = reflect.TypeOf((*ZeroFillVirtualDisk_Task)(nil)).Elem()
}

type ZeroFillVirtualDisk_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type ConfigureVchaRequestType struct {
	This       ManagedObjectReference `xml:"_this" json:"-"`
	ConfigSpec VchaClusterConfigSpec  `xml:"configSpec" json:"configSpec"`
}

func init() {
	t["configureVchaRequestType"] = reflect.TypeOf((*ConfigureVchaRequestType)(nil)).Elem()
}

type ConfigureVcha_Task ConfigureVchaRequestType

func init() {
	t["configureVcha_Task"] = reflect.TypeOf((*ConfigureVcha_Task)(nil)).Elem()
}

type ConfigureVcha_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreatePassiveNodeRequestType struct {
	This                  ManagedObjectReference    `xml:"_this" json:"-"`
	PassiveDeploymentSpec PassiveNodeDeploymentSpec `xml:"passiveDeploymentSpec" json:"passiveDeploymentSpec"`
	SourceVcSpec          SourceNodeSpec            `xml:"sourceVcSpec" json:"sourceVcSpec"`
}

func init() {
	t["createPassiveNodeRequestType"] = reflect.TypeOf((*CreatePassiveNodeRequestType)(nil)).Elem()
}

type CreatePassiveNode_Task CreatePassiveNodeRequestType

func init() {
	t["createPassiveNode_Task"] = reflect.TypeOf((*CreatePassiveNode_Task)(nil)).Elem()
}

type CreatePassiveNode_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type CreateWitnessNodeRequestType struct {
	This                  ManagedObjectReference `xml:"_this" json:"-"`
	WitnessDeploymentSpec BaseNodeDeploymentSpec `xml:"witnessDeploymentSpec,typeattr" json:"witnessDeploymentSpec"`
	SourceVcSpec          SourceNodeSpec         `xml:"sourceVcSpec" json:"sourceVcSpec"`
}

func init() {
	t["createWitnessNodeRequestType"] = reflect.TypeOf((*CreateWitnessNodeRequestType)(nil)).Elem()
}

type CreateWitnessNode_Task CreateWitnessNodeRequestType

func init() {
	t["createWitnessNode_Task"] = reflect.TypeOf((*CreateWitnessNode_Task)(nil)).Elem()
}

type CreateWitnessNode_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type DeployVchaRequestType struct {
	This           ManagedObjectReference    `xml:"_this" json:"-"`
	DeploymentSpec VchaClusterDeploymentSpec `xml:"deploymentSpec" json:"deploymentSpec"`
}

func init() {
	t["deployVchaRequestType"] = reflect.TypeOf((*DeployVchaRequestType)(nil)).Elem()
}

type DeployVcha_Task DeployVchaRequestType

func init() {
	t["deployVcha_Task"] = reflect.TypeOf((*DeployVcha_Task)(nil)).Elem()
}

type DeployVcha_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type DestroyVchaRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["destroyVchaRequestType"] = reflect.TypeOf((*DestroyVchaRequestType)(nil)).Elem()
}

type DestroyVcha_Task DestroyVchaRequestType

func init() {
	t["destroyVcha_Task"] = reflect.TypeOf((*DestroyVcha_Task)(nil)).Elem()
}

type DestroyVcha_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type FetchSoftwarePackages FetchSoftwarePackagesRequestType

func init() {
	t["fetchSoftwarePackages"] = reflect.TypeOf((*FetchSoftwarePackages)(nil)).Elem()
}

type FetchSoftwarePackagesRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["fetchSoftwarePackagesRequestType"] = reflect.TypeOf((*FetchSoftwarePackagesRequestType)(nil)).Elem()
}

type FetchSoftwarePackagesResponse struct {
	Returnval []SoftwarePackage `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type GetClusterMode GetClusterModeRequestType

func init() {
	t["getClusterMode"] = reflect.TypeOf((*GetClusterMode)(nil)).Elem()
}

type GetClusterModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["getClusterModeRequestType"] = reflect.TypeOf((*GetClusterModeRequestType)(nil)).Elem()
}

type GetClusterModeResponse struct {
	Returnval string `xml:"returnval" json:"returnval"`
}

type GetVchaConfig GetVchaConfigRequestType

func init() {
	t["getVchaConfig"] = reflect.TypeOf((*GetVchaConfig)(nil)).Elem()
}

type GetVchaConfigRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["getVchaConfigRequestType"] = reflect.TypeOf((*GetVchaConfigRequestType)(nil)).Elem()
}

type GetVchaConfigResponse struct {
	Returnval VchaClusterConfigInfo `xml:"returnval" json:"returnval"`
}

type InitiateFailoverRequestType struct {
	This    ManagedObjectReference `xml:"_this" json:"-"`
	Planned bool                   `xml:"planned" json:"planned"`
}

func init() {
	t["initiateFailoverRequestType"] = reflect.TypeOf((*InitiateFailoverRequestType)(nil)).Elem()
}

type InitiateFailover_Task InitiateFailoverRequestType

func init() {
	t["initiateFailover_Task"] = reflect.TypeOf((*InitiateFailover_Task)(nil)).Elem()
}

type InitiateFailover_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type InstallDate InstallDateRequestType

func init() {
	t["installDate"] = reflect.TypeOf((*InstallDate)(nil)).Elem()
}

type InstallDateRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["installDateRequestType"] = reflect.TypeOf((*InstallDateRequestType)(nil)).Elem()
}

type InstallDateResponse struct {
	Returnval time.Time `xml:"returnval" json:"returnval"`
}

type PrepareVchaRequestType struct {
	This        ManagedObjectReference `xml:"_this" json:"-"`
	NetworkSpec VchaClusterNetworkSpec `xml:"networkSpec" json:"networkSpec"`
}

func init() {
	t["prepareVchaRequestType"] = reflect.TypeOf((*PrepareVchaRequestType)(nil)).Elem()
}

type PrepareVcha_Task PrepareVchaRequestType

func init() {
	t["prepareVcha_Task"] = reflect.TypeOf((*PrepareVcha_Task)(nil)).Elem()
}

type PrepareVcha_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type QueryDatacenterConfigOptionDescriptor QueryDatacenterConfigOptionDescriptorRequestType

func init() {
	t["queryDatacenterConfigOptionDescriptor"] = reflect.TypeOf((*QueryDatacenterConfigOptionDescriptor)(nil)).Elem()
}

type QueryDatacenterConfigOptionDescriptorRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["queryDatacenterConfigOptionDescriptorRequestType"] = reflect.TypeOf((*QueryDatacenterConfigOptionDescriptorRequestType)(nil)).Elem()
}

type QueryDatacenterConfigOptionDescriptorResponse struct {
	Returnval []VirtualMachineConfigOptionDescriptor `xml:"returnval,omitempty" json:"returnval,omitempty"`
}

type ReloadVirtualMachineFromPathRequestType struct {
	This              ManagedObjectReference `xml:"_this" json:"-"`
	ConfigurationPath string                 `xml:"configurationPath" json:"configurationPath"`
}

func init() {
	t["reloadVirtualMachineFromPathRequestType"] = reflect.TypeOf((*ReloadVirtualMachineFromPathRequestType)(nil)).Elem()
}

type ReloadVirtualMachineFromPath_Task ReloadVirtualMachineFromPathRequestType

func init() {
	t["reloadVirtualMachineFromPath_Task"] = reflect.TypeOf((*ReloadVirtualMachineFromPath_Task)(nil)).Elem()
}

type ReloadVirtualMachineFromPath_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type SetClusterModeRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
	Mode string                 `xml:"mode" json:"mode"`
}

func init() {
	t["setClusterModeRequestType"] = reflect.TypeOf((*SetClusterModeRequestType)(nil)).Elem()
}

type SetClusterMode_Task SetClusterModeRequestType

func init() {
	t["setClusterMode_Task"] = reflect.TypeOf((*SetClusterMode_Task)(nil)).Elem()
}

type SetClusterMode_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type SetCustomValue SetCustomValueRequestType

func init() {
	t["setCustomValue"] = reflect.TypeOf((*SetCustomValue)(nil)).Elem()
}

type SetCustomValueRequestType struct {
	This  ManagedObjectReference `xml:"_this" json:"-"`
	Key   string                 `xml:"key" json:"key"`
	Value string                 `xml:"value" json:"value"`
}

func init() {
	t["setCustomValueRequestType"] = reflect.TypeOf((*SetCustomValueRequestType)(nil)).Elem()
}

type SetCustomValueResponse struct {
}

type StartDpuFailover StartDpuFailoverRequestType

func init() {
	t["startDpuFailover"] = reflect.TypeOf((*StartDpuFailover)(nil)).Elem()
}

type StartDpuFailoverRequestType struct {
	This           ManagedObjectReference `xml:"_this" json:"-"`
	DvsName        string                 `xml:"dvsName" json:"dvsName"`
	TargetDpuAlias string                 `xml:"targetDpuAlias,omitempty" json:"targetDpuAlias,omitempty"`
}

func init() {
	t["startDpuFailoverRequestType"] = reflect.TypeOf((*StartDpuFailoverRequestType)(nil)).Elem()
}

type StartDpuFailoverResponse struct {
}

type UnregisterVAppRequestType struct {
	This ManagedObjectReference `xml:"_this" json:"-"`
}

func init() {
	t["unregisterVAppRequestType"] = reflect.TypeOf((*UnregisterVAppRequestType)(nil)).Elem()
}

type UnregisterVApp_Task UnregisterVAppRequestType

func init() {
	t["unregisterVApp_Task"] = reflect.TypeOf((*UnregisterVApp_Task)(nil)).Elem()
}

type UnregisterVApp_TaskResponse struct {
	Returnval ManagedObjectReference `xml:"returnval" json:"returnval"`
}

type VersionURI string

func init() {
	t["versionURI"] = reflect.TypeOf((*VersionURI)(nil)).Elem()
}

type VslmInfrastructureObjectPolicy struct {
	DynamicData

	Name            string                `xml:"name" json:"name"`
	BackingObjectId string                `xml:"backingObjectId" json:"backingObjectId"`
	ProfileId       string                `xml:"profileId" json:"profileId"`
	Error           *LocalizedMethodFault `xml:"error,omitempty" json:"error,omitempty"`
}

func init() {
	t["vslmInfrastructureObjectPolicy"] = reflect.TypeOf((*VslmInfrastructureObjectPolicy)(nil)).Elem()
}

type VslmInfrastructureObjectPolicySpec struct {
	DynamicData

	Datastore ManagedObjectReference          `xml:"datastore" json:"datastore"`
	Profile   []BaseVirtualMachineProfileSpec `xml:"profile,omitempty,typeattr" json:"profile,omitempty"`
}

func init() {
	t["vslmInfrastructureObjectPolicySpec"] = reflect.TypeOf((*VslmInfrastructureObjectPolicySpec)(nil)).Elem()
}

type VslmVClockInfo struct {
	DynamicData

	VClockTime int64 `xml:"vClockTime" json:"vClockTime"`
}

func init() {
	t["vslmVClockInfo"] = reflect.TypeOf((*VslmVClockInfo)(nil)).Elem()
}
