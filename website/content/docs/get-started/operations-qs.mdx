---
layout: docs
page_title: Operations quick start
description: >-
  Bring Vault up in developer mode with a basic configuration file
  then store and retrieve a key/value secret.
---

# Operations quick start

Start Vault in developer mode to authenticate entities, store and retrieve
your first key/value secret.

<Warning>

Running Vault in-memory with `dev` mode is insecure but useful for
practicing locally. **Do not use `dev` mode in production**.

For help managing a production Vault installation, refer to the
[Production hardening tutorial](/vault/tutorials/operations/production-hardening).

</Warning>

For a complete Vault learning experience, refer to the [Vault foundations tutorials](/vault/tutorials/get-started).

## Before you start

- **You must have [Vault installed](/vault/install) locally**.

## Start Vault


1. Start the Vault server in development mode.

   ```shell-session
   $ vault server -dev -dev-root-token-id="dev-only-token"
   ```

   The `-dev-root-token-id` flag for dev servers defines the initial root token.
   The root token allows full access to any entity that presents the token (in this
   case "dev-only-token").

   <Warning>

   [Root tokens](/vault/docs/concepts/tokens#root-tokens) grant full
   access to all data and functionality in your Vault server. Do not share
   your root token. For production deployments, we recommend creating
   individual administrator tokens  with explicit privileges.

   </Warning>

   Vault is now listening over HTTP on port `8200`.

1. Open a new terminal and export environment variables to interact with the
   Vault server.

   ```shell-session
   $ export VAULT_ADDR='http://127.0.0.1:8200'
   ```

1. Log into the Vault server using the root token.

   ```shell-session
   $ vault login dev-only-token
   ```

   You are now authenticated to Vault with the root token.

## Enable auth methods

Vault supports multiple [authentication methods](/vault/docs/auth). Authentication
plugins control access to Vault for humans and machine based workloads. 
The `userpass` plugin uses basic authentication with usernames and passwords.

1. Use `vault auth enable` to enable the `userpass` authentication method for human clients:

   ```shell-session
   $ vault auth enable userpass
   ```

   The `userpass` auth method is enabled.

1. To authenticate users with Vault, you must create a user and password.

   ```shell-session
   $ vault write auth/userpass/users/opsuser \
       password=p@ssw0rd
   ```


1. (Optional) Enable the `approle` auth method. This is a general purpose plugin that
   allows machines or apps to authenticate to Vault.

   ```shell-session
   $ vault auth enable approle
   ```


1. (Optional) To authenticate workloads with Vault, you must create a role.

   ```shell-session
   $ vault write auth/approle/role/my-app-role \
       secret_id_ttl=10m \
       token_ttl=20m \
       token_max_ttl=30m
   ```

   The `my-app-role` role has a secret ID TTL of 10 minutes, a token TTL
   of 20 minutes, and a token max TTL of 30 minutes.

## Enable secrets engines

Vault supports multiple [secrets engine plugins](/vault/docs/secrets).
You can use secret engine plugins to manage critical information like
static secrets, dynamic secrets, and PKI certificates.

Enable the `kv` secrets engine. This engine stores arbitrary secrets.

```shell-session
$ vault secrets enable -version=2 kv
```


## Store a secret



<Tip>

The `kv` plugin is a core Vault plugin and has dedicated commands in the Vault CLI. Most plugins use the `vault read` and `vault write` commands.

</Tip>

Use the `kv put` command to store the demo user credentials in the `kv` plugin as the secrets `username` and `password`:

```shell-session
$ vault kv put kv/creds username=opsuser password=p@ssw0rd
```

The `kv put` command writes the secret to the `kv` secrets engine. In this example, two
secrets are written: The `username` key with a value of `opsuser` and the key
`password` with a value of `p@ssw0rd`.

## Protect secrets

In the previous step, you wrote a password to the `kv` secrets engine using the
root token. The use of the root token, and root policy, is not recommended for production environments.

You can use Vault policies to control and limit access to plugin data and
the operations allowed on plugin data.

1. Write a policy that permits access to the `kv` secrets engine.

   ```shell-session
   $ vault policy write kv-access-policy - << EOF
   path "kv/creds" {
      capabilities = ["read", "create", "update", "delete"]
   }
   EOF
   ```


1. Attach the policy to the `opsuser` user.

   ```shell-session
   $ vault write auth/userpass/users/opsuser \
       policies=kv-access-policy
   ```


## Authenticate to Vault

Use `vault login` to authenticate to Vault using the `opsuser` user. When prompted, enter the
password `p@ssw0rd`:

```shell-session
$ vault login -method=userpass username=opsuser
```

You are now authenticated to Vault with the `opsuser` and the `kv-access-policy` access policy instead of the root token.



Try retrieving the secrets stored on the `kv/creds` path:

```shell-session
$ vault kv get kv/creds
```

Now try retrieving the secrets stored on the `kv/api-keys` path:

```shell-session
$ vault kv get kv/api-keys
```

The second command fails because the policy for `opsuser` does
not grant access to the `/api-keys` path.

You have successfully stored and retrieved your first secret value with a user
from the `userpass` auth method.