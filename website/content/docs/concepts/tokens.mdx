---
layout: docs
page_title: Tokens
description: Tokens are a core auth method in Vault. Concepts and important features.
---

# Tokens

<Warning heading="Internal token structure is volatile">
  Tokens are opaque values, so their structure is undocumented and subject to change.
  Scripts and automation that rely on a token's internal structure will break.
</Warning>

Tokens are the core method for authentication within Vault. You can use tokens
directly, or you can use [auth methods](/vault/docs/concepts/auth)
to dynamically generate tokens based on external identities.

The `vault server -dev` script (or `vault operator init` for a non-dev server) outputs an
initial root token. The root token is the first method of authentication for Vault.
It is also the only auth method that you cannot disable.

As stated in the [authentication concepts](/vault/docs/concepts/auth),
all external authentication mechanisms, such as GitHub, map down to dynamically
created tokens. These dynamically created tokens have all the same properties as a normal manually
created token.

Within Vault, tokens map to information. The most important information that is mapped
to a token is a set of one or more attached
[policies](/vault/docs/concepts/policies). These policies control what the token
holder is allowed to do within Vault. Other mapped information includes
metadata such as creation time, last renewal time, and more. Vault adds the metadata to the audit log.

Refer to the
[tokens tutorial](/vault/tutorials/get-started/introduction-tokens)
for details on how these concepts work in practice.

## Token types

There are three types of tokens. This page explains `service` tokens and `batch` tokens,
while `recovery` tokens are discussed separately in the [Recovery mode](/vault/docs/concepts/recovery-mode#recovery-tokens) documentation.
The features described in the following
sections apply to service tokens, their applicability to batch tokens is discussed
later.
A section near the bottom of this page contains detailed information about their differences,
but it is useful to understand other token concepts first.

### Token prefixes

Tokens have a specific prefix that indicates their type. In Vault 1.10, HashiCorp updated this token
format. The following table lists the differences between the prefixes. These format
patterns also apply to recovery tokens. Vault appends a string of
24 or more randomly-generated characters after the prefix.

| Token type      | Vault 1.9.x or earlier | Vault 1.10 and later |
|-----------------|------------------------|----------------------|
| Service tokens  | `s.<random>`           | `hvs.<random>`       |
| Batch tokens    | `b.<random>`           | `hvb.<random>`       |
| Recovery tokens | `r.<random>`           | `hvr.<random>`       |

For example, a service token may look like `hvs.CvmS4c0DPTvHv5eJgXWMJg9r`.

## The token store

The token store is another name for the [`token` authentication
backend](/vault/docs/auth/token). It is responsible for creating and storing tokens, and cannot
be disabled. It is also the only auth method that has no login
capability -- all actions require existing authenticated tokens.

## Root tokens

Root tokens are tokens that have the `root` policy attached to them. Root
tokens can do anything in Vault. In addition, they are the only
type of token within Vault that you can set to never expire without a required renewal. For security reasons,there are only three ways to create root tokens:

1. The initial root token generated at `vault operator init` time -- this token has no
   expiration
1. By using another root token; a root token with an expiration cannot create a
   root token that never expires
1. By using `vault operator generate-root` ([example](/vault/tutorials/operations/generate-root))
   with the permission of a quorum of unseal key holders

Root tokens are useful in development, but you should be extremely careful if you use them
in production. The Vault team recommends that you only use root tokens for the initial setup, specifically setting up the auth methods
and policies necessary to allow administrators to acquire more limited tokens.
You can also use them in emergencies, and immediately revoke them after they are no longer needed.
If a new root token is needed, you can use the `operator generate-root` command and associated
[API endpoint](/vault/api-docs/system/generate-root) to generate one on-the-fly.

It is also a good security practice to have multiple people responsible for watching a terminal
whenever a root token is live. This way, multiple people can verify any
tasks performed with the root token, and confirm the token was revoked immediately
after these tasks were completed.

## Token hierarchies and orphan tokens

Normally, when a token holder creates new tokens, they create the tokens
as children of the original token. Any tokens those tokens create will be their children,
and so on. When you revoke a parent token, Vault revokes all of its child tokens, and all
of their leases, as well. Revoking child tokens ensures that a user cannot escape
revocation by simply generating a never-ending tree of child tokens.

Often this behavior is not desired, so users with the appropriate access can create
`orphan` tokens. These `orphan` tokens have no parent, they are the root of their own
token tree. You can create `orphan` tokens:

1. Via `write` access to the `auth/token/create-orphan` endpoint
1. By having `sudo` or `root` access to the `auth/token/create`
   and setting the `no_parent` parameter to `true`
1. Via token store roles
1. By logging in with any other (non-`token`) auth method

If you have the appropriate permissions, you can also use the `auth/token/revoke-orphan`
endpoint, which revokes the given token. But rather than revoke the rest of the
tree, it instead sets the tokens' immediate children to be orphans. Use the `auth/toke/revoke-orphan` endpoint with caution.

## Token accessors

When you create tokens, Vault also creates and returns a token accessor. The
accessor is a value that acts as a reference to a token and can only
perform the following limited actions:

1. Look up a token's properties, not including the actual token ID
1. Look up a token's capabilities on a path
1. Renew the token
1. Revoke the token

The token making the call, not the token associated with the accessor, must
have appropriate permissions for these functions.

Token accessors enable many useful workflows. As an example, a
service that creates tokens on behalf of another service, such as the
[Nomad](https://www.nomadproject.io/) scheduler. can store the accessor
correlated with a particular job ID. When the job is complete, you can use the accessor
to instantly revoke the job's token and all of its leased
credentials, limiting the chance that a bad actor will discover and use them.

You can optionally set audit devices to not obfuscate token accessors in audit
logs, providing a way for you to quickly revoke tokens in case of an emergency.
However, it also means that a bad actor could use the audit logs to perform a larger-scale
denial of service attack.

Finally, the only way to list tokens is using the `auth/token/accessors`
command, which gives a list of token accessors. You should use this endpoint with caution since listing all of the accessors means that someone could use them
to revoke all tokens. However, it also provides a way to audit and revoke the
currently-active set of tokens.

## Token Time-To-Live, periodic tokens, and explicit max TTLs

Every non-root token has a time-to-live (TTL) associated with it, which is a
current period of validity since either the token's creation time or last
renewal time, whichever is more recent. Root tokens may have an associated TTL,
but the TTL may also be 0, indicating a token that never expires. After the
current TTL is up, the token no longer functions. Vault revokes it and any associated
leases.

If the token is renewable, you can extend the token validity
period using `vault token renew` or the appropriate renewal endpoint. At this
time, various factors come into play. What happens depends upon whether the
token is a periodic token (available for creation by `root`/`sudo` users, token
store roles, or some auth methods), has an explicit maximum TTL
attached, or neither.

### The general case

In the general case, where there is neither a period nor explicit maximum TTL
value set on the token, Vault compares the token's lifetime since it was created
to the maximum TTL. Vault generates the maximum TTL value dynamically
and it can change from renewal to renewal. So you cannot view the value when you
look up a token's information. The value is based on a combination of factors:

1. The system max TTL, which is 32 days by default, but you can change it in Vault's
   configuration file.
1. The max TTL set on a mount using [mount
   tuning](/vault/api-docs/system/mounts). This value
   is allowed to override the system max TTL -- it can be longer or shorter,
   and if set this value will be respected.
1. A value suggested by the auth method that issued the token. This
   might be configured on a per-role, per-group, or per-user basis. This value
   is allowed to be less than the mount max TTL (or, if not set, the system max
   TTL), but it is not allowed to be longer.

Note that the values in (2) and (3) may change at any given time, which is why
a final determination about the current allowed max TTL is made at renewal time
using the current values. It is also why it is important to always ensure that
the TTL returned from a renewal operation is within an allowed range; if this
value is not extending, likely the TTL of the token cannot be extended past its
current value and the client may want to reauthenticate and acquire a new
token. However, outside of direct operator interaction, Vault will never revoke
a token before the returned TTL has expired.

### Explicit max TTLs

Tokens can have an explicit max TTL set on them. This value becomes a hard
limit on the token's lifetime -- no matter what the values in (1), (2), and (3)
from the general case are, the token cannot live past this explicitly-set
value. This has an effect even when using periodic tokens to escape the normal
TTL mechanism.

### Periodic tokens

In some cases, having a token be revoked would be problematic -- for instance,
if a long-running service needs to maintain its SQL connection pool over a long
period of time. In this scenario, a periodic token can be used. Periodic tokens
can be created in a few ways:

1. By having `sudo` capability or a `root` token with the `auth/token/create`
   endpoint
1. By using token store roles
1. By using an auth method that supports issuing these, such as
   AppRole

At issue time, the TTL of a periodic token will be equal to the configured
period. At every renewal time, the TTL will be reset back to this configured
period, and as long as the token is successfully renewed within each of these
periods of time, it will never expire. Outside of `root` tokens, it is
currently the only way for a token in Vault to have an unlimited lifetime.

The idea behind periodic tokens is that it is easy for systems and services to
perform an action relatively frequently -- for instance, every two hours, or
even every five minutes. Therefore, as long as a system is actively renewing
this token -- in other words, as long as the system is alive -- the system is
allowed to keep using the token and any associated leases. However, if the
system stops renewing within this period (for instance, if it was shut down),
the token will expire relatively quickly. It is good practice to keep this
period as short as possible, and generally speaking it is not useful for humans
to be given periodic tokens.

There are a few important things to know when using periodic tokens:

- When a periodic token is created via a token store role, the _current_ value
  of the role's period setting will be used at renewal time
- A token with both a period and an explicit max TTL will act like a periodic
  token but will be revoked when the explicit max TTL is reached

## CIDR-Bound tokens

Some tokens are able to be bound to CIDR(s) that restrict the range of client
IPs allowed to use them. These affect all tokens except for non-expiring root
tokens (those with a TTL of zero). If a root token has an expiration, it also
is affected by CIDR-binding.

## Token types in detail

There are currently two types of tokens.

### Service tokens

Service tokens are what users will generally think of as "normal" Vault tokens.
They support all features, such as renewal, revocation, creating child tokens,
and more. They are correspondingly heavyweight to create and track.

### Batch tokens

Batch tokens are encrypted blobs that carry enough information for them to
be used for Vault actions, but they require no storage on disk to track them.
As a result they are extremely lightweight and scalable, but lack most of the
flexibility and features of service tokens.

### Token type comparison

This reference chart describes the difference in behavior between service and
batch tokens.

|                                                     |                                          Service Tokens |                                    Batch Tokens |
| --------------------------------------------------- | ------------------------------------------------------: | ----------------------------------------------: |
| Can Be Root Tokens                                  |                                                     Yes |                                              No |
| Can Create Child Tokens                             |                                                     Yes |                                              No |
| Can be Renewable                                    |                                                     Yes |                                              No |
| Manually Revocable                                  |                                                     Yes |                                              No |
| Can be Periodic                                     |                                                     Yes |                                              No |
| Can have Explicit Max TTL                           |                                                     Yes |                    No (always uses a fixed TTL) |
| Has Accessors                                       |                                                     Yes |                                              No |
| Has Cubbyhole                                       |                                                     Yes |                                              No |
| Revoked with Parent (if not orphan)                 |                                                     Yes |                                   Stops Working |
| Dynamic Secrets Lease Assignment                    |                                                    Self |                          Parent (if not orphan) |
| Can be Used Across Performance Replication Clusters |                                                      No |                                 Yes (if orphan) |
| Creation Scales with Performance Standby Node Count |                                                      No |                                             Yes |
| Cost                                                | Heavyweight; multiple storage writes per token creation | Lightweight; no storage cost for token creation |

### Service vs. batch token lease handling

#### Service tokens

Leases created by service tokens (including child tokens' leases) are tracked
along with the service token and revoked when the token expires.

#### Batch tokens

Leases created by batch tokens are constrained to the remaining TTL of the
batch tokens and, if the batch token is not an orphan, are tracked by the
parent. They are revoked when the batch token's TTL expires, or when the batch
token's parent is revoked (at which point the batch token is also denied access
to Vault).

As a corollary, batch tokens can be used across performance replication
clusters, but only if they are orphan, since non-orphan tokens will not be able
to ensure the validity of the parent token.

## Error Responses

When using a token that has been revoked, exceeded its TTL, or is an otherwise invalid value, Vault will respond
with a `403` response code error containing the following error messages: `invalid token` and `permission denied`.

When using a token with incorrect policy access, Vault will respond with a `403` response code error containing the error message
`permission denied`.
